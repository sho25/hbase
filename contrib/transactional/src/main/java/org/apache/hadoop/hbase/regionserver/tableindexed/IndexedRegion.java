begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2009 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|tableindexed
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Leases
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Delete
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Get
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|HTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Put
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|tableindexed
operator|.
name|IndexSpecification
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|tableindexed
operator|.
name|IndexedTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|FlushRequester
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|transactional
operator|.
name|TransactionalRegion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|wal
operator|.
name|HLog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_class
class|class
name|IndexedRegion
extends|extends
name|TransactionalRegion
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|IndexedRegion
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
specifier|private
specifier|final
name|IndexedTableDescriptor
name|indexTableDescriptor
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|IndexSpecification
argument_list|,
name|HTable
argument_list|>
name|indexSpecToTable
init|=
operator|new
name|HashMap
argument_list|<
name|IndexSpecification
argument_list|,
name|HTable
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
name|IndexedRegion
parameter_list|(
specifier|final
name|Path
name|basedir
parameter_list|,
specifier|final
name|HLog
name|log
parameter_list|,
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|,
specifier|final
name|FlushRequester
name|flushListener
parameter_list|,
name|Leases
name|trxLeases
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|basedir
argument_list|,
name|log
argument_list|,
name|fs
argument_list|,
name|conf
argument_list|,
name|regionInfo
argument_list|,
name|flushListener
argument_list|,
name|trxLeases
argument_list|)
expr_stmt|;
name|this
operator|.
name|indexTableDescriptor
operator|=
operator|new
name|IndexedTableDescriptor
argument_list|(
name|regionInfo
operator|.
name|getTableDesc
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
block|}
specifier|private
specifier|synchronized
name|HTable
name|getIndexTable
parameter_list|(
name|IndexSpecification
name|index
parameter_list|)
throws|throws
name|IOException
block|{
name|HTable
name|indexTable
init|=
name|indexSpecToTable
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexTable
operator|==
literal|null
condition|)
block|{
name|indexTable
operator|=
operator|new
name|HTable
argument_list|(
name|conf
argument_list|,
name|index
operator|.
name|getIndexedTableName
argument_list|(
name|super
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getTableDesc
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|indexSpecToTable
operator|.
name|put
argument_list|(
name|index
argument_list|,
name|indexTable
argument_list|)
expr_stmt|;
block|}
return|return
name|indexTable
return|;
block|}
specifier|private
name|Collection
argument_list|<
name|IndexSpecification
argument_list|>
name|getIndexes
parameter_list|()
block|{
return|return
name|indexTableDescriptor
operator|.
name|getIndexes
argument_list|()
return|;
block|}
comment|/**    * @param batchUpdate    * @param lockid    * @param writeToWAL if true, then we write this update to the log    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|void
name|put
parameter_list|(
name|Put
name|put
parameter_list|,
name|Integer
name|lockId
parameter_list|,
name|boolean
name|writeToWAL
parameter_list|)
throws|throws
name|IOException
block|{
name|updateIndexes
argument_list|(
name|put
argument_list|,
name|lockId
argument_list|)
expr_stmt|;
comment|// Do this first because will want to see the old row
name|super
operator|.
name|put
argument_list|(
name|put
argument_list|,
name|lockId
argument_list|,
name|writeToWAL
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|updateIndexes
parameter_list|(
name|Put
name|put
parameter_list|,
name|Integer
name|lockId
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|IndexSpecification
argument_list|>
name|indexesToUpdate
init|=
operator|new
name|LinkedList
argument_list|<
name|IndexSpecification
argument_list|>
argument_list|()
decl_stmt|;
comment|// Find the indexes we need to update
for|for
control|(
name|IndexSpecification
name|index
range|:
name|getIndexes
argument_list|()
control|)
block|{
if|if
condition|(
name|possiblyAppliesToIndex
argument_list|(
name|index
argument_list|,
name|put
argument_list|)
condition|)
block|{
name|indexesToUpdate
operator|.
name|add
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|indexesToUpdate
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|NavigableSet
argument_list|<
name|byte
index|[]
argument_list|>
name|neededColumns
init|=
name|getColumnsForIndexes
argument_list|(
name|indexesToUpdate
argument_list|)
decl_stmt|;
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|newColumnValues
init|=
name|getColumnsFromPut
argument_list|(
name|put
argument_list|)
decl_stmt|;
name|Get
name|oldGet
init|=
operator|new
name|Get
argument_list|(
name|put
operator|.
name|getRow
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|neededCol
range|:
name|neededColumns
control|)
block|{
name|byte
index|[]
index|[]
name|famQf
init|=
name|KeyValue
operator|.
name|parseColumn
argument_list|(
name|neededCol
argument_list|)
decl_stmt|;
if|if
condition|(
name|famQf
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|oldGet
operator|.
name|addFamily
argument_list|(
name|famQf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oldGet
operator|.
name|addColumn
argument_list|(
name|famQf
index|[
literal|0
index|]
argument_list|,
name|famQf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|Result
name|oldResult
init|=
name|super
operator|.
name|get
argument_list|(
name|oldGet
argument_list|,
name|lockId
argument_list|)
decl_stmt|;
comment|// Add the old values to the new if they are not there
if|if
condition|(
name|oldResult
operator|!=
literal|null
operator|&&
name|oldResult
operator|.
name|raw
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|KeyValue
name|oldKV
range|:
name|oldResult
operator|.
name|raw
argument_list|()
control|)
block|{
name|byte
index|[]
name|column
init|=
name|KeyValue
operator|.
name|makeColumn
argument_list|(
name|oldKV
operator|.
name|getFamily
argument_list|()
argument_list|,
name|oldKV
operator|.
name|getQualifier
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|newColumnValues
operator|.
name|containsKey
argument_list|(
name|column
argument_list|)
condition|)
block|{
name|newColumnValues
operator|.
name|put
argument_list|(
name|column
argument_list|,
name|oldKV
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Iterator
argument_list|<
name|IndexSpecification
argument_list|>
name|indexIterator
init|=
name|indexesToUpdate
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|indexIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|IndexSpecification
name|indexSpec
init|=
name|indexIterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|IndexMaintenanceUtils
operator|.
name|doesApplyToIndex
argument_list|(
name|indexSpec
argument_list|,
name|newColumnValues
argument_list|)
condition|)
block|{
name|indexIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
name|SortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|oldColumnValues
init|=
name|convertToValueMap
argument_list|(
name|oldResult
argument_list|)
decl_stmt|;
for|for
control|(
name|IndexSpecification
name|indexSpec
range|:
name|indexesToUpdate
control|)
block|{
name|updateIndex
argument_list|(
name|indexSpec
argument_list|,
name|put
argument_list|,
name|newColumnValues
argument_list|,
name|oldColumnValues
argument_list|)
expr_stmt|;
block|}
block|}
comment|// FIXME: This call takes place in an RPC, and requires an RPC. This makes for
comment|// a likely deadlock if the number of RPCs we are trying to serve is>= the
comment|// number of handler threads.
specifier|private
name|void
name|updateIndex
parameter_list|(
name|IndexSpecification
name|indexSpec
parameter_list|,
name|Put
name|put
parameter_list|,
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|newColumnValues
parameter_list|,
name|SortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|oldColumnValues
parameter_list|)
throws|throws
name|IOException
block|{
name|Delete
name|indexDelete
init|=
name|makeDeleteToRemoveOldIndexEntry
argument_list|(
name|indexSpec
argument_list|,
name|put
operator|.
name|getRow
argument_list|()
argument_list|,
name|oldColumnValues
argument_list|)
decl_stmt|;
name|Put
name|indexPut
init|=
name|makeIndexUpdate
argument_list|(
name|indexSpec
argument_list|,
name|put
operator|.
name|getRow
argument_list|()
argument_list|,
name|newColumnValues
argument_list|)
decl_stmt|;
name|HTable
name|indexTable
init|=
name|getIndexTable
argument_list|(
name|indexSpec
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexDelete
operator|!=
literal|null
operator|&&
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|indexDelete
operator|.
name|getRow
argument_list|()
argument_list|,
name|indexPut
operator|.
name|getRow
argument_list|()
argument_list|)
condition|)
block|{
comment|// Only do the delete if the row changed. This way we save the put after delete issues in HBASE-2256
name|LOG
operator|.
name|debug
argument_list|(
literal|"Deleting old index row ["
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|indexDelete
operator|.
name|getRow
argument_list|()
argument_list|)
operator|+
literal|"]. New row is ["
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|indexPut
operator|.
name|getRow
argument_list|()
argument_list|)
operator|+
literal|"]."
argument_list|)
expr_stmt|;
name|indexTable
operator|.
name|delete
argument_list|(
name|indexDelete
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|indexDelete
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping deleting index row ["
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|indexDelete
operator|.
name|getRow
argument_list|()
argument_list|)
operator|+
literal|"] because it has not changed."
argument_list|)
expr_stmt|;
block|}
name|indexTable
operator|.
name|put
argument_list|(
name|indexPut
argument_list|)
expr_stmt|;
block|}
comment|/** Return the columns needed for the update. */
specifier|private
name|NavigableSet
argument_list|<
name|byte
index|[]
argument_list|>
name|getColumnsForIndexes
parameter_list|(
name|Collection
argument_list|<
name|IndexSpecification
argument_list|>
name|indexes
parameter_list|)
block|{
name|NavigableSet
argument_list|<
name|byte
index|[]
argument_list|>
name|neededColumns
init|=
operator|new
name|TreeSet
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
for|for
control|(
name|IndexSpecification
name|indexSpec
range|:
name|indexes
control|)
block|{
for|for
control|(
name|byte
index|[]
name|col
range|:
name|indexSpec
operator|.
name|getAllColumns
argument_list|()
control|)
block|{
name|neededColumns
operator|.
name|add
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|neededColumns
return|;
block|}
specifier|private
name|Delete
name|makeDeleteToRemoveOldIndexEntry
parameter_list|(
name|IndexSpecification
name|indexSpec
parameter_list|,
name|byte
index|[]
name|row
parameter_list|,
name|SortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|oldColumnValues
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|byte
index|[]
name|indexedCol
range|:
name|indexSpec
operator|.
name|getIndexedColumns
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|oldColumnValues
operator|.
name|containsKey
argument_list|(
name|indexedCol
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Index ["
operator|+
name|indexSpec
operator|.
name|getIndexId
argument_list|()
operator|+
literal|"] not trying to remove old entry for row ["
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|row
argument_list|)
operator|+
literal|"] because col ["
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|indexedCol
argument_list|)
operator|+
literal|"] is missing"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
name|byte
index|[]
name|oldIndexRow
init|=
name|indexSpec
operator|.
name|getKeyGenerator
argument_list|()
operator|.
name|createIndexKey
argument_list|(
name|row
argument_list|,
name|oldColumnValues
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Index ["
operator|+
name|indexSpec
operator|.
name|getIndexId
argument_list|()
operator|+
literal|"] removing old entry ["
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|oldIndexRow
argument_list|)
operator|+
literal|"]"
argument_list|)
expr_stmt|;
return|return
operator|new
name|Delete
argument_list|(
name|oldIndexRow
argument_list|)
return|;
block|}
specifier|private
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|getColumnsFromPut
parameter_list|(
name|Put
name|put
parameter_list|)
block|{
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|columnValues
init|=
operator|new
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|KeyValue
argument_list|>
name|familyPuts
range|:
name|put
operator|.
name|getFamilyMap
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|KeyValue
name|kv
range|:
name|familyPuts
control|)
block|{
name|byte
index|[]
name|column
init|=
name|KeyValue
operator|.
name|makeColumn
argument_list|(
name|kv
operator|.
name|getFamily
argument_list|()
argument_list|,
name|kv
operator|.
name|getQualifier
argument_list|()
argument_list|)
decl_stmt|;
name|columnValues
operator|.
name|put
argument_list|(
name|column
argument_list|,
name|kv
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|columnValues
return|;
block|}
comment|/** Ask if this put *could* apply to the index. It may actually apply if some of the columns needed are missing.    *     * @param indexSpec    * @param put    * @return true if possibly apply.    */
specifier|private
name|boolean
name|possiblyAppliesToIndex
parameter_list|(
name|IndexSpecification
name|indexSpec
parameter_list|,
name|Put
name|put
parameter_list|)
block|{
for|for
control|(
name|List
argument_list|<
name|KeyValue
argument_list|>
name|familyPuts
range|:
name|put
operator|.
name|getFamilyMap
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|KeyValue
name|kv
range|:
name|familyPuts
control|)
block|{
name|byte
index|[]
name|column
init|=
name|KeyValue
operator|.
name|makeColumn
argument_list|(
name|kv
operator|.
name|getFamily
argument_list|()
argument_list|,
name|kv
operator|.
name|getQualifier
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexSpec
operator|.
name|containsColumn
argument_list|(
name|column
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|Put
name|makeIndexUpdate
parameter_list|(
name|IndexSpecification
name|indexSpec
parameter_list|,
name|byte
index|[]
name|row
parameter_list|,
name|SortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|columnValues
parameter_list|)
throws|throws
name|IOException
block|{
name|Put
name|indexUpdate
init|=
name|IndexMaintenanceUtils
operator|.
name|createIndexUpdate
argument_list|(
name|indexSpec
argument_list|,
name|row
argument_list|,
name|columnValues
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Index ["
operator|+
name|indexSpec
operator|.
name|getIndexId
argument_list|()
operator|+
literal|"] adding new entry ["
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|indexUpdate
operator|.
name|getRow
argument_list|()
argument_list|)
operator|+
literal|"] for row ["
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|row
argument_list|)
operator|+
literal|"]"
argument_list|)
expr_stmt|;
return|return
name|indexUpdate
return|;
block|}
comment|// FIXME we can be smarter about this and avoid the base gets and index maintenance in many cases.
annotation|@
name|Override
specifier|public
name|void
name|delete
parameter_list|(
name|Delete
name|delete
parameter_list|,
specifier|final
name|Integer
name|lockid
parameter_list|,
name|boolean
name|writeToWAL
parameter_list|)
throws|throws
name|IOException
block|{
comment|// First look at the current (to be the old) state.
name|SortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|oldColumnValues
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|getIndexes
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Need all columns
name|NavigableSet
argument_list|<
name|byte
index|[]
argument_list|>
name|neededColumns
init|=
name|getColumnsForIndexes
argument_list|(
name|getIndexes
argument_list|()
argument_list|)
decl_stmt|;
name|Get
name|get
init|=
operator|new
name|Get
argument_list|(
name|delete
operator|.
name|getRow
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|col
range|:
name|neededColumns
control|)
block|{
name|byte
index|[]
index|[]
name|famQf
init|=
name|KeyValue
operator|.
name|parseColumn
argument_list|(
name|col
argument_list|)
decl_stmt|;
if|if
condition|(
name|famQf
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|get
operator|.
name|addFamily
argument_list|(
name|famQf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|get
operator|.
name|addColumn
argument_list|(
name|famQf
index|[
literal|0
index|]
argument_list|,
name|famQf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|Result
name|oldRow
init|=
name|super
operator|.
name|get
argument_list|(
name|get
argument_list|,
name|lockid
argument_list|)
decl_stmt|;
name|oldColumnValues
operator|=
name|convertToValueMap
argument_list|(
name|oldRow
argument_list|)
expr_stmt|;
block|}
name|super
operator|.
name|delete
argument_list|(
name|delete
argument_list|,
name|lockid
argument_list|,
name|writeToWAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getIndexes
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Get
name|get
init|=
operator|new
name|Get
argument_list|(
name|delete
operator|.
name|getRow
argument_list|()
argument_list|)
decl_stmt|;
comment|// Rebuild index if there is still a version visible.
name|Result
name|currentRow
init|=
name|super
operator|.
name|get
argument_list|(
name|get
argument_list|,
name|lockid
argument_list|)
decl_stmt|;
name|SortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|currentColumnValues
init|=
name|convertToValueMap
argument_list|(
name|currentRow
argument_list|)
decl_stmt|;
for|for
control|(
name|IndexSpecification
name|indexSpec
range|:
name|getIndexes
argument_list|()
control|)
block|{
name|Delete
name|indexDelete
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|IndexMaintenanceUtils
operator|.
name|doesApplyToIndex
argument_list|(
name|indexSpec
argument_list|,
name|oldColumnValues
argument_list|)
condition|)
block|{
name|indexDelete
operator|=
name|makeDeleteToRemoveOldIndexEntry
argument_list|(
name|indexSpec
argument_list|,
name|delete
operator|.
name|getRow
argument_list|()
argument_list|,
name|oldColumnValues
argument_list|)
expr_stmt|;
block|}
name|Put
name|indexPut
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|IndexMaintenanceUtils
operator|.
name|doesApplyToIndex
argument_list|(
name|indexSpec
argument_list|,
name|currentColumnValues
argument_list|)
condition|)
block|{
name|indexPut
operator|=
name|makeIndexUpdate
argument_list|(
name|indexSpec
argument_list|,
name|delete
operator|.
name|getRow
argument_list|()
argument_list|,
name|currentColumnValues
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indexPut
operator|==
literal|null
operator|&&
name|indexDelete
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|HTable
name|indexTable
init|=
name|getIndexTable
argument_list|(
name|indexSpec
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexDelete
operator|!=
literal|null
operator|&&
operator|(
name|indexPut
operator|==
literal|null
operator|||
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|indexDelete
operator|.
name|getRow
argument_list|()
argument_list|,
name|indexPut
operator|.
name|getRow
argument_list|()
argument_list|)
operator|)
condition|)
block|{
comment|// Only do the delete if the row changed. This way we save the put
comment|// after delete issues in HBASE-2256
name|LOG
operator|.
name|debug
argument_list|(
literal|"Deleting old index row ["
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|indexDelete
operator|.
name|getRow
argument_list|()
argument_list|)
operator|+
literal|"]."
argument_list|)
expr_stmt|;
name|indexTable
operator|.
name|delete
argument_list|(
name|indexDelete
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|indexDelete
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping deleting index row ["
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|indexDelete
operator|.
name|getRow
argument_list|()
argument_list|)
operator|+
literal|"] because it has not changed."
argument_list|)
expr_stmt|;
for|for
control|(
name|byte
index|[]
name|indexCol
range|:
name|indexSpec
operator|.
name|getAdditionalColumns
argument_list|()
control|)
block|{
name|byte
index|[]
index|[]
name|parsed
init|=
name|KeyValue
operator|.
name|parseColumn
argument_list|(
name|indexCol
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|KeyValue
argument_list|>
name|famDeletes
init|=
name|delete
operator|.
name|getFamilyMap
argument_list|()
operator|.
name|get
argument_list|(
name|parsed
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|famDeletes
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|KeyValue
name|kv
range|:
name|famDeletes
control|)
block|{
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|parsed
index|[
literal|0
index|]
argument_list|,
name|kv
operator|.
name|getFamily
argument_list|()
argument_list|)
operator|&&
name|Bytes
operator|.
name|equals
argument_list|(
name|parsed
index|[
literal|1
index|]
argument_list|,
name|kv
operator|.
name|getQualifier
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Need to delete this specific column: "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|indexCol
argument_list|)
argument_list|)
expr_stmt|;
name|Delete
name|columnDelete
init|=
operator|new
name|Delete
argument_list|(
name|indexDelete
operator|.
name|getRow
argument_list|()
argument_list|)
decl_stmt|;
name|columnDelete
operator|.
name|deleteColumns
argument_list|(
name|parsed
index|[
literal|0
index|]
argument_list|,
name|parsed
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|indexTable
operator|.
name|delete
argument_list|(
name|columnDelete
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|indexPut
operator|!=
literal|null
condition|)
block|{
name|getIndexTable
argument_list|(
name|indexSpec
argument_list|)
operator|.
name|put
argument_list|(
name|indexPut
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
name|SortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|convertToValueMap
parameter_list|(
name|Result
name|result
parameter_list|)
block|{
name|SortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|currentColumnValues
init|=
operator|new
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
operator|||
name|result
operator|.
name|raw
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
name|currentColumnValues
return|;
block|}
name|List
argument_list|<
name|KeyValue
argument_list|>
name|list
init|=
name|result
operator|.
name|list
argument_list|()
decl_stmt|;
if|if
condition|(
name|list
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|KeyValue
name|kv
range|:
name|result
operator|.
name|list
argument_list|()
control|)
block|{
name|byte
index|[]
name|column
init|=
name|KeyValue
operator|.
name|makeColumn
argument_list|(
name|kv
operator|.
name|getFamily
argument_list|()
argument_list|,
name|kv
operator|.
name|getQualifier
argument_list|()
argument_list|)
decl_stmt|;
name|currentColumnValues
operator|.
name|put
argument_list|(
name|column
argument_list|,
name|kv
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|currentColumnValues
return|;
block|}
block|}
end_class

end_unit

