begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|// Protocol Buffers - Google's data interchange format
end_comment

begin_comment
comment|// Copyright 2008 Google Inc.  All rights reserved.
end_comment

begin_comment
comment|// https://developers.google.com/protocol-buffers/
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Redistribution and use in source and binary forms, with or without
end_comment

begin_comment
comment|// modification, are permitted provided that the following conditions are
end_comment

begin_comment
comment|// met:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//     * Redistributions of source code must retain the above copyright
end_comment

begin_comment
comment|// notice, this list of conditions and the following disclaimer.
end_comment

begin_comment
comment|//     * Redistributions in binary form must reproduce the above
end_comment

begin_comment
comment|// copyright notice, this list of conditions and the following disclaimer
end_comment

begin_comment
comment|// in the documentation and/or other materials provided with the
end_comment

begin_comment
comment|// distribution.
end_comment

begin_comment
comment|//     * Neither the name of Google Inc. nor the names of its
end_comment

begin_comment
comment|// contributors may be used to endorse or promote products derived from
end_comment

begin_comment
comment|// this software without specific prior written permission.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
end_comment

begin_comment
comment|// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
end_comment

begin_comment
comment|// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
end_comment

begin_comment
comment|// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
end_comment

begin_comment
comment|// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
end_comment

begin_comment
comment|// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
end_comment

begin_comment
comment|// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
end_comment

begin_comment
comment|// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
end_comment

begin_comment
comment|// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|DescriptorProtos
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Descriptors
operator|.
name|FileDescriptor
operator|.
name|Syntax
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|WeakReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|WeakHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_comment
comment|/**  * Contains a collection of classes which describe protocol message types.  *  * Every message type has a {@link Descriptor}, which lists all  * its fields and other information about a type.  You can get a message  * type's descriptor by calling {@code MessageType.getDescriptor()}, or  * (given a message object of the type) {@code message.getDescriptorForType()}.  * Furthermore, each message is associated with a {@link FileDescriptor} for  * a relevant {@code .proto} file. You can obtain it by calling  * {@code Descriptor.getFile()}. A {@link FileDescriptor} contains descriptors  * for all the messages defined in that file, and file descriptors for all the  * imported {@code .proto} files.  *  * Descriptors are built from DescriptorProtos, as defined in  * {@code google/protobuf/descriptor.proto}.  *  * @author kenton@google.com Kenton Varda  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|Descriptors
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|logger
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|Descriptors
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Describes a {@code .proto} file, including everything defined within.    * That includes, in particular, descriptors for all the messages and    * file descriptors for all other imported {@code .proto} files    * (dependencies).    */
specifier|public
specifier|static
specifier|final
class|class
name|FileDescriptor
extends|extends
name|GenericDescriptor
block|{
comment|/** Convert the descriptor to its protocol message representation. */
annotation|@
name|Override
specifier|public
name|FileDescriptorProto
name|toProto
parameter_list|()
block|{
return|return
name|proto
return|;
block|}
comment|/** Get the file name. */
annotation|@
name|Override
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getName
argument_list|()
return|;
block|}
comment|/** Returns this object. */
annotation|@
name|Override
specifier|public
name|FileDescriptor
name|getFile
parameter_list|()
block|{
return|return
name|this
return|;
block|}
comment|/** Returns the same as getName(). */
annotation|@
name|Override
specifier|public
name|String
name|getFullName
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getName
argument_list|()
return|;
block|}
comment|/**      * Get the proto package name.  This is the package name given by the      * {@code package} statement in the {@code .proto} file, which differs      * from the Java package.      */
specifier|public
name|String
name|getPackage
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getPackage
argument_list|()
return|;
block|}
comment|/** Get the {@code FileOptions}, defined in {@code descriptor.proto}. */
specifier|public
name|FileOptions
name|getOptions
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getOptions
argument_list|()
return|;
block|}
comment|/** Get a list of top-level message types declared in this file. */
specifier|public
name|List
argument_list|<
name|Descriptor
argument_list|>
name|getMessageTypes
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|messageTypes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Get a list of top-level enum types declared in this file. */
specifier|public
name|List
argument_list|<
name|EnumDescriptor
argument_list|>
name|getEnumTypes
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|enumTypes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Get a list of top-level services declared in this file. */
specifier|public
name|List
argument_list|<
name|ServiceDescriptor
argument_list|>
name|getServices
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|services
argument_list|)
argument_list|)
return|;
block|}
comment|/** Get a list of top-level extensions declared in this file. */
specifier|public
name|List
argument_list|<
name|FieldDescriptor
argument_list|>
name|getExtensions
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|extensions
argument_list|)
argument_list|)
return|;
block|}
comment|/** Get a list of this file's dependencies (imports). */
specifier|public
name|List
argument_list|<
name|FileDescriptor
argument_list|>
name|getDependencies
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|dependencies
argument_list|)
argument_list|)
return|;
block|}
comment|/** Get a list of this file's public dependencies (public imports). */
specifier|public
name|List
argument_list|<
name|FileDescriptor
argument_list|>
name|getPublicDependencies
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|publicDependencies
argument_list|)
argument_list|)
return|;
block|}
comment|/** The syntax of the .proto file. */
specifier|public
enum|enum
name|Syntax
block|{
name|UNKNOWN
argument_list|(
literal|"unknown"
argument_list|)
block|,
name|PROTO2
argument_list|(
literal|"proto2"
argument_list|)
block|,
name|PROTO3
argument_list|(
literal|"proto3"
argument_list|)
block|;
name|Syntax
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
block|}
comment|/** Get the syntax of the .proto file. */
specifier|public
name|Syntax
name|getSyntax
parameter_list|()
block|{
if|if
condition|(
name|Syntax
operator|.
name|PROTO3
operator|.
name|name
operator|.
name|equals
argument_list|(
name|proto
operator|.
name|getSyntax
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|Syntax
operator|.
name|PROTO3
return|;
block|}
return|return
name|Syntax
operator|.
name|PROTO2
return|;
block|}
comment|/**      * Find a message type in the file by name.  Does not find nested types.      *      * @param name The unqualified type name to look for.      * @return The message type's descriptor, or {@code null} if not found.      */
specifier|public
name|Descriptor
name|findMessageTypeByName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
comment|// Don't allow looking up nested types.  This will make optimization
comment|// easier later.
if|if
condition|(
name|name
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|getPackage
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|name
operator|=
name|getPackage
argument_list|()
operator|+
literal|'.'
operator|+
name|name
expr_stmt|;
block|}
specifier|final
name|GenericDescriptor
name|result
init|=
name|pool
operator|.
name|findSymbol
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
operator|&&
name|result
operator|instanceof
name|Descriptor
operator|&&
name|result
operator|.
name|getFile
argument_list|()
operator|==
name|this
condition|)
block|{
return|return
operator|(
name|Descriptor
operator|)
name|result
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Find an enum type in the file by name.  Does not find nested types.      *      * @param name The unqualified type name to look for.      * @return The enum type's descriptor, or {@code null} if not found.      */
specifier|public
name|EnumDescriptor
name|findEnumTypeByName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
comment|// Don't allow looking up nested types.  This will make optimization
comment|// easier later.
if|if
condition|(
name|name
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|getPackage
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|name
operator|=
name|getPackage
argument_list|()
operator|+
literal|'.'
operator|+
name|name
expr_stmt|;
block|}
specifier|final
name|GenericDescriptor
name|result
init|=
name|pool
operator|.
name|findSymbol
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
operator|&&
name|result
operator|instanceof
name|EnumDescriptor
operator|&&
name|result
operator|.
name|getFile
argument_list|()
operator|==
name|this
condition|)
block|{
return|return
operator|(
name|EnumDescriptor
operator|)
name|result
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Find a service type in the file by name.      *      * @param name The unqualified type name to look for.      * @return The service type's descriptor, or {@code null} if not found.      */
specifier|public
name|ServiceDescriptor
name|findServiceByName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
comment|// Don't allow looking up nested types.  This will make optimization
comment|// easier later.
if|if
condition|(
name|name
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|getPackage
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|name
operator|=
name|getPackage
argument_list|()
operator|+
literal|'.'
operator|+
name|name
expr_stmt|;
block|}
specifier|final
name|GenericDescriptor
name|result
init|=
name|pool
operator|.
name|findSymbol
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
operator|&&
name|result
operator|instanceof
name|ServiceDescriptor
operator|&&
name|result
operator|.
name|getFile
argument_list|()
operator|==
name|this
condition|)
block|{
return|return
operator|(
name|ServiceDescriptor
operator|)
name|result
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Find an extension in the file by name.  Does not find extensions nested      * inside message types.      *      * @param name The unqualified extension name to look for.      * @return The extension's descriptor, or {@code null} if not found.      */
specifier|public
name|FieldDescriptor
name|findExtensionByName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|getPackage
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|name
operator|=
name|getPackage
argument_list|()
operator|+
literal|'.'
operator|+
name|name
expr_stmt|;
block|}
specifier|final
name|GenericDescriptor
name|result
init|=
name|pool
operator|.
name|findSymbol
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
operator|&&
name|result
operator|instanceof
name|FieldDescriptor
operator|&&
name|result
operator|.
name|getFile
argument_list|()
operator|==
name|this
condition|)
block|{
return|return
operator|(
name|FieldDescriptor
operator|)
name|result
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Construct a {@code FileDescriptor}.      *      * @param proto The protocol message form of the FileDescriptor.      * @param dependencies {@code FileDescriptor}s corresponding to all of      *                     the file's dependencies.      * @throws DescriptorValidationException {@code proto} is not a valid      *           descriptor.  This can occur for a number of reasons, e.g.      *           because a field has an undefined type or because two messages      *           were defined with the same name.      */
specifier|public
specifier|static
name|FileDescriptor
name|buildFrom
parameter_list|(
specifier|final
name|FileDescriptorProto
name|proto
parameter_list|,
specifier|final
name|FileDescriptor
index|[]
name|dependencies
parameter_list|)
throws|throws
name|DescriptorValidationException
block|{
return|return
name|buildFrom
argument_list|(
name|proto
argument_list|,
name|dependencies
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Construct a {@code FileDescriptor}.      *      * @param proto The protocol message form of the FileDescriptor.      * @param dependencies {@code FileDescriptor}s corresponding to all of      *                     the file's dependencies.      * @param allowUnknownDependencies If true, non-exist dependenncies will be      *           ignored and undefined message types will be replaced with a      *           placeholder type.      * @throws DescriptorValidationException {@code proto} is not a valid      *           descriptor.  This can occur for a number of reasons, e.g.      *           because a field has an undefined type or because two messages      *           were defined with the same name.      */
specifier|public
specifier|static
name|FileDescriptor
name|buildFrom
parameter_list|(
specifier|final
name|FileDescriptorProto
name|proto
parameter_list|,
specifier|final
name|FileDescriptor
index|[]
name|dependencies
parameter_list|,
specifier|final
name|boolean
name|allowUnknownDependencies
parameter_list|)
throws|throws
name|DescriptorValidationException
block|{
comment|// Building descriptors involves two steps:  translating and linking.
comment|// In the translation step (implemented by FileDescriptor's
comment|// constructor), we build an object tree mirroring the
comment|// FileDescriptorProto's tree and put all of the descriptors into the
comment|// DescriptorPool's lookup tables.  In the linking step, we look up all
comment|// type references in the DescriptorPool, so that, for example, a
comment|// FieldDescriptor for an embedded message contains a pointer directly
comment|// to the Descriptor for that message's type.  We also detect undefined
comment|// types in the linking step.
specifier|final
name|DescriptorPool
name|pool
init|=
operator|new
name|DescriptorPool
argument_list|(
name|dependencies
argument_list|,
name|allowUnknownDependencies
argument_list|)
decl_stmt|;
specifier|final
name|FileDescriptor
name|result
init|=
operator|new
name|FileDescriptor
argument_list|(
name|proto
argument_list|,
name|dependencies
argument_list|,
name|pool
argument_list|,
name|allowUnknownDependencies
argument_list|)
decl_stmt|;
name|result
operator|.
name|crossLink
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**      * This method is to be called by generated code only.  It is equivalent      * to {@code buildFrom} except that the {@code FileDescriptorProto} is      * encoded in protocol buffer wire format.      */
specifier|public
specifier|static
name|void
name|internalBuildGeneratedFileFrom
parameter_list|(
specifier|final
name|String
index|[]
name|descriptorDataParts
parameter_list|,
specifier|final
name|FileDescriptor
index|[]
name|dependencies
parameter_list|,
specifier|final
name|InternalDescriptorAssigner
name|descriptorAssigner
parameter_list|)
block|{
comment|// Hack:  We can't embed a raw byte array inside generated Java code
comment|//   (at least, not efficiently), but we can embed Strings.  So, the
comment|//   protocol compiler embeds the FileDescriptorProto as a giant
comment|//   string literal which is passed to this function to construct the
comment|//   file's FileDescriptor.  The string literal contains only 8-bit
comment|//   characters, each one representing a byte of the FileDescriptorProto's
comment|//   serialized form.  So, if we convert it to bytes in ISO-8859-1, we
comment|//   should get the original bytes that we want.
comment|// descriptorData may contain multiple strings in order to get around the
comment|// Java 64k string literal limit.
name|StringBuilder
name|descriptorData
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|part
range|:
name|descriptorDataParts
control|)
block|{
name|descriptorData
operator|.
name|append
argument_list|(
name|part
argument_list|)
expr_stmt|;
block|}
specifier|final
name|byte
index|[]
name|descriptorBytes
decl_stmt|;
name|descriptorBytes
operator|=
name|descriptorData
operator|.
name|toString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|Internal
operator|.
name|ISO_8859_1
argument_list|)
expr_stmt|;
name|FileDescriptorProto
name|proto
decl_stmt|;
try|try
block|{
name|proto
operator|=
name|FileDescriptorProto
operator|.
name|parseFrom
argument_list|(
name|descriptorBytes
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidProtocolBufferException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Failed to parse protocol buffer descriptor for generated code."
argument_list|,
name|e
argument_list|)
throw|;
block|}
specifier|final
name|FileDescriptor
name|result
decl_stmt|;
try|try
block|{
comment|// When building descriptors for generated code, we allow unknown
comment|// dependencies by default.
name|result
operator|=
name|buildFrom
argument_list|(
name|proto
argument_list|,
name|dependencies
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DescriptorValidationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid embedded descriptor for \""
operator|+
name|proto
operator|.
name|getName
argument_list|()
operator|+
literal|"\"."
argument_list|,
name|e
argument_list|)
throw|;
block|}
specifier|final
name|ExtensionRegistry
name|registry
init|=
name|descriptorAssigner
operator|.
name|assignDescriptors
argument_list|(
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|registry
operator|!=
literal|null
condition|)
block|{
comment|// We must re-parse the proto using the registry.
try|try
block|{
name|proto
operator|=
name|FileDescriptorProto
operator|.
name|parseFrom
argument_list|(
name|descriptorBytes
argument_list|,
name|registry
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidProtocolBufferException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Failed to parse protocol buffer descriptor for generated code."
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|result
operator|.
name|setProto
argument_list|(
name|proto
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This method is to be called by generated code only.  It uses Java      * reflection to load the dependencies' descriptors.      */
specifier|public
specifier|static
name|void
name|internalBuildGeneratedFileFrom
parameter_list|(
specifier|final
name|String
index|[]
name|descriptorDataParts
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|descriptorOuterClass
parameter_list|,
specifier|final
name|String
index|[]
name|dependencies
parameter_list|,
specifier|final
name|String
index|[]
name|dependencyFileNames
parameter_list|,
specifier|final
name|InternalDescriptorAssigner
name|descriptorAssigner
parameter_list|)
block|{
name|List
argument_list|<
name|FileDescriptor
argument_list|>
name|descriptors
init|=
operator|new
name|ArrayList
argument_list|<
name|FileDescriptor
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dependencies
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|descriptorOuterClass
operator|.
name|getClassLoader
argument_list|()
operator|.
name|loadClass
argument_list|(
name|dependencies
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|descriptors
operator|.
name|add
argument_list|(
operator|(
name|FileDescriptor
operator|)
name|clazz
operator|.
name|getField
argument_list|(
literal|"descriptor"
argument_list|)
operator|.
name|get
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// We allow unknown dependencies by default. If a dependency cannot
comment|// be found we only generate a warning.
name|logger
operator|.
name|warning
argument_list|(
literal|"Descriptors for \""
operator|+
name|dependencyFileNames
index|[
name|i
index|]
operator|+
literal|"\" can not be found."
argument_list|)
expr_stmt|;
block|}
block|}
name|FileDescriptor
index|[]
name|descriptorArray
init|=
operator|new
name|FileDescriptor
index|[
name|descriptors
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|descriptors
operator|.
name|toArray
argument_list|(
name|descriptorArray
argument_list|)
expr_stmt|;
name|internalBuildGeneratedFileFrom
argument_list|(
name|descriptorDataParts
argument_list|,
name|descriptorArray
argument_list|,
name|descriptorAssigner
argument_list|)
expr_stmt|;
block|}
comment|/**      * This method is to be called by generated code only.  It is used to      * update the FileDescriptorProto associated with the descriptor by      * parsing it again with the given ExtensionRegistry. This is needed to      * recognize custom options.      */
specifier|public
specifier|static
name|void
name|internalUpdateFileDescriptor
parameter_list|(
specifier|final
name|FileDescriptor
name|descriptor
parameter_list|,
specifier|final
name|ExtensionRegistry
name|registry
parameter_list|)
block|{
name|ByteString
name|bytes
init|=
name|descriptor
operator|.
name|proto
operator|.
name|toByteString
argument_list|()
decl_stmt|;
name|FileDescriptorProto
name|proto
decl_stmt|;
try|try
block|{
name|proto
operator|=
name|FileDescriptorProto
operator|.
name|parseFrom
argument_list|(
name|bytes
argument_list|,
name|registry
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidProtocolBufferException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Failed to parse protocol buffer descriptor for generated code."
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|descriptor
operator|.
name|setProto
argument_list|(
name|proto
argument_list|)
expr_stmt|;
block|}
comment|/**      * This class should be used by generated code only.  When calling      * {@link FileDescriptor#internalBuildGeneratedFileFrom}, the caller      * provides a callback implementing this interface.  The callback is called      * after the FileDescriptor has been constructed, in order to assign all      * the global variables defined in the generated code which point at parts      * of the FileDescriptor.  The callback returns an ExtensionRegistry which      * contains any extensions which might be used in the descriptor -- that      * is, extensions of the various "Options" messages defined in      * descriptor.proto.  The callback may also return null to indicate that      * no extensions are used in the descriptor.      */
specifier|public
interface|interface
name|InternalDescriptorAssigner
block|{
name|ExtensionRegistry
name|assignDescriptors
parameter_list|(
name|FileDescriptor
name|root
parameter_list|)
function_decl|;
block|}
specifier|private
name|FileDescriptorProto
name|proto
decl_stmt|;
specifier|private
specifier|final
name|Descriptor
index|[]
name|messageTypes
decl_stmt|;
specifier|private
specifier|final
name|EnumDescriptor
index|[]
name|enumTypes
decl_stmt|;
specifier|private
specifier|final
name|ServiceDescriptor
index|[]
name|services
decl_stmt|;
specifier|private
specifier|final
name|FieldDescriptor
index|[]
name|extensions
decl_stmt|;
specifier|private
specifier|final
name|FileDescriptor
index|[]
name|dependencies
decl_stmt|;
specifier|private
specifier|final
name|FileDescriptor
index|[]
name|publicDependencies
decl_stmt|;
specifier|private
specifier|final
name|DescriptorPool
name|pool
decl_stmt|;
specifier|private
name|FileDescriptor
parameter_list|(
specifier|final
name|FileDescriptorProto
name|proto
parameter_list|,
specifier|final
name|FileDescriptor
index|[]
name|dependencies
parameter_list|,
specifier|final
name|DescriptorPool
name|pool
parameter_list|,
name|boolean
name|allowUnknownDependencies
parameter_list|)
throws|throws
name|DescriptorValidationException
block|{
name|this
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|this
operator|.
name|proto
operator|=
name|proto
expr_stmt|;
name|this
operator|.
name|dependencies
operator|=
name|dependencies
operator|.
name|clone
argument_list|()
expr_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|FileDescriptor
argument_list|>
name|nameToFileMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|FileDescriptor
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|FileDescriptor
name|file
range|:
name|dependencies
control|)
block|{
name|nameToFileMap
operator|.
name|put
argument_list|(
name|file
operator|.
name|getName
argument_list|()
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|FileDescriptor
argument_list|>
name|publicDependencies
init|=
operator|new
name|ArrayList
argument_list|<
name|FileDescriptor
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|proto
operator|.
name|getPublicDependencyCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|index
init|=
name|proto
operator|.
name|getPublicDependency
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|proto
operator|.
name|getDependencyCount
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|this
argument_list|,
literal|"Invalid public dependency index."
argument_list|)
throw|;
block|}
name|String
name|name
init|=
name|proto
operator|.
name|getDependency
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|FileDescriptor
name|file
init|=
name|nameToFileMap
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|allowUnknownDependencies
condition|)
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|this
argument_list|,
literal|"Invalid public dependency: "
operator|+
name|name
argument_list|)
throw|;
block|}
comment|// Ignore unknown dependencies.
block|}
else|else
block|{
name|publicDependencies
operator|.
name|add
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|publicDependencies
operator|=
operator|new
name|FileDescriptor
index|[
name|publicDependencies
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|publicDependencies
operator|.
name|toArray
argument_list|(
name|this
operator|.
name|publicDependencies
argument_list|)
expr_stmt|;
name|pool
operator|.
name|addPackage
argument_list|(
name|getPackage
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|messageTypes
operator|=
operator|new
name|Descriptor
index|[
name|proto
operator|.
name|getMessageTypeCount
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|proto
operator|.
name|getMessageTypeCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|messageTypes
index|[
name|i
index|]
operator|=
operator|new
name|Descriptor
argument_list|(
name|proto
operator|.
name|getMessageType
argument_list|(
name|i
argument_list|)
argument_list|,
name|this
argument_list|,
literal|null
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|enumTypes
operator|=
operator|new
name|EnumDescriptor
index|[
name|proto
operator|.
name|getEnumTypeCount
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|proto
operator|.
name|getEnumTypeCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|enumTypes
index|[
name|i
index|]
operator|=
operator|new
name|EnumDescriptor
argument_list|(
name|proto
operator|.
name|getEnumType
argument_list|(
name|i
argument_list|)
argument_list|,
name|this
argument_list|,
literal|null
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|services
operator|=
operator|new
name|ServiceDescriptor
index|[
name|proto
operator|.
name|getServiceCount
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|proto
operator|.
name|getServiceCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|services
index|[
name|i
index|]
operator|=
operator|new
name|ServiceDescriptor
argument_list|(
name|proto
operator|.
name|getService
argument_list|(
name|i
argument_list|)
argument_list|,
name|this
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|extensions
operator|=
operator|new
name|FieldDescriptor
index|[
name|proto
operator|.
name|getExtensionCount
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|proto
operator|.
name|getExtensionCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|extensions
index|[
name|i
index|]
operator|=
operator|new
name|FieldDescriptor
argument_list|(
name|proto
operator|.
name|getExtension
argument_list|(
name|i
argument_list|)
argument_list|,
name|this
argument_list|,
literal|null
argument_list|,
name|i
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Create a placeholder FileDescriptor for a message Descriptor.      */
name|FileDescriptor
parameter_list|(
name|String
name|packageName
parameter_list|,
name|Descriptor
name|message
parameter_list|)
throws|throws
name|DescriptorValidationException
block|{
name|this
operator|.
name|pool
operator|=
operator|new
name|DescriptorPool
argument_list|(
operator|new
name|FileDescriptor
index|[
literal|0
index|]
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|proto
operator|=
name|FileDescriptorProto
operator|.
name|newBuilder
argument_list|()
operator|.
name|setName
argument_list|(
name|message
operator|.
name|getFullName
argument_list|()
operator|+
literal|".placeholder.proto"
argument_list|)
operator|.
name|setPackage
argument_list|(
name|packageName
argument_list|)
operator|.
name|addMessageType
argument_list|(
name|message
operator|.
name|toProto
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|this
operator|.
name|dependencies
operator|=
operator|new
name|FileDescriptor
index|[
literal|0
index|]
expr_stmt|;
name|this
operator|.
name|publicDependencies
operator|=
operator|new
name|FileDescriptor
index|[
literal|0
index|]
expr_stmt|;
name|messageTypes
operator|=
operator|new
name|Descriptor
index|[]
block|{
name|message
block|}
expr_stmt|;
name|enumTypes
operator|=
operator|new
name|EnumDescriptor
index|[
literal|0
index|]
expr_stmt|;
name|services
operator|=
operator|new
name|ServiceDescriptor
index|[
literal|0
index|]
expr_stmt|;
name|extensions
operator|=
operator|new
name|FieldDescriptor
index|[
literal|0
index|]
expr_stmt|;
name|pool
operator|.
name|addPackage
argument_list|(
name|packageName
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|pool
operator|.
name|addSymbol
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
comment|/** Look up and cross-link all field types, etc. */
specifier|private
name|void
name|crossLink
parameter_list|()
throws|throws
name|DescriptorValidationException
block|{
for|for
control|(
specifier|final
name|Descriptor
name|messageType
range|:
name|messageTypes
control|)
block|{
name|messageType
operator|.
name|crossLink
argument_list|()
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|ServiceDescriptor
name|service
range|:
name|services
control|)
block|{
name|service
operator|.
name|crossLink
argument_list|()
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|FieldDescriptor
name|extension
range|:
name|extensions
control|)
block|{
name|extension
operator|.
name|crossLink
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Replace our {@link FileDescriptorProto} with the given one, which is      * identical except that it might contain extensions that weren't present      * in the original.  This method is needed for bootstrapping when a file      * defines custom options.  The options may be defined in the file itself,      * so we can't actually parse them until we've constructed the descriptors,      * but to construct the descriptors we have to have parsed the descriptor      * protos.  So, we have to parse the descriptor protos a second time after      * constructing the descriptors.      */
specifier|private
name|void
name|setProto
parameter_list|(
specifier|final
name|FileDescriptorProto
name|proto
parameter_list|)
block|{
name|this
operator|.
name|proto
operator|=
name|proto
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|messageTypes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|messageTypes
index|[
name|i
index|]
operator|.
name|setProto
argument_list|(
name|proto
operator|.
name|getMessageType
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|enumTypes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|enumTypes
index|[
name|i
index|]
operator|.
name|setProto
argument_list|(
name|proto
operator|.
name|getEnumType
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|services
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|services
index|[
name|i
index|]
operator|.
name|setProto
argument_list|(
name|proto
operator|.
name|getService
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|extensions
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|extensions
index|[
name|i
index|]
operator|.
name|setProto
argument_list|(
name|proto
operator|.
name|getExtension
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|boolean
name|supportsUnknownEnumValue
parameter_list|()
block|{
return|return
name|getSyntax
argument_list|()
operator|==
name|Syntax
operator|.
name|PROTO3
return|;
block|}
block|}
comment|// =================================================================
comment|/** Describes a message type. */
specifier|public
specifier|static
specifier|final
class|class
name|Descriptor
extends|extends
name|GenericDescriptor
block|{
comment|/**      * Get the index of this descriptor within its parent.  In other words,      * given a {@link FileDescriptor} {@code file}, the following is true:      *<pre>      *   for all i in [0, file.getMessageTypeCount()):      *     file.getMessageType(i).getIndex() == i      *</pre>      * Similarly, for a {@link Descriptor} {@code messageType}:      *<pre>      *   for all i in [0, messageType.getNestedTypeCount()):      *     messageType.getNestedType(i).getIndex() == i      *</pre>      */
specifier|public
name|int
name|getIndex
parameter_list|()
block|{
return|return
name|index
return|;
block|}
comment|/** Convert the descriptor to its protocol message representation. */
annotation|@
name|Override
specifier|public
name|DescriptorProto
name|toProto
parameter_list|()
block|{
return|return
name|proto
return|;
block|}
comment|/** Get the type's unqualified name. */
annotation|@
name|Override
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getName
argument_list|()
return|;
block|}
comment|/**      * Get the type's fully-qualified name, within the proto language's      * namespace.  This differs from the Java name.  For example, given this      * {@code .proto}:      *<pre>      *   package foo.bar;      *   option java_package = "com.example.protos"      *   message Baz {}      *</pre>      * {@code Baz}'s full name is "foo.bar.Baz".      */
annotation|@
name|Override
specifier|public
name|String
name|getFullName
parameter_list|()
block|{
return|return
name|fullName
return|;
block|}
comment|/** Get the {@link FileDescriptor} containing this descriptor. */
annotation|@
name|Override
specifier|public
name|FileDescriptor
name|getFile
parameter_list|()
block|{
return|return
name|file
return|;
block|}
comment|/** If this is a nested type, get the outer descriptor, otherwise null. */
specifier|public
name|Descriptor
name|getContainingType
parameter_list|()
block|{
return|return
name|containingType
return|;
block|}
comment|/** Get the {@code MessageOptions}, defined in {@code descriptor.proto}. */
specifier|public
name|MessageOptions
name|getOptions
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getOptions
argument_list|()
return|;
block|}
comment|/** Get a list of this message type's fields. */
specifier|public
name|List
argument_list|<
name|FieldDescriptor
argument_list|>
name|getFields
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|fields
argument_list|)
argument_list|)
return|;
block|}
comment|/** Get a list of this message type's oneofs. */
specifier|public
name|List
argument_list|<
name|OneofDescriptor
argument_list|>
name|getOneofs
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|oneofs
argument_list|)
argument_list|)
return|;
block|}
comment|/** Get a list of this message type's extensions. */
specifier|public
name|List
argument_list|<
name|FieldDescriptor
argument_list|>
name|getExtensions
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|extensions
argument_list|)
argument_list|)
return|;
block|}
comment|/** Get a list of message types nested within this one. */
specifier|public
name|List
argument_list|<
name|Descriptor
argument_list|>
name|getNestedTypes
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|nestedTypes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Get a list of enum types nested within this one. */
specifier|public
name|List
argument_list|<
name|EnumDescriptor
argument_list|>
name|getEnumTypes
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|enumTypes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Determines if the given field number is an extension. */
specifier|public
name|boolean
name|isExtensionNumber
parameter_list|(
specifier|final
name|int
name|number
parameter_list|)
block|{
for|for
control|(
specifier|final
name|DescriptorProto
operator|.
name|ExtensionRange
name|range
range|:
name|proto
operator|.
name|getExtensionRangeList
argument_list|()
control|)
block|{
if|if
condition|(
name|range
operator|.
name|getStart
argument_list|()
operator|<=
name|number
operator|&&
name|number
operator|<
name|range
operator|.
name|getEnd
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** Determines if the given field number is reserved. */
specifier|public
name|boolean
name|isReservedNumber
parameter_list|(
specifier|final
name|int
name|number
parameter_list|)
block|{
for|for
control|(
specifier|final
name|DescriptorProto
operator|.
name|ReservedRange
name|range
range|:
name|proto
operator|.
name|getReservedRangeList
argument_list|()
control|)
block|{
if|if
condition|(
name|range
operator|.
name|getStart
argument_list|()
operator|<=
name|number
operator|&&
name|number
operator|<
name|range
operator|.
name|getEnd
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** Determines if the given field name is reserved. */
specifier|public
name|boolean
name|isReservedName
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
for|for
control|(
specifier|final
name|String
name|reservedName
range|:
name|proto
operator|.
name|getReservedNameList
argument_list|()
control|)
block|{
if|if
condition|(
name|reservedName
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Indicates whether the message can be extended.  That is, whether it has      * any "extensions x to y" ranges declared on it.      */
specifier|public
name|boolean
name|isExtendable
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getExtensionRangeList
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|0
return|;
block|}
comment|/**      * Finds a field by name.      * @param name The unqualified name of the field (e.g. "foo").      * @return The field's descriptor, or {@code null} if not found.      */
specifier|public
name|FieldDescriptor
name|findFieldByName
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
block|{
specifier|final
name|GenericDescriptor
name|result
init|=
name|file
operator|.
name|pool
operator|.
name|findSymbol
argument_list|(
name|fullName
operator|+
literal|'.'
operator|+
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
operator|&&
name|result
operator|instanceof
name|FieldDescriptor
condition|)
block|{
return|return
operator|(
name|FieldDescriptor
operator|)
name|result
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Finds a field by field number.      * @param number The field number within this message type.      * @return The field's descriptor, or {@code null} if not found.      */
specifier|public
name|FieldDescriptor
name|findFieldByNumber
parameter_list|(
specifier|final
name|int
name|number
parameter_list|)
block|{
return|return
name|file
operator|.
name|pool
operator|.
name|fieldsByNumber
operator|.
name|get
argument_list|(
operator|new
name|DescriptorPool
operator|.
name|DescriptorIntPair
argument_list|(
name|this
argument_list|,
name|number
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Finds a nested message type by name.      * @param name The unqualified name of the nested type (e.g. "Foo").      * @return The types's descriptor, or {@code null} if not found.      */
specifier|public
name|Descriptor
name|findNestedTypeByName
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
block|{
specifier|final
name|GenericDescriptor
name|result
init|=
name|file
operator|.
name|pool
operator|.
name|findSymbol
argument_list|(
name|fullName
operator|+
literal|'.'
operator|+
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
operator|&&
name|result
operator|instanceof
name|Descriptor
condition|)
block|{
return|return
operator|(
name|Descriptor
operator|)
name|result
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Finds a nested enum type by name.      * @param name The unqualified name of the nested type (e.g. "Foo").      * @return The types's descriptor, or {@code null} if not found.      */
specifier|public
name|EnumDescriptor
name|findEnumTypeByName
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
block|{
specifier|final
name|GenericDescriptor
name|result
init|=
name|file
operator|.
name|pool
operator|.
name|findSymbol
argument_list|(
name|fullName
operator|+
literal|'.'
operator|+
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
operator|&&
name|result
operator|instanceof
name|EnumDescriptor
condition|)
block|{
return|return
operator|(
name|EnumDescriptor
operator|)
name|result
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|private
specifier|final
name|int
name|index
decl_stmt|;
specifier|private
name|DescriptorProto
name|proto
decl_stmt|;
specifier|private
specifier|final
name|String
name|fullName
decl_stmt|;
specifier|private
specifier|final
name|FileDescriptor
name|file
decl_stmt|;
specifier|private
specifier|final
name|Descriptor
name|containingType
decl_stmt|;
specifier|private
specifier|final
name|Descriptor
index|[]
name|nestedTypes
decl_stmt|;
specifier|private
specifier|final
name|EnumDescriptor
index|[]
name|enumTypes
decl_stmt|;
specifier|private
specifier|final
name|FieldDescriptor
index|[]
name|fields
decl_stmt|;
specifier|private
specifier|final
name|FieldDescriptor
index|[]
name|extensions
decl_stmt|;
specifier|private
specifier|final
name|OneofDescriptor
index|[]
name|oneofs
decl_stmt|;
comment|// Used to create a placeholder when the type cannot be found.
name|Descriptor
parameter_list|(
specifier|final
name|String
name|fullname
parameter_list|)
throws|throws
name|DescriptorValidationException
block|{
name|String
name|name
init|=
name|fullname
decl_stmt|;
name|String
name|packageName
init|=
literal|""
decl_stmt|;
name|int
name|pos
init|=
name|fullname
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
operator|-
literal|1
condition|)
block|{
name|name
operator|=
name|fullname
operator|.
name|substring
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
name|packageName
operator|=
name|fullname
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|index
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|proto
operator|=
name|DescriptorProto
operator|.
name|newBuilder
argument_list|()
operator|.
name|setName
argument_list|(
name|name
argument_list|)
operator|.
name|addExtensionRange
argument_list|(
name|DescriptorProto
operator|.
name|ExtensionRange
operator|.
name|newBuilder
argument_list|()
operator|.
name|setStart
argument_list|(
literal|1
argument_list|)
operator|.
name|setEnd
argument_list|(
literal|536870912
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|this
operator|.
name|fullName
operator|=
name|fullname
expr_stmt|;
name|this
operator|.
name|containingType
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|nestedTypes
operator|=
operator|new
name|Descriptor
index|[
literal|0
index|]
expr_stmt|;
name|this
operator|.
name|enumTypes
operator|=
operator|new
name|EnumDescriptor
index|[
literal|0
index|]
expr_stmt|;
name|this
operator|.
name|fields
operator|=
operator|new
name|FieldDescriptor
index|[
literal|0
index|]
expr_stmt|;
name|this
operator|.
name|extensions
operator|=
operator|new
name|FieldDescriptor
index|[
literal|0
index|]
expr_stmt|;
name|this
operator|.
name|oneofs
operator|=
operator|new
name|OneofDescriptor
index|[
literal|0
index|]
expr_stmt|;
comment|// Create a placeholder FileDescriptor to hold this message.
name|this
operator|.
name|file
operator|=
operator|new
name|FileDescriptor
argument_list|(
name|packageName
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
specifier|private
name|Descriptor
parameter_list|(
specifier|final
name|DescriptorProto
name|proto
parameter_list|,
specifier|final
name|FileDescriptor
name|file
parameter_list|,
specifier|final
name|Descriptor
name|parent
parameter_list|,
specifier|final
name|int
name|index
parameter_list|)
throws|throws
name|DescriptorValidationException
block|{
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
name|this
operator|.
name|proto
operator|=
name|proto
expr_stmt|;
name|fullName
operator|=
name|computeFullName
argument_list|(
name|file
argument_list|,
name|parent
argument_list|,
name|proto
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|file
operator|=
name|file
expr_stmt|;
name|containingType
operator|=
name|parent
expr_stmt|;
name|oneofs
operator|=
operator|new
name|OneofDescriptor
index|[
name|proto
operator|.
name|getOneofDeclCount
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|proto
operator|.
name|getOneofDeclCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|oneofs
index|[
name|i
index|]
operator|=
operator|new
name|OneofDescriptor
argument_list|(
name|proto
operator|.
name|getOneofDecl
argument_list|(
name|i
argument_list|)
argument_list|,
name|file
argument_list|,
name|this
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|nestedTypes
operator|=
operator|new
name|Descriptor
index|[
name|proto
operator|.
name|getNestedTypeCount
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|proto
operator|.
name|getNestedTypeCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|nestedTypes
index|[
name|i
index|]
operator|=
operator|new
name|Descriptor
argument_list|(
name|proto
operator|.
name|getNestedType
argument_list|(
name|i
argument_list|)
argument_list|,
name|file
argument_list|,
name|this
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|enumTypes
operator|=
operator|new
name|EnumDescriptor
index|[
name|proto
operator|.
name|getEnumTypeCount
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|proto
operator|.
name|getEnumTypeCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|enumTypes
index|[
name|i
index|]
operator|=
operator|new
name|EnumDescriptor
argument_list|(
name|proto
operator|.
name|getEnumType
argument_list|(
name|i
argument_list|)
argument_list|,
name|file
argument_list|,
name|this
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|fields
operator|=
operator|new
name|FieldDescriptor
index|[
name|proto
operator|.
name|getFieldCount
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|proto
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|fields
index|[
name|i
index|]
operator|=
operator|new
name|FieldDescriptor
argument_list|(
name|proto
operator|.
name|getField
argument_list|(
name|i
argument_list|)
argument_list|,
name|file
argument_list|,
name|this
argument_list|,
name|i
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|extensions
operator|=
operator|new
name|FieldDescriptor
index|[
name|proto
operator|.
name|getExtensionCount
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|proto
operator|.
name|getExtensionCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|extensions
index|[
name|i
index|]
operator|=
operator|new
name|FieldDescriptor
argument_list|(
name|proto
operator|.
name|getExtension
argument_list|(
name|i
argument_list|)
argument_list|,
name|file
argument_list|,
name|this
argument_list|,
name|i
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|proto
operator|.
name|getOneofDeclCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|oneofs
index|[
name|i
index|]
operator|.
name|fields
operator|=
operator|new
name|FieldDescriptor
index|[
name|oneofs
index|[
name|i
index|]
operator|.
name|getFieldCount
argument_list|()
index|]
expr_stmt|;
name|oneofs
index|[
name|i
index|]
operator|.
name|fieldCount
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|proto
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|OneofDescriptor
name|oneofDescriptor
init|=
name|fields
index|[
name|i
index|]
operator|.
name|getContainingOneof
argument_list|()
decl_stmt|;
if|if
condition|(
name|oneofDescriptor
operator|!=
literal|null
condition|)
block|{
name|oneofDescriptor
operator|.
name|fields
index|[
name|oneofDescriptor
operator|.
name|fieldCount
operator|++
index|]
operator|=
name|fields
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|file
operator|.
name|pool
operator|.
name|addSymbol
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/** Look up and cross-link all field types, etc. */
specifier|private
name|void
name|crossLink
parameter_list|()
throws|throws
name|DescriptorValidationException
block|{
for|for
control|(
specifier|final
name|Descriptor
name|nestedType
range|:
name|nestedTypes
control|)
block|{
name|nestedType
operator|.
name|crossLink
argument_list|()
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|FieldDescriptor
name|field
range|:
name|fields
control|)
block|{
name|field
operator|.
name|crossLink
argument_list|()
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|FieldDescriptor
name|extension
range|:
name|extensions
control|)
block|{
name|extension
operator|.
name|crossLink
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** See {@link FileDescriptor#setProto}. */
specifier|private
name|void
name|setProto
parameter_list|(
specifier|final
name|DescriptorProto
name|proto
parameter_list|)
block|{
name|this
operator|.
name|proto
operator|=
name|proto
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nestedTypes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|nestedTypes
index|[
name|i
index|]
operator|.
name|setProto
argument_list|(
name|proto
operator|.
name|getNestedType
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|oneofs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|oneofs
index|[
name|i
index|]
operator|.
name|setProto
argument_list|(
name|proto
operator|.
name|getOneofDecl
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|enumTypes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|enumTypes
index|[
name|i
index|]
operator|.
name|setProto
argument_list|(
name|proto
operator|.
name|getEnumType
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|fields
index|[
name|i
index|]
operator|.
name|setProto
argument_list|(
name|proto
operator|.
name|getField
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|extensions
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|extensions
index|[
name|i
index|]
operator|.
name|setProto
argument_list|(
name|proto
operator|.
name|getExtension
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// =================================================================
comment|/** Describes a field of a message type. */
specifier|public
specifier|static
specifier|final
class|class
name|FieldDescriptor
extends|extends
name|GenericDescriptor
implements|implements
name|Comparable
argument_list|<
name|FieldDescriptor
argument_list|>
implements|,
name|FieldSet
operator|.
name|FieldDescriptorLite
argument_list|<
name|FieldDescriptor
argument_list|>
block|{
comment|/**      * Get the index of this descriptor within its parent.      * @see Descriptors.Descriptor#getIndex()      */
specifier|public
name|int
name|getIndex
parameter_list|()
block|{
return|return
name|index
return|;
block|}
comment|/** Convert the descriptor to its protocol message representation. */
annotation|@
name|Override
specifier|public
name|FieldDescriptorProto
name|toProto
parameter_list|()
block|{
return|return
name|proto
return|;
block|}
comment|/** Get the field's unqualified name. */
annotation|@
name|Override
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getName
argument_list|()
return|;
block|}
comment|/** Get the field's number. */
annotation|@
name|Override
specifier|public
name|int
name|getNumber
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getNumber
argument_list|()
return|;
block|}
comment|/**      * Get the field's fully-qualified name.      * @see Descriptors.Descriptor#getFullName()      */
annotation|@
name|Override
specifier|public
name|String
name|getFullName
parameter_list|()
block|{
return|return
name|fullName
return|;
block|}
comment|/** Get the JSON name of this field. */
specifier|public
name|String
name|getJsonName
parameter_list|()
block|{
return|return
name|jsonName
return|;
block|}
comment|/**      * Get the field's java type.  This is just for convenience.  Every      * {@code FieldDescriptorProto.Type} maps to exactly one Java type.      */
specifier|public
name|JavaType
name|getJavaType
parameter_list|()
block|{
return|return
name|type
operator|.
name|getJavaType
argument_list|()
return|;
block|}
comment|/** For internal use only. */
annotation|@
name|Override
specifier|public
name|WireFormat
operator|.
name|JavaType
name|getLiteJavaType
parameter_list|()
block|{
return|return
name|getLiteType
argument_list|()
operator|.
name|getJavaType
argument_list|()
return|;
block|}
comment|/** Get the {@code FileDescriptor} containing this descriptor. */
annotation|@
name|Override
specifier|public
name|FileDescriptor
name|getFile
parameter_list|()
block|{
return|return
name|file
return|;
block|}
comment|/** Get the field's declared type. */
specifier|public
name|Type
name|getType
parameter_list|()
block|{
return|return
name|type
return|;
block|}
comment|/** For internal use only. */
annotation|@
name|Override
specifier|public
name|WireFormat
operator|.
name|FieldType
name|getLiteType
parameter_list|()
block|{
return|return
name|table
index|[
name|type
operator|.
name|ordinal
argument_list|()
index|]
return|;
block|}
comment|/** For internal use only. */
specifier|public
name|boolean
name|needsUtf8Check
parameter_list|()
block|{
if|if
condition|(
name|type
operator|!=
name|Type
operator|.
name|STRING
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|getContainingType
argument_list|()
operator|.
name|getOptions
argument_list|()
operator|.
name|getMapEntry
argument_list|()
condition|)
block|{
comment|// Always enforce strict UTF-8 checking for map fields.
return|return
literal|true
return|;
block|}
if|if
condition|(
name|getFile
argument_list|()
operator|.
name|getSyntax
argument_list|()
operator|==
name|Syntax
operator|.
name|PROTO3
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|getFile
argument_list|()
operator|.
name|getOptions
argument_list|()
operator|.
name|getJavaStringCheckUtf8
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|isMapField
parameter_list|()
block|{
return|return
name|getType
argument_list|()
operator|==
name|Type
operator|.
name|MESSAGE
operator|&&
name|isRepeated
argument_list|()
operator|&&
name|getMessageType
argument_list|()
operator|.
name|getOptions
argument_list|()
operator|.
name|getMapEntry
argument_list|()
return|;
block|}
comment|// I'm pretty sure values() constructs a new array every time, since there
comment|// is nothing stopping the caller from mutating the array.  Therefore we
comment|// make a static copy here.
specifier|private
specifier|static
specifier|final
name|WireFormat
operator|.
name|FieldType
index|[]
name|table
init|=
name|WireFormat
operator|.
name|FieldType
operator|.
name|values
argument_list|()
decl_stmt|;
comment|/** Is this field declared required? */
specifier|public
name|boolean
name|isRequired
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getLabel
argument_list|()
operator|==
name|FieldDescriptorProto
operator|.
name|Label
operator|.
name|LABEL_REQUIRED
return|;
block|}
comment|/** Is this field declared optional? */
specifier|public
name|boolean
name|isOptional
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getLabel
argument_list|()
operator|==
name|FieldDescriptorProto
operator|.
name|Label
operator|.
name|LABEL_OPTIONAL
return|;
block|}
comment|/** Is this field declared repeated? */
annotation|@
name|Override
specifier|public
name|boolean
name|isRepeated
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getLabel
argument_list|()
operator|==
name|FieldDescriptorProto
operator|.
name|Label
operator|.
name|LABEL_REPEATED
return|;
block|}
comment|/** Does this field have the {@code [packed = true]} option or is this field      *  packable in proto3 and not explicitly setted to unpacked?      */
annotation|@
name|Override
specifier|public
name|boolean
name|isPacked
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isPackable
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|getFile
argument_list|()
operator|.
name|getSyntax
argument_list|()
operator|==
name|FileDescriptor
operator|.
name|Syntax
operator|.
name|PROTO2
condition|)
block|{
return|return
name|getOptions
argument_list|()
operator|.
name|getPacked
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|!
name|getOptions
argument_list|()
operator|.
name|hasPacked
argument_list|()
operator|||
name|getOptions
argument_list|()
operator|.
name|getPacked
argument_list|()
return|;
block|}
block|}
comment|/** Can this field be packed? i.e. is it a repeated primitive field? */
specifier|public
name|boolean
name|isPackable
parameter_list|()
block|{
return|return
name|isRepeated
argument_list|()
operator|&&
name|getLiteType
argument_list|()
operator|.
name|isPackable
argument_list|()
return|;
block|}
comment|/** Returns true if the field had an explicitly-defined default value. */
specifier|public
name|boolean
name|hasDefaultValue
parameter_list|()
block|{
return|return
name|proto
operator|.
name|hasDefaultValue
argument_list|()
return|;
block|}
comment|/**      * Returns the field's default value.  Valid for all types except for      * messages and groups.  For all other types, the object returned is of      * the same class that would returned by Message.getField(this).      */
specifier|public
name|Object
name|getDefaultValue
parameter_list|()
block|{
if|if
condition|(
name|getJavaType
argument_list|()
operator|==
name|JavaType
operator|.
name|MESSAGE
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"FieldDescriptor.getDefaultValue() called on an embedded message "
operator|+
literal|"field."
argument_list|)
throw|;
block|}
return|return
name|defaultValue
return|;
block|}
comment|/** Get the {@code FieldOptions}, defined in {@code descriptor.proto}. */
specifier|public
name|FieldOptions
name|getOptions
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getOptions
argument_list|()
return|;
block|}
comment|/** Is this field an extension? */
specifier|public
name|boolean
name|isExtension
parameter_list|()
block|{
return|return
name|proto
operator|.
name|hasExtendee
argument_list|()
return|;
block|}
comment|/**      * Get the field's containing type. For extensions, this is the type being      * extended, not the location where the extension was defined.  See      * {@link #getExtensionScope()}.      */
specifier|public
name|Descriptor
name|getContainingType
parameter_list|()
block|{
return|return
name|containingType
return|;
block|}
comment|/** Get the field's containing oneof. */
specifier|public
name|OneofDescriptor
name|getContainingOneof
parameter_list|()
block|{
return|return
name|containingOneof
return|;
block|}
comment|/**      * For extensions defined nested within message types, gets the outer      * type.  Not valid for non-extension fields.  For example, consider      * this {@code .proto} file:      *<pre>      *   message Foo {      *     extensions 1000 to max;      *   }      *   extend Foo {      *     optional int32 baz = 1234;      *   }      *   message Bar {      *     extend Foo {      *       optional int32 qux = 4321;      *     }      *   }      *</pre>      * Both {@code baz}'s and {@code qux}'s containing type is {@code Foo}.      * However, {@code baz}'s extension scope is {@code null} while      * {@code qux}'s extension scope is {@code Bar}.      */
specifier|public
name|Descriptor
name|getExtensionScope
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isExtension
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This field is not an extension."
argument_list|)
throw|;
block|}
return|return
name|extensionScope
return|;
block|}
comment|/** For embedded message and group fields, gets the field's type. */
specifier|public
name|Descriptor
name|getMessageType
parameter_list|()
block|{
if|if
condition|(
name|getJavaType
argument_list|()
operator|!=
name|JavaType
operator|.
name|MESSAGE
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This field is not of message type."
argument_list|)
throw|;
block|}
return|return
name|messageType
return|;
block|}
comment|/** For enum fields, gets the field's type. */
annotation|@
name|Override
specifier|public
name|EnumDescriptor
name|getEnumType
parameter_list|()
block|{
if|if
condition|(
name|getJavaType
argument_list|()
operator|!=
name|JavaType
operator|.
name|ENUM
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This field is not of enum type."
argument_list|)
throw|;
block|}
return|return
name|enumType
return|;
block|}
comment|/**      * Compare with another {@code FieldDescriptor}.  This orders fields in      * "canonical" order, which simply means ascending order by field number.      * {@code other} must be a field of the same type -- i.e.      * {@code getContainingType()} must return the same {@code Descriptor} for      * both fields.      *      * @return negative, zero, or positive if {@code this} is less than,      *         equal to, or greater than {@code other}, respectively.      */
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
specifier|final
name|FieldDescriptor
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|.
name|containingType
operator|!=
name|containingType
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"FieldDescriptors can only be compared to other FieldDescriptors "
operator|+
literal|"for fields of the same message type."
argument_list|)
throw|;
block|}
return|return
name|getNumber
argument_list|()
operator|-
name|other
operator|.
name|getNumber
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getFullName
argument_list|()
return|;
block|}
specifier|private
specifier|final
name|int
name|index
decl_stmt|;
specifier|private
name|FieldDescriptorProto
name|proto
decl_stmt|;
specifier|private
specifier|final
name|String
name|fullName
decl_stmt|;
specifier|private
specifier|final
name|String
name|jsonName
decl_stmt|;
specifier|private
specifier|final
name|FileDescriptor
name|file
decl_stmt|;
specifier|private
specifier|final
name|Descriptor
name|extensionScope
decl_stmt|;
comment|// Possibly initialized during cross-linking.
specifier|private
name|Type
name|type
decl_stmt|;
specifier|private
name|Descriptor
name|containingType
decl_stmt|;
specifier|private
name|Descriptor
name|messageType
decl_stmt|;
specifier|private
name|OneofDescriptor
name|containingOneof
decl_stmt|;
specifier|private
name|EnumDescriptor
name|enumType
decl_stmt|;
specifier|private
name|Object
name|defaultValue
decl_stmt|;
specifier|public
enum|enum
name|Type
block|{
name|DOUBLE
parameter_list|(
name|JavaType
operator|.
name|DOUBLE
parameter_list|)
operator|,
constructor|FLOAT   (JavaType.FLOAT
block|)
enum|,
name|INT64
parameter_list|(
name|JavaType
operator|.
name|LONG
parameter_list|)
operator|,
constructor|UINT64  (JavaType.LONG
block|)
operator|,
name|INT32
parameter_list|(
name|JavaType
operator|.
name|INT
parameter_list|)
operator|,
constructor|FIXED64 (JavaType.LONG
block|)
operator|,
name|FIXED32
argument_list|(
name|JavaType
operator|.
name|INT
argument_list|)
operator|,
name|BOOL
argument_list|(
name|JavaType
operator|.
name|BOOLEAN
argument_list|)
operator|,
name|STRING
argument_list|(
name|JavaType
operator|.
name|STRING
argument_list|)
operator|,
name|GROUP
argument_list|(
name|JavaType
operator|.
name|MESSAGE
argument_list|)
operator|,
name|MESSAGE
argument_list|(
name|JavaType
operator|.
name|MESSAGE
argument_list|)
operator|,
name|BYTES
argument_list|(
name|JavaType
operator|.
name|BYTE_STRING
argument_list|)
operator|,
name|UINT32
argument_list|(
name|JavaType
operator|.
name|INT
argument_list|)
operator|,
name|ENUM
argument_list|(
name|JavaType
operator|.
name|ENUM
argument_list|)
operator|,
name|SFIXED32
argument_list|(
name|JavaType
operator|.
name|INT
argument_list|)
operator|,
name|SFIXED64
argument_list|(
name|JavaType
operator|.
name|LONG
argument_list|)
operator|,
name|SINT32
argument_list|(
name|JavaType
operator|.
name|INT
argument_list|)
operator|,
name|SINT64
argument_list|(
name|JavaType
operator|.
name|LONG
argument_list|)
expr_stmt|;
end_class

begin_expr_stmt
name|Type
argument_list|(
name|final
name|JavaType
name|javaType
argument_list|)
block|{
name|this
operator|.
name|javaType
operator|=
name|javaType
block|;       }
specifier|private
name|JavaType
name|javaType
expr_stmt|;
end_expr_stmt

begin_function
specifier|public
name|FieldDescriptorProto
operator|.
name|Type
name|toProto
parameter_list|()
block|{
return|return
name|FieldDescriptorProto
operator|.
name|Type
operator|.
name|forNumber
argument_list|(
name|ordinal
argument_list|()
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|public
name|JavaType
name|getJavaType
parameter_list|()
block|{
return|return
name|javaType
return|;
block|}
end_function

begin_function
specifier|public
specifier|static
name|Type
name|valueOf
parameter_list|(
specifier|final
name|FieldDescriptorProto
operator|.
name|Type
name|type
parameter_list|)
block|{
return|return
name|values
argument_list|()
index|[
name|type
operator|.
name|getNumber
argument_list|()
operator|-
literal|1
index|]
return|;
block|}
end_function

begin_block
unit|}      static
block|{
comment|// Refuse to init if someone added a new declared type.
if|if
condition|(
name|Type
operator|.
name|values
argument_list|()
operator|.
name|length
operator|!=
name|FieldDescriptorProto
operator|.
name|Type
operator|.
name|values
argument_list|()
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|""
operator|+
literal|"descriptor.proto has a new declared type but Descriptors.java "
operator|+
literal|"wasn't updated."
argument_list|)
throw|;
block|}
block|}
end_block

begin_enum
specifier|public
enum|enum
name|JavaType
block|{
name|INT
argument_list|(
literal|0
argument_list|)
block|,
name|LONG
argument_list|(
literal|0L
argument_list|)
block|,
name|FLOAT
argument_list|(
literal|0F
argument_list|)
block|,
name|DOUBLE
argument_list|(
literal|0D
argument_list|)
block|,
name|BOOLEAN
argument_list|(
literal|false
argument_list|)
block|,
name|STRING
argument_list|(
literal|""
argument_list|)
block|,
name|BYTE_STRING
parameter_list|(
name|ByteString
operator|.
name|EMPTY
parameter_list|)
operator|,
constructor|ENUM(null
block|)
enum|,
name|MESSAGE
argument_list|(
literal|null
argument_list|)
enum|;
end_enum

begin_expr_stmt
name|JavaType
argument_list|(
name|final
name|Object
name|defaultDefault
argument_list|)
block|{
name|this
operator|.
name|defaultDefault
operator|=
name|defaultDefault
block|;       }
comment|/**        * The default default value for fields of this type, if it's a primitive        * type.  This is meant for use inside this file only, hence is private.        */
specifier|private
name|final
name|Object
name|defaultDefault
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|// This method should match exactly with the ToJsonName() function in C++
end_comment

begin_comment
comment|// descriptor.cc.
end_comment

begin_function
unit|private
specifier|static
name|String
name|fieldNameToJsonName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|(
name|name
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|isNextUpperCase
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|name
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Character
name|ch
init|=
name|name
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'_'
condition|)
block|{
name|isNextUpperCase
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isNextUpperCase
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|Character
operator|.
name|toUpperCase
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
name|isNextUpperCase
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
end_function

begin_constructor
specifier|private
name|FieldDescriptor
parameter_list|(
specifier|final
name|FieldDescriptorProto
name|proto
parameter_list|,
specifier|final
name|FileDescriptor
name|file
parameter_list|,
specifier|final
name|Descriptor
name|parent
parameter_list|,
specifier|final
name|int
name|index
parameter_list|,
specifier|final
name|boolean
name|isExtension
parameter_list|)
throws|throws
name|DescriptorValidationException
block|{
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
name|this
operator|.
name|proto
operator|=
name|proto
expr_stmt|;
name|fullName
operator|=
name|computeFullName
argument_list|(
name|file
argument_list|,
name|parent
argument_list|,
name|proto
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|file
operator|=
name|file
expr_stmt|;
if|if
condition|(
name|proto
operator|.
name|hasJsonName
argument_list|()
condition|)
block|{
name|jsonName
operator|=
name|proto
operator|.
name|getJsonName
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|jsonName
operator|=
name|fieldNameToJsonName
argument_list|(
name|proto
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|proto
operator|.
name|hasType
argument_list|()
condition|)
block|{
name|type
operator|=
name|Type
operator|.
name|valueOf
argument_list|(
name|proto
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getNumber
argument_list|()
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|this
argument_list|,
literal|"Field numbers must be positive integers."
argument_list|)
throw|;
block|}
if|if
condition|(
name|isExtension
condition|)
block|{
if|if
condition|(
operator|!
name|proto
operator|.
name|hasExtendee
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|this
argument_list|,
literal|"FieldDescriptorProto.extendee not set for extension field."
argument_list|)
throw|;
block|}
name|containingType
operator|=
literal|null
expr_stmt|;
comment|// Will be filled in when cross-linking
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|extensionScope
operator|=
name|parent
expr_stmt|;
block|}
else|else
block|{
name|extensionScope
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|proto
operator|.
name|hasOneofIndex
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|this
argument_list|,
literal|"FieldDescriptorProto.oneof_index set for extension field."
argument_list|)
throw|;
block|}
name|containingOneof
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|proto
operator|.
name|hasExtendee
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|this
argument_list|,
literal|"FieldDescriptorProto.extendee set for non-extension field."
argument_list|)
throw|;
block|}
name|containingType
operator|=
name|parent
expr_stmt|;
if|if
condition|(
name|proto
operator|.
name|hasOneofIndex
argument_list|()
condition|)
block|{
if|if
condition|(
name|proto
operator|.
name|getOneofIndex
argument_list|()
operator|<
literal|0
operator|||
name|proto
operator|.
name|getOneofIndex
argument_list|()
operator|>=
name|parent
operator|.
name|toProto
argument_list|()
operator|.
name|getOneofDeclCount
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|this
argument_list|,
literal|"FieldDescriptorProto.oneof_index is out of range for type "
operator|+
name|parent
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
name|containingOneof
operator|=
name|parent
operator|.
name|getOneofs
argument_list|()
operator|.
name|get
argument_list|(
name|proto
operator|.
name|getOneofIndex
argument_list|()
argument_list|)
expr_stmt|;
name|containingOneof
operator|.
name|fieldCount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|containingOneof
operator|=
literal|null
expr_stmt|;
block|}
name|extensionScope
operator|=
literal|null
expr_stmt|;
block|}
name|file
operator|.
name|pool
operator|.
name|addSymbol
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor

begin_comment
comment|/** Look up and cross-link all field types, etc. */
end_comment

begin_function
specifier|private
name|void
name|crossLink
parameter_list|()
throws|throws
name|DescriptorValidationException
block|{
if|if
condition|(
name|proto
operator|.
name|hasExtendee
argument_list|()
condition|)
block|{
specifier|final
name|GenericDescriptor
name|extendee
init|=
name|file
operator|.
name|pool
operator|.
name|lookupSymbol
argument_list|(
name|proto
operator|.
name|getExtendee
argument_list|()
argument_list|,
name|this
argument_list|,
name|DescriptorPool
operator|.
name|SearchFilter
operator|.
name|TYPES_ONLY
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|extendee
operator|instanceof
name|Descriptor
operator|)
condition|)
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|this
argument_list|,
literal|'\"'
operator|+
name|proto
operator|.
name|getExtendee
argument_list|()
operator|+
literal|"\" is not a message type."
argument_list|)
throw|;
block|}
name|containingType
operator|=
operator|(
name|Descriptor
operator|)
name|extendee
expr_stmt|;
if|if
condition|(
operator|!
name|getContainingType
argument_list|()
operator|.
name|isExtensionNumber
argument_list|(
name|getNumber
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|this
argument_list|,
literal|'\"'
operator|+
name|getContainingType
argument_list|()
operator|.
name|getFullName
argument_list|()
operator|+
literal|"\" does not declare "
operator|+
name|getNumber
argument_list|()
operator|+
literal|" as an extension number."
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|proto
operator|.
name|hasTypeName
argument_list|()
condition|)
block|{
specifier|final
name|GenericDescriptor
name|typeDescriptor
init|=
name|file
operator|.
name|pool
operator|.
name|lookupSymbol
argument_list|(
name|proto
operator|.
name|getTypeName
argument_list|()
argument_list|,
name|this
argument_list|,
name|DescriptorPool
operator|.
name|SearchFilter
operator|.
name|TYPES_ONLY
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|proto
operator|.
name|hasType
argument_list|()
condition|)
block|{
comment|// Choose field type based on symbol.
if|if
condition|(
name|typeDescriptor
operator|instanceof
name|Descriptor
condition|)
block|{
name|type
operator|=
name|Type
operator|.
name|MESSAGE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typeDescriptor
operator|instanceof
name|EnumDescriptor
condition|)
block|{
name|type
operator|=
name|Type
operator|.
name|ENUM
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|this
argument_list|,
literal|'\"'
operator|+
name|proto
operator|.
name|getTypeName
argument_list|()
operator|+
literal|"\" is not a type."
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|getJavaType
argument_list|()
operator|==
name|JavaType
operator|.
name|MESSAGE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|typeDescriptor
operator|instanceof
name|Descriptor
operator|)
condition|)
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|this
argument_list|,
literal|'\"'
operator|+
name|proto
operator|.
name|getTypeName
argument_list|()
operator|+
literal|"\" is not a message type."
argument_list|)
throw|;
block|}
name|messageType
operator|=
operator|(
name|Descriptor
operator|)
name|typeDescriptor
expr_stmt|;
if|if
condition|(
name|proto
operator|.
name|hasDefaultValue
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|this
argument_list|,
literal|"Messages can't have default values."
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|getJavaType
argument_list|()
operator|==
name|JavaType
operator|.
name|ENUM
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|typeDescriptor
operator|instanceof
name|EnumDescriptor
operator|)
condition|)
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|this
argument_list|,
literal|'\"'
operator|+
name|proto
operator|.
name|getTypeName
argument_list|()
operator|+
literal|"\" is not an enum type."
argument_list|)
throw|;
block|}
name|enumType
operator|=
operator|(
name|EnumDescriptor
operator|)
name|typeDescriptor
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|this
argument_list|,
literal|"Field with primitive type has type_name."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|getJavaType
argument_list|()
operator|==
name|JavaType
operator|.
name|MESSAGE
operator|||
name|getJavaType
argument_list|()
operator|==
name|JavaType
operator|.
name|ENUM
condition|)
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|this
argument_list|,
literal|"Field with message or enum type missing type_name."
argument_list|)
throw|;
block|}
block|}
comment|// Only repeated primitive fields may be packed.
if|if
condition|(
name|proto
operator|.
name|getOptions
argument_list|()
operator|.
name|getPacked
argument_list|()
operator|&&
operator|!
name|isPackable
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|this
argument_list|,
literal|"[packed = true] can only be specified for repeated primitive "
operator|+
literal|"fields."
argument_list|)
throw|;
block|}
comment|// We don't attempt to parse the default value until here because for
comment|// enums we need the enum type's descriptor.
if|if
condition|(
name|proto
operator|.
name|hasDefaultValue
argument_list|()
condition|)
block|{
if|if
condition|(
name|isRepeated
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|this
argument_list|,
literal|"Repeated fields cannot have default values."
argument_list|)
throw|;
block|}
try|try
block|{
switch|switch
condition|(
name|getType
argument_list|()
condition|)
block|{
case|case
name|INT32
case|:
case|case
name|SINT32
case|:
case|case
name|SFIXED32
case|:
name|defaultValue
operator|=
name|TextFormat
operator|.
name|parseInt32
argument_list|(
name|proto
operator|.
name|getDefaultValue
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|UINT32
case|:
case|case
name|FIXED32
case|:
name|defaultValue
operator|=
name|TextFormat
operator|.
name|parseUInt32
argument_list|(
name|proto
operator|.
name|getDefaultValue
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|INT64
case|:
case|case
name|SINT64
case|:
case|case
name|SFIXED64
case|:
name|defaultValue
operator|=
name|TextFormat
operator|.
name|parseInt64
argument_list|(
name|proto
operator|.
name|getDefaultValue
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|UINT64
case|:
case|case
name|FIXED64
case|:
name|defaultValue
operator|=
name|TextFormat
operator|.
name|parseUInt64
argument_list|(
name|proto
operator|.
name|getDefaultValue
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
if|if
condition|(
name|proto
operator|.
name|getDefaultValue
argument_list|()
operator|.
name|equals
argument_list|(
literal|"inf"
argument_list|)
condition|)
block|{
name|defaultValue
operator|=
name|Float
operator|.
name|POSITIVE_INFINITY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|proto
operator|.
name|getDefaultValue
argument_list|()
operator|.
name|equals
argument_list|(
literal|"-inf"
argument_list|)
condition|)
block|{
name|defaultValue
operator|=
name|Float
operator|.
name|NEGATIVE_INFINITY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|proto
operator|.
name|getDefaultValue
argument_list|()
operator|.
name|equals
argument_list|(
literal|"nan"
argument_list|)
condition|)
block|{
name|defaultValue
operator|=
name|Float
operator|.
name|NaN
expr_stmt|;
block|}
else|else
block|{
name|defaultValue
operator|=
name|Float
operator|.
name|valueOf
argument_list|(
name|proto
operator|.
name|getDefaultValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DOUBLE
case|:
if|if
condition|(
name|proto
operator|.
name|getDefaultValue
argument_list|()
operator|.
name|equals
argument_list|(
literal|"inf"
argument_list|)
condition|)
block|{
name|defaultValue
operator|=
name|Double
operator|.
name|POSITIVE_INFINITY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|proto
operator|.
name|getDefaultValue
argument_list|()
operator|.
name|equals
argument_list|(
literal|"-inf"
argument_list|)
condition|)
block|{
name|defaultValue
operator|=
name|Double
operator|.
name|NEGATIVE_INFINITY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|proto
operator|.
name|getDefaultValue
argument_list|()
operator|.
name|equals
argument_list|(
literal|"nan"
argument_list|)
condition|)
block|{
name|defaultValue
operator|=
name|Double
operator|.
name|NaN
expr_stmt|;
block|}
else|else
block|{
name|defaultValue
operator|=
name|Double
operator|.
name|valueOf
argument_list|(
name|proto
operator|.
name|getDefaultValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BOOL
case|:
name|defaultValue
operator|=
name|Boolean
operator|.
name|valueOf
argument_list|(
name|proto
operator|.
name|getDefaultValue
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|defaultValue
operator|=
name|proto
operator|.
name|getDefaultValue
argument_list|()
expr_stmt|;
break|break;
case|case
name|BYTES
case|:
try|try
block|{
name|defaultValue
operator|=
name|TextFormat
operator|.
name|unescapeBytes
argument_list|(
name|proto
operator|.
name|getDefaultValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TextFormat
operator|.
name|InvalidEscapeSequenceException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|this
argument_list|,
literal|"Couldn't parse default value: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
break|break;
case|case
name|ENUM
case|:
name|defaultValue
operator|=
name|enumType
operator|.
name|findValueByName
argument_list|(
name|proto
operator|.
name|getDefaultValue
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|defaultValue
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|this
argument_list|,
literal|"Unknown enum default value: \""
operator|+
name|proto
operator|.
name|getDefaultValue
argument_list|()
operator|+
literal|'\"'
argument_list|)
throw|;
block|}
break|break;
case|case
name|MESSAGE
case|:
case|case
name|GROUP
case|:
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|this
argument_list|,
literal|"Message type had default value."
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|this
argument_list|,
literal|"Could not parse default value: \""
operator|+
name|proto
operator|.
name|getDefaultValue
argument_list|()
operator|+
literal|'\"'
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// Determine the default default for this field.
if|if
condition|(
name|isRepeated
argument_list|()
condition|)
block|{
name|defaultValue
operator|=
name|Collections
operator|.
name|emptyList
argument_list|()
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|getJavaType
argument_list|()
condition|)
block|{
case|case
name|ENUM
case|:
comment|// We guarantee elsewhere that an enum type always has at least
comment|// one possible value.
name|defaultValue
operator|=
name|enumType
operator|.
name|getValues
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MESSAGE
case|:
name|defaultValue
operator|=
literal|null
expr_stmt|;
break|break;
default|default:
name|defaultValue
operator|=
name|getJavaType
argument_list|()
operator|.
name|defaultDefault
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|isExtension
argument_list|()
condition|)
block|{
name|file
operator|.
name|pool
operator|.
name|addFieldByNumber
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|containingType
operator|!=
literal|null
operator|&&
name|containingType
operator|.
name|getOptions
argument_list|()
operator|.
name|getMessageSetWireFormat
argument_list|()
condition|)
block|{
if|if
condition|(
name|isExtension
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|isOptional
argument_list|()
operator|||
name|getType
argument_list|()
operator|!=
name|Type
operator|.
name|MESSAGE
condition|)
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|this
argument_list|,
literal|"Extensions of MessageSets must be optional messages."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|this
argument_list|,
literal|"MessageSets cannot have fields, only extensions."
argument_list|)
throw|;
block|}
block|}
block|}
end_function

begin_comment
comment|/** See {@link FileDescriptor#setProto}. */
end_comment

begin_function
specifier|private
name|void
name|setProto
parameter_list|(
specifier|final
name|FieldDescriptorProto
name|proto
parameter_list|)
block|{
name|this
operator|.
name|proto
operator|=
name|proto
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * For internal use only.  This is to satisfy the FieldDescriptorLite      * interface.      */
end_comment

begin_function
annotation|@
name|Override
specifier|public
name|MessageLite
operator|.
name|Builder
name|internalMergeFrom
parameter_list|(
name|MessageLite
operator|.
name|Builder
name|to
parameter_list|,
name|MessageLite
name|from
parameter_list|)
block|{
comment|// FieldDescriptors are only used with non-lite messages so we can just
comment|// down-cast and call mergeFrom directly.
return|return
operator|(
operator|(
name|Message
operator|.
name|Builder
operator|)
name|to
operator|)
operator|.
name|mergeFrom
argument_list|(
operator|(
name|Message
operator|)
name|from
argument_list|)
return|;
block|}
end_function

begin_comment
unit|}
comment|// =================================================================
end_comment

begin_comment
comment|/** Describes an enum type. */
end_comment

begin_class
unit|public
specifier|static
specifier|final
class|class
name|EnumDescriptor
extends|extends
name|GenericDescriptor
implements|implements
name|Internal
operator|.
name|EnumLiteMap
argument_list|<
name|EnumValueDescriptor
argument_list|>
block|{
comment|/**      * Get the index of this descriptor within its parent.      * @see Descriptors.Descriptor#getIndex()      */
specifier|public
name|int
name|getIndex
parameter_list|()
block|{
return|return
name|index
return|;
block|}
comment|/** Convert the descriptor to its protocol message representation. */
annotation|@
name|Override
specifier|public
name|EnumDescriptorProto
name|toProto
parameter_list|()
block|{
return|return
name|proto
return|;
block|}
comment|/** Get the type's unqualified name. */
annotation|@
name|Override
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getName
argument_list|()
return|;
block|}
comment|/**      * Get the type's fully-qualified name.      * @see Descriptors.Descriptor#getFullName()      */
annotation|@
name|Override
specifier|public
name|String
name|getFullName
parameter_list|()
block|{
return|return
name|fullName
return|;
block|}
comment|/** Get the {@link FileDescriptor} containing this descriptor. */
annotation|@
name|Override
specifier|public
name|FileDescriptor
name|getFile
parameter_list|()
block|{
return|return
name|file
return|;
block|}
comment|/** If this is a nested type, get the outer descriptor, otherwise null. */
specifier|public
name|Descriptor
name|getContainingType
parameter_list|()
block|{
return|return
name|containingType
return|;
block|}
comment|/** Get the {@code EnumOptions}, defined in {@code descriptor.proto}. */
specifier|public
name|EnumOptions
name|getOptions
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getOptions
argument_list|()
return|;
block|}
comment|/** Get a list of defined values for this enum. */
specifier|public
name|List
argument_list|<
name|EnumValueDescriptor
argument_list|>
name|getValues
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|values
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Find an enum value by name.      * @param name The unqualified name of the value (e.g. "FOO").      * @return the value's descriptor, or {@code null} if not found.      */
specifier|public
name|EnumValueDescriptor
name|findValueByName
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
block|{
specifier|final
name|GenericDescriptor
name|result
init|=
name|file
operator|.
name|pool
operator|.
name|findSymbol
argument_list|(
name|fullName
operator|+
literal|'.'
operator|+
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
operator|&&
name|result
operator|instanceof
name|EnumValueDescriptor
condition|)
block|{
return|return
operator|(
name|EnumValueDescriptor
operator|)
name|result
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Find an enum value by number.  If multiple enum values have the same      * number, this returns the first defined value with that number.      * @param number The value's number.      * @return the value's descriptor, or {@code null} if not found.      */
annotation|@
name|Override
specifier|public
name|EnumValueDescriptor
name|findValueByNumber
parameter_list|(
specifier|final
name|int
name|number
parameter_list|)
block|{
return|return
name|file
operator|.
name|pool
operator|.
name|enumValuesByNumber
operator|.
name|get
argument_list|(
operator|new
name|DescriptorPool
operator|.
name|DescriptorIntPair
argument_list|(
name|this
argument_list|,
name|number
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Get the enum value for a number. If no enum value has this number,      * construct an EnumValueDescriptor for it.      */
specifier|public
name|EnumValueDescriptor
name|findValueByNumberCreatingIfUnknown
parameter_list|(
specifier|final
name|int
name|number
parameter_list|)
block|{
name|EnumValueDescriptor
name|result
init|=
name|findValueByNumber
argument_list|(
name|number
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
return|return
name|result
return|;
block|}
comment|// The number represents an unknown enum value.
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// Descriptors are compared by object identity so for the same number
comment|// we need to return the same EnumValueDescriptor object. This means
comment|// we have to store created EnumValueDescriptors. However, as there
comment|// are potentially 2G unknown enum values, storing all of these
comment|// objects persistently will consume lots of memory for long-running
comment|// services and it's also unnecessary as not many EnumValueDescriptors
comment|// will be used at the same time.
comment|//
comment|// To solve the problem we take advantage of Java's weak references and
comment|// rely on gc to release unused descriptors.
comment|//
comment|// Here is how it works:
comment|//   * We store unknown EnumValueDescriptors in a WeakHashMap with the
comment|//     value being a weak reference to the descriptor.
comment|//   * The descriptor holds a strong reference to the key so as long
comment|//     as the EnumValueDescriptor is in use, the key will be there
comment|//     and the corresponding map entry will be there. Following-up
comment|//     queries with the same number will return the same descriptor.
comment|//   * If the user no longer uses an unknown EnumValueDescriptor,
comment|//     it will be gc-ed since we only hold a weak reference to it in
comment|//     the map. The key in the corresponding map entry will also be
comment|//     gc-ed as the only strong reference to it is in the descriptor
comment|//     which is just gc-ed. With the key being gone WeakHashMap will
comment|//     then remove the whole entry. This way unknown descriptors will
comment|//     be freed automatically and we don't need to do anything to
comment|//     clean-up unused map entries.
comment|// Note: We must use "new Integer(number)" here because we don't want
comment|// these Integer objects to be cached.
name|Integer
name|key
init|=
operator|new
name|Integer
argument_list|(
name|number
argument_list|)
decl_stmt|;
name|WeakReference
argument_list|<
name|EnumValueDescriptor
argument_list|>
name|reference
init|=
name|unknownValues
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|reference
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
name|reference
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|result
operator|=
operator|new
name|EnumValueDescriptor
argument_list|(
name|file
argument_list|,
name|this
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|unknownValues
operator|.
name|put
argument_list|(
name|key
argument_list|,
operator|new
name|WeakReference
argument_list|<
name|EnumValueDescriptor
argument_list|>
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|// Used in tests only.
name|int
name|getUnknownEnumValueDescriptorCount
parameter_list|()
block|{
return|return
name|unknownValues
operator|.
name|size
argument_list|()
return|;
block|}
specifier|private
specifier|final
name|int
name|index
decl_stmt|;
specifier|private
name|EnumDescriptorProto
name|proto
decl_stmt|;
specifier|private
specifier|final
name|String
name|fullName
decl_stmt|;
specifier|private
specifier|final
name|FileDescriptor
name|file
decl_stmt|;
specifier|private
specifier|final
name|Descriptor
name|containingType
decl_stmt|;
specifier|private
name|EnumValueDescriptor
index|[]
name|values
decl_stmt|;
specifier|private
specifier|final
name|WeakHashMap
argument_list|<
name|Integer
argument_list|,
name|WeakReference
argument_list|<
name|EnumValueDescriptor
argument_list|>
argument_list|>
name|unknownValues
init|=
operator|new
name|WeakHashMap
argument_list|<
name|Integer
argument_list|,
name|WeakReference
argument_list|<
name|EnumValueDescriptor
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|EnumDescriptor
parameter_list|(
specifier|final
name|EnumDescriptorProto
name|proto
parameter_list|,
specifier|final
name|FileDescriptor
name|file
parameter_list|,
specifier|final
name|Descriptor
name|parent
parameter_list|,
specifier|final
name|int
name|index
parameter_list|)
throws|throws
name|DescriptorValidationException
block|{
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
name|this
operator|.
name|proto
operator|=
name|proto
expr_stmt|;
name|fullName
operator|=
name|computeFullName
argument_list|(
name|file
argument_list|,
name|parent
argument_list|,
name|proto
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|file
operator|=
name|file
expr_stmt|;
name|containingType
operator|=
name|parent
expr_stmt|;
if|if
condition|(
name|proto
operator|.
name|getValueCount
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// We cannot allow enums with no values because this would mean there
comment|// would be no valid default value for fields of this type.
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|this
argument_list|,
literal|"Enums must contain at least one value."
argument_list|)
throw|;
block|}
name|values
operator|=
operator|new
name|EnumValueDescriptor
index|[
name|proto
operator|.
name|getValueCount
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|proto
operator|.
name|getValueCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|values
index|[
name|i
index|]
operator|=
operator|new
name|EnumValueDescriptor
argument_list|(
name|proto
operator|.
name|getValue
argument_list|(
name|i
argument_list|)
argument_list|,
name|file
argument_list|,
name|this
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|file
operator|.
name|pool
operator|.
name|addSymbol
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/** See {@link FileDescriptor#setProto}. */
specifier|private
name|void
name|setProto
parameter_list|(
specifier|final
name|EnumDescriptorProto
name|proto
parameter_list|)
block|{
name|this
operator|.
name|proto
operator|=
name|proto
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|values
index|[
name|i
index|]
operator|.
name|setProto
argument_list|(
name|proto
operator|.
name|getValue
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// =================================================================
end_comment

begin_comment
comment|/**    * Describes one value within an enum type.  Note that multiple defined    * values may have the same number.  In generated Java code, all values    * with the same number after the first become aliases of the first.    * However, they still have independent EnumValueDescriptors.    */
end_comment

begin_class
specifier|public
specifier|static
specifier|final
class|class
name|EnumValueDescriptor
extends|extends
name|GenericDescriptor
implements|implements
name|Internal
operator|.
name|EnumLite
block|{
comment|/**      * Get the index of this descriptor within its parent.      * @see Descriptors.Descriptor#getIndex()      */
specifier|public
name|int
name|getIndex
parameter_list|()
block|{
return|return
name|index
return|;
block|}
comment|/** Convert the descriptor to its protocol message representation. */
annotation|@
name|Override
specifier|public
name|EnumValueDescriptorProto
name|toProto
parameter_list|()
block|{
return|return
name|proto
return|;
block|}
comment|/** Get the value's unqualified name. */
annotation|@
name|Override
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getName
argument_list|()
return|;
block|}
comment|/** Get the value's number. */
annotation|@
name|Override
specifier|public
name|int
name|getNumber
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getNumber
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getName
argument_list|()
return|;
block|}
comment|/**      * Get the value's fully-qualified name.      * @see Descriptors.Descriptor#getFullName()      */
annotation|@
name|Override
specifier|public
name|String
name|getFullName
parameter_list|()
block|{
return|return
name|fullName
return|;
block|}
comment|/** Get the {@link FileDescriptor} containing this descriptor. */
annotation|@
name|Override
specifier|public
name|FileDescriptor
name|getFile
parameter_list|()
block|{
return|return
name|file
return|;
block|}
comment|/** Get the value's enum type. */
specifier|public
name|EnumDescriptor
name|getType
parameter_list|()
block|{
return|return
name|type
return|;
block|}
comment|/**      * Get the {@code EnumValueOptions}, defined in {@code descriptor.proto}.      */
specifier|public
name|EnumValueOptions
name|getOptions
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getOptions
argument_list|()
return|;
block|}
specifier|private
specifier|final
name|int
name|index
decl_stmt|;
specifier|private
name|EnumValueDescriptorProto
name|proto
decl_stmt|;
specifier|private
specifier|final
name|String
name|fullName
decl_stmt|;
specifier|private
specifier|final
name|FileDescriptor
name|file
decl_stmt|;
specifier|private
specifier|final
name|EnumDescriptor
name|type
decl_stmt|;
specifier|private
name|EnumValueDescriptor
parameter_list|(
specifier|final
name|EnumValueDescriptorProto
name|proto
parameter_list|,
specifier|final
name|FileDescriptor
name|file
parameter_list|,
specifier|final
name|EnumDescriptor
name|parent
parameter_list|,
specifier|final
name|int
name|index
parameter_list|)
throws|throws
name|DescriptorValidationException
block|{
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
name|this
operator|.
name|proto
operator|=
name|proto
expr_stmt|;
name|this
operator|.
name|file
operator|=
name|file
expr_stmt|;
name|type
operator|=
name|parent
expr_stmt|;
name|fullName
operator|=
name|parent
operator|.
name|getFullName
argument_list|()
operator|+
literal|'.'
operator|+
name|proto
operator|.
name|getName
argument_list|()
expr_stmt|;
name|file
operator|.
name|pool
operator|.
name|addSymbol
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|file
operator|.
name|pool
operator|.
name|addEnumValueByNumber
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
specifier|private
name|Integer
name|number
decl_stmt|;
comment|// Create an unknown enum value.
specifier|private
name|EnumValueDescriptor
parameter_list|(
specifier|final
name|FileDescriptor
name|file
parameter_list|,
specifier|final
name|EnumDescriptor
name|parent
parameter_list|,
specifier|final
name|Integer
name|number
parameter_list|)
block|{
name|String
name|name
init|=
literal|"UNKNOWN_ENUM_VALUE_"
operator|+
name|parent
operator|.
name|getName
argument_list|()
operator|+
literal|"_"
operator|+
name|number
decl_stmt|;
name|EnumValueDescriptorProto
name|proto
init|=
name|EnumValueDescriptorProto
operator|.
name|newBuilder
argument_list|()
operator|.
name|setName
argument_list|(
name|name
argument_list|)
operator|.
name|setNumber
argument_list|(
name|number
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|this
operator|.
name|index
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|proto
operator|=
name|proto
expr_stmt|;
name|this
operator|.
name|file
operator|=
name|file
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|parent
expr_stmt|;
name|this
operator|.
name|fullName
operator|=
name|parent
operator|.
name|getFullName
argument_list|()
operator|+
literal|'.'
operator|+
name|proto
operator|.
name|getName
argument_list|()
expr_stmt|;
name|this
operator|.
name|number
operator|=
name|number
expr_stmt|;
comment|// Don't add this descriptor into pool.
block|}
comment|/** See {@link FileDescriptor#setProto}. */
specifier|private
name|void
name|setProto
parameter_list|(
specifier|final
name|EnumValueDescriptorProto
name|proto
parameter_list|)
block|{
name|this
operator|.
name|proto
operator|=
name|proto
expr_stmt|;
block|}
block|}
end_class

begin_comment
comment|// =================================================================
end_comment

begin_comment
comment|/** Describes a service type. */
end_comment

begin_class
specifier|public
specifier|static
specifier|final
class|class
name|ServiceDescriptor
extends|extends
name|GenericDescriptor
block|{
comment|/**      * Get the index of this descriptor within its parent.      * * @see Descriptors.Descriptor#getIndex()      */
specifier|public
name|int
name|getIndex
parameter_list|()
block|{
return|return
name|index
return|;
block|}
comment|/** Convert the descriptor to its protocol message representation. */
annotation|@
name|Override
specifier|public
name|ServiceDescriptorProto
name|toProto
parameter_list|()
block|{
return|return
name|proto
return|;
block|}
comment|/** Get the type's unqualified name. */
annotation|@
name|Override
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getName
argument_list|()
return|;
block|}
comment|/**      * Get the type's fully-qualified name.      * @see Descriptors.Descriptor#getFullName()      */
annotation|@
name|Override
specifier|public
name|String
name|getFullName
parameter_list|()
block|{
return|return
name|fullName
return|;
block|}
comment|/** Get the {@link FileDescriptor} containing this descriptor. */
annotation|@
name|Override
specifier|public
name|FileDescriptor
name|getFile
parameter_list|()
block|{
return|return
name|file
return|;
block|}
comment|/** Get the {@code ServiceOptions}, defined in {@code descriptor.proto}. */
specifier|public
name|ServiceOptions
name|getOptions
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getOptions
argument_list|()
return|;
block|}
comment|/** Get a list of methods for this service. */
specifier|public
name|List
argument_list|<
name|MethodDescriptor
argument_list|>
name|getMethods
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|methods
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Find a method by name.      * @param name The unqualified name of the method (e.g. "Foo").      * @return the method's descriptor, or {@code null} if not found.      */
specifier|public
name|MethodDescriptor
name|findMethodByName
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
block|{
specifier|final
name|GenericDescriptor
name|result
init|=
name|file
operator|.
name|pool
operator|.
name|findSymbol
argument_list|(
name|fullName
operator|+
literal|'.'
operator|+
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
operator|&&
name|result
operator|instanceof
name|MethodDescriptor
condition|)
block|{
return|return
operator|(
name|MethodDescriptor
operator|)
name|result
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|private
specifier|final
name|int
name|index
decl_stmt|;
specifier|private
name|ServiceDescriptorProto
name|proto
decl_stmt|;
specifier|private
specifier|final
name|String
name|fullName
decl_stmt|;
specifier|private
specifier|final
name|FileDescriptor
name|file
decl_stmt|;
specifier|private
name|MethodDescriptor
index|[]
name|methods
decl_stmt|;
specifier|private
name|ServiceDescriptor
parameter_list|(
specifier|final
name|ServiceDescriptorProto
name|proto
parameter_list|,
specifier|final
name|FileDescriptor
name|file
parameter_list|,
specifier|final
name|int
name|index
parameter_list|)
throws|throws
name|DescriptorValidationException
block|{
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
name|this
operator|.
name|proto
operator|=
name|proto
expr_stmt|;
name|fullName
operator|=
name|computeFullName
argument_list|(
name|file
argument_list|,
literal|null
argument_list|,
name|proto
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|file
operator|=
name|file
expr_stmt|;
name|methods
operator|=
operator|new
name|MethodDescriptor
index|[
name|proto
operator|.
name|getMethodCount
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|proto
operator|.
name|getMethodCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|methods
index|[
name|i
index|]
operator|=
operator|new
name|MethodDescriptor
argument_list|(
name|proto
operator|.
name|getMethod
argument_list|(
name|i
argument_list|)
argument_list|,
name|file
argument_list|,
name|this
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|file
operator|.
name|pool
operator|.
name|addSymbol
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|crossLink
parameter_list|()
throws|throws
name|DescriptorValidationException
block|{
for|for
control|(
specifier|final
name|MethodDescriptor
name|method
range|:
name|methods
control|)
block|{
name|method
operator|.
name|crossLink
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** See {@link FileDescriptor#setProto}. */
specifier|private
name|void
name|setProto
parameter_list|(
specifier|final
name|ServiceDescriptorProto
name|proto
parameter_list|)
block|{
name|this
operator|.
name|proto
operator|=
name|proto
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|methods
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|methods
index|[
name|i
index|]
operator|.
name|setProto
argument_list|(
name|proto
operator|.
name|getMethod
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// =================================================================
end_comment

begin_comment
comment|/**    * Describes one method within a service type.    */
end_comment

begin_class
specifier|public
specifier|static
specifier|final
class|class
name|MethodDescriptor
extends|extends
name|GenericDescriptor
block|{
comment|/**      * Get the index of this descriptor within its parent.      * * @see Descriptors.Descriptor#getIndex()      */
specifier|public
name|int
name|getIndex
parameter_list|()
block|{
return|return
name|index
return|;
block|}
comment|/** Convert the descriptor to its protocol message representation. */
annotation|@
name|Override
specifier|public
name|MethodDescriptorProto
name|toProto
parameter_list|()
block|{
return|return
name|proto
return|;
block|}
comment|/** Get the method's unqualified name. */
annotation|@
name|Override
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getName
argument_list|()
return|;
block|}
comment|/**      * Get the method's fully-qualified name.      * @see Descriptors.Descriptor#getFullName()      */
annotation|@
name|Override
specifier|public
name|String
name|getFullName
parameter_list|()
block|{
return|return
name|fullName
return|;
block|}
comment|/** Get the {@link FileDescriptor} containing this descriptor. */
annotation|@
name|Override
specifier|public
name|FileDescriptor
name|getFile
parameter_list|()
block|{
return|return
name|file
return|;
block|}
comment|/** Get the method's service type. */
specifier|public
name|ServiceDescriptor
name|getService
parameter_list|()
block|{
return|return
name|service
return|;
block|}
comment|/** Get the method's input type. */
specifier|public
name|Descriptor
name|getInputType
parameter_list|()
block|{
return|return
name|inputType
return|;
block|}
comment|/** Get the method's output type. */
specifier|public
name|Descriptor
name|getOutputType
parameter_list|()
block|{
return|return
name|outputType
return|;
block|}
comment|/**      * Get the {@code MethodOptions}, defined in {@code descriptor.proto}.      */
specifier|public
name|MethodOptions
name|getOptions
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getOptions
argument_list|()
return|;
block|}
specifier|private
specifier|final
name|int
name|index
decl_stmt|;
specifier|private
name|MethodDescriptorProto
name|proto
decl_stmt|;
specifier|private
specifier|final
name|String
name|fullName
decl_stmt|;
specifier|private
specifier|final
name|FileDescriptor
name|file
decl_stmt|;
specifier|private
specifier|final
name|ServiceDescriptor
name|service
decl_stmt|;
comment|// Initialized during cross-linking.
specifier|private
name|Descriptor
name|inputType
decl_stmt|;
specifier|private
name|Descriptor
name|outputType
decl_stmt|;
specifier|private
name|MethodDescriptor
parameter_list|(
specifier|final
name|MethodDescriptorProto
name|proto
parameter_list|,
specifier|final
name|FileDescriptor
name|file
parameter_list|,
specifier|final
name|ServiceDescriptor
name|parent
parameter_list|,
specifier|final
name|int
name|index
parameter_list|)
throws|throws
name|DescriptorValidationException
block|{
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
name|this
operator|.
name|proto
operator|=
name|proto
expr_stmt|;
name|this
operator|.
name|file
operator|=
name|file
expr_stmt|;
name|service
operator|=
name|parent
expr_stmt|;
name|fullName
operator|=
name|parent
operator|.
name|getFullName
argument_list|()
operator|+
literal|'.'
operator|+
name|proto
operator|.
name|getName
argument_list|()
expr_stmt|;
name|file
operator|.
name|pool
operator|.
name|addSymbol
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|crossLink
parameter_list|()
throws|throws
name|DescriptorValidationException
block|{
specifier|final
name|GenericDescriptor
name|input
init|=
name|file
operator|.
name|pool
operator|.
name|lookupSymbol
argument_list|(
name|proto
operator|.
name|getInputType
argument_list|()
argument_list|,
name|this
argument_list|,
name|DescriptorPool
operator|.
name|SearchFilter
operator|.
name|TYPES_ONLY
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|input
operator|instanceof
name|Descriptor
operator|)
condition|)
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|this
argument_list|,
literal|'\"'
operator|+
name|proto
operator|.
name|getInputType
argument_list|()
operator|+
literal|"\" is not a message type."
argument_list|)
throw|;
block|}
name|inputType
operator|=
operator|(
name|Descriptor
operator|)
name|input
expr_stmt|;
specifier|final
name|GenericDescriptor
name|output
init|=
name|file
operator|.
name|pool
operator|.
name|lookupSymbol
argument_list|(
name|proto
operator|.
name|getOutputType
argument_list|()
argument_list|,
name|this
argument_list|,
name|DescriptorPool
operator|.
name|SearchFilter
operator|.
name|TYPES_ONLY
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|output
operator|instanceof
name|Descriptor
operator|)
condition|)
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|this
argument_list|,
literal|'\"'
operator|+
name|proto
operator|.
name|getOutputType
argument_list|()
operator|+
literal|"\" is not a message type."
argument_list|)
throw|;
block|}
name|outputType
operator|=
operator|(
name|Descriptor
operator|)
name|output
expr_stmt|;
block|}
comment|/** See {@link FileDescriptor#setProto}. */
specifier|private
name|void
name|setProto
parameter_list|(
specifier|final
name|MethodDescriptorProto
name|proto
parameter_list|)
block|{
name|this
operator|.
name|proto
operator|=
name|proto
expr_stmt|;
block|}
block|}
end_class

begin_comment
comment|// =================================================================
end_comment

begin_function
specifier|private
specifier|static
name|String
name|computeFullName
parameter_list|(
specifier|final
name|FileDescriptor
name|file
parameter_list|,
specifier|final
name|Descriptor
name|parent
parameter_list|,
specifier|final
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
return|return
name|parent
operator|.
name|getFullName
argument_list|()
operator|+
literal|'.'
operator|+
name|name
return|;
block|}
elseif|else
if|if
condition|(
name|file
operator|.
name|getPackage
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return
name|file
operator|.
name|getPackage
argument_list|()
operator|+
literal|'.'
operator|+
name|name
return|;
block|}
else|else
block|{
return|return
name|name
return|;
block|}
block|}
end_function

begin_comment
comment|// =================================================================
end_comment

begin_comment
comment|/**    * All descriptors implement this to make it easier to implement tools like    * {@code DescriptorPool}.<p>    *    * This class is public so that the methods it exposes can be called from    * outside of this package. However, it should only be subclassed from    * nested classes of Descriptors.    */
end_comment

begin_class
specifier|public
specifier|abstract
specifier|static
class|class
name|GenericDescriptor
block|{
specifier|public
specifier|abstract
name|Message
name|toProto
parameter_list|()
function_decl|;
specifier|public
specifier|abstract
name|String
name|getName
parameter_list|()
function_decl|;
specifier|public
specifier|abstract
name|String
name|getFullName
parameter_list|()
function_decl|;
specifier|public
specifier|abstract
name|FileDescriptor
name|getFile
parameter_list|()
function_decl|;
block|}
end_class

begin_comment
comment|/**    * Thrown when building descriptors fails because the source DescriptorProtos    * are not valid.    */
end_comment

begin_class
specifier|public
specifier|static
class|class
name|DescriptorValidationException
extends|extends
name|Exception
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5750205775490483148L
decl_stmt|;
comment|/** Gets the full name of the descriptor where the error occurred. */
specifier|public
name|String
name|getProblemSymbolName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
comment|/**      * Gets the protocol message representation of the invalid descriptor.      */
specifier|public
name|Message
name|getProblemProto
parameter_list|()
block|{
return|return
name|proto
return|;
block|}
comment|/**      * Gets a human-readable description of the error.      */
specifier|public
name|String
name|getDescription
parameter_list|()
block|{
return|return
name|description
return|;
block|}
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
specifier|private
specifier|final
name|Message
name|proto
decl_stmt|;
specifier|private
specifier|final
name|String
name|description
decl_stmt|;
specifier|private
name|DescriptorValidationException
parameter_list|(
specifier|final
name|GenericDescriptor
name|problemDescriptor
parameter_list|,
specifier|final
name|String
name|description
parameter_list|)
block|{
name|super
argument_list|(
name|problemDescriptor
operator|.
name|getFullName
argument_list|()
operator|+
literal|": "
operator|+
name|description
argument_list|)
expr_stmt|;
comment|// Note that problemDescriptor may be partially uninitialized, so we
comment|// don't want to expose it directly to the user.  So, we only provide
comment|// the name and the original proto.
name|name
operator|=
name|problemDescriptor
operator|.
name|getFullName
argument_list|()
expr_stmt|;
name|proto
operator|=
name|problemDescriptor
operator|.
name|toProto
argument_list|()
expr_stmt|;
name|this
operator|.
name|description
operator|=
name|description
expr_stmt|;
block|}
specifier|private
name|DescriptorValidationException
parameter_list|(
specifier|final
name|GenericDescriptor
name|problemDescriptor
parameter_list|,
specifier|final
name|String
name|description
parameter_list|,
specifier|final
name|Throwable
name|cause
parameter_list|)
block|{
name|this
argument_list|(
name|problemDescriptor
argument_list|,
name|description
argument_list|)
expr_stmt|;
name|initCause
argument_list|(
name|cause
argument_list|)
expr_stmt|;
block|}
specifier|private
name|DescriptorValidationException
parameter_list|(
specifier|final
name|FileDescriptor
name|problemDescriptor
parameter_list|,
specifier|final
name|String
name|description
parameter_list|)
block|{
name|super
argument_list|(
name|problemDescriptor
operator|.
name|getName
argument_list|()
operator|+
literal|": "
operator|+
name|description
argument_list|)
expr_stmt|;
comment|// Note that problemDescriptor may be partially uninitialized, so we
comment|// don't want to expose it directly to the user.  So, we only provide
comment|// the name and the original proto.
name|name
operator|=
name|problemDescriptor
operator|.
name|getName
argument_list|()
expr_stmt|;
name|proto
operator|=
name|problemDescriptor
operator|.
name|toProto
argument_list|()
expr_stmt|;
name|this
operator|.
name|description
operator|=
name|description
expr_stmt|;
block|}
block|}
end_class

begin_comment
comment|// =================================================================
end_comment

begin_comment
comment|/**    * A private helper class which contains lookup tables containing all the    * descriptors defined in a particular file.    */
end_comment

begin_class
specifier|private
specifier|static
specifier|final
class|class
name|DescriptorPool
block|{
comment|/** Defines what subclass of descriptors to search in the descriptor pool.      */
enum|enum
name|SearchFilter
block|{
name|TYPES_ONLY
block|,
name|AGGREGATES_ONLY
block|,
name|ALL_SYMBOLS
block|}
name|DescriptorPool
parameter_list|(
specifier|final
name|FileDescriptor
index|[]
name|dependencies
parameter_list|,
name|boolean
name|allowUnknownDependencies
parameter_list|)
block|{
name|this
operator|.
name|dependencies
operator|=
operator|new
name|HashSet
argument_list|<
name|FileDescriptor
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|allowUnknownDependencies
operator|=
name|allowUnknownDependencies
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dependencies
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|this
operator|.
name|dependencies
operator|.
name|add
argument_list|(
name|dependencies
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|importPublicDependencies
argument_list|(
name|dependencies
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|FileDescriptor
name|dependency
range|:
name|this
operator|.
name|dependencies
control|)
block|{
try|try
block|{
name|addPackage
argument_list|(
name|dependency
operator|.
name|getPackage
argument_list|()
argument_list|,
name|dependency
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DescriptorValidationException
name|e
parameter_list|)
block|{
comment|// Can't happen, because addPackage() only fails when the name
comment|// conflicts with a non-package, but we have not yet added any
comment|// non-packages at this point.
assert|assert
literal|false
assert|;
block|}
block|}
block|}
comment|/** Find and put public dependencies of the file into dependencies set.*/
specifier|private
name|void
name|importPublicDependencies
parameter_list|(
specifier|final
name|FileDescriptor
name|file
parameter_list|)
block|{
for|for
control|(
name|FileDescriptor
name|dependency
range|:
name|file
operator|.
name|getPublicDependencies
argument_list|()
control|)
block|{
if|if
condition|(
name|dependencies
operator|.
name|add
argument_list|(
name|dependency
argument_list|)
condition|)
block|{
name|importPublicDependencies
argument_list|(
name|dependency
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|final
name|Set
argument_list|<
name|FileDescriptor
argument_list|>
name|dependencies
decl_stmt|;
specifier|private
name|boolean
name|allowUnknownDependencies
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|GenericDescriptor
argument_list|>
name|descriptorsByName
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|GenericDescriptor
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|DescriptorIntPair
argument_list|,
name|FieldDescriptor
argument_list|>
name|fieldsByNumber
init|=
operator|new
name|HashMap
argument_list|<
name|DescriptorIntPair
argument_list|,
name|FieldDescriptor
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|DescriptorIntPair
argument_list|,
name|EnumValueDescriptor
argument_list|>
name|enumValuesByNumber
init|=
operator|new
name|HashMap
argument_list|<
name|DescriptorIntPair
argument_list|,
name|EnumValueDescriptor
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Find a generic descriptor by fully-qualified name. */
name|GenericDescriptor
name|findSymbol
parameter_list|(
specifier|final
name|String
name|fullName
parameter_list|)
block|{
return|return
name|findSymbol
argument_list|(
name|fullName
argument_list|,
name|SearchFilter
operator|.
name|ALL_SYMBOLS
argument_list|)
return|;
block|}
comment|/** Find a descriptor by fully-qualified name and given option to only      * search valid field type descriptors.      */
name|GenericDescriptor
name|findSymbol
parameter_list|(
specifier|final
name|String
name|fullName
parameter_list|,
specifier|final
name|SearchFilter
name|filter
parameter_list|)
block|{
name|GenericDescriptor
name|result
init|=
name|descriptorsByName
operator|.
name|get
argument_list|(
name|fullName
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|filter
operator|==
name|SearchFilter
operator|.
name|ALL_SYMBOLS
operator|)
operator|||
operator|(
operator|(
name|filter
operator|==
name|SearchFilter
operator|.
name|TYPES_ONLY
operator|)
operator|&&
name|isType
argument_list|(
name|result
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|filter
operator|==
name|SearchFilter
operator|.
name|AGGREGATES_ONLY
operator|)
operator|&&
name|isAggregate
argument_list|(
name|result
argument_list|)
operator|)
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
for|for
control|(
specifier|final
name|FileDescriptor
name|dependency
range|:
name|dependencies
control|)
block|{
name|result
operator|=
name|dependency
operator|.
name|pool
operator|.
name|descriptorsByName
operator|.
name|get
argument_list|(
name|fullName
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|filter
operator|==
name|SearchFilter
operator|.
name|ALL_SYMBOLS
operator|)
operator|||
operator|(
operator|(
name|filter
operator|==
name|SearchFilter
operator|.
name|TYPES_ONLY
operator|)
operator|&&
name|isType
argument_list|(
name|result
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|filter
operator|==
name|SearchFilter
operator|.
name|AGGREGATES_ONLY
operator|)
operator|&&
name|isAggregate
argument_list|(
name|result
argument_list|)
operator|)
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/** Checks if the descriptor is a valid type for a message field. */
name|boolean
name|isType
parameter_list|(
name|GenericDescriptor
name|descriptor
parameter_list|)
block|{
return|return
operator|(
name|descriptor
operator|instanceof
name|Descriptor
operator|)
operator|||
operator|(
name|descriptor
operator|instanceof
name|EnumDescriptor
operator|)
return|;
block|}
comment|/** Checks if the descriptor is a valid namespace type. */
name|boolean
name|isAggregate
parameter_list|(
name|GenericDescriptor
name|descriptor
parameter_list|)
block|{
return|return
operator|(
name|descriptor
operator|instanceof
name|Descriptor
operator|)
operator|||
operator|(
name|descriptor
operator|instanceof
name|EnumDescriptor
operator|)
operator|||
operator|(
name|descriptor
operator|instanceof
name|PackageDescriptor
operator|)
operator|||
operator|(
name|descriptor
operator|instanceof
name|ServiceDescriptor
operator|)
return|;
block|}
comment|/**      * Look up a type descriptor by name, relative to some other descriptor.      * The name may be fully-qualified (with a leading '.'),      * partially-qualified, or unqualified.  C++-like name lookup semantics      * are used to search for the matching descriptor.      */
name|GenericDescriptor
name|lookupSymbol
parameter_list|(
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|GenericDescriptor
name|relativeTo
parameter_list|,
specifier|final
name|DescriptorPool
operator|.
name|SearchFilter
name|filter
parameter_list|)
throws|throws
name|DescriptorValidationException
block|{
comment|// TODO(kenton):  This could be optimized in a number of ways.
name|GenericDescriptor
name|result
decl_stmt|;
name|String
name|fullname
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
comment|// Fully-qualified name.
name|fullname
operator|=
name|name
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|findSymbol
argument_list|(
name|fullname
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If "name" is a compound identifier, we want to search for the
comment|// first component of it, then search within it for the rest.
comment|// If name is something like "Foo.Bar.baz", and symbols named "Foo" are
comment|// defined in multiple parent scopes, we only want to find "Bar.baz" in
comment|// the innermost one.  E.g., the following should produce an error:
comment|//   message Bar { message Baz {} }
comment|//   message Foo {
comment|//     message Bar {
comment|//     }
comment|//     optional Bar.Baz baz = 1;
comment|//   }
comment|// So, we look for just "Foo" first, then look for "Bar.baz" within it
comment|// if found.
specifier|final
name|int
name|firstPartLength
init|=
name|name
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
specifier|final
name|String
name|firstPart
decl_stmt|;
if|if
condition|(
name|firstPartLength
operator|==
operator|-
literal|1
condition|)
block|{
name|firstPart
operator|=
name|name
expr_stmt|;
block|}
else|else
block|{
name|firstPart
operator|=
name|name
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|firstPartLength
argument_list|)
expr_stmt|;
block|}
comment|// We will search each parent scope of "relativeTo" looking for the
comment|// symbol.
specifier|final
name|StringBuilder
name|scopeToTry
init|=
operator|new
name|StringBuilder
argument_list|(
name|relativeTo
operator|.
name|getFullName
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|// Chop off the last component of the scope.
specifier|final
name|int
name|dotpos
init|=
name|scopeToTry
operator|.
name|lastIndexOf
argument_list|(
literal|"."
argument_list|)
decl_stmt|;
if|if
condition|(
name|dotpos
operator|==
operator|-
literal|1
condition|)
block|{
name|fullname
operator|=
name|name
expr_stmt|;
name|result
operator|=
name|findSymbol
argument_list|(
name|name
argument_list|,
name|filter
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|scopeToTry
operator|.
name|setLength
argument_list|(
name|dotpos
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// Append firstPart and try to find
name|scopeToTry
operator|.
name|append
argument_list|(
name|firstPart
argument_list|)
expr_stmt|;
name|result
operator|=
name|findSymbol
argument_list|(
name|scopeToTry
operator|.
name|toString
argument_list|()
argument_list|,
name|DescriptorPool
operator|.
name|SearchFilter
operator|.
name|AGGREGATES_ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|firstPartLength
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// We only found the first part of the symbol.  Now look for
comment|// the whole thing.  If this fails, we *don't* want to keep
comment|// searching parent scopes.
name|scopeToTry
operator|.
name|setLength
argument_list|(
name|dotpos
operator|+
literal|1
argument_list|)
expr_stmt|;
name|scopeToTry
operator|.
name|append
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|result
operator|=
name|findSymbol
argument_list|(
name|scopeToTry
operator|.
name|toString
argument_list|()
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
name|fullname
operator|=
name|scopeToTry
operator|.
name|toString
argument_list|()
expr_stmt|;
break|break;
block|}
comment|// Not found.  Remove the name so we can try again.
name|scopeToTry
operator|.
name|setLength
argument_list|(
name|dotpos
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|allowUnknownDependencies
operator|&&
name|filter
operator|==
name|SearchFilter
operator|.
name|TYPES_ONLY
condition|)
block|{
name|logger
operator|.
name|warning
argument_list|(
literal|"The descriptor for message type \""
operator|+
name|name
operator|+
literal|"\" can not be found and a placeholder is created for it"
argument_list|)
expr_stmt|;
comment|// We create a dummy message descriptor here regardless of the
comment|// expected type. If the type should be message, this dummy
comment|// descriptor will work well and if the type should be enum, a
comment|// DescriptorValidationException will be thrown latter. In either
comment|// case, the code works as expected: we allow unknown message types
comment|// but not unknwon enum types.
name|result
operator|=
operator|new
name|Descriptor
argument_list|(
name|fullname
argument_list|)
expr_stmt|;
comment|// Add the placeholder file as a dependency so we can find the
comment|// placeholder symbol when resolving other references.
name|this
operator|.
name|dependencies
operator|.
name|add
argument_list|(
name|result
operator|.
name|getFile
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|relativeTo
argument_list|,
literal|'\"'
operator|+
name|name
operator|+
literal|"\" is not defined."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
return|return
name|result
return|;
block|}
block|}
comment|/**      * Adds a symbol to the symbol table.  If a symbol with the same name      * already exists, throws an error.      */
name|void
name|addSymbol
parameter_list|(
specifier|final
name|GenericDescriptor
name|descriptor
parameter_list|)
throws|throws
name|DescriptorValidationException
block|{
name|validateSymbolName
argument_list|(
name|descriptor
argument_list|)
expr_stmt|;
specifier|final
name|String
name|fullName
init|=
name|descriptor
operator|.
name|getFullName
argument_list|()
decl_stmt|;
specifier|final
name|int
name|dotpos
init|=
name|fullName
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
specifier|final
name|GenericDescriptor
name|old
init|=
name|descriptorsByName
operator|.
name|put
argument_list|(
name|fullName
argument_list|,
name|descriptor
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
condition|)
block|{
name|descriptorsByName
operator|.
name|put
argument_list|(
name|fullName
argument_list|,
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|descriptor
operator|.
name|getFile
argument_list|()
operator|==
name|old
operator|.
name|getFile
argument_list|()
condition|)
block|{
if|if
condition|(
name|dotpos
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|descriptor
argument_list|,
literal|'\"'
operator|+
name|fullName
operator|+
literal|"\" is already defined."
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|descriptor
argument_list|,
literal|'\"'
operator|+
name|fullName
operator|.
name|substring
argument_list|(
name|dotpos
operator|+
literal|1
argument_list|)
operator|+
literal|"\" is already defined in \""
operator|+
name|fullName
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|dotpos
argument_list|)
operator|+
literal|"\"."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|descriptor
argument_list|,
literal|'\"'
operator|+
name|fullName
operator|+
literal|"\" is already defined in file \""
operator|+
name|old
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"\"."
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * Represents a package in the symbol table.  We use PackageDescriptors      * just as placeholders so that someone cannot define, say, a message type      * that has the same name as an existing package.      */
specifier|private
specifier|static
specifier|final
class|class
name|PackageDescriptor
extends|extends
name|GenericDescriptor
block|{
annotation|@
name|Override
specifier|public
name|Message
name|toProto
parameter_list|()
block|{
return|return
name|file
operator|.
name|toProto
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getFullName
parameter_list|()
block|{
return|return
name|fullName
return|;
block|}
annotation|@
name|Override
specifier|public
name|FileDescriptor
name|getFile
parameter_list|()
block|{
return|return
name|file
return|;
block|}
name|PackageDescriptor
parameter_list|(
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|String
name|fullName
parameter_list|,
specifier|final
name|FileDescriptor
name|file
parameter_list|)
block|{
name|this
operator|.
name|file
operator|=
name|file
expr_stmt|;
name|this
operator|.
name|fullName
operator|=
name|fullName
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
specifier|private
specifier|final
name|String
name|fullName
decl_stmt|;
specifier|private
specifier|final
name|FileDescriptor
name|file
decl_stmt|;
block|}
comment|/**      * Adds a package to the symbol tables.  If a package by the same name      * already exists, that is fine, but if some other kind of symbol exists      * under the same name, an exception is thrown.  If the package has      * multiple components, this also adds the parent package(s).      */
name|void
name|addPackage
parameter_list|(
specifier|final
name|String
name|fullName
parameter_list|,
specifier|final
name|FileDescriptor
name|file
parameter_list|)
throws|throws
name|DescriptorValidationException
block|{
specifier|final
name|int
name|dotpos
init|=
name|fullName
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
specifier|final
name|String
name|name
decl_stmt|;
if|if
condition|(
name|dotpos
operator|==
operator|-
literal|1
condition|)
block|{
name|name
operator|=
name|fullName
expr_stmt|;
block|}
else|else
block|{
name|addPackage
argument_list|(
name|fullName
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|dotpos
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|name
operator|=
name|fullName
operator|.
name|substring
argument_list|(
name|dotpos
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|final
name|GenericDescriptor
name|old
init|=
name|descriptorsByName
operator|.
name|put
argument_list|(
name|fullName
argument_list|,
operator|new
name|PackageDescriptor
argument_list|(
name|name
argument_list|,
name|fullName
argument_list|,
name|file
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
condition|)
block|{
name|descriptorsByName
operator|.
name|put
argument_list|(
name|fullName
argument_list|,
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|old
operator|instanceof
name|PackageDescriptor
operator|)
condition|)
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|file
argument_list|,
literal|'\"'
operator|+
name|name
operator|+
literal|"\" is already defined (as something other than a "
operator|+
literal|"package) in file \""
operator|+
name|old
operator|.
name|getFile
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"\"."
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** A (GenericDescriptor, int) pair, used as a map key. */
specifier|private
specifier|static
specifier|final
class|class
name|DescriptorIntPair
block|{
specifier|private
specifier|final
name|GenericDescriptor
name|descriptor
decl_stmt|;
specifier|private
specifier|final
name|int
name|number
decl_stmt|;
name|DescriptorIntPair
parameter_list|(
specifier|final
name|GenericDescriptor
name|descriptor
parameter_list|,
specifier|final
name|int
name|number
parameter_list|)
block|{
name|this
operator|.
name|descriptor
operator|=
name|descriptor
expr_stmt|;
name|this
operator|.
name|number
operator|=
name|number
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|descriptor
operator|.
name|hashCode
argument_list|()
operator|*
operator|(
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
operator|+
name|number
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
specifier|final
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|obj
operator|instanceof
name|DescriptorIntPair
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|DescriptorIntPair
name|other
init|=
operator|(
name|DescriptorIntPair
operator|)
name|obj
decl_stmt|;
return|return
name|descriptor
operator|==
name|other
operator|.
name|descriptor
operator|&&
name|number
operator|==
name|other
operator|.
name|number
return|;
block|}
block|}
comment|/**      * Adds a field to the fieldsByNumber table.  Throws an exception if a      * field with the same containing type and number already exists.      */
name|void
name|addFieldByNumber
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|)
throws|throws
name|DescriptorValidationException
block|{
specifier|final
name|DescriptorIntPair
name|key
init|=
operator|new
name|DescriptorIntPair
argument_list|(
name|field
operator|.
name|getContainingType
argument_list|()
argument_list|,
name|field
operator|.
name|getNumber
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|FieldDescriptor
name|old
init|=
name|fieldsByNumber
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
condition|)
block|{
name|fieldsByNumber
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|old
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|field
argument_list|,
literal|"Field number "
operator|+
name|field
operator|.
name|getNumber
argument_list|()
operator|+
literal|" has already been used in \""
operator|+
name|field
operator|.
name|getContainingType
argument_list|()
operator|.
name|getFullName
argument_list|()
operator|+
literal|"\" by field \""
operator|+
name|old
operator|.
name|getName
argument_list|()
operator|+
literal|"\"."
argument_list|)
throw|;
block|}
block|}
comment|/**      * Adds an enum value to the enumValuesByNumber table.  If an enum value      * with the same type and number already exists, does nothing.  (This is      * allowed; the first value define with the number takes precedence.)      */
name|void
name|addEnumValueByNumber
parameter_list|(
specifier|final
name|EnumValueDescriptor
name|value
parameter_list|)
block|{
specifier|final
name|DescriptorIntPair
name|key
init|=
operator|new
name|DescriptorIntPair
argument_list|(
name|value
operator|.
name|getType
argument_list|()
argument_list|,
name|value
operator|.
name|getNumber
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|EnumValueDescriptor
name|old
init|=
name|enumValuesByNumber
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
condition|)
block|{
name|enumValuesByNumber
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|old
argument_list|)
expr_stmt|;
comment|// Not an error:  Multiple enum values may have the same number, but
comment|// we only want the first one in the map.
block|}
block|}
comment|/**      * Verifies that the descriptor's name is valid (i.e. it contains only      * letters, digits, and underscores, and does not start with a digit).      */
specifier|static
name|void
name|validateSymbolName
parameter_list|(
specifier|final
name|GenericDescriptor
name|descriptor
parameter_list|)
throws|throws
name|DescriptorValidationException
block|{
specifier|final
name|String
name|name
init|=
name|descriptor
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|descriptor
argument_list|,
literal|"Missing name."
argument_list|)
throw|;
block|}
else|else
block|{
name|boolean
name|valid
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|name
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|char
name|c
init|=
name|name
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// Non-ASCII characters are not valid in protobuf identifiers, even
comment|// if they are letters or digits.
if|if
condition|(
name|c
operator|>=
literal|128
condition|)
block|{
name|valid
operator|=
literal|false
expr_stmt|;
block|}
comment|// First character must be letter or _.  Subsequent characters may
comment|// be letters, numbers, or digits.
if|if
condition|(
name|Character
operator|.
name|isLetter
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
operator|(
name|Character
operator|.
name|isDigit
argument_list|(
name|c
argument_list|)
operator|&&
name|i
operator|>
literal|0
operator|)
condition|)
block|{
comment|// Valid
block|}
else|else
block|{
name|valid
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|valid
condition|)
block|{
throw|throw
operator|new
name|DescriptorValidationException
argument_list|(
name|descriptor
argument_list|,
literal|'\"'
operator|+
name|name
operator|+
literal|"\" is not a valid identifier."
argument_list|)
throw|;
block|}
block|}
block|}
block|}
end_class

begin_comment
comment|/** Describes an oneof of a message type. */
end_comment

begin_class
specifier|public
specifier|static
specifier|final
class|class
name|OneofDescriptor
block|{
comment|/** Get the index of this descriptor within its parent. */
specifier|public
name|int
name|getIndex
parameter_list|()
block|{
return|return
name|index
return|;
block|}
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getName
argument_list|()
return|;
block|}
specifier|public
name|FileDescriptor
name|getFile
parameter_list|()
block|{
return|return
name|file
return|;
block|}
specifier|public
name|String
name|getFullName
parameter_list|()
block|{
return|return
name|fullName
return|;
block|}
specifier|public
name|Descriptor
name|getContainingType
parameter_list|()
block|{
return|return
name|containingType
return|;
block|}
specifier|public
name|int
name|getFieldCount
parameter_list|()
block|{
return|return
name|fieldCount
return|;
block|}
specifier|public
name|OneofOptions
name|getOptions
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getOptions
argument_list|()
return|;
block|}
comment|/** Get a list of this message type's fields. */
specifier|public
name|List
argument_list|<
name|FieldDescriptor
argument_list|>
name|getFields
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|fields
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|FieldDescriptor
name|getField
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|fields
index|[
name|index
index|]
return|;
block|}
specifier|private
name|void
name|setProto
parameter_list|(
specifier|final
name|OneofDescriptorProto
name|proto
parameter_list|)
block|{
name|this
operator|.
name|proto
operator|=
name|proto
expr_stmt|;
block|}
specifier|private
name|OneofDescriptor
parameter_list|(
specifier|final
name|OneofDescriptorProto
name|proto
parameter_list|,
specifier|final
name|FileDescriptor
name|file
parameter_list|,
specifier|final
name|Descriptor
name|parent
parameter_list|,
specifier|final
name|int
name|index
parameter_list|)
throws|throws
name|DescriptorValidationException
block|{
name|this
operator|.
name|proto
operator|=
name|proto
expr_stmt|;
name|fullName
operator|=
name|computeFullName
argument_list|(
name|file
argument_list|,
name|parent
argument_list|,
name|proto
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|file
operator|=
name|file
expr_stmt|;
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
name|containingType
operator|=
name|parent
expr_stmt|;
name|fieldCount
operator|=
literal|0
expr_stmt|;
block|}
specifier|private
specifier|final
name|int
name|index
decl_stmt|;
specifier|private
name|OneofDescriptorProto
name|proto
decl_stmt|;
specifier|private
specifier|final
name|String
name|fullName
decl_stmt|;
specifier|private
specifier|final
name|FileDescriptor
name|file
decl_stmt|;
specifier|private
name|Descriptor
name|containingType
decl_stmt|;
specifier|private
name|int
name|fieldCount
decl_stmt|;
specifier|private
name|FieldDescriptor
index|[]
name|fields
decl_stmt|;
block|}
end_class

unit|}
end_unit

