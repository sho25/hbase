begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|// Protocol Buffers - Google's data interchange format
end_comment

begin_comment
comment|// Copyright 2008 Google Inc.  All rights reserved.
end_comment

begin_comment
comment|// https://developers.google.com/protocol-buffers/
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Redistribution and use in source and binary forms, with or without
end_comment

begin_comment
comment|// modification, are permitted provided that the following conditions are
end_comment

begin_comment
comment|// met:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//     * Redistributions of source code must retain the above copyright
end_comment

begin_comment
comment|// notice, this list of conditions and the following disclaimer.
end_comment

begin_comment
comment|//     * Redistributions in binary form must reproduce the above
end_comment

begin_comment
comment|// copyright notice, this list of conditions and the following disclaimer
end_comment

begin_comment
comment|// in the documentation and/or other materials provided with the
end_comment

begin_comment
comment|// distribution.
end_comment

begin_comment
comment|//     * Neither the name of Google Inc. nor the names of its
end_comment

begin_comment
comment|// contributors may be used to endorse or promote products derived from
end_comment

begin_comment
comment|// this software without specific prior written permission.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
end_comment

begin_comment
comment|// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
end_comment

begin_comment
comment|// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
end_comment

begin_comment
comment|// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
end_comment

begin_comment
comment|// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
end_comment

begin_comment
comment|// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
end_comment

begin_comment
comment|// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
end_comment

begin_comment
comment|// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
end_comment

begin_comment
comment|// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InvalidObjectException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|UnsupportedCharsetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_comment
comment|/**  * Immutable sequence of bytes.  Substring is supported by sharing the reference  * to the immutable underlying bytes.  Concatenation is likewise supported  * without copying (long strings) by building a tree of pieces in  * {@link RopeByteString}.  *<p>  * Like {@link String}, the contents of a {@link ByteString} can never be  * observed to change, not even in the presence of a data race or incorrect  * API usage in the client code.  *  * @author crazybob@google.com Bob Lee  * @author kenton@google.com Kenton Varda  * @author carlanton@google.com Carl Haverl  * @author martinrb@google.com Martin Buchholz  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|ByteString
implements|implements
name|Iterable
argument_list|<
name|Byte
argument_list|>
implements|,
name|Serializable
block|{
comment|/**    * When two strings to be concatenated have a combined length shorter than    * this, we just copy their bytes on {@link #concat(ByteString)}.    * The trade-off is copy size versus the overhead of creating tree nodes    * in {@link RopeByteString}.    */
specifier|static
specifier|final
name|int
name|CONCATENATE_BY_COPY_SIZE
init|=
literal|128
decl_stmt|;
comment|/**    * When copying an InputStream into a ByteString with .readFrom(),    * the chunks in the underlying rope start at 256 bytes, but double    * each iteration up to 8192 bytes.    */
specifier|static
specifier|final
name|int
name|MIN_READ_FROM_CHUNK_SIZE
init|=
literal|0x100
decl_stmt|;
comment|// 256b
specifier|static
specifier|final
name|int
name|MAX_READ_FROM_CHUNK_SIZE
init|=
literal|0x2000
decl_stmt|;
comment|// 8k
comment|/**    * Empty {@code ByteString}.    */
specifier|public
specifier|static
specifier|final
name|ByteString
name|EMPTY
init|=
operator|new
name|LiteralByteString
argument_list|(
name|Internal
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|)
decl_stmt|;
comment|/**    * An interface to efficiently copy {@code byte[]}.    *    *<p>One of the noticeable costs of copying a byte[] into a new array using    * {@code System.arraycopy} is nullification of a new buffer before the copy. It has been shown    * the Hotspot VM is capable to intrisicfy {@code Arrays.copyOfRange} operation to avoid this    * expensive nullification and provide substantial performance gain. Unfortunately this does not    * hold on Android runtimes and could make the copy slightly slower due to additional code in    * the {@code Arrays.copyOfRange}. Thus we provide two different implementation for array copier    * for Hotspot and Android runtimes.    */
specifier|private
interface|interface
name|ByteArrayCopier
block|{
comment|/**      * Copies the specified range of the specified array into a new array      */
name|byte
index|[]
name|copyFrom
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
block|}
comment|/** Implementation of {@code ByteArrayCopier} which uses {@link System#arraycopy}. */
specifier|private
specifier|static
specifier|final
class|class
name|SystemByteArrayCopier
implements|implements
name|ByteArrayCopier
block|{
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|copyFrom
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|byte
index|[]
name|copy
init|=
operator|new
name|byte
index|[
name|size
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|copy
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
block|}
comment|/** Implementation of {@code ByteArrayCopier} which uses {@link Arrays#copyOfRange}. */
specifier|private
specifier|static
specifier|final
class|class
name|ArraysByteArrayCopier
implements|implements
name|ByteArrayCopier
block|{
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|copyFrom
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|size
parameter_list|)
block|{
return|return
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|offset
operator|+
name|size
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|ByteArrayCopier
name|byteArrayCopier
decl_stmt|;
static|static
block|{
name|boolean
name|isAndroid
init|=
literal|true
decl_stmt|;
try|try
block|{
name|Class
operator|.
name|forName
argument_list|(
literal|"android.content.Context"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
name|isAndroid
operator|=
literal|false
expr_stmt|;
block|}
name|byteArrayCopier
operator|=
name|isAndroid
condition|?
operator|new
name|SystemByteArrayCopier
argument_list|()
else|:
operator|new
name|ArraysByteArrayCopier
argument_list|()
expr_stmt|;
block|}
comment|/**    * Cached hash value. Intentionally accessed via a data race, which    * is safe because of the Java Memory Model's "no out-of-thin-air values"    * guarantees for ints. A value of 0 implies that the hash has not been set.    */
specifier|private
name|int
name|hash
init|=
literal|0
decl_stmt|;
comment|// This constructor is here to prevent subclassing outside of this package,
name|ByteString
parameter_list|()
block|{}
comment|/**    * Gets the byte at the given index. This method should be used only for    * random access to individual bytes. To access bytes sequentially, use the    * {@link ByteIterator} returned by {@link #iterator()}, and call {@link    * #substring(int, int)} first if necessary.    *    * @param index index of byte    * @return the value    * @throws IndexOutOfBoundsException {@code index< 0 or index>= size}    */
specifier|public
specifier|abstract
name|byte
name|byteAt
parameter_list|(
name|int
name|index
parameter_list|)
function_decl|;
comment|/**    * Return a {@link ByteString.ByteIterator} over the bytes in the ByteString.    * To avoid auto-boxing, you may get the iterator manually and call    * {@link ByteIterator#nextByte()}.    *    * @return the iterator    */
annotation|@
name|Override
specifier|public
specifier|final
name|ByteIterator
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|ByteIterator
argument_list|()
block|{
specifier|private
name|int
name|position
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|int
name|limit
init|=
name|size
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|position
operator|<
name|limit
return|;
block|}
annotation|@
name|Override
specifier|public
name|Byte
name|next
parameter_list|()
block|{
comment|// Boxing calls Byte.valueOf(byte), which does not instantiate.
return|return
name|nextByte
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
name|nextByte
parameter_list|()
block|{
try|try
block|{
return|return
name|byteAt
argument_list|(
name|position
operator|++
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
comment|/**    * This interface extends {@code Iterator<Byte>}, so that we can return an    * unboxed {@code byte}.    */
specifier|public
interface|interface
name|ByteIterator
extends|extends
name|Iterator
argument_list|<
name|Byte
argument_list|>
block|{
comment|/**      * An alternative to {@link Iterator#next()} that returns an      * unboxed primitive {@code byte}.      *      * @return the next {@code byte} in the iteration      * @throws NoSuchElementException if the iteration has no more elements      */
name|byte
name|nextByte
parameter_list|()
function_decl|;
block|}
comment|/**    * Gets the number of bytes.    *    * @return size in bytes    */
specifier|public
specifier|abstract
name|int
name|size
parameter_list|()
function_decl|;
comment|/**    * Returns {@code true} if the size is {@code 0}, {@code false} otherwise.    *    * @return true if this is zero bytes long    */
specifier|public
specifier|final
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|size
argument_list|()
operator|==
literal|0
return|;
block|}
comment|// =================================================================
comment|// ByteString -> substring
comment|/**    * Return the substring from {@code beginIndex}, inclusive, to the end of the    * string.    *    * @param beginIndex start at this index    * @return substring sharing underlying data    * @throws IndexOutOfBoundsException if {@code beginIndex< 0} or    *     {@code beginIndex> size()}.    */
specifier|public
specifier|final
name|ByteString
name|substring
parameter_list|(
name|int
name|beginIndex
parameter_list|)
block|{
return|return
name|substring
argument_list|(
name|beginIndex
argument_list|,
name|size
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Return the substring from {@code beginIndex}, inclusive, to {@code    * endIndex}, exclusive.    *    * @param beginIndex start at this index    * @param endIndex   the last character is the one before this index    * @return substring sharing underlying data    * @throws IndexOutOfBoundsException if {@code beginIndex< 0},    *     {@code endIndex> size()}, or {@code beginIndex> endIndex}.    */
specifier|public
specifier|abstract
name|ByteString
name|substring
parameter_list|(
name|int
name|beginIndex
parameter_list|,
name|int
name|endIndex
parameter_list|)
function_decl|;
comment|/**    * Tests if this bytestring starts with the specified prefix.    * Similar to {@link String#startsWith(String)}    *    * @param prefix the prefix.    * @return<code>true</code> if the byte sequence represented by the    *         argument is a prefix of the byte sequence represented by    *         this string;<code>false</code> otherwise.    */
specifier|public
specifier|final
name|boolean
name|startsWith
parameter_list|(
name|ByteString
name|prefix
parameter_list|)
block|{
return|return
name|size
argument_list|()
operator|>=
name|prefix
operator|.
name|size
argument_list|()
operator|&&
name|substring
argument_list|(
literal|0
argument_list|,
name|prefix
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
name|prefix
argument_list|)
return|;
block|}
comment|/**    * Tests if this bytestring ends with the specified suffix.    * Similar to {@link String#endsWith(String)}    *    * @param suffix the suffix.    * @return<code>true</code> if the byte sequence represented by the    *         argument is a suffix of the byte sequence represented by    *         this string;<code>false</code> otherwise.    */
specifier|public
specifier|final
name|boolean
name|endsWith
parameter_list|(
name|ByteString
name|suffix
parameter_list|)
block|{
return|return
name|size
argument_list|()
operator|>=
name|suffix
operator|.
name|size
argument_list|()
operator|&&
name|substring
argument_list|(
name|size
argument_list|()
operator|-
name|suffix
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
name|suffix
argument_list|)
return|;
block|}
comment|// =================================================================
comment|// byte[] -> ByteString
comment|/**    * Copies the given bytes into a {@code ByteString}.    *    * @param bytes source array    * @param offset offset in source array    * @param size number of bytes to copy    * @return new {@code ByteString}    */
specifier|public
specifier|static
name|ByteString
name|copyFrom
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|size
parameter_list|)
block|{
return|return
operator|new
name|LiteralByteString
argument_list|(
name|byteArrayCopier
operator|.
name|copyFrom
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Copies the given bytes into a {@code ByteString}.    *    * @param bytes to copy    * @return new {@code ByteString}    */
specifier|public
specifier|static
name|ByteString
name|copyFrom
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|)
block|{
return|return
name|copyFrom
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * Wraps the given bytes into a {@code ByteString}. Intended for internal only usage.    */
specifier|static
name|ByteString
name|wrap
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|)
block|{
if|if
condition|(
name|buffer
operator|.
name|hasArray
argument_list|()
condition|)
block|{
specifier|final
name|int
name|offset
init|=
name|buffer
operator|.
name|arrayOffset
argument_list|()
decl_stmt|;
return|return
name|ByteString
operator|.
name|wrap
argument_list|(
name|buffer
operator|.
name|array
argument_list|()
argument_list|,
name|offset
operator|+
name|buffer
operator|.
name|position
argument_list|()
argument_list|,
name|buffer
operator|.
name|remaining
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|NioByteString
argument_list|(
name|buffer
argument_list|)
return|;
block|}
block|}
comment|/**    * Wraps the given bytes into a {@code ByteString}. Intended for internal only usage.    */
specifier|static
name|ByteString
name|wrap
parameter_list|(
name|ByteInput
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
return|return
operator|new
name|ByteInputByteString
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
comment|/**    * Wraps the given bytes into a {@code ByteString}. Intended for internal only    * usage to force a classload of ByteString before LiteralByteString.    */
specifier|static
name|ByteString
name|wrap
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|)
block|{
comment|// TODO(dweis): Return EMPTY when bytes are empty to reduce allocations?
return|return
operator|new
name|LiteralByteString
argument_list|(
name|bytes
argument_list|)
return|;
block|}
comment|/**    * Wraps the given bytes into a {@code ByteString}. Intended for internal only    * usage to force a classload of ByteString before BoundedByteString and    * LiteralByteString.    */
specifier|static
name|ByteString
name|wrap
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
return|return
operator|new
name|BoundedByteString
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
comment|/**    * Copies the next {@code size} bytes from a {@code java.nio.ByteBuffer} into    * a {@code ByteString}.    *    * @param bytes source buffer    * @param size number of bytes to copy    * @return new {@code ByteString}    */
specifier|public
specifier|static
name|ByteString
name|copyFrom
parameter_list|(
name|ByteBuffer
name|bytes
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|byte
index|[]
name|copy
init|=
operator|new
name|byte
index|[
name|size
index|]
decl_stmt|;
name|bytes
operator|.
name|get
argument_list|(
name|copy
argument_list|)
expr_stmt|;
return|return
operator|new
name|LiteralByteString
argument_list|(
name|copy
argument_list|)
return|;
block|}
comment|/**    * Copies the remaining bytes from a {@code java.nio.ByteBuffer} into    * a {@code ByteString}.    *    * @param bytes sourceBuffer    * @return new {@code ByteString}    */
specifier|public
specifier|static
name|ByteString
name|copyFrom
parameter_list|(
name|ByteBuffer
name|bytes
parameter_list|)
block|{
return|return
name|copyFrom
argument_list|(
name|bytes
argument_list|,
name|bytes
operator|.
name|remaining
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Encodes {@code text} into a sequence of bytes using the named charset    * and returns the result as a {@code ByteString}.    *    * @param text source string    * @param charsetName encoding to use    * @return new {@code ByteString}    * @throws UnsupportedEncodingException if the encoding isn't found    */
specifier|public
specifier|static
name|ByteString
name|copyFrom
parameter_list|(
name|String
name|text
parameter_list|,
name|String
name|charsetName
parameter_list|)
throws|throws
name|UnsupportedEncodingException
block|{
return|return
operator|new
name|LiteralByteString
argument_list|(
name|text
operator|.
name|getBytes
argument_list|(
name|charsetName
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Encodes {@code text} into a sequence of bytes using the named charset    * and returns the result as a {@code ByteString}.    *    * @param text source string    * @param charset encode using this charset    * @return new {@code ByteString}    */
specifier|public
specifier|static
name|ByteString
name|copyFrom
parameter_list|(
name|String
name|text
parameter_list|,
name|Charset
name|charset
parameter_list|)
block|{
return|return
operator|new
name|LiteralByteString
argument_list|(
name|text
operator|.
name|getBytes
argument_list|(
name|charset
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Encodes {@code text} into a sequence of UTF-8 bytes and returns the    * result as a {@code ByteString}.    *    * @param text source string    * @return new {@code ByteString}    */
specifier|public
specifier|static
name|ByteString
name|copyFromUtf8
parameter_list|(
name|String
name|text
parameter_list|)
block|{
return|return
operator|new
name|LiteralByteString
argument_list|(
name|text
operator|.
name|getBytes
argument_list|(
name|Internal
operator|.
name|UTF_8
argument_list|)
argument_list|)
return|;
block|}
comment|// =================================================================
comment|// InputStream -> ByteString
comment|/**    * Completely reads the given stream's bytes into a    * {@code ByteString}, blocking if necessary until all bytes are    * read through to the end of the stream.    *    *<b>Performance notes:</b> The returned {@code ByteString} is an    * immutable tree of byte arrays ("chunks") of the stream data.  The    * first chunk is small, with subsequent chunks each being double    * the size, up to 8K.    *    *<p>Each byte read from the input stream will be copied twice to ensure    * that the resulting ByteString is truly immutable.    *    * @param streamToDrain The source stream, which is read completely    *     but not closed.    * @return A new {@code ByteString} which is made up of chunks of    *     various sizes, depending on the behavior of the underlying    *     stream.    * @throws IOException IOException is thrown if there is a problem    *     reading the underlying stream.    */
specifier|public
specifier|static
name|ByteString
name|readFrom
parameter_list|(
name|InputStream
name|streamToDrain
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|readFrom
argument_list|(
name|streamToDrain
argument_list|,
name|MIN_READ_FROM_CHUNK_SIZE
argument_list|,
name|MAX_READ_FROM_CHUNK_SIZE
argument_list|)
return|;
block|}
comment|/**    * Completely reads the given stream's bytes into a    * {@code ByteString}, blocking if necessary until all bytes are    * read through to the end of the stream.    *    *<b>Performance notes:</b> The returned {@code ByteString} is an    * immutable tree of byte arrays ("chunks") of the stream data.  The    * chunkSize parameter sets the size of these byte arrays.    *    *<p>Each byte read from the input stream will be copied twice to ensure    * that the resulting ByteString is truly immutable.    *    * @param streamToDrain The source stream, which is read completely    *     but not closed.    * @param chunkSize The size of the chunks in which to read the    *     stream.    * @return A new {@code ByteString} which is made up of chunks of    *     the given size.    * @throws IOException IOException is thrown if there is a problem    *     reading the underlying stream.    */
specifier|public
specifier|static
name|ByteString
name|readFrom
parameter_list|(
name|InputStream
name|streamToDrain
parameter_list|,
name|int
name|chunkSize
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|readFrom
argument_list|(
name|streamToDrain
argument_list|,
name|chunkSize
argument_list|,
name|chunkSize
argument_list|)
return|;
block|}
comment|// Helper method that takes the chunk size range as a parameter.
specifier|public
specifier|static
name|ByteString
name|readFrom
parameter_list|(
name|InputStream
name|streamToDrain
parameter_list|,
name|int
name|minChunkSize
parameter_list|,
name|int
name|maxChunkSize
parameter_list|)
throws|throws
name|IOException
block|{
name|Collection
argument_list|<
name|ByteString
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|ByteString
argument_list|>
argument_list|()
decl_stmt|;
comment|// copy the inbound bytes into a list of chunks; the chunk size
comment|// grows exponentially to support both short and long streams.
name|int
name|chunkSize
init|=
name|minChunkSize
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|ByteString
name|chunk
init|=
name|readChunk
argument_list|(
name|streamToDrain
argument_list|,
name|chunkSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|chunk
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|results
operator|.
name|add
argument_list|(
name|chunk
argument_list|)
expr_stmt|;
name|chunkSize
operator|=
name|Math
operator|.
name|min
argument_list|(
name|chunkSize
operator|*
literal|2
argument_list|,
name|maxChunkSize
argument_list|)
expr_stmt|;
block|}
return|return
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|results
argument_list|)
return|;
block|}
comment|/**    * Blocks until a chunk of the given size can be made from the    * stream, or EOF is reached.  Calls read() repeatedly in case the    * given stream implementation doesn't completely fill the given    * buffer in one read() call.    *    * @return A chunk of the desired size, or else a chunk as large as    * was available when end of stream was reached. Returns null if the    * given stream had no more data in it.    */
specifier|private
specifier|static
name|ByteString
name|readChunk
parameter_list|(
name|InputStream
name|in
parameter_list|,
specifier|final
name|int
name|chunkSize
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
name|chunkSize
index|]
decl_stmt|;
name|int
name|bytesRead
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|bytesRead
operator|<
name|chunkSize
condition|)
block|{
specifier|final
name|int
name|count
init|=
name|in
operator|.
name|read
argument_list|(
name|buf
argument_list|,
name|bytesRead
argument_list|,
name|chunkSize
operator|-
name|bytesRead
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
block|}
name|bytesRead
operator|+=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|bytesRead
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Always make a copy since InputStream could steal a reference to buf.
return|return
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|bytesRead
argument_list|)
return|;
block|}
comment|// =================================================================
comment|// Multiple ByteStrings -> One ByteString
comment|/**    * Concatenate the given {@code ByteString} to this one. Short concatenations,    * of total size smaller than {@link ByteString#CONCATENATE_BY_COPY_SIZE}, are    * produced by copying the underlying bytes (as per Rope.java,<a    * href="http://www.cs.ubc.ca/local/reading/proceedings/spe91-95/spe/vol25/issue12/spe986.pdf">    * BAP95</a>. In general, the concatenate involves no copying.    *    * @param other string to concatenate    * @return a new {@code ByteString} instance    */
specifier|public
specifier|final
name|ByteString
name|concat
parameter_list|(
name|ByteString
name|other
parameter_list|)
block|{
if|if
condition|(
name|Integer
operator|.
name|MAX_VALUE
operator|-
name|size
argument_list|()
operator|<
name|other
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"ByteString would be too long: "
operator|+
name|size
argument_list|()
operator|+
literal|"+"
operator|+
name|other
operator|.
name|size
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|RopeByteString
operator|.
name|concatenate
argument_list|(
name|this
argument_list|,
name|other
argument_list|)
return|;
block|}
comment|/**    * Concatenates all byte strings in the iterable and returns the result.    * This is designed to run in O(list size), not O(total bytes).    *    *<p>The returned {@code ByteString} is not necessarily a unique object.    * If the list is empty, the returned object is the singleton empty    * {@code ByteString}.  If the list has only one element, that    * {@code ByteString} will be returned without copying.    *    * @param byteStrings strings to be concatenated    * @return new {@code ByteString}    */
specifier|public
specifier|static
name|ByteString
name|copyFrom
parameter_list|(
name|Iterable
argument_list|<
name|ByteString
argument_list|>
name|byteStrings
parameter_list|)
block|{
comment|// Determine the size;
specifier|final
name|int
name|size
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|byteStrings
operator|instanceof
name|Collection
operator|)
condition|)
block|{
name|int
name|tempSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|ByteString
argument_list|>
name|iter
init|=
name|byteStrings
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
name|iter
operator|.
name|next
argument_list|()
operator|,
operator|++
name|tempSize
control|)
block|{       }
name|size
operator|=
name|tempSize
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
operator|(
operator|(
name|Collection
argument_list|<
name|ByteString
argument_list|>
operator|)
name|byteStrings
operator|)
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
name|EMPTY
return|;
block|}
return|return
name|balancedConcat
argument_list|(
name|byteStrings
operator|.
name|iterator
argument_list|()
argument_list|,
name|size
argument_list|)
return|;
block|}
comment|// Internal function used by copyFrom(Iterable<ByteString>).
comment|// Create a balanced concatenation of the next "length" elements from the
comment|// iterable.
specifier|private
specifier|static
name|ByteString
name|balancedConcat
parameter_list|(
name|Iterator
argument_list|<
name|ByteString
argument_list|>
name|iterator
parameter_list|,
name|int
name|length
parameter_list|)
block|{
assert|assert
name|length
operator|>=
literal|1
assert|;
name|ByteString
name|result
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|1
condition|)
block|{
name|result
operator|=
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|halfLength
init|=
name|length
operator|>>>
literal|1
decl_stmt|;
name|ByteString
name|left
init|=
name|balancedConcat
argument_list|(
name|iterator
argument_list|,
name|halfLength
argument_list|)
decl_stmt|;
name|ByteString
name|right
init|=
name|balancedConcat
argument_list|(
name|iterator
argument_list|,
name|length
operator|-
name|halfLength
argument_list|)
decl_stmt|;
name|result
operator|=
name|left
operator|.
name|concat
argument_list|(
name|right
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|// =================================================================
comment|// ByteString -> byte[]
comment|/**    * Copies bytes into a buffer at the given offset.    *    * @param target buffer to copy into    * @param offset in the target buffer    * @throws IndexOutOfBoundsException if the offset is negative or too large    */
specifier|public
name|void
name|copyTo
parameter_list|(
name|byte
index|[]
name|target
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|copyTo
argument_list|(
name|target
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|,
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Copies bytes into a buffer.    *    * @param target       buffer to copy into    * @param sourceOffset offset within these bytes    * @param targetOffset offset within the target buffer    * @param numberToCopy number of bytes to copy    * @throws IndexOutOfBoundsException if an offset or size is negative or too    *     large    */
specifier|public
specifier|final
name|void
name|copyTo
parameter_list|(
name|byte
index|[]
name|target
parameter_list|,
name|int
name|sourceOffset
parameter_list|,
name|int
name|targetOffset
parameter_list|,
name|int
name|numberToCopy
parameter_list|)
block|{
name|checkRange
argument_list|(
name|sourceOffset
argument_list|,
name|sourceOffset
operator|+
name|numberToCopy
argument_list|,
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|checkRange
argument_list|(
name|targetOffset
argument_list|,
name|targetOffset
operator|+
name|numberToCopy
argument_list|,
name|target
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|numberToCopy
operator|>
literal|0
condition|)
block|{
name|copyToInternal
argument_list|(
name|target
argument_list|,
name|sourceOffset
argument_list|,
name|targetOffset
argument_list|,
name|numberToCopy
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Internal (package private) implementation of    * {@link #copyTo(byte[],int,int,int)}.    * It assumes that all error checking has already been performed and that    * {@code numberToCopy> 0}.    */
specifier|protected
specifier|abstract
name|void
name|copyToInternal
parameter_list|(
name|byte
index|[]
name|target
parameter_list|,
name|int
name|sourceOffset
parameter_list|,
name|int
name|targetOffset
parameter_list|,
name|int
name|numberToCopy
parameter_list|)
function_decl|;
comment|/**    * Copies bytes into a ByteBuffer.    *    * @param target ByteBuffer to copy into.    * @throws java.nio.ReadOnlyBufferException if the {@code target} is read-only    * @throws java.nio.BufferOverflowException if the {@code target}'s    *     remaining() space is not large enough to hold the data.    */
specifier|public
specifier|abstract
name|void
name|copyTo
parameter_list|(
name|ByteBuffer
name|target
parameter_list|)
function_decl|;
comment|/**    * Copies bytes to a {@code byte[]}.    *    * @return copied bytes    */
specifier|public
specifier|final
name|byte
index|[]
name|toByteArray
parameter_list|()
block|{
specifier|final
name|int
name|size
init|=
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
name|Internal
operator|.
name|EMPTY_BYTE_ARRAY
return|;
block|}
name|byte
index|[]
name|result
init|=
operator|new
name|byte
index|[
name|size
index|]
decl_stmt|;
name|copyToInternal
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Writes a copy of the contents of this byte string to the specified output stream argument.    *    * @param  out  the output stream to which to write the data.    * @throws IOException  if an I/O error occurs.    */
specifier|public
specifier|abstract
name|void
name|writeTo
parameter_list|(
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Writes a specified part of this byte string to an output stream.    *    * @param  out  the output stream to which to write the data.    * @param  sourceOffset offset within these bytes    * @param  numberToWrite number of bytes to write    * @throws IOException  if an I/O error occurs.    * @throws IndexOutOfBoundsException if an offset or size is negative or too large    */
specifier|final
name|void
name|writeTo
parameter_list|(
name|OutputStream
name|out
parameter_list|,
name|int
name|sourceOffset
parameter_list|,
name|int
name|numberToWrite
parameter_list|)
throws|throws
name|IOException
block|{
name|checkRange
argument_list|(
name|sourceOffset
argument_list|,
name|sourceOffset
operator|+
name|numberToWrite
argument_list|,
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|numberToWrite
operator|>
literal|0
condition|)
block|{
name|writeToInternal
argument_list|(
name|out
argument_list|,
name|sourceOffset
argument_list|,
name|numberToWrite
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Internal version of {@link #writeTo(OutputStream,int,int)} that assumes    * all error checking has already been done.    */
specifier|abstract
name|void
name|writeToInternal
parameter_list|(
name|OutputStream
name|out
parameter_list|,
name|int
name|sourceOffset
parameter_list|,
name|int
name|numberToWrite
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Writes this {@link ByteString} to the provided {@link ByteOutput}. Calling    * this method may result in multiple operations on the target {@link ByteOutput}.    *    *<p>This method may expose internal backing buffers of the {@link ByteString} to the {@link    * ByteOutput} in order to avoid additional copying overhead. It would be possible for a malicious    * {@link ByteOutput} to corrupt the {@link ByteString}. Use with caution!    *    * @param  byteOutput  the output target to receive the bytes    * @throws IOException  if an I/O error occurs    * @see UnsafeByteOperations#unsafeWriteTo(ByteString, ByteOutput)    */
specifier|abstract
name|void
name|writeTo
parameter_list|(
name|ByteOutput
name|byteOutput
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Constructs a read-only {@code java.nio.ByteBuffer} whose content    * is equal to the contents of this byte string.    * The result uses the same backing array as the byte string, if possible.    *    * @return wrapped bytes    */
specifier|public
specifier|abstract
name|ByteBuffer
name|asReadOnlyByteBuffer
parameter_list|()
function_decl|;
comment|/**    * Constructs a list of read-only {@code java.nio.ByteBuffer} objects    * such that the concatenation of their contents is equal to the contents    * of this byte string.  The result uses the same backing arrays as the    * byte string.    *<p>    * By returning a list, implementations of this method may be able to avoid    * copying even when there are multiple backing arrays.    *    * @return a list of wrapped bytes    */
specifier|public
specifier|abstract
name|List
argument_list|<
name|ByteBuffer
argument_list|>
name|asReadOnlyByteBufferList
parameter_list|()
function_decl|;
comment|/**    * Constructs a new {@code String} by decoding the bytes using the    * specified charset.    *    * @param charsetName encode using this charset    * @return new string    * @throws UnsupportedEncodingException if charset isn't recognized    */
specifier|public
specifier|final
name|String
name|toString
parameter_list|(
name|String
name|charsetName
parameter_list|)
throws|throws
name|UnsupportedEncodingException
block|{
try|try
block|{
return|return
name|toString
argument_list|(
name|Charset
operator|.
name|forName
argument_list|(
name|charsetName
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedCharsetException
name|e
parameter_list|)
block|{
name|UnsupportedEncodingException
name|exception
init|=
operator|new
name|UnsupportedEncodingException
argument_list|(
name|charsetName
argument_list|)
decl_stmt|;
name|exception
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|exception
throw|;
block|}
block|}
comment|/**    * Constructs a new {@code String} by decoding the bytes using the    * specified charset. Returns the same empty String if empty.    *    * @param charset encode using this charset    * @return new string    */
specifier|public
specifier|final
name|String
name|toString
parameter_list|(
name|Charset
name|charset
parameter_list|)
block|{
return|return
name|size
argument_list|()
operator|==
literal|0
condition|?
literal|""
else|:
name|toStringInternal
argument_list|(
name|charset
argument_list|)
return|;
block|}
comment|/**    * Constructs a new {@code String} by decoding the bytes using the    * specified charset.    *    * @param charset encode using this charset    * @return new string    */
specifier|protected
specifier|abstract
name|String
name|toStringInternal
parameter_list|(
name|Charset
name|charset
parameter_list|)
function_decl|;
comment|// =================================================================
comment|// UTF-8 decoding
comment|/**    * Constructs a new {@code String} by decoding the bytes as UTF-8.    *    * @return new string using UTF-8 encoding    */
specifier|public
specifier|final
name|String
name|toStringUtf8
parameter_list|()
block|{
return|return
name|toString
argument_list|(
name|Internal
operator|.
name|UTF_8
argument_list|)
return|;
block|}
comment|/**    * Tells whether this {@code ByteString} represents a well-formed UTF-8    * byte sequence, such that the original bytes can be converted to a    * String object and then round tripped back to bytes without loss.    *    *<p>More precisely, returns {@code true} whenever:<pre> {@code    * Arrays.equals(byteString.toByteArray(),    *     new String(byteString.toByteArray(), "UTF-8").getBytes("UTF-8"))    * }</pre>    *    *<p>This method returns {@code false} for "overlong" byte sequences,    * as well as for 3-byte sequences that would map to a surrogate    * character, in accordance with the restricted definition of UTF-8    * introduced in Unicode 3.1.  Note that the UTF-8 decoder included in    * Oracle's JDK has been modified to also reject "overlong" byte    * sequences, but (as of 2011) still accepts 3-byte surrogate    * character byte sequences.    *    *<p>See the Unicode Standard,<br>    * Table 3-6.<em>UTF-8 Bit Distribution</em>,<br>    * Table 3-7.<em>Well Formed UTF-8 Byte Sequences</em>.    *    * @return whether the bytes in this {@code ByteString} are a    * well-formed UTF-8 byte sequence    */
specifier|public
specifier|abstract
name|boolean
name|isValidUtf8
parameter_list|()
function_decl|;
comment|/**    * Tells whether the given byte sequence is a well-formed, malformed, or    * incomplete UTF-8 byte sequence.  This method accepts and returns a partial    * state result, allowing the bytes for a complete UTF-8 byte sequence to be    * composed from multiple {@code ByteString} segments.    *    * @param state either {@code 0} (if this is the initial decoding operation)    *     or the value returned from a call to a partial decoding method for the    *     previous bytes    * @param offset offset of the first byte to check    * @param length number of bytes to check    *    * @return {@code -1} if the partial byte sequence is definitely malformed,    * {@code 0} if it is well-formed (no additional input needed), or, if the    * byte sequence is "incomplete", i.e. apparently terminated in the middle of    * a character, an opaque integer "state" value containing enough information    * to decode the character when passed to a subsequent invocation of a    * partial decoding method.    */
specifier|protected
specifier|abstract
name|int
name|partialIsValidUtf8
parameter_list|(
name|int
name|state
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
comment|// =================================================================
comment|// equals() and hashCode()
annotation|@
name|Override
specifier|public
specifier|abstract
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
function_decl|;
comment|/**    * Base class for leaf {@link ByteString}s (i.e. non-ropes).    */
specifier|abstract
specifier|static
class|class
name|LeafByteString
extends|extends
name|ByteString
block|{
annotation|@
name|Override
specifier|protected
specifier|final
name|int
name|getTreeDepth
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
annotation|@
name|Override
specifier|protected
specifier|final
name|boolean
name|isBalanced
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/**      * Check equality of the substring of given length of this object starting at      * zero with another {@code ByteString} substring starting at offset.      *      * @param other  what to compare a substring in      * @param offset offset into other      * @param length number of bytes to compare      * @return true for equality of substrings, else false.      */
specifier|abstract
name|boolean
name|equalsRange
parameter_list|(
name|ByteString
name|other
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
block|}
comment|/**    * Compute the hashCode using the traditional algorithm from {@link    * ByteString}.    *    * @return hashCode value    */
annotation|@
name|Override
specifier|public
specifier|final
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|h
init|=
name|hash
decl_stmt|;
if|if
condition|(
name|h
operator|==
literal|0
condition|)
block|{
name|int
name|size
init|=
name|size
argument_list|()
decl_stmt|;
name|h
operator|=
name|partialHash
argument_list|(
name|size
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
literal|0
condition|)
block|{
name|h
operator|=
literal|1
expr_stmt|;
block|}
name|hash
operator|=
name|h
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
comment|// =================================================================
comment|// Input stream
comment|/**    * Creates an {@code InputStream} which can be used to read the bytes.    *<p>    * The {@link InputStream} returned by this method is guaranteed to be    * completely non-blocking.  The method {@link InputStream#available()}    * returns the number of bytes remaining in the stream. The methods    * {@link InputStream#read(byte[])}, {@link InputStream#read(byte[],int,int)}    * and {@link InputStream#skip(long)} will read/skip as many bytes as are    * available.  The method {@link InputStream#markSupported()} returns    * {@code true}.    *<p>    * The methods in the returned {@link InputStream} might<b>not</b> be    * thread safe.    *    * @return an input stream that returns the bytes of this byte string.    */
specifier|public
specifier|abstract
name|InputStream
name|newInput
parameter_list|()
function_decl|;
comment|/**    * Creates a {@link CodedInputStream} which can be used to read the bytes.    * Using this is often more efficient than creating a {@link CodedInputStream}    * that wraps the result of {@link #newInput()}.    *    * @return stream based on wrapped data    */
specifier|public
specifier|abstract
name|CodedInputStream
name|newCodedInput
parameter_list|()
function_decl|;
comment|// =================================================================
comment|// Output stream
comment|/**    * Creates a new {@link Output} with the given initial capacity. Call {@link    * Output#toByteString()} to create the {@code ByteString} instance.    *<p>    * A {@link ByteString.Output} offers the same functionality as a    * {@link ByteArrayOutputStream}, except that it returns a {@link ByteString}    * rather than a {@code byte} array.    *    * @param initialCapacity estimate of number of bytes to be written    * @return {@code OutputStream} for building a {@code ByteString}    */
specifier|public
specifier|static
name|Output
name|newOutput
parameter_list|(
name|int
name|initialCapacity
parameter_list|)
block|{
return|return
operator|new
name|Output
argument_list|(
name|initialCapacity
argument_list|)
return|;
block|}
comment|/**    * Creates a new {@link Output}. Call {@link Output#toByteString()} to create    * the {@code ByteString} instance.    *<p>    * A {@link ByteString.Output} offers the same functionality as a    * {@link ByteArrayOutputStream}, except that it returns a {@link ByteString}    * rather than a {@code byte array}.    *    * @return {@code OutputStream} for building a {@code ByteString}    */
specifier|public
specifier|static
name|Output
name|newOutput
parameter_list|()
block|{
return|return
operator|new
name|Output
argument_list|(
name|CONCATENATE_BY_COPY_SIZE
argument_list|)
return|;
block|}
comment|/**    * Outputs to a {@code ByteString} instance. Call {@link #toByteString()} to    * create the {@code ByteString} instance.    */
specifier|public
specifier|static
specifier|final
class|class
name|Output
extends|extends
name|OutputStream
block|{
comment|// Implementation note.
comment|// The public methods of this class must be synchronized.  ByteStrings
comment|// are guaranteed to be immutable.  Without some sort of locking, it could
comment|// be possible for one thread to call toByteSring(), while another thread
comment|// is still modifying the underlying byte array.
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|EMPTY_BYTE_ARRAY
init|=
operator|new
name|byte
index|[
literal|0
index|]
decl_stmt|;
comment|// argument passed by user, indicating initial capacity.
specifier|private
specifier|final
name|int
name|initialCapacity
decl_stmt|;
comment|// ByteStrings to be concatenated to create the result
specifier|private
specifier|final
name|ArrayList
argument_list|<
name|ByteString
argument_list|>
name|flushedBuffers
decl_stmt|;
comment|// Total number of bytes in the ByteStrings of flushedBuffers
specifier|private
name|int
name|flushedBuffersTotalBytes
decl_stmt|;
comment|// Current buffer to which we are writing
specifier|private
name|byte
index|[]
name|buffer
decl_stmt|;
comment|// Location in buffer[] to which we write the next byte.
specifier|private
name|int
name|bufferPos
decl_stmt|;
comment|/**      * Creates a new ByteString output stream with the specified      * initial capacity.      *      * @param initialCapacity  the initial capacity of the output stream.      */
name|Output
parameter_list|(
name|int
name|initialCapacity
parameter_list|)
block|{
if|if
condition|(
name|initialCapacity
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Buffer size< 0"
argument_list|)
throw|;
block|}
name|this
operator|.
name|initialCapacity
operator|=
name|initialCapacity
expr_stmt|;
name|this
operator|.
name|flushedBuffers
operator|=
operator|new
name|ArrayList
argument_list|<
name|ByteString
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|buffer
operator|=
operator|new
name|byte
index|[
name|initialCapacity
index|]
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|write
parameter_list|(
name|int
name|b
parameter_list|)
block|{
if|if
condition|(
name|bufferPos
operator|==
name|buffer
operator|.
name|length
condition|)
block|{
name|flushFullBuffer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|buffer
index|[
name|bufferPos
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|b
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
name|length
operator|<=
name|buffer
operator|.
name|length
operator|-
name|bufferPos
condition|)
block|{
comment|// The bytes can fit into the current buffer.
name|System
operator|.
name|arraycopy
argument_list|(
name|b
argument_list|,
name|offset
argument_list|,
name|buffer
argument_list|,
name|bufferPos
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|bufferPos
operator|+=
name|length
expr_stmt|;
block|}
else|else
block|{
comment|// Use up the current buffer
name|int
name|copySize
init|=
name|buffer
operator|.
name|length
operator|-
name|bufferPos
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|b
argument_list|,
name|offset
argument_list|,
name|buffer
argument_list|,
name|bufferPos
argument_list|,
name|copySize
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|copySize
expr_stmt|;
name|length
operator|-=
name|copySize
expr_stmt|;
comment|// Flush the buffer, and get a new buffer at least big enough to cover
comment|// what we still need to output
name|flushFullBuffer
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|b
argument_list|,
name|offset
argument_list|,
name|buffer
argument_list|,
literal|0
comment|/* count */
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|bufferPos
operator|=
name|length
expr_stmt|;
block|}
block|}
comment|/**      * Creates a byte string. Its size is the current size of this output      * stream and its output has been copied to it.      *      * @return  the current contents of this output stream, as a byte string.      */
specifier|public
specifier|synchronized
name|ByteString
name|toByteString
parameter_list|()
block|{
name|flushLastBuffer
argument_list|()
expr_stmt|;
return|return
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|flushedBuffers
argument_list|)
return|;
block|}
comment|/**      * Implement java.util.Arrays.copyOf() for jdk 1.5.      */
specifier|private
name|byte
index|[]
name|copyArray
parameter_list|(
name|byte
index|[]
name|buffer
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|byte
index|[]
name|result
init|=
operator|new
name|byte
index|[
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|buffer
operator|.
name|length
argument_list|,
name|length
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**      * Writes the complete contents of this byte array output stream to      * the specified output stream argument.      *      * @param out the output stream to which to write the data.      * @throws IOException  if an I/O error occurs.      */
specifier|public
name|void
name|writeTo
parameter_list|(
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteString
index|[]
name|cachedFlushBuffers
decl_stmt|;
name|byte
index|[]
name|cachedBuffer
decl_stmt|;
name|int
name|cachedBufferPos
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// Copy the information we need into local variables so as to hold
comment|// the lock for as short a time as possible.
name|cachedFlushBuffers
operator|=
name|flushedBuffers
operator|.
name|toArray
argument_list|(
operator|new
name|ByteString
index|[
name|flushedBuffers
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
name|cachedBuffer
operator|=
name|buffer
expr_stmt|;
name|cachedBufferPos
operator|=
name|bufferPos
expr_stmt|;
block|}
for|for
control|(
name|ByteString
name|byteString
range|:
name|cachedFlushBuffers
control|)
block|{
name|byteString
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|write
argument_list|(
name|copyArray
argument_list|(
name|cachedBuffer
argument_list|,
name|cachedBufferPos
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the current size of the output stream.      *      * @return  the current size of the output stream      */
specifier|public
specifier|synchronized
name|int
name|size
parameter_list|()
block|{
return|return
name|flushedBuffersTotalBytes
operator|+
name|bufferPos
return|;
block|}
comment|/**      * Resets this stream, so that all currently accumulated output in the      * output stream is discarded. The output stream can be used again,      * reusing the already allocated buffer space.      */
specifier|public
specifier|synchronized
name|void
name|reset
parameter_list|()
block|{
name|flushedBuffers
operator|.
name|clear
argument_list|()
expr_stmt|;
name|flushedBuffersTotalBytes
operator|=
literal|0
expr_stmt|;
name|bufferPos
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"<ByteString.Output@%s size=%d>"
argument_list|,
name|Integer
operator|.
name|toHexString
argument_list|(
name|System
operator|.
name|identityHashCode
argument_list|(
name|this
argument_list|)
argument_list|)
argument_list|,
name|size
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Internal function used by writers.  The current buffer is full, and the      * writer needs a new buffer whose size is at least the specified minimum      * size.      */
specifier|private
name|void
name|flushFullBuffer
parameter_list|(
name|int
name|minSize
parameter_list|)
block|{
name|flushedBuffers
operator|.
name|add
argument_list|(
operator|new
name|LiteralByteString
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|flushedBuffersTotalBytes
operator|+=
name|buffer
operator|.
name|length
expr_stmt|;
comment|// We want to increase our total capacity by 50%, but as a minimum,
comment|// the new buffer should also at least be>= minSize and
comment|//>= initial Capacity.
name|int
name|newSize
init|=
name|Math
operator|.
name|max
argument_list|(
name|initialCapacity
argument_list|,
name|Math
operator|.
name|max
argument_list|(
name|minSize
argument_list|,
name|flushedBuffersTotalBytes
operator|>>>
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|buffer
operator|=
operator|new
name|byte
index|[
name|newSize
index|]
expr_stmt|;
name|bufferPos
operator|=
literal|0
expr_stmt|;
block|}
comment|/**      * Internal function used by {@link #toByteString()}. The current buffer may      * or may not be full, but it needs to be flushed.      */
specifier|private
name|void
name|flushLastBuffer
parameter_list|()
block|{
if|if
condition|(
name|bufferPos
operator|<
name|buffer
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|bufferPos
operator|>
literal|0
condition|)
block|{
name|byte
index|[]
name|bufferCopy
init|=
name|copyArray
argument_list|(
name|buffer
argument_list|,
name|bufferPos
argument_list|)
decl_stmt|;
name|flushedBuffers
operator|.
name|add
argument_list|(
operator|new
name|LiteralByteString
argument_list|(
name|bufferCopy
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// We reuse this buffer for further writes.
block|}
else|else
block|{
comment|// Buffer is completely full.  Huzzah.
name|flushedBuffers
operator|.
name|add
argument_list|(
operator|new
name|LiteralByteString
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|// 99% of the time, we're not going to use this OutputStream again.
comment|// We set buffer to an empty byte stream so that we're handling this
comment|// case without wasting space.  In the rare case that more writes
comment|// *do* occur, this empty buffer will be flushed and an appropriately
comment|// sized new buffer will be created.
name|buffer
operator|=
name|EMPTY_BYTE_ARRAY
expr_stmt|;
block|}
name|flushedBuffersTotalBytes
operator|+=
name|bufferPos
expr_stmt|;
name|bufferPos
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/**    * Constructs a new {@code ByteString} builder, which allows you to    * efficiently construct a {@code ByteString} by writing to a {@link    * CodedOutputStream}. Using this is much more efficient than calling {@code    * newOutput()} and wrapping that in a {@code CodedOutputStream}.    *    *<p>This is package-private because it's a somewhat confusing interface.    * Users can call {@link Message#toByteString()} instead of calling this    * directly.    *    * @param size The target byte size of the {@code ByteString}.  You must write    *     exactly this many bytes before building the result.    * @return the builder    */
specifier|static
name|CodedBuilder
name|newCodedBuilder
parameter_list|(
name|int
name|size
parameter_list|)
block|{
return|return
operator|new
name|CodedBuilder
argument_list|(
name|size
argument_list|)
return|;
block|}
comment|/** See {@link ByteString#newCodedBuilder(int)}. */
specifier|static
specifier|final
class|class
name|CodedBuilder
block|{
specifier|private
specifier|final
name|CodedOutputStream
name|output
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|buffer
decl_stmt|;
specifier|private
name|CodedBuilder
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|buffer
operator|=
operator|new
name|byte
index|[
name|size
index|]
expr_stmt|;
name|output
operator|=
name|CodedOutputStream
operator|.
name|newInstance
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
specifier|public
name|ByteString
name|build
parameter_list|()
block|{
name|output
operator|.
name|checkNoSpaceLeft
argument_list|()
expr_stmt|;
comment|// We can be confident that the CodedOutputStream will not modify the
comment|// underlying bytes anymore because it already wrote all of them.  So,
comment|// no need to make a copy.
return|return
operator|new
name|LiteralByteString
argument_list|(
name|buffer
argument_list|)
return|;
block|}
specifier|public
name|CodedOutputStream
name|getCodedOutput
parameter_list|()
block|{
return|return
name|output
return|;
block|}
block|}
comment|// =================================================================
comment|// Methods {@link RopeByteString} needs on instances, which aren't part of the
comment|// public API.
comment|/**    * Return the depth of the tree representing this {@code ByteString}, if any,    * whose root is this node. If this is a leaf node, return 0.    *    * @return tree depth or zero    */
specifier|protected
specifier|abstract
name|int
name|getTreeDepth
parameter_list|()
function_decl|;
comment|/**    * Return {@code true} if this ByteString is literal (a leaf node) or a    * flat-enough tree in the sense of {@link RopeByteString}.    *    * @return true if the tree is flat enough    */
specifier|protected
specifier|abstract
name|boolean
name|isBalanced
parameter_list|()
function_decl|;
comment|/**    * Return the cached hash code if available.    *    * @return value of cached hash code or 0 if not computed yet    */
specifier|protected
specifier|final
name|int
name|peekCachedHashCode
parameter_list|()
block|{
return|return
name|hash
return|;
block|}
comment|/**    * Compute the hash across the value bytes starting with the given hash, and    * return the result.  This is used to compute the hash across strings    * represented as a set of pieces by allowing the hash computation to be    * continued from piece to piece.    *    * @param h starting hash value    * @param offset offset into this value to start looking at data values    * @param length number of data values to include in the hash computation    * @return ending hash value    */
specifier|protected
specifier|abstract
name|int
name|partialHash
parameter_list|(
name|int
name|h
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
comment|/**    * Checks that the given index falls within the specified array size.    *    * @param index the index position to be tested    * @param size the length of the array    * @throws IndexOutOfBoundsException if the index does not fall within the array.    */
specifier|static
name|void
name|checkIndex
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
operator|(
name|index
operator||
operator|(
name|size
operator|-
operator|(
name|index
operator|+
literal|1
operator|)
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
literal|"Index< 0: "
operator|+
name|index
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
literal|"Index> length: "
operator|+
name|index
operator|+
literal|", "
operator|+
name|size
argument_list|)
throw|;
block|}
block|}
comment|/**    * Checks that the given range falls within the bounds of an array    *    * @param startIndex the start index of the range (inclusive)    * @param endIndex the end index of the range (exclusive)    * @param size the size of the array.    * @return the length of the range.    * @throws IndexOutOfBoundsException some or all of the range falls outside of the array.    */
specifier|static
name|int
name|checkRange
parameter_list|(
name|int
name|startIndex
parameter_list|,
name|int
name|endIndex
parameter_list|,
name|int
name|size
parameter_list|)
block|{
specifier|final
name|int
name|length
init|=
name|endIndex
operator|-
name|startIndex
decl_stmt|;
if|if
condition|(
operator|(
name|startIndex
operator||
name|endIndex
operator||
name|length
operator||
operator|(
name|size
operator|-
name|endIndex
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|startIndex
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"Beginning index: "
operator|+
name|startIndex
operator|+
literal|"< 0"
argument_list|)
throw|;
block|}
if|if
condition|(
name|endIndex
operator|<
name|startIndex
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"Beginning index larger than ending index: "
operator|+
name|startIndex
operator|+
literal|", "
operator|+
name|endIndex
argument_list|)
throw|;
block|}
comment|// endIndex>= size
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"End index: "
operator|+
name|endIndex
operator|+
literal|">= "
operator|+
name|size
argument_list|)
throw|;
block|}
return|return
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"<ByteString@%s size=%d>"
argument_list|,
name|Integer
operator|.
name|toHexString
argument_list|(
name|System
operator|.
name|identityHashCode
argument_list|(
name|this
argument_list|)
argument_list|)
argument_list|,
name|size
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * This class implements a {@link org.apache.hadoop.hbase.shaded.com.google.protobuf.ByteString} backed by a    * single array of bytes, contiguous in memory. It supports substring by    * pointing to only a sub-range of the underlying byte array, meaning that a    * substring will reference the full byte-array of the string it's made from,    * exactly as with {@link String}.    *    * @author carlanton@google.com (Carl Haverl)    */
comment|// Keep this class private to avoid deadlocks in classloading across threads as ByteString's
comment|// static initializer loads LiteralByteString and another thread loads LiteralByteString.
specifier|private
specifier|static
class|class
name|LiteralByteString
extends|extends
name|ByteString
operator|.
name|LeafByteString
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
specifier|protected
specifier|final
name|byte
index|[]
name|bytes
decl_stmt|;
comment|/**      * Creates a {@code LiteralByteString} backed by the given array, without      * copying.      *      * @param bytes array to wrap      */
name|LiteralByteString
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|)
block|{
name|this
operator|.
name|bytes
operator|=
name|bytes
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|byte
name|byteAt
parameter_list|(
name|int
name|index
parameter_list|)
block|{
comment|// Unlike most methods in this class, this one is a direct implementation
comment|// ignoring the potential offset because we need to do range-checking in the
comment|// substring case anyway.
return|return
name|bytes
index|[
name|index
index|]
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|bytes
operator|.
name|length
return|;
block|}
comment|// =================================================================
comment|// ByteString -> substring
annotation|@
name|Override
specifier|public
specifier|final
name|ByteString
name|substring
parameter_list|(
name|int
name|beginIndex
parameter_list|,
name|int
name|endIndex
parameter_list|)
block|{
specifier|final
name|int
name|length
init|=
name|checkRange
argument_list|(
name|beginIndex
argument_list|,
name|endIndex
argument_list|,
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|ByteString
operator|.
name|EMPTY
return|;
block|}
return|return
operator|new
name|BoundedByteString
argument_list|(
name|bytes
argument_list|,
name|getOffsetIntoBytes
argument_list|()
operator|+
name|beginIndex
argument_list|,
name|length
argument_list|)
return|;
block|}
comment|// =================================================================
comment|// ByteString -> byte[]
annotation|@
name|Override
specifier|protected
name|void
name|copyToInternal
parameter_list|(
name|byte
index|[]
name|target
parameter_list|,
name|int
name|sourceOffset
parameter_list|,
name|int
name|targetOffset
parameter_list|,
name|int
name|numberToCopy
parameter_list|)
block|{
comment|// Optimized form, not for subclasses, since we don't call
comment|// getOffsetIntoBytes() or check the 'numberToCopy' parameter.
comment|// TODO(nathanmittler): Is not calling getOffsetIntoBytes really saving that much?
name|System
operator|.
name|arraycopy
argument_list|(
name|bytes
argument_list|,
name|sourceOffset
argument_list|,
name|target
argument_list|,
name|targetOffset
argument_list|,
name|numberToCopy
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|copyTo
parameter_list|(
name|ByteBuffer
name|target
parameter_list|)
block|{
name|target
operator|.
name|put
argument_list|(
name|bytes
argument_list|,
name|getOffsetIntoBytes
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// Copies bytes
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|ByteBuffer
name|asReadOnlyByteBuffer
parameter_list|()
block|{
return|return
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|bytes
argument_list|,
name|getOffsetIntoBytes
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|)
operator|.
name|asReadOnlyBuffer
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|List
argument_list|<
name|ByteBuffer
argument_list|>
name|asReadOnlyByteBufferList
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|singletonList
argument_list|(
name|asReadOnlyByteBuffer
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeTo
parameter_list|(
name|OutputStream
name|outputStream
parameter_list|)
throws|throws
name|IOException
block|{
name|outputStream
operator|.
name|write
argument_list|(
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|final
name|void
name|writeToInternal
parameter_list|(
name|OutputStream
name|outputStream
parameter_list|,
name|int
name|sourceOffset
parameter_list|,
name|int
name|numberToWrite
parameter_list|)
throws|throws
name|IOException
block|{
name|outputStream
operator|.
name|write
argument_list|(
name|bytes
argument_list|,
name|getOffsetIntoBytes
argument_list|()
operator|+
name|sourceOffset
argument_list|,
name|numberToWrite
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|final
name|void
name|writeTo
parameter_list|(
name|ByteOutput
name|output
parameter_list|)
throws|throws
name|IOException
block|{
name|output
operator|.
name|writeLazy
argument_list|(
name|bytes
argument_list|,
name|getOffsetIntoBytes
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
specifier|final
name|String
name|toStringInternal
parameter_list|(
name|Charset
name|charset
parameter_list|)
block|{
return|return
operator|new
name|String
argument_list|(
name|bytes
argument_list|,
name|getOffsetIntoBytes
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
name|charset
argument_list|)
return|;
block|}
comment|// =================================================================
comment|// UTF-8 decoding
annotation|@
name|Override
specifier|public
specifier|final
name|boolean
name|isValidUtf8
parameter_list|()
block|{
name|int
name|offset
init|=
name|getOffsetIntoBytes
argument_list|()
decl_stmt|;
return|return
name|Utf8
operator|.
name|isValidUtf8
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|offset
operator|+
name|size
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
specifier|final
name|int
name|partialIsValidUtf8
parameter_list|(
name|int
name|state
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|index
init|=
name|getOffsetIntoBytes
argument_list|()
operator|+
name|offset
decl_stmt|;
return|return
name|Utf8
operator|.
name|partialIsValidUtf8
argument_list|(
name|state
argument_list|,
name|bytes
argument_list|,
name|index
argument_list|,
name|index
operator|+
name|length
argument_list|)
return|;
block|}
comment|// =================================================================
comment|// equals() and hashCode()
annotation|@
name|Override
specifier|public
specifier|final
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|==
name|this
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|other
operator|instanceof
name|ByteString
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|size
argument_list|()
operator|!=
operator|(
operator|(
name|ByteString
operator|)
name|other
operator|)
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|other
operator|instanceof
name|LiteralByteString
condition|)
block|{
name|LiteralByteString
name|otherAsLiteral
init|=
operator|(
name|LiteralByteString
operator|)
name|other
decl_stmt|;
comment|// If we know the hash codes and they are not equal, we know the byte
comment|// strings are not equal.
name|int
name|thisHash
init|=
name|peekCachedHashCode
argument_list|()
decl_stmt|;
name|int
name|thatHash
init|=
name|otherAsLiteral
operator|.
name|peekCachedHashCode
argument_list|()
decl_stmt|;
if|if
condition|(
name|thisHash
operator|!=
literal|0
operator|&&
name|thatHash
operator|!=
literal|0
operator|&&
name|thisHash
operator|!=
name|thatHash
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|equalsRange
argument_list|(
operator|(
name|LiteralByteString
operator|)
name|other
argument_list|,
literal|0
argument_list|,
name|size
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
comment|// RopeByteString and NioByteString.
return|return
name|other
operator|.
name|equals
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
comment|/**      * Check equality of the substring of given length of this object starting at      * zero with another {@code LiteralByteString} substring starting at offset.      *      * @param other  what to compare a substring in      * @param offset offset into other      * @param length number of bytes to compare      * @return true for equality of substrings, else false.      */
annotation|@
name|Override
specifier|final
name|boolean
name|equalsRange
parameter_list|(
name|ByteString
name|other
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
name|length
operator|>
name|other
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Length too large: "
operator|+
name|length
operator|+
name|size
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|offset
operator|+
name|length
operator|>
name|other
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Ran off end of other: "
operator|+
name|offset
operator|+
literal|", "
operator|+
name|length
operator|+
literal|", "
operator|+
name|other
operator|.
name|size
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|other
operator|instanceof
name|LiteralByteString
condition|)
block|{
name|LiteralByteString
name|lbsOther
init|=
operator|(
name|LiteralByteString
operator|)
name|other
decl_stmt|;
name|byte
index|[]
name|thisBytes
init|=
name|bytes
decl_stmt|;
name|byte
index|[]
name|otherBytes
init|=
name|lbsOther
operator|.
name|bytes
decl_stmt|;
name|int
name|thisLimit
init|=
name|getOffsetIntoBytes
argument_list|()
operator|+
name|length
decl_stmt|;
for|for
control|(
name|int
name|thisIndex
init|=
name|getOffsetIntoBytes
argument_list|()
init|,
name|otherIndex
init|=
name|lbsOther
operator|.
name|getOffsetIntoBytes
argument_list|()
operator|+
name|offset
init|;
operator|(
name|thisIndex
operator|<
name|thisLimit
operator|)
condition|;
operator|++
name|thisIndex
operator|,
operator|++
name|otherIndex
control|)
block|{
if|if
condition|(
name|thisBytes
index|[
name|thisIndex
index|]
operator|!=
name|otherBytes
index|[
name|otherIndex
index|]
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
return|return
name|other
operator|.
name|substring
argument_list|(
name|offset
argument_list|,
name|offset
operator|+
name|length
argument_list|)
operator|.
name|equals
argument_list|(
name|substring
argument_list|(
literal|0
argument_list|,
name|length
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
specifier|final
name|int
name|partialHash
parameter_list|(
name|int
name|h
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
return|return
name|Internal
operator|.
name|partialHash
argument_list|(
name|h
argument_list|,
name|bytes
argument_list|,
name|getOffsetIntoBytes
argument_list|()
operator|+
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
comment|// =================================================================
comment|// Input stream
annotation|@
name|Override
specifier|public
specifier|final
name|InputStream
name|newInput
parameter_list|()
block|{
return|return
operator|new
name|ByteArrayInputStream
argument_list|(
name|bytes
argument_list|,
name|getOffsetIntoBytes
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|)
return|;
comment|// No copy
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|CodedInputStream
name|newCodedInput
parameter_list|()
block|{
comment|// We trust CodedInputStream not to modify the bytes, or to give anyone
comment|// else access to them.
return|return
name|CodedInputStream
operator|.
name|newInstance
argument_list|(
name|bytes
argument_list|,
name|getOffsetIntoBytes
argument_list|()
argument_list|,
name|size
argument_list|()
argument_list|,
literal|true
comment|/* bufferIsImmutable */
argument_list|)
return|;
block|}
comment|// =================================================================
comment|// Internal methods
comment|/**      * Offset into {@code bytes[]} to use, non-zero for substrings.      *      * @return always 0 for this class      */
specifier|protected
name|int
name|getOffsetIntoBytes
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
block|}
comment|/**    * This class is used to represent the substring of a {@link ByteString} over a    * single byte array. In terms of the public API of {@link ByteString}, you end    * up here by calling {@link ByteString#copyFrom(byte[])} followed by {@link    * ByteString#substring(int, int)}.    *    *<p>This class contains most of the overhead involved in creating a substring    * from a {@link LiteralByteString}.  The overhead involves some range-checking    * and two extra fields.    *    * @author carlanton@google.com (Carl Haverl)    */
comment|// Keep this class private to avoid deadlocks in classloading across threads as ByteString's
comment|// static initializer loads LiteralByteString and another thread loads BoundedByteString.
specifier|private
specifier|static
specifier|final
class|class
name|BoundedByteString
extends|extends
name|LiteralByteString
block|{
specifier|private
specifier|final
name|int
name|bytesOffset
decl_stmt|;
specifier|private
specifier|final
name|int
name|bytesLength
decl_stmt|;
comment|/**      * Creates a {@code BoundedByteString} backed by the sub-range of given array,      * without copying.      *      * @param bytes  array to wrap      * @param offset index to first byte to use in bytes      * @param length number of bytes to use from bytes      * @throws IllegalArgumentException if {@code offset< 0}, {@code length< 0},      *                                  or if {@code offset + length>      *                                  bytes.length}.      */
name|BoundedByteString
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|super
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|checkRange
argument_list|(
name|offset
argument_list|,
name|offset
operator|+
name|length
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|this
operator|.
name|bytesOffset
operator|=
name|offset
expr_stmt|;
name|this
operator|.
name|bytesLength
operator|=
name|length
expr_stmt|;
block|}
comment|/**      * Gets the byte at the given index.      * Throws {@link ArrayIndexOutOfBoundsException}      * for backwards-compatibility reasons although it would more properly be      * {@link IndexOutOfBoundsException}.      *      * @param index index of byte      * @return the value      * @throws ArrayIndexOutOfBoundsException {@code index} is< 0 or>= size      */
annotation|@
name|Override
specifier|public
name|byte
name|byteAt
parameter_list|(
name|int
name|index
parameter_list|)
block|{
comment|// We must check the index ourselves as we cannot rely on Java array index
comment|// checking for substrings.
name|checkIndex
argument_list|(
name|index
argument_list|,
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|bytes
index|[
name|bytesOffset
operator|+
name|index
index|]
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|bytesLength
return|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|getOffsetIntoBytes
parameter_list|()
block|{
return|return
name|bytesOffset
return|;
block|}
comment|// =================================================================
comment|// ByteString -> byte[]
annotation|@
name|Override
specifier|protected
name|void
name|copyToInternal
parameter_list|(
name|byte
index|[]
name|target
parameter_list|,
name|int
name|sourceOffset
parameter_list|,
name|int
name|targetOffset
parameter_list|,
name|int
name|numberToCopy
parameter_list|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|bytes
argument_list|,
name|getOffsetIntoBytes
argument_list|()
operator|+
name|sourceOffset
argument_list|,
name|target
argument_list|,
name|targetOffset
argument_list|,
name|numberToCopy
argument_list|)
expr_stmt|;
block|}
comment|// =================================================================
comment|// Serializable
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
name|Object
name|writeReplace
parameter_list|()
block|{
return|return
name|ByteString
operator|.
name|wrap
argument_list|(
name|toByteArray
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|void
name|readObject
parameter_list|(
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
name|ObjectInputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|InvalidObjectException
argument_list|(
literal|"BoundedByteStream instances are not to be serialized directly"
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

