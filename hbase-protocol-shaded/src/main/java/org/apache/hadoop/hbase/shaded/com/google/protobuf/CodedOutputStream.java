begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|// Protocol Buffers - Google's data interchange format
end_comment

begin_comment
comment|// Copyright 2008 Google Inc.  All rights reserved.
end_comment

begin_comment
comment|// https://developers.google.com/protocol-buffers/
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Redistribution and use in source and binary forms, with or without
end_comment

begin_comment
comment|// modification, are permitted provided that the following conditions are
end_comment

begin_comment
comment|// met:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//     * Redistributions of source code must retain the above copyright
end_comment

begin_comment
comment|// notice, this list of conditions and the following disclaimer.
end_comment

begin_comment
comment|//     * Redistributions in binary form must reproduce the above
end_comment

begin_comment
comment|// copyright notice, this list of conditions and the following disclaimer
end_comment

begin_comment
comment|// in the documentation and/or other materials provided with the
end_comment

begin_comment
comment|// distribution.
end_comment

begin_comment
comment|//     * Neither the name of Google Inc. nor the names of its
end_comment

begin_comment
comment|// contributors may be used to endorse or promote products derived from
end_comment

begin_comment
comment|// this software without specific prior written permission.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
end_comment

begin_comment
comment|// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
end_comment

begin_comment
comment|// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
end_comment

begin_comment
comment|// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
end_comment

begin_comment
comment|// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
end_comment

begin_comment
comment|// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
end_comment

begin_comment
comment|// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
end_comment

begin_comment
comment|// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
end_comment

begin_comment
comment|// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|WireFormat
operator|.
name|FIXED_32_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|WireFormat
operator|.
name|FIXED_64_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|WireFormat
operator|.
name|MAX_VARINT_SIZE
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|Math
operator|.
name|max
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Utf8
operator|.
name|UnpairedSurrogateException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|BufferOverflowException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteOrder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_comment
comment|/**  * Encodes and writes protocol message fields.  *  *<p>This class contains two kinds of methods:  methods that write specific  * protocol message constructs and field types (e.g. {@link #writeTag} and  * {@link #writeInt32}) and methods that write low-level values (e.g.  * {@link #writeRawVarint32} and {@link #writeRawBytes}).  If you are  * writing encoded protocol messages, you should use the former methods, but if  * you are writing some other format of your own design, use the latter.  *  *<p>This class is totally unsynchronized.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|CodedOutputStream
extends|extends
name|ByteOutput
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|logger
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|CodedOutputStream
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|boolean
name|HAS_UNSAFE_ARRAY_OPERATIONS
init|=
name|UnsafeUtil
operator|.
name|hasUnsafeArrayOperations
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|ARRAY_BASE_OFFSET
init|=
name|UnsafeUtil
operator|.
name|getArrayBaseOffset
argument_list|()
decl_stmt|;
comment|/**    * @deprecated Use {@link #computeFixed32SizeNoTag(int)} instead.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
specifier|final
name|int
name|LITTLE_ENDIAN_32_SIZE
init|=
name|FIXED_32_SIZE
decl_stmt|;
comment|/**    * The buffer size used in {@link #newInstance(OutputStream)}.    */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_BUFFER_SIZE
init|=
literal|4096
decl_stmt|;
comment|/**    * Returns the buffer size to efficiently write dataLength bytes to this    * CodedOutputStream. Used by AbstractMessageLite.    *    * @return the buffer size to efficiently write dataLength bytes to this    *         CodedOutputStream.    */
specifier|static
name|int
name|computePreferredBufferSize
parameter_list|(
name|int
name|dataLength
parameter_list|)
block|{
if|if
condition|(
name|dataLength
operator|>
name|DEFAULT_BUFFER_SIZE
condition|)
block|{
return|return
name|DEFAULT_BUFFER_SIZE
return|;
block|}
return|return
name|dataLength
return|;
block|}
comment|/**    * Create a new {@code CodedOutputStream} wrapping the given {@code OutputStream}.    *    *<p> NOTE: The provided {@link OutputStream}<strong>MUST NOT</strong> retain access or    * modify the provided byte arrays. Doing so may result in corrupted data, which would be    * difficult to debug.    */
specifier|public
specifier|static
name|CodedOutputStream
name|newInstance
parameter_list|(
specifier|final
name|OutputStream
name|output
parameter_list|)
block|{
return|return
name|newInstance
argument_list|(
name|output
argument_list|,
name|DEFAULT_BUFFER_SIZE
argument_list|)
return|;
block|}
comment|/**    * Create a new {@code CodedOutputStream} wrapping the given {@code OutputStream} with a given    * buffer size.    *    *<p> NOTE: The provided {@link OutputStream}<strong>MUST NOT</strong> retain access or    * modify the provided byte arrays. Doing so may result in corrupted data, which would be    * difficult to debug.    */
specifier|public
specifier|static
name|CodedOutputStream
name|newInstance
parameter_list|(
specifier|final
name|OutputStream
name|output
parameter_list|,
specifier|final
name|int
name|bufferSize
parameter_list|)
block|{
return|return
operator|new
name|OutputStreamEncoder
argument_list|(
name|output
argument_list|,
name|bufferSize
argument_list|)
return|;
block|}
comment|/**    * Create a new {@code CodedOutputStream} that writes directly to the given    * byte array.  If more bytes are written than fit in the array,    * {@link OutOfSpaceException} will be thrown.  Writing directly to a flat    * array is faster than writing to an {@code OutputStream}.  See also    * {@link ByteString#newCodedBuilder}.    */
specifier|public
specifier|static
name|CodedOutputStream
name|newInstance
parameter_list|(
specifier|final
name|byte
index|[]
name|flatArray
parameter_list|)
block|{
return|return
name|newInstance
argument_list|(
name|flatArray
argument_list|,
literal|0
argument_list|,
name|flatArray
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * Create a new {@code CodedOutputStream} that writes directly to the given    * byte array slice.  If more bytes are written than fit in the slice,    * {@link OutOfSpaceException} will be thrown.  Writing directly to a flat    * array is faster than writing to an {@code OutputStream}.  See also    * {@link ByteString#newCodedBuilder}.    */
specifier|public
specifier|static
name|CodedOutputStream
name|newInstance
parameter_list|(
specifier|final
name|byte
index|[]
name|flatArray
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|)
block|{
return|return
operator|new
name|ArrayEncoder
argument_list|(
name|flatArray
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
comment|/** Create a new {@code CodedOutputStream} that writes to the given {@link ByteBuffer}. */
specifier|public
specifier|static
name|CodedOutputStream
name|newInstance
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|)
block|{
if|if
condition|(
name|buffer
operator|.
name|hasArray
argument_list|()
condition|)
block|{
return|return
operator|new
name|HeapNioEncoder
argument_list|(
name|buffer
argument_list|)
return|;
block|}
if|if
condition|(
name|buffer
operator|.
name|isDirect
argument_list|()
operator|&&
operator|!
name|buffer
operator|.
name|isReadOnly
argument_list|()
condition|)
block|{
return|return
name|UnsafeDirectNioEncoder
operator|.
name|isSupported
argument_list|()
condition|?
name|newUnsafeInstance
argument_list|(
name|buffer
argument_list|)
else|:
name|newSafeInstance
argument_list|(
name|buffer
argument_list|)
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"ByteBuffer is read-only"
argument_list|)
throw|;
block|}
comment|/** For testing purposes only. */
specifier|static
name|CodedOutputStream
name|newUnsafeInstance
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|)
block|{
return|return
operator|new
name|UnsafeDirectNioEncoder
argument_list|(
name|buffer
argument_list|)
return|;
block|}
comment|/** For testing purposes only. */
specifier|static
name|CodedOutputStream
name|newSafeInstance
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|)
block|{
return|return
operator|new
name|SafeDirectNioEncoder
argument_list|(
name|buffer
argument_list|)
return|;
block|}
comment|/**    * Configures serialization to be deterministic.    *    *<p>The deterministic serialization guarantees that for a given binary, equal (defined by the    * {@code equals()} methods in protos) messages will always be serialized to the same bytes. This    * implies:    *    *<ul>    *<li>repeated serialization of a message will return the same bytes    *<li>different processes of the same binary (which may be executing on different machines) will    *     serialize equal messages to the same bytes.    *</ul>    *    *<p>Note the deterministic serialization is NOT canonical across languages; it is also unstable    * across different builds with schema changes due to unknown fields. Users who need canonical    * serialization, e.g. persistent storage in a canonical form, fingerprinting, etc, should define    * their own canonicalization specification and implement the serializer using reflection APIs    * rather than relying on this API.    *    *<p> Once set, the serializer will:  (Note this is an implementation detail and may subject to    * change in the future)    *    *<ul>    *<li> sort map entries by keys in lexicographical order or numerical order. Note: For string    *     keys, the order is based on comparing the Unicode value of each character in the strings.    *     The order may be different from the deterministic serialization in other languages where    *     maps are sorted on the lexicographical order of the UTF8 encoded keys.    *</ul>    */
name|void
name|useDeterministicSerialization
parameter_list|()
block|{
name|serializationDeterministic
operator|=
literal|true
expr_stmt|;
block|}
name|boolean
name|isSerializationDeterministic
parameter_list|()
block|{
return|return
name|serializationDeterministic
return|;
block|}
specifier|private
name|boolean
name|serializationDeterministic
decl_stmt|;
comment|/**    * Create a new {@code CodedOutputStream} that writes to the given {@link ByteBuffer}.    *    * @deprecated the size parameter is no longer used since use of an internal buffer is useless    * (and wasteful) when writing to a {@link ByteBuffer}. Use {@link #newInstance(ByteBuffer)}    * instead.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|CodedOutputStream
name|newInstance
parameter_list|(
name|ByteBuffer
name|byteBuffer
parameter_list|,
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
name|int
name|unused
parameter_list|)
block|{
return|return
name|newInstance
argument_list|(
name|byteBuffer
argument_list|)
return|;
block|}
comment|/**    * Create a new {@code CodedOutputStream} that writes to the provided {@link ByteOutput}.    *    *<p> NOTE: The {@link ByteOutput}<strong>MUST NOT</strong> modify the provided buffers. Doing    * so may result in corrupted data, which would be difficult to debug.    *    * @param byteOutput the output target for encoded bytes.    * @param bufferSize the size of the internal scratch buffer to be used for string encoding.    * Setting this to {@code 0} will disable buffering, requiring an allocation for each encoded    * string.    */
specifier|static
name|CodedOutputStream
name|newInstance
parameter_list|(
name|ByteOutput
name|byteOutput
parameter_list|,
name|int
name|bufferSize
parameter_list|)
block|{
if|if
condition|(
name|bufferSize
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"bufferSize must be positive"
argument_list|)
throw|;
block|}
return|return
operator|new
name|ByteOutputEncoder
argument_list|(
name|byteOutput
argument_list|,
name|bufferSize
argument_list|)
return|;
block|}
comment|// Disallow construction outside of this class.
specifier|private
name|CodedOutputStream
parameter_list|()
block|{   }
comment|// -----------------------------------------------------------------
comment|/** Encode and write a tag. */
comment|// Abstract to avoid overhead of additional virtual method calls.
specifier|public
specifier|abstract
name|void
name|writeTag
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|int
name|wireType
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Write an {@code int32} field, including tag, to the stream. */
comment|// Abstract to avoid overhead of additional virtual method calls.
specifier|public
specifier|abstract
name|void
name|writeInt32
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|int
name|value
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Write a {@code uint32} field, including tag, to the stream. */
comment|// Abstract to avoid overhead of additional virtual method calls.
specifier|public
specifier|abstract
name|void
name|writeUInt32
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|int
name|value
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Write a {@code sint32} field, including tag, to the stream. */
specifier|public
specifier|final
name|void
name|writeSInt32
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt32
argument_list|(
name|fieldNumber
argument_list|,
name|encodeZigZag32
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Write a {@code fixed32} field, including tag, to the stream. */
comment|// Abstract to avoid overhead of additional virtual method calls.
specifier|public
specifier|abstract
name|void
name|writeFixed32
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|int
name|value
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Write an {@code sfixed32} field, including tag, to the stream. */
specifier|public
specifier|final
name|void
name|writeSFixed32
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeFixed32
argument_list|(
name|fieldNumber
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/** Write an {@code int64} field, including tag, to the stream. */
specifier|public
specifier|final
name|void
name|writeInt64
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt64
argument_list|(
name|fieldNumber
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/** Write a {@code uint64} field, including tag, to the stream. */
comment|// Abstract to avoid overhead of additional virtual method calls.
specifier|public
specifier|abstract
name|void
name|writeUInt64
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|long
name|value
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Write an {@code sint64} field, including tag, to the stream. */
specifier|public
specifier|final
name|void
name|writeSInt64
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt64
argument_list|(
name|fieldNumber
argument_list|,
name|encodeZigZag64
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Write a {@code fixed64} field, including tag, to the stream. */
comment|// Abstract to avoid overhead of additional virtual method calls.
specifier|public
specifier|abstract
name|void
name|writeFixed64
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|long
name|value
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Write an {@code sfixed64} field, including tag, to the stream. */
specifier|public
specifier|final
name|void
name|writeSFixed64
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeFixed64
argument_list|(
name|fieldNumber
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/** Write a {@code float} field, including tag, to the stream. */
specifier|public
specifier|final
name|void
name|writeFloat
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|float
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeFixed32
argument_list|(
name|fieldNumber
argument_list|,
name|Float
operator|.
name|floatToRawIntBits
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Write a {@code double} field, including tag, to the stream. */
specifier|public
specifier|final
name|void
name|writeDouble
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|double
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeFixed64
argument_list|(
name|fieldNumber
argument_list|,
name|Double
operator|.
name|doubleToRawLongBits
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Write a {@code bool} field, including tag, to the stream. */
comment|// Abstract to avoid overhead of additional virtual method calls.
specifier|public
specifier|abstract
name|void
name|writeBool
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|boolean
name|value
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Write an enum field, including tag, to the stream. The provided value is the numeric    * value used to represent the enum value on the wire (not the enum ordinal value).    */
specifier|public
specifier|final
name|void
name|writeEnum
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeInt32
argument_list|(
name|fieldNumber
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/** Write a {@code string} field, including tag, to the stream. */
comment|// Abstract to avoid overhead of additional virtual method calls.
specifier|public
specifier|abstract
name|void
name|writeString
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|String
name|value
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Write a {@code bytes} field, including tag, to the stream. */
comment|// Abstract to avoid overhead of additional virtual method calls.
specifier|public
specifier|abstract
name|void
name|writeBytes
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|ByteString
name|value
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Write a {@code bytes} field, including tag, to the stream. */
comment|// Abstract to avoid overhead of additional virtual method calls.
specifier|public
specifier|abstract
name|void
name|writeByteArray
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|byte
index|[]
name|value
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Write a {@code bytes} field, including tag, to the stream. */
comment|// Abstract to avoid overhead of additional virtual method calls.
specifier|public
specifier|abstract
name|void
name|writeByteArray
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|byte
index|[]
name|value
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Write a {@code bytes} field, including tag, to the stream.    * This method will write all content of the ByteBuffer regardless of the    * current position and limit (i.e., the number of bytes to be written is    * value.capacity(), not value.remaining()). Furthermore, this method doesn't    * alter the state of the passed-in ByteBuffer. Its position, limit, mark,    * etc. will remain unchanged. If you only want to write the remaining bytes    * of a ByteBuffer, you can call    * {@code writeByteBuffer(fieldNumber, byteBuffer.slice())}.    */
comment|// Abstract to avoid overhead of additional virtual method calls.
specifier|public
specifier|abstract
name|void
name|writeByteBuffer
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|ByteBuffer
name|value
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Write a single byte.    */
specifier|public
specifier|final
name|void
name|writeRawByte
parameter_list|(
specifier|final
name|byte
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
comment|/** Write a single byte, represented by an integer value. */
specifier|public
specifier|final
name|void
name|writeRawByte
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
operator|(
name|byte
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
comment|/** Write an array of bytes. */
specifier|public
specifier|final
name|void
name|writeRawBytes
parameter_list|(
specifier|final
name|byte
index|[]
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
name|value
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**    * Write part of an array of bytes.    */
specifier|public
specifier|final
name|void
name|writeRawBytes
parameter_list|(
specifier|final
name|byte
index|[]
name|value
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
name|value
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|/** Write a byte string. */
specifier|public
specifier|final
name|void
name|writeRawBytes
parameter_list|(
specifier|final
name|ByteString
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|value
operator|.
name|writeTo
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**    * Write a ByteBuffer. This method will write all content of the ByteBuffer    * regardless of the current position and limit (i.e., the number of bytes    * to be written is value.capacity(), not value.remaining()). Furthermore,    * this method doesn't alter the state of the passed-in ByteBuffer. Its    * position, limit, mark, etc. will remain unchanged. If you only want to    * write the remaining bytes of a ByteBuffer, you can call    * {@code writeRawBytes(byteBuffer.slice())}.    */
comment|// Abstract to avoid overhead of additional virtual method calls.
specifier|public
specifier|abstract
name|void
name|writeRawBytes
parameter_list|(
specifier|final
name|ByteBuffer
name|value
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Write an embedded message field, including tag, to the stream. */
comment|// Abstract to avoid overhead of additional virtual method calls.
specifier|public
specifier|abstract
name|void
name|writeMessage
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|MessageLite
name|value
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Write a MessageSet extension field to the stream.  For historical reasons,    * the wire format differs from normal fields.    */
comment|// Abstract to avoid overhead of additional virtual method calls.
specifier|public
specifier|abstract
name|void
name|writeMessageSetExtension
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|MessageLite
name|value
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Write an unparsed MessageSet extension field to the stream.  For    * historical reasons, the wire format differs from normal fields.    */
comment|// Abstract to avoid overhead of additional virtual method calls.
specifier|public
specifier|abstract
name|void
name|writeRawMessageSetExtension
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|ByteString
name|value
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|// -----------------------------------------------------------------
comment|/** Write an {@code int32} field to the stream. */
comment|// Abstract to avoid overhead of additional virtual method calls.
specifier|public
specifier|abstract
name|void
name|writeInt32NoTag
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Write a {@code uint32} field to the stream. */
comment|// Abstract to avoid overhead of additional virtual method calls.
specifier|public
specifier|abstract
name|void
name|writeUInt32NoTag
parameter_list|(
name|int
name|value
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Write a {@code sint32} field to the stream. */
specifier|public
specifier|final
name|void
name|writeSInt32NoTag
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt32NoTag
argument_list|(
name|encodeZigZag32
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Write a {@code fixed32} field to the stream. */
comment|// Abstract to avoid overhead of additional virtual method calls.
specifier|public
specifier|abstract
name|void
name|writeFixed32NoTag
parameter_list|(
name|int
name|value
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Write a {@code sfixed32} field to the stream. */
specifier|public
specifier|final
name|void
name|writeSFixed32NoTag
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeFixed32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
comment|/** Write an {@code int64} field to the stream. */
specifier|public
specifier|final
name|void
name|writeInt64NoTag
parameter_list|(
specifier|final
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
comment|/** Write a {@code uint64} field to the stream. */
comment|// Abstract to avoid overhead of additional virtual method calls.
specifier|public
specifier|abstract
name|void
name|writeUInt64NoTag
parameter_list|(
name|long
name|value
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Write a {@code sint64} field to the stream. */
specifier|public
specifier|final
name|void
name|writeSInt64NoTag
parameter_list|(
specifier|final
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt64NoTag
argument_list|(
name|encodeZigZag64
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Write a {@code fixed64} field to the stream. */
comment|// Abstract to avoid overhead of additional virtual method calls.
specifier|public
specifier|abstract
name|void
name|writeFixed64NoTag
parameter_list|(
name|long
name|value
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Write a {@code sfixed64} field to the stream. */
specifier|public
specifier|final
name|void
name|writeSFixed64NoTag
parameter_list|(
specifier|final
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeFixed64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
comment|/** Write a {@code float} field to the stream. */
specifier|public
specifier|final
name|void
name|writeFloatNoTag
parameter_list|(
specifier|final
name|float
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeFixed32NoTag
argument_list|(
name|Float
operator|.
name|floatToRawIntBits
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Write a {@code double} field to the stream. */
specifier|public
specifier|final
name|void
name|writeDoubleNoTag
parameter_list|(
specifier|final
name|double
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeFixed64NoTag
argument_list|(
name|Double
operator|.
name|doubleToRawLongBits
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Write a {@code bool} field to the stream. */
specifier|public
specifier|final
name|void
name|writeBoolNoTag
parameter_list|(
specifier|final
name|boolean
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|value
condition|?
literal|1
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Write an enum field to the stream. The provided value is the numeric    * value used to represent the enum value on the wire (not the enum ordinal value).    */
specifier|public
specifier|final
name|void
name|writeEnumNoTag
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeInt32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
comment|/** Write a {@code string} field to the stream. */
comment|// TODO(dweis): Document behavior on ill-formed UTF-16 input.
comment|// Abstract to avoid overhead of additional virtual method calls.
specifier|public
specifier|abstract
name|void
name|writeStringNoTag
parameter_list|(
name|String
name|value
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Write a {@code bytes} field to the stream. */
comment|// Abstract to avoid overhead of additional virtual method calls.
specifier|public
specifier|abstract
name|void
name|writeBytesNoTag
parameter_list|(
specifier|final
name|ByteString
name|value
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Write a {@code bytes} field to the stream. */
specifier|public
specifier|final
name|void
name|writeByteArrayNoTag
parameter_list|(
specifier|final
name|byte
index|[]
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeByteArrayNoTag
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
name|value
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/** Write an embedded message field to the stream. */
comment|// Abstract to avoid overhead of additional virtual method calls.
specifier|public
specifier|abstract
name|void
name|writeMessageNoTag
parameter_list|(
specifier|final
name|MessageLite
name|value
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|//=================================================================
annotation|@
name|ExperimentalApi
annotation|@
name|Override
specifier|public
specifier|abstract
name|void
name|write
parameter_list|(
name|byte
name|value
parameter_list|)
throws|throws
name|IOException
function_decl|;
annotation|@
name|ExperimentalApi
annotation|@
name|Override
specifier|public
specifier|abstract
name|void
name|write
parameter_list|(
name|byte
index|[]
name|value
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
function_decl|;
annotation|@
name|ExperimentalApi
annotation|@
name|Override
specifier|public
specifier|abstract
name|void
name|writeLazy
parameter_list|(
name|byte
index|[]
name|value
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
function_decl|;
annotation|@
name|Override
specifier|public
specifier|abstract
name|void
name|write
parameter_list|(
name|ByteBuffer
name|value
parameter_list|)
throws|throws
name|IOException
function_decl|;
annotation|@
name|ExperimentalApi
annotation|@
name|Override
specifier|public
specifier|abstract
name|void
name|writeLazy
parameter_list|(
name|ByteBuffer
name|value
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|// =================================================================
comment|// =================================================================
comment|/**    * Compute the number of bytes that would be needed to encode an    * {@code int32} field, including tag.    */
specifier|public
specifier|static
name|int
name|computeInt32Size
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|int
name|value
parameter_list|)
block|{
return|return
name|computeTagSize
argument_list|(
name|fieldNumber
argument_list|)
operator|+
name|computeInt32SizeNoTag
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a    * {@code uint32} field, including tag.    */
specifier|public
specifier|static
name|int
name|computeUInt32Size
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|int
name|value
parameter_list|)
block|{
return|return
name|computeTagSize
argument_list|(
name|fieldNumber
argument_list|)
operator|+
name|computeUInt32SizeNoTag
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode an    * {@code sint32} field, including tag.    */
specifier|public
specifier|static
name|int
name|computeSInt32Size
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|int
name|value
parameter_list|)
block|{
return|return
name|computeTagSize
argument_list|(
name|fieldNumber
argument_list|)
operator|+
name|computeSInt32SizeNoTag
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a    * {@code fixed32} field, including tag.    */
specifier|public
specifier|static
name|int
name|computeFixed32Size
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|int
name|value
parameter_list|)
block|{
return|return
name|computeTagSize
argument_list|(
name|fieldNumber
argument_list|)
operator|+
name|computeFixed32SizeNoTag
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode an    * {@code sfixed32} field, including tag.    */
specifier|public
specifier|static
name|int
name|computeSFixed32Size
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|int
name|value
parameter_list|)
block|{
return|return
name|computeTagSize
argument_list|(
name|fieldNumber
argument_list|)
operator|+
name|computeSFixed32SizeNoTag
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode an    * {@code int64} field, including tag.    */
specifier|public
specifier|static
name|int
name|computeInt64Size
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|long
name|value
parameter_list|)
block|{
return|return
name|computeTagSize
argument_list|(
name|fieldNumber
argument_list|)
operator|+
name|computeInt64SizeNoTag
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a    * {@code uint64} field, including tag.    */
specifier|public
specifier|static
name|int
name|computeUInt64Size
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|long
name|value
parameter_list|)
block|{
return|return
name|computeTagSize
argument_list|(
name|fieldNumber
argument_list|)
operator|+
name|computeUInt64SizeNoTag
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode an    * {@code sint64} field, including tag.    */
specifier|public
specifier|static
name|int
name|computeSInt64Size
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|long
name|value
parameter_list|)
block|{
return|return
name|computeTagSize
argument_list|(
name|fieldNumber
argument_list|)
operator|+
name|computeSInt64SizeNoTag
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a    * {@code fixed64} field, including tag.    */
specifier|public
specifier|static
name|int
name|computeFixed64Size
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|long
name|value
parameter_list|)
block|{
return|return
name|computeTagSize
argument_list|(
name|fieldNumber
argument_list|)
operator|+
name|computeFixed64SizeNoTag
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode an    * {@code sfixed64} field, including tag.    */
specifier|public
specifier|static
name|int
name|computeSFixed64Size
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|long
name|value
parameter_list|)
block|{
return|return
name|computeTagSize
argument_list|(
name|fieldNumber
argument_list|)
operator|+
name|computeSFixed64SizeNoTag
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a    * {@code float} field, including tag.    */
specifier|public
specifier|static
name|int
name|computeFloatSize
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|float
name|value
parameter_list|)
block|{
return|return
name|computeTagSize
argument_list|(
name|fieldNumber
argument_list|)
operator|+
name|computeFloatSizeNoTag
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a    * {@code double} field, including tag.    */
specifier|public
specifier|static
name|int
name|computeDoubleSize
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|double
name|value
parameter_list|)
block|{
return|return
name|computeTagSize
argument_list|(
name|fieldNumber
argument_list|)
operator|+
name|computeDoubleSizeNoTag
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a    * {@code bool} field, including tag.    */
specifier|public
specifier|static
name|int
name|computeBoolSize
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|boolean
name|value
parameter_list|)
block|{
return|return
name|computeTagSize
argument_list|(
name|fieldNumber
argument_list|)
operator|+
name|computeBoolSizeNoTag
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode an    * enum field, including tag. The provided value is the numeric    * value used to represent the enum value on the wire (not the enum ordinal value).    */
specifier|public
specifier|static
name|int
name|computeEnumSize
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|int
name|value
parameter_list|)
block|{
return|return
name|computeTagSize
argument_list|(
name|fieldNumber
argument_list|)
operator|+
name|computeEnumSizeNoTag
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a    * {@code string} field, including tag.    */
specifier|public
specifier|static
name|int
name|computeStringSize
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|String
name|value
parameter_list|)
block|{
return|return
name|computeTagSize
argument_list|(
name|fieldNumber
argument_list|)
operator|+
name|computeStringSizeNoTag
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a    * {@code bytes} field, including tag.    */
specifier|public
specifier|static
name|int
name|computeBytesSize
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|ByteString
name|value
parameter_list|)
block|{
return|return
name|computeTagSize
argument_list|(
name|fieldNumber
argument_list|)
operator|+
name|computeBytesSizeNoTag
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a    * {@code bytes} field, including tag.    */
specifier|public
specifier|static
name|int
name|computeByteArraySize
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|)
block|{
return|return
name|computeTagSize
argument_list|(
name|fieldNumber
argument_list|)
operator|+
name|computeByteArraySizeNoTag
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a    * {@code bytes} field, including tag.    */
specifier|public
specifier|static
name|int
name|computeByteBufferSize
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|ByteBuffer
name|value
parameter_list|)
block|{
return|return
name|computeTagSize
argument_list|(
name|fieldNumber
argument_list|)
operator|+
name|computeByteBufferSizeNoTag
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode an    * embedded message in lazy field, including tag.    */
specifier|public
specifier|static
name|int
name|computeLazyFieldSize
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|LazyFieldLite
name|value
parameter_list|)
block|{
return|return
name|computeTagSize
argument_list|(
name|fieldNumber
argument_list|)
operator|+
name|computeLazyFieldSizeNoTag
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode an    * embedded message field, including tag.    */
specifier|public
specifier|static
name|int
name|computeMessageSize
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|MessageLite
name|value
parameter_list|)
block|{
return|return
name|computeTagSize
argument_list|(
name|fieldNumber
argument_list|)
operator|+
name|computeMessageSizeNoTag
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a    * MessageSet extension to the stream.  For historical reasons,    * the wire format differs from normal fields.    */
specifier|public
specifier|static
name|int
name|computeMessageSetExtensionSize
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|MessageLite
name|value
parameter_list|)
block|{
return|return
name|computeTagSize
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_ITEM
argument_list|)
operator|*
literal|2
operator|+
name|computeUInt32Size
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_TYPE_ID
argument_list|,
name|fieldNumber
argument_list|)
operator|+
name|computeMessageSize
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_MESSAGE
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode an    * unparsed MessageSet extension field to the stream.  For    * historical reasons, the wire format differs from normal fields.    */
specifier|public
specifier|static
name|int
name|computeRawMessageSetExtensionSize
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|ByteString
name|value
parameter_list|)
block|{
return|return
name|computeTagSize
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_ITEM
argument_list|)
operator|*
literal|2
operator|+
name|computeUInt32Size
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_TYPE_ID
argument_list|,
name|fieldNumber
argument_list|)
operator|+
name|computeBytesSize
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_MESSAGE
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode an    * lazily parsed MessageSet extension field to the stream.  For    * historical reasons, the wire format differs from normal fields.    */
specifier|public
specifier|static
name|int
name|computeLazyFieldMessageSetExtensionSize
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|LazyFieldLite
name|value
parameter_list|)
block|{
return|return
name|computeTagSize
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_ITEM
argument_list|)
operator|*
literal|2
operator|+
name|computeUInt32Size
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_TYPE_ID
argument_list|,
name|fieldNumber
argument_list|)
operator|+
name|computeLazyFieldSize
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_MESSAGE
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|// -----------------------------------------------------------------
comment|/** Compute the number of bytes that would be needed to encode a tag. */
specifier|public
specifier|static
name|int
name|computeTagSize
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|)
block|{
return|return
name|computeUInt32SizeNoTag
argument_list|(
name|WireFormat
operator|.
name|makeTag
argument_list|(
name|fieldNumber
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode an    * {@code int32} field, including tag.    */
specifier|public
specifier|static
name|int
name|computeInt32SizeNoTag
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|>=
literal|0
condition|)
block|{
return|return
name|computeUInt32SizeNoTag
argument_list|(
name|value
argument_list|)
return|;
block|}
else|else
block|{
comment|// Must sign-extend.
return|return
name|MAX_VARINT_SIZE
return|;
block|}
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a    * {@code uint32} field.    */
specifier|public
specifier|static
name|int
name|computeUInt32SizeNoTag
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
block|{
if|if
condition|(
operator|(
name|value
operator|&
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|value
operator|&
operator|(
operator|~
literal|0
operator|<<
literal|14
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
literal|2
return|;
block|}
if|if
condition|(
operator|(
name|value
operator|&
operator|(
operator|~
literal|0
operator|<<
literal|21
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
literal|3
return|;
block|}
if|if
condition|(
operator|(
name|value
operator|&
operator|(
operator|~
literal|0
operator|<<
literal|28
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
literal|4
return|;
block|}
return|return
literal|5
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode an    * {@code sint32} field.    */
specifier|public
specifier|static
name|int
name|computeSInt32SizeNoTag
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
block|{
return|return
name|computeUInt32SizeNoTag
argument_list|(
name|encodeZigZag32
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a    * {@code fixed32} field.    */
specifier|public
specifier|static
name|int
name|computeFixed32SizeNoTag
parameter_list|(
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|final
name|int
name|unused
parameter_list|)
block|{
return|return
name|FIXED_32_SIZE
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode an    * {@code sfixed32} field.    */
specifier|public
specifier|static
name|int
name|computeSFixed32SizeNoTag
parameter_list|(
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|final
name|int
name|unused
parameter_list|)
block|{
return|return
name|FIXED_32_SIZE
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode an    * {@code int64} field, including tag.    */
specifier|public
specifier|static
name|int
name|computeInt64SizeNoTag
parameter_list|(
specifier|final
name|long
name|value
parameter_list|)
block|{
return|return
name|computeUInt64SizeNoTag
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a    * {@code uint64} field, including tag.    */
specifier|public
specifier|static
name|int
name|computeUInt64SizeNoTag
parameter_list|(
name|long
name|value
parameter_list|)
block|{
comment|// handle two popular special cases up front ...
if|if
condition|(
operator|(
name|value
operator|&
operator|(
operator|~
literal|0L
operator|<<
literal|7
operator|)
operator|)
operator|==
literal|0L
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|value
operator|<
literal|0L
condition|)
block|{
return|return
literal|10
return|;
block|}
comment|// ... leaving us with 8 remaining, which we can divide and conquer
name|int
name|n
init|=
literal|2
decl_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
operator|(
operator|~
literal|0L
operator|<<
literal|35
operator|)
operator|)
operator|!=
literal|0L
condition|)
block|{
name|n
operator|+=
literal|4
expr_stmt|;
name|value
operator|>>>=
literal|28
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|value
operator|&
operator|(
operator|~
literal|0L
operator|<<
literal|21
operator|)
operator|)
operator|!=
literal|0L
condition|)
block|{
name|n
operator|+=
literal|2
expr_stmt|;
name|value
operator|>>>=
literal|14
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|value
operator|&
operator|(
operator|~
literal|0L
operator|<<
literal|14
operator|)
operator|)
operator|!=
literal|0L
condition|)
block|{
name|n
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode an    * {@code sint64} field.    */
specifier|public
specifier|static
name|int
name|computeSInt64SizeNoTag
parameter_list|(
specifier|final
name|long
name|value
parameter_list|)
block|{
return|return
name|computeUInt64SizeNoTag
argument_list|(
name|encodeZigZag64
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a    * {@code fixed64} field.    */
specifier|public
specifier|static
name|int
name|computeFixed64SizeNoTag
parameter_list|(
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|final
name|long
name|unused
parameter_list|)
block|{
return|return
name|FIXED_64_SIZE
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode an    * {@code sfixed64} field.    */
specifier|public
specifier|static
name|int
name|computeSFixed64SizeNoTag
parameter_list|(
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|final
name|long
name|unused
parameter_list|)
block|{
return|return
name|FIXED_64_SIZE
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a    * {@code float} field, including tag.    */
specifier|public
specifier|static
name|int
name|computeFloatSizeNoTag
parameter_list|(
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|final
name|float
name|unused
parameter_list|)
block|{
return|return
name|FIXED_32_SIZE
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a    * {@code double} field, including tag.    */
specifier|public
specifier|static
name|int
name|computeDoubleSizeNoTag
parameter_list|(
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|final
name|double
name|unused
parameter_list|)
block|{
return|return
name|FIXED_64_SIZE
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a    * {@code bool} field.    */
specifier|public
specifier|static
name|int
name|computeBoolSizeNoTag
parameter_list|(
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|final
name|boolean
name|unused
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode an enum field.    * The provided value is the numeric value used to represent the enum value on the wire    * (not the enum ordinal value).    */
specifier|public
specifier|static
name|int
name|computeEnumSizeNoTag
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
block|{
return|return
name|computeInt32SizeNoTag
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a    * {@code string} field.    */
specifier|public
specifier|static
name|int
name|computeStringSizeNoTag
parameter_list|(
specifier|final
name|String
name|value
parameter_list|)
block|{
name|int
name|length
decl_stmt|;
try|try
block|{
name|length
operator|=
name|Utf8
operator|.
name|encodedLength
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnpairedSurrogateException
name|e
parameter_list|)
block|{
comment|// TODO(dweis): Consider using nio Charset methods instead.
specifier|final
name|byte
index|[]
name|bytes
init|=
name|value
operator|.
name|getBytes
argument_list|(
name|Internal
operator|.
name|UTF_8
argument_list|)
decl_stmt|;
name|length
operator|=
name|bytes
operator|.
name|length
expr_stmt|;
block|}
return|return
name|computeLengthDelimitedFieldSize
argument_list|(
name|length
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode an embedded    * message stored in lazy field.    */
specifier|public
specifier|static
name|int
name|computeLazyFieldSizeNoTag
parameter_list|(
specifier|final
name|LazyFieldLite
name|value
parameter_list|)
block|{
return|return
name|computeLengthDelimitedFieldSize
argument_list|(
name|value
operator|.
name|getSerializedSize
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a    * {@code bytes} field.    */
specifier|public
specifier|static
name|int
name|computeBytesSizeNoTag
parameter_list|(
specifier|final
name|ByteString
name|value
parameter_list|)
block|{
return|return
name|computeLengthDelimitedFieldSize
argument_list|(
name|value
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a    * {@code bytes} field.    */
specifier|public
specifier|static
name|int
name|computeByteArraySizeNoTag
parameter_list|(
specifier|final
name|byte
index|[]
name|value
parameter_list|)
block|{
return|return
name|computeLengthDelimitedFieldSize
argument_list|(
name|value
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a    * {@code bytes} field.    */
specifier|public
specifier|static
name|int
name|computeByteBufferSizeNoTag
parameter_list|(
specifier|final
name|ByteBuffer
name|value
parameter_list|)
block|{
return|return
name|computeLengthDelimitedFieldSize
argument_list|(
name|value
operator|.
name|capacity
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode an embedded    * message field.    */
specifier|public
specifier|static
name|int
name|computeMessageSizeNoTag
parameter_list|(
specifier|final
name|MessageLite
name|value
parameter_list|)
block|{
return|return
name|computeLengthDelimitedFieldSize
argument_list|(
name|value
operator|.
name|getSerializedSize
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|int
name|computeLengthDelimitedFieldSize
parameter_list|(
name|int
name|fieldLength
parameter_list|)
block|{
return|return
name|computeUInt32SizeNoTag
argument_list|(
name|fieldLength
argument_list|)
operator|+
name|fieldLength
return|;
block|}
comment|/**    * Encode a ZigZag-encoded 32-bit value.  ZigZag encodes signed integers    * into values that can be efficiently encoded with varint.  (Otherwise,    * negative values must be sign-extended to 64 bits to be varint encoded,    * thus always taking 10 bytes on the wire.)    *    * @param n A signed 32-bit integer.    * @return An unsigned 32-bit integer, stored in a signed int because    *         Java has no explicit unsigned support.    */
specifier|public
specifier|static
name|int
name|encodeZigZag32
parameter_list|(
specifier|final
name|int
name|n
parameter_list|)
block|{
comment|// Note:  the right-shift must be arithmetic
return|return
operator|(
name|n
operator|<<
literal|1
operator|)
operator|^
operator|(
name|n
operator|>>
literal|31
operator|)
return|;
block|}
comment|/**    * Encode a ZigZag-encoded 64-bit value.  ZigZag encodes signed integers    * into values that can be efficiently encoded with varint.  (Otherwise,    * negative values must be sign-extended to 64 bits to be varint encoded,    * thus always taking 10 bytes on the wire.)    *    * @param n A signed 64-bit integer.    * @return An unsigned 64-bit integer, stored in a signed int because    *         Java has no explicit unsigned support.    */
specifier|public
specifier|static
name|long
name|encodeZigZag64
parameter_list|(
specifier|final
name|long
name|n
parameter_list|)
block|{
comment|// Note:  the right-shift must be arithmetic
return|return
operator|(
name|n
operator|<<
literal|1
operator|)
operator|^
operator|(
name|n
operator|>>
literal|63
operator|)
return|;
block|}
comment|// =================================================================
comment|/**    * Flushes the stream and forces any buffered bytes to be written.  This    * does not flush the underlying OutputStream.    */
specifier|public
specifier|abstract
name|void
name|flush
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**    * If writing to a flat array, return the space left in the array.    * Otherwise, throws {@code UnsupportedOperationException}.    */
specifier|public
specifier|abstract
name|int
name|spaceLeft
parameter_list|()
function_decl|;
comment|/**    * Verifies that {@link #spaceLeft()} returns zero.  It's common to create    * a byte array that is exactly big enough to hold a message, then write to    * it with a {@code CodedOutputStream}.  Calling {@code checkNoSpaceLeft()}    * after writing verifies that the message was actually as big as expected,    * which can help catch bugs.    */
specifier|public
specifier|final
name|void
name|checkNoSpaceLeft
parameter_list|()
block|{
if|if
condition|(
name|spaceLeft
argument_list|()
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Did not write as much data as expected."
argument_list|)
throw|;
block|}
block|}
comment|/**    * If you create a CodedOutputStream around a simple flat array, you must    * not attempt to write more bytes than the array has space.  Otherwise,    * this exception will be thrown.    */
specifier|public
specifier|static
class|class
name|OutOfSpaceException
extends|extends
name|IOException
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
operator|-
literal|6947486886997889499L
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|MESSAGE
init|=
literal|"CodedOutputStream was writing to a flat byte array and ran out of space."
decl_stmt|;
name|OutOfSpaceException
parameter_list|()
block|{
name|super
argument_list|(
name|MESSAGE
argument_list|)
expr_stmt|;
block|}
name|OutOfSpaceException
parameter_list|(
name|String
name|explanationMessage
parameter_list|)
block|{
name|super
argument_list|(
name|MESSAGE
operator|+
literal|": "
operator|+
name|explanationMessage
argument_list|)
expr_stmt|;
block|}
name|OutOfSpaceException
parameter_list|(
name|Throwable
name|cause
parameter_list|)
block|{
name|super
argument_list|(
name|MESSAGE
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
name|OutOfSpaceException
parameter_list|(
name|String
name|explanationMessage
parameter_list|,
name|Throwable
name|cause
parameter_list|)
block|{
name|super
argument_list|(
name|MESSAGE
operator|+
literal|": "
operator|+
name|explanationMessage
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get the total number of bytes successfully written to this stream.  The    * returned value is not guaranteed to be accurate if exceptions have been    * found in the middle of writing.    */
specifier|public
specifier|abstract
name|int
name|getTotalBytesWritten
parameter_list|()
function_decl|;
comment|// =================================================================
comment|/** Write a {@code bytes} field to the stream. Visible for testing. */
specifier|abstract
name|void
name|writeByteArrayNoTag
parameter_list|(
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|)
throws|throws
name|IOException
function_decl|;
specifier|final
name|void
name|inefficientWriteStringNoTag
parameter_list|(
name|String
name|value
parameter_list|,
name|UnpairedSurrogateException
name|cause
parameter_list|)
throws|throws
name|IOException
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"Converting ill-formed UTF-16. Your Protocol Buffer will not round trip correctly!"
argument_list|,
name|cause
argument_list|)
expr_stmt|;
comment|// Unfortunately there does not appear to be any way to tell Java to encode
comment|// UTF-8 directly into our buffer, so we have to let it create its own byte
comment|// array and then copy.
comment|// TODO(dweis): Consider using nio Charset methods instead.
specifier|final
name|byte
index|[]
name|bytes
init|=
name|value
operator|.
name|getBytes
argument_list|(
name|Internal
operator|.
name|UTF_8
argument_list|)
decl_stmt|;
try|try
block|{
name|writeUInt32NoTag
argument_list|(
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|writeLazy
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|OutOfSpaceException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
block|}
comment|// =================================================================
comment|/**    * Write a {@code group} field, including tag, to the stream.    *    * @deprecated groups are deprecated.    */
annotation|@
name|Deprecated
specifier|public
specifier|final
name|void
name|writeGroup
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|MessageLite
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_START_GROUP
argument_list|)
expr_stmt|;
name|writeGroupNoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
argument_list|)
expr_stmt|;
block|}
comment|/**    * Write a {@code group} field to the stream.    *    * @deprecated groups are deprecated.    */
annotation|@
name|Deprecated
specifier|public
specifier|final
name|void
name|writeGroupNoTag
parameter_list|(
specifier|final
name|MessageLite
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|value
operator|.
name|writeTo
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a    * {@code group} field, including tag.    *    * @deprecated groups are deprecated.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|int
name|computeGroupSize
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|MessageLite
name|value
parameter_list|)
block|{
return|return
name|computeTagSize
argument_list|(
name|fieldNumber
argument_list|)
operator|*
literal|2
operator|+
name|computeGroupSizeNoTag
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a    * {@code group} field.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|int
name|computeGroupSizeNoTag
parameter_list|(
specifier|final
name|MessageLite
name|value
parameter_list|)
block|{
return|return
name|value
operator|.
name|getSerializedSize
argument_list|()
return|;
block|}
comment|/**    * Encode and write a varint.  {@code value} is treated as    * unsigned, so it won't be sign-extended if negative.    *    * @deprecated use {@link #writeUInt32NoTag} instead.    */
annotation|@
name|Deprecated
specifier|public
specifier|final
name|void
name|writeRawVarint32
parameter_list|(
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**    * Encode and write a varint.    *    * @deprecated use {@link #writeUInt64NoTag} instead.    */
annotation|@
name|Deprecated
specifier|public
specifier|final
name|void
name|writeRawVarint64
parameter_list|(
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a varint.    * {@code value} is treated as unsigned, so it won't be sign-extended if    * negative.    *    * @deprecated use {@link #computeUInt32SizeNoTag(int)} instead.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|int
name|computeRawVarint32Size
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
block|{
return|return
name|computeUInt32SizeNoTag
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a varint.    *    * @deprecated use {@link #computeUInt64SizeNoTag(long)} instead.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|int
name|computeRawVarint64Size
parameter_list|(
name|long
name|value
parameter_list|)
block|{
return|return
name|computeUInt64SizeNoTag
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * Write a little-endian 32-bit integer.    *    * @deprecated Use {@link #writeFixed32NoTag} instead.    */
annotation|@
name|Deprecated
specifier|public
specifier|final
name|void
name|writeRawLittleEndian32
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeFixed32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**    * Write a little-endian 64-bit integer.    *    * @deprecated Use {@link #writeFixed64NoTag} instead.    */
annotation|@
name|Deprecated
specifier|public
specifier|final
name|void
name|writeRawLittleEndian64
parameter_list|(
specifier|final
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeFixed64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
comment|// =================================================================
comment|/**    * A {@link CodedOutputStream} that writes directly to a byte array.    */
specifier|private
specifier|static
class|class
name|ArrayEncoder
extends|extends
name|CodedOutputStream
block|{
specifier|private
specifier|final
name|byte
index|[]
name|buffer
decl_stmt|;
specifier|private
specifier|final
name|int
name|offset
decl_stmt|;
specifier|private
specifier|final
name|int
name|limit
decl_stmt|;
specifier|private
name|int
name|position
decl_stmt|;
name|ArrayEncoder
parameter_list|(
name|byte
index|[]
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
name|buffer
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"buffer"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|offset
operator||
name|length
operator||
operator|(
name|buffer
operator|.
name|length
operator|-
operator|(
name|offset
operator|+
name|length
operator|)
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Array range is invalid. Buffer.length=%d, offset=%d, length=%d"
argument_list|,
name|buffer
operator|.
name|length
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|)
throw|;
block|}
name|this
operator|.
name|buffer
operator|=
name|buffer
expr_stmt|;
name|this
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|position
operator|=
name|offset
expr_stmt|;
name|limit
operator|=
name|offset
operator|+
name|length
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeTag
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|int
name|wireType
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt32NoTag
argument_list|(
name|WireFormat
operator|.
name|makeTag
argument_list|(
name|fieldNumber
argument_list|,
name|wireType
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeInt32
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_VARINT
argument_list|)
expr_stmt|;
name|writeInt32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeUInt32
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_VARINT
argument_list|)
expr_stmt|;
name|writeUInt32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeFixed32
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_FIXED32
argument_list|)
expr_stmt|;
name|writeFixed32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeUInt64
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_VARINT
argument_list|)
expr_stmt|;
name|writeUInt64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeFixed64
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_FIXED64
argument_list|)
expr_stmt|;
name|writeFixed64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeBool
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|boolean
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_VARINT
argument_list|)
expr_stmt|;
name|write
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|value
condition|?
literal|1
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeString
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|String
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
argument_list|)
expr_stmt|;
name|writeStringNoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeBytes
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|ByteString
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
argument_list|)
expr_stmt|;
name|writeBytesNoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeByteArray
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeByteArray
argument_list|(
name|fieldNumber
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|value
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeByteArray
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
argument_list|)
expr_stmt|;
name|writeByteArrayNoTag
argument_list|(
name|value
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeByteBuffer
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|ByteBuffer
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
argument_list|)
expr_stmt|;
name|writeUInt32NoTag
argument_list|(
name|value
operator|.
name|capacity
argument_list|()
argument_list|)
expr_stmt|;
name|writeRawBytes
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeBytesNoTag
parameter_list|(
specifier|final
name|ByteString
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt32NoTag
argument_list|(
name|value
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|value
operator|.
name|writeTo
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeByteArrayNoTag
parameter_list|(
specifier|final
name|byte
index|[]
name|value
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt32NoTag
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|value
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeRawBytes
parameter_list|(
specifier|final
name|ByteBuffer
name|value
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|value
operator|.
name|hasArray
argument_list|()
condition|)
block|{
name|write
argument_list|(
name|value
operator|.
name|array
argument_list|()
argument_list|,
name|value
operator|.
name|arrayOffset
argument_list|()
argument_list|,
name|value
operator|.
name|capacity
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ByteBuffer
name|duplicated
init|=
name|value
operator|.
name|duplicate
argument_list|()
decl_stmt|;
name|duplicated
operator|.
name|clear
argument_list|()
expr_stmt|;
name|write
argument_list|(
name|duplicated
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeMessage
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|MessageLite
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
argument_list|)
expr_stmt|;
name|writeMessageNoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeMessageSetExtension
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|MessageLite
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_ITEM
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_START_GROUP
argument_list|)
expr_stmt|;
name|writeUInt32
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_TYPE_ID
argument_list|,
name|fieldNumber
argument_list|)
expr_stmt|;
name|writeMessage
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_MESSAGE
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|writeTag
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_ITEM
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeRawMessageSetExtension
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|ByteString
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_ITEM
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_START_GROUP
argument_list|)
expr_stmt|;
name|writeUInt32
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_TYPE_ID
argument_list|,
name|fieldNumber
argument_list|)
expr_stmt|;
name|writeBytes
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_MESSAGE
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|writeTag
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_ITEM
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeMessageNoTag
parameter_list|(
specifier|final
name|MessageLite
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt32NoTag
argument_list|(
name|value
operator|.
name|getSerializedSize
argument_list|()
argument_list|)
expr_stmt|;
name|value
operator|.
name|writeTo
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|write
parameter_list|(
name|byte
name|value
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|buffer
index|[
name|position
operator|++
index|]
operator|=
name|value
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Pos: %d, limit: %d, len: %d"
argument_list|,
name|position
argument_list|,
name|limit
argument_list|,
literal|1
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeInt32NoTag
parameter_list|(
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|value
operator|>=
literal|0
condition|)
block|{
name|writeUInt32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Must sign-extend.
name|writeUInt64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeUInt32NoTag
parameter_list|(
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|HAS_UNSAFE_ARRAY_OPERATIONS
operator|&&
name|spaceLeft
argument_list|()
operator|>=
name|MAX_VARINT_SIZE
condition|)
block|{
name|long
name|pos
init|=
name|ARRAY_BASE_OFFSET
operator|+
name|position
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
operator|(
name|value
operator|&
operator|~
literal|0x7F
operator|)
operator|==
literal|0
condition|)
block|{
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|buffer
argument_list|,
name|pos
operator|++
argument_list|,
operator|(
name|byte
operator|)
name|value
argument_list|)
expr_stmt|;
name|position
operator|++
expr_stmt|;
return|return;
block|}
else|else
block|{
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|buffer
argument_list|,
name|pos
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
operator|(
name|value
operator|&
literal|0x7F
operator|)
operator||
literal|0x80
argument_list|)
argument_list|)
expr_stmt|;
name|position
operator|++
expr_stmt|;
name|value
operator|>>>=
literal|7
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
operator|(
name|value
operator|&
operator|~
literal|0x7F
operator|)
operator|==
literal|0
condition|)
block|{
name|buffer
index|[
name|position
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|value
expr_stmt|;
return|return;
block|}
else|else
block|{
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|value
operator|&
literal|0x7F
operator|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|value
operator|>>>=
literal|7
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Pos: %d, limit: %d, len: %d"
argument_list|,
name|position
argument_list|,
name|limit
argument_list|,
literal|1
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeFixed32NoTag
parameter_list|(
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|value
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Pos: %d, limit: %d, len: %d"
argument_list|,
name|position
argument_list|,
name|limit
argument_list|,
literal|1
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeUInt64NoTag
parameter_list|(
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|HAS_UNSAFE_ARRAY_OPERATIONS
operator|&&
name|spaceLeft
argument_list|()
operator|>=
name|MAX_VARINT_SIZE
condition|)
block|{
name|long
name|pos
init|=
name|ARRAY_BASE_OFFSET
operator|+
name|position
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
operator|(
name|value
operator|&
operator|~
literal|0x7FL
operator|)
operator|==
literal|0
condition|)
block|{
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|buffer
argument_list|,
name|pos
operator|++
argument_list|,
operator|(
name|byte
operator|)
name|value
argument_list|)
expr_stmt|;
name|position
operator|++
expr_stmt|;
return|return;
block|}
else|else
block|{
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|buffer
argument_list|,
name|pos
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
name|value
operator|&
literal|0x7F
operator|)
operator||
literal|0x80
argument_list|)
argument_list|)
expr_stmt|;
name|position
operator|++
expr_stmt|;
name|value
operator|>>>=
literal|7
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
operator|(
name|value
operator|&
operator|~
literal|0x7FL
operator|)
operator|==
literal|0
condition|)
block|{
name|buffer
index|[
name|position
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|value
expr_stmt|;
return|return;
block|}
else|else
block|{
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
name|value
operator|&
literal|0x7F
operator|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|value
operator|>>>=
literal|7
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Pos: %d, limit: %d, len: %d"
argument_list|,
name|position
argument_list|,
name|limit
argument_list|,
literal|1
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeFixed64NoTag
parameter_list|(
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
call|(
name|int
call|)
argument_list|(
name|value
argument_list|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
call|(
name|int
call|)
argument_list|(
name|value
operator|>>
literal|8
argument_list|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
call|(
name|int
call|)
argument_list|(
name|value
operator|>>
literal|16
argument_list|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
call|(
name|int
call|)
argument_list|(
name|value
operator|>>
literal|24
argument_list|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
call|(
name|int
call|)
argument_list|(
name|value
operator|>>
literal|32
argument_list|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
call|(
name|int
call|)
argument_list|(
name|value
operator|>>
literal|40
argument_list|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
call|(
name|int
call|)
argument_list|(
name|value
operator|>>
literal|48
argument_list|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
call|(
name|int
call|)
argument_list|(
name|value
operator|>>
literal|56
argument_list|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Pos: %d, limit: %d, len: %d"
argument_list|,
name|position
argument_list|,
name|limit
argument_list|,
literal|1
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|write
parameter_list|(
name|byte
index|[]
name|value
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|value
argument_list|,
name|offset
argument_list|,
name|buffer
argument_list|,
name|position
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|position
operator|+=
name|length
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Pos: %d, limit: %d, len: %d"
argument_list|,
name|position
argument_list|,
name|limit
argument_list|,
name|length
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeLazy
parameter_list|(
name|byte
index|[]
name|value
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
name|value
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|write
parameter_list|(
name|ByteBuffer
name|value
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|length
init|=
name|value
operator|.
name|remaining
argument_list|()
decl_stmt|;
try|try
block|{
name|value
operator|.
name|get
argument_list|(
name|buffer
argument_list|,
name|position
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|position
operator|+=
name|length
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Pos: %d, limit: %d, len: %d"
argument_list|,
name|position
argument_list|,
name|limit
argument_list|,
name|length
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeLazy
parameter_list|(
name|ByteBuffer
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|writeStringNoTag
parameter_list|(
name|String
name|value
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|oldPosition
init|=
name|position
decl_stmt|;
try|try
block|{
comment|// UTF-8 byte length of the string is at least its UTF-16 code unit length (value.length()),
comment|// and at most 3 times of it. We take advantage of this in both branches below.
specifier|final
name|int
name|maxLength
init|=
name|value
operator|.
name|length
argument_list|()
operator|*
name|Utf8
operator|.
name|MAX_BYTES_PER_CHAR
decl_stmt|;
specifier|final
name|int
name|maxLengthVarIntSize
init|=
name|computeUInt32SizeNoTag
argument_list|(
name|maxLength
argument_list|)
decl_stmt|;
specifier|final
name|int
name|minLengthVarIntSize
init|=
name|computeUInt32SizeNoTag
argument_list|(
name|value
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|minLengthVarIntSize
operator|==
name|maxLengthVarIntSize
condition|)
block|{
name|position
operator|=
name|oldPosition
operator|+
name|minLengthVarIntSize
expr_stmt|;
name|int
name|newPosition
init|=
name|Utf8
operator|.
name|encode
argument_list|(
name|value
argument_list|,
name|buffer
argument_list|,
name|position
argument_list|,
name|spaceLeft
argument_list|()
argument_list|)
decl_stmt|;
comment|// Since this class is stateful and tracks the position, we rewind and store the state,
comment|// prepend the length, then reset it back to the end of the string.
name|position
operator|=
name|oldPosition
expr_stmt|;
name|int
name|length
init|=
name|newPosition
operator|-
name|oldPosition
operator|-
name|minLengthVarIntSize
decl_stmt|;
name|writeUInt32NoTag
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|position
operator|=
name|newPosition
expr_stmt|;
block|}
else|else
block|{
name|int
name|length
init|=
name|Utf8
operator|.
name|encodedLength
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|writeUInt32NoTag
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|position
operator|=
name|Utf8
operator|.
name|encode
argument_list|(
name|value
argument_list|,
name|buffer
argument_list|,
name|position
argument_list|,
name|spaceLeft
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|UnpairedSurrogateException
name|e
parameter_list|)
block|{
comment|// Roll back the change - we fall back to inefficient path.
name|position
operator|=
name|oldPosition
expr_stmt|;
comment|// TODO(nathanmittler): We should throw an IOException here instead.
name|inefficientWriteStringNoTag
argument_list|(
name|value
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|flush
parameter_list|()
block|{
comment|// Do nothing.
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|int
name|spaceLeft
parameter_list|()
block|{
return|return
name|limit
operator|-
name|position
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|int
name|getTotalBytesWritten
parameter_list|()
block|{
return|return
name|position
operator|-
name|offset
return|;
block|}
block|}
comment|/**    * A {@link CodedOutputStream} that writes directly to a heap {@link ByteBuffer}. Writes are    * done directly to the underlying array. The buffer position is only updated after a flush.    */
specifier|private
specifier|static
specifier|final
class|class
name|HeapNioEncoder
extends|extends
name|ArrayEncoder
block|{
specifier|private
specifier|final
name|ByteBuffer
name|byteBuffer
decl_stmt|;
specifier|private
name|int
name|initialPosition
decl_stmt|;
name|HeapNioEncoder
parameter_list|(
name|ByteBuffer
name|byteBuffer
parameter_list|)
block|{
name|super
argument_list|(
name|byteBuffer
operator|.
name|array
argument_list|()
argument_list|,
name|byteBuffer
operator|.
name|arrayOffset
argument_list|()
operator|+
name|byteBuffer
operator|.
name|position
argument_list|()
argument_list|,
name|byteBuffer
operator|.
name|remaining
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|byteBuffer
operator|=
name|byteBuffer
expr_stmt|;
name|this
operator|.
name|initialPosition
operator|=
name|byteBuffer
operator|.
name|position
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|flush
parameter_list|()
block|{
comment|// Update the position on the buffer.
name|byteBuffer
operator|.
name|position
argument_list|(
name|initialPosition
operator|+
name|getTotalBytesWritten
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * A {@link CodedOutputStream} that writes directly to a direct {@link ByteBuffer}, using only    * safe operations..    */
specifier|private
specifier|static
specifier|final
class|class
name|SafeDirectNioEncoder
extends|extends
name|CodedOutputStream
block|{
specifier|private
specifier|final
name|ByteBuffer
name|originalBuffer
decl_stmt|;
specifier|private
specifier|final
name|ByteBuffer
name|buffer
decl_stmt|;
specifier|private
specifier|final
name|int
name|initialPosition
decl_stmt|;
name|SafeDirectNioEncoder
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|)
block|{
name|this
operator|.
name|originalBuffer
operator|=
name|buffer
expr_stmt|;
name|this
operator|.
name|buffer
operator|=
name|buffer
operator|.
name|duplicate
argument_list|()
operator|.
name|order
argument_list|(
name|ByteOrder
operator|.
name|LITTLE_ENDIAN
argument_list|)
expr_stmt|;
name|initialPosition
operator|=
name|buffer
operator|.
name|position
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeTag
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|int
name|wireType
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt32NoTag
argument_list|(
name|WireFormat
operator|.
name|makeTag
argument_list|(
name|fieldNumber
argument_list|,
name|wireType
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeInt32
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_VARINT
argument_list|)
expr_stmt|;
name|writeInt32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeUInt32
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_VARINT
argument_list|)
expr_stmt|;
name|writeUInt32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeFixed32
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_FIXED32
argument_list|)
expr_stmt|;
name|writeFixed32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeUInt64
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_VARINT
argument_list|)
expr_stmt|;
name|writeUInt64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeFixed64
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_FIXED64
argument_list|)
expr_stmt|;
name|writeFixed64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeBool
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|boolean
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_VARINT
argument_list|)
expr_stmt|;
name|write
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|value
condition|?
literal|1
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeString
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|String
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
argument_list|)
expr_stmt|;
name|writeStringNoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeBytes
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|ByteString
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
argument_list|)
expr_stmt|;
name|writeBytesNoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeByteArray
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeByteArray
argument_list|(
name|fieldNumber
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|value
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeByteArray
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
argument_list|)
expr_stmt|;
name|writeByteArrayNoTag
argument_list|(
name|value
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeByteBuffer
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|ByteBuffer
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
argument_list|)
expr_stmt|;
name|writeUInt32NoTag
argument_list|(
name|value
operator|.
name|capacity
argument_list|()
argument_list|)
expr_stmt|;
name|writeRawBytes
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeMessage
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|MessageLite
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
argument_list|)
expr_stmt|;
name|writeMessageNoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeMessageSetExtension
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|MessageLite
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_ITEM
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_START_GROUP
argument_list|)
expr_stmt|;
name|writeUInt32
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_TYPE_ID
argument_list|,
name|fieldNumber
argument_list|)
expr_stmt|;
name|writeMessage
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_MESSAGE
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|writeTag
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_ITEM
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeRawMessageSetExtension
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|ByteString
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_ITEM
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_START_GROUP
argument_list|)
expr_stmt|;
name|writeUInt32
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_TYPE_ID
argument_list|,
name|fieldNumber
argument_list|)
expr_stmt|;
name|writeBytes
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_MESSAGE
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|writeTag
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_ITEM
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeMessageNoTag
parameter_list|(
specifier|final
name|MessageLite
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt32NoTag
argument_list|(
name|value
operator|.
name|getSerializedSize
argument_list|()
argument_list|)
expr_stmt|;
name|value
operator|.
name|writeTo
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|byte
name|value
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|buffer
operator|.
name|put
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BufferOverflowException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeBytesNoTag
parameter_list|(
specifier|final
name|ByteString
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt32NoTag
argument_list|(
name|value
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|value
operator|.
name|writeTo
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeByteArrayNoTag
parameter_list|(
specifier|final
name|byte
index|[]
name|value
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt32NoTag
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|value
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeRawBytes
parameter_list|(
specifier|final
name|ByteBuffer
name|value
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|value
operator|.
name|hasArray
argument_list|()
condition|)
block|{
name|write
argument_list|(
name|value
operator|.
name|array
argument_list|()
argument_list|,
name|value
operator|.
name|arrayOffset
argument_list|()
argument_list|,
name|value
operator|.
name|capacity
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ByteBuffer
name|duplicated
init|=
name|value
operator|.
name|duplicate
argument_list|()
decl_stmt|;
name|duplicated
operator|.
name|clear
argument_list|()
expr_stmt|;
name|write
argument_list|(
name|duplicated
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeInt32NoTag
parameter_list|(
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|value
operator|>=
literal|0
condition|)
block|{
name|writeUInt32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Must sign-extend.
name|writeUInt64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeUInt32NoTag
parameter_list|(
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
operator|(
name|value
operator|&
operator|~
literal|0x7F
operator|)
operator|==
literal|0
condition|)
block|{
name|buffer
operator|.
name|put
argument_list|(
operator|(
name|byte
operator|)
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|buffer
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
operator|(
name|value
operator|&
literal|0x7F
operator|)
operator||
literal|0x80
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|>>>=
literal|7
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|BufferOverflowException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeFixed32NoTag
parameter_list|(
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|buffer
operator|.
name|putInt
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BufferOverflowException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeUInt64NoTag
parameter_list|(
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
operator|(
name|value
operator|&
operator|~
literal|0x7FL
operator|)
operator|==
literal|0
condition|)
block|{
name|buffer
operator|.
name|put
argument_list|(
operator|(
name|byte
operator|)
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|buffer
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
name|value
operator|&
literal|0x7F
operator|)
operator||
literal|0x80
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|>>>=
literal|7
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|BufferOverflowException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeFixed64NoTag
parameter_list|(
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|buffer
operator|.
name|putLong
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BufferOverflowException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|value
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|buffer
operator|.
name|put
argument_list|(
name|value
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|BufferOverflowException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeLazy
parameter_list|(
name|byte
index|[]
name|value
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
name|value
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|ByteBuffer
name|value
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|buffer
operator|.
name|put
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BufferOverflowException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeLazy
parameter_list|(
name|ByteBuffer
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeStringNoTag
parameter_list|(
name|String
name|value
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|startPos
init|=
name|buffer
operator|.
name|position
argument_list|()
decl_stmt|;
try|try
block|{
comment|// UTF-8 byte length of the string is at least its UTF-16 code unit length (value.length()),
comment|// and at most 3 times of it. We take advantage of this in both branches below.
specifier|final
name|int
name|maxEncodedSize
init|=
name|value
operator|.
name|length
argument_list|()
operator|*
name|Utf8
operator|.
name|MAX_BYTES_PER_CHAR
decl_stmt|;
specifier|final
name|int
name|maxLengthVarIntSize
init|=
name|computeUInt32SizeNoTag
argument_list|(
name|maxEncodedSize
argument_list|)
decl_stmt|;
specifier|final
name|int
name|minLengthVarIntSize
init|=
name|computeUInt32SizeNoTag
argument_list|(
name|value
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|minLengthVarIntSize
operator|==
name|maxLengthVarIntSize
condition|)
block|{
comment|// Save the current position and increment past the length field. We'll come back
comment|// and write the length field after the encoding is complete.
specifier|final
name|int
name|startOfBytes
init|=
name|buffer
operator|.
name|position
argument_list|()
operator|+
name|minLengthVarIntSize
decl_stmt|;
name|buffer
operator|.
name|position
argument_list|(
name|startOfBytes
argument_list|)
expr_stmt|;
comment|// Encode the string.
name|encode
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|// Now go back to the beginning and write the length.
name|int
name|endOfBytes
init|=
name|buffer
operator|.
name|position
argument_list|()
decl_stmt|;
name|buffer
operator|.
name|position
argument_list|(
name|startPos
argument_list|)
expr_stmt|;
name|writeUInt32NoTag
argument_list|(
name|endOfBytes
operator|-
name|startOfBytes
argument_list|)
expr_stmt|;
comment|// Reposition the buffer past the written data.
name|buffer
operator|.
name|position
argument_list|(
name|endOfBytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|int
name|length
init|=
name|Utf8
operator|.
name|encodedLength
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|writeUInt32NoTag
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|encode
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|UnpairedSurrogateException
name|e
parameter_list|)
block|{
comment|// Roll back the change and convert to an IOException.
name|buffer
operator|.
name|position
argument_list|(
name|startPos
argument_list|)
expr_stmt|;
comment|// TODO(nathanmittler): We should throw an IOException here instead.
name|inefficientWriteStringNoTag
argument_list|(
name|value
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|// Thrown by buffer.position() if out of range.
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|flush
parameter_list|()
block|{
comment|// Update the position of the original buffer.
name|originalBuffer
operator|.
name|position
argument_list|(
name|buffer
operator|.
name|position
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|spaceLeft
parameter_list|()
block|{
return|return
name|buffer
operator|.
name|remaining
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getTotalBytesWritten
parameter_list|()
block|{
return|return
name|buffer
operator|.
name|position
argument_list|()
operator|-
name|initialPosition
return|;
block|}
specifier|private
name|void
name|encode
parameter_list|(
name|String
name|value
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|Utf8
operator|.
name|encodeUtf8
argument_list|(
name|value
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * A {@link CodedOutputStream} that writes directly to a direct {@link ByteBuffer} using {@code    * sun.misc.Unsafe}.    */
specifier|private
specifier|static
specifier|final
class|class
name|UnsafeDirectNioEncoder
extends|extends
name|CodedOutputStream
block|{
specifier|private
specifier|final
name|ByteBuffer
name|originalBuffer
decl_stmt|;
specifier|private
specifier|final
name|ByteBuffer
name|buffer
decl_stmt|;
specifier|private
specifier|final
name|long
name|address
decl_stmt|;
specifier|private
specifier|final
name|long
name|initialPosition
decl_stmt|;
specifier|private
specifier|final
name|long
name|limit
decl_stmt|;
specifier|private
specifier|final
name|long
name|oneVarintLimit
decl_stmt|;
specifier|private
name|long
name|position
decl_stmt|;
name|UnsafeDirectNioEncoder
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|)
block|{
name|this
operator|.
name|originalBuffer
operator|=
name|buffer
expr_stmt|;
name|this
operator|.
name|buffer
operator|=
name|buffer
operator|.
name|duplicate
argument_list|()
operator|.
name|order
argument_list|(
name|ByteOrder
operator|.
name|LITTLE_ENDIAN
argument_list|)
expr_stmt|;
name|address
operator|=
name|UnsafeUtil
operator|.
name|addressOffset
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|initialPosition
operator|=
name|address
operator|+
name|buffer
operator|.
name|position
argument_list|()
expr_stmt|;
name|limit
operator|=
name|address
operator|+
name|buffer
operator|.
name|limit
argument_list|()
expr_stmt|;
name|oneVarintLimit
operator|=
name|limit
operator|-
name|MAX_VARINT_SIZE
expr_stmt|;
name|position
operator|=
name|initialPosition
expr_stmt|;
block|}
specifier|static
name|boolean
name|isSupported
parameter_list|()
block|{
return|return
name|UnsafeUtil
operator|.
name|hasUnsafeByteBufferOperations
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeTag
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|int
name|wireType
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt32NoTag
argument_list|(
name|WireFormat
operator|.
name|makeTag
argument_list|(
name|fieldNumber
argument_list|,
name|wireType
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeInt32
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_VARINT
argument_list|)
expr_stmt|;
name|writeInt32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeUInt32
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_VARINT
argument_list|)
expr_stmt|;
name|writeUInt32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeFixed32
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_FIXED32
argument_list|)
expr_stmt|;
name|writeFixed32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeUInt64
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_VARINT
argument_list|)
expr_stmt|;
name|writeUInt64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeFixed64
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_FIXED64
argument_list|)
expr_stmt|;
name|writeFixed64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeBool
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|boolean
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_VARINT
argument_list|)
expr_stmt|;
name|write
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|value
condition|?
literal|1
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeString
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|String
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
argument_list|)
expr_stmt|;
name|writeStringNoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeBytes
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|ByteString
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
argument_list|)
expr_stmt|;
name|writeBytesNoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeByteArray
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|byte
index|[]
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeByteArray
argument_list|(
name|fieldNumber
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|value
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeByteArray
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|byte
index|[]
name|value
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
argument_list|)
expr_stmt|;
name|writeByteArrayNoTag
argument_list|(
name|value
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeByteBuffer
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|ByteBuffer
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
argument_list|)
expr_stmt|;
name|writeUInt32NoTag
argument_list|(
name|value
operator|.
name|capacity
argument_list|()
argument_list|)
expr_stmt|;
name|writeRawBytes
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeMessage
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|MessageLite
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
argument_list|)
expr_stmt|;
name|writeMessageNoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeMessageSetExtension
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|MessageLite
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_ITEM
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_START_GROUP
argument_list|)
expr_stmt|;
name|writeUInt32
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_TYPE_ID
argument_list|,
name|fieldNumber
argument_list|)
expr_stmt|;
name|writeMessage
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_MESSAGE
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|writeTag
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_ITEM
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeRawMessageSetExtension
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|ByteString
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_ITEM
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_START_GROUP
argument_list|)
expr_stmt|;
name|writeUInt32
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_TYPE_ID
argument_list|,
name|fieldNumber
argument_list|)
expr_stmt|;
name|writeBytes
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_MESSAGE
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|writeTag
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_ITEM
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeMessageNoTag
parameter_list|(
name|MessageLite
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt32NoTag
argument_list|(
name|value
operator|.
name|getSerializedSize
argument_list|()
argument_list|)
expr_stmt|;
name|value
operator|.
name|writeTo
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|byte
name|value
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|position
operator|>=
name|limit
condition|)
block|{
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Pos: %d, limit: %d, len: %d"
argument_list|,
name|position
argument_list|,
name|limit
argument_list|,
literal|1
argument_list|)
argument_list|)
throw|;
block|}
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|position
operator|++
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeBytesNoTag
parameter_list|(
name|ByteString
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt32NoTag
argument_list|(
name|value
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|value
operator|.
name|writeTo
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeByteArrayNoTag
parameter_list|(
name|byte
index|[]
name|value
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt32NoTag
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|value
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeRawBytes
parameter_list|(
name|ByteBuffer
name|value
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|value
operator|.
name|hasArray
argument_list|()
condition|)
block|{
name|write
argument_list|(
name|value
operator|.
name|array
argument_list|()
argument_list|,
name|value
operator|.
name|arrayOffset
argument_list|()
argument_list|,
name|value
operator|.
name|capacity
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ByteBuffer
name|duplicated
init|=
name|value
operator|.
name|duplicate
argument_list|()
decl_stmt|;
name|duplicated
operator|.
name|clear
argument_list|()
expr_stmt|;
name|write
argument_list|(
name|duplicated
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeInt32NoTag
parameter_list|(
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|value
operator|>=
literal|0
condition|)
block|{
name|writeUInt32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Must sign-extend.
name|writeUInt64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeUInt32NoTag
parameter_list|(
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|position
operator|<=
name|oneVarintLimit
condition|)
block|{
comment|// Optimization to avoid bounds checks on each iteration.
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
operator|(
name|value
operator|&
operator|~
literal|0x7F
operator|)
operator|==
literal|0
condition|)
block|{
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|position
operator|++
argument_list|,
operator|(
name|byte
operator|)
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|position
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
operator|(
name|value
operator|&
literal|0x7F
operator|)
operator||
literal|0x80
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|>>>=
literal|7
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
while|while
condition|(
name|position
operator|<
name|limit
condition|)
block|{
if|if
condition|(
operator|(
name|value
operator|&
operator|~
literal|0x7F
operator|)
operator|==
literal|0
condition|)
block|{
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|position
operator|++
argument_list|,
operator|(
name|byte
operator|)
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|position
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
operator|(
name|value
operator|&
literal|0x7F
operator|)
operator||
literal|0x80
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|>>>=
literal|7
expr_stmt|;
block|}
block|}
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Pos: %d, limit: %d, len: %d"
argument_list|,
name|position
argument_list|,
name|limit
argument_list|,
literal|1
argument_list|)
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeFixed32NoTag
parameter_list|(
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|buffer
operator|.
name|putInt
argument_list|(
name|bufferPos
argument_list|(
name|position
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|position
operator|+=
name|FIXED_32_SIZE
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeUInt64NoTag
parameter_list|(
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|position
operator|<=
name|oneVarintLimit
condition|)
block|{
comment|// Optimization to avoid bounds checks on each iteration.
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
operator|(
name|value
operator|&
operator|~
literal|0x7FL
operator|)
operator|==
literal|0
condition|)
block|{
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|position
operator|++
argument_list|,
operator|(
name|byte
operator|)
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|position
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
name|value
operator|&
literal|0x7F
operator|)
operator||
literal|0x80
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|>>>=
literal|7
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
while|while
condition|(
name|position
operator|<
name|limit
condition|)
block|{
if|if
condition|(
operator|(
name|value
operator|&
operator|~
literal|0x7FL
operator|)
operator|==
literal|0
condition|)
block|{
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|position
operator|++
argument_list|,
operator|(
name|byte
operator|)
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|position
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
name|value
operator|&
literal|0x7F
operator|)
operator||
literal|0x80
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|>>>=
literal|7
expr_stmt|;
block|}
block|}
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Pos: %d, limit: %d, len: %d"
argument_list|,
name|position
argument_list|,
name|limit
argument_list|,
literal|1
argument_list|)
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeFixed64NoTag
parameter_list|(
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|buffer
operator|.
name|putLong
argument_list|(
name|bufferPos
argument_list|(
name|position
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|position
operator|+=
name|FIXED_64_SIZE
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|value
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|value
operator|==
literal|null
operator|||
name|offset
operator|<
literal|0
operator|||
name|length
operator|<
literal|0
operator|||
operator|(
name|value
operator|.
name|length
operator|-
name|length
operator|)
operator|<
name|offset
operator|||
operator|(
name|limit
operator|-
name|length
operator|)
operator|<
name|position
condition|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"value"
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Pos: %d, limit: %d, len: %d"
argument_list|,
name|position
argument_list|,
name|limit
argument_list|,
name|length
argument_list|)
argument_list|)
throw|;
block|}
name|UnsafeUtil
operator|.
name|copyMemory
argument_list|(
name|value
argument_list|,
name|UnsafeUtil
operator|.
name|getArrayBaseOffset
argument_list|()
operator|+
name|offset
argument_list|,
literal|null
argument_list|,
name|position
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|position
operator|+=
name|length
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeLazy
parameter_list|(
name|byte
index|[]
name|value
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
name|value
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|ByteBuffer
name|value
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|int
name|length
init|=
name|value
operator|.
name|remaining
argument_list|()
decl_stmt|;
name|repositionBuffer
argument_list|(
name|position
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|put
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|position
operator|+=
name|length
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BufferOverflowException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeLazy
parameter_list|(
name|ByteBuffer
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeStringNoTag
parameter_list|(
name|String
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|prevPos
init|=
name|position
decl_stmt|;
try|try
block|{
comment|// UTF-8 byte length of the string is at least its UTF-16 code unit length (value.length()),
comment|// and at most 3 times of it. We take advantage of this in both branches below.
name|int
name|maxEncodedSize
init|=
name|value
operator|.
name|length
argument_list|()
operator|*
name|Utf8
operator|.
name|MAX_BYTES_PER_CHAR
decl_stmt|;
name|int
name|maxLengthVarIntSize
init|=
name|computeUInt32SizeNoTag
argument_list|(
name|maxEncodedSize
argument_list|)
decl_stmt|;
name|int
name|minLengthVarIntSize
init|=
name|computeUInt32SizeNoTag
argument_list|(
name|value
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|minLengthVarIntSize
operator|==
name|maxLengthVarIntSize
condition|)
block|{
comment|// Save the current position and increment past the length field. We'll come back
comment|// and write the length field after the encoding is complete.
name|int
name|stringStart
init|=
name|bufferPos
argument_list|(
name|position
argument_list|)
operator|+
name|minLengthVarIntSize
decl_stmt|;
name|buffer
operator|.
name|position
argument_list|(
name|stringStart
argument_list|)
expr_stmt|;
comment|// Encode the string.
name|Utf8
operator|.
name|encodeUtf8
argument_list|(
name|value
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
comment|// Write the length and advance the position.
name|int
name|length
init|=
name|buffer
operator|.
name|position
argument_list|()
operator|-
name|stringStart
decl_stmt|;
name|writeUInt32NoTag
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|position
operator|+=
name|length
expr_stmt|;
block|}
else|else
block|{
comment|// Calculate and write the encoded length.
name|int
name|length
init|=
name|Utf8
operator|.
name|encodedLength
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|writeUInt32NoTag
argument_list|(
name|length
argument_list|)
expr_stmt|;
comment|// Write the string and advance the position.
name|repositionBuffer
argument_list|(
name|position
argument_list|)
expr_stmt|;
name|Utf8
operator|.
name|encodeUtf8
argument_list|(
name|value
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|position
operator|+=
name|length
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|UnpairedSurrogateException
name|e
parameter_list|)
block|{
comment|// Roll back the change and convert to an IOException.
name|position
operator|=
name|prevPos
expr_stmt|;
name|repositionBuffer
argument_list|(
name|position
argument_list|)
expr_stmt|;
comment|// TODO(nathanmittler): We should throw an IOException here instead.
name|inefficientWriteStringNoTag
argument_list|(
name|value
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|// Thrown by buffer.position() if out of range.
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|flush
parameter_list|()
block|{
comment|// Update the position of the original buffer.
name|originalBuffer
operator|.
name|position
argument_list|(
name|bufferPos
argument_list|(
name|position
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|spaceLeft
parameter_list|()
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|limit
operator|-
name|position
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getTotalBytesWritten
parameter_list|()
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|position
operator|-
name|initialPosition
argument_list|)
return|;
block|}
specifier|private
name|void
name|repositionBuffer
parameter_list|(
name|long
name|pos
parameter_list|)
block|{
name|buffer
operator|.
name|position
argument_list|(
name|bufferPos
argument_list|(
name|pos
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|int
name|bufferPos
parameter_list|(
name|long
name|pos
parameter_list|)
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|pos
operator|-
name|address
argument_list|)
return|;
block|}
block|}
comment|/**    * Abstract base class for buffered encoders.    */
specifier|private
specifier|abstract
specifier|static
class|class
name|AbstractBufferedEncoder
extends|extends
name|CodedOutputStream
block|{
specifier|final
name|byte
index|[]
name|buffer
decl_stmt|;
specifier|final
name|int
name|limit
decl_stmt|;
name|int
name|position
decl_stmt|;
name|int
name|totalBytesWritten
decl_stmt|;
name|AbstractBufferedEncoder
parameter_list|(
name|int
name|bufferSize
parameter_list|)
block|{
if|if
condition|(
name|bufferSize
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"bufferSize must be>= 0"
argument_list|)
throw|;
block|}
comment|// As an optimization, we require that the buffer be able to store at least 2
comment|// varints so that we can buffer any integer write (tag + value). This reduces the
comment|// number of range checks for a single write to 1 (i.e. if there is not enough space
comment|// to buffer the tag+value, flush and then buffer it).
name|this
operator|.
name|buffer
operator|=
operator|new
name|byte
index|[
name|max
argument_list|(
name|bufferSize
argument_list|,
name|MAX_VARINT_SIZE
operator|*
literal|2
argument_list|)
index|]
expr_stmt|;
name|this
operator|.
name|limit
operator|=
name|buffer
operator|.
name|length
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|int
name|spaceLeft
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"spaceLeft() can only be called on CodedOutputStreams that are "
operator|+
literal|"writing to a flat array or ByteBuffer."
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|int
name|getTotalBytesWritten
parameter_list|()
block|{
return|return
name|totalBytesWritten
return|;
block|}
comment|/**      * This method does not perform bounds checking on the array. Checking array bounds is the      * responsibility of the caller.      */
specifier|final
name|void
name|buffer
parameter_list|(
name|byte
name|value
parameter_list|)
block|{
name|buffer
index|[
name|position
operator|++
index|]
operator|=
name|value
expr_stmt|;
name|totalBytesWritten
operator|++
expr_stmt|;
block|}
comment|/**      * This method does not perform bounds checking on the array. Checking array bounds is the      * responsibility of the caller.      */
specifier|final
name|void
name|bufferTag
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|int
name|wireType
parameter_list|)
block|{
name|bufferUInt32NoTag
argument_list|(
name|WireFormat
operator|.
name|makeTag
argument_list|(
name|fieldNumber
argument_list|,
name|wireType
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * This method does not perform bounds checking on the array. Checking array bounds is the      * responsibility of the caller.      */
specifier|final
name|void
name|bufferInt32NoTag
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|>=
literal|0
condition|)
block|{
name|bufferUInt32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Must sign-extend.
name|bufferUInt64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This method does not perform bounds checking on the array. Checking array bounds is the      * responsibility of the caller.      */
specifier|final
name|void
name|bufferUInt32NoTag
parameter_list|(
name|int
name|value
parameter_list|)
block|{
if|if
condition|(
name|HAS_UNSAFE_ARRAY_OPERATIONS
condition|)
block|{
specifier|final
name|long
name|originalPos
init|=
name|ARRAY_BASE_OFFSET
operator|+
name|position
decl_stmt|;
name|long
name|pos
init|=
name|originalPos
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
operator|(
name|value
operator|&
operator|~
literal|0x7F
operator|)
operator|==
literal|0
condition|)
block|{
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|buffer
argument_list|,
name|pos
operator|++
argument_list|,
operator|(
name|byte
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|buffer
argument_list|,
name|pos
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
operator|(
name|value
operator|&
literal|0x7F
operator|)
operator||
literal|0x80
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|>>>=
literal|7
expr_stmt|;
block|}
block|}
name|int
name|delta
init|=
call|(
name|int
call|)
argument_list|(
name|pos
operator|-
name|originalPos
argument_list|)
decl_stmt|;
name|position
operator|+=
name|delta
expr_stmt|;
name|totalBytesWritten
operator|+=
name|delta
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
operator|(
name|value
operator|&
operator|~
literal|0x7F
operator|)
operator|==
literal|0
condition|)
block|{
name|buffer
index|[
name|position
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|value
expr_stmt|;
name|totalBytesWritten
operator|++
expr_stmt|;
return|return;
block|}
else|else
block|{
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|value
operator|&
literal|0x7F
operator|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|totalBytesWritten
operator|++
expr_stmt|;
name|value
operator|>>>=
literal|7
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * This method does not perform bounds checking on the array. Checking array bounds is the      * responsibility of the caller.      */
specifier|final
name|void
name|bufferUInt64NoTag
parameter_list|(
name|long
name|value
parameter_list|)
block|{
if|if
condition|(
name|HAS_UNSAFE_ARRAY_OPERATIONS
condition|)
block|{
specifier|final
name|long
name|originalPos
init|=
name|ARRAY_BASE_OFFSET
operator|+
name|position
decl_stmt|;
name|long
name|pos
init|=
name|originalPos
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
operator|(
name|value
operator|&
operator|~
literal|0x7FL
operator|)
operator|==
literal|0
condition|)
block|{
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|buffer
argument_list|,
name|pos
operator|++
argument_list|,
operator|(
name|byte
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|buffer
argument_list|,
name|pos
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
name|value
operator|&
literal|0x7F
operator|)
operator||
literal|0x80
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|>>>=
literal|7
expr_stmt|;
block|}
block|}
name|int
name|delta
init|=
call|(
name|int
call|)
argument_list|(
name|pos
operator|-
name|originalPos
argument_list|)
decl_stmt|;
name|position
operator|+=
name|delta
expr_stmt|;
name|totalBytesWritten
operator|+=
name|delta
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
operator|(
name|value
operator|&
operator|~
literal|0x7FL
operator|)
operator|==
literal|0
condition|)
block|{
name|buffer
index|[
name|position
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|value
expr_stmt|;
name|totalBytesWritten
operator|++
expr_stmt|;
return|return;
block|}
else|else
block|{
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
name|value
operator|&
literal|0x7F
operator|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|totalBytesWritten
operator|++
expr_stmt|;
name|value
operator|>>>=
literal|7
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * This method does not perform bounds checking on the array. Checking array bounds is the      * responsibility of the caller.      */
specifier|final
name|void
name|bufferFixed32NoTag
parameter_list|(
name|int
name|value
parameter_list|)
block|{
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|value
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|totalBytesWritten
operator|+=
name|FIXED_32_SIZE
expr_stmt|;
block|}
comment|/**      * This method does not perform bounds checking on the array. Checking array bounds is the      * responsibility of the caller.      */
specifier|final
name|void
name|bufferFixed64NoTag
parameter_list|(
name|long
name|value
parameter_list|)
block|{
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|value
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
call|(
name|int
call|)
argument_list|(
name|value
operator|>>
literal|32
argument_list|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
call|(
name|int
call|)
argument_list|(
name|value
operator|>>
literal|40
argument_list|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
call|(
name|int
call|)
argument_list|(
name|value
operator|>>
literal|48
argument_list|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|buffer
index|[
name|position
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
call|(
name|int
call|)
argument_list|(
name|value
operator|>>
literal|56
argument_list|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|totalBytesWritten
operator|+=
name|FIXED_64_SIZE
expr_stmt|;
block|}
block|}
comment|/**    * A {@link CodedOutputStream} that decorates a {@link ByteOutput}. It internal buffer only to    * support string encoding operations. All other writes are just passed through to the    * {@link ByteOutput}.    */
specifier|private
specifier|static
specifier|final
class|class
name|ByteOutputEncoder
extends|extends
name|AbstractBufferedEncoder
block|{
specifier|private
specifier|final
name|ByteOutput
name|out
decl_stmt|;
name|ByteOutputEncoder
parameter_list|(
name|ByteOutput
name|out
parameter_list|,
name|int
name|bufferSize
parameter_list|)
block|{
name|super
argument_list|(
name|bufferSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"out"
argument_list|)
throw|;
block|}
name|this
operator|.
name|out
operator|=
name|out
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeTag
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|int
name|wireType
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt32NoTag
argument_list|(
name|WireFormat
operator|.
name|makeTag
argument_list|(
name|fieldNumber
argument_list|,
name|wireType
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeInt32
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|flushIfNotAvailable
argument_list|(
name|MAX_VARINT_SIZE
operator|*
literal|2
argument_list|)
expr_stmt|;
name|bufferTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_VARINT
argument_list|)
expr_stmt|;
name|bufferInt32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeUInt32
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|flushIfNotAvailable
argument_list|(
name|MAX_VARINT_SIZE
operator|*
literal|2
argument_list|)
expr_stmt|;
name|bufferTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_VARINT
argument_list|)
expr_stmt|;
name|bufferUInt32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeFixed32
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|flushIfNotAvailable
argument_list|(
name|MAX_VARINT_SIZE
operator|+
name|FIXED_32_SIZE
argument_list|)
expr_stmt|;
name|bufferTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_FIXED32
argument_list|)
expr_stmt|;
name|bufferFixed32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeUInt64
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|flushIfNotAvailable
argument_list|(
name|MAX_VARINT_SIZE
operator|*
literal|2
argument_list|)
expr_stmt|;
name|bufferTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_VARINT
argument_list|)
expr_stmt|;
name|bufferUInt64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeFixed64
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|flushIfNotAvailable
argument_list|(
name|MAX_VARINT_SIZE
operator|+
name|FIXED_64_SIZE
argument_list|)
expr_stmt|;
name|bufferTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_FIXED64
argument_list|)
expr_stmt|;
name|bufferFixed64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeBool
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|boolean
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|flushIfNotAvailable
argument_list|(
name|MAX_VARINT_SIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bufferTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_VARINT
argument_list|)
expr_stmt|;
name|buffer
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|value
condition|?
literal|1
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeString
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|String
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
argument_list|)
expr_stmt|;
name|writeStringNoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeBytes
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|ByteString
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
argument_list|)
expr_stmt|;
name|writeBytesNoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeByteArray
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeByteArray
argument_list|(
name|fieldNumber
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|value
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeByteArray
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
argument_list|)
expr_stmt|;
name|writeByteArrayNoTag
argument_list|(
name|value
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeByteBuffer
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|ByteBuffer
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
argument_list|)
expr_stmt|;
name|writeUInt32NoTag
argument_list|(
name|value
operator|.
name|capacity
argument_list|()
argument_list|)
expr_stmt|;
name|writeRawBytes
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeBytesNoTag
parameter_list|(
specifier|final
name|ByteString
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt32NoTag
argument_list|(
name|value
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|value
operator|.
name|writeTo
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeByteArrayNoTag
parameter_list|(
specifier|final
name|byte
index|[]
name|value
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt32NoTag
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|value
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeRawBytes
parameter_list|(
specifier|final
name|ByteBuffer
name|value
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|value
operator|.
name|hasArray
argument_list|()
condition|)
block|{
name|write
argument_list|(
name|value
operator|.
name|array
argument_list|()
argument_list|,
name|value
operator|.
name|arrayOffset
argument_list|()
argument_list|,
name|value
operator|.
name|capacity
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ByteBuffer
name|duplicated
init|=
name|value
operator|.
name|duplicate
argument_list|()
decl_stmt|;
name|duplicated
operator|.
name|clear
argument_list|()
expr_stmt|;
name|write
argument_list|(
name|duplicated
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeMessage
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|MessageLite
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
argument_list|)
expr_stmt|;
name|writeMessageNoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeMessageSetExtension
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|MessageLite
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_ITEM
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_START_GROUP
argument_list|)
expr_stmt|;
name|writeUInt32
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_TYPE_ID
argument_list|,
name|fieldNumber
argument_list|)
expr_stmt|;
name|writeMessage
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_MESSAGE
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|writeTag
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_ITEM
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeRawMessageSetExtension
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|ByteString
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_ITEM
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_START_GROUP
argument_list|)
expr_stmt|;
name|writeUInt32
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_TYPE_ID
argument_list|,
name|fieldNumber
argument_list|)
expr_stmt|;
name|writeBytes
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_MESSAGE
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|writeTag
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_ITEM
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeMessageNoTag
parameter_list|(
specifier|final
name|MessageLite
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt32NoTag
argument_list|(
name|value
operator|.
name|getSerializedSize
argument_list|()
argument_list|)
expr_stmt|;
name|value
operator|.
name|writeTo
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|byte
name|value
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|position
operator|==
name|limit
condition|)
block|{
name|doFlush
argument_list|()
expr_stmt|;
block|}
name|buffer
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeInt32NoTag
parameter_list|(
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|value
operator|>=
literal|0
condition|)
block|{
name|writeUInt32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Must sign-extend.
name|writeUInt64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeUInt32NoTag
parameter_list|(
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|flushIfNotAvailable
argument_list|(
name|MAX_VARINT_SIZE
argument_list|)
expr_stmt|;
name|bufferUInt32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeFixed32NoTag
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|flushIfNotAvailable
argument_list|(
name|FIXED_32_SIZE
argument_list|)
expr_stmt|;
name|bufferFixed32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeUInt64NoTag
parameter_list|(
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|flushIfNotAvailable
argument_list|(
name|MAX_VARINT_SIZE
argument_list|)
expr_stmt|;
name|bufferUInt64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeFixed64NoTag
parameter_list|(
specifier|final
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|flushIfNotAvailable
argument_list|(
name|FIXED_64_SIZE
argument_list|)
expr_stmt|;
name|bufferFixed64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeStringNoTag
parameter_list|(
name|String
name|value
parameter_list|)
throws|throws
name|IOException
block|{
comment|// UTF-8 byte length of the string is at least its UTF-16 code unit length (value.length()),
comment|// and at most 3 times of it. We take advantage of this in both branches below.
specifier|final
name|int
name|maxLength
init|=
name|value
operator|.
name|length
argument_list|()
operator|*
name|Utf8
operator|.
name|MAX_BYTES_PER_CHAR
decl_stmt|;
specifier|final
name|int
name|maxLengthVarIntSize
init|=
name|computeUInt32SizeNoTag
argument_list|(
name|maxLength
argument_list|)
decl_stmt|;
comment|// If we are streaming and the potential length is too big to fit in our buffer, we take the
comment|// slower path.
if|if
condition|(
name|maxLengthVarIntSize
operator|+
name|maxLength
operator|>
name|limit
condition|)
block|{
comment|// Allocate a byte[] that we know can fit the string and encode into it. String.getBytes()
comment|// does the same internally and then does *another copy* to return a byte[] of exactly the
comment|// right size. We can skip that copy and just writeRawBytes up to the actualLength of the
comment|// UTF-8 encoded bytes.
specifier|final
name|byte
index|[]
name|encodedBytes
init|=
operator|new
name|byte
index|[
name|maxLength
index|]
decl_stmt|;
name|int
name|actualLength
init|=
name|Utf8
operator|.
name|encode
argument_list|(
name|value
argument_list|,
name|encodedBytes
argument_list|,
literal|0
argument_list|,
name|maxLength
argument_list|)
decl_stmt|;
name|writeUInt32NoTag
argument_list|(
name|actualLength
argument_list|)
expr_stmt|;
name|writeLazy
argument_list|(
name|encodedBytes
argument_list|,
literal|0
argument_list|,
name|actualLength
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Fast path: we have enough space available in our buffer for the string...
if|if
condition|(
name|maxLengthVarIntSize
operator|+
name|maxLength
operator|>
name|limit
operator|-
name|position
condition|)
block|{
comment|// Flush to free up space.
name|doFlush
argument_list|()
expr_stmt|;
block|}
specifier|final
name|int
name|oldPosition
init|=
name|position
decl_stmt|;
try|try
block|{
comment|// Optimize for the case where we know this length results in a constant varint length as
comment|// this saves a pass for measuring the length of the string.
specifier|final
name|int
name|minLengthVarIntSize
init|=
name|computeUInt32SizeNoTag
argument_list|(
name|value
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|minLengthVarIntSize
operator|==
name|maxLengthVarIntSize
condition|)
block|{
name|position
operator|=
name|oldPosition
operator|+
name|minLengthVarIntSize
expr_stmt|;
name|int
name|newPosition
init|=
name|Utf8
operator|.
name|encode
argument_list|(
name|value
argument_list|,
name|buffer
argument_list|,
name|position
argument_list|,
name|limit
operator|-
name|position
argument_list|)
decl_stmt|;
comment|// Since this class is stateful and tracks the position, we rewind and store the state,
comment|// prepend the length, then reset it back to the end of the string.
name|position
operator|=
name|oldPosition
expr_stmt|;
name|int
name|length
init|=
name|newPosition
operator|-
name|oldPosition
operator|-
name|minLengthVarIntSize
decl_stmt|;
name|bufferUInt32NoTag
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|position
operator|=
name|newPosition
expr_stmt|;
name|totalBytesWritten
operator|+=
name|length
expr_stmt|;
block|}
else|else
block|{
name|int
name|length
init|=
name|Utf8
operator|.
name|encodedLength
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|bufferUInt32NoTag
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|position
operator|=
name|Utf8
operator|.
name|encode
argument_list|(
name|value
argument_list|,
name|buffer
argument_list|,
name|position
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|totalBytesWritten
operator|+=
name|length
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|UnpairedSurrogateException
name|e
parameter_list|)
block|{
comment|// Roll back the change and convert to an IOException.
name|totalBytesWritten
operator|-=
name|position
operator|-
name|oldPosition
expr_stmt|;
name|position
operator|=
name|oldPosition
expr_stmt|;
comment|// TODO(nathanmittler): We should throw an IOException here instead.
name|inefficientWriteStringNoTag
argument_list|(
name|value
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|flush
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|position
operator|>
literal|0
condition|)
block|{
comment|// Flush the buffer.
name|doFlush
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|value
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|flush
argument_list|()
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|value
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|totalBytesWritten
operator|+=
name|length
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeLazy
parameter_list|(
name|byte
index|[]
name|value
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|flush
argument_list|()
expr_stmt|;
name|out
operator|.
name|writeLazy
argument_list|(
name|value
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|totalBytesWritten
operator|+=
name|length
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|ByteBuffer
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|flush
argument_list|()
expr_stmt|;
name|int
name|length
init|=
name|value
operator|.
name|remaining
argument_list|()
decl_stmt|;
name|out
operator|.
name|write
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|totalBytesWritten
operator|+=
name|length
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeLazy
parameter_list|(
name|ByteBuffer
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|flush
argument_list|()
expr_stmt|;
name|int
name|length
init|=
name|value
operator|.
name|remaining
argument_list|()
decl_stmt|;
name|out
operator|.
name|writeLazy
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|totalBytesWritten
operator|+=
name|length
expr_stmt|;
block|}
specifier|private
name|void
name|flushIfNotAvailable
parameter_list|(
name|int
name|requiredSize
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|limit
operator|-
name|position
operator|<
name|requiredSize
condition|)
block|{
name|doFlush
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|doFlush
parameter_list|()
throws|throws
name|IOException
block|{
name|out
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|position
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/**    * An {@link CodedOutputStream} that decorates an {@link OutputStream}. It performs internal    * buffering to optimize writes to the {@link OutputStream}.    */
specifier|private
specifier|static
specifier|final
class|class
name|OutputStreamEncoder
extends|extends
name|AbstractBufferedEncoder
block|{
specifier|private
specifier|final
name|OutputStream
name|out
decl_stmt|;
name|OutputStreamEncoder
parameter_list|(
name|OutputStream
name|out
parameter_list|,
name|int
name|bufferSize
parameter_list|)
block|{
name|super
argument_list|(
name|bufferSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"out"
argument_list|)
throw|;
block|}
name|this
operator|.
name|out
operator|=
name|out
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeTag
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|int
name|wireType
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt32NoTag
argument_list|(
name|WireFormat
operator|.
name|makeTag
argument_list|(
name|fieldNumber
argument_list|,
name|wireType
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeInt32
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|flushIfNotAvailable
argument_list|(
name|MAX_VARINT_SIZE
operator|*
literal|2
argument_list|)
expr_stmt|;
name|bufferTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_VARINT
argument_list|)
expr_stmt|;
name|bufferInt32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeUInt32
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|flushIfNotAvailable
argument_list|(
name|MAX_VARINT_SIZE
operator|*
literal|2
argument_list|)
expr_stmt|;
name|bufferTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_VARINT
argument_list|)
expr_stmt|;
name|bufferUInt32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeFixed32
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|flushIfNotAvailable
argument_list|(
name|MAX_VARINT_SIZE
operator|+
name|FIXED_32_SIZE
argument_list|)
expr_stmt|;
name|bufferTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_FIXED32
argument_list|)
expr_stmt|;
name|bufferFixed32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeUInt64
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|flushIfNotAvailable
argument_list|(
name|MAX_VARINT_SIZE
operator|*
literal|2
argument_list|)
expr_stmt|;
name|bufferTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_VARINT
argument_list|)
expr_stmt|;
name|bufferUInt64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeFixed64
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|flushIfNotAvailable
argument_list|(
name|MAX_VARINT_SIZE
operator|+
name|FIXED_64_SIZE
argument_list|)
expr_stmt|;
name|bufferTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_FIXED64
argument_list|)
expr_stmt|;
name|bufferFixed64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeBool
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|boolean
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|flushIfNotAvailable
argument_list|(
name|MAX_VARINT_SIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bufferTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_VARINT
argument_list|)
expr_stmt|;
name|buffer
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|value
condition|?
literal|1
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeString
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|String
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
argument_list|)
expr_stmt|;
name|writeStringNoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeBytes
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|ByteString
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
argument_list|)
expr_stmt|;
name|writeBytesNoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeByteArray
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeByteArray
argument_list|(
name|fieldNumber
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|value
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeByteArray
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
argument_list|)
expr_stmt|;
name|writeByteArrayNoTag
argument_list|(
name|value
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeByteBuffer
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|ByteBuffer
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
argument_list|)
expr_stmt|;
name|writeUInt32NoTag
argument_list|(
name|value
operator|.
name|capacity
argument_list|()
argument_list|)
expr_stmt|;
name|writeRawBytes
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeBytesNoTag
parameter_list|(
specifier|final
name|ByteString
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt32NoTag
argument_list|(
name|value
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|value
operator|.
name|writeTo
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeByteArrayNoTag
parameter_list|(
specifier|final
name|byte
index|[]
name|value
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt32NoTag
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|value
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeRawBytes
parameter_list|(
specifier|final
name|ByteBuffer
name|value
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|value
operator|.
name|hasArray
argument_list|()
condition|)
block|{
name|write
argument_list|(
name|value
operator|.
name|array
argument_list|()
argument_list|,
name|value
operator|.
name|arrayOffset
argument_list|()
argument_list|,
name|value
operator|.
name|capacity
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ByteBuffer
name|duplicated
init|=
name|value
operator|.
name|duplicate
argument_list|()
decl_stmt|;
name|duplicated
operator|.
name|clear
argument_list|()
expr_stmt|;
name|write
argument_list|(
name|duplicated
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeMessage
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|MessageLite
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
argument_list|)
expr_stmt|;
name|writeMessageNoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeMessageSetExtension
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|MessageLite
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_ITEM
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_START_GROUP
argument_list|)
expr_stmt|;
name|writeUInt32
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_TYPE_ID
argument_list|,
name|fieldNumber
argument_list|)
expr_stmt|;
name|writeMessage
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_MESSAGE
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|writeTag
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_ITEM
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeRawMessageSetExtension
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|ByteString
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeTag
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_ITEM
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_START_GROUP
argument_list|)
expr_stmt|;
name|writeUInt32
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_TYPE_ID
argument_list|,
name|fieldNumber
argument_list|)
expr_stmt|;
name|writeBytes
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_MESSAGE
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|writeTag
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_ITEM
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeMessageNoTag
parameter_list|(
specifier|final
name|MessageLite
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|writeUInt32NoTag
argument_list|(
name|value
operator|.
name|getSerializedSize
argument_list|()
argument_list|)
expr_stmt|;
name|value
operator|.
name|writeTo
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|byte
name|value
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|position
operator|==
name|limit
condition|)
block|{
name|doFlush
argument_list|()
expr_stmt|;
block|}
name|buffer
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeInt32NoTag
parameter_list|(
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|value
operator|>=
literal|0
condition|)
block|{
name|writeUInt32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Must sign-extend.
name|writeUInt64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeUInt32NoTag
parameter_list|(
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|flushIfNotAvailable
argument_list|(
name|MAX_VARINT_SIZE
argument_list|)
expr_stmt|;
name|bufferUInt32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeFixed32NoTag
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|flushIfNotAvailable
argument_list|(
name|FIXED_32_SIZE
argument_list|)
expr_stmt|;
name|bufferFixed32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeUInt64NoTag
parameter_list|(
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|flushIfNotAvailable
argument_list|(
name|MAX_VARINT_SIZE
argument_list|)
expr_stmt|;
name|bufferUInt64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeFixed64NoTag
parameter_list|(
specifier|final
name|long
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|flushIfNotAvailable
argument_list|(
name|FIXED_64_SIZE
argument_list|)
expr_stmt|;
name|bufferFixed64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeStringNoTag
parameter_list|(
name|String
name|value
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
comment|// UTF-8 byte length of the string is at least its UTF-16 code unit length (value.length()),
comment|// and at most 3 times of it. We take advantage of this in both branches below.
specifier|final
name|int
name|maxLength
init|=
name|value
operator|.
name|length
argument_list|()
operator|*
name|Utf8
operator|.
name|MAX_BYTES_PER_CHAR
decl_stmt|;
specifier|final
name|int
name|maxLengthVarIntSize
init|=
name|computeUInt32SizeNoTag
argument_list|(
name|maxLength
argument_list|)
decl_stmt|;
comment|// If we are streaming and the potential length is too big to fit in our buffer, we take the
comment|// slower path.
if|if
condition|(
name|maxLengthVarIntSize
operator|+
name|maxLength
operator|>
name|limit
condition|)
block|{
comment|// Allocate a byte[] that we know can fit the string and encode into it. String.getBytes()
comment|// does the same internally and then does *another copy* to return a byte[] of exactly the
comment|// right size. We can skip that copy and just writeRawBytes up to the actualLength of the
comment|// UTF-8 encoded bytes.
specifier|final
name|byte
index|[]
name|encodedBytes
init|=
operator|new
name|byte
index|[
name|maxLength
index|]
decl_stmt|;
name|int
name|actualLength
init|=
name|Utf8
operator|.
name|encode
argument_list|(
name|value
argument_list|,
name|encodedBytes
argument_list|,
literal|0
argument_list|,
name|maxLength
argument_list|)
decl_stmt|;
name|writeUInt32NoTag
argument_list|(
name|actualLength
argument_list|)
expr_stmt|;
name|writeLazy
argument_list|(
name|encodedBytes
argument_list|,
literal|0
argument_list|,
name|actualLength
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Fast path: we have enough space available in our buffer for the string...
if|if
condition|(
name|maxLengthVarIntSize
operator|+
name|maxLength
operator|>
name|limit
operator|-
name|position
condition|)
block|{
comment|// Flush to free up space.
name|doFlush
argument_list|()
expr_stmt|;
block|}
comment|// Optimize for the case where we know this length results in a constant varint length as
comment|// this saves a pass for measuring the length of the string.
specifier|final
name|int
name|minLengthVarIntSize
init|=
name|computeUInt32SizeNoTag
argument_list|(
name|value
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|oldPosition
init|=
name|position
decl_stmt|;
specifier|final
name|int
name|length
decl_stmt|;
try|try
block|{
if|if
condition|(
name|minLengthVarIntSize
operator|==
name|maxLengthVarIntSize
condition|)
block|{
name|position
operator|=
name|oldPosition
operator|+
name|minLengthVarIntSize
expr_stmt|;
name|int
name|newPosition
init|=
name|Utf8
operator|.
name|encode
argument_list|(
name|value
argument_list|,
name|buffer
argument_list|,
name|position
argument_list|,
name|limit
operator|-
name|position
argument_list|)
decl_stmt|;
comment|// Since this class is stateful and tracks the position, we rewind and store the
comment|// state, prepend the length, then reset it back to the end of the string.
name|position
operator|=
name|oldPosition
expr_stmt|;
name|length
operator|=
name|newPosition
operator|-
name|oldPosition
operator|-
name|minLengthVarIntSize
expr_stmt|;
name|bufferUInt32NoTag
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|position
operator|=
name|newPosition
expr_stmt|;
block|}
else|else
block|{
name|length
operator|=
name|Utf8
operator|.
name|encodedLength
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|bufferUInt32NoTag
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|position
operator|=
name|Utf8
operator|.
name|encode
argument_list|(
name|value
argument_list|,
name|buffer
argument_list|,
name|position
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|totalBytesWritten
operator|+=
name|length
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnpairedSurrogateException
name|e
parameter_list|)
block|{
comment|// Be extra careful and restore the original position for retrying the write with the
comment|// less efficient path.
name|totalBytesWritten
operator|-=
name|position
operator|-
name|oldPosition
expr_stmt|;
name|position
operator|=
name|oldPosition
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|OutOfSpaceException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|UnpairedSurrogateException
name|e
parameter_list|)
block|{
name|inefficientWriteStringNoTag
argument_list|(
name|value
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|flush
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|position
operator|>
literal|0
condition|)
block|{
comment|// Flush the buffer.
name|doFlush
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|value
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|limit
operator|-
name|position
operator|>=
name|length
condition|)
block|{
comment|// We have room in the current buffer.
name|System
operator|.
name|arraycopy
argument_list|(
name|value
argument_list|,
name|offset
argument_list|,
name|buffer
argument_list|,
name|position
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|position
operator|+=
name|length
expr_stmt|;
name|totalBytesWritten
operator|+=
name|length
expr_stmt|;
block|}
else|else
block|{
comment|// Write extends past current buffer.  Fill the rest of this buffer and
comment|// flush.
specifier|final
name|int
name|bytesWritten
init|=
name|limit
operator|-
name|position
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|value
argument_list|,
name|offset
argument_list|,
name|buffer
argument_list|,
name|position
argument_list|,
name|bytesWritten
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|bytesWritten
expr_stmt|;
name|length
operator|-=
name|bytesWritten
expr_stmt|;
name|position
operator|=
name|limit
expr_stmt|;
name|totalBytesWritten
operator|+=
name|bytesWritten
expr_stmt|;
name|doFlush
argument_list|()
expr_stmt|;
comment|// Now deal with the rest.
comment|// Since we have an output stream, this is our buffer
comment|// and buffer offset == 0
if|if
condition|(
name|length
operator|<=
name|limit
condition|)
block|{
comment|// Fits in new buffer.
name|System
operator|.
name|arraycopy
argument_list|(
name|value
argument_list|,
name|offset
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|position
operator|=
name|length
expr_stmt|;
block|}
else|else
block|{
comment|// Write is very big.  Let's do it all at once.
name|out
operator|.
name|write
argument_list|(
name|value
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|totalBytesWritten
operator|+=
name|length
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeLazy
parameter_list|(
name|byte
index|[]
name|value
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
name|value
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|ByteBuffer
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|length
init|=
name|value
operator|.
name|remaining
argument_list|()
decl_stmt|;
if|if
condition|(
name|limit
operator|-
name|position
operator|>=
name|length
condition|)
block|{
comment|// We have room in the current buffer.
name|value
operator|.
name|get
argument_list|(
name|buffer
argument_list|,
name|position
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|position
operator|+=
name|length
expr_stmt|;
name|totalBytesWritten
operator|+=
name|length
expr_stmt|;
block|}
else|else
block|{
comment|// Write extends past current buffer.  Fill the rest of this buffer and
comment|// flush.
specifier|final
name|int
name|bytesWritten
init|=
name|limit
operator|-
name|position
decl_stmt|;
name|value
operator|.
name|get
argument_list|(
name|buffer
argument_list|,
name|position
argument_list|,
name|bytesWritten
argument_list|)
expr_stmt|;
name|length
operator|-=
name|bytesWritten
expr_stmt|;
name|position
operator|=
name|limit
expr_stmt|;
name|totalBytesWritten
operator|+=
name|bytesWritten
expr_stmt|;
name|doFlush
argument_list|()
expr_stmt|;
comment|// Now deal with the rest.
comment|// Since we have an output stream, this is our buffer
comment|// and buffer offset == 0
while|while
condition|(
name|length
operator|>
name|limit
condition|)
block|{
comment|// Copy data into the buffer before writing it to OutputStream.
name|value
operator|.
name|get
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|length
operator|-=
name|limit
expr_stmt|;
name|totalBytesWritten
operator|+=
name|limit
expr_stmt|;
block|}
name|value
operator|.
name|get
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|position
operator|=
name|length
expr_stmt|;
name|totalBytesWritten
operator|+=
name|length
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeLazy
parameter_list|(
name|ByteBuffer
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|flushIfNotAvailable
parameter_list|(
name|int
name|requiredSize
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|limit
operator|-
name|position
operator|<
name|requiredSize
condition|)
block|{
name|doFlush
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|doFlush
parameter_list|()
throws|throws
name|IOException
block|{
name|out
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|position
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

