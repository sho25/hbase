begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|// Protocol Buffers - Google's data interchange format
end_comment

begin_comment
comment|// Copyright 2008 Google Inc.  All rights reserved.
end_comment

begin_comment
comment|// https://developers.google.com/protocol-buffers/
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Redistribution and use in source and binary forms, with or without
end_comment

begin_comment
comment|// modification, are permitted provided that the following conditions are
end_comment

begin_comment
comment|// met:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//     * Redistributions of source code must retain the above copyright
end_comment

begin_comment
comment|// notice, this list of conditions and the following disclaimer.
end_comment

begin_comment
comment|//     * Redistributions in binary form must reproduce the above
end_comment

begin_comment
comment|// copyright notice, this list of conditions and the following disclaimer
end_comment

begin_comment
comment|// in the documentation and/or other materials provided with the
end_comment

begin_comment
comment|// distribution.
end_comment

begin_comment
comment|//     * Neither the name of Google Inc. nor the names of its
end_comment

begin_comment
comment|// contributors may be used to endorse or promote products derived from
end_comment

begin_comment
comment|// this software without specific prior written permission.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
end_comment

begin_comment
comment|// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
end_comment

begin_comment
comment|// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
end_comment

begin_comment
comment|// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
end_comment

begin_comment
comment|// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
end_comment

begin_comment
comment|// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
end_comment

begin_comment
comment|// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
end_comment

begin_comment
comment|// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
end_comment

begin_comment
comment|// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Descriptors
operator|.
name|FieldDescriptor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_comment
comment|/**  * Reflection utility methods shared by both mutable and immutable messages.  *  * @author liujisi@google.com (Pherl Liu)  */
end_comment

begin_class
class|class
name|MessageReflection
block|{
specifier|static
name|void
name|writeMessageTo
parameter_list|(
name|Message
name|message
parameter_list|,
name|Map
argument_list|<
name|FieldDescriptor
argument_list|,
name|Object
argument_list|>
name|fields
parameter_list|,
name|CodedOutputStream
name|output
parameter_list|,
name|boolean
name|alwaysWriteRequiredFields
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|boolean
name|isMessageSet
init|=
name|message
operator|.
name|getDescriptorForType
argument_list|()
operator|.
name|getOptions
argument_list|()
operator|.
name|getMessageSetWireFormat
argument_list|()
decl_stmt|;
if|if
condition|(
name|alwaysWriteRequiredFields
condition|)
block|{
name|fields
operator|=
operator|new
name|TreeMap
argument_list|<
name|FieldDescriptor
argument_list|,
name|Object
argument_list|>
argument_list|(
name|fields
argument_list|)
expr_stmt|;
for|for
control|(
specifier|final
name|FieldDescriptor
name|field
range|:
name|message
operator|.
name|getDescriptorForType
argument_list|()
operator|.
name|getFields
argument_list|()
control|)
block|{
if|if
condition|(
name|field
operator|.
name|isRequired
argument_list|()
operator|&&
operator|!
name|fields
operator|.
name|containsKey
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|fields
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|message
operator|.
name|getField
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|Descriptors
operator|.
name|FieldDescriptor
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|fields
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|Descriptors
operator|.
name|FieldDescriptor
name|field
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
specifier|final
name|Object
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|isMessageSet
operator|&&
name|field
operator|.
name|isExtension
argument_list|()
operator|&&
name|field
operator|.
name|getType
argument_list|()
operator|==
name|Descriptors
operator|.
name|FieldDescriptor
operator|.
name|Type
operator|.
name|MESSAGE
operator|&&
operator|!
name|field
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
name|output
operator|.
name|writeMessageSetExtension
argument_list|(
name|field
operator|.
name|getNumber
argument_list|()
argument_list|,
operator|(
name|Message
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FieldSet
operator|.
name|writeField
argument_list|(
name|field
argument_list|,
name|value
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|UnknownFieldSet
name|unknownFields
init|=
name|message
operator|.
name|getUnknownFields
argument_list|()
decl_stmt|;
if|if
condition|(
name|isMessageSet
condition|)
block|{
name|unknownFields
operator|.
name|writeAsMessageSetTo
argument_list|(
name|output
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unknownFields
operator|.
name|writeTo
argument_list|(
name|output
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|int
name|getSerializedSize
parameter_list|(
name|Message
name|message
parameter_list|,
name|Map
argument_list|<
name|FieldDescriptor
argument_list|,
name|Object
argument_list|>
name|fields
parameter_list|)
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
specifier|final
name|boolean
name|isMessageSet
init|=
name|message
operator|.
name|getDescriptorForType
argument_list|()
operator|.
name|getOptions
argument_list|()
operator|.
name|getMessageSetWireFormat
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|Descriptors
operator|.
name|FieldDescriptor
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|fields
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|Descriptors
operator|.
name|FieldDescriptor
name|field
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
specifier|final
name|Object
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|isMessageSet
operator|&&
name|field
operator|.
name|isExtension
argument_list|()
operator|&&
name|field
operator|.
name|getType
argument_list|()
operator|==
name|Descriptors
operator|.
name|FieldDescriptor
operator|.
name|Type
operator|.
name|MESSAGE
operator|&&
operator|!
name|field
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
name|size
operator|+=
name|CodedOutputStream
operator|.
name|computeMessageSetExtensionSize
argument_list|(
name|field
operator|.
name|getNumber
argument_list|()
argument_list|,
operator|(
name|Message
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size
operator|+=
name|FieldSet
operator|.
name|computeFieldSize
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|UnknownFieldSet
name|unknownFields
init|=
name|message
operator|.
name|getUnknownFields
argument_list|()
decl_stmt|;
if|if
condition|(
name|isMessageSet
condition|)
block|{
name|size
operator|+=
name|unknownFields
operator|.
name|getSerializedSizeAsMessageSet
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|size
operator|+=
name|unknownFields
operator|.
name|getSerializedSize
argument_list|()
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
specifier|static
name|String
name|delimitWithCommas
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|parts
parameter_list|)
block|{
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|part
range|:
name|parts
control|)
block|{
if|if
condition|(
name|result
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|append
argument_list|(
name|part
argument_list|)
expr_stmt|;
block|}
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|static
name|boolean
name|isInitialized
parameter_list|(
name|MessageOrBuilder
name|message
parameter_list|)
block|{
comment|// Check that all required fields are present.
for|for
control|(
specifier|final
name|Descriptors
operator|.
name|FieldDescriptor
name|field
range|:
name|message
operator|.
name|getDescriptorForType
argument_list|()
operator|.
name|getFields
argument_list|()
control|)
block|{
if|if
condition|(
name|field
operator|.
name|isRequired
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|message
operator|.
name|hasField
argument_list|(
name|field
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
comment|// Check that embedded messages are initialized.
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|Descriptors
operator|.
name|FieldDescriptor
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|message
operator|.
name|getAllFields
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|Descriptors
operator|.
name|FieldDescriptor
name|field
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|getJavaType
argument_list|()
operator|==
name|Descriptors
operator|.
name|FieldDescriptor
operator|.
name|JavaType
operator|.
name|MESSAGE
condition|)
block|{
if|if
condition|(
name|field
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
for|for
control|(
specifier|final
name|Message
name|element
range|:
operator|(
name|List
argument_list|<
name|Message
argument_list|>
operator|)
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|element
operator|.
name|isInitialized
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|Message
operator|)
name|entry
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|isInitialized
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
specifier|static
name|String
name|subMessagePrefix
parameter_list|(
specifier|final
name|String
name|prefix
parameter_list|,
specifier|final
name|Descriptors
operator|.
name|FieldDescriptor
name|field
parameter_list|,
specifier|final
name|int
name|index
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|isExtension
argument_list|()
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|'('
argument_list|)
operator|.
name|append
argument_list|(
name|field
operator|.
name|getFullName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|append
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
operator|.
name|append
argument_list|(
name|index
argument_list|)
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|void
name|findMissingFields
parameter_list|(
specifier|final
name|MessageOrBuilder
name|message
parameter_list|,
specifier|final
name|String
name|prefix
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|results
parameter_list|)
block|{
for|for
control|(
specifier|final
name|Descriptors
operator|.
name|FieldDescriptor
name|field
range|:
name|message
operator|.
name|getDescriptorForType
argument_list|()
operator|.
name|getFields
argument_list|()
control|)
block|{
if|if
condition|(
name|field
operator|.
name|isRequired
argument_list|()
operator|&&
operator|!
name|message
operator|.
name|hasField
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|results
operator|.
name|add
argument_list|(
name|prefix
operator|+
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|Descriptors
operator|.
name|FieldDescriptor
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|message
operator|.
name|getAllFields
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|Descriptors
operator|.
name|FieldDescriptor
name|field
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
specifier|final
name|Object
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|getJavaType
argument_list|()
operator|==
name|Descriptors
operator|.
name|FieldDescriptor
operator|.
name|JavaType
operator|.
name|MESSAGE
condition|)
block|{
if|if
condition|(
name|field
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|final
name|Object
name|element
range|:
operator|(
name|List
operator|)
name|value
control|)
block|{
name|findMissingFields
argument_list|(
operator|(
name|MessageOrBuilder
operator|)
name|element
argument_list|,
name|subMessagePrefix
argument_list|(
name|prefix
argument_list|,
name|field
argument_list|,
name|i
operator|++
argument_list|)
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|message
operator|.
name|hasField
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|findMissingFields
argument_list|(
operator|(
name|MessageOrBuilder
operator|)
name|value
argument_list|,
name|subMessagePrefix
argument_list|(
name|prefix
argument_list|,
name|field
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**    * Populates {@code this.missingFields} with the full "path" of each missing    * required field in the given message.    */
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|findMissingFields
parameter_list|(
specifier|final
name|MessageOrBuilder
name|message
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|findMissingFields
argument_list|(
name|message
argument_list|,
literal|""
argument_list|,
name|results
argument_list|)
expr_stmt|;
return|return
name|results
return|;
block|}
specifier|static
interface|interface
name|MergeTarget
block|{
enum|enum
name|ContainerType
block|{
name|MESSAGE
block|,
name|EXTENSION_SET
block|}
comment|/**      * Returns the descriptor for the target.      */
specifier|public
name|Descriptors
operator|.
name|Descriptor
name|getDescriptorForType
parameter_list|()
function_decl|;
specifier|public
name|ContainerType
name|getContainerType
parameter_list|()
function_decl|;
specifier|public
name|ExtensionRegistry
operator|.
name|ExtensionInfo
name|findExtensionByName
parameter_list|(
name|ExtensionRegistry
name|registry
parameter_list|,
name|String
name|name
parameter_list|)
function_decl|;
specifier|public
name|ExtensionRegistry
operator|.
name|ExtensionInfo
name|findExtensionByNumber
parameter_list|(
name|ExtensionRegistry
name|registry
parameter_list|,
name|Descriptors
operator|.
name|Descriptor
name|containingType
parameter_list|,
name|int
name|fieldNumber
parameter_list|)
function_decl|;
comment|/**      * Obtains the value of the given field, or the default value if it is not      * set.  For primitive fields, the boxed primitive value is returned. For      * enum fields, the EnumValueDescriptor for the value is returned. For      * embedded message fields, the sub-message is returned.  For repeated      * fields, a java.util.List is returned.      */
specifier|public
name|Object
name|getField
parameter_list|(
name|Descriptors
operator|.
name|FieldDescriptor
name|field
parameter_list|)
function_decl|;
comment|/**      * Returns true if the given field is set.  This is exactly equivalent to      * calling the generated "has" accessor method corresponding to the field.      *      * @throws IllegalArgumentException The field is a repeated field, or {@code      *     field.getContainingType() != getDescriptorForType()}.      */
name|boolean
name|hasField
parameter_list|(
name|Descriptors
operator|.
name|FieldDescriptor
name|field
parameter_list|)
function_decl|;
comment|/**      * Sets a field to the given value.  The value must be of the correct type      * for this field, i.e. the same type that      * {@link Message#getField(Descriptors.FieldDescriptor)}      * would return.      */
name|MergeTarget
name|setField
parameter_list|(
name|Descriptors
operator|.
name|FieldDescriptor
name|field
parameter_list|,
name|Object
name|value
parameter_list|)
function_decl|;
comment|/**      * Clears the field.  This is exactly equivalent to calling the generated      * "clear" accessor method corresponding to the field.      */
name|MergeTarget
name|clearField
parameter_list|(
name|Descriptors
operator|.
name|FieldDescriptor
name|field
parameter_list|)
function_decl|;
comment|/**      * Sets an element of a repeated field to the given value.  The value must      * be of the correct type for this field, i.e. the same type that {@link      * Message#getRepeatedField(Descriptors.FieldDescriptor, int)} would return.      *      * @throws IllegalArgumentException The field is not a repeated field, or      *                                  {@code field.getContainingType() !=      *                                  getDescriptorForType()}.      */
name|MergeTarget
name|setRepeatedField
parameter_list|(
name|Descriptors
operator|.
name|FieldDescriptor
name|field
parameter_list|,
name|int
name|index
parameter_list|,
name|Object
name|value
parameter_list|)
function_decl|;
comment|/**      * Like {@code setRepeatedField}, but appends the value as a new element.      *      * @throws IllegalArgumentException The field is not a repeated field, or      *                                  {@code field.getContainingType() !=      *                                  getDescriptorForType()}.      */
name|MergeTarget
name|addRepeatedField
parameter_list|(
name|Descriptors
operator|.
name|FieldDescriptor
name|field
parameter_list|,
name|Object
name|value
parameter_list|)
function_decl|;
comment|/**      * Returns true if the given oneof is set.      *      * @throws IllegalArgumentException if      *           {@code oneof.getContainingType() != getDescriptorForType()}.      */
name|boolean
name|hasOneof
parameter_list|(
name|Descriptors
operator|.
name|OneofDescriptor
name|oneof
parameter_list|)
function_decl|;
comment|/**      * Clears the oneof.  This is exactly equivalent to calling the generated      * "clear" accessor method corresponding to the oneof.      */
name|MergeTarget
name|clearOneof
parameter_list|(
name|Descriptors
operator|.
name|OneofDescriptor
name|oneof
parameter_list|)
function_decl|;
comment|/**      * Obtains the FieldDescriptor if the given oneof is set. Returns null      * if no field is set.      */
name|Descriptors
operator|.
name|FieldDescriptor
name|getOneofFieldDescriptor
parameter_list|(
name|Descriptors
operator|.
name|OneofDescriptor
name|oneof
parameter_list|)
function_decl|;
comment|/**      * Parse the input stream into a sub field group defined based on either      * FieldDescriptor or the default instance.      */
name|Object
name|parseGroup
parameter_list|(
name|CodedInputStream
name|input
parameter_list|,
name|ExtensionRegistryLite
name|registry
parameter_list|,
name|Descriptors
operator|.
name|FieldDescriptor
name|descriptor
parameter_list|,
name|Message
name|defaultInstance
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Parse the input stream into a sub field message defined based on either      * FieldDescriptor or the default instance.      */
name|Object
name|parseMessage
parameter_list|(
name|CodedInputStream
name|input
parameter_list|,
name|ExtensionRegistryLite
name|registry
parameter_list|,
name|Descriptors
operator|.
name|FieldDescriptor
name|descriptor
parameter_list|,
name|Message
name|defaultInstance
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Parse from a ByteString into a sub field message defined based on either      * FieldDescriptor or the default instance.  There isn't a varint indicating      * the length of the message at the beginning of the input ByteString.      */
name|Object
name|parseMessageFromBytes
parameter_list|(
name|ByteString
name|bytes
parameter_list|,
name|ExtensionRegistryLite
name|registry
parameter_list|,
name|Descriptors
operator|.
name|FieldDescriptor
name|descriptor
parameter_list|,
name|Message
name|defaultInstance
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Returns the UTF8 validation level for the field.      */
name|WireFormat
operator|.
name|Utf8Validation
name|getUtf8Validation
parameter_list|(
name|Descriptors
operator|.
name|FieldDescriptor
name|descriptor
parameter_list|)
function_decl|;
comment|/**      * Returns a new merge target for a sub-field. When defaultInstance is      * provided, it indicates the descriptor is for an extension type, and      * implementations should create a new instance from the defaultInstance      * prototype directly.      */
name|MergeTarget
name|newMergeTargetForField
parameter_list|(
name|Descriptors
operator|.
name|FieldDescriptor
name|descriptor
parameter_list|,
name|Message
name|defaultInstance
parameter_list|)
function_decl|;
comment|/**      * Finishes the merge and returns the underlying object.      */
name|Object
name|finish
parameter_list|()
function_decl|;
block|}
specifier|static
class|class
name|BuilderAdapter
implements|implements
name|MergeTarget
block|{
specifier|private
specifier|final
name|Message
operator|.
name|Builder
name|builder
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Descriptors
operator|.
name|Descriptor
name|getDescriptorForType
parameter_list|()
block|{
return|return
name|builder
operator|.
name|getDescriptorForType
argument_list|()
return|;
block|}
specifier|public
name|BuilderAdapter
parameter_list|(
name|Message
operator|.
name|Builder
name|builder
parameter_list|)
block|{
name|this
operator|.
name|builder
operator|=
name|builder
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getField
parameter_list|(
name|Descriptors
operator|.
name|FieldDescriptor
name|field
parameter_list|)
block|{
return|return
name|builder
operator|.
name|getField
argument_list|(
name|field
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasField
parameter_list|(
name|Descriptors
operator|.
name|FieldDescriptor
name|field
parameter_list|)
block|{
return|return
name|builder
operator|.
name|hasField
argument_list|(
name|field
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|MergeTarget
name|setField
parameter_list|(
name|Descriptors
operator|.
name|FieldDescriptor
name|field
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|builder
operator|.
name|setField
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|MergeTarget
name|clearField
parameter_list|(
name|Descriptors
operator|.
name|FieldDescriptor
name|field
parameter_list|)
block|{
name|builder
operator|.
name|clearField
argument_list|(
name|field
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|MergeTarget
name|setRepeatedField
parameter_list|(
name|Descriptors
operator|.
name|FieldDescriptor
name|field
parameter_list|,
name|int
name|index
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|builder
operator|.
name|setRepeatedField
argument_list|(
name|field
argument_list|,
name|index
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|MergeTarget
name|addRepeatedField
parameter_list|(
name|Descriptors
operator|.
name|FieldDescriptor
name|field
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|builder
operator|.
name|addRepeatedField
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasOneof
parameter_list|(
name|Descriptors
operator|.
name|OneofDescriptor
name|oneof
parameter_list|)
block|{
return|return
name|builder
operator|.
name|hasOneof
argument_list|(
name|oneof
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|MergeTarget
name|clearOneof
parameter_list|(
name|Descriptors
operator|.
name|OneofDescriptor
name|oneof
parameter_list|)
block|{
name|builder
operator|.
name|clearOneof
argument_list|(
name|oneof
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|Descriptors
operator|.
name|FieldDescriptor
name|getOneofFieldDescriptor
parameter_list|(
name|Descriptors
operator|.
name|OneofDescriptor
name|oneof
parameter_list|)
block|{
return|return
name|builder
operator|.
name|getOneofFieldDescriptor
argument_list|(
name|oneof
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|ContainerType
name|getContainerType
parameter_list|()
block|{
return|return
name|ContainerType
operator|.
name|MESSAGE
return|;
block|}
annotation|@
name|Override
specifier|public
name|ExtensionRegistry
operator|.
name|ExtensionInfo
name|findExtensionByName
parameter_list|(
name|ExtensionRegistry
name|registry
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
name|registry
operator|.
name|findImmutableExtensionByName
argument_list|(
name|name
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|ExtensionRegistry
operator|.
name|ExtensionInfo
name|findExtensionByNumber
parameter_list|(
name|ExtensionRegistry
name|registry
parameter_list|,
name|Descriptors
operator|.
name|Descriptor
name|containingType
parameter_list|,
name|int
name|fieldNumber
parameter_list|)
block|{
return|return
name|registry
operator|.
name|findImmutableExtensionByNumber
argument_list|(
name|containingType
argument_list|,
name|fieldNumber
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|parseGroup
parameter_list|(
name|CodedInputStream
name|input
parameter_list|,
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|,
name|Descriptors
operator|.
name|FieldDescriptor
name|field
parameter_list|,
name|Message
name|defaultInstance
parameter_list|)
throws|throws
name|IOException
block|{
name|Message
operator|.
name|Builder
name|subBuilder
decl_stmt|;
comment|// When default instance is not null. The field is an extension field.
if|if
condition|(
name|defaultInstance
operator|!=
literal|null
condition|)
block|{
name|subBuilder
operator|=
name|defaultInstance
operator|.
name|newBuilderForType
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|subBuilder
operator|=
name|builder
operator|.
name|newBuilderForField
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|field
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
name|Message
name|originalMessage
init|=
operator|(
name|Message
operator|)
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|originalMessage
operator|!=
literal|null
condition|)
block|{
name|subBuilder
operator|.
name|mergeFrom
argument_list|(
name|originalMessage
argument_list|)
expr_stmt|;
block|}
block|}
name|input
operator|.
name|readGroup
argument_list|(
name|field
operator|.
name|getNumber
argument_list|()
argument_list|,
name|subBuilder
argument_list|,
name|extensionRegistry
argument_list|)
expr_stmt|;
return|return
name|subBuilder
operator|.
name|buildPartial
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|parseMessage
parameter_list|(
name|CodedInputStream
name|input
parameter_list|,
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|,
name|Descriptors
operator|.
name|FieldDescriptor
name|field
parameter_list|,
name|Message
name|defaultInstance
parameter_list|)
throws|throws
name|IOException
block|{
name|Message
operator|.
name|Builder
name|subBuilder
decl_stmt|;
comment|// When default instance is not null. The field is an extension field.
if|if
condition|(
name|defaultInstance
operator|!=
literal|null
condition|)
block|{
name|subBuilder
operator|=
name|defaultInstance
operator|.
name|newBuilderForType
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|subBuilder
operator|=
name|builder
operator|.
name|newBuilderForField
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|field
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
name|Message
name|originalMessage
init|=
operator|(
name|Message
operator|)
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|originalMessage
operator|!=
literal|null
condition|)
block|{
name|subBuilder
operator|.
name|mergeFrom
argument_list|(
name|originalMessage
argument_list|)
expr_stmt|;
block|}
block|}
name|input
operator|.
name|readMessage
argument_list|(
name|subBuilder
argument_list|,
name|extensionRegistry
argument_list|)
expr_stmt|;
return|return
name|subBuilder
operator|.
name|buildPartial
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|parseMessageFromBytes
parameter_list|(
name|ByteString
name|bytes
parameter_list|,
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|,
name|Descriptors
operator|.
name|FieldDescriptor
name|field
parameter_list|,
name|Message
name|defaultInstance
parameter_list|)
throws|throws
name|IOException
block|{
name|Message
operator|.
name|Builder
name|subBuilder
decl_stmt|;
comment|// When default instance is not null. The field is an extension field.
if|if
condition|(
name|defaultInstance
operator|!=
literal|null
condition|)
block|{
name|subBuilder
operator|=
name|defaultInstance
operator|.
name|newBuilderForType
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|subBuilder
operator|=
name|builder
operator|.
name|newBuilderForField
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|field
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
name|Message
name|originalMessage
init|=
operator|(
name|Message
operator|)
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|originalMessage
operator|!=
literal|null
condition|)
block|{
name|subBuilder
operator|.
name|mergeFrom
argument_list|(
name|originalMessage
argument_list|)
expr_stmt|;
block|}
block|}
name|subBuilder
operator|.
name|mergeFrom
argument_list|(
name|bytes
argument_list|,
name|extensionRegistry
argument_list|)
expr_stmt|;
return|return
name|subBuilder
operator|.
name|buildPartial
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|MergeTarget
name|newMergeTargetForField
parameter_list|(
name|Descriptors
operator|.
name|FieldDescriptor
name|field
parameter_list|,
name|Message
name|defaultInstance
parameter_list|)
block|{
if|if
condition|(
name|defaultInstance
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|BuilderAdapter
argument_list|(
name|defaultInstance
operator|.
name|newBuilderForType
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|BuilderAdapter
argument_list|(
name|builder
operator|.
name|newBuilderForField
argument_list|(
name|field
argument_list|)
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|WireFormat
operator|.
name|Utf8Validation
name|getUtf8Validation
parameter_list|(
name|Descriptors
operator|.
name|FieldDescriptor
name|descriptor
parameter_list|)
block|{
if|if
condition|(
name|descriptor
operator|.
name|needsUtf8Check
argument_list|()
condition|)
block|{
return|return
name|WireFormat
operator|.
name|Utf8Validation
operator|.
name|STRICT
return|;
block|}
comment|// TODO(liujisi): support lazy strings for repeated fields.
if|if
condition|(
operator|!
name|descriptor
operator|.
name|isRepeated
argument_list|()
operator|&&
name|builder
operator|instanceof
name|GeneratedMessage
operator|.
name|Builder
condition|)
block|{
return|return
name|WireFormat
operator|.
name|Utf8Validation
operator|.
name|LAZY
return|;
block|}
return|return
name|WireFormat
operator|.
name|Utf8Validation
operator|.
name|LOOSE
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|finish
parameter_list|()
block|{
return|return
name|builder
operator|.
name|buildPartial
argument_list|()
return|;
block|}
block|}
specifier|static
class|class
name|ExtensionAdapter
implements|implements
name|MergeTarget
block|{
specifier|private
specifier|final
name|FieldSet
argument_list|<
name|Descriptors
operator|.
name|FieldDescriptor
argument_list|>
name|extensions
decl_stmt|;
name|ExtensionAdapter
parameter_list|(
name|FieldSet
argument_list|<
name|Descriptors
operator|.
name|FieldDescriptor
argument_list|>
name|extensions
parameter_list|)
block|{
name|this
operator|.
name|extensions
operator|=
name|extensions
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Descriptors
operator|.
name|Descriptor
name|getDescriptorForType
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"getDescriptorForType() called on FieldSet object"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getField
parameter_list|(
name|Descriptors
operator|.
name|FieldDescriptor
name|field
parameter_list|)
block|{
return|return
name|extensions
operator|.
name|getField
argument_list|(
name|field
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasField
parameter_list|(
name|Descriptors
operator|.
name|FieldDescriptor
name|field
parameter_list|)
block|{
return|return
name|extensions
operator|.
name|hasField
argument_list|(
name|field
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|MergeTarget
name|setField
parameter_list|(
name|Descriptors
operator|.
name|FieldDescriptor
name|field
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|extensions
operator|.
name|setField
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|MergeTarget
name|clearField
parameter_list|(
name|Descriptors
operator|.
name|FieldDescriptor
name|field
parameter_list|)
block|{
name|extensions
operator|.
name|clearField
argument_list|(
name|field
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|MergeTarget
name|setRepeatedField
parameter_list|(
name|Descriptors
operator|.
name|FieldDescriptor
name|field
parameter_list|,
name|int
name|index
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|extensions
operator|.
name|setRepeatedField
argument_list|(
name|field
argument_list|,
name|index
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|MergeTarget
name|addRepeatedField
parameter_list|(
name|Descriptors
operator|.
name|FieldDescriptor
name|field
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|extensions
operator|.
name|addRepeatedField
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasOneof
parameter_list|(
name|Descriptors
operator|.
name|OneofDescriptor
name|oneof
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|MergeTarget
name|clearOneof
parameter_list|(
name|Descriptors
operator|.
name|OneofDescriptor
name|oneof
parameter_list|)
block|{
comment|// Nothing to clear.
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|Descriptors
operator|.
name|FieldDescriptor
name|getOneofFieldDescriptor
parameter_list|(
name|Descriptors
operator|.
name|OneofDescriptor
name|oneof
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|ContainerType
name|getContainerType
parameter_list|()
block|{
return|return
name|ContainerType
operator|.
name|EXTENSION_SET
return|;
block|}
annotation|@
name|Override
specifier|public
name|ExtensionRegistry
operator|.
name|ExtensionInfo
name|findExtensionByName
parameter_list|(
name|ExtensionRegistry
name|registry
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
name|registry
operator|.
name|findImmutableExtensionByName
argument_list|(
name|name
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|ExtensionRegistry
operator|.
name|ExtensionInfo
name|findExtensionByNumber
parameter_list|(
name|ExtensionRegistry
name|registry
parameter_list|,
name|Descriptors
operator|.
name|Descriptor
name|containingType
parameter_list|,
name|int
name|fieldNumber
parameter_list|)
block|{
return|return
name|registry
operator|.
name|findImmutableExtensionByNumber
argument_list|(
name|containingType
argument_list|,
name|fieldNumber
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|parseGroup
parameter_list|(
name|CodedInputStream
name|input
parameter_list|,
name|ExtensionRegistryLite
name|registry
parameter_list|,
name|Descriptors
operator|.
name|FieldDescriptor
name|field
parameter_list|,
name|Message
name|defaultInstance
parameter_list|)
throws|throws
name|IOException
block|{
name|Message
operator|.
name|Builder
name|subBuilder
init|=
name|defaultInstance
operator|.
name|newBuilderForType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|field
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
name|Message
name|originalMessage
init|=
operator|(
name|Message
operator|)
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|originalMessage
operator|!=
literal|null
condition|)
block|{
name|subBuilder
operator|.
name|mergeFrom
argument_list|(
name|originalMessage
argument_list|)
expr_stmt|;
block|}
block|}
name|input
operator|.
name|readGroup
argument_list|(
name|field
operator|.
name|getNumber
argument_list|()
argument_list|,
name|subBuilder
argument_list|,
name|registry
argument_list|)
expr_stmt|;
return|return
name|subBuilder
operator|.
name|buildPartial
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|parseMessage
parameter_list|(
name|CodedInputStream
name|input
parameter_list|,
name|ExtensionRegistryLite
name|registry
parameter_list|,
name|Descriptors
operator|.
name|FieldDescriptor
name|field
parameter_list|,
name|Message
name|defaultInstance
parameter_list|)
throws|throws
name|IOException
block|{
name|Message
operator|.
name|Builder
name|subBuilder
init|=
name|defaultInstance
operator|.
name|newBuilderForType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|field
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
name|Message
name|originalMessage
init|=
operator|(
name|Message
operator|)
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|originalMessage
operator|!=
literal|null
condition|)
block|{
name|subBuilder
operator|.
name|mergeFrom
argument_list|(
name|originalMessage
argument_list|)
expr_stmt|;
block|}
block|}
name|input
operator|.
name|readMessage
argument_list|(
name|subBuilder
argument_list|,
name|registry
argument_list|)
expr_stmt|;
return|return
name|subBuilder
operator|.
name|buildPartial
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|parseMessageFromBytes
parameter_list|(
name|ByteString
name|bytes
parameter_list|,
name|ExtensionRegistryLite
name|registry
parameter_list|,
name|Descriptors
operator|.
name|FieldDescriptor
name|field
parameter_list|,
name|Message
name|defaultInstance
parameter_list|)
throws|throws
name|IOException
block|{
name|Message
operator|.
name|Builder
name|subBuilder
init|=
name|defaultInstance
operator|.
name|newBuilderForType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|field
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
name|Message
name|originalMessage
init|=
operator|(
name|Message
operator|)
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|originalMessage
operator|!=
literal|null
condition|)
block|{
name|subBuilder
operator|.
name|mergeFrom
argument_list|(
name|originalMessage
argument_list|)
expr_stmt|;
block|}
block|}
name|subBuilder
operator|.
name|mergeFrom
argument_list|(
name|bytes
argument_list|,
name|registry
argument_list|)
expr_stmt|;
return|return
name|subBuilder
operator|.
name|buildPartial
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|MergeTarget
name|newMergeTargetForField
parameter_list|(
name|Descriptors
operator|.
name|FieldDescriptor
name|descriptor
parameter_list|,
name|Message
name|defaultInstance
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"newMergeTargetForField() called on FieldSet object"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|WireFormat
operator|.
name|Utf8Validation
name|getUtf8Validation
parameter_list|(
name|Descriptors
operator|.
name|FieldDescriptor
name|descriptor
parameter_list|)
block|{
if|if
condition|(
name|descriptor
operator|.
name|needsUtf8Check
argument_list|()
condition|)
block|{
return|return
name|WireFormat
operator|.
name|Utf8Validation
operator|.
name|STRICT
return|;
block|}
comment|// TODO(liujisi): support lazy strings for ExtesnsionSet.
return|return
name|WireFormat
operator|.
name|Utf8Validation
operator|.
name|LOOSE
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|finish
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"finish() called on FieldSet object"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Parses a single field into MergeTarget. The target can be Message.Builder,    * FieldSet or MutableMessage.    *    * Package-private because it is used by GeneratedMessage.ExtendableMessage.    *    * @param tag The tag, which should have already been read.    * @return {@code true} unless the tag is an end-group tag.    */
specifier|static
name|boolean
name|mergeFieldFrom
parameter_list|(
name|CodedInputStream
name|input
parameter_list|,
name|UnknownFieldSet
operator|.
name|Builder
name|unknownFields
parameter_list|,
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|,
name|Descriptors
operator|.
name|Descriptor
name|type
parameter_list|,
name|MergeTarget
name|target
parameter_list|,
name|int
name|tag
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|type
operator|.
name|getOptions
argument_list|()
operator|.
name|getMessageSetWireFormat
argument_list|()
operator|&&
name|tag
operator|==
name|WireFormat
operator|.
name|MESSAGE_SET_ITEM_TAG
condition|)
block|{
name|mergeMessageSetExtensionFromCodedStream
argument_list|(
name|input
argument_list|,
name|unknownFields
argument_list|,
name|extensionRegistry
argument_list|,
name|type
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|final
name|int
name|wireType
init|=
name|WireFormat
operator|.
name|getTagWireType
argument_list|(
name|tag
argument_list|)
decl_stmt|;
specifier|final
name|int
name|fieldNumber
init|=
name|WireFormat
operator|.
name|getTagFieldNumber
argument_list|(
name|tag
argument_list|)
decl_stmt|;
specifier|final
name|Descriptors
operator|.
name|FieldDescriptor
name|field
decl_stmt|;
name|Message
name|defaultInstance
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|isExtensionNumber
argument_list|(
name|fieldNumber
argument_list|)
condition|)
block|{
comment|// extensionRegistry may be either ExtensionRegistry or
comment|// ExtensionRegistryLite.  Since the type we are parsing is a full
comment|// message, only a full ExtensionRegistry could possibly contain
comment|// extensions of it.  Otherwise we will treat the registry as if it
comment|// were empty.
if|if
condition|(
name|extensionRegistry
operator|instanceof
name|ExtensionRegistry
condition|)
block|{
specifier|final
name|ExtensionRegistry
operator|.
name|ExtensionInfo
name|extension
init|=
name|target
operator|.
name|findExtensionByNumber
argument_list|(
operator|(
name|ExtensionRegistry
operator|)
name|extensionRegistry
argument_list|,
name|type
argument_list|,
name|fieldNumber
argument_list|)
decl_stmt|;
if|if
condition|(
name|extension
operator|==
literal|null
condition|)
block|{
name|field
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|field
operator|=
name|extension
operator|.
name|descriptor
expr_stmt|;
name|defaultInstance
operator|=
name|extension
operator|.
name|defaultInstance
expr_stmt|;
if|if
condition|(
name|defaultInstance
operator|==
literal|null
operator|&&
name|field
operator|.
name|getJavaType
argument_list|()
operator|==
name|Descriptors
operator|.
name|FieldDescriptor
operator|.
name|JavaType
operator|.
name|MESSAGE
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Message-typed extension lacked default instance: "
operator|+
name|field
operator|.
name|getFullName
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
else|else
block|{
name|field
operator|=
literal|null
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|target
operator|.
name|getContainerType
argument_list|()
operator|==
name|MergeTarget
operator|.
name|ContainerType
operator|.
name|MESSAGE
condition|)
block|{
name|field
operator|=
name|type
operator|.
name|findFieldByNumber
argument_list|(
name|fieldNumber
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|field
operator|=
literal|null
expr_stmt|;
block|}
name|boolean
name|unknown
init|=
literal|false
decl_stmt|;
name|boolean
name|packed
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
name|unknown
operator|=
literal|true
expr_stmt|;
comment|// Unknown field.
block|}
elseif|else
if|if
condition|(
name|wireType
operator|==
name|FieldSet
operator|.
name|getWireFormatForFieldType
argument_list|(
name|field
operator|.
name|getLiteType
argument_list|()
argument_list|,
literal|false
comment|/* isPacked */
argument_list|)
condition|)
block|{
name|packed
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|isPackable
argument_list|()
operator|&&
name|wireType
operator|==
name|FieldSet
operator|.
name|getWireFormatForFieldType
argument_list|(
name|field
operator|.
name|getLiteType
argument_list|()
argument_list|,
literal|true
comment|/* isPacked */
argument_list|)
condition|)
block|{
name|packed
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|unknown
operator|=
literal|true
expr_stmt|;
comment|// Unknown wire type.
block|}
if|if
condition|(
name|unknown
condition|)
block|{
comment|// Unknown field or wrong wire type.  Skip.
return|return
name|unknownFields
operator|.
name|mergeFieldFrom
argument_list|(
name|tag
argument_list|,
name|input
argument_list|)
return|;
block|}
if|if
condition|(
name|packed
condition|)
block|{
specifier|final
name|int
name|length
init|=
name|input
operator|.
name|readRawVarint32
argument_list|()
decl_stmt|;
specifier|final
name|int
name|limit
init|=
name|input
operator|.
name|pushLimit
argument_list|(
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|getLiteType
argument_list|()
operator|==
name|WireFormat
operator|.
name|FieldType
operator|.
name|ENUM
condition|)
block|{
while|while
condition|(
name|input
operator|.
name|getBytesUntilLimit
argument_list|()
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|rawValue
init|=
name|input
operator|.
name|readEnum
argument_list|()
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|getFile
argument_list|()
operator|.
name|supportsUnknownEnumValue
argument_list|()
condition|)
block|{
name|target
operator|.
name|addRepeatedField
argument_list|(
name|field
argument_list|,
name|field
operator|.
name|getEnumType
argument_list|()
operator|.
name|findValueByNumberCreatingIfUnknown
argument_list|(
name|rawValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|Object
name|value
init|=
name|field
operator|.
name|getEnumType
argument_list|()
operator|.
name|findValueByNumber
argument_list|(
name|rawValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
comment|// If the number isn't recognized as a valid value for this
comment|// enum, drop it (don't even add it to unknownFields).
return|return
literal|true
return|;
block|}
name|target
operator|.
name|addRepeatedField
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
while|while
condition|(
name|input
operator|.
name|getBytesUntilLimit
argument_list|()
operator|>
literal|0
condition|)
block|{
specifier|final
name|Object
name|value
init|=
name|WireFormat
operator|.
name|readPrimitiveField
argument_list|(
name|input
argument_list|,
name|field
operator|.
name|getLiteType
argument_list|()
argument_list|,
name|target
operator|.
name|getUtf8Validation
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
name|target
operator|.
name|addRepeatedField
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
name|input
operator|.
name|popLimit
argument_list|(
name|limit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|Object
name|value
decl_stmt|;
switch|switch
condition|(
name|field
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|GROUP
case|:
block|{
name|value
operator|=
name|target
operator|.
name|parseGroup
argument_list|(
name|input
argument_list|,
name|extensionRegistry
argument_list|,
name|field
argument_list|,
name|defaultInstance
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MESSAGE
case|:
block|{
name|value
operator|=
name|target
operator|.
name|parseMessage
argument_list|(
name|input
argument_list|,
name|extensionRegistry
argument_list|,
name|field
argument_list|,
name|defaultInstance
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ENUM
case|:
specifier|final
name|int
name|rawValue
init|=
name|input
operator|.
name|readEnum
argument_list|()
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|getFile
argument_list|()
operator|.
name|supportsUnknownEnumValue
argument_list|()
condition|)
block|{
name|value
operator|=
name|field
operator|.
name|getEnumType
argument_list|()
operator|.
name|findValueByNumberCreatingIfUnknown
argument_list|(
name|rawValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|field
operator|.
name|getEnumType
argument_list|()
operator|.
name|findValueByNumber
argument_list|(
name|rawValue
argument_list|)
expr_stmt|;
comment|// If the number isn't recognized as a valid value for this enum,
comment|// drop it.
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|unknownFields
operator|.
name|mergeVarintField
argument_list|(
name|fieldNumber
argument_list|,
name|rawValue
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
break|break;
default|default:
name|value
operator|=
name|WireFormat
operator|.
name|readPrimitiveField
argument_list|(
name|input
argument_list|,
name|field
operator|.
name|getLiteType
argument_list|()
argument_list|,
name|target
operator|.
name|getUtf8Validation
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|field
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
name|target
operator|.
name|addRepeatedField
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|target
operator|.
name|setField
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Called by {@code #mergeFieldFrom()} to parse a MessageSet extension into    * MergeTarget.    */
specifier|private
specifier|static
name|void
name|mergeMessageSetExtensionFromCodedStream
parameter_list|(
name|CodedInputStream
name|input
parameter_list|,
name|UnknownFieldSet
operator|.
name|Builder
name|unknownFields
parameter_list|,
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|,
name|Descriptors
operator|.
name|Descriptor
name|type
parameter_list|,
name|MergeTarget
name|target
parameter_list|)
throws|throws
name|IOException
block|{
comment|// The wire format for MessageSet is:
comment|//   message MessageSet {
comment|//     repeated group Item = 1 {
comment|//       required int32 typeId = 2;
comment|//       required bytes message = 3;
comment|//     }
comment|//   }
comment|// "typeId" is the extension's field number.  The extension can only be
comment|// a message type, where "message" contains the encoded bytes of that
comment|// message.
comment|//
comment|// In practice, we will probably never see a MessageSet item in which
comment|// the message appears before the type ID, or where either field does not
comment|// appear exactly once.  However, in theory such cases are valid, so we
comment|// should be prepared to accept them.
name|int
name|typeId
init|=
literal|0
decl_stmt|;
name|ByteString
name|rawBytes
init|=
literal|null
decl_stmt|;
comment|// If we encounter "message" before "typeId"
name|ExtensionRegistry
operator|.
name|ExtensionInfo
name|extension
init|=
literal|null
decl_stmt|;
comment|// Read bytes from input, if we get it's type first then parse it eagerly,
comment|// otherwise we store the raw bytes in a local variable.
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|tag
init|=
name|input
operator|.
name|readTag
argument_list|()
decl_stmt|;
if|if
condition|(
name|tag
operator|==
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|tag
operator|==
name|WireFormat
operator|.
name|MESSAGE_SET_TYPE_ID_TAG
condition|)
block|{
name|typeId
operator|=
name|input
operator|.
name|readUInt32
argument_list|()
expr_stmt|;
if|if
condition|(
name|typeId
operator|!=
literal|0
condition|)
block|{
comment|// extensionRegistry may be either ExtensionRegistry or
comment|// ExtensionRegistryLite. Since the type we are parsing is a full
comment|// message, only a full ExtensionRegistry could possibly contain
comment|// extensions of it. Otherwise we will treat the registry as if it
comment|// were empty.
if|if
condition|(
name|extensionRegistry
operator|instanceof
name|ExtensionRegistry
condition|)
block|{
name|extension
operator|=
name|target
operator|.
name|findExtensionByNumber
argument_list|(
operator|(
name|ExtensionRegistry
operator|)
name|extensionRegistry
argument_list|,
name|type
argument_list|,
name|typeId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|tag
operator|==
name|WireFormat
operator|.
name|MESSAGE_SET_MESSAGE_TAG
condition|)
block|{
if|if
condition|(
name|typeId
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|extension
operator|!=
literal|null
operator|&&
name|ExtensionRegistryLite
operator|.
name|isEagerlyParseMessageSets
argument_list|()
condition|)
block|{
comment|// We already know the type, so we can parse directly from the
comment|// input with no copying.  Hooray!
name|eagerlyMergeMessageSetExtension
argument_list|(
name|input
argument_list|,
name|extension
argument_list|,
name|extensionRegistry
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|rawBytes
operator|=
literal|null
expr_stmt|;
continue|continue;
block|}
block|}
comment|// We haven't seen a type ID yet or we want parse message lazily.
name|rawBytes
operator|=
name|input
operator|.
name|readBytes
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Unknown tag. Skip it.
if|if
condition|(
operator|!
name|input
operator|.
name|skipField
argument_list|(
name|tag
argument_list|)
condition|)
block|{
break|break;
comment|// End of group
block|}
block|}
block|}
name|input
operator|.
name|checkLastTagWas
argument_list|(
name|WireFormat
operator|.
name|MESSAGE_SET_ITEM_END_TAG
argument_list|)
expr_stmt|;
comment|// Process the raw bytes.
if|if
condition|(
name|rawBytes
operator|!=
literal|null
operator|&&
name|typeId
operator|!=
literal|0
condition|)
block|{
comment|// Zero is not a valid type ID.
if|if
condition|(
name|extension
operator|!=
literal|null
condition|)
block|{
comment|// We known the type
name|mergeMessageSetExtensionFromBytes
argument_list|(
name|rawBytes
argument_list|,
name|extension
argument_list|,
name|extensionRegistry
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// We don't know how to parse this. Ignore it.
if|if
condition|(
name|rawBytes
operator|!=
literal|null
condition|)
block|{
name|unknownFields
operator|.
name|mergeField
argument_list|(
name|typeId
argument_list|,
name|UnknownFieldSet
operator|.
name|Field
operator|.
name|newBuilder
argument_list|()
operator|.
name|addLengthDelimited
argument_list|(
name|rawBytes
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
specifier|static
name|void
name|mergeMessageSetExtensionFromBytes
parameter_list|(
name|ByteString
name|rawBytes
parameter_list|,
name|ExtensionRegistry
operator|.
name|ExtensionInfo
name|extension
parameter_list|,
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|,
name|MergeTarget
name|target
parameter_list|)
throws|throws
name|IOException
block|{
name|Descriptors
operator|.
name|FieldDescriptor
name|field
init|=
name|extension
operator|.
name|descriptor
decl_stmt|;
name|boolean
name|hasOriginalValue
init|=
name|target
operator|.
name|hasField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|hasOriginalValue
operator|||
name|ExtensionRegistryLite
operator|.
name|isEagerlyParseMessageSets
argument_list|()
condition|)
block|{
comment|// If the field already exists, we just parse the field.
name|Object
name|value
init|=
name|target
operator|.
name|parseMessageFromBytes
argument_list|(
name|rawBytes
argument_list|,
name|extensionRegistry
argument_list|,
name|field
argument_list|,
name|extension
operator|.
name|defaultInstance
argument_list|)
decl_stmt|;
name|target
operator|.
name|setField
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Use LazyField to load MessageSet lazily.
name|LazyField
name|lazyField
init|=
operator|new
name|LazyField
argument_list|(
name|extension
operator|.
name|defaultInstance
argument_list|,
name|extensionRegistry
argument_list|,
name|rawBytes
argument_list|)
decl_stmt|;
name|target
operator|.
name|setField
argument_list|(
name|field
argument_list|,
name|lazyField
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|void
name|eagerlyMergeMessageSetExtension
parameter_list|(
name|CodedInputStream
name|input
parameter_list|,
name|ExtensionRegistry
operator|.
name|ExtensionInfo
name|extension
parameter_list|,
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|,
name|MergeTarget
name|target
parameter_list|)
throws|throws
name|IOException
block|{
name|Descriptors
operator|.
name|FieldDescriptor
name|field
init|=
name|extension
operator|.
name|descriptor
decl_stmt|;
name|Object
name|value
init|=
name|target
operator|.
name|parseMessage
argument_list|(
name|input
argument_list|,
name|extensionRegistry
argument_list|,
name|field
argument_list|,
name|extension
operator|.
name|defaultInstance
argument_list|)
decl_stmt|;
name|target
operator|.
name|setField
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

