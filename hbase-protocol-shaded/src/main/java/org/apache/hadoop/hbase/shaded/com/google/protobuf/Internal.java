begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|// Protocol Buffers - Google's data interchange format
end_comment

begin_comment
comment|// Copyright 2008 Google Inc.  All rights reserved.
end_comment

begin_comment
comment|// https://developers.google.com/protocol-buffers/
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Redistribution and use in source and binary forms, with or without
end_comment

begin_comment
comment|// modification, are permitted provided that the following conditions are
end_comment

begin_comment
comment|// met:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//     * Redistributions of source code must retain the above copyright
end_comment

begin_comment
comment|// notice, this list of conditions and the following disclaimer.
end_comment

begin_comment
comment|//     * Redistributions in binary form must reproduce the above
end_comment

begin_comment
comment|// copyright notice, this list of conditions and the following disclaimer
end_comment

begin_comment
comment|// in the documentation and/or other materials provided with the
end_comment

begin_comment
comment|// distribution.
end_comment

begin_comment
comment|//     * Neither the name of Google Inc. nor the names of its
end_comment

begin_comment
comment|// contributors may be used to endorse or promote products derived from
end_comment

begin_comment
comment|// this software without specific prior written permission.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
end_comment

begin_comment
comment|// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
end_comment

begin_comment
comment|// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
end_comment

begin_comment
comment|// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
end_comment

begin_comment
comment|// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
end_comment

begin_comment
comment|// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
end_comment

begin_comment
comment|// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
end_comment

begin_comment
comment|// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
end_comment

begin_comment
comment|// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|RandomAccess
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * The classes contained within are used internally by the Protocol Buffer  * library and generated message implementations. They are public only because  * those generated messages do not reside in the {@code protobuf} package.  * Others should not use this class directly.  *  * @author kenton@google.com (Kenton Varda)  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|Internal
block|{
specifier|private
name|Internal
parameter_list|()
block|{}
specifier|static
specifier|final
name|Charset
name|UTF_8
init|=
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-8"
argument_list|)
decl_stmt|;
specifier|static
specifier|final
name|Charset
name|ISO_8859_1
init|=
name|Charset
operator|.
name|forName
argument_list|(
literal|"ISO-8859-1"
argument_list|)
decl_stmt|;
comment|/**    * Throws an appropriate {@link NullPointerException} if the given objects is {@code null}.    */
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|checkNotNull
parameter_list|(
name|T
name|obj
parameter_list|,
name|String
name|message
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
name|message
argument_list|)
throw|;
block|}
return|return
name|obj
return|;
block|}
comment|/**    * Helper called by generated code to construct default values for string    * fields.    *<p>    * The protocol compiler does not actually contain a UTF-8 decoder -- it    * just pushes UTF-8-encoded text around without touching it.  The one place    * where this presents a problem is when generating Java string literals.    * Unicode characters in the string literal would normally need to be encoded    * using a Unicode escape sequence, which would require decoding them.    * To get around this, protoc instead embeds the UTF-8 bytes into the    * generated code and leaves it to the runtime library to decode them.    *<p>    * It gets worse, though.  If protoc just generated a byte array, like:    *   new byte[] {0x12, 0x34, 0x56, 0x78}    * Java actually generates *code* which allocates an array and then fills    * in each value.  This is much less efficient than just embedding the bytes    * directly into the bytecode.  To get around this, we need another    * work-around.  String literals are embedded directly, so protoc actually    * generates a string literal corresponding to the bytes.  The easiest way    * to do this is to use the ISO-8859-1 character set, which corresponds to    * the first 256 characters of the Unicode range.  Protoc can then use    * good old CEscape to generate the string.    *<p>    * So we have a string literal which represents a set of bytes which    * represents another string.  This function -- stringDefaultValue --    * converts from the generated string to the string we actually want.  The    * generated code calls this automatically.    */
specifier|public
specifier|static
name|String
name|stringDefaultValue
parameter_list|(
name|String
name|bytes
parameter_list|)
block|{
return|return
operator|new
name|String
argument_list|(
name|bytes
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
argument_list|,
name|UTF_8
argument_list|)
return|;
block|}
comment|/**    * Helper called by generated code to construct default values for bytes    * fields.    *<p>    * This is a lot like {@link #stringDefaultValue}, but for bytes fields.    * In this case we only need the second of the two hacks -- allowing us to    * embed raw bytes as a string literal with ISO-8859-1 encoding.    */
specifier|public
specifier|static
name|ByteString
name|bytesDefaultValue
parameter_list|(
name|String
name|bytes
parameter_list|)
block|{
return|return
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|bytes
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Helper called by generated code to construct default values for bytes    * fields.    *<p>    * This is like {@link #bytesDefaultValue}, but returns a byte array.    */
specifier|public
specifier|static
name|byte
index|[]
name|byteArrayDefaultValue
parameter_list|(
name|String
name|bytes
parameter_list|)
block|{
return|return
name|bytes
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
return|;
block|}
comment|/**    * Helper called by generated code to construct default values for bytes    * fields.    *<p>    * This is like {@link #bytesDefaultValue}, but returns a ByteBuffer.    */
specifier|public
specifier|static
name|ByteBuffer
name|byteBufferDefaultValue
parameter_list|(
name|String
name|bytes
parameter_list|)
block|{
return|return
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|byteArrayDefaultValue
argument_list|(
name|bytes
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Create a new ByteBuffer and copy all the content of {@code source}    * ByteBuffer to the new ByteBuffer. The new ByteBuffer's limit and    * capacity will be source.capacity(), and its position will be 0.    * Note that the state of {@code source} ByteBuffer won't be changed.    */
specifier|public
specifier|static
name|ByteBuffer
name|copyByteBuffer
parameter_list|(
name|ByteBuffer
name|source
parameter_list|)
block|{
comment|// Make a duplicate of the source ByteBuffer and read data from the
comment|// duplicate. This is to avoid affecting the source ByteBuffer's state.
name|ByteBuffer
name|temp
init|=
name|source
operator|.
name|duplicate
argument_list|()
decl_stmt|;
comment|// We want to copy all the data in the source ByteBuffer, not just the
comment|// remaining bytes.
name|temp
operator|.
name|clear
argument_list|()
expr_stmt|;
name|ByteBuffer
name|result
init|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|temp
operator|.
name|capacity
argument_list|()
argument_list|)
decl_stmt|;
name|result
operator|.
name|put
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|result
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Helper called by generated code to determine if a byte array is a valid    * UTF-8 encoded string such that the original bytes can be converted to    * a String object and then back to a byte array round tripping the bytes    * without loss.  More precisely, returns {@code true} whenever:    *<pre>   {@code    * Arrays.equals(byteString.toByteArray(),    *     new String(byteString.toByteArray(), "UTF-8").getBytes("UTF-8"))    * }</pre>    *    *<p>This method rejects "overlong" byte sequences, as well as    * 3-byte sequences that would map to a surrogate character, in    * accordance with the restricted definition of UTF-8 introduced in    * Unicode 3.1.  Note that the UTF-8 decoder included in Oracle's    * JDK has been modified to also reject "overlong" byte sequences,    * but currently (2011) still accepts 3-byte surrogate character    * byte sequences.    *    *<p>See the Unicode Standard,<br>    * Table 3-6.<em>UTF-8 Bit Distribution</em>,<br>    * Table 3-7.<em>Well Formed UTF-8 Byte Sequences</em>.    *    *<p>As of 2011-02, this method simply returns the result of {@link    * ByteString#isValidUtf8()}.  Calling that method directly is preferred.    *    * @param byteString the string to check    * @return whether the byte array is round trippable    */
specifier|public
specifier|static
name|boolean
name|isValidUtf8
parameter_list|(
name|ByteString
name|byteString
parameter_list|)
block|{
return|return
name|byteString
operator|.
name|isValidUtf8
argument_list|()
return|;
block|}
comment|/**    * Like {@link #isValidUtf8(ByteString)} but for byte arrays.    */
specifier|public
specifier|static
name|boolean
name|isValidUtf8
parameter_list|(
name|byte
index|[]
name|byteArray
parameter_list|)
block|{
return|return
name|Utf8
operator|.
name|isValidUtf8
argument_list|(
name|byteArray
argument_list|)
return|;
block|}
comment|/**    * Helper method to get the UTF-8 bytes of a string.    */
specifier|public
specifier|static
name|byte
index|[]
name|toByteArray
parameter_list|(
name|String
name|value
parameter_list|)
block|{
return|return
name|value
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
return|;
block|}
comment|/**    * Helper method to convert a byte array to a string using UTF-8 encoding.    */
specifier|public
specifier|static
name|String
name|toStringUtf8
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|)
block|{
return|return
operator|new
name|String
argument_list|(
name|bytes
argument_list|,
name|UTF_8
argument_list|)
return|;
block|}
comment|/**    * Interface for an enum value or value descriptor, to be used in FieldSet.    * The lite library stores enum values directly in FieldSets but the full    * library stores EnumValueDescriptors in order to better support reflection.    */
specifier|public
interface|interface
name|EnumLite
block|{
name|int
name|getNumber
parameter_list|()
function_decl|;
block|}
comment|/**    * Interface for an object which maps integers to {@link EnumLite}s.    * {@link Descriptors.EnumDescriptor} implements this interface by mapping    * numbers to {@link Descriptors.EnumValueDescriptor}s.  Additionally,    * every generated enum type has a static method internalGetValueMap() which    * returns an implementation of this type that maps numbers to enum values.    */
specifier|public
interface|interface
name|EnumLiteMap
parameter_list|<
name|T
extends|extends
name|EnumLite
parameter_list|>
block|{
name|T
name|findValueByNumber
parameter_list|(
name|int
name|number
parameter_list|)
function_decl|;
block|}
comment|/**    * Helper method for implementing {@link Message#hashCode()} for longs.    * @see Long#hashCode()    */
specifier|public
specifier|static
name|int
name|hashLong
parameter_list|(
name|long
name|n
parameter_list|)
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|n
operator|^
operator|(
name|n
operator|>>>
literal|32
operator|)
argument_list|)
return|;
block|}
comment|/**    * Helper method for implementing {@link Message#hashCode()} for    * booleans.    * @see Boolean#hashCode()    */
specifier|public
specifier|static
name|int
name|hashBoolean
parameter_list|(
name|boolean
name|b
parameter_list|)
block|{
return|return
name|b
condition|?
literal|1231
else|:
literal|1237
return|;
block|}
comment|/**    * Helper method for implementing {@link Message#hashCode()} for enums.    *<p>    * This is needed because {@link java.lang.Enum#hashCode()} is final, but we    * need to use the field number as the hash code to ensure compatibility    * between statically and dynamically generated enum objects.    */
specifier|public
specifier|static
name|int
name|hashEnum
parameter_list|(
name|EnumLite
name|e
parameter_list|)
block|{
return|return
name|e
operator|.
name|getNumber
argument_list|()
return|;
block|}
comment|/**    * Helper method for implementing {@link Message#hashCode()} for    * enum lists.    */
specifier|public
specifier|static
name|int
name|hashEnumList
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|EnumLite
argument_list|>
name|list
parameter_list|)
block|{
name|int
name|hash
init|=
literal|1
decl_stmt|;
for|for
control|(
name|EnumLite
name|e
range|:
name|list
control|)
block|{
name|hash
operator|=
literal|31
operator|*
name|hash
operator|+
name|hashEnum
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|hash
return|;
block|}
comment|/**    * Helper method for implementing {@link Message#equals(Object)} for bytes field.    */
specifier|public
specifier|static
name|boolean
name|equals
parameter_list|(
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|a
parameter_list|,
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|size
argument_list|()
operator|!=
name|b
operator|.
name|size
argument_list|()
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|a
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|a
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|b
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Helper method for implementing {@link Message#hashCode()} for bytes field.    */
specifier|public
specifier|static
name|int
name|hashCode
parameter_list|(
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|list
parameter_list|)
block|{
name|int
name|hash
init|=
literal|1
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|bytes
range|:
name|list
control|)
block|{
name|hash
operator|=
literal|31
operator|*
name|hash
operator|+
name|hashCode
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
return|return
name|hash
return|;
block|}
comment|/**    * Helper method for implementing {@link Message#hashCode()} for bytes field.    */
specifier|public
specifier|static
name|int
name|hashCode
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|)
block|{
comment|// The hash code for a byte array should be the same as the hash code for a
comment|// ByteString with the same content. This is to ensure that the generated
comment|// hashCode() method will return the same value as the pure reflection
comment|// based hashCode() method.
return|return
name|Internal
operator|.
name|hashCode
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * Helper method for implementing {@link LiteralByteString#hashCode()}.    */
specifier|static
name|int
name|hashCode
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
comment|// The hash code for a byte array should be the same as the hash code for a
comment|// ByteString with the same content. This is to ensure that the generated
comment|// hashCode() method will return the same value as the pure reflection
comment|// based hashCode() method.
name|int
name|h
init|=
name|Internal
operator|.
name|partialHash
argument_list|(
name|length
argument_list|,
name|bytes
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
decl_stmt|;
return|return
name|h
operator|==
literal|0
condition|?
literal|1
else|:
name|h
return|;
block|}
comment|/**    * Helper method for continuously hashing bytes.    */
specifier|static
name|int
name|partialHash
parameter_list|(
name|int
name|h
parameter_list|,
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|offset
init|;
name|i
operator|<
name|offset
operator|+
name|length
condition|;
name|i
operator|++
control|)
block|{
name|h
operator|=
name|h
operator|*
literal|31
operator|+
name|bytes
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
comment|/**    * Helper method for implementing {@link Message#equals(Object)} for bytes    * field.    */
specifier|public
specifier|static
name|boolean
name|equalsByteBuffer
parameter_list|(
name|ByteBuffer
name|a
parameter_list|,
name|ByteBuffer
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|capacity
argument_list|()
operator|!=
name|b
operator|.
name|capacity
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// ByteBuffer.equals() will only compare the remaining bytes, but we want to
comment|// compare all the content.
return|return
name|a
operator|.
name|duplicate
argument_list|()
operator|.
name|clear
argument_list|()
operator|.
name|equals
argument_list|(
name|b
operator|.
name|duplicate
argument_list|()
operator|.
name|clear
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Helper method for implementing {@link Message#equals(Object)} for bytes    * field.    */
specifier|public
specifier|static
name|boolean
name|equalsByteBuffer
parameter_list|(
name|List
argument_list|<
name|ByteBuffer
argument_list|>
name|a
parameter_list|,
name|List
argument_list|<
name|ByteBuffer
argument_list|>
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|size
argument_list|()
operator|!=
name|b
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|a
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|equalsByteBuffer
argument_list|(
name|a
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|b
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Helper method for implementing {@link Message#hashCode()} for bytes    * field.    */
specifier|public
specifier|static
name|int
name|hashCodeByteBuffer
parameter_list|(
name|List
argument_list|<
name|ByteBuffer
argument_list|>
name|list
parameter_list|)
block|{
name|int
name|hash
init|=
literal|1
decl_stmt|;
for|for
control|(
name|ByteBuffer
name|bytes
range|:
name|list
control|)
block|{
name|hash
operator|=
literal|31
operator|*
name|hash
operator|+
name|hashCodeByteBuffer
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
return|return
name|hash
return|;
block|}
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_BUFFER_SIZE
init|=
literal|4096
decl_stmt|;
comment|/**    * Helper method for implementing {@link Message#hashCode()} for bytes    * field.    */
specifier|public
specifier|static
name|int
name|hashCodeByteBuffer
parameter_list|(
name|ByteBuffer
name|bytes
parameter_list|)
block|{
if|if
condition|(
name|bytes
operator|.
name|hasArray
argument_list|()
condition|)
block|{
comment|// Fast path.
name|int
name|h
init|=
name|partialHash
argument_list|(
name|bytes
operator|.
name|capacity
argument_list|()
argument_list|,
name|bytes
operator|.
name|array
argument_list|()
argument_list|,
name|bytes
operator|.
name|arrayOffset
argument_list|()
argument_list|,
name|bytes
operator|.
name|capacity
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|h
operator|==
literal|0
condition|?
literal|1
else|:
name|h
return|;
block|}
else|else
block|{
comment|// Read the data into a temporary byte array before calculating the
comment|// hash value.
specifier|final
name|int
name|bufferSize
init|=
name|bytes
operator|.
name|capacity
argument_list|()
operator|>
name|DEFAULT_BUFFER_SIZE
condition|?
name|DEFAULT_BUFFER_SIZE
else|:
name|bytes
operator|.
name|capacity
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
name|bufferSize
index|]
decl_stmt|;
specifier|final
name|ByteBuffer
name|duplicated
init|=
name|bytes
operator|.
name|duplicate
argument_list|()
decl_stmt|;
name|duplicated
operator|.
name|clear
argument_list|()
expr_stmt|;
name|int
name|h
init|=
name|bytes
operator|.
name|capacity
argument_list|()
decl_stmt|;
while|while
condition|(
name|duplicated
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|length
init|=
name|duplicated
operator|.
name|remaining
argument_list|()
operator|<=
name|bufferSize
condition|?
name|duplicated
operator|.
name|remaining
argument_list|()
else|:
name|bufferSize
decl_stmt|;
name|duplicated
operator|.
name|get
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|h
operator|=
name|partialHash
argument_list|(
name|h
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
return|return
name|h
operator|==
literal|0
condition|?
literal|1
else|:
name|h
return|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|static
parameter_list|<
name|T
extends|extends
name|MessageLite
parameter_list|>
name|T
name|getDefaultInstance
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|)
block|{
try|try
block|{
name|Method
name|method
init|=
name|clazz
operator|.
name|getMethod
argument_list|(
literal|"getDefaultInstance"
argument_list|)
decl_stmt|;
return|return
operator|(
name|T
operator|)
name|method
operator|.
name|invoke
argument_list|(
name|method
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Failed to get default instance for "
operator|+
name|clazz
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * An empty byte array constant used in generated code.    */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|EMPTY_BYTE_ARRAY
init|=
operator|new
name|byte
index|[
literal|0
index|]
decl_stmt|;
comment|/**    * An empty byte array constant used in generated code.    */
specifier|public
specifier|static
specifier|final
name|ByteBuffer
name|EMPTY_BYTE_BUFFER
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|EMPTY_BYTE_ARRAY
argument_list|)
decl_stmt|;
comment|/** An empty coded input stream constant used in generated code. */
specifier|public
specifier|static
specifier|final
name|CodedInputStream
name|EMPTY_CODED_INPUT_STREAM
init|=
name|CodedInputStream
operator|.
name|newInstance
argument_list|(
name|EMPTY_BYTE_ARRAY
argument_list|)
decl_stmt|;
comment|/**    * Provides an immutable view of {@code List<T>} around a {@code List<F>}.    *    * Protobuf internal. Used in protobuf generated code only.    */
specifier|public
specifier|static
class|class
name|ListAdapter
parameter_list|<
name|F
parameter_list|,
name|T
parameter_list|>
extends|extends
name|AbstractList
argument_list|<
name|T
argument_list|>
block|{
comment|/**      * Convert individual elements of the List from F to T.      */
specifier|public
interface|interface
name|Converter
parameter_list|<
name|F
parameter_list|,
name|T
parameter_list|>
block|{
name|T
name|convert
parameter_list|(
name|F
name|from
parameter_list|)
function_decl|;
block|}
specifier|private
specifier|final
name|List
argument_list|<
name|F
argument_list|>
name|fromList
decl_stmt|;
specifier|private
specifier|final
name|Converter
argument_list|<
name|F
argument_list|,
name|T
argument_list|>
name|converter
decl_stmt|;
specifier|public
name|ListAdapter
parameter_list|(
name|List
argument_list|<
name|F
argument_list|>
name|fromList
parameter_list|,
name|Converter
argument_list|<
name|F
argument_list|,
name|T
argument_list|>
name|converter
parameter_list|)
block|{
name|this
operator|.
name|fromList
operator|=
name|fromList
expr_stmt|;
name|this
operator|.
name|converter
operator|=
name|converter
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|T
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|converter
operator|.
name|convert
argument_list|(
name|fromList
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|fromList
operator|.
name|size
argument_list|()
return|;
block|}
block|}
comment|/**    * Wrap around a {@code Map<K, RealValue>} and provide a {@code Map<K, V>}    * interface.    */
specifier|public
specifier|static
class|class
name|MapAdapter
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|RealValue
parameter_list|>
extends|extends
name|AbstractMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
comment|/**      * An interface used to convert between two types.      */
specifier|public
interface|interface
name|Converter
parameter_list|<
name|A
parameter_list|,
name|B
parameter_list|>
block|{
name|B
name|doForward
parameter_list|(
name|A
name|object
parameter_list|)
function_decl|;
name|A
name|doBackward
parameter_list|(
name|B
name|object
parameter_list|)
function_decl|;
block|}
specifier|public
specifier|static
parameter_list|<
name|T
extends|extends
name|EnumLite
parameter_list|>
name|Converter
argument_list|<
name|Integer
argument_list|,
name|T
argument_list|>
name|newEnumConverter
parameter_list|(
specifier|final
name|EnumLiteMap
argument_list|<
name|T
argument_list|>
name|enumMap
parameter_list|,
specifier|final
name|T
name|unrecognizedValue
parameter_list|)
block|{
return|return
operator|new
name|Converter
argument_list|<
name|Integer
argument_list|,
name|T
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|T
name|doForward
parameter_list|(
name|Integer
name|value
parameter_list|)
block|{
name|T
name|result
init|=
name|enumMap
operator|.
name|findValueByNumber
argument_list|(
name|value
argument_list|)
decl_stmt|;
return|return
name|result
operator|==
literal|null
condition|?
name|unrecognizedValue
else|:
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|Integer
name|doBackward
parameter_list|(
name|T
name|value
parameter_list|)
block|{
return|return
name|value
operator|.
name|getNumber
argument_list|()
return|;
block|}
block|}
return|;
block|}
specifier|private
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|RealValue
argument_list|>
name|realMap
decl_stmt|;
specifier|private
specifier|final
name|Converter
argument_list|<
name|RealValue
argument_list|,
name|V
argument_list|>
name|valueConverter
decl_stmt|;
specifier|public
name|MapAdapter
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|RealValue
argument_list|>
name|realMap
parameter_list|,
name|Converter
argument_list|<
name|RealValue
argument_list|,
name|V
argument_list|>
name|valueConverter
parameter_list|)
block|{
name|this
operator|.
name|realMap
operator|=
name|realMap
expr_stmt|;
name|this
operator|.
name|valueConverter
operator|=
name|valueConverter
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
specifier|public
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|RealValue
name|result
init|=
name|realMap
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|valueConverter
operator|.
name|doForward
argument_list|(
name|result
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|RealValue
name|oldValue
init|=
name|realMap
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|valueConverter
operator|.
name|doBackward
argument_list|(
name|value
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldValue
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|valueConverter
operator|.
name|doForward
argument_list|(
name|oldValue
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
return|return
operator|new
name|SetAdapter
argument_list|(
name|realMap
operator|.
name|entrySet
argument_list|()
argument_list|)
return|;
block|}
specifier|private
class|class
name|SetAdapter
extends|extends
name|AbstractSet
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
specifier|private
specifier|final
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|RealValue
argument_list|>
argument_list|>
name|realSet
decl_stmt|;
specifier|public
name|SetAdapter
parameter_list|(
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|RealValue
argument_list|>
argument_list|>
name|realSet
parameter_list|)
block|{
name|this
operator|.
name|realSet
operator|=
name|realSet
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|IteratorAdapter
argument_list|(
name|realSet
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|realSet
operator|.
name|size
argument_list|()
return|;
block|}
block|}
specifier|private
class|class
name|IteratorAdapter
implements|implements
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
specifier|private
specifier|final
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|RealValue
argument_list|>
argument_list|>
name|realIterator
decl_stmt|;
specifier|public
name|IteratorAdapter
parameter_list|(
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|RealValue
argument_list|>
argument_list|>
name|realIterator
parameter_list|)
block|{
name|this
operator|.
name|realIterator
operator|=
name|realIterator
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|realIterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|()
block|{
return|return
operator|new
name|EntryAdapter
argument_list|(
name|realIterator
operator|.
name|next
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|realIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
class|class
name|EntryAdapter
implements|implements
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
specifier|private
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|RealValue
argument_list|>
name|realEntry
decl_stmt|;
specifier|public
name|EntryAdapter
parameter_list|(
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|RealValue
argument_list|>
name|realEntry
parameter_list|)
block|{
name|this
operator|.
name|realEntry
operator|=
name|realEntry
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|realEntry
operator|.
name|getKey
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|getValue
parameter_list|()
block|{
return|return
name|valueConverter
operator|.
name|doForward
argument_list|(
name|realEntry
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|setValue
parameter_list|(
name|V
name|value
parameter_list|)
block|{
name|RealValue
name|oldValue
init|=
name|realEntry
operator|.
name|setValue
argument_list|(
name|valueConverter
operator|.
name|doBackward
argument_list|(
name|value
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldValue
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|valueConverter
operator|.
name|doForward
argument_list|(
name|oldValue
argument_list|)
return|;
block|}
block|}
block|}
comment|/**    * Extends {@link List} to add the capability to make the list immutable and inspect if it is    * modifiable.    *<p>    * All implementations must support efficient random access.    */
specifier|public
specifier|static
interface|interface
name|ProtobufList
parameter_list|<
name|E
parameter_list|>
extends|extends
name|List
argument_list|<
name|E
argument_list|>
extends|,
name|RandomAccess
block|{
comment|/**      * Makes this list immutable. All subsequent modifications will throw an      * {@link UnsupportedOperationException}.      */
name|void
name|makeImmutable
parameter_list|()
function_decl|;
comment|/**      * Returns whether this list can be modified via the publicly accessible {@link List} methods.      */
name|boolean
name|isModifiable
parameter_list|()
function_decl|;
comment|/**      * Returns a mutable clone of this list with the specified capacity.      */
name|ProtobufList
argument_list|<
name|E
argument_list|>
name|mutableCopyWithCapacity
parameter_list|(
name|int
name|capacity
parameter_list|)
function_decl|;
block|}
comment|/**    * A {@link java.util.List} implementation that avoids boxing the elements into Integers if    * possible. Does not support null elements.    */
specifier|public
specifier|static
interface|interface
name|IntList
extends|extends
name|ProtobufList
argument_list|<
name|Integer
argument_list|>
block|{
comment|/**      * Like {@link #get(int)} but more efficient in that it doesn't box the returned value.      */
name|int
name|getInt
parameter_list|(
name|int
name|index
parameter_list|)
function_decl|;
comment|/**      * Like {@link #add(Object)} but more efficient in that it doesn't box the element.      */
name|void
name|addInt
parameter_list|(
name|int
name|element
parameter_list|)
function_decl|;
comment|/**      * Like {@link #set(int, Object)} but more efficient in that it doesn't box the element.      */
name|int
name|setInt
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|element
parameter_list|)
function_decl|;
comment|/**      * Returns a mutable clone of this list with the specified capacity.      */
annotation|@
name|Override
name|IntList
name|mutableCopyWithCapacity
parameter_list|(
name|int
name|capacity
parameter_list|)
function_decl|;
block|}
comment|/**    * A {@link java.util.List} implementation that avoids boxing the elements into Booleans if    * possible. Does not support null elements.    */
specifier|public
specifier|static
interface|interface
name|BooleanList
extends|extends
name|ProtobufList
argument_list|<
name|Boolean
argument_list|>
block|{
comment|/**      * Like {@link #get(int)} but more efficient in that it doesn't box the returned value.      */
name|boolean
name|getBoolean
parameter_list|(
name|int
name|index
parameter_list|)
function_decl|;
comment|/**      * Like {@link #add(Object)} but more efficient in that it doesn't box the element.      */
name|void
name|addBoolean
parameter_list|(
name|boolean
name|element
parameter_list|)
function_decl|;
comment|/**      * Like {@link #set(int, Object)} but more efficient in that it doesn't box the element.      */
name|boolean
name|setBoolean
parameter_list|(
name|int
name|index
parameter_list|,
name|boolean
name|element
parameter_list|)
function_decl|;
comment|/**      * Returns a mutable clone of this list with the specified capacity.      */
annotation|@
name|Override
name|BooleanList
name|mutableCopyWithCapacity
parameter_list|(
name|int
name|capacity
parameter_list|)
function_decl|;
block|}
comment|/**    * A {@link java.util.List} implementation that avoids boxing the elements into Longs if    * possible. Does not support null elements.    */
specifier|public
specifier|static
interface|interface
name|LongList
extends|extends
name|ProtobufList
argument_list|<
name|Long
argument_list|>
block|{
comment|/**      * Like {@link #get(int)} but more efficient in that it doesn't box the returned value.      */
name|long
name|getLong
parameter_list|(
name|int
name|index
parameter_list|)
function_decl|;
comment|/**      * Like {@link #add(Object)} but more efficient in that it doesn't box the element.      */
name|void
name|addLong
parameter_list|(
name|long
name|element
parameter_list|)
function_decl|;
comment|/**      * Like {@link #set(int, Object)} but more efficient in that it doesn't box the element.      */
name|long
name|setLong
parameter_list|(
name|int
name|index
parameter_list|,
name|long
name|element
parameter_list|)
function_decl|;
comment|/**      * Returns a mutable clone of this list with the specified capacity.      */
annotation|@
name|Override
name|LongList
name|mutableCopyWithCapacity
parameter_list|(
name|int
name|capacity
parameter_list|)
function_decl|;
block|}
comment|/**    * A {@link java.util.List} implementation that avoids boxing the elements into Doubles if    * possible. Does not support null elements.    */
specifier|public
specifier|static
interface|interface
name|DoubleList
extends|extends
name|ProtobufList
argument_list|<
name|Double
argument_list|>
block|{
comment|/**      * Like {@link #get(int)} but more efficient in that it doesn't box the returned value.      */
name|double
name|getDouble
parameter_list|(
name|int
name|index
parameter_list|)
function_decl|;
comment|/**      * Like {@link #add(Object)} but more efficient in that it doesn't box the element.      */
name|void
name|addDouble
parameter_list|(
name|double
name|element
parameter_list|)
function_decl|;
comment|/**      * Like {@link #set(int, Object)} but more efficient in that it doesn't box the element.      */
name|double
name|setDouble
parameter_list|(
name|int
name|index
parameter_list|,
name|double
name|element
parameter_list|)
function_decl|;
comment|/**      * Returns a mutable clone of this list with the specified capacity.      */
annotation|@
name|Override
name|DoubleList
name|mutableCopyWithCapacity
parameter_list|(
name|int
name|capacity
parameter_list|)
function_decl|;
block|}
comment|/**    * A {@link java.util.List} implementation that avoids boxing the elements into Floats if    * possible. Does not support null elements.    */
specifier|public
specifier|static
interface|interface
name|FloatList
extends|extends
name|ProtobufList
argument_list|<
name|Float
argument_list|>
block|{
comment|/**      * Like {@link #get(int)} but more efficient in that it doesn't box the returned value.      */
name|float
name|getFloat
parameter_list|(
name|int
name|index
parameter_list|)
function_decl|;
comment|/**      * Like {@link #add(Object)} but more efficient in that it doesn't box the element.      */
name|void
name|addFloat
parameter_list|(
name|float
name|element
parameter_list|)
function_decl|;
comment|/**      * Like {@link #set(int, Object)} but more efficient in that it doesn't box the element.      */
name|float
name|setFloat
parameter_list|(
name|int
name|index
parameter_list|,
name|float
name|element
parameter_list|)
function_decl|;
comment|/**      * Returns a mutable clone of this list with the specified capacity.      */
annotation|@
name|Override
name|FloatList
name|mutableCopyWithCapacity
parameter_list|(
name|int
name|capacity
parameter_list|)
function_decl|;
block|}
block|}
end_class

end_unit

