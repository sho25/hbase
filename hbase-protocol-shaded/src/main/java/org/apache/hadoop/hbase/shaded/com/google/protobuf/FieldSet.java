begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|// Protocol Buffers - Google's data interchange format
end_comment

begin_comment
comment|// Copyright 2008 Google Inc.  All rights reserved.
end_comment

begin_comment
comment|// https://developers.google.com/protocol-buffers/
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Redistribution and use in source and binary forms, with or without
end_comment

begin_comment
comment|// modification, are permitted provided that the following conditions are
end_comment

begin_comment
comment|// met:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//     * Redistributions of source code must retain the above copyright
end_comment

begin_comment
comment|// notice, this list of conditions and the following disclaimer.
end_comment

begin_comment
comment|//     * Redistributions in binary form must reproduce the above
end_comment

begin_comment
comment|// copyright notice, this list of conditions and the following disclaimer
end_comment

begin_comment
comment|// in the documentation and/or other materials provided with the
end_comment

begin_comment
comment|// distribution.
end_comment

begin_comment
comment|//     * Neither the name of Google Inc. nor the names of its
end_comment

begin_comment
comment|// contributors may be used to endorse or promote products derived from
end_comment

begin_comment
comment|// this software without specific prior written permission.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
end_comment

begin_comment
comment|// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
end_comment

begin_comment
comment|// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
end_comment

begin_comment
comment|// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
end_comment

begin_comment
comment|// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
end_comment

begin_comment
comment|// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
end_comment

begin_comment
comment|// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
end_comment

begin_comment
comment|// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
end_comment

begin_comment
comment|// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|LazyField
operator|.
name|LazyIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * A class which represents an arbitrary set of fields of some message type.  * This is used to implement {@link DynamicMessage}, and also to represent  * extensions in {@link GeneratedMessage}.  This class is package-private,  * since outside users should probably be using {@link DynamicMessage}.  *  * @author kenton@google.com Kenton Varda  */
end_comment

begin_class
specifier|final
class|class
name|FieldSet
parameter_list|<
name|FieldDescriptorType
extends|extends
name|FieldSet
operator|.
name|FieldDescriptorLite
parameter_list|<
name|FieldDescriptorType
parameter_list|>
parameter_list|>
block|{
comment|/**    * Interface for a FieldDescriptor or lite extension descriptor.  This    * prevents FieldSet from depending on {@link Descriptors.FieldDescriptor}.    */
specifier|public
interface|interface
name|FieldDescriptorLite
parameter_list|<
name|T
extends|extends
name|FieldDescriptorLite
parameter_list|<
name|T
parameter_list|>
parameter_list|>
extends|extends
name|Comparable
argument_list|<
name|T
argument_list|>
block|{
name|int
name|getNumber
parameter_list|()
function_decl|;
name|WireFormat
operator|.
name|FieldType
name|getLiteType
parameter_list|()
function_decl|;
name|WireFormat
operator|.
name|JavaType
name|getLiteJavaType
parameter_list|()
function_decl|;
name|boolean
name|isRepeated
parameter_list|()
function_decl|;
name|boolean
name|isPacked
parameter_list|()
function_decl|;
name|Internal
operator|.
name|EnumLiteMap
argument_list|<
name|?
argument_list|>
name|getEnumType
parameter_list|()
function_decl|;
comment|// If getLiteJavaType() == MESSAGE, this merges a message object of the
comment|// type into a builder of the type.  Returns {@code to}.
name|MessageLite
operator|.
name|Builder
name|internalMergeFrom
parameter_list|(
name|MessageLite
operator|.
name|Builder
name|to
parameter_list|,
name|MessageLite
name|from
parameter_list|)
function_decl|;
block|}
specifier|private
specifier|final
name|SmallSortedMap
argument_list|<
name|FieldDescriptorType
argument_list|,
name|Object
argument_list|>
name|fields
decl_stmt|;
specifier|private
name|boolean
name|isImmutable
decl_stmt|;
specifier|private
name|boolean
name|hasLazyField
init|=
literal|false
decl_stmt|;
comment|/** Construct a new FieldSet. */
specifier|private
name|FieldSet
parameter_list|()
block|{
name|this
operator|.
name|fields
operator|=
name|SmallSortedMap
operator|.
name|newFieldMap
argument_list|(
literal|16
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct an empty FieldSet.  This is only used to initialize    * DEFAULT_INSTANCE.    */
specifier|private
name|FieldSet
parameter_list|(
specifier|final
name|boolean
name|dummy
parameter_list|)
block|{
name|this
operator|.
name|fields
operator|=
name|SmallSortedMap
operator|.
name|newFieldMap
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|makeImmutable
argument_list|()
expr_stmt|;
block|}
comment|/** Construct a new FieldSet. */
specifier|public
specifier|static
parameter_list|<
name|T
extends|extends
name|FieldSet
operator|.
name|FieldDescriptorLite
argument_list|<
name|T
argument_list|>
parameter_list|>
name|FieldSet
argument_list|<
name|T
argument_list|>
name|newFieldSet
parameter_list|()
block|{
return|return
operator|new
name|FieldSet
argument_list|<
name|T
argument_list|>
argument_list|()
return|;
block|}
comment|/** Get an immutable empty FieldSet. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|static
parameter_list|<
name|T
extends|extends
name|FieldSet
operator|.
name|FieldDescriptorLite
argument_list|<
name|T
argument_list|>
parameter_list|>
name|FieldSet
argument_list|<
name|T
argument_list|>
name|emptySet
parameter_list|()
block|{
return|return
name|DEFAULT_INSTANCE
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
specifier|private
specifier|static
specifier|final
name|FieldSet
name|DEFAULT_INSTANCE
init|=
operator|new
name|FieldSet
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|/** Make this FieldSet immutable from this point forward. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|void
name|makeImmutable
parameter_list|()
block|{
if|if
condition|(
name|isImmutable
condition|)
block|{
return|return;
block|}
name|fields
operator|.
name|makeImmutable
argument_list|()
expr_stmt|;
name|isImmutable
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * Returns whether the FieldSet is immutable. This is true if it is the    * {@link #emptySet} or if {@link #makeImmutable} were called.    *    * @return whether the FieldSet is immutable.    */
specifier|public
name|boolean
name|isImmutable
parameter_list|()
block|{
return|return
name|isImmutable
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|FieldSet
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|FieldSet
argument_list|<
name|?
argument_list|>
name|other
init|=
operator|(
name|FieldSet
argument_list|<
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
return|return
name|fields
operator|.
name|equals
argument_list|(
name|other
operator|.
name|fields
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|fields
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|/**    * Clones the FieldSet. The returned FieldSet will be mutable even if the    * original FieldSet was immutable.    *    * @return the newly cloned FieldSet    */
annotation|@
name|Override
specifier|public
name|FieldSet
argument_list|<
name|FieldDescriptorType
argument_list|>
name|clone
parameter_list|()
block|{
comment|// We can't just call fields.clone because List objects in the map
comment|// should not be shared.
name|FieldSet
argument_list|<
name|FieldDescriptorType
argument_list|>
name|clone
init|=
name|FieldSet
operator|.
name|newFieldSet
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|getNumArrayEntries
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|FieldDescriptorType
argument_list|,
name|Object
argument_list|>
name|entry
init|=
name|fields
operator|.
name|getArrayEntryAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|FieldDescriptorType
name|descriptor
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|clone
operator|.
name|setField
argument_list|(
name|descriptor
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|FieldDescriptorType
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|fields
operator|.
name|getOverflowEntries
argument_list|()
control|)
block|{
name|FieldDescriptorType
name|descriptor
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|clone
operator|.
name|setField
argument_list|(
name|descriptor
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|clone
operator|.
name|hasLazyField
operator|=
name|hasLazyField
expr_stmt|;
return|return
name|clone
return|;
block|}
comment|// =================================================================
comment|/** See {@link Message.Builder#clear()}. */
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|fields
operator|.
name|clear
argument_list|()
expr_stmt|;
name|hasLazyField
operator|=
literal|false
expr_stmt|;
block|}
comment|/**    * Get a simple map containing all the fields.    */
specifier|public
name|Map
argument_list|<
name|FieldDescriptorType
argument_list|,
name|Object
argument_list|>
name|getAllFields
parameter_list|()
block|{
if|if
condition|(
name|hasLazyField
condition|)
block|{
name|SmallSortedMap
argument_list|<
name|FieldDescriptorType
argument_list|,
name|Object
argument_list|>
name|result
init|=
name|SmallSortedMap
operator|.
name|newFieldMap
argument_list|(
literal|16
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|getNumArrayEntries
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|cloneFieldEntry
argument_list|(
name|result
argument_list|,
name|fields
operator|.
name|getArrayEntryAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|FieldDescriptorType
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|fields
operator|.
name|getOverflowEntries
argument_list|()
control|)
block|{
name|cloneFieldEntry
argument_list|(
name|result
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fields
operator|.
name|isImmutable
argument_list|()
condition|)
block|{
name|result
operator|.
name|makeImmutable
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
return|return
name|fields
operator|.
name|isImmutable
argument_list|()
condition|?
name|fields
else|:
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|fields
argument_list|)
return|;
block|}
specifier|private
name|void
name|cloneFieldEntry
parameter_list|(
name|Map
argument_list|<
name|FieldDescriptorType
argument_list|,
name|Object
argument_list|>
name|map
parameter_list|,
name|Map
operator|.
name|Entry
argument_list|<
name|FieldDescriptorType
argument_list|,
name|Object
argument_list|>
name|entry
parameter_list|)
block|{
name|FieldDescriptorType
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Object
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|LazyField
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
operator|(
operator|(
name|LazyField
operator|)
name|value
operator|)
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get an iterator to the field map. This iterator should not be leaked out    * of the protobuf library as it is not protected from mutation when fields    * is not immutable.    */
specifier|public
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|FieldDescriptorType
argument_list|,
name|Object
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
if|if
condition|(
name|hasLazyField
condition|)
block|{
return|return
operator|new
name|LazyIterator
argument_list|<
name|FieldDescriptorType
argument_list|>
argument_list|(
name|fields
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
return|return
name|fields
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
comment|/**    * Useful for implementing    * {@link Message#hasField(Descriptors.FieldDescriptor)}.    */
specifier|public
name|boolean
name|hasField
parameter_list|(
specifier|final
name|FieldDescriptorType
name|descriptor
parameter_list|)
block|{
if|if
condition|(
name|descriptor
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"hasField() can only be called on non-repeated fields."
argument_list|)
throw|;
block|}
return|return
name|fields
operator|.
name|get
argument_list|(
name|descriptor
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**    * Useful for implementing    * {@link Message#getField(Descriptors.FieldDescriptor)}.  This method    * returns {@code null} if the field is not set; in this case it is up    * to the caller to fetch the field's default value.    */
specifier|public
name|Object
name|getField
parameter_list|(
specifier|final
name|FieldDescriptorType
name|descriptor
parameter_list|)
block|{
name|Object
name|o
init|=
name|fields
operator|.
name|get
argument_list|(
name|descriptor
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|instanceof
name|LazyField
condition|)
block|{
return|return
operator|(
operator|(
name|LazyField
operator|)
name|o
operator|)
operator|.
name|getValue
argument_list|()
return|;
block|}
return|return
name|o
return|;
block|}
comment|/**    * Useful for implementing    * {@link Message.Builder#setField(Descriptors.FieldDescriptor,Object)}.    */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unchecked"
block|,
literal|"rawtypes"
block|}
argument_list|)
specifier|public
name|void
name|setField
parameter_list|(
specifier|final
name|FieldDescriptorType
name|descriptor
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|descriptor
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|value
operator|instanceof
name|List
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Wrong object type used with protocol message reflection."
argument_list|)
throw|;
block|}
comment|// Wrap the contents in a new list so that the caller cannot change
comment|// the list's contents after setting it.
specifier|final
name|List
name|newList
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|newList
operator|.
name|addAll
argument_list|(
operator|(
name|List
operator|)
name|value
argument_list|)
expr_stmt|;
for|for
control|(
specifier|final
name|Object
name|element
range|:
name|newList
control|)
block|{
name|verifyType
argument_list|(
name|descriptor
operator|.
name|getLiteType
argument_list|()
argument_list|,
name|element
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|newList
expr_stmt|;
block|}
else|else
block|{
name|verifyType
argument_list|(
name|descriptor
operator|.
name|getLiteType
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|instanceof
name|LazyField
condition|)
block|{
name|hasLazyField
operator|=
literal|true
expr_stmt|;
block|}
name|fields
operator|.
name|put
argument_list|(
name|descriptor
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**    * Useful for implementing    * {@link Message.Builder#clearField(Descriptors.FieldDescriptor)}.    */
specifier|public
name|void
name|clearField
parameter_list|(
specifier|final
name|FieldDescriptorType
name|descriptor
parameter_list|)
block|{
name|fields
operator|.
name|remove
argument_list|(
name|descriptor
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|hasLazyField
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|/**    * Useful for implementing    * {@link Message#getRepeatedFieldCount(Descriptors.FieldDescriptor)}.    */
specifier|public
name|int
name|getRepeatedFieldCount
parameter_list|(
specifier|final
name|FieldDescriptorType
name|descriptor
parameter_list|)
block|{
if|if
condition|(
operator|!
name|descriptor
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"getRepeatedField() can only be called on repeated fields."
argument_list|)
throw|;
block|}
specifier|final
name|Object
name|value
init|=
name|getField
argument_list|(
name|descriptor
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|value
operator|)
operator|.
name|size
argument_list|()
return|;
block|}
block|}
comment|/**    * Useful for implementing    * {@link Message#getRepeatedField(Descriptors.FieldDescriptor,int)}.    */
specifier|public
name|Object
name|getRepeatedField
parameter_list|(
specifier|final
name|FieldDescriptorType
name|descriptor
parameter_list|,
specifier|final
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
operator|!
name|descriptor
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"getRepeatedField() can only be called on repeated fields."
argument_list|)
throw|;
block|}
specifier|final
name|Object
name|value
init|=
name|getField
argument_list|(
name|descriptor
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|()
throw|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|value
operator|)
operator|.
name|get
argument_list|(
name|index
argument_list|)
return|;
block|}
block|}
comment|/**    * Useful for implementing    * {@link Message.Builder#setRepeatedField(Descriptors.FieldDescriptor,int,Object)}.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|void
name|setRepeatedField
parameter_list|(
specifier|final
name|FieldDescriptorType
name|descriptor
parameter_list|,
specifier|final
name|int
name|index
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|descriptor
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"getRepeatedField() can only be called on repeated fields."
argument_list|)
throw|;
block|}
specifier|final
name|Object
name|list
init|=
name|getField
argument_list|(
name|descriptor
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|()
throw|;
block|}
name|verifyType
argument_list|(
name|descriptor
operator|.
name|getLiteType
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
operator|(
operator|(
name|List
argument_list|<
name|Object
argument_list|>
operator|)
name|list
operator|)
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**    * Useful for implementing    * {@link Message.Builder#addRepeatedField(Descriptors.FieldDescriptor,Object)}.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|void
name|addRepeatedField
parameter_list|(
specifier|final
name|FieldDescriptorType
name|descriptor
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|descriptor
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"addRepeatedField() can only be called on repeated fields."
argument_list|)
throw|;
block|}
name|verifyType
argument_list|(
name|descriptor
operator|.
name|getLiteType
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
specifier|final
name|Object
name|existingValue
init|=
name|getField
argument_list|(
name|descriptor
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|list
decl_stmt|;
if|if
condition|(
name|existingValue
operator|==
literal|null
condition|)
block|{
name|list
operator|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|()
expr_stmt|;
name|fields
operator|.
name|put
argument_list|(
name|descriptor
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list
operator|=
operator|(
name|List
argument_list|<
name|Object
argument_list|>
operator|)
name|existingValue
expr_stmt|;
block|}
name|list
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**    * Verifies that the given object is of the correct type to be a valid    * value for the given field.  (For repeated fields, this checks if the    * object is the right type to be one element of the field.)    *    * @throws IllegalArgumentException The value is not of the right type.    */
specifier|private
specifier|static
name|void
name|verifyType
parameter_list|(
specifier|final
name|WireFormat
operator|.
name|FieldType
name|type
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
name|boolean
name|isValid
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|type
operator|.
name|getJavaType
argument_list|()
condition|)
block|{
case|case
name|INT
case|:
name|isValid
operator|=
name|value
operator|instanceof
name|Integer
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|isValid
operator|=
name|value
operator|instanceof
name|Long
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|isValid
operator|=
name|value
operator|instanceof
name|Float
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
name|isValid
operator|=
name|value
operator|instanceof
name|Double
expr_stmt|;
break|break;
case|case
name|BOOLEAN
case|:
name|isValid
operator|=
name|value
operator|instanceof
name|Boolean
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|isValid
operator|=
name|value
operator|instanceof
name|String
expr_stmt|;
break|break;
case|case
name|BYTE_STRING
case|:
name|isValid
operator|=
name|value
operator|instanceof
name|ByteString
operator|||
name|value
operator|instanceof
name|byte
index|[]
expr_stmt|;
break|break;
case|case
name|ENUM
case|:
comment|// TODO(kenton):  Caller must do type checking here, I guess.
name|isValid
operator|=
operator|(
name|value
operator|instanceof
name|Integer
operator|||
name|value
operator|instanceof
name|Internal
operator|.
name|EnumLite
operator|)
expr_stmt|;
break|break;
case|case
name|MESSAGE
case|:
comment|// TODO(kenton):  Caller must do type checking here, I guess.
name|isValid
operator|=
operator|(
name|value
operator|instanceof
name|MessageLite
operator|)
operator|||
operator|(
name|value
operator|instanceof
name|LazyField
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|isValid
condition|)
block|{
comment|// TODO(kenton):  When chaining calls to setField(), it can be hard to
comment|//   tell from the stack trace which exact call failed, since the whole
comment|//   chain is considered one line of code.  It would be nice to print
comment|//   more information here, e.g. naming the field.  We used to do that.
comment|//   But we can't now that FieldSet doesn't use descriptors.  Maybe this
comment|//   isn't a big deal, though, since it would only really apply when using
comment|//   reflection and generally people don't chain reflection setters.
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Wrong object type used with protocol message reflection."
argument_list|)
throw|;
block|}
block|}
comment|// =================================================================
comment|// Parsing and serialization
comment|/**    * See {@link Message#isInitialized()}.  Note:  Since {@code FieldSet}    * itself does not have any way of knowing about required fields that    * aren't actually present in the set, it is up to the caller to check    * that all required fields are present.    */
specifier|public
name|boolean
name|isInitialized
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|getNumArrayEntries
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isInitialized
argument_list|(
name|fields
operator|.
name|getArrayEntryAt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|FieldDescriptorType
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|fields
operator|.
name|getOverflowEntries
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|isInitialized
argument_list|(
name|entry
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
name|boolean
name|isInitialized
parameter_list|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|FieldDescriptorType
argument_list|,
name|Object
argument_list|>
name|entry
parameter_list|)
block|{
specifier|final
name|FieldDescriptorType
name|descriptor
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|descriptor
operator|.
name|getLiteJavaType
argument_list|()
operator|==
name|WireFormat
operator|.
name|JavaType
operator|.
name|MESSAGE
condition|)
block|{
if|if
condition|(
name|descriptor
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
for|for
control|(
specifier|final
name|MessageLite
name|element
range|:
operator|(
name|List
argument_list|<
name|MessageLite
argument_list|>
operator|)
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|element
operator|.
name|isInitialized
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
else|else
block|{
name|Object
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|MessageLite
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|MessageLite
operator|)
name|value
operator|)
operator|.
name|isInitialized
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|LazyField
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Wrong object type used with protocol message reflection."
argument_list|)
throw|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Given a field type, return the wire type.    *    * @returns One of the {@code WIRETYPE_} constants defined in    *          {@link WireFormat}.    */
specifier|static
name|int
name|getWireFormatForFieldType
parameter_list|(
specifier|final
name|WireFormat
operator|.
name|FieldType
name|type
parameter_list|,
name|boolean
name|isPacked
parameter_list|)
block|{
if|if
condition|(
name|isPacked
condition|)
block|{
return|return
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
return|;
block|}
else|else
block|{
return|return
name|type
operator|.
name|getWireType
argument_list|()
return|;
block|}
block|}
comment|/**    * Like {@link Message.Builder#mergeFrom(Message)}, but merges from another    * {@link FieldSet}.    */
specifier|public
name|void
name|mergeFrom
parameter_list|(
specifier|final
name|FieldSet
argument_list|<
name|FieldDescriptorType
argument_list|>
name|other
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|other
operator|.
name|fields
operator|.
name|getNumArrayEntries
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|mergeFromField
argument_list|(
name|other
operator|.
name|fields
operator|.
name|getArrayEntryAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|FieldDescriptorType
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|other
operator|.
name|fields
operator|.
name|getOverflowEntries
argument_list|()
control|)
block|{
name|mergeFromField
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|Object
name|cloneIfMutable
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|byte
index|[]
condition|)
block|{
name|byte
index|[]
name|bytes
init|=
operator|(
name|byte
index|[]
operator|)
name|value
decl_stmt|;
name|byte
index|[]
name|copy
init|=
operator|new
name|byte
index|[
name|bytes
operator|.
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|copy
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
else|else
block|{
return|return
name|value
return|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unchecked"
block|,
literal|"rawtypes"
block|}
argument_list|)
specifier|private
name|void
name|mergeFromField
parameter_list|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|FieldDescriptorType
argument_list|,
name|Object
argument_list|>
name|entry
parameter_list|)
block|{
specifier|final
name|FieldDescriptorType
name|descriptor
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Object
name|otherValue
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|otherValue
operator|instanceof
name|LazyField
condition|)
block|{
name|otherValue
operator|=
operator|(
operator|(
name|LazyField
operator|)
name|otherValue
operator|)
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|descriptor
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
name|Object
name|value
init|=
name|getField
argument_list|(
name|descriptor
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|value
operator|=
operator|new
name|ArrayList
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Object
name|element
range|:
operator|(
name|List
operator|)
name|otherValue
control|)
block|{
operator|(
operator|(
name|List
operator|)
name|value
operator|)
operator|.
name|add
argument_list|(
name|cloneIfMutable
argument_list|(
name|element
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fields
operator|.
name|put
argument_list|(
name|descriptor
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|descriptor
operator|.
name|getLiteJavaType
argument_list|()
operator|==
name|WireFormat
operator|.
name|JavaType
operator|.
name|MESSAGE
condition|)
block|{
name|Object
name|value
init|=
name|getField
argument_list|(
name|descriptor
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|fields
operator|.
name|put
argument_list|(
name|descriptor
argument_list|,
name|cloneIfMutable
argument_list|(
name|otherValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Merge the messages.
name|value
operator|=
name|descriptor
operator|.
name|internalMergeFrom
argument_list|(
operator|(
operator|(
name|MessageLite
operator|)
name|value
operator|)
operator|.
name|toBuilder
argument_list|()
argument_list|,
operator|(
name|MessageLite
operator|)
name|otherValue
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|fields
operator|.
name|put
argument_list|(
name|descriptor
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fields
operator|.
name|put
argument_list|(
name|descriptor
argument_list|,
name|cloneIfMutable
argument_list|(
name|otherValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO(kenton):  Move static parsing and serialization methods into some
comment|//   other class.  Probably WireFormat.
comment|/**    * Read a field of any primitive type for immutable messages from a    * CodedInputStream. Enums, groups, and embedded messages are not handled by    * this method.    *    * @param input The stream from which to read.    * @param type Declared type of the field.    * @param checkUtf8 When true, check that the input is valid utf8.    * @return An object representing the field's value, of the exact    *         type which would be returned by    *         {@link Message#getField(Descriptors.FieldDescriptor)} for    *         this field.    */
specifier|public
specifier|static
name|Object
name|readPrimitiveField
parameter_list|(
name|CodedInputStream
name|input
parameter_list|,
specifier|final
name|WireFormat
operator|.
name|FieldType
name|type
parameter_list|,
name|boolean
name|checkUtf8
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|checkUtf8
condition|)
block|{
return|return
name|WireFormat
operator|.
name|readPrimitiveField
argument_list|(
name|input
argument_list|,
name|type
argument_list|,
name|WireFormat
operator|.
name|Utf8Validation
operator|.
name|STRICT
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|WireFormat
operator|.
name|readPrimitiveField
argument_list|(
name|input
argument_list|,
name|type
argument_list|,
name|WireFormat
operator|.
name|Utf8Validation
operator|.
name|LOOSE
argument_list|)
return|;
block|}
block|}
comment|/** See {@link Message#writeTo(CodedOutputStream)}. */
specifier|public
name|void
name|writeTo
parameter_list|(
specifier|final
name|CodedOutputStream
name|output
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|getNumArrayEntries
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|FieldDescriptorType
argument_list|,
name|Object
argument_list|>
name|entry
init|=
name|fields
operator|.
name|getArrayEntryAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|writeField
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|FieldDescriptorType
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|fields
operator|.
name|getOverflowEntries
argument_list|()
control|)
block|{
name|writeField
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Like {@link #writeTo} but uses MessageSet wire format.    */
specifier|public
name|void
name|writeMessageSetTo
parameter_list|(
specifier|final
name|CodedOutputStream
name|output
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|getNumArrayEntries
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|writeMessageSetTo
argument_list|(
name|fields
operator|.
name|getArrayEntryAt
argument_list|(
name|i
argument_list|)
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|FieldDescriptorType
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|fields
operator|.
name|getOverflowEntries
argument_list|()
control|)
block|{
name|writeMessageSetTo
argument_list|(
name|entry
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|writeMessageSetTo
parameter_list|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|FieldDescriptorType
argument_list|,
name|Object
argument_list|>
name|entry
parameter_list|,
specifier|final
name|CodedOutputStream
name|output
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|FieldDescriptorType
name|descriptor
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|descriptor
operator|.
name|getLiteJavaType
argument_list|()
operator|==
name|WireFormat
operator|.
name|JavaType
operator|.
name|MESSAGE
operator|&&
operator|!
name|descriptor
operator|.
name|isRepeated
argument_list|()
operator|&&
operator|!
name|descriptor
operator|.
name|isPacked
argument_list|()
condition|)
block|{
name|Object
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|LazyField
condition|)
block|{
name|value
operator|=
operator|(
operator|(
name|LazyField
operator|)
name|value
operator|)
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
name|output
operator|.
name|writeMessageSetExtension
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getNumber
argument_list|()
argument_list|,
operator|(
name|MessageLite
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeField
argument_list|(
name|descriptor
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Write a single tag-value pair to the stream.    *    * @param output The output stream.    * @param type   The field's type.    * @param number The field's number.    * @param value  Object representing the field's value.  Must be of the exact    *               type which would be returned by    *               {@link Message#getField(Descriptors.FieldDescriptor)} for    *               this field.    */
specifier|static
name|void
name|writeElement
parameter_list|(
specifier|final
name|CodedOutputStream
name|output
parameter_list|,
specifier|final
name|WireFormat
operator|.
name|FieldType
name|type
parameter_list|,
specifier|final
name|int
name|number
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Special case for groups, which need a start and end tag; other fields
comment|// can just use writeTag() and writeFieldNoTag().
if|if
condition|(
name|type
operator|==
name|WireFormat
operator|.
name|FieldType
operator|.
name|GROUP
condition|)
block|{
name|output
operator|.
name|writeGroup
argument_list|(
name|number
argument_list|,
operator|(
name|MessageLite
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output
operator|.
name|writeTag
argument_list|(
name|number
argument_list|,
name|getWireFormatForFieldType
argument_list|(
name|type
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|writeElementNoTag
argument_list|(
name|output
argument_list|,
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Write a field of arbitrary type, without its tag, to the stream.    *    * @param output The output stream.    * @param type The field's type.    * @param value  Object representing the field's value.  Must be of the exact    *               type which would be returned by    *               {@link Message#getField(Descriptors.FieldDescriptor)} for    *               this field.    */
specifier|static
name|void
name|writeElementNoTag
parameter_list|(
specifier|final
name|CodedOutputStream
name|output
parameter_list|,
specifier|final
name|WireFormat
operator|.
name|FieldType
name|type
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
throws|throws
name|IOException
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DOUBLE
case|:
name|output
operator|.
name|writeDoubleNoTag
argument_list|(
operator|(
name|Double
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|output
operator|.
name|writeFloatNoTag
argument_list|(
operator|(
name|Float
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|INT64
case|:
name|output
operator|.
name|writeInt64NoTag
argument_list|(
operator|(
name|Long
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|UINT64
case|:
name|output
operator|.
name|writeUInt64NoTag
argument_list|(
operator|(
name|Long
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|INT32
case|:
name|output
operator|.
name|writeInt32NoTag
argument_list|(
operator|(
name|Integer
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIXED64
case|:
name|output
operator|.
name|writeFixed64NoTag
argument_list|(
operator|(
name|Long
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIXED32
case|:
name|output
operator|.
name|writeFixed32NoTag
argument_list|(
operator|(
name|Integer
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOOL
case|:
name|output
operator|.
name|writeBoolNoTag
argument_list|(
operator|(
name|Boolean
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|GROUP
case|:
name|output
operator|.
name|writeGroupNoTag
argument_list|(
operator|(
name|MessageLite
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|MESSAGE
case|:
name|output
operator|.
name|writeMessageNoTag
argument_list|(
operator|(
name|MessageLite
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING
case|:
if|if
condition|(
name|value
operator|instanceof
name|ByteString
condition|)
block|{
name|output
operator|.
name|writeBytesNoTag
argument_list|(
operator|(
name|ByteString
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output
operator|.
name|writeStringNoTag
argument_list|(
operator|(
name|String
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BYTES
case|:
if|if
condition|(
name|value
operator|instanceof
name|ByteString
condition|)
block|{
name|output
operator|.
name|writeBytesNoTag
argument_list|(
operator|(
name|ByteString
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output
operator|.
name|writeByteArrayNoTag
argument_list|(
operator|(
name|byte
index|[]
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UINT32
case|:
name|output
operator|.
name|writeUInt32NoTag
argument_list|(
operator|(
name|Integer
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|SFIXED32
case|:
name|output
operator|.
name|writeSFixed32NoTag
argument_list|(
operator|(
name|Integer
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|SFIXED64
case|:
name|output
operator|.
name|writeSFixed64NoTag
argument_list|(
operator|(
name|Long
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|SINT32
case|:
name|output
operator|.
name|writeSInt32NoTag
argument_list|(
operator|(
name|Integer
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|SINT64
case|:
name|output
operator|.
name|writeSInt64NoTag
argument_list|(
operator|(
name|Long
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENUM
case|:
if|if
condition|(
name|value
operator|instanceof
name|Internal
operator|.
name|EnumLite
condition|)
block|{
name|output
operator|.
name|writeEnumNoTag
argument_list|(
operator|(
operator|(
name|Internal
operator|.
name|EnumLite
operator|)
name|value
operator|)
operator|.
name|getNumber
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output
operator|.
name|writeEnumNoTag
argument_list|(
operator|(
operator|(
name|Integer
operator|)
name|value
operator|)
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/** Write a single field. */
specifier|public
specifier|static
name|void
name|writeField
parameter_list|(
specifier|final
name|FieldDescriptorLite
argument_list|<
name|?
argument_list|>
name|descriptor
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|,
specifier|final
name|CodedOutputStream
name|output
parameter_list|)
throws|throws
name|IOException
block|{
name|WireFormat
operator|.
name|FieldType
name|type
init|=
name|descriptor
operator|.
name|getLiteType
argument_list|()
decl_stmt|;
name|int
name|number
init|=
name|descriptor
operator|.
name|getNumber
argument_list|()
decl_stmt|;
if|if
condition|(
name|descriptor
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
specifier|final
name|List
argument_list|<
name|?
argument_list|>
name|valueList
init|=
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|value
decl_stmt|;
if|if
condition|(
name|descriptor
operator|.
name|isPacked
argument_list|()
condition|)
block|{
name|output
operator|.
name|writeTag
argument_list|(
name|number
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
argument_list|)
expr_stmt|;
comment|// Compute the total data size so the length can be written.
name|int
name|dataSize
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|final
name|Object
name|element
range|:
name|valueList
control|)
block|{
name|dataSize
operator|+=
name|computeElementSizeNoTag
argument_list|(
name|type
argument_list|,
name|element
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|writeRawVarint32
argument_list|(
name|dataSize
argument_list|)
expr_stmt|;
comment|// Write the data itself, without any tags.
for|for
control|(
specifier|final
name|Object
name|element
range|:
name|valueList
control|)
block|{
name|writeElementNoTag
argument_list|(
name|output
argument_list|,
name|type
argument_list|,
name|element
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
specifier|final
name|Object
name|element
range|:
name|valueList
control|)
block|{
name|writeElement
argument_list|(
name|output
argument_list|,
name|type
argument_list|,
name|number
argument_list|,
name|element
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|value
operator|instanceof
name|LazyField
condition|)
block|{
name|writeElement
argument_list|(
name|output
argument_list|,
name|type
argument_list|,
name|number
argument_list|,
operator|(
operator|(
name|LazyField
operator|)
name|value
operator|)
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeElement
argument_list|(
name|output
argument_list|,
name|type
argument_list|,
name|number
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * See {@link Message#getSerializedSize()}.  It's up to the caller to cache    * the resulting size if desired.    */
specifier|public
name|int
name|getSerializedSize
parameter_list|()
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|getNumArrayEntries
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|FieldDescriptorType
argument_list|,
name|Object
argument_list|>
name|entry
init|=
name|fields
operator|.
name|getArrayEntryAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|size
operator|+=
name|computeFieldSize
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|FieldDescriptorType
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|fields
operator|.
name|getOverflowEntries
argument_list|()
control|)
block|{
name|size
operator|+=
name|computeFieldSize
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
comment|/**    * Like {@link #getSerializedSize} but uses MessageSet wire format.    */
specifier|public
name|int
name|getMessageSetSerializedSize
parameter_list|()
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|getNumArrayEntries
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|+=
name|getMessageSetSerializedSize
argument_list|(
name|fields
operator|.
name|getArrayEntryAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|FieldDescriptorType
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|fields
operator|.
name|getOverflowEntries
argument_list|()
control|)
block|{
name|size
operator|+=
name|getMessageSetSerializedSize
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
specifier|private
name|int
name|getMessageSetSerializedSize
parameter_list|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|FieldDescriptorType
argument_list|,
name|Object
argument_list|>
name|entry
parameter_list|)
block|{
specifier|final
name|FieldDescriptorType
name|descriptor
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Object
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|descriptor
operator|.
name|getLiteJavaType
argument_list|()
operator|==
name|WireFormat
operator|.
name|JavaType
operator|.
name|MESSAGE
operator|&&
operator|!
name|descriptor
operator|.
name|isRepeated
argument_list|()
operator|&&
operator|!
name|descriptor
operator|.
name|isPacked
argument_list|()
condition|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|LazyField
condition|)
block|{
return|return
name|CodedOutputStream
operator|.
name|computeLazyFieldMessageSetExtensionSize
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getNumber
argument_list|()
argument_list|,
operator|(
name|LazyField
operator|)
name|value
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|CodedOutputStream
operator|.
name|computeMessageSetExtensionSize
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getNumber
argument_list|()
argument_list|,
operator|(
name|MessageLite
operator|)
name|value
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
name|computeFieldSize
argument_list|(
name|descriptor
argument_list|,
name|value
argument_list|)
return|;
block|}
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a    * single tag/value pair of arbitrary type.    *    * @param type   The field's type.    * @param number The field's number.    * @param value  Object representing the field's value.  Must be of the exact    *               type which would be returned by    *               {@link Message#getField(Descriptors.FieldDescriptor)} for    *               this field.    */
specifier|static
name|int
name|computeElementSize
parameter_list|(
specifier|final
name|WireFormat
operator|.
name|FieldType
name|type
parameter_list|,
specifier|final
name|int
name|number
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
block|{
name|int
name|tagSize
init|=
name|CodedOutputStream
operator|.
name|computeTagSize
argument_list|(
name|number
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|WireFormat
operator|.
name|FieldType
operator|.
name|GROUP
condition|)
block|{
comment|// Only count the end group tag for proto2 messages as for proto1 the end
comment|// group tag will be counted as a part of getSerializedSize().
name|tagSize
operator|*=
literal|2
expr_stmt|;
block|}
return|return
name|tagSize
operator|+
name|computeElementSizeNoTag
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/**    * Compute the number of bytes that would be needed to encode a    * particular value of arbitrary type, excluding tag.    *    * @param type   The field's type.    * @param value  Object representing the field's value.  Must be of the exact    *               type which would be returned by    *               {@link Message#getField(Descriptors.FieldDescriptor)} for    *               this field.    */
specifier|static
name|int
name|computeElementSizeNoTag
parameter_list|(
specifier|final
name|WireFormat
operator|.
name|FieldType
name|type
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
comment|// Note:  Minor violation of 80-char limit rule here because this would
comment|//   actually be harder to read if we wrapped the lines.
case|case
name|DOUBLE
case|:
return|return
name|CodedOutputStream
operator|.
name|computeDoubleSizeNoTag
argument_list|(
operator|(
name|Double
operator|)
name|value
argument_list|)
return|;
case|case
name|FLOAT
case|:
return|return
name|CodedOutputStream
operator|.
name|computeFloatSizeNoTag
argument_list|(
operator|(
name|Float
operator|)
name|value
argument_list|)
return|;
case|case
name|INT64
case|:
return|return
name|CodedOutputStream
operator|.
name|computeInt64SizeNoTag
argument_list|(
operator|(
name|Long
operator|)
name|value
argument_list|)
return|;
case|case
name|UINT64
case|:
return|return
name|CodedOutputStream
operator|.
name|computeUInt64SizeNoTag
argument_list|(
operator|(
name|Long
operator|)
name|value
argument_list|)
return|;
case|case
name|INT32
case|:
return|return
name|CodedOutputStream
operator|.
name|computeInt32SizeNoTag
argument_list|(
operator|(
name|Integer
operator|)
name|value
argument_list|)
return|;
case|case
name|FIXED64
case|:
return|return
name|CodedOutputStream
operator|.
name|computeFixed64SizeNoTag
argument_list|(
operator|(
name|Long
operator|)
name|value
argument_list|)
return|;
case|case
name|FIXED32
case|:
return|return
name|CodedOutputStream
operator|.
name|computeFixed32SizeNoTag
argument_list|(
operator|(
name|Integer
operator|)
name|value
argument_list|)
return|;
case|case
name|BOOL
case|:
return|return
name|CodedOutputStream
operator|.
name|computeBoolSizeNoTag
argument_list|(
operator|(
name|Boolean
operator|)
name|value
argument_list|)
return|;
case|case
name|GROUP
case|:
return|return
name|CodedOutputStream
operator|.
name|computeGroupSizeNoTag
argument_list|(
operator|(
name|MessageLite
operator|)
name|value
argument_list|)
return|;
case|case
name|BYTES
case|:
if|if
condition|(
name|value
operator|instanceof
name|ByteString
condition|)
block|{
return|return
name|CodedOutputStream
operator|.
name|computeBytesSizeNoTag
argument_list|(
operator|(
name|ByteString
operator|)
name|value
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|CodedOutputStream
operator|.
name|computeByteArraySizeNoTag
argument_list|(
operator|(
name|byte
index|[]
operator|)
name|value
argument_list|)
return|;
block|}
case|case
name|STRING
case|:
if|if
condition|(
name|value
operator|instanceof
name|ByteString
condition|)
block|{
return|return
name|CodedOutputStream
operator|.
name|computeBytesSizeNoTag
argument_list|(
operator|(
name|ByteString
operator|)
name|value
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|CodedOutputStream
operator|.
name|computeStringSizeNoTag
argument_list|(
operator|(
name|String
operator|)
name|value
argument_list|)
return|;
block|}
case|case
name|UINT32
case|:
return|return
name|CodedOutputStream
operator|.
name|computeUInt32SizeNoTag
argument_list|(
operator|(
name|Integer
operator|)
name|value
argument_list|)
return|;
case|case
name|SFIXED32
case|:
return|return
name|CodedOutputStream
operator|.
name|computeSFixed32SizeNoTag
argument_list|(
operator|(
name|Integer
operator|)
name|value
argument_list|)
return|;
case|case
name|SFIXED64
case|:
return|return
name|CodedOutputStream
operator|.
name|computeSFixed64SizeNoTag
argument_list|(
operator|(
name|Long
operator|)
name|value
argument_list|)
return|;
case|case
name|SINT32
case|:
return|return
name|CodedOutputStream
operator|.
name|computeSInt32SizeNoTag
argument_list|(
operator|(
name|Integer
operator|)
name|value
argument_list|)
return|;
case|case
name|SINT64
case|:
return|return
name|CodedOutputStream
operator|.
name|computeSInt64SizeNoTag
argument_list|(
operator|(
name|Long
operator|)
name|value
argument_list|)
return|;
case|case
name|MESSAGE
case|:
if|if
condition|(
name|value
operator|instanceof
name|LazyField
condition|)
block|{
return|return
name|CodedOutputStream
operator|.
name|computeLazyFieldSizeNoTag
argument_list|(
operator|(
name|LazyField
operator|)
name|value
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|CodedOutputStream
operator|.
name|computeMessageSizeNoTag
argument_list|(
operator|(
name|MessageLite
operator|)
name|value
argument_list|)
return|;
block|}
case|case
name|ENUM
case|:
if|if
condition|(
name|value
operator|instanceof
name|Internal
operator|.
name|EnumLite
condition|)
block|{
return|return
name|CodedOutputStream
operator|.
name|computeEnumSizeNoTag
argument_list|(
operator|(
operator|(
name|Internal
operator|.
name|EnumLite
operator|)
name|value
operator|)
operator|.
name|getNumber
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|CodedOutputStream
operator|.
name|computeEnumSizeNoTag
argument_list|(
operator|(
name|Integer
operator|)
name|value
argument_list|)
return|;
block|}
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"There is no way to get here, but the compiler thinks otherwise."
argument_list|)
throw|;
block|}
comment|/**    * Compute the number of bytes needed to encode a particular field.    */
specifier|public
specifier|static
name|int
name|computeFieldSize
parameter_list|(
specifier|final
name|FieldDescriptorLite
argument_list|<
name|?
argument_list|>
name|descriptor
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
block|{
name|WireFormat
operator|.
name|FieldType
name|type
init|=
name|descriptor
operator|.
name|getLiteType
argument_list|()
decl_stmt|;
name|int
name|number
init|=
name|descriptor
operator|.
name|getNumber
argument_list|()
decl_stmt|;
if|if
condition|(
name|descriptor
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
if|if
condition|(
name|descriptor
operator|.
name|isPacked
argument_list|()
condition|)
block|{
name|int
name|dataSize
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|final
name|Object
name|element
range|:
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|value
control|)
block|{
name|dataSize
operator|+=
name|computeElementSizeNoTag
argument_list|(
name|type
argument_list|,
name|element
argument_list|)
expr_stmt|;
block|}
return|return
name|dataSize
operator|+
name|CodedOutputStream
operator|.
name|computeTagSize
argument_list|(
name|number
argument_list|)
operator|+
name|CodedOutputStream
operator|.
name|computeRawVarint32Size
argument_list|(
name|dataSize
argument_list|)
return|;
block|}
else|else
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|final
name|Object
name|element
range|:
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|value
control|)
block|{
name|size
operator|+=
name|computeElementSize
argument_list|(
name|type
argument_list|,
name|number
argument_list|,
name|element
argument_list|)
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
block|}
else|else
block|{
return|return
name|computeElementSize
argument_list|(
name|type
argument_list|,
name|number
argument_list|,
name|value
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

