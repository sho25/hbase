begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|// Protocol Buffers - Google's data interchange format
end_comment

begin_comment
comment|// Copyright 2008 Google Inc.  All rights reserved.
end_comment

begin_comment
comment|// https://developers.google.com/protocol-buffers/
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Redistribution and use in source and binary forms, with or without
end_comment

begin_comment
comment|// modification, are permitted provided that the following conditions are
end_comment

begin_comment
comment|// met:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//     * Redistributions of source code must retain the above copyright
end_comment

begin_comment
comment|// notice, this list of conditions and the following disclaimer.
end_comment

begin_comment
comment|//     * Redistributions in binary form must reproduce the above
end_comment

begin_comment
comment|// copyright notice, this list of conditions and the following disclaimer
end_comment

begin_comment
comment|// in the documentation and/or other materials provided with the
end_comment

begin_comment
comment|// distribution.
end_comment

begin_comment
comment|//     * Neither the name of Google Inc. nor the names of its
end_comment

begin_comment
comment|// contributors may be used to endorse or promote products derived from
end_comment

begin_comment
comment|// this software without specific prior written permission.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
end_comment

begin_comment
comment|// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
end_comment

begin_comment
comment|// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
end_comment

begin_comment
comment|// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
end_comment

begin_comment
comment|// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
end_comment

begin_comment
comment|// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
end_comment

begin_comment
comment|// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
end_comment

begin_comment
comment|// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
end_comment

begin_comment
comment|// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Descriptors
operator|.
name|Descriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Descriptors
operator|.
name|EnumDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Descriptors
operator|.
name|EnumValueDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Descriptors
operator|.
name|FieldDescriptor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|CharBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_comment
comment|/**  * Provide text parsing and formatting support for proto2 instances.  * The implementation largely follows google/protobuf/text_format.cc.  *  * @author wenboz@google.com Wenbo Zhu  * @author kenton@google.com Kenton Varda  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|TextFormat
block|{
specifier|private
name|TextFormat
parameter_list|()
block|{}
specifier|private
specifier|static
specifier|final
name|Logger
name|logger
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|TextFormat
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Printer
name|DEFAULT_PRINTER
init|=
operator|new
name|Printer
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Printer
name|SINGLE_LINE_PRINTER
init|=
operator|(
operator|new
name|Printer
argument_list|()
operator|)
operator|.
name|setSingleLineMode
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Printer
name|UNICODE_PRINTER
init|=
operator|(
operator|new
name|Printer
argument_list|()
operator|)
operator|.
name|setEscapeNonAscii
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|/**    * Outputs a textual representation of the Protocol Message supplied into    * the parameter output. (This representation is the new version of the    * classic "ProtocolPrinter" output from the original Protocol Buffer system)    */
specifier|public
specifier|static
name|void
name|print
parameter_list|(
specifier|final
name|MessageOrBuilder
name|message
parameter_list|,
specifier|final
name|Appendable
name|output
parameter_list|)
throws|throws
name|IOException
block|{
name|DEFAULT_PRINTER
operator|.
name|print
argument_list|(
name|message
argument_list|,
operator|new
name|TextGenerator
argument_list|(
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Outputs a textual representation of {@code fields} to {@code output}. */
specifier|public
specifier|static
name|void
name|print
parameter_list|(
specifier|final
name|UnknownFieldSet
name|fields
parameter_list|,
specifier|final
name|Appendable
name|output
parameter_list|)
throws|throws
name|IOException
block|{
name|DEFAULT_PRINTER
operator|.
name|printUnknownFields
argument_list|(
name|fields
argument_list|,
operator|new
name|TextGenerator
argument_list|(
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Same as {@code print()}, except that non-ASCII characters are not    * escaped.    */
specifier|public
specifier|static
name|void
name|printUnicode
parameter_list|(
specifier|final
name|MessageOrBuilder
name|message
parameter_list|,
specifier|final
name|Appendable
name|output
parameter_list|)
throws|throws
name|IOException
block|{
name|UNICODE_PRINTER
operator|.
name|print
argument_list|(
name|message
argument_list|,
operator|new
name|TextGenerator
argument_list|(
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Same as {@code print()}, except that non-ASCII characters are not    * escaped.    */
specifier|public
specifier|static
name|void
name|printUnicode
parameter_list|(
specifier|final
name|UnknownFieldSet
name|fields
parameter_list|,
specifier|final
name|Appendable
name|output
parameter_list|)
throws|throws
name|IOException
block|{
name|UNICODE_PRINTER
operator|.
name|printUnknownFields
argument_list|(
name|fields
argument_list|,
operator|new
name|TextGenerator
argument_list|(
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Generates a human readable form of this message, useful for debugging and    * other purposes, with no newline characters.    */
specifier|public
specifier|static
name|String
name|shortDebugString
parameter_list|(
specifier|final
name|MessageOrBuilder
name|message
parameter_list|)
block|{
try|try
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|SINGLE_LINE_PRINTER
operator|.
name|print
argument_list|(
name|message
argument_list|,
operator|new
name|TextGenerator
argument_list|(
name|sb
argument_list|)
argument_list|)
expr_stmt|;
comment|// Single line mode currently might have an extra space at the end.
return|return
name|sb
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Generates a human readable form of the field, useful for debugging    * and other purposes, with no newline characters.    */
specifier|public
specifier|static
name|String
name|shortDebugString
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
block|{
try|try
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|SINGLE_LINE_PRINTER
operator|.
name|printField
argument_list|(
name|field
argument_list|,
name|value
argument_list|,
operator|new
name|TextGenerator
argument_list|(
name|sb
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Generates a human readable form of the unknown fields, useful for debugging    * and other purposes, with no newline characters.    */
specifier|public
specifier|static
name|String
name|shortDebugString
parameter_list|(
specifier|final
name|UnknownFieldSet
name|fields
parameter_list|)
block|{
try|try
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|SINGLE_LINE_PRINTER
operator|.
name|printUnknownFields
argument_list|(
name|fields
argument_list|,
operator|new
name|TextGenerator
argument_list|(
name|sb
argument_list|)
argument_list|)
expr_stmt|;
comment|// Single line mode currently might have an extra space at the end.
return|return
name|sb
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Like {@code print()}, but writes directly to a {@code String} and    * returns it.    */
specifier|public
specifier|static
name|String
name|printToString
parameter_list|(
specifier|final
name|MessageOrBuilder
name|message
parameter_list|)
block|{
try|try
block|{
specifier|final
name|StringBuilder
name|text
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|print
argument_list|(
name|message
argument_list|,
name|text
argument_list|)
expr_stmt|;
return|return
name|text
operator|.
name|toString
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Like {@code print()}, but writes directly to a {@code String} and    * returns it.    */
specifier|public
specifier|static
name|String
name|printToString
parameter_list|(
specifier|final
name|UnknownFieldSet
name|fields
parameter_list|)
block|{
try|try
block|{
specifier|final
name|StringBuilder
name|text
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|print
argument_list|(
name|fields
argument_list|,
name|text
argument_list|)
expr_stmt|;
return|return
name|text
operator|.
name|toString
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Same as {@code printToString()}, except that non-ASCII characters    * in string type fields are not escaped in backslash+octals.    */
specifier|public
specifier|static
name|String
name|printToUnicodeString
parameter_list|(
specifier|final
name|MessageOrBuilder
name|message
parameter_list|)
block|{
try|try
block|{
specifier|final
name|StringBuilder
name|text
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|UNICODE_PRINTER
operator|.
name|print
argument_list|(
name|message
argument_list|,
operator|new
name|TextGenerator
argument_list|(
name|text
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|text
operator|.
name|toString
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Same as {@code printToString()}, except that non-ASCII characters    * in string type fields are not escaped in backslash+octals.    */
specifier|public
specifier|static
name|String
name|printToUnicodeString
parameter_list|(
specifier|final
name|UnknownFieldSet
name|fields
parameter_list|)
block|{
try|try
block|{
specifier|final
name|StringBuilder
name|text
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|UNICODE_PRINTER
operator|.
name|printUnknownFields
argument_list|(
name|fields
argument_list|,
operator|new
name|TextGenerator
argument_list|(
name|text
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|text
operator|.
name|toString
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|public
specifier|static
name|void
name|printField
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|,
specifier|final
name|Appendable
name|output
parameter_list|)
throws|throws
name|IOException
block|{
name|DEFAULT_PRINTER
operator|.
name|printField
argument_list|(
name|field
argument_list|,
name|value
argument_list|,
operator|new
name|TextGenerator
argument_list|(
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|String
name|printFieldToString
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
block|{
try|try
block|{
specifier|final
name|StringBuilder
name|text
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|printField
argument_list|(
name|field
argument_list|,
name|value
argument_list|,
name|text
argument_list|)
expr_stmt|;
return|return
name|text
operator|.
name|toString
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Outputs a textual representation of the value of given field value.    *    * @param field the descriptor of the field    * @param value the value of the field    * @param output the output to which to append the formatted value    * @throws ClassCastException if the value is not appropriate for the    *     given field descriptor    * @throws IOException if there is an exception writing to the output    */
specifier|public
specifier|static
name|void
name|printFieldValue
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|,
specifier|final
name|Appendable
name|output
parameter_list|)
throws|throws
name|IOException
block|{
name|DEFAULT_PRINTER
operator|.
name|printFieldValue
argument_list|(
name|field
argument_list|,
name|value
argument_list|,
operator|new
name|TextGenerator
argument_list|(
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Outputs a textual representation of the value of an unknown field.    *    * @param tag the field's tag number    * @param value the value of the field    * @param output the output to which to append the formatted value    * @throws ClassCastException if the value is not appropriate for the    *     given field descriptor    * @throws IOException if there is an exception writing to the output    */
specifier|public
specifier|static
name|void
name|printUnknownFieldValue
parameter_list|(
specifier|final
name|int
name|tag
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|,
specifier|final
name|Appendable
name|output
parameter_list|)
throws|throws
name|IOException
block|{
name|printUnknownFieldValue
argument_list|(
name|tag
argument_list|,
name|value
argument_list|,
operator|new
name|TextGenerator
argument_list|(
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|printUnknownFieldValue
parameter_list|(
specifier|final
name|int
name|tag
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|,
specifier|final
name|TextGenerator
name|generator
parameter_list|)
throws|throws
name|IOException
block|{
switch|switch
condition|(
name|WireFormat
operator|.
name|getTagWireType
argument_list|(
name|tag
argument_list|)
condition|)
block|{
case|case
name|WireFormat
operator|.
name|WIRETYPE_VARINT
case|:
name|generator
operator|.
name|print
argument_list|(
name|unsignedToString
argument_list|(
operator|(
name|Long
operator|)
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|WireFormat
operator|.
name|WIRETYPE_FIXED32
case|:
name|generator
operator|.
name|print
argument_list|(
name|String
operator|.
name|format
argument_list|(
operator|(
name|Locale
operator|)
literal|null
argument_list|,
literal|"0x%08x"
argument_list|,
operator|(
name|Integer
operator|)
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|WireFormat
operator|.
name|WIRETYPE_FIXED64
case|:
name|generator
operator|.
name|print
argument_list|(
name|String
operator|.
name|format
argument_list|(
operator|(
name|Locale
operator|)
literal|null
argument_list|,
literal|"0x%016x"
argument_list|,
operator|(
name|Long
operator|)
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
case|:
name|generator
operator|.
name|print
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
name|generator
operator|.
name|print
argument_list|(
name|escapeBytes
argument_list|(
operator|(
name|ByteString
operator|)
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|generator
operator|.
name|print
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
break|break;
case|case
name|WireFormat
operator|.
name|WIRETYPE_START_GROUP
case|:
name|DEFAULT_PRINTER
operator|.
name|printUnknownFields
argument_list|(
operator|(
name|UnknownFieldSet
operator|)
name|value
argument_list|,
name|generator
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Bad tag: "
operator|+
name|tag
argument_list|)
throw|;
block|}
block|}
comment|/** Helper class for converting protobufs to text. */
specifier|private
specifier|static
specifier|final
class|class
name|Printer
block|{
comment|/** Whether to omit newlines from the output. */
name|boolean
name|singleLineMode
init|=
literal|false
decl_stmt|;
comment|/** Whether to escape non ASCII characters with backslash and octal. */
name|boolean
name|escapeNonAscii
init|=
literal|true
decl_stmt|;
specifier|private
name|Printer
parameter_list|()
block|{}
comment|/** Setter of singleLineMode */
specifier|private
name|Printer
name|setSingleLineMode
parameter_list|(
name|boolean
name|singleLineMode
parameter_list|)
block|{
name|this
operator|.
name|singleLineMode
operator|=
name|singleLineMode
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Setter of escapeNonAscii */
specifier|private
name|Printer
name|setEscapeNonAscii
parameter_list|(
name|boolean
name|escapeNonAscii
parameter_list|)
block|{
name|this
operator|.
name|escapeNonAscii
operator|=
name|escapeNonAscii
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|private
name|void
name|print
parameter_list|(
specifier|final
name|MessageOrBuilder
name|message
parameter_list|,
specifier|final
name|TextGenerator
name|generator
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|FieldDescriptor
argument_list|,
name|Object
argument_list|>
name|field
range|:
name|message
operator|.
name|getAllFields
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|printField
argument_list|(
name|field
operator|.
name|getKey
argument_list|()
argument_list|,
name|field
operator|.
name|getValue
argument_list|()
argument_list|,
name|generator
argument_list|)
expr_stmt|;
block|}
name|printUnknownFields
argument_list|(
name|message
operator|.
name|getUnknownFields
argument_list|()
argument_list|,
name|generator
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|printField
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|,
specifier|final
name|TextGenerator
name|generator
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|field
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
comment|// Repeated field.  Print each element.
for|for
control|(
name|Object
name|element
range|:
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|value
control|)
block|{
name|printSingleField
argument_list|(
name|field
argument_list|,
name|element
argument_list|,
name|generator
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printSingleField
argument_list|(
name|field
argument_list|,
name|value
argument_list|,
name|generator
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|printSingleField
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|,
specifier|final
name|TextGenerator
name|generator
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|field
operator|.
name|isExtension
argument_list|()
condition|)
block|{
name|generator
operator|.
name|print
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
comment|// We special-case MessageSet elements for compatibility with proto1.
if|if
condition|(
name|field
operator|.
name|getContainingType
argument_list|()
operator|.
name|getOptions
argument_list|()
operator|.
name|getMessageSetWireFormat
argument_list|()
operator|&&
operator|(
name|field
operator|.
name|getType
argument_list|()
operator|==
name|FieldDescriptor
operator|.
name|Type
operator|.
name|MESSAGE
operator|)
operator|&&
operator|(
name|field
operator|.
name|isOptional
argument_list|()
operator|)
comment|// object equality
operator|&&
operator|(
name|field
operator|.
name|getExtensionScope
argument_list|()
operator|==
name|field
operator|.
name|getMessageType
argument_list|()
operator|)
condition|)
block|{
name|generator
operator|.
name|print
argument_list|(
name|field
operator|.
name|getMessageType
argument_list|()
operator|.
name|getFullName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|generator
operator|.
name|print
argument_list|(
name|field
operator|.
name|getFullName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|generator
operator|.
name|print
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|field
operator|.
name|getType
argument_list|()
operator|==
name|FieldDescriptor
operator|.
name|Type
operator|.
name|GROUP
condition|)
block|{
comment|// Groups must be serialized with their original capitalization.
name|generator
operator|.
name|print
argument_list|(
name|field
operator|.
name|getMessageType
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|generator
operator|.
name|print
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|field
operator|.
name|getJavaType
argument_list|()
operator|==
name|FieldDescriptor
operator|.
name|JavaType
operator|.
name|MESSAGE
condition|)
block|{
if|if
condition|(
name|singleLineMode
condition|)
block|{
name|generator
operator|.
name|print
argument_list|(
literal|" { "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|generator
operator|.
name|print
argument_list|(
literal|" {\n"
argument_list|)
expr_stmt|;
name|generator
operator|.
name|indent
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|generator
operator|.
name|print
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
block|}
name|printFieldValue
argument_list|(
name|field
argument_list|,
name|value
argument_list|,
name|generator
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|.
name|getJavaType
argument_list|()
operator|==
name|FieldDescriptor
operator|.
name|JavaType
operator|.
name|MESSAGE
condition|)
block|{
if|if
condition|(
name|singleLineMode
condition|)
block|{
name|generator
operator|.
name|print
argument_list|(
literal|"} "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|generator
operator|.
name|outdent
argument_list|()
expr_stmt|;
name|generator
operator|.
name|print
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|singleLineMode
condition|)
block|{
name|generator
operator|.
name|print
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|generator
operator|.
name|print
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|printFieldValue
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|,
specifier|final
name|TextGenerator
name|generator
parameter_list|)
throws|throws
name|IOException
block|{
switch|switch
condition|(
name|field
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|INT32
case|:
case|case
name|SINT32
case|:
case|case
name|SFIXED32
case|:
name|generator
operator|.
name|print
argument_list|(
operator|(
operator|(
name|Integer
operator|)
name|value
operator|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|INT64
case|:
case|case
name|SINT64
case|:
case|case
name|SFIXED64
case|:
name|generator
operator|.
name|print
argument_list|(
operator|(
operator|(
name|Long
operator|)
name|value
operator|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOOL
case|:
name|generator
operator|.
name|print
argument_list|(
operator|(
operator|(
name|Boolean
operator|)
name|value
operator|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|generator
operator|.
name|print
argument_list|(
operator|(
operator|(
name|Float
operator|)
name|value
operator|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
name|generator
operator|.
name|print
argument_list|(
operator|(
operator|(
name|Double
operator|)
name|value
operator|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|UINT32
case|:
case|case
name|FIXED32
case|:
name|generator
operator|.
name|print
argument_list|(
name|unsignedToString
argument_list|(
operator|(
name|Integer
operator|)
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|UINT64
case|:
case|case
name|FIXED64
case|:
name|generator
operator|.
name|print
argument_list|(
name|unsignedToString
argument_list|(
operator|(
name|Long
operator|)
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|generator
operator|.
name|print
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
name|generator
operator|.
name|print
argument_list|(
name|escapeNonAscii
condition|?
name|TextFormatEscaper
operator|.
name|escapeText
argument_list|(
operator|(
name|String
operator|)
name|value
argument_list|)
else|:
name|escapeDoubleQuotesAndBackslashes
argument_list|(
operator|(
name|String
operator|)
name|value
argument_list|)
operator|.
name|replace
argument_list|(
literal|"\n"
argument_list|,
literal|"\\n"
argument_list|)
argument_list|)
expr_stmt|;
name|generator
operator|.
name|print
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
break|break;
case|case
name|BYTES
case|:
name|generator
operator|.
name|print
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|ByteString
condition|)
block|{
name|generator
operator|.
name|print
argument_list|(
name|escapeBytes
argument_list|(
operator|(
name|ByteString
operator|)
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|generator
operator|.
name|print
argument_list|(
name|escapeBytes
argument_list|(
operator|(
name|byte
index|[]
operator|)
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|generator
operator|.
name|print
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENUM
case|:
name|generator
operator|.
name|print
argument_list|(
operator|(
operator|(
name|EnumValueDescriptor
operator|)
name|value
operator|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|MESSAGE
case|:
case|case
name|GROUP
case|:
name|print
argument_list|(
operator|(
name|Message
operator|)
name|value
argument_list|,
name|generator
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
specifier|private
name|void
name|printUnknownFields
parameter_list|(
specifier|final
name|UnknownFieldSet
name|unknownFields
parameter_list|,
specifier|final
name|TextGenerator
name|generator
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|UnknownFieldSet
operator|.
name|Field
argument_list|>
name|entry
range|:
name|unknownFields
operator|.
name|asMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|int
name|number
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
specifier|final
name|UnknownFieldSet
operator|.
name|Field
name|field
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|printUnknownField
argument_list|(
name|number
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_VARINT
argument_list|,
name|field
operator|.
name|getVarintList
argument_list|()
argument_list|,
name|generator
argument_list|)
expr_stmt|;
name|printUnknownField
argument_list|(
name|number
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_FIXED32
argument_list|,
name|field
operator|.
name|getFixed32List
argument_list|()
argument_list|,
name|generator
argument_list|)
expr_stmt|;
name|printUnknownField
argument_list|(
name|number
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_FIXED64
argument_list|,
name|field
operator|.
name|getFixed64List
argument_list|()
argument_list|,
name|generator
argument_list|)
expr_stmt|;
name|printUnknownField
argument_list|(
name|number
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
argument_list|,
name|field
operator|.
name|getLengthDelimitedList
argument_list|()
argument_list|,
name|generator
argument_list|)
expr_stmt|;
for|for
control|(
specifier|final
name|UnknownFieldSet
name|value
range|:
name|field
operator|.
name|getGroupList
argument_list|()
control|)
block|{
name|generator
operator|.
name|print
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|singleLineMode
condition|)
block|{
name|generator
operator|.
name|print
argument_list|(
literal|" { "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|generator
operator|.
name|print
argument_list|(
literal|" {\n"
argument_list|)
expr_stmt|;
name|generator
operator|.
name|indent
argument_list|()
expr_stmt|;
block|}
name|printUnknownFields
argument_list|(
name|value
argument_list|,
name|generator
argument_list|)
expr_stmt|;
if|if
condition|(
name|singleLineMode
condition|)
block|{
name|generator
operator|.
name|print
argument_list|(
literal|"} "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|generator
operator|.
name|outdent
argument_list|()
expr_stmt|;
name|generator
operator|.
name|print
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
name|void
name|printUnknownField
parameter_list|(
specifier|final
name|int
name|number
parameter_list|,
specifier|final
name|int
name|wireType
parameter_list|,
specifier|final
name|List
argument_list|<
name|?
argument_list|>
name|values
parameter_list|,
specifier|final
name|TextGenerator
name|generator
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
specifier|final
name|Object
name|value
range|:
name|values
control|)
block|{
name|generator
operator|.
name|print
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|number
argument_list|)
argument_list|)
expr_stmt|;
name|generator
operator|.
name|print
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
name|printUnknownFieldValue
argument_list|(
name|wireType
argument_list|,
name|value
argument_list|,
name|generator
argument_list|)
expr_stmt|;
name|generator
operator|.
name|print
argument_list|(
name|singleLineMode
condition|?
literal|" "
else|:
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Convert an unsigned 32-bit integer to a string. */
specifier|public
specifier|static
name|String
name|unsignedToString
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|>=
literal|0
condition|)
block|{
return|return
name|Integer
operator|.
name|toString
argument_list|(
name|value
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Long
operator|.
name|toString
argument_list|(
name|value
operator|&
literal|0x00000000FFFFFFFFL
argument_list|)
return|;
block|}
block|}
comment|/** Convert an unsigned 64-bit integer to a string. */
specifier|public
specifier|static
name|String
name|unsignedToString
parameter_list|(
specifier|final
name|long
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|>=
literal|0
condition|)
block|{
return|return
name|Long
operator|.
name|toString
argument_list|(
name|value
argument_list|)
return|;
block|}
else|else
block|{
comment|// Pull off the most-significant bit so that BigInteger doesn't think
comment|// the number is negative, then set it again using setBit().
return|return
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|value
operator|&
literal|0x7FFFFFFFFFFFFFFFL
argument_list|)
operator|.
name|setBit
argument_list|(
literal|63
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * An inner class for writing text to the output stream.    */
specifier|private
specifier|static
specifier|final
class|class
name|TextGenerator
block|{
specifier|private
specifier|final
name|Appendable
name|output
decl_stmt|;
specifier|private
specifier|final
name|StringBuilder
name|indent
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|atStartOfLine
init|=
literal|true
decl_stmt|;
specifier|private
name|TextGenerator
parameter_list|(
specifier|final
name|Appendable
name|output
parameter_list|)
block|{
name|this
operator|.
name|output
operator|=
name|output
expr_stmt|;
block|}
comment|/**      * Indent text by two spaces.  After calling Indent(), two spaces will be      * inserted at the beginning of each line of text.  Indent() may be called      * multiple times to produce deeper indents.      */
specifier|public
name|void
name|indent
parameter_list|()
block|{
name|indent
operator|.
name|append
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
block|}
comment|/**      * Reduces the current indent level by two spaces, or crashes if the indent      * level is zero.      */
specifier|public
name|void
name|outdent
parameter_list|()
block|{
specifier|final
name|int
name|length
init|=
name|indent
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|" Outdent() without matching Indent()."
argument_list|)
throw|;
block|}
name|indent
operator|.
name|delete
argument_list|(
name|length
operator|-
literal|2
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**      * Print text to the output stream.      */
specifier|public
name|void
name|print
parameter_list|(
specifier|final
name|CharSequence
name|text
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|size
init|=
name|text
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|text
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|'\n'
condition|)
block|{
name|write
argument_list|(
name|text
operator|.
name|subSequence
argument_list|(
name|pos
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|atStartOfLine
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|write
argument_list|(
name|text
operator|.
name|subSequence
argument_list|(
name|pos
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|write
parameter_list|(
specifier|final
name|CharSequence
name|data
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|data
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|atStartOfLine
condition|)
block|{
name|atStartOfLine
operator|=
literal|false
expr_stmt|;
name|output
operator|.
name|append
argument_list|(
name|indent
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|append
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
block|}
comment|// =================================================================
comment|// Parsing
comment|/**    * Represents a stream of tokens parsed from a {@code String}.    *    *<p>The Java standard library provides many classes that you might think    * would be useful for implementing this, but aren't.  For example:    *    *<ul>    *<li>{@code java.io.StreamTokenizer}:  This almost does what we want -- or,    *   at least, something that would get us close to what we want -- except    *   for one fatal flaw:  It automatically un-escapes strings using Java    *   escape sequences, which do not include all the escape sequences we    *   need to support (e.g. '\x').    *<li>{@code java.util.Scanner}:  This seems like a great way at least to    *   parse regular expressions out of a stream (so we wouldn't have to load    *   the entire input into a single string before parsing).  Sadly,    *   {@code Scanner} requires that tokens be delimited with some delimiter.    *   Thus, although the text "foo:" should parse to two tokens ("foo" and    *   ":"), {@code Scanner} would recognize it only as a single token.    *   Furthermore, {@code Scanner} provides no way to inspect the contents    *   of delimiters, making it impossible to keep track of line and column    *   numbers.    *</ul>    *    *<p>Luckily, Java's regular expression support does manage to be useful to    * us.  (Barely:  We need {@code Matcher.usePattern()}, which is new in    * Java 1.5.)  So, we can use that, at least.  Unfortunately, this implies    * that we need to have the entire input in one contiguous string.    */
specifier|private
specifier|static
specifier|final
class|class
name|Tokenizer
block|{
specifier|private
specifier|final
name|CharSequence
name|text
decl_stmt|;
specifier|private
specifier|final
name|Matcher
name|matcher
decl_stmt|;
specifier|private
name|String
name|currentToken
decl_stmt|;
comment|// The character index within this.text at which the current token begins.
specifier|private
name|int
name|pos
init|=
literal|0
decl_stmt|;
comment|// The line and column numbers of the current token.
specifier|private
name|int
name|line
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|column
init|=
literal|0
decl_stmt|;
comment|// The line and column numbers of the previous token (allows throwing
comment|// errors *after* consuming).
specifier|private
name|int
name|previousLine
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|previousColumn
init|=
literal|0
decl_stmt|;
comment|// We use possessive quantifiers (*+ and ++) because otherwise the Java
comment|// regex matcher has stack overflows on large inputs.
specifier|private
specifier|static
specifier|final
name|Pattern
name|WHITESPACE
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"(\\s|(#.*$))++"
argument_list|,
name|Pattern
operator|.
name|MULTILINE
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Pattern
name|TOKEN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"[a-zA-Z_][0-9a-zA-Z_+-]*+|"
operator|+
comment|// an identifier
literal|"[.]?[0-9+-][0-9a-zA-Z_.+-]*+|"
operator|+
comment|// a number
literal|"\"([^\"\n\\\\]|\\\\.)*+(\"|\\\\?$)|"
operator|+
comment|// a double-quoted string
literal|"\'([^\'\n\\\\]|\\\\.)*+(\'|\\\\?$)"
argument_list|,
comment|// a single-quoted string
name|Pattern
operator|.
name|MULTILINE
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Pattern
name|DOUBLE_INFINITY
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"-?inf(inity)?"
argument_list|,
name|Pattern
operator|.
name|CASE_INSENSITIVE
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Pattern
name|FLOAT_INFINITY
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"-?inf(inity)?f?"
argument_list|,
name|Pattern
operator|.
name|CASE_INSENSITIVE
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Pattern
name|FLOAT_NAN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"nanf?"
argument_list|,
name|Pattern
operator|.
name|CASE_INSENSITIVE
argument_list|)
decl_stmt|;
comment|/** Construct a tokenizer that parses tokens from the given text. */
specifier|private
name|Tokenizer
parameter_list|(
specifier|final
name|CharSequence
name|text
parameter_list|)
block|{
name|this
operator|.
name|text
operator|=
name|text
expr_stmt|;
name|this
operator|.
name|matcher
operator|=
name|WHITESPACE
operator|.
name|matcher
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|skipWhitespace
argument_list|()
expr_stmt|;
name|nextToken
argument_list|()
expr_stmt|;
block|}
name|int
name|getPreviousLine
parameter_list|()
block|{
return|return
name|previousLine
return|;
block|}
name|int
name|getPreviousColumn
parameter_list|()
block|{
return|return
name|previousColumn
return|;
block|}
name|int
name|getLine
parameter_list|()
block|{
return|return
name|line
return|;
block|}
name|int
name|getColumn
parameter_list|()
block|{
return|return
name|column
return|;
block|}
comment|/** Are we at the end of the input? */
specifier|public
name|boolean
name|atEnd
parameter_list|()
block|{
return|return
name|currentToken
operator|.
name|length
argument_list|()
operator|==
literal|0
return|;
block|}
comment|/** Advance to the next token. */
specifier|public
name|void
name|nextToken
parameter_list|()
block|{
name|previousLine
operator|=
name|line
expr_stmt|;
name|previousColumn
operator|=
name|column
expr_stmt|;
comment|// Advance the line counter to the current position.
while|while
condition|(
name|pos
operator|<
name|matcher
operator|.
name|regionStart
argument_list|()
condition|)
block|{
if|if
condition|(
name|text
operator|.
name|charAt
argument_list|(
name|pos
argument_list|)
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|line
expr_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|++
name|column
expr_stmt|;
block|}
operator|++
name|pos
expr_stmt|;
block|}
comment|// Match the next token.
if|if
condition|(
name|matcher
operator|.
name|regionStart
argument_list|()
operator|==
name|matcher
operator|.
name|regionEnd
argument_list|()
condition|)
block|{
comment|// EOF
name|currentToken
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|matcher
operator|.
name|usePattern
argument_list|(
name|TOKEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|matcher
operator|.
name|lookingAt
argument_list|()
condition|)
block|{
name|currentToken
operator|=
name|matcher
operator|.
name|group
argument_list|()
expr_stmt|;
name|matcher
operator|.
name|region
argument_list|(
name|matcher
operator|.
name|end
argument_list|()
argument_list|,
name|matcher
operator|.
name|regionEnd
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Take one character.
name|currentToken
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|text
operator|.
name|charAt
argument_list|(
name|pos
argument_list|)
argument_list|)
expr_stmt|;
name|matcher
operator|.
name|region
argument_list|(
name|pos
operator|+
literal|1
argument_list|,
name|matcher
operator|.
name|regionEnd
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|skipWhitespace
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Skip over any whitespace so that the matcher region starts at the next      * token.      */
specifier|private
name|void
name|skipWhitespace
parameter_list|()
block|{
name|matcher
operator|.
name|usePattern
argument_list|(
name|WHITESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|matcher
operator|.
name|lookingAt
argument_list|()
condition|)
block|{
name|matcher
operator|.
name|region
argument_list|(
name|matcher
operator|.
name|end
argument_list|()
argument_list|,
name|matcher
operator|.
name|regionEnd
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * If the next token exactly matches {@code token}, consume it and return      * {@code true}.  Otherwise, return {@code false} without doing anything.      */
specifier|public
name|boolean
name|tryConsume
parameter_list|(
specifier|final
name|String
name|token
parameter_list|)
block|{
if|if
condition|(
name|currentToken
operator|.
name|equals
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|nextToken
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**      * If the next token exactly matches {@code token}, consume it.  Otherwise,      * throw a {@link ParseException}.      */
specifier|public
name|void
name|consume
parameter_list|(
specifier|final
name|String
name|token
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
operator|!
name|tryConsume
argument_list|(
name|token
argument_list|)
condition|)
block|{
throw|throw
name|parseException
argument_list|(
literal|"Expected \""
operator|+
name|token
operator|+
literal|"\"."
argument_list|)
throw|;
block|}
block|}
comment|/**      * Returns {@code true} if the next token is an integer, but does      * not consume it.      */
specifier|public
name|boolean
name|lookingAtInteger
parameter_list|()
block|{
if|if
condition|(
name|currentToken
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|char
name|c
init|=
name|currentToken
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
return|return
operator|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'+'
return|;
block|}
comment|/**      * Returns {@code true} if the current token's text is equal to that      * specified.      */
specifier|public
name|boolean
name|lookingAt
parameter_list|(
name|String
name|text
parameter_list|)
block|{
return|return
name|currentToken
operator|.
name|equals
argument_list|(
name|text
argument_list|)
return|;
block|}
comment|/**      * If the next token is an identifier, consume it and return its value.      * Otherwise, throw a {@link ParseException}.      */
specifier|public
name|String
name|consumeIdentifier
parameter_list|()
throws|throws
name|ParseException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|currentToken
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|char
name|c
init|=
name|currentToken
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
literal|'a'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'z'
operator|)
operator|||
operator|(
literal|'A'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'_'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'.'
operator|)
condition|)
block|{
comment|// OK
block|}
else|else
block|{
throw|throw
name|parseException
argument_list|(
literal|"Expected identifier. Found '"
operator|+
name|currentToken
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
specifier|final
name|String
name|result
init|=
name|currentToken
decl_stmt|;
name|nextToken
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**      * If the next token is an identifier, consume it and return {@code true}.      * Otherwise, return {@code false} without doing anything.      */
specifier|public
name|boolean
name|tryConsumeIdentifier
parameter_list|()
block|{
try|try
block|{
name|consumeIdentifier
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**      * If the next token is a 32-bit signed integer, consume it and return its      * value.  Otherwise, throw a {@link ParseException}.      */
specifier|public
name|int
name|consumeInt32
parameter_list|()
throws|throws
name|ParseException
block|{
try|try
block|{
specifier|final
name|int
name|result
init|=
name|parseInt32
argument_list|(
name|currentToken
argument_list|)
decl_stmt|;
name|nextToken
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
name|integerParseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * If the next token is a 32-bit unsigned integer, consume it and return its      * value.  Otherwise, throw a {@link ParseException}.      */
specifier|public
name|int
name|consumeUInt32
parameter_list|()
throws|throws
name|ParseException
block|{
try|try
block|{
specifier|final
name|int
name|result
init|=
name|parseUInt32
argument_list|(
name|currentToken
argument_list|)
decl_stmt|;
name|nextToken
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
name|integerParseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * If the next token is a 64-bit signed integer, consume it and return its      * value.  Otherwise, throw a {@link ParseException}.      */
specifier|public
name|long
name|consumeInt64
parameter_list|()
throws|throws
name|ParseException
block|{
try|try
block|{
specifier|final
name|long
name|result
init|=
name|parseInt64
argument_list|(
name|currentToken
argument_list|)
decl_stmt|;
name|nextToken
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
name|integerParseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * If the next token is a 64-bit signed integer, consume it and return      * {@code true}.  Otherwise, return {@code false} without doing anything.      */
specifier|public
name|boolean
name|tryConsumeInt64
parameter_list|()
block|{
try|try
block|{
name|consumeInt64
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**      * If the next token is a 64-bit unsigned integer, consume it and return its      * value.  Otherwise, throw a {@link ParseException}.      */
specifier|public
name|long
name|consumeUInt64
parameter_list|()
throws|throws
name|ParseException
block|{
try|try
block|{
specifier|final
name|long
name|result
init|=
name|parseUInt64
argument_list|(
name|currentToken
argument_list|)
decl_stmt|;
name|nextToken
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
name|integerParseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * If the next token is a 64-bit unsigned integer, consume it and return      * {@code true}.  Otherwise, return {@code false} without doing anything.      */
specifier|public
name|boolean
name|tryConsumeUInt64
parameter_list|()
block|{
try|try
block|{
name|consumeUInt64
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**      * If the next token is a double, consume it and return its value.      * Otherwise, throw a {@link ParseException}.      */
specifier|public
name|double
name|consumeDouble
parameter_list|()
throws|throws
name|ParseException
block|{
comment|// We need to parse infinity and nan separately because
comment|// Double.parseDouble() does not accept "inf", "infinity", or "nan".
if|if
condition|(
name|DOUBLE_INFINITY
operator|.
name|matcher
argument_list|(
name|currentToken
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
specifier|final
name|boolean
name|negative
init|=
name|currentToken
operator|.
name|startsWith
argument_list|(
literal|"-"
argument_list|)
decl_stmt|;
name|nextToken
argument_list|()
expr_stmt|;
return|return
name|negative
condition|?
name|Double
operator|.
name|NEGATIVE_INFINITY
else|:
name|Double
operator|.
name|POSITIVE_INFINITY
return|;
block|}
if|if
condition|(
name|currentToken
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"nan"
argument_list|)
condition|)
block|{
name|nextToken
argument_list|()
expr_stmt|;
return|return
name|Double
operator|.
name|NaN
return|;
block|}
try|try
block|{
specifier|final
name|double
name|result
init|=
name|Double
operator|.
name|parseDouble
argument_list|(
name|currentToken
argument_list|)
decl_stmt|;
name|nextToken
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
name|floatParseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * If the next token is a double, consume it and return {@code true}.      * Otherwise, return {@code false} without doing anything.      */
specifier|public
name|boolean
name|tryConsumeDouble
parameter_list|()
block|{
try|try
block|{
name|consumeDouble
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**      * If the next token is a float, consume it and return its value.      * Otherwise, throw a {@link ParseException}.      */
specifier|public
name|float
name|consumeFloat
parameter_list|()
throws|throws
name|ParseException
block|{
comment|// We need to parse infinity and nan separately because
comment|// Float.parseFloat() does not accept "inf", "infinity", or "nan".
if|if
condition|(
name|FLOAT_INFINITY
operator|.
name|matcher
argument_list|(
name|currentToken
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
specifier|final
name|boolean
name|negative
init|=
name|currentToken
operator|.
name|startsWith
argument_list|(
literal|"-"
argument_list|)
decl_stmt|;
name|nextToken
argument_list|()
expr_stmt|;
return|return
name|negative
condition|?
name|Float
operator|.
name|NEGATIVE_INFINITY
else|:
name|Float
operator|.
name|POSITIVE_INFINITY
return|;
block|}
if|if
condition|(
name|FLOAT_NAN
operator|.
name|matcher
argument_list|(
name|currentToken
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
name|nextToken
argument_list|()
expr_stmt|;
return|return
name|Float
operator|.
name|NaN
return|;
block|}
try|try
block|{
specifier|final
name|float
name|result
init|=
name|Float
operator|.
name|parseFloat
argument_list|(
name|currentToken
argument_list|)
decl_stmt|;
name|nextToken
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
name|floatParseException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * If the next token is a float, consume it and return {@code true}.      * Otherwise, return {@code false} without doing anything.      */
specifier|public
name|boolean
name|tryConsumeFloat
parameter_list|()
block|{
try|try
block|{
name|consumeFloat
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**      * If the next token is a boolean, consume it and return its value.      * Otherwise, throw a {@link ParseException}.      */
specifier|public
name|boolean
name|consumeBoolean
parameter_list|()
throws|throws
name|ParseException
block|{
if|if
condition|(
name|currentToken
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
operator|||
name|currentToken
operator|.
name|equals
argument_list|(
literal|"True"
argument_list|)
operator|||
name|currentToken
operator|.
name|equals
argument_list|(
literal|"t"
argument_list|)
operator|||
name|currentToken
operator|.
name|equals
argument_list|(
literal|"1"
argument_list|)
condition|)
block|{
name|nextToken
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|currentToken
operator|.
name|equals
argument_list|(
literal|"false"
argument_list|)
operator|||
name|currentToken
operator|.
name|equals
argument_list|(
literal|"False"
argument_list|)
operator|||
name|currentToken
operator|.
name|equals
argument_list|(
literal|"f"
argument_list|)
operator|||
name|currentToken
operator|.
name|equals
argument_list|(
literal|"0"
argument_list|)
condition|)
block|{
name|nextToken
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
throw|throw
name|parseException
argument_list|(
literal|"Expected \"true\" or \"false\"."
argument_list|)
throw|;
block|}
block|}
comment|/**      * If the next token is a string, consume it and return its (unescaped)      * value.  Otherwise, throw a {@link ParseException}.      */
specifier|public
name|String
name|consumeString
parameter_list|()
throws|throws
name|ParseException
block|{
return|return
name|consumeByteString
argument_list|()
operator|.
name|toStringUtf8
argument_list|()
return|;
block|}
comment|/**      * If the next token is a string, consume it and return true.  Otherwise,      * return false.      */
specifier|public
name|boolean
name|tryConsumeString
parameter_list|()
block|{
try|try
block|{
name|consumeString
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**      * If the next token is a string, consume it, unescape it as a      * {@link ByteString}, and return it.  Otherwise, throw a      * {@link ParseException}.      */
specifier|public
name|ByteString
name|consumeByteString
parameter_list|()
throws|throws
name|ParseException
block|{
name|List
argument_list|<
name|ByteString
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|ByteString
argument_list|>
argument_list|()
decl_stmt|;
name|consumeByteString
argument_list|(
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
name|currentToken
operator|.
name|startsWith
argument_list|(
literal|"'"
argument_list|)
operator|||
name|currentToken
operator|.
name|startsWith
argument_list|(
literal|"\""
argument_list|)
condition|)
block|{
name|consumeByteString
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|list
argument_list|)
return|;
block|}
comment|/**      * Like {@link #consumeByteString()} but adds each token of the string to      * the given list.  String literals (whether bytes or text) may come in      * multiple adjacent tokens which are automatically concatenated, like in      * C or Python.      */
specifier|private
name|void
name|consumeByteString
parameter_list|(
name|List
argument_list|<
name|ByteString
argument_list|>
name|list
parameter_list|)
throws|throws
name|ParseException
block|{
specifier|final
name|char
name|quote
init|=
name|currentToken
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|?
name|currentToken
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
else|:
literal|'\0'
decl_stmt|;
if|if
condition|(
name|quote
operator|!=
literal|'\"'
operator|&&
name|quote
operator|!=
literal|'\''
condition|)
block|{
throw|throw
name|parseException
argument_list|(
literal|"Expected string."
argument_list|)
throw|;
block|}
if|if
condition|(
name|currentToken
operator|.
name|length
argument_list|()
operator|<
literal|2
operator|||
name|currentToken
operator|.
name|charAt
argument_list|(
name|currentToken
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|!=
name|quote
condition|)
block|{
throw|throw
name|parseException
argument_list|(
literal|"String missing ending quote."
argument_list|)
throw|;
block|}
try|try
block|{
specifier|final
name|String
name|escaped
init|=
name|currentToken
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|currentToken
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|ByteString
name|result
init|=
name|unescapeBytes
argument_list|(
name|escaped
argument_list|)
decl_stmt|;
name|nextToken
argument_list|()
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidEscapeSequenceException
name|e
parameter_list|)
block|{
throw|throw
name|parseException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**      * Returns a {@link ParseException} with the current line and column      * numbers in the description, suitable for throwing.      */
specifier|public
name|ParseException
name|parseException
parameter_list|(
specifier|final
name|String
name|description
parameter_list|)
block|{
comment|// Note:  People generally prefer one-based line and column numbers.
return|return
operator|new
name|ParseException
argument_list|(
name|line
operator|+
literal|1
argument_list|,
name|column
operator|+
literal|1
argument_list|,
name|description
argument_list|)
return|;
block|}
comment|/**      * Returns a {@link ParseException} with the line and column numbers of      * the previous token in the description, suitable for throwing.      */
specifier|public
name|ParseException
name|parseExceptionPreviousToken
parameter_list|(
specifier|final
name|String
name|description
parameter_list|)
block|{
comment|// Note:  People generally prefer one-based line and column numbers.
return|return
operator|new
name|ParseException
argument_list|(
name|previousLine
operator|+
literal|1
argument_list|,
name|previousColumn
operator|+
literal|1
argument_list|,
name|description
argument_list|)
return|;
block|}
comment|/**      * Constructs an appropriate {@link ParseException} for the given      * {@code NumberFormatException} when trying to parse an integer.      */
specifier|private
name|ParseException
name|integerParseException
parameter_list|(
specifier|final
name|NumberFormatException
name|e
parameter_list|)
block|{
return|return
name|parseException
argument_list|(
literal|"Couldn't parse integer: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Constructs an appropriate {@link ParseException} for the given      * {@code NumberFormatException} when trying to parse a float or double.      */
specifier|private
name|ParseException
name|floatParseException
parameter_list|(
specifier|final
name|NumberFormatException
name|e
parameter_list|)
block|{
return|return
name|parseException
argument_list|(
literal|"Couldn't parse number: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns a {@link UnknownFieldParseException} with the line and column      * numbers of the previous token in the description, and the unknown field      * name, suitable for throwing.      */
specifier|public
name|UnknownFieldParseException
name|unknownFieldParseExceptionPreviousToken
parameter_list|(
specifier|final
name|String
name|unknownField
parameter_list|,
specifier|final
name|String
name|description
parameter_list|)
block|{
comment|// Note:  People generally prefer one-based line and column numbers.
return|return
operator|new
name|UnknownFieldParseException
argument_list|(
name|previousLine
operator|+
literal|1
argument_list|,
name|previousColumn
operator|+
literal|1
argument_list|,
name|unknownField
argument_list|,
name|description
argument_list|)
return|;
block|}
block|}
comment|/** Thrown when parsing an invalid text format message. */
specifier|public
specifier|static
class|class
name|ParseException
extends|extends
name|IOException
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|3196188060225107702L
decl_stmt|;
specifier|private
specifier|final
name|int
name|line
decl_stmt|;
specifier|private
specifier|final
name|int
name|column
decl_stmt|;
comment|/** Create a new instance, with -1 as the line and column numbers. */
specifier|public
name|ParseException
parameter_list|(
specifier|final
name|String
name|message
parameter_list|)
block|{
name|this
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
comment|/**      * Create a new instance      *      * @param line the line number where the parse error occurred,      * using 1-offset.      * @param column the column number where the parser error occurred,      * using 1-offset.      */
specifier|public
name|ParseException
parameter_list|(
specifier|final
name|int
name|line
parameter_list|,
specifier|final
name|int
name|column
parameter_list|,
specifier|final
name|String
name|message
parameter_list|)
block|{
name|super
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|line
argument_list|)
operator|+
literal|":"
operator|+
name|column
operator|+
literal|": "
operator|+
name|message
argument_list|)
expr_stmt|;
name|this
operator|.
name|line
operator|=
name|line
expr_stmt|;
name|this
operator|.
name|column
operator|=
name|column
expr_stmt|;
block|}
comment|/**      * Return the line where the parse exception occurred, or -1 when      * none is provided. The value is specified as 1-offset, so the first      * line is line 1.      */
specifier|public
name|int
name|getLine
parameter_list|()
block|{
return|return
name|line
return|;
block|}
comment|/**      * Return the column where the parse exception occurred, or -1 when      * none is provided. The value is specified as 1-offset, so the first      * line is line 1.      */
specifier|public
name|int
name|getColumn
parameter_list|()
block|{
return|return
name|column
return|;
block|}
block|}
comment|/**    * Thrown when encountering an unknown field while parsing    * a text format message.    */
specifier|public
specifier|static
class|class
name|UnknownFieldParseException
extends|extends
name|ParseException
block|{
specifier|private
specifier|final
name|String
name|unknownField
decl_stmt|;
comment|/**      * Create a new instance, with -1 as the line and column numbers, and an      * empty unknown field name.      */
specifier|public
name|UnknownFieldParseException
parameter_list|(
specifier|final
name|String
name|message
parameter_list|)
block|{
name|this
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|""
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
comment|/**      * Create a new instance      *      * @param line the line number where the parse error occurred,      * using 1-offset.      * @param column the column number where the parser error occurred,      * using 1-offset.      * @param unknownField the name of the unknown field found while parsing.      */
specifier|public
name|UnknownFieldParseException
parameter_list|(
specifier|final
name|int
name|line
parameter_list|,
specifier|final
name|int
name|column
parameter_list|,
specifier|final
name|String
name|unknownField
parameter_list|,
specifier|final
name|String
name|message
parameter_list|)
block|{
name|super
argument_list|(
name|line
argument_list|,
name|column
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|this
operator|.
name|unknownField
operator|=
name|unknownField
expr_stmt|;
block|}
comment|/**      * Return the name of the unknown field encountered while parsing the      * protocol buffer string.      */
specifier|public
name|String
name|getUnknownField
parameter_list|()
block|{
return|return
name|unknownField
return|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|Parser
name|PARSER
init|=
name|Parser
operator|.
name|newBuilder
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
comment|/**    * Return a {@link Parser} instance which can parse text-format    * messages. The returned instance is thread-safe.    */
specifier|public
specifier|static
name|Parser
name|getParser
parameter_list|()
block|{
return|return
name|PARSER
return|;
block|}
comment|/**    * Parse a text-format message from {@code input} and merge the contents    * into {@code builder}.    */
specifier|public
specifier|static
name|void
name|merge
parameter_list|(
specifier|final
name|Readable
name|input
parameter_list|,
specifier|final
name|Message
operator|.
name|Builder
name|builder
parameter_list|)
throws|throws
name|IOException
block|{
name|PARSER
operator|.
name|merge
argument_list|(
name|input
argument_list|,
name|builder
argument_list|)
expr_stmt|;
block|}
comment|/**    * Parse a text-format message from {@code input} and merge the contents    * into {@code builder}.    */
specifier|public
specifier|static
name|void
name|merge
parameter_list|(
specifier|final
name|CharSequence
name|input
parameter_list|,
specifier|final
name|Message
operator|.
name|Builder
name|builder
parameter_list|)
throws|throws
name|ParseException
block|{
name|PARSER
operator|.
name|merge
argument_list|(
name|input
argument_list|,
name|builder
argument_list|)
expr_stmt|;
block|}
comment|/**    * Parse a text-format message from {@code input} and merge the contents    * into {@code builder}.  Extensions will be recognized if they are    * registered in {@code extensionRegistry}.    */
specifier|public
specifier|static
name|void
name|merge
parameter_list|(
specifier|final
name|Readable
name|input
parameter_list|,
specifier|final
name|ExtensionRegistry
name|extensionRegistry
parameter_list|,
specifier|final
name|Message
operator|.
name|Builder
name|builder
parameter_list|)
throws|throws
name|IOException
block|{
name|PARSER
operator|.
name|merge
argument_list|(
name|input
argument_list|,
name|extensionRegistry
argument_list|,
name|builder
argument_list|)
expr_stmt|;
block|}
comment|/**    * Parse a text-format message from {@code input} and merge the contents    * into {@code builder}.  Extensions will be recognized if they are    * registered in {@code extensionRegistry}.    */
specifier|public
specifier|static
name|void
name|merge
parameter_list|(
specifier|final
name|CharSequence
name|input
parameter_list|,
specifier|final
name|ExtensionRegistry
name|extensionRegistry
parameter_list|,
specifier|final
name|Message
operator|.
name|Builder
name|builder
parameter_list|)
throws|throws
name|ParseException
block|{
name|PARSER
operator|.
name|merge
argument_list|(
name|input
argument_list|,
name|extensionRegistry
argument_list|,
name|builder
argument_list|)
expr_stmt|;
block|}
comment|/**    * Parser for text-format proto2 instances. This class is thread-safe.    * The implementation largely follows google/protobuf/text_format.cc.    *    *<p>Use {@link TextFormat#getParser()} to obtain the default parser, or    * {@link Builder} to control the parser behavior.    */
specifier|public
specifier|static
class|class
name|Parser
block|{
comment|/**      * Determines if repeated values for non-repeated fields and      * oneofs are permitted. For example, given required/optional field "foo"      * and a oneof containing "baz" and "qux":      *<ul>      *<li>"foo: 1 foo: 2"      *<li>"baz: 1 qux: 2"      *<li>merging "foo: 2" into a proto in which foo is already set, or      *<li>merging "qux: 2" into a proto in which baz is already set.      *</ul>      */
specifier|public
enum|enum
name|SingularOverwritePolicy
block|{
comment|/** The last value is retained. */
name|ALLOW_SINGULAR_OVERWRITES
block|,
comment|/** An error is issued. */
name|FORBID_SINGULAR_OVERWRITES
block|}
specifier|private
specifier|final
name|boolean
name|allowUnknownFields
decl_stmt|;
specifier|private
specifier|final
name|SingularOverwritePolicy
name|singularOverwritePolicy
decl_stmt|;
specifier|private
name|TextFormatParseInfoTree
operator|.
name|Builder
name|parseInfoTreeBuilder
decl_stmt|;
specifier|private
name|Parser
parameter_list|(
name|boolean
name|allowUnknownFields
parameter_list|,
name|SingularOverwritePolicy
name|singularOverwritePolicy
parameter_list|,
name|TextFormatParseInfoTree
operator|.
name|Builder
name|parseInfoTreeBuilder
parameter_list|)
block|{
name|this
operator|.
name|allowUnknownFields
operator|=
name|allowUnknownFields
expr_stmt|;
name|this
operator|.
name|singularOverwritePolicy
operator|=
name|singularOverwritePolicy
expr_stmt|;
name|this
operator|.
name|parseInfoTreeBuilder
operator|=
name|parseInfoTreeBuilder
expr_stmt|;
block|}
comment|/**      * Returns a new instance of {@link Builder}.      */
specifier|public
specifier|static
name|Builder
name|newBuilder
parameter_list|()
block|{
return|return
operator|new
name|Builder
argument_list|()
return|;
block|}
comment|/**      * Builder that can be used to obtain new instances of {@link Parser}.      */
specifier|public
specifier|static
class|class
name|Builder
block|{
specifier|private
name|boolean
name|allowUnknownFields
init|=
literal|false
decl_stmt|;
specifier|private
name|SingularOverwritePolicy
name|singularOverwritePolicy
init|=
name|SingularOverwritePolicy
operator|.
name|ALLOW_SINGULAR_OVERWRITES
decl_stmt|;
specifier|private
name|TextFormatParseInfoTree
operator|.
name|Builder
name|parseInfoTreeBuilder
init|=
literal|null
decl_stmt|;
comment|/**        * Sets parser behavior when a non-repeated field appears more than once.        */
specifier|public
name|Builder
name|setSingularOverwritePolicy
parameter_list|(
name|SingularOverwritePolicy
name|p
parameter_list|)
block|{
name|this
operator|.
name|singularOverwritePolicy
operator|=
name|p
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|Builder
name|setParseInfoTreeBuilder
parameter_list|(
name|TextFormatParseInfoTree
operator|.
name|Builder
name|parseInfoTreeBuilder
parameter_list|)
block|{
name|this
operator|.
name|parseInfoTreeBuilder
operator|=
name|parseInfoTreeBuilder
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|Parser
name|build
parameter_list|()
block|{
return|return
operator|new
name|Parser
argument_list|(
name|allowUnknownFields
argument_list|,
name|singularOverwritePolicy
argument_list|,
name|parseInfoTreeBuilder
argument_list|)
return|;
block|}
block|}
comment|/**      * Parse a text-format message from {@code input} and merge the contents      * into {@code builder}.      */
specifier|public
name|void
name|merge
parameter_list|(
specifier|final
name|Readable
name|input
parameter_list|,
specifier|final
name|Message
operator|.
name|Builder
name|builder
parameter_list|)
throws|throws
name|IOException
block|{
name|merge
argument_list|(
name|input
argument_list|,
name|ExtensionRegistry
operator|.
name|getEmptyRegistry
argument_list|()
argument_list|,
name|builder
argument_list|)
expr_stmt|;
block|}
comment|/**      * Parse a text-format message from {@code input} and merge the contents      * into {@code builder}.      */
specifier|public
name|void
name|merge
parameter_list|(
specifier|final
name|CharSequence
name|input
parameter_list|,
specifier|final
name|Message
operator|.
name|Builder
name|builder
parameter_list|)
throws|throws
name|ParseException
block|{
name|merge
argument_list|(
name|input
argument_list|,
name|ExtensionRegistry
operator|.
name|getEmptyRegistry
argument_list|()
argument_list|,
name|builder
argument_list|)
expr_stmt|;
block|}
comment|/**      * Parse a text-format message from {@code input} and merge the contents      * into {@code builder}.  Extensions will be recognized if they are      * registered in {@code extensionRegistry}.      */
specifier|public
name|void
name|merge
parameter_list|(
specifier|final
name|Readable
name|input
parameter_list|,
specifier|final
name|ExtensionRegistry
name|extensionRegistry
parameter_list|,
specifier|final
name|Message
operator|.
name|Builder
name|builder
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Read the entire input to a String then parse that.
comment|// If StreamTokenizer were not quite so crippled, or if there were a kind
comment|// of Reader that could read in chunks that match some particular regex,
comment|// or if we wanted to write a custom Reader to tokenize our stream, then
comment|// we would not have to read to one big String.  Alas, none of these is
comment|// the case.  Oh well.
name|merge
argument_list|(
name|toStringBuilder
argument_list|(
name|input
argument_list|)
argument_list|,
name|extensionRegistry
argument_list|,
name|builder
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
specifier|final
name|int
name|BUFFER_SIZE
init|=
literal|4096
decl_stmt|;
comment|// TODO(chrisn): See if working around java.io.Reader#read(CharBuffer)
comment|// overhead is worthwhile
specifier|private
specifier|static
name|StringBuilder
name|toStringBuilder
parameter_list|(
specifier|final
name|Readable
name|input
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|StringBuilder
name|text
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
specifier|final
name|CharBuffer
name|buffer
init|=
name|CharBuffer
operator|.
name|allocate
argument_list|(
name|BUFFER_SIZE
argument_list|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|n
init|=
name|input
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
block|}
name|buffer
operator|.
name|flip
argument_list|()
expr_stmt|;
name|text
operator|.
name|append
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
name|text
return|;
block|}
comment|// Check both unknown fields and unknown extensions and log warming messages
comment|// or throw exceptions according to the flag.
specifier|private
name|void
name|checkUnknownFields
parameter_list|(
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|unknownFields
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
name|unknownFields
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|StringBuilder
name|msg
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"Input contains unknown fields and/or extensions:"
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|field
range|:
name|unknownFields
control|)
block|{
name|msg
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
operator|.
name|append
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|allowUnknownFields
condition|)
block|{
name|logger
operator|.
name|warning
argument_list|(
name|msg
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
index|[]
name|lineColumn
init|=
name|unknownFields
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|split
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|ParseException
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|lineColumn
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|lineColumn
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|msg
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**      * Parse a text-format message from {@code input} and merge the contents      * into {@code builder}.  Extensions will be recognized if they are      * registered in {@code extensionRegistry}.      */
specifier|public
name|void
name|merge
parameter_list|(
specifier|final
name|CharSequence
name|input
parameter_list|,
specifier|final
name|ExtensionRegistry
name|extensionRegistry
parameter_list|,
specifier|final
name|Message
operator|.
name|Builder
name|builder
parameter_list|)
throws|throws
name|ParseException
block|{
specifier|final
name|Tokenizer
name|tokenizer
init|=
operator|new
name|Tokenizer
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|MessageReflection
operator|.
name|BuilderAdapter
name|target
init|=
operator|new
name|MessageReflection
operator|.
name|BuilderAdapter
argument_list|(
name|builder
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|unknownFields
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|tokenizer
operator|.
name|atEnd
argument_list|()
condition|)
block|{
name|mergeField
argument_list|(
name|tokenizer
argument_list|,
name|extensionRegistry
argument_list|,
name|target
argument_list|,
name|unknownFields
argument_list|)
expr_stmt|;
block|}
name|checkUnknownFields
argument_list|(
name|unknownFields
argument_list|)
expr_stmt|;
block|}
comment|/**      * Parse a single field from {@code tokenizer} and merge it into      * {@code builder}.      */
specifier|private
name|void
name|mergeField
parameter_list|(
specifier|final
name|Tokenizer
name|tokenizer
parameter_list|,
specifier|final
name|ExtensionRegistry
name|extensionRegistry
parameter_list|,
specifier|final
name|MessageReflection
operator|.
name|MergeTarget
name|target
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|unknownFields
parameter_list|)
throws|throws
name|ParseException
block|{
name|mergeField
argument_list|(
name|tokenizer
argument_list|,
name|extensionRegistry
argument_list|,
name|target
argument_list|,
name|parseInfoTreeBuilder
argument_list|,
name|unknownFields
argument_list|)
expr_stmt|;
block|}
comment|/**      * Parse a single field from {@code tokenizer} and merge it into      * {@code builder}.      */
specifier|private
name|void
name|mergeField
parameter_list|(
specifier|final
name|Tokenizer
name|tokenizer
parameter_list|,
specifier|final
name|ExtensionRegistry
name|extensionRegistry
parameter_list|,
specifier|final
name|MessageReflection
operator|.
name|MergeTarget
name|target
parameter_list|,
name|TextFormatParseInfoTree
operator|.
name|Builder
name|parseTreeBuilder
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|unknownFields
parameter_list|)
throws|throws
name|ParseException
block|{
name|FieldDescriptor
name|field
init|=
literal|null
decl_stmt|;
name|int
name|startLine
init|=
name|tokenizer
operator|.
name|getLine
argument_list|()
decl_stmt|;
name|int
name|startColumn
init|=
name|tokenizer
operator|.
name|getColumn
argument_list|()
decl_stmt|;
specifier|final
name|Descriptor
name|type
init|=
name|target
operator|.
name|getDescriptorForType
argument_list|()
decl_stmt|;
name|ExtensionRegistry
operator|.
name|ExtensionInfo
name|extension
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|tokenizer
operator|.
name|tryConsume
argument_list|(
literal|"["
argument_list|)
condition|)
block|{
comment|// An extension.
specifier|final
name|StringBuilder
name|name
init|=
operator|new
name|StringBuilder
argument_list|(
name|tokenizer
operator|.
name|consumeIdentifier
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|tokenizer
operator|.
name|tryConsume
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
name|name
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|name
operator|.
name|append
argument_list|(
name|tokenizer
operator|.
name|consumeIdentifier
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|extension
operator|=
name|target
operator|.
name|findExtensionByName
argument_list|(
name|extensionRegistry
argument_list|,
name|name
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|extension
operator|==
literal|null
condition|)
block|{
name|unknownFields
operator|.
name|add
argument_list|(
operator|(
name|tokenizer
operator|.
name|getPreviousLine
argument_list|()
operator|+
literal|1
operator|)
operator|+
literal|":"
operator|+
operator|(
name|tokenizer
operator|.
name|getPreviousColumn
argument_list|()
operator|+
literal|1
operator|)
operator|+
literal|":\t"
operator|+
name|type
operator|.
name|getFullName
argument_list|()
operator|+
literal|".["
operator|+
name|name
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|extension
operator|.
name|descriptor
operator|.
name|getContainingType
argument_list|()
operator|!=
name|type
condition|)
block|{
throw|throw
name|tokenizer
operator|.
name|parseExceptionPreviousToken
argument_list|(
literal|"Extension \""
operator|+
name|name
operator|+
literal|"\" does not extend message type \""
operator|+
name|type
operator|.
name|getFullName
argument_list|()
operator|+
literal|"\"."
argument_list|)
throw|;
block|}
name|field
operator|=
name|extension
operator|.
name|descriptor
expr_stmt|;
block|}
name|tokenizer
operator|.
name|consume
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|String
name|name
init|=
name|tokenizer
operator|.
name|consumeIdentifier
argument_list|()
decl_stmt|;
name|field
operator|=
name|type
operator|.
name|findFieldByName
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|// Group names are expected to be capitalized as they appear in the
comment|// .proto file, which actually matches their type names, not their field
comment|// names.
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
comment|// Explicitly specify US locale so that this code does not break when
comment|// executing in Turkey.
specifier|final
name|String
name|lowerName
init|=
name|name
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|US
argument_list|)
decl_stmt|;
name|field
operator|=
name|type
operator|.
name|findFieldByName
argument_list|(
name|lowerName
argument_list|)
expr_stmt|;
comment|// If the case-insensitive match worked but the field is NOT a group,
if|if
condition|(
name|field
operator|!=
literal|null
operator|&&
name|field
operator|.
name|getType
argument_list|()
operator|!=
name|FieldDescriptor
operator|.
name|Type
operator|.
name|GROUP
condition|)
block|{
name|field
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// Again, special-case group names as described above.
if|if
condition|(
name|field
operator|!=
literal|null
operator|&&
name|field
operator|.
name|getType
argument_list|()
operator|==
name|FieldDescriptor
operator|.
name|Type
operator|.
name|GROUP
operator|&&
operator|!
name|field
operator|.
name|getMessageType
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|field
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
name|unknownFields
operator|.
name|add
argument_list|(
operator|(
name|tokenizer
operator|.
name|getPreviousLine
argument_list|()
operator|+
literal|1
operator|)
operator|+
literal|":"
operator|+
operator|(
name|tokenizer
operator|.
name|getPreviousColumn
argument_list|()
operator|+
literal|1
operator|)
operator|+
literal|":\t"
operator|+
name|type
operator|.
name|getFullName
argument_list|()
operator|+
literal|"."
operator|+
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Skips unknown fields.
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
comment|// Try to guess the type of this field.
comment|// If this field is not a message, there should be a ":" between the
comment|// field name and the field value and also the field value should not
comment|// start with "{" or "<" which indicates the beginning of a message body.
comment|// If there is no ":" or there is a "{" or "<" after ":", this field has
comment|// to be a message or the input is ill-formed.
if|if
condition|(
name|tokenizer
operator|.
name|tryConsume
argument_list|(
literal|":"
argument_list|)
operator|&&
operator|!
name|tokenizer
operator|.
name|lookingAt
argument_list|(
literal|"{"
argument_list|)
operator|&&
operator|!
name|tokenizer
operator|.
name|lookingAt
argument_list|(
literal|"<"
argument_list|)
condition|)
block|{
name|skipFieldValue
argument_list|(
name|tokenizer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|skipFieldMessage
argument_list|(
name|tokenizer
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// Handle potential ':'.
if|if
condition|(
name|field
operator|.
name|getJavaType
argument_list|()
operator|==
name|FieldDescriptor
operator|.
name|JavaType
operator|.
name|MESSAGE
condition|)
block|{
name|tokenizer
operator|.
name|tryConsume
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
comment|// optional
if|if
condition|(
name|parseTreeBuilder
operator|!=
literal|null
condition|)
block|{
name|TextFormatParseInfoTree
operator|.
name|Builder
name|childParseTreeBuilder
init|=
name|parseTreeBuilder
operator|.
name|getBuilderForSubMessageField
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|consumeFieldValues
argument_list|(
name|tokenizer
argument_list|,
name|extensionRegistry
argument_list|,
name|target
argument_list|,
name|field
argument_list|,
name|extension
argument_list|,
name|childParseTreeBuilder
argument_list|,
name|unknownFields
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|consumeFieldValues
argument_list|(
name|tokenizer
argument_list|,
name|extensionRegistry
argument_list|,
name|target
argument_list|,
name|field
argument_list|,
name|extension
argument_list|,
name|parseTreeBuilder
argument_list|,
name|unknownFields
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tokenizer
operator|.
name|consume
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
comment|// required
name|consumeFieldValues
argument_list|(
name|tokenizer
argument_list|,
name|extensionRegistry
argument_list|,
name|target
argument_list|,
name|field
argument_list|,
name|extension
argument_list|,
name|parseTreeBuilder
argument_list|,
name|unknownFields
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parseTreeBuilder
operator|!=
literal|null
condition|)
block|{
name|parseTreeBuilder
operator|.
name|setLocation
argument_list|(
name|field
argument_list|,
name|TextFormatParseLocation
operator|.
name|create
argument_list|(
name|startLine
argument_list|,
name|startColumn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// For historical reasons, fields may optionally be separated by commas or
comment|// semicolons.
if|if
condition|(
operator|!
name|tokenizer
operator|.
name|tryConsume
argument_list|(
literal|";"
argument_list|)
condition|)
block|{
name|tokenizer
operator|.
name|tryConsume
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Parse a one or more field values from {@code tokenizer} and merge it into      * {@code builder}.      */
specifier|private
name|void
name|consumeFieldValues
parameter_list|(
specifier|final
name|Tokenizer
name|tokenizer
parameter_list|,
specifier|final
name|ExtensionRegistry
name|extensionRegistry
parameter_list|,
specifier|final
name|MessageReflection
operator|.
name|MergeTarget
name|target
parameter_list|,
specifier|final
name|FieldDescriptor
name|field
parameter_list|,
specifier|final
name|ExtensionRegistry
operator|.
name|ExtensionInfo
name|extension
parameter_list|,
specifier|final
name|TextFormatParseInfoTree
operator|.
name|Builder
name|parseTreeBuilder
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|unknownFields
parameter_list|)
throws|throws
name|ParseException
block|{
comment|// Support specifying repeated field values as a comma-separated list.
comment|// Ex."foo: [1, 2, 3]"
if|if
condition|(
name|field
operator|.
name|isRepeated
argument_list|()
operator|&&
name|tokenizer
operator|.
name|tryConsume
argument_list|(
literal|"["
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|tokenizer
operator|.
name|tryConsume
argument_list|(
literal|"]"
argument_list|)
condition|)
block|{
comment|// Allow "foo: []" to be treated as empty.
while|while
condition|(
literal|true
condition|)
block|{
name|consumeFieldValue
argument_list|(
name|tokenizer
argument_list|,
name|extensionRegistry
argument_list|,
name|target
argument_list|,
name|field
argument_list|,
name|extension
argument_list|,
name|parseTreeBuilder
argument_list|,
name|unknownFields
argument_list|)
expr_stmt|;
if|if
condition|(
name|tokenizer
operator|.
name|tryConsume
argument_list|(
literal|"]"
argument_list|)
condition|)
block|{
comment|// End of list.
break|break;
block|}
name|tokenizer
operator|.
name|consume
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|consumeFieldValue
argument_list|(
name|tokenizer
argument_list|,
name|extensionRegistry
argument_list|,
name|target
argument_list|,
name|field
argument_list|,
name|extension
argument_list|,
name|parseTreeBuilder
argument_list|,
name|unknownFields
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Parse a single field value from {@code tokenizer} and merge it into      * {@code builder}.      */
specifier|private
name|void
name|consumeFieldValue
parameter_list|(
specifier|final
name|Tokenizer
name|tokenizer
parameter_list|,
specifier|final
name|ExtensionRegistry
name|extensionRegistry
parameter_list|,
specifier|final
name|MessageReflection
operator|.
name|MergeTarget
name|target
parameter_list|,
specifier|final
name|FieldDescriptor
name|field
parameter_list|,
specifier|final
name|ExtensionRegistry
operator|.
name|ExtensionInfo
name|extension
parameter_list|,
specifier|final
name|TextFormatParseInfoTree
operator|.
name|Builder
name|parseTreeBuilder
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|unknownFields
parameter_list|)
throws|throws
name|ParseException
block|{
name|Object
name|value
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|getJavaType
argument_list|()
operator|==
name|FieldDescriptor
operator|.
name|JavaType
operator|.
name|MESSAGE
condition|)
block|{
specifier|final
name|String
name|endToken
decl_stmt|;
if|if
condition|(
name|tokenizer
operator|.
name|tryConsume
argument_list|(
literal|"<"
argument_list|)
condition|)
block|{
name|endToken
operator|=
literal|">"
expr_stmt|;
block|}
else|else
block|{
name|tokenizer
operator|.
name|consume
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|endToken
operator|=
literal|"}"
expr_stmt|;
block|}
specifier|final
name|MessageReflection
operator|.
name|MergeTarget
name|subField
decl_stmt|;
name|subField
operator|=
name|target
operator|.
name|newMergeTargetForField
argument_list|(
name|field
argument_list|,
operator|(
name|extension
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|extension
operator|.
name|defaultInstance
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|tokenizer
operator|.
name|tryConsume
argument_list|(
name|endToken
argument_list|)
condition|)
block|{
if|if
condition|(
name|tokenizer
operator|.
name|atEnd
argument_list|()
condition|)
block|{
throw|throw
name|tokenizer
operator|.
name|parseException
argument_list|(
literal|"Expected \""
operator|+
name|endToken
operator|+
literal|"\"."
argument_list|)
throw|;
block|}
name|mergeField
argument_list|(
name|tokenizer
argument_list|,
name|extensionRegistry
argument_list|,
name|subField
argument_list|,
name|parseTreeBuilder
argument_list|,
name|unknownFields
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|subField
operator|.
name|finish
argument_list|()
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|field
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|INT32
case|:
case|case
name|SINT32
case|:
case|case
name|SFIXED32
case|:
name|value
operator|=
name|tokenizer
operator|.
name|consumeInt32
argument_list|()
expr_stmt|;
break|break;
case|case
name|INT64
case|:
case|case
name|SINT64
case|:
case|case
name|SFIXED64
case|:
name|value
operator|=
name|tokenizer
operator|.
name|consumeInt64
argument_list|()
expr_stmt|;
break|break;
case|case
name|UINT32
case|:
case|case
name|FIXED32
case|:
name|value
operator|=
name|tokenizer
operator|.
name|consumeUInt32
argument_list|()
expr_stmt|;
break|break;
case|case
name|UINT64
case|:
case|case
name|FIXED64
case|:
name|value
operator|=
name|tokenizer
operator|.
name|consumeUInt64
argument_list|()
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|value
operator|=
name|tokenizer
operator|.
name|consumeFloat
argument_list|()
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
name|value
operator|=
name|tokenizer
operator|.
name|consumeDouble
argument_list|()
expr_stmt|;
break|break;
case|case
name|BOOL
case|:
name|value
operator|=
name|tokenizer
operator|.
name|consumeBoolean
argument_list|()
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|value
operator|=
name|tokenizer
operator|.
name|consumeString
argument_list|()
expr_stmt|;
break|break;
case|case
name|BYTES
case|:
name|value
operator|=
name|tokenizer
operator|.
name|consumeByteString
argument_list|()
expr_stmt|;
break|break;
case|case
name|ENUM
case|:
specifier|final
name|EnumDescriptor
name|enumType
init|=
name|field
operator|.
name|getEnumType
argument_list|()
decl_stmt|;
if|if
condition|(
name|tokenizer
operator|.
name|lookingAtInteger
argument_list|()
condition|)
block|{
specifier|final
name|int
name|number
init|=
name|tokenizer
operator|.
name|consumeInt32
argument_list|()
decl_stmt|;
name|value
operator|=
name|enumType
operator|.
name|findValueByNumber
argument_list|(
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
name|tokenizer
operator|.
name|parseExceptionPreviousToken
argument_list|(
literal|"Enum type \""
operator|+
name|enumType
operator|.
name|getFullName
argument_list|()
operator|+
literal|"\" has no value with number "
operator|+
name|number
operator|+
literal|'.'
argument_list|)
throw|;
block|}
block|}
else|else
block|{
specifier|final
name|String
name|id
init|=
name|tokenizer
operator|.
name|consumeIdentifier
argument_list|()
decl_stmt|;
name|value
operator|=
name|enumType
operator|.
name|findValueByName
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
name|tokenizer
operator|.
name|parseExceptionPreviousToken
argument_list|(
literal|"Enum type \""
operator|+
name|enumType
operator|.
name|getFullName
argument_list|()
operator|+
literal|"\" has no value named \""
operator|+
name|id
operator|+
literal|"\"."
argument_list|)
throw|;
block|}
block|}
break|break;
case|case
name|MESSAGE
case|:
case|case
name|GROUP
case|:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Can't get here."
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|field
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
name|target
operator|.
name|addRepeatedField
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|singularOverwritePolicy
operator|==
name|SingularOverwritePolicy
operator|.
name|FORBID_SINGULAR_OVERWRITES
operator|)
operator|&&
name|target
operator|.
name|hasField
argument_list|(
name|field
argument_list|)
condition|)
block|{
throw|throw
name|tokenizer
operator|.
name|parseExceptionPreviousToken
argument_list|(
literal|"Non-repeated field \""
operator|+
name|field
operator|.
name|getFullName
argument_list|()
operator|+
literal|"\" cannot be overwritten."
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
operator|(
name|singularOverwritePolicy
operator|==
name|SingularOverwritePolicy
operator|.
name|FORBID_SINGULAR_OVERWRITES
operator|)
operator|&&
name|field
operator|.
name|getContainingOneof
argument_list|()
operator|!=
literal|null
operator|&&
name|target
operator|.
name|hasOneof
argument_list|(
name|field
operator|.
name|getContainingOneof
argument_list|()
argument_list|)
condition|)
block|{
name|Descriptors
operator|.
name|OneofDescriptor
name|oneof
init|=
name|field
operator|.
name|getContainingOneof
argument_list|()
decl_stmt|;
throw|throw
name|tokenizer
operator|.
name|parseExceptionPreviousToken
argument_list|(
literal|"Field \""
operator|+
name|field
operator|.
name|getFullName
argument_list|()
operator|+
literal|"\" is specified along with field \""
operator|+
name|target
operator|.
name|getOneofFieldDescriptor
argument_list|(
name|oneof
argument_list|)
operator|.
name|getFullName
argument_list|()
operator|+
literal|"\", another member of oneof \""
operator|+
name|oneof
operator|.
name|getName
argument_list|()
operator|+
literal|"\"."
argument_list|)
throw|;
block|}
else|else
block|{
name|target
operator|.
name|setField
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Skips the next field including the field's name and value.      */
specifier|private
name|void
name|skipField
parameter_list|(
name|Tokenizer
name|tokenizer
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
name|tokenizer
operator|.
name|tryConsume
argument_list|(
literal|"["
argument_list|)
condition|)
block|{
comment|// Extension name.
do|do
block|{
name|tokenizer
operator|.
name|consumeIdentifier
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|tokenizer
operator|.
name|tryConsume
argument_list|(
literal|"."
argument_list|)
condition|)
do|;
name|tokenizer
operator|.
name|consume
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tokenizer
operator|.
name|consumeIdentifier
argument_list|()
expr_stmt|;
block|}
comment|// Try to guess the type of this field.
comment|// If this field is not a message, there should be a ":" between the
comment|// field name and the field value and also the field value should not
comment|// start with "{" or "<" which indicates the beginning of a message body.
comment|// If there is no ":" or there is a "{" or "<" after ":", this field has
comment|// to be a message or the input is ill-formed.
if|if
condition|(
name|tokenizer
operator|.
name|tryConsume
argument_list|(
literal|":"
argument_list|)
operator|&&
operator|!
name|tokenizer
operator|.
name|lookingAt
argument_list|(
literal|"<"
argument_list|)
operator|&&
operator|!
name|tokenizer
operator|.
name|lookingAt
argument_list|(
literal|"{"
argument_list|)
condition|)
block|{
name|skipFieldValue
argument_list|(
name|tokenizer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|skipFieldMessage
argument_list|(
name|tokenizer
argument_list|)
expr_stmt|;
block|}
comment|// For historical reasons, fields may optionally be separated by commas or
comment|// semicolons.
if|if
condition|(
operator|!
name|tokenizer
operator|.
name|tryConsume
argument_list|(
literal|";"
argument_list|)
condition|)
block|{
name|tokenizer
operator|.
name|tryConsume
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Skips the whole body of a message including the beginning delimiter and      * the ending delimiter.      */
specifier|private
name|void
name|skipFieldMessage
parameter_list|(
name|Tokenizer
name|tokenizer
parameter_list|)
throws|throws
name|ParseException
block|{
specifier|final
name|String
name|delimiter
decl_stmt|;
if|if
condition|(
name|tokenizer
operator|.
name|tryConsume
argument_list|(
literal|"<"
argument_list|)
condition|)
block|{
name|delimiter
operator|=
literal|">"
expr_stmt|;
block|}
else|else
block|{
name|tokenizer
operator|.
name|consume
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|delimiter
operator|=
literal|"}"
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|tokenizer
operator|.
name|lookingAt
argument_list|(
literal|">"
argument_list|)
operator|&&
operator|!
name|tokenizer
operator|.
name|lookingAt
argument_list|(
literal|"}"
argument_list|)
condition|)
block|{
name|skipField
argument_list|(
name|tokenizer
argument_list|)
expr_stmt|;
block|}
name|tokenizer
operator|.
name|consume
argument_list|(
name|delimiter
argument_list|)
expr_stmt|;
block|}
comment|/**      * Skips a field value.      */
specifier|private
name|void
name|skipFieldValue
parameter_list|(
name|Tokenizer
name|tokenizer
parameter_list|)
throws|throws
name|ParseException
block|{
if|if
condition|(
name|tokenizer
operator|.
name|tryConsumeString
argument_list|()
condition|)
block|{
while|while
condition|(
name|tokenizer
operator|.
name|tryConsumeString
argument_list|()
condition|)
block|{}
return|return;
block|}
if|if
condition|(
operator|!
name|tokenizer
operator|.
name|tryConsumeIdentifier
argument_list|()
comment|// includes enum& boolean
operator|&&
operator|!
name|tokenizer
operator|.
name|tryConsumeInt64
argument_list|()
comment|// includes int32
operator|&&
operator|!
name|tokenizer
operator|.
name|tryConsumeUInt64
argument_list|()
comment|// includes uint32
operator|&&
operator|!
name|tokenizer
operator|.
name|tryConsumeDouble
argument_list|()
operator|&&
operator|!
name|tokenizer
operator|.
name|tryConsumeFloat
argument_list|()
condition|)
block|{
throw|throw
name|tokenizer
operator|.
name|parseException
argument_list|(
literal|"Invalid field value: "
operator|+
name|tokenizer
operator|.
name|currentToken
argument_list|)
throw|;
block|}
block|}
block|}
comment|// =================================================================
comment|// Utility functions
comment|//
comment|// Some of these methods are package-private because Descriptors.java uses
comment|// them.
comment|/**    * Escapes bytes in the format used in protocol buffer text format, which    * is the same as the format used for C string literals.  All bytes    * that are not printable 7-bit ASCII characters are escaped, as well as    * backslash, single-quote, and double-quote characters.  Characters for    * which no defined short-hand escape sequence is defined will be escaped    * using 3-digit octal sequences.    */
specifier|public
specifier|static
name|String
name|escapeBytes
parameter_list|(
name|ByteString
name|input
parameter_list|)
block|{
return|return
name|TextFormatEscaper
operator|.
name|escapeBytes
argument_list|(
name|input
argument_list|)
return|;
block|}
comment|/**    * Like {@link #escapeBytes(ByteString)}, but used for byte array.    */
specifier|public
specifier|static
name|String
name|escapeBytes
parameter_list|(
name|byte
index|[]
name|input
parameter_list|)
block|{
return|return
name|TextFormatEscaper
operator|.
name|escapeBytes
argument_list|(
name|input
argument_list|)
return|;
block|}
comment|/**    * Un-escape a byte sequence as escaped using    * {@link #escapeBytes(ByteString)}.  Two-digit hex escapes (starting with    * "\x") are also recognized.    */
specifier|public
specifier|static
name|ByteString
name|unescapeBytes
parameter_list|(
specifier|final
name|CharSequence
name|charString
parameter_list|)
throws|throws
name|InvalidEscapeSequenceException
block|{
comment|// First convert the Java character sequence to UTF-8 bytes.
name|ByteString
name|input
init|=
name|ByteString
operator|.
name|copyFromUtf8
argument_list|(
name|charString
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
comment|// Then unescape certain byte sequences introduced by ASCII '\\'.  The valid
comment|// escapes can all be expressed with ASCII characters, so it is safe to
comment|// operate on bytes here.
comment|//
comment|// Unescaping the input byte array will result in a byte sequence that's no
comment|// longer than the input.  That's because each escape sequence is between
comment|// two and four bytes long and stands for a single byte.
specifier|final
name|byte
index|[]
name|result
init|=
operator|new
name|byte
index|[
name|input
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|input
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|byte
name|c
init|=
name|input
operator|.
name|byteAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|input
operator|.
name|size
argument_list|()
condition|)
block|{
operator|++
name|i
expr_stmt|;
name|c
operator|=
name|input
operator|.
name|byteAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|isOctal
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|// Octal escape.
name|int
name|code
init|=
name|digitValue
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|input
operator|.
name|size
argument_list|()
operator|&&
name|isOctal
argument_list|(
name|input
operator|.
name|byteAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
condition|)
block|{
operator|++
name|i
expr_stmt|;
name|code
operator|=
name|code
operator|*
literal|8
operator|+
name|digitValue
argument_list|(
name|input
operator|.
name|byteAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|input
operator|.
name|size
argument_list|()
operator|&&
name|isOctal
argument_list|(
name|input
operator|.
name|byteAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
condition|)
block|{
operator|++
name|i
expr_stmt|;
name|code
operator|=
name|code
operator|*
literal|8
operator|+
name|digitValue
argument_list|(
name|input
operator|.
name|byteAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// TODO: Check that 0<= code&& code<= 0xFF.
name|result
index|[
name|pos
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|code
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|result
index|[
name|pos
operator|++
index|]
operator|=
literal|0x07
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|result
index|[
name|pos
operator|++
index|]
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|result
index|[
name|pos
operator|++
index|]
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|result
index|[
name|pos
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|result
index|[
name|pos
operator|++
index|]
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|result
index|[
name|pos
operator|++
index|]
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|result
index|[
name|pos
operator|++
index|]
operator|=
literal|0x0b
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|result
index|[
name|pos
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|result
index|[
name|pos
operator|++
index|]
operator|=
literal|'\''
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
name|result
index|[
name|pos
operator|++
index|]
operator|=
literal|'\"'
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|// hex escape
name|int
name|code
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|input
operator|.
name|size
argument_list|()
operator|&&
name|isHex
argument_list|(
name|input
operator|.
name|byteAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
condition|)
block|{
operator|++
name|i
expr_stmt|;
name|code
operator|=
name|digitValue
argument_list|(
name|input
operator|.
name|byteAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|InvalidEscapeSequenceException
argument_list|(
literal|"Invalid escape sequence: '\\x' with no digits"
argument_list|)
throw|;
block|}
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|input
operator|.
name|size
argument_list|()
operator|&&
name|isHex
argument_list|(
name|input
operator|.
name|byteAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
condition|)
block|{
operator|++
name|i
expr_stmt|;
name|code
operator|=
name|code
operator|*
literal|16
operator|+
name|digitValue
argument_list|(
name|input
operator|.
name|byteAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|result
index|[
name|pos
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|code
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|InvalidEscapeSequenceException
argument_list|(
literal|"Invalid escape sequence: '\\"
operator|+
operator|(
name|char
operator|)
name|c
operator|+
literal|'\''
argument_list|)
throw|;
block|}
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|InvalidEscapeSequenceException
argument_list|(
literal|"Invalid escape sequence: '\\' at end of string."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|result
index|[
name|pos
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
return|return
name|result
operator|.
name|length
operator|==
name|pos
condition|?
name|ByteString
operator|.
name|wrap
argument_list|(
name|result
argument_list|)
comment|// This reference has not been out of our control.
else|:
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
name|pos
argument_list|)
return|;
block|}
comment|/**    * Thrown by {@link TextFormat#unescapeBytes} and    * {@link TextFormat#unescapeText} when an invalid escape sequence is seen.    */
specifier|public
specifier|static
class|class
name|InvalidEscapeSequenceException
extends|extends
name|IOException
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
operator|-
literal|8164033650142593304L
decl_stmt|;
name|InvalidEscapeSequenceException
parameter_list|(
specifier|final
name|String
name|description
parameter_list|)
block|{
name|super
argument_list|(
name|description
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Like {@link #escapeBytes(ByteString)}, but escapes a text string.    * Non-ASCII characters are first encoded as UTF-8, then each byte is escaped    * individually as a 3-digit octal escape.  Yes, it's weird.    */
specifier|static
name|String
name|escapeText
parameter_list|(
specifier|final
name|String
name|input
parameter_list|)
block|{
return|return
name|escapeBytes
argument_list|(
name|ByteString
operator|.
name|copyFromUtf8
argument_list|(
name|input
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Escape double quotes and backslashes in a String for unicode output of a message.    */
specifier|public
specifier|static
name|String
name|escapeDoubleQuotesAndBackslashes
parameter_list|(
specifier|final
name|String
name|input
parameter_list|)
block|{
return|return
name|TextFormatEscaper
operator|.
name|escapeDoubleQuotesAndBackslashes
argument_list|(
name|input
argument_list|)
return|;
block|}
comment|/**    * Un-escape a text string as escaped using {@link #escapeText(String)}.    * Two-digit hex escapes (starting with "\x") are also recognized.    */
specifier|static
name|String
name|unescapeText
parameter_list|(
specifier|final
name|String
name|input
parameter_list|)
throws|throws
name|InvalidEscapeSequenceException
block|{
return|return
name|unescapeBytes
argument_list|(
name|input
argument_list|)
operator|.
name|toStringUtf8
argument_list|()
return|;
block|}
comment|/** Is this an octal digit? */
specifier|private
specifier|static
name|boolean
name|isOctal
parameter_list|(
specifier|final
name|byte
name|c
parameter_list|)
block|{
return|return
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'7'
return|;
block|}
comment|/** Is this a hex digit? */
specifier|private
specifier|static
name|boolean
name|isHex
parameter_list|(
specifier|final
name|byte
name|c
parameter_list|)
block|{
return|return
operator|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
operator|(
literal|'a'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'f'
operator|)
operator|||
operator|(
literal|'A'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'F'
operator|)
return|;
block|}
comment|/**    * Interpret a character as a digit (in any base up to 36) and return the    * numeric value.  This is like {@code Character.digit()} but we don't accept    * non-ASCII digits.    */
specifier|private
specifier|static
name|int
name|digitValue
parameter_list|(
specifier|final
name|byte
name|c
parameter_list|)
block|{
if|if
condition|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
return|return
name|c
operator|-
literal|'0'
return|;
block|}
elseif|else
if|if
condition|(
literal|'a'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'z'
condition|)
block|{
return|return
name|c
operator|-
literal|'a'
operator|+
literal|10
return|;
block|}
else|else
block|{
return|return
name|c
operator|-
literal|'A'
operator|+
literal|10
return|;
block|}
block|}
comment|/**    * Parse a 32-bit signed integer from the text.  Unlike the Java standard    * {@code Integer.parseInt()}, this function recognizes the prefixes "0x"    * and "0" to signify hexadecimal and octal numbers, respectively.    */
specifier|static
name|int
name|parseInt32
parameter_list|(
specifier|final
name|String
name|text
parameter_list|)
throws|throws
name|NumberFormatException
block|{
return|return
operator|(
name|int
operator|)
name|parseInteger
argument_list|(
name|text
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Parse a 32-bit unsigned integer from the text.  Unlike the Java standard    * {@code Integer.parseInt()}, this function recognizes the prefixes "0x"    * and "0" to signify hexadecimal and octal numbers, respectively.  The    * result is coerced to a (signed) {@code int} when returned since Java has    * no unsigned integer type.    */
specifier|static
name|int
name|parseUInt32
parameter_list|(
specifier|final
name|String
name|text
parameter_list|)
throws|throws
name|NumberFormatException
block|{
return|return
operator|(
name|int
operator|)
name|parseInteger
argument_list|(
name|text
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Parse a 64-bit signed integer from the text.  Unlike the Java standard    * {@code Integer.parseInt()}, this function recognizes the prefixes "0x"    * and "0" to signify hexadecimal and octal numbers, respectively.    */
specifier|static
name|long
name|parseInt64
parameter_list|(
specifier|final
name|String
name|text
parameter_list|)
throws|throws
name|NumberFormatException
block|{
return|return
name|parseInteger
argument_list|(
name|text
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Parse a 64-bit unsigned integer from the text.  Unlike the Java standard    * {@code Integer.parseInt()}, this function recognizes the prefixes "0x"    * and "0" to signify hexadecimal and octal numbers, respectively.  The    * result is coerced to a (signed) {@code long} when returned since Java has    * no unsigned long type.    */
specifier|static
name|long
name|parseUInt64
parameter_list|(
specifier|final
name|String
name|text
parameter_list|)
throws|throws
name|NumberFormatException
block|{
return|return
name|parseInteger
argument_list|(
name|text
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|long
name|parseInteger
parameter_list|(
specifier|final
name|String
name|text
parameter_list|,
specifier|final
name|boolean
name|isSigned
parameter_list|,
specifier|final
name|boolean
name|isLong
parameter_list|)
throws|throws
name|NumberFormatException
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|boolean
name|negative
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|text
operator|.
name|startsWith
argument_list|(
literal|"-"
argument_list|,
name|pos
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|isSigned
condition|)
block|{
throw|throw
operator|new
name|NumberFormatException
argument_list|(
literal|"Number must be positive: "
operator|+
name|text
argument_list|)
throw|;
block|}
operator|++
name|pos
expr_stmt|;
name|negative
operator|=
literal|true
expr_stmt|;
block|}
name|int
name|radix
init|=
literal|10
decl_stmt|;
if|if
condition|(
name|text
operator|.
name|startsWith
argument_list|(
literal|"0x"
argument_list|,
name|pos
argument_list|)
condition|)
block|{
name|pos
operator|+=
literal|2
expr_stmt|;
name|radix
operator|=
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|text
operator|.
name|startsWith
argument_list|(
literal|"0"
argument_list|,
name|pos
argument_list|)
condition|)
block|{
name|radix
operator|=
literal|8
expr_stmt|;
block|}
specifier|final
name|String
name|numberText
init|=
name|text
operator|.
name|substring
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|long
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|numberText
operator|.
name|length
argument_list|()
operator|<
literal|16
condition|)
block|{
comment|// Can safely assume no overflow.
name|result
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|numberText
argument_list|,
name|radix
argument_list|)
expr_stmt|;
if|if
condition|(
name|negative
condition|)
block|{
name|result
operator|=
operator|-
name|result
expr_stmt|;
block|}
comment|// Check bounds.
comment|// No need to check for 64-bit numbers since they'd have to be 16 chars
comment|// or longer to overflow.
if|if
condition|(
operator|!
name|isLong
condition|)
block|{
if|if
condition|(
name|isSigned
condition|)
block|{
if|if
condition|(
name|result
operator|>
name|Integer
operator|.
name|MAX_VALUE
operator|||
name|result
operator|<
name|Integer
operator|.
name|MIN_VALUE
condition|)
block|{
throw|throw
operator|new
name|NumberFormatException
argument_list|(
literal|"Number out of range for 32-bit signed integer: "
operator|+
name|text
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|result
operator|>=
operator|(
literal|1L
operator|<<
literal|32
operator|)
operator|||
name|result
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|NumberFormatException
argument_list|(
literal|"Number out of range for 32-bit unsigned integer: "
operator|+
name|text
argument_list|)
throw|;
block|}
block|}
block|}
block|}
else|else
block|{
name|BigInteger
name|bigValue
init|=
operator|new
name|BigInteger
argument_list|(
name|numberText
argument_list|,
name|radix
argument_list|)
decl_stmt|;
if|if
condition|(
name|negative
condition|)
block|{
name|bigValue
operator|=
name|bigValue
operator|.
name|negate
argument_list|()
expr_stmt|;
block|}
comment|// Check bounds.
if|if
condition|(
operator|!
name|isLong
condition|)
block|{
if|if
condition|(
name|isSigned
condition|)
block|{
if|if
condition|(
name|bigValue
operator|.
name|bitLength
argument_list|()
operator|>
literal|31
condition|)
block|{
throw|throw
operator|new
name|NumberFormatException
argument_list|(
literal|"Number out of range for 32-bit signed integer: "
operator|+
name|text
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|bigValue
operator|.
name|bitLength
argument_list|()
operator|>
literal|32
condition|)
block|{
throw|throw
operator|new
name|NumberFormatException
argument_list|(
literal|"Number out of range for 32-bit unsigned integer: "
operator|+
name|text
argument_list|)
throw|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|isSigned
condition|)
block|{
if|if
condition|(
name|bigValue
operator|.
name|bitLength
argument_list|()
operator|>
literal|63
condition|)
block|{
throw|throw
operator|new
name|NumberFormatException
argument_list|(
literal|"Number out of range for 64-bit signed integer: "
operator|+
name|text
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|bigValue
operator|.
name|bitLength
argument_list|()
operator|>
literal|64
condition|)
block|{
throw|throw
operator|new
name|NumberFormatException
argument_list|(
literal|"Number out of range for 64-bit unsigned integer: "
operator|+
name|text
argument_list|)
throw|;
block|}
block|}
block|}
name|result
operator|=
name|bigValue
operator|.
name|longValue
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
end_class

end_unit

