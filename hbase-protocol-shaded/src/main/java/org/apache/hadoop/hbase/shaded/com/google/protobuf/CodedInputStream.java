begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|// Protocol Buffers - Google's data interchange format
end_comment

begin_comment
comment|// Copyright 2008 Google Inc.  All rights reserved.
end_comment

begin_comment
comment|// https://developers.google.com/protocol-buffers/
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Redistribution and use in source and binary forms, with or without
end_comment

begin_comment
comment|// modification, are permitted provided that the following conditions are
end_comment

begin_comment
comment|// met:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//     * Redistributions of source code must retain the above copyright
end_comment

begin_comment
comment|// notice, this list of conditions and the following disclaimer.
end_comment

begin_comment
comment|//     * Redistributions in binary form must reproduce the above
end_comment

begin_comment
comment|// copyright notice, this list of conditions and the following disclaimer
end_comment

begin_comment
comment|// in the documentation and/or other materials provided with the
end_comment

begin_comment
comment|// distribution.
end_comment

begin_comment
comment|//     * Neither the name of Google Inc. nor the names of its
end_comment

begin_comment
comment|// contributors may be used to endorse or promote products derived from
end_comment

begin_comment
comment|// this software without specific prior written permission.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
end_comment

begin_comment
comment|// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
end_comment

begin_comment
comment|// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
end_comment

begin_comment
comment|// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
end_comment

begin_comment
comment|// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
end_comment

begin_comment
comment|// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
end_comment

begin_comment
comment|// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
end_comment

begin_comment
comment|// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
end_comment

begin_comment
comment|// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Internal
operator|.
name|EMPTY_BYTE_ARRAY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Internal
operator|.
name|EMPTY_BYTE_BUFFER
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Internal
operator|.
name|UTF_8
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Internal
operator|.
name|checkNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|WireFormat
operator|.
name|FIXED_32_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|WireFormat
operator|.
name|FIXED_64_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|WireFormat
operator|.
name|MAX_VARINT_SIZE
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|/**  * Reads and decodes protocol message fields.  *  *<p>This class contains two kinds of methods: methods that read specific protocol message  * constructs and field types (e.g. {@link #readTag()} and {@link #readInt32()}) and methods that  * read low-level values (e.g. {@link #readRawVarint32()} and {@link #readRawBytes}). If you are  * reading encoded protocol messages, you should use the former methods, but if you are reading some  * other format of your own design, use the latter.  *  * @author kenton@google.com Kenton Varda  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|CodedInputStream
block|{
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_BUFFER_SIZE
init|=
literal|4096
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_RECURSION_LIMIT
init|=
literal|100
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_SIZE_LIMIT
init|=
literal|64
operator|<<
literal|20
decl_stmt|;
comment|// 64MB
comment|/** Visible for subclasses. See setRecursionLimit() */
name|int
name|recursionDepth
decl_stmt|;
name|int
name|recursionLimit
init|=
name|DEFAULT_RECURSION_LIMIT
decl_stmt|;
comment|/** Visible for subclasses. See setSizeLimit() */
name|int
name|sizeLimit
init|=
name|DEFAULT_SIZE_LIMIT
decl_stmt|;
comment|/** Create a new CodedInputStream wrapping the given InputStream. */
specifier|public
specifier|static
name|CodedInputStream
name|newInstance
parameter_list|(
specifier|final
name|InputStream
name|input
parameter_list|)
block|{
return|return
name|newInstance
argument_list|(
name|input
argument_list|,
name|DEFAULT_BUFFER_SIZE
argument_list|)
return|;
block|}
comment|/** Create a new CodedInputStream wrapping the given InputStream. */
specifier|static
name|CodedInputStream
name|newInstance
parameter_list|(
specifier|final
name|InputStream
name|input
parameter_list|,
name|int
name|bufferSize
parameter_list|)
block|{
if|if
condition|(
name|input
operator|==
literal|null
condition|)
block|{
comment|// TODO(nathanmittler): Ideally we should throw here. This is done for backward compatibility.
return|return
name|newInstance
argument_list|(
name|EMPTY_BYTE_ARRAY
argument_list|)
return|;
block|}
return|return
operator|new
name|StreamDecoder
argument_list|(
name|input
argument_list|,
name|bufferSize
argument_list|)
return|;
block|}
comment|/** Create a new CodedInputStream wrapping the given byte array. */
specifier|public
specifier|static
name|CodedInputStream
name|newInstance
parameter_list|(
specifier|final
name|byte
index|[]
name|buf
parameter_list|)
block|{
return|return
name|newInstance
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|)
return|;
block|}
comment|/** Create a new CodedInputStream wrapping the given byte array slice. */
specifier|public
specifier|static
name|CodedInputStream
name|newInstance
parameter_list|(
specifier|final
name|byte
index|[]
name|buf
parameter_list|,
specifier|final
name|int
name|off
parameter_list|,
specifier|final
name|int
name|len
parameter_list|)
block|{
return|return
name|newInstance
argument_list|(
name|buf
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
literal|false
comment|/* bufferIsImmutable */
argument_list|)
return|;
block|}
comment|/** Create a new CodedInputStream wrapping the given byte array slice. */
specifier|static
name|CodedInputStream
name|newInstance
parameter_list|(
specifier|final
name|byte
index|[]
name|buf
parameter_list|,
specifier|final
name|int
name|off
parameter_list|,
specifier|final
name|int
name|len
parameter_list|,
specifier|final
name|boolean
name|bufferIsImmutable
parameter_list|)
block|{
name|ArrayDecoder
name|result
init|=
operator|new
name|ArrayDecoder
argument_list|(
name|buf
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|bufferIsImmutable
argument_list|)
decl_stmt|;
try|try
block|{
comment|// Some uses of CodedInputStream can be more efficient if they know
comment|// exactly how many bytes are available.  By pushing the end point of the
comment|// buffer as a limit, we allow them to get this information via
comment|// getBytesUntilLimit().  Pushing a limit that we know is at the end of
comment|// the stream can never hurt, since we can never past that point anyway.
name|result
operator|.
name|pushLimit
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidProtocolBufferException
name|ex
parameter_list|)
block|{
comment|// The only reason pushLimit() might throw an exception here is if len
comment|// is negative. Normally pushLimit()'s parameter comes directly off the
comment|// wire, so it's important to catch exceptions in case of corrupt or
comment|// malicious data. However, in this case, we expect that len is not a
comment|// user-supplied value, so we can assume that it being negative indicates
comment|// a programming error. Therefore, throwing an unchecked exception is
comment|// appropriate.
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Create a new CodedInputStream wrapping the given ByteBuffer. The data starting from the    * ByteBuffer's current position to its limit will be read. The returned CodedInputStream may or    * may not share the underlying data in the ByteBuffer, therefore the ByteBuffer cannot be changed    * while the CodedInputStream is in use. Note that the ByteBuffer's position won't be changed by    * this function. Concurrent calls with the same ByteBuffer object are safe if no other thread is    * trying to alter the ByteBuffer's status.    */
specifier|public
specifier|static
name|CodedInputStream
name|newInstance
parameter_list|(
name|ByteBuffer
name|buf
parameter_list|)
block|{
return|return
name|newInstance
argument_list|(
name|buf
argument_list|,
literal|false
comment|/* bufferIsImmutable */
argument_list|)
return|;
block|}
comment|/** Create a new CodedInputStream wrapping the given buffer. */
specifier|static
name|CodedInputStream
name|newInstance
parameter_list|(
name|ByteBuffer
name|buf
parameter_list|,
name|boolean
name|bufferIsImmutable
parameter_list|)
block|{
if|if
condition|(
name|buf
operator|.
name|hasArray
argument_list|()
condition|)
block|{
return|return
name|newInstance
argument_list|(
name|buf
operator|.
name|array
argument_list|()
argument_list|,
name|buf
operator|.
name|arrayOffset
argument_list|()
operator|+
name|buf
operator|.
name|position
argument_list|()
argument_list|,
name|buf
operator|.
name|remaining
argument_list|()
argument_list|,
name|bufferIsImmutable
argument_list|)
return|;
block|}
if|if
condition|(
name|buf
operator|.
name|isDirect
argument_list|()
operator|&&
name|UnsafeDirectNioDecoder
operator|.
name|isSupported
argument_list|()
condition|)
block|{
return|return
operator|new
name|UnsafeDirectNioDecoder
argument_list|(
name|buf
argument_list|,
name|bufferIsImmutable
argument_list|)
return|;
block|}
comment|// The buffer is non-direct and does not expose the underlying array. Using the ByteBuffer API
comment|// to access individual bytes is very slow, so just copy the buffer to an array.
comment|// TODO(nathanmittler): Re-evaluate with Java 9
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
name|buf
operator|.
name|remaining
argument_list|()
index|]
decl_stmt|;
name|buf
operator|.
name|duplicate
argument_list|()
operator|.
name|get
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|newInstance
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|buffer
operator|.
name|length
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/** Create a new CodedInputStream wrapping the given {@link ByteInput}. */
specifier|static
name|CodedInputStream
name|newInstance
parameter_list|(
name|ByteInput
name|buf
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|,
name|boolean
name|bufferIsImmutable
parameter_list|)
block|{
return|return
operator|new
name|ByteInputDecoder
argument_list|(
name|buf
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|bufferIsImmutable
argument_list|)
return|;
block|}
comment|/** Disable construction/inheritance outside of this class. */
specifier|private
name|CodedInputStream
parameter_list|()
block|{}
comment|// -----------------------------------------------------------------
comment|/**    * Attempt to read a field tag, returning zero if we have reached EOF. Protocol message parsers    * use this to read tags, since a protocol message may legally end wherever a tag occurs, and zero    * is not a valid tag number.    */
specifier|public
specifier|abstract
name|int
name|readTag
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**    * Verifies that the last call to readTag() returned the given tag value. This is used to verify    * that a nested group ended with the correct end tag.    *    * @throws InvalidProtocolBufferException {@code value} does not match the last tag.    */
specifier|public
specifier|abstract
name|void
name|checkLastTagWas
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|InvalidProtocolBufferException
function_decl|;
specifier|public
specifier|abstract
name|int
name|getLastTag
parameter_list|()
function_decl|;
comment|/**    * Reads and discards a single field, given its tag value.    *    * @return {@code false} if the tag is an endgroup tag, in which case nothing is skipped.    *     Otherwise, returns {@code true}.    */
specifier|public
specifier|abstract
name|boolean
name|skipField
parameter_list|(
specifier|final
name|int
name|tag
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Reads a single field and writes it to output in wire format, given its tag value.    *    * @return {@code false} if the tag is an endgroup tag, in which case nothing is skipped.    *     Otherwise, returns {@code true}.    * @deprecated use {@code UnknownFieldSet} or {@code UnknownFieldSetLite} to skip to an output    *     stream.    */
annotation|@
name|Deprecated
specifier|public
specifier|abstract
name|boolean
name|skipField
parameter_list|(
specifier|final
name|int
name|tag
parameter_list|,
specifier|final
name|CodedOutputStream
name|output
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Reads and discards an entire message. This will read either until EOF or until an endgroup tag,    * whichever comes first.    */
specifier|public
specifier|abstract
name|void
name|skipMessage
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**    * Reads an entire message and writes it to output in wire format. This will read either until EOF    * or until an endgroup tag, whichever comes first.    */
specifier|public
specifier|abstract
name|void
name|skipMessage
parameter_list|(
name|CodedOutputStream
name|output
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|// -----------------------------------------------------------------
comment|/** Read a {@code double} field value from the stream. */
specifier|public
specifier|abstract
name|double
name|readDouble
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Read a {@code float} field value from the stream. */
specifier|public
specifier|abstract
name|float
name|readFloat
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Read a {@code uint64} field value from the stream. */
specifier|public
specifier|abstract
name|long
name|readUInt64
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Read an {@code int64} field value from the stream. */
specifier|public
specifier|abstract
name|long
name|readInt64
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Read an {@code int32} field value from the stream. */
specifier|public
specifier|abstract
name|int
name|readInt32
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Read a {@code fixed64} field value from the stream. */
specifier|public
specifier|abstract
name|long
name|readFixed64
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Read a {@code fixed32} field value from the stream. */
specifier|public
specifier|abstract
name|int
name|readFixed32
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Read a {@code bool} field value from the stream. */
specifier|public
specifier|abstract
name|boolean
name|readBool
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**    * Read a {@code string} field value from the stream. If the stream contains malformed UTF-8,    * replace the offending bytes with the standard UTF-8 replacement character.    */
specifier|public
specifier|abstract
name|String
name|readString
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**    * Read a {@code string} field value from the stream. If the stream contains malformed UTF-8,    * throw exception {@link InvalidProtocolBufferException}.    */
specifier|public
specifier|abstract
name|String
name|readStringRequireUtf8
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Read a {@code group} field value from the stream. */
specifier|public
specifier|abstract
name|void
name|readGroup
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|MessageLite
operator|.
name|Builder
name|builder
parameter_list|,
specifier|final
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Read a {@code group} field value from the stream. */
specifier|public
specifier|abstract
parameter_list|<
name|T
extends|extends
name|MessageLite
parameter_list|>
name|T
name|readGroup
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|Parser
argument_list|<
name|T
argument_list|>
name|parser
parameter_list|,
specifier|final
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Reads a {@code group} field value from the stream and merges it into the given {@link    * UnknownFieldSet}.    *    * @deprecated UnknownFieldSet.Builder now implements MessageLite.Builder, so you can just call    *     {@link #readGroup}.    */
annotation|@
name|Deprecated
specifier|public
specifier|abstract
name|void
name|readUnknownGroup
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|MessageLite
operator|.
name|Builder
name|builder
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Read an embedded message field value from the stream. */
specifier|public
specifier|abstract
name|void
name|readMessage
parameter_list|(
specifier|final
name|MessageLite
operator|.
name|Builder
name|builder
parameter_list|,
specifier|final
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Read an embedded message field value from the stream. */
specifier|public
specifier|abstract
parameter_list|<
name|T
extends|extends
name|MessageLite
parameter_list|>
name|T
name|readMessage
parameter_list|(
specifier|final
name|Parser
argument_list|<
name|T
argument_list|>
name|parser
parameter_list|,
specifier|final
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Read a {@code bytes} field value from the stream. */
specifier|public
specifier|abstract
name|ByteString
name|readBytes
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Read a {@code bytes} field value from the stream. */
specifier|public
specifier|abstract
name|byte
index|[]
name|readByteArray
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Read a {@code bytes} field value from the stream. */
specifier|public
specifier|abstract
name|ByteBuffer
name|readByteBuffer
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Read a {@code uint32} field value from the stream. */
specifier|public
specifier|abstract
name|int
name|readUInt32
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**    * Read an enum field value from the stream. Caller is responsible for converting the numeric    * value to an actual enum.    */
specifier|public
specifier|abstract
name|int
name|readEnum
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Read an {@code sfixed32} field value from the stream. */
specifier|public
specifier|abstract
name|int
name|readSFixed32
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Read an {@code sfixed64} field value from the stream. */
specifier|public
specifier|abstract
name|long
name|readSFixed64
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Read an {@code sint32} field value from the stream. */
specifier|public
specifier|abstract
name|int
name|readSInt32
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Read an {@code sint64} field value from the stream. */
specifier|public
specifier|abstract
name|long
name|readSInt64
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|// =================================================================
comment|/** Read a raw Varint from the stream. If larger than 32 bits, discard the upper bits. */
specifier|public
specifier|abstract
name|int
name|readRawVarint32
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Read a raw Varint from the stream. */
specifier|public
specifier|abstract
name|long
name|readRawVarint64
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Variant of readRawVarint64 for when uncomfortably close to the limit. */
comment|/* Visible for testing */
specifier|abstract
name|long
name|readRawVarint64SlowPath
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Read a 32-bit little-endian integer from the stream. */
specifier|public
specifier|abstract
name|int
name|readRawLittleEndian32
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Read a 64-bit little-endian integer from the stream. */
specifier|public
specifier|abstract
name|long
name|readRawLittleEndian64
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|// -----------------------------------------------------------------
comment|/**    * Enables {@link ByteString} aliasing of the underlying buffer, trading off on buffer pinning for    * data copies. Only valid for buffer-backed streams.    */
specifier|public
specifier|abstract
name|void
name|enableAliasing
parameter_list|(
name|boolean
name|enabled
parameter_list|)
function_decl|;
comment|/**    * Set the maximum message recursion depth. In order to prevent malicious messages from causing    * stack overflows, {@code CodedInputStream} limits how deeply messages may be nested. The default    * limit is 64.    *    * @return the old limit.    */
specifier|public
specifier|final
name|int
name|setRecursionLimit
parameter_list|(
specifier|final
name|int
name|limit
parameter_list|)
block|{
if|if
condition|(
name|limit
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Recursion limit cannot be negative: "
operator|+
name|limit
argument_list|)
throw|;
block|}
specifier|final
name|int
name|oldLimit
init|=
name|recursionLimit
decl_stmt|;
name|recursionLimit
operator|=
name|limit
expr_stmt|;
return|return
name|oldLimit
return|;
block|}
comment|/**    * Only valid for {@link InputStream}-backed streams.    *    *<p>Set the maximum message size. In order to prevent malicious messages from exhausting memory    * or causing integer overflows, {@code CodedInputStream} limits how large a message may be. The    * default limit is 64MB. You should set this limit as small as you can without harming your app's    * functionality. Note that size limits only apply when reading from an {@code InputStream}, not    * when constructed around a raw byte array (nor with {@link ByteString#newCodedInput}).    *    *<p>If you want to read several messages from a single CodedInputStream, you could call {@link    * #resetSizeCounter()} after each one to avoid hitting the size limit.    *    * @return the old limit.    */
specifier|public
specifier|final
name|int
name|setSizeLimit
parameter_list|(
specifier|final
name|int
name|limit
parameter_list|)
block|{
if|if
condition|(
name|limit
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Size limit cannot be negative: "
operator|+
name|limit
argument_list|)
throw|;
block|}
specifier|final
name|int
name|oldLimit
init|=
name|sizeLimit
decl_stmt|;
name|sizeLimit
operator|=
name|limit
expr_stmt|;
return|return
name|oldLimit
return|;
block|}
comment|/**    * Resets the current size counter to zero (see {@link #setSizeLimit(int)}). Only valid for {@link    * InputStream}-backed streams.    */
specifier|public
specifier|abstract
name|void
name|resetSizeCounter
parameter_list|()
function_decl|;
comment|/**    * Sets {@code currentLimit} to (current position) + {@code byteLimit}. This is called when    * descending into a length-delimited embedded message.    *    *<p>Note that {@code pushLimit()} does NOT affect how many bytes the {@code CodedInputStream}    * reads from an underlying {@code InputStream} when refreshing its buffer. If you need to prevent    * reading past a certain point in the underlying {@code InputStream} (e.g. because you expect it    * to contain more data after the end of the message which you need to handle differently) then    * you must place a wrapper around your {@code InputStream} which limits the amount of data that    * can be read from it.    *    * @return the old limit.    */
specifier|public
specifier|abstract
name|int
name|pushLimit
parameter_list|(
name|int
name|byteLimit
parameter_list|)
throws|throws
name|InvalidProtocolBufferException
function_decl|;
comment|/**    * Discards the current limit, returning to the previous limit.    *    * @param oldLimit The old limit, as returned by {@code pushLimit}.    */
specifier|public
specifier|abstract
name|void
name|popLimit
parameter_list|(
specifier|final
name|int
name|oldLimit
parameter_list|)
function_decl|;
comment|/**    * Returns the number of bytes to be read before the current limit. If no limit is set, returns    * -1.    */
specifier|public
specifier|abstract
name|int
name|getBytesUntilLimit
parameter_list|()
function_decl|;
comment|/**    * Returns true if the stream has reached the end of the input. This is the case if either the end    * of the underlying input source has been reached or if the stream has reached a limit created    * using {@link #pushLimit(int)}.    */
specifier|public
specifier|abstract
name|boolean
name|isAtEnd
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**    * The total bytes read up to the current position. Calling {@link #resetSizeCounter()} resets    * this value to zero.    */
specifier|public
specifier|abstract
name|int
name|getTotalBytesRead
parameter_list|()
function_decl|;
comment|/**    * Read one byte from the input.    *    * @throws InvalidProtocolBufferException The end of the stream or the current limit was reached.    */
specifier|public
specifier|abstract
name|byte
name|readRawByte
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**    * Read a fixed size of bytes from the input.    *    * @throws InvalidProtocolBufferException The end of the stream or the current limit was reached.    */
specifier|public
specifier|abstract
name|byte
index|[]
name|readRawBytes
parameter_list|(
specifier|final
name|int
name|size
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Reads and discards {@code size} bytes.    *    * @throws InvalidProtocolBufferException The end of the stream or the current limit was reached.    */
specifier|public
specifier|abstract
name|void
name|skipRawBytes
parameter_list|(
specifier|final
name|int
name|size
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Decode a ZigZag-encoded 32-bit value. ZigZag encodes signed integers into values that can be    * efficiently encoded with varint. (Otherwise, negative values must be sign-extended to 64 bits    * to be varint encoded, thus always taking 10 bytes on the wire.)    *    * @param n An unsigned 32-bit integer, stored in a signed int because Java has no explicit    *     unsigned support.    * @return A signed 32-bit integer.    */
specifier|public
specifier|static
name|int
name|decodeZigZag32
parameter_list|(
specifier|final
name|int
name|n
parameter_list|)
block|{
return|return
operator|(
name|n
operator|>>>
literal|1
operator|)
operator|^
operator|-
operator|(
name|n
operator|&
literal|1
operator|)
return|;
block|}
comment|/**    * Decode a ZigZag-encoded 64-bit value. ZigZag encodes signed integers into values that can be    * efficiently encoded with varint. (Otherwise, negative values must be sign-extended to 64 bits    * to be varint encoded, thus always taking 10 bytes on the wire.)    *    * @param n An unsigned 64-bit integer, stored in a signed int because Java has no explicit    *     unsigned support.    * @return A signed 64-bit integer.    */
specifier|public
specifier|static
name|long
name|decodeZigZag64
parameter_list|(
specifier|final
name|long
name|n
parameter_list|)
block|{
return|return
operator|(
name|n
operator|>>>
literal|1
operator|)
operator|^
operator|-
operator|(
name|n
operator|&
literal|1
operator|)
return|;
block|}
comment|/**    * Like {@link #readRawVarint32(InputStream)}, but expects that the caller has already read one    * byte. This allows the caller to determine if EOF has been reached before attempting to read.    */
specifier|public
specifier|static
name|int
name|readRawVarint32
parameter_list|(
specifier|final
name|int
name|firstByte
parameter_list|,
specifier|final
name|InputStream
name|input
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|(
name|firstByte
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
return|return
name|firstByte
return|;
block|}
name|int
name|result
init|=
name|firstByte
operator|&
literal|0x7f
decl_stmt|;
name|int
name|offset
init|=
literal|7
decl_stmt|;
for|for
control|(
init|;
name|offset
operator|<
literal|32
condition|;
name|offset
operator|+=
literal|7
control|)
block|{
specifier|final
name|int
name|b
init|=
name|input
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|b
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
name|result
operator||=
operator|(
name|b
operator|&
literal|0x7f
operator|)
operator|<<
name|offset
expr_stmt|;
if|if
condition|(
operator|(
name|b
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
comment|// Keep reading up to 64 bits.
for|for
control|(
init|;
name|offset
operator|<
literal|64
condition|;
name|offset
operator|+=
literal|7
control|)
block|{
specifier|final
name|int
name|b
init|=
name|input
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|b
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
if|if
condition|(
operator|(
name|b
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|malformedVarint
argument_list|()
throw|;
block|}
comment|/**    * Reads a varint from the input one byte at a time, so that it does not read any bytes after the    * end of the varint. If you simply wrapped the stream in a CodedInputStream and used {@link    * #readRawVarint32(InputStream)} then you would probably end up reading past the end of the    * varint since CodedInputStream buffers its input.    */
specifier|static
name|int
name|readRawVarint32
parameter_list|(
specifier|final
name|InputStream
name|input
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|firstByte
init|=
name|input
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|firstByte
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
return|return
name|readRawVarint32
argument_list|(
name|firstByte
argument_list|,
name|input
argument_list|)
return|;
block|}
comment|/** A {@link CodedInputStream} implementation that uses a backing array as the input. */
specifier|private
specifier|static
specifier|final
class|class
name|ArrayDecoder
extends|extends
name|CodedInputStream
block|{
specifier|private
specifier|final
name|byte
index|[]
name|buffer
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|immutable
decl_stmt|;
specifier|private
name|int
name|limit
decl_stmt|;
specifier|private
name|int
name|bufferSizeAfterLimit
decl_stmt|;
specifier|private
name|int
name|pos
decl_stmt|;
specifier|private
name|int
name|startPos
decl_stmt|;
specifier|private
name|int
name|lastTag
decl_stmt|;
specifier|private
name|boolean
name|enableAliasing
decl_stmt|;
comment|/** The absolute position of the end of the current message. */
specifier|private
name|int
name|currentLimit
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
specifier|private
name|ArrayDecoder
parameter_list|(
specifier|final
name|byte
index|[]
name|buffer
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|len
parameter_list|,
name|boolean
name|immutable
parameter_list|)
block|{
name|this
operator|.
name|buffer
operator|=
name|buffer
expr_stmt|;
name|limit
operator|=
name|offset
operator|+
name|len
expr_stmt|;
name|pos
operator|=
name|offset
expr_stmt|;
name|startPos
operator|=
name|pos
expr_stmt|;
name|this
operator|.
name|immutable
operator|=
name|immutable
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readTag
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|isAtEnd
argument_list|()
condition|)
block|{
name|lastTag
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lastTag
operator|=
name|readRawVarint32
argument_list|()
expr_stmt|;
if|if
condition|(
name|WireFormat
operator|.
name|getTagFieldNumber
argument_list|(
name|lastTag
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// If we actually read zero (or any tag number corresponding to field
comment|// number zero), that's not a valid tag.
throw|throw
name|InvalidProtocolBufferException
operator|.
name|invalidTag
argument_list|()
throw|;
block|}
return|return
name|lastTag
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|checkLastTagWas
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|InvalidProtocolBufferException
block|{
if|if
condition|(
name|lastTag
operator|!=
name|value
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|invalidEndTag
argument_list|()
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|getLastTag
parameter_list|()
block|{
return|return
name|lastTag
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|skipField
parameter_list|(
specifier|final
name|int
name|tag
parameter_list|)
throws|throws
name|IOException
block|{
switch|switch
condition|(
name|WireFormat
operator|.
name|getTagWireType
argument_list|(
name|tag
argument_list|)
condition|)
block|{
case|case
name|WireFormat
operator|.
name|WIRETYPE_VARINT
case|:
name|skipRawVarint
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
case|case
name|WireFormat
operator|.
name|WIRETYPE_FIXED64
case|:
name|skipRawBytes
argument_list|(
name|FIXED_64_SIZE
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
case|:
name|skipRawBytes
argument_list|(
name|readRawVarint32
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
name|WireFormat
operator|.
name|WIRETYPE_START_GROUP
case|:
name|skipMessage
argument_list|()
expr_stmt|;
name|checkLastTagWas
argument_list|(
name|WireFormat
operator|.
name|makeTag
argument_list|(
name|WireFormat
operator|.
name|getTagFieldNumber
argument_list|(
name|tag
argument_list|)
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
case|:
return|return
literal|false
return|;
case|case
name|WireFormat
operator|.
name|WIRETYPE_FIXED32
case|:
name|skipRawBytes
argument_list|(
name|FIXED_32_SIZE
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
default|default:
throw|throw
name|InvalidProtocolBufferException
operator|.
name|invalidWireType
argument_list|()
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|skipField
parameter_list|(
specifier|final
name|int
name|tag
parameter_list|,
specifier|final
name|CodedOutputStream
name|output
parameter_list|)
throws|throws
name|IOException
block|{
switch|switch
condition|(
name|WireFormat
operator|.
name|getTagWireType
argument_list|(
name|tag
argument_list|)
condition|)
block|{
case|case
name|WireFormat
operator|.
name|WIRETYPE_VARINT
case|:
block|{
name|long
name|value
init|=
name|readInt64
argument_list|()
decl_stmt|;
name|output
operator|.
name|writeRawVarint32
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|output
operator|.
name|writeUInt64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
case|case
name|WireFormat
operator|.
name|WIRETYPE_FIXED64
case|:
block|{
name|long
name|value
init|=
name|readRawLittleEndian64
argument_list|()
decl_stmt|;
name|output
operator|.
name|writeRawVarint32
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|output
operator|.
name|writeFixed64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
case|case
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
case|:
block|{
name|ByteString
name|value
init|=
name|readBytes
argument_list|()
decl_stmt|;
name|output
operator|.
name|writeRawVarint32
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|output
operator|.
name|writeBytesNoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
case|case
name|WireFormat
operator|.
name|WIRETYPE_START_GROUP
case|:
block|{
name|output
operator|.
name|writeRawVarint32
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|skipMessage
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|int
name|endtag
init|=
name|WireFormat
operator|.
name|makeTag
argument_list|(
name|WireFormat
operator|.
name|getTagFieldNumber
argument_list|(
name|tag
argument_list|)
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
argument_list|)
decl_stmt|;
name|checkLastTagWas
argument_list|(
name|endtag
argument_list|)
expr_stmt|;
name|output
operator|.
name|writeRawVarint32
argument_list|(
name|endtag
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
case|case
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
case|:
block|{
return|return
literal|false
return|;
block|}
case|case
name|WireFormat
operator|.
name|WIRETYPE_FIXED32
case|:
block|{
name|int
name|value
init|=
name|readRawLittleEndian32
argument_list|()
decl_stmt|;
name|output
operator|.
name|writeRawVarint32
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|output
operator|.
name|writeFixed32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
default|default:
throw|throw
name|InvalidProtocolBufferException
operator|.
name|invalidWireType
argument_list|()
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|skipMessage
parameter_list|()
throws|throws
name|IOException
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|tag
init|=
name|readTag
argument_list|()
decl_stmt|;
if|if
condition|(
name|tag
operator|==
literal|0
operator|||
operator|!
name|skipField
argument_list|(
name|tag
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|skipMessage
parameter_list|(
name|CodedOutputStream
name|output
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|tag
init|=
name|readTag
argument_list|()
decl_stmt|;
if|if
condition|(
name|tag
operator|==
literal|0
operator|||
operator|!
name|skipField
argument_list|(
name|tag
argument_list|,
name|output
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
block|}
comment|// -----------------------------------------------------------------
annotation|@
name|Override
specifier|public
name|double
name|readDouble
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|Double
operator|.
name|longBitsToDouble
argument_list|(
name|readRawLittleEndian64
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|float
name|readFloat
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|Float
operator|.
name|intBitsToFloat
argument_list|(
name|readRawLittleEndian32
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readUInt64
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawVarint64
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readInt64
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawVarint64
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readInt32
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawVarint32
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readFixed64
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawLittleEndian64
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readFixed32
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawLittleEndian32
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|readBool
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawVarint64
argument_list|()
operator|!=
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|readString
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|size
init|=
name|readRawVarint32
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|<=
operator|(
name|limit
operator|-
name|pos
operator|)
condition|)
block|{
comment|// Fast path:  We already have the bytes in a contiguous buffer, so
comment|//   just copy directly from it.
specifier|final
name|String
name|result
init|=
operator|new
name|String
argument_list|(
name|buffer
argument_list|,
name|pos
argument_list|,
name|size
argument_list|,
name|UTF_8
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|size
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
literal|""
return|;
block|}
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|negativeSize
argument_list|()
throw|;
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|readStringRequireUtf8
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|size
init|=
name|readRawVarint32
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|<=
operator|(
name|limit
operator|-
name|pos
operator|)
condition|)
block|{
comment|// TODO(martinrb): We could save a pass by validating while decoding.
if|if
condition|(
operator|!
name|Utf8
operator|.
name|isValidUtf8
argument_list|(
name|buffer
argument_list|,
name|pos
argument_list|,
name|pos
operator|+
name|size
argument_list|)
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|invalidUtf8
argument_list|()
throw|;
block|}
specifier|final
name|int
name|tempPos
init|=
name|pos
decl_stmt|;
name|pos
operator|+=
name|size
expr_stmt|;
return|return
operator|new
name|String
argument_list|(
name|buffer
argument_list|,
name|tempPos
argument_list|,
name|size
argument_list|,
name|UTF_8
argument_list|)
return|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
literal|""
return|;
block|}
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|negativeSize
argument_list|()
throw|;
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readGroup
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|MessageLite
operator|.
name|Builder
name|builder
parameter_list|,
specifier|final
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|recursionDepth
operator|>=
name|recursionLimit
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|recursionLimitExceeded
argument_list|()
throw|;
block|}
operator|++
name|recursionDepth
expr_stmt|;
name|builder
operator|.
name|mergeFrom
argument_list|(
name|this
argument_list|,
name|extensionRegistry
argument_list|)
expr_stmt|;
name|checkLastTagWas
argument_list|(
name|WireFormat
operator|.
name|makeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|recursionDepth
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|MessageLite
parameter_list|>
name|T
name|readGroup
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|Parser
argument_list|<
name|T
argument_list|>
name|parser
parameter_list|,
specifier|final
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|recursionDepth
operator|>=
name|recursionLimit
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|recursionLimitExceeded
argument_list|()
throw|;
block|}
operator|++
name|recursionDepth
expr_stmt|;
name|T
name|result
init|=
name|parser
operator|.
name|parsePartialFrom
argument_list|(
name|this
argument_list|,
name|extensionRegistry
argument_list|)
decl_stmt|;
name|checkLastTagWas
argument_list|(
name|WireFormat
operator|.
name|makeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|recursionDepth
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Deprecated
annotation|@
name|Override
specifier|public
name|void
name|readUnknownGroup
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|MessageLite
operator|.
name|Builder
name|builder
parameter_list|)
throws|throws
name|IOException
block|{
name|readGroup
argument_list|(
name|fieldNumber
argument_list|,
name|builder
argument_list|,
name|ExtensionRegistryLite
operator|.
name|getEmptyRegistry
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readMessage
parameter_list|(
specifier|final
name|MessageLite
operator|.
name|Builder
name|builder
parameter_list|,
specifier|final
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|length
init|=
name|readRawVarint32
argument_list|()
decl_stmt|;
if|if
condition|(
name|recursionDepth
operator|>=
name|recursionLimit
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|recursionLimitExceeded
argument_list|()
throw|;
block|}
specifier|final
name|int
name|oldLimit
init|=
name|pushLimit
argument_list|(
name|length
argument_list|)
decl_stmt|;
operator|++
name|recursionDepth
expr_stmt|;
name|builder
operator|.
name|mergeFrom
argument_list|(
name|this
argument_list|,
name|extensionRegistry
argument_list|)
expr_stmt|;
name|checkLastTagWas
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|--
name|recursionDepth
expr_stmt|;
name|popLimit
argument_list|(
name|oldLimit
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|MessageLite
parameter_list|>
name|T
name|readMessage
parameter_list|(
specifier|final
name|Parser
argument_list|<
name|T
argument_list|>
name|parser
parameter_list|,
specifier|final
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|length
init|=
name|readRawVarint32
argument_list|()
decl_stmt|;
if|if
condition|(
name|recursionDepth
operator|>=
name|recursionLimit
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|recursionLimitExceeded
argument_list|()
throw|;
block|}
specifier|final
name|int
name|oldLimit
init|=
name|pushLimit
argument_list|(
name|length
argument_list|)
decl_stmt|;
operator|++
name|recursionDepth
expr_stmt|;
name|T
name|result
init|=
name|parser
operator|.
name|parsePartialFrom
argument_list|(
name|this
argument_list|,
name|extensionRegistry
argument_list|)
decl_stmt|;
name|checkLastTagWas
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|--
name|recursionDepth
expr_stmt|;
name|popLimit
argument_list|(
name|oldLimit
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|ByteString
name|readBytes
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|size
init|=
name|readRawVarint32
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|<=
operator|(
name|limit
operator|-
name|pos
operator|)
condition|)
block|{
comment|// Fast path:  We already have the bytes in a contiguous buffer, so
comment|//   just copy directly from it.
specifier|final
name|ByteString
name|result
init|=
name|immutable
operator|&&
name|enableAliasing
condition|?
name|ByteString
operator|.
name|wrap
argument_list|(
name|buffer
argument_list|,
name|pos
argument_list|,
name|size
argument_list|)
else|:
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|buffer
argument_list|,
name|pos
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|size
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
name|ByteString
operator|.
name|EMPTY
return|;
block|}
comment|// Slow path:  Build a byte array first then copy it.
return|return
name|ByteString
operator|.
name|wrap
argument_list|(
name|readRawBytes
argument_list|(
name|size
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|readByteArray
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|size
init|=
name|readRawVarint32
argument_list|()
decl_stmt|;
return|return
name|readRawBytes
argument_list|(
name|size
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|ByteBuffer
name|readByteBuffer
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|size
init|=
name|readRawVarint32
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|<=
operator|(
name|limit
operator|-
name|pos
operator|)
condition|)
block|{
comment|// Fast path: We already have the bytes in a contiguous buffer.
comment|// When aliasing is enabled, we can return a ByteBuffer pointing directly
comment|// into the underlying byte array without copy if the CodedInputStream is
comment|// constructed from a byte array. If aliasing is disabled or the input is
comment|// from an InputStream or ByteString, we have to make a copy of the bytes.
name|ByteBuffer
name|result
init|=
operator|!
name|immutable
operator|&&
name|enableAliasing
condition|?
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|buffer
argument_list|,
name|pos
argument_list|,
name|size
argument_list|)
operator|.
name|slice
argument_list|()
else|:
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|buffer
argument_list|,
name|pos
argument_list|,
name|pos
operator|+
name|size
argument_list|)
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|size
expr_stmt|;
comment|// TODO(nathanmittler): Investigate making the ByteBuffer be made read-only
return|return
name|result
return|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
name|EMPTY_BYTE_BUFFER
return|;
block|}
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|negativeSize
argument_list|()
throw|;
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readUInt32
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawVarint32
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readEnum
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawVarint32
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readSFixed32
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawLittleEndian32
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readSFixed64
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawLittleEndian64
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readSInt32
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|decodeZigZag32
argument_list|(
name|readRawVarint32
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readSInt64
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|decodeZigZag64
argument_list|(
name|readRawVarint64
argument_list|()
argument_list|)
return|;
block|}
comment|// =================================================================
annotation|@
name|Override
specifier|public
name|int
name|readRawVarint32
parameter_list|()
throws|throws
name|IOException
block|{
comment|// See implementation notes for readRawVarint64
name|fastpath
label|:
block|{
name|int
name|tempPos
init|=
name|pos
decl_stmt|;
if|if
condition|(
name|limit
operator|==
name|tempPos
condition|)
block|{
break|break
name|fastpath
break|;
block|}
specifier|final
name|byte
index|[]
name|buffer
init|=
name|this
operator|.
name|buffer
decl_stmt|;
name|int
name|x
decl_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|)
operator|>=
literal|0
condition|)
block|{
name|pos
operator|=
name|tempPos
expr_stmt|;
return|return
name|x
return|;
block|}
elseif|else
if|if
condition|(
name|limit
operator|-
name|tempPos
operator|<
literal|9
condition|)
block|{
break|break
name|fastpath
break|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|^=
operator|(
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<<
literal|7
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|^=
operator|(
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<<
literal|14
operator|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|14
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|^=
operator|(
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<<
literal|21
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|21
operator|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|y
init|=
name|buffer
index|[
name|tempPos
operator|++
index|]
decl_stmt|;
name|x
operator|^=
name|y
operator|<<
literal|28
expr_stmt|;
name|x
operator|^=
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|21
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|28
operator|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
operator|&&
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<
literal|0
operator|&&
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<
literal|0
operator|&&
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<
literal|0
operator|&&
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<
literal|0
operator|&&
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<
literal|0
condition|)
block|{
break|break
name|fastpath
break|;
comment|// Will throw malformedVarint()
block|}
block|}
name|pos
operator|=
name|tempPos
expr_stmt|;
return|return
name|x
return|;
block|}
return|return
operator|(
name|int
operator|)
name|readRawVarint64SlowPath
argument_list|()
return|;
block|}
specifier|private
name|void
name|skipRawVarint
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|limit
operator|-
name|pos
operator|>=
name|MAX_VARINT_SIZE
condition|)
block|{
name|skipRawVarintFastPath
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|skipRawVarintSlowPath
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|skipRawVarintFastPath
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VARINT_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|buffer
index|[
name|pos
operator|++
index|]
operator|>=
literal|0
condition|)
block|{
return|return;
block|}
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|malformedVarint
argument_list|()
throw|;
block|}
specifier|private
name|void
name|skipRawVarintSlowPath
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VARINT_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|readRawByte
argument_list|()
operator|>=
literal|0
condition|)
block|{
return|return;
block|}
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|malformedVarint
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readRawVarint64
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Implementation notes:
comment|//
comment|// Optimized for one-byte values, expected to be common.
comment|// The particular code below was selected from various candidates
comment|// empirically, by winning VarintBenchmark.
comment|//
comment|// Sign extension of (signed) Java bytes is usually a nuisance, but
comment|// we exploit it here to more easily obtain the sign of bytes read.
comment|// Instead of cleaning up the sign extension bits by masking eagerly,
comment|// we delay until we find the final (positive) byte, when we clear all
comment|// accumulated bits with one xor.  We depend on javac to constant fold.
name|fastpath
label|:
block|{
name|int
name|tempPos
init|=
name|pos
decl_stmt|;
if|if
condition|(
name|limit
operator|==
name|tempPos
condition|)
block|{
break|break
name|fastpath
break|;
block|}
specifier|final
name|byte
index|[]
name|buffer
init|=
name|this
operator|.
name|buffer
decl_stmt|;
name|long
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|)
operator|>=
literal|0
condition|)
block|{
name|pos
operator|=
name|tempPos
expr_stmt|;
return|return
name|y
return|;
block|}
elseif|else
if|if
condition|(
name|limit
operator|-
name|tempPos
operator|<
literal|9
condition|)
block|{
break|break
name|fastpath
break|;
block|}
elseif|else
if|if
condition|(
operator|(
name|y
operator|^=
operator|(
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<<
literal|7
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
name|x
operator|=
name|y
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|y
operator|^=
operator|(
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<<
literal|14
operator|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|x
operator|=
name|y
operator|^
operator|(
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|14
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|y
operator|^=
operator|(
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<<
literal|21
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
name|x
operator|=
name|y
operator|^
operator|(
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|21
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|=
name|y
operator|^
operator|(
operator|(
name|long
operator|)
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<<
literal|28
operator|)
operator|)
operator|>=
literal|0L
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0L
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|21
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|28
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|^=
operator|(
operator|(
name|long
operator|)
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<<
literal|35
operator|)
operator|)
operator|<
literal|0L
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0L
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|21
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|28
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|35
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|^=
operator|(
operator|(
name|long
operator|)
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<<
literal|42
operator|)
operator|)
operator|>=
literal|0L
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0L
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|21
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|28
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|35
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|42
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|^=
operator|(
operator|(
name|long
operator|)
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<<
literal|49
operator|)
operator|)
operator|<
literal|0L
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0L
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|21
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|28
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|35
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|42
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|49
operator|)
expr_stmt|;
block|}
else|else
block|{
name|x
operator|^=
operator|(
operator|(
name|long
operator|)
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<<
literal|56
operator|)
expr_stmt|;
name|x
operator|^=
operator|(
operator|~
literal|0L
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|21
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|28
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|35
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|42
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|49
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|56
operator|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0L
condition|)
block|{
if|if
condition|(
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<
literal|0L
condition|)
block|{
break|break
name|fastpath
break|;
comment|// Will throw malformedVarint()
block|}
block|}
block|}
name|pos
operator|=
name|tempPos
expr_stmt|;
return|return
name|x
return|;
block|}
return|return
name|readRawVarint64SlowPath
argument_list|()
return|;
block|}
annotation|@
name|Override
name|long
name|readRawVarint64SlowPath
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|result
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|shift
init|=
literal|0
init|;
name|shift
operator|<
literal|64
condition|;
name|shift
operator|+=
literal|7
control|)
block|{
specifier|final
name|byte
name|b
init|=
name|readRawByte
argument_list|()
decl_stmt|;
name|result
operator||=
call|(
name|long
call|)
argument_list|(
name|b
operator|&
literal|0x7F
argument_list|)
operator|<<
name|shift
expr_stmt|;
if|if
condition|(
operator|(
name|b
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|malformedVarint
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readRawLittleEndian32
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|tempPos
init|=
name|pos
decl_stmt|;
if|if
condition|(
name|limit
operator|-
name|tempPos
operator|<
name|FIXED_32_SIZE
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
specifier|final
name|byte
index|[]
name|buffer
init|=
name|this
operator|.
name|buffer
decl_stmt|;
name|pos
operator|=
name|tempPos
operator|+
name|FIXED_32_SIZE
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|buffer
index|[
name|tempPos
index|]
operator|&
literal|0xff
operator|)
operator|)
operator||
operator|(
operator|(
name|buffer
index|[
name|tempPos
operator|+
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|buffer
index|[
name|tempPos
operator|+
literal|2
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|buffer
index|[
name|tempPos
operator|+
literal|3
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readRawLittleEndian64
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|tempPos
init|=
name|pos
decl_stmt|;
if|if
condition|(
name|limit
operator|-
name|tempPos
operator|<
name|FIXED_64_SIZE
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
specifier|final
name|byte
index|[]
name|buffer
init|=
name|this
operator|.
name|buffer
decl_stmt|;
name|pos
operator|=
name|tempPos
operator|+
name|FIXED_64_SIZE
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|buffer
index|[
name|tempPos
index|]
operator|&
literal|0xffL
operator|)
operator|)
operator||
operator|(
operator|(
name|buffer
index|[
name|tempPos
operator|+
literal|1
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|buffer
index|[
name|tempPos
operator|+
literal|2
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|buffer
index|[
name|tempPos
operator|+
literal|3
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|buffer
index|[
name|tempPos
operator|+
literal|4
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|buffer
index|[
name|tempPos
operator|+
literal|5
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
name|buffer
index|[
name|tempPos
operator|+
literal|6
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
name|buffer
index|[
name|tempPos
operator|+
literal|7
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|56
operator|)
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|enableAliasing
parameter_list|(
name|boolean
name|enabled
parameter_list|)
block|{
name|this
operator|.
name|enableAliasing
operator|=
name|enabled
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|resetSizeCounter
parameter_list|()
block|{
name|startPos
operator|=
name|pos
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|pushLimit
parameter_list|(
name|int
name|byteLimit
parameter_list|)
throws|throws
name|InvalidProtocolBufferException
block|{
if|if
condition|(
name|byteLimit
operator|<
literal|0
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|negativeSize
argument_list|()
throw|;
block|}
name|byteLimit
operator|+=
name|getTotalBytesRead
argument_list|()
expr_stmt|;
specifier|final
name|int
name|oldLimit
init|=
name|currentLimit
decl_stmt|;
if|if
condition|(
name|byteLimit
operator|>
name|oldLimit
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
name|currentLimit
operator|=
name|byteLimit
expr_stmt|;
name|recomputeBufferSizeAfterLimit
argument_list|()
expr_stmt|;
return|return
name|oldLimit
return|;
block|}
specifier|private
name|void
name|recomputeBufferSizeAfterLimit
parameter_list|()
block|{
name|limit
operator|+=
name|bufferSizeAfterLimit
expr_stmt|;
specifier|final
name|int
name|bufferEnd
init|=
name|limit
operator|-
name|startPos
decl_stmt|;
if|if
condition|(
name|bufferEnd
operator|>
name|currentLimit
condition|)
block|{
comment|// Limit is in current buffer.
name|bufferSizeAfterLimit
operator|=
name|bufferEnd
operator|-
name|currentLimit
expr_stmt|;
name|limit
operator|-=
name|bufferSizeAfterLimit
expr_stmt|;
block|}
else|else
block|{
name|bufferSizeAfterLimit
operator|=
literal|0
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|popLimit
parameter_list|(
specifier|final
name|int
name|oldLimit
parameter_list|)
block|{
name|currentLimit
operator|=
name|oldLimit
expr_stmt|;
name|recomputeBufferSizeAfterLimit
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getBytesUntilLimit
parameter_list|()
block|{
if|if
condition|(
name|currentLimit
operator|==
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
name|currentLimit
operator|-
name|getTotalBytesRead
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isAtEnd
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|pos
operator|==
name|limit
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getTotalBytesRead
parameter_list|()
block|{
return|return
name|pos
operator|-
name|startPos
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
name|readRawByte
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|pos
operator|==
name|limit
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
return|return
name|buffer
index|[
name|pos
operator|++
index|]
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|readRawBytes
parameter_list|(
specifier|final
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|length
operator|>
literal|0
operator|&&
name|length
operator|<=
operator|(
name|limit
operator|-
name|pos
operator|)
condition|)
block|{
specifier|final
name|int
name|tempPos
init|=
name|pos
decl_stmt|;
name|pos
operator|+=
name|length
expr_stmt|;
return|return
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|buffer
argument_list|,
name|tempPos
argument_list|,
name|pos
argument_list|)
return|;
block|}
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|Internal
operator|.
name|EMPTY_BYTE_ARRAY
return|;
block|}
else|else
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|negativeSize
argument_list|()
throw|;
block|}
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|skipRawBytes
parameter_list|(
specifier|final
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|length
operator|>=
literal|0
operator|&&
name|length
operator|<=
operator|(
name|limit
operator|-
name|pos
operator|)
condition|)
block|{
comment|// We have all the bytes we need already.
name|pos
operator|+=
name|length
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|negativeSize
argument_list|()
throw|;
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
block|}
comment|/**    * A {@link CodedInputStream} implementation that uses a backing direct ByteBuffer as the input.    * Requires the use of {@code sun.misc.Unsafe} to perform fast reads on the buffer.    */
specifier|private
specifier|static
specifier|final
class|class
name|UnsafeDirectNioDecoder
extends|extends
name|CodedInputStream
block|{
comment|/** The direct buffer that is backing this stream. */
specifier|private
specifier|final
name|ByteBuffer
name|buffer
decl_stmt|;
comment|/**      * If {@code true}, indicates that the buffer is backing a {@link ByteString} and is therefore      * considered to be an immutable input source.      */
specifier|private
specifier|final
name|boolean
name|immutable
decl_stmt|;
comment|/** The unsafe address of the content of {@link #buffer}. */
specifier|private
specifier|final
name|long
name|address
decl_stmt|;
comment|/** The unsafe address of the current read limit of the buffer. */
specifier|private
name|long
name|limit
decl_stmt|;
comment|/** The unsafe address of the current read position of the buffer. */
specifier|private
name|long
name|pos
decl_stmt|;
comment|/** The unsafe address of the starting read position. */
specifier|private
name|long
name|startPos
decl_stmt|;
comment|/** The amount of available data in the buffer beyond {@link #limit}. */
specifier|private
name|int
name|bufferSizeAfterLimit
decl_stmt|;
comment|/** The last tag that was read from this stream. */
specifier|private
name|int
name|lastTag
decl_stmt|;
comment|/**      * If {@code true}, indicates that calls to read {@link ByteString} or {@code byte[]}      *<strong>may</strong> return slices of the underlying buffer, rather than copies.      */
specifier|private
name|boolean
name|enableAliasing
decl_stmt|;
comment|/** The absolute position of the end of the current message. */
specifier|private
name|int
name|currentLimit
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
specifier|static
name|boolean
name|isSupported
parameter_list|()
block|{
return|return
name|UnsafeUtil
operator|.
name|hasUnsafeByteBufferOperations
argument_list|()
return|;
block|}
specifier|private
name|UnsafeDirectNioDecoder
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|,
name|boolean
name|immutable
parameter_list|)
block|{
name|this
operator|.
name|buffer
operator|=
name|buffer
expr_stmt|;
name|address
operator|=
name|UnsafeUtil
operator|.
name|addressOffset
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|limit
operator|=
name|address
operator|+
name|buffer
operator|.
name|limit
argument_list|()
expr_stmt|;
name|pos
operator|=
name|address
operator|+
name|buffer
operator|.
name|position
argument_list|()
expr_stmt|;
name|startPos
operator|=
name|pos
expr_stmt|;
name|this
operator|.
name|immutable
operator|=
name|immutable
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readTag
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|isAtEnd
argument_list|()
condition|)
block|{
name|lastTag
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lastTag
operator|=
name|readRawVarint32
argument_list|()
expr_stmt|;
if|if
condition|(
name|WireFormat
operator|.
name|getTagFieldNumber
argument_list|(
name|lastTag
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// If we actually read zero (or any tag number corresponding to field
comment|// number zero), that's not a valid tag.
throw|throw
name|InvalidProtocolBufferException
operator|.
name|invalidTag
argument_list|()
throw|;
block|}
return|return
name|lastTag
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|checkLastTagWas
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|InvalidProtocolBufferException
block|{
if|if
condition|(
name|lastTag
operator|!=
name|value
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|invalidEndTag
argument_list|()
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|getLastTag
parameter_list|()
block|{
return|return
name|lastTag
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|skipField
parameter_list|(
specifier|final
name|int
name|tag
parameter_list|)
throws|throws
name|IOException
block|{
switch|switch
condition|(
name|WireFormat
operator|.
name|getTagWireType
argument_list|(
name|tag
argument_list|)
condition|)
block|{
case|case
name|WireFormat
operator|.
name|WIRETYPE_VARINT
case|:
name|skipRawVarint
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
case|case
name|WireFormat
operator|.
name|WIRETYPE_FIXED64
case|:
name|skipRawBytes
argument_list|(
name|FIXED_64_SIZE
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
case|:
name|skipRawBytes
argument_list|(
name|readRawVarint32
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
name|WireFormat
operator|.
name|WIRETYPE_START_GROUP
case|:
name|skipMessage
argument_list|()
expr_stmt|;
name|checkLastTagWas
argument_list|(
name|WireFormat
operator|.
name|makeTag
argument_list|(
name|WireFormat
operator|.
name|getTagFieldNumber
argument_list|(
name|tag
argument_list|)
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
case|:
return|return
literal|false
return|;
case|case
name|WireFormat
operator|.
name|WIRETYPE_FIXED32
case|:
name|skipRawBytes
argument_list|(
name|FIXED_32_SIZE
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
default|default:
throw|throw
name|InvalidProtocolBufferException
operator|.
name|invalidWireType
argument_list|()
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|skipField
parameter_list|(
specifier|final
name|int
name|tag
parameter_list|,
specifier|final
name|CodedOutputStream
name|output
parameter_list|)
throws|throws
name|IOException
block|{
switch|switch
condition|(
name|WireFormat
operator|.
name|getTagWireType
argument_list|(
name|tag
argument_list|)
condition|)
block|{
case|case
name|WireFormat
operator|.
name|WIRETYPE_VARINT
case|:
block|{
name|long
name|value
init|=
name|readInt64
argument_list|()
decl_stmt|;
name|output
operator|.
name|writeRawVarint32
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|output
operator|.
name|writeUInt64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
case|case
name|WireFormat
operator|.
name|WIRETYPE_FIXED64
case|:
block|{
name|long
name|value
init|=
name|readRawLittleEndian64
argument_list|()
decl_stmt|;
name|output
operator|.
name|writeRawVarint32
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|output
operator|.
name|writeFixed64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
case|case
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
case|:
block|{
name|ByteString
name|value
init|=
name|readBytes
argument_list|()
decl_stmt|;
name|output
operator|.
name|writeRawVarint32
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|output
operator|.
name|writeBytesNoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
case|case
name|WireFormat
operator|.
name|WIRETYPE_START_GROUP
case|:
block|{
name|output
operator|.
name|writeRawVarint32
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|skipMessage
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|int
name|endtag
init|=
name|WireFormat
operator|.
name|makeTag
argument_list|(
name|WireFormat
operator|.
name|getTagFieldNumber
argument_list|(
name|tag
argument_list|)
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
argument_list|)
decl_stmt|;
name|checkLastTagWas
argument_list|(
name|endtag
argument_list|)
expr_stmt|;
name|output
operator|.
name|writeRawVarint32
argument_list|(
name|endtag
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
case|case
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
case|:
block|{
return|return
literal|false
return|;
block|}
case|case
name|WireFormat
operator|.
name|WIRETYPE_FIXED32
case|:
block|{
name|int
name|value
init|=
name|readRawLittleEndian32
argument_list|()
decl_stmt|;
name|output
operator|.
name|writeRawVarint32
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|output
operator|.
name|writeFixed32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
default|default:
throw|throw
name|InvalidProtocolBufferException
operator|.
name|invalidWireType
argument_list|()
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|skipMessage
parameter_list|()
throws|throws
name|IOException
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|tag
init|=
name|readTag
argument_list|()
decl_stmt|;
if|if
condition|(
name|tag
operator|==
literal|0
operator|||
operator|!
name|skipField
argument_list|(
name|tag
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|skipMessage
parameter_list|(
name|CodedOutputStream
name|output
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|tag
init|=
name|readTag
argument_list|()
decl_stmt|;
if|if
condition|(
name|tag
operator|==
literal|0
operator|||
operator|!
name|skipField
argument_list|(
name|tag
argument_list|,
name|output
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
block|}
comment|// -----------------------------------------------------------------
annotation|@
name|Override
specifier|public
name|double
name|readDouble
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|Double
operator|.
name|longBitsToDouble
argument_list|(
name|readRawLittleEndian64
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|float
name|readFloat
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|Float
operator|.
name|intBitsToFloat
argument_list|(
name|readRawLittleEndian32
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readUInt64
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawVarint64
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readInt64
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawVarint64
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readInt32
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawVarint32
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readFixed64
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawLittleEndian64
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readFixed32
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawLittleEndian32
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|readBool
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawVarint64
argument_list|()
operator|!=
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|readString
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|size
init|=
name|readRawVarint32
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|<=
name|remaining
argument_list|()
condition|)
block|{
comment|// TODO(nathanmittler): Is there a way to avoid this copy?
name|byte
index|[]
name|bytes
init|=
name|copyToArray
argument_list|(
name|pos
argument_list|,
name|pos
operator|+
name|size
argument_list|)
decl_stmt|;
name|String
name|result
init|=
operator|new
name|String
argument_list|(
name|bytes
argument_list|,
name|UTF_8
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|size
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
literal|""
return|;
block|}
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|negativeSize
argument_list|()
throw|;
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|readStringRequireUtf8
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|size
init|=
name|readRawVarint32
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|>=
literal|0
operator|&&
name|size
operator|<=
name|remaining
argument_list|()
condition|)
block|{
comment|// TODO(nathanmittler): Is there a way to avoid this copy?
name|byte
index|[]
name|bytes
init|=
name|copyToArray
argument_list|(
name|pos
argument_list|,
name|pos
operator|+
name|size
argument_list|)
decl_stmt|;
comment|// TODO(martinrb): We could save a pass by validating while decoding.
if|if
condition|(
operator|!
name|Utf8
operator|.
name|isValidUtf8
argument_list|(
name|bytes
argument_list|)
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|invalidUtf8
argument_list|()
throw|;
block|}
name|String
name|result
init|=
operator|new
name|String
argument_list|(
name|bytes
argument_list|,
name|UTF_8
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|size
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
literal|""
return|;
block|}
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|negativeSize
argument_list|()
throw|;
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readGroup
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|MessageLite
operator|.
name|Builder
name|builder
parameter_list|,
specifier|final
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|recursionDepth
operator|>=
name|recursionLimit
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|recursionLimitExceeded
argument_list|()
throw|;
block|}
operator|++
name|recursionDepth
expr_stmt|;
name|builder
operator|.
name|mergeFrom
argument_list|(
name|this
argument_list|,
name|extensionRegistry
argument_list|)
expr_stmt|;
name|checkLastTagWas
argument_list|(
name|WireFormat
operator|.
name|makeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|recursionDepth
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|MessageLite
parameter_list|>
name|T
name|readGroup
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|Parser
argument_list|<
name|T
argument_list|>
name|parser
parameter_list|,
specifier|final
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|recursionDepth
operator|>=
name|recursionLimit
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|recursionLimitExceeded
argument_list|()
throw|;
block|}
operator|++
name|recursionDepth
expr_stmt|;
name|T
name|result
init|=
name|parser
operator|.
name|parsePartialFrom
argument_list|(
name|this
argument_list|,
name|extensionRegistry
argument_list|)
decl_stmt|;
name|checkLastTagWas
argument_list|(
name|WireFormat
operator|.
name|makeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|recursionDepth
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Deprecated
annotation|@
name|Override
specifier|public
name|void
name|readUnknownGroup
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|MessageLite
operator|.
name|Builder
name|builder
parameter_list|)
throws|throws
name|IOException
block|{
name|readGroup
argument_list|(
name|fieldNumber
argument_list|,
name|builder
argument_list|,
name|ExtensionRegistryLite
operator|.
name|getEmptyRegistry
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readMessage
parameter_list|(
specifier|final
name|MessageLite
operator|.
name|Builder
name|builder
parameter_list|,
specifier|final
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|length
init|=
name|readRawVarint32
argument_list|()
decl_stmt|;
if|if
condition|(
name|recursionDepth
operator|>=
name|recursionLimit
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|recursionLimitExceeded
argument_list|()
throw|;
block|}
specifier|final
name|int
name|oldLimit
init|=
name|pushLimit
argument_list|(
name|length
argument_list|)
decl_stmt|;
operator|++
name|recursionDepth
expr_stmt|;
name|builder
operator|.
name|mergeFrom
argument_list|(
name|this
argument_list|,
name|extensionRegistry
argument_list|)
expr_stmt|;
name|checkLastTagWas
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|--
name|recursionDepth
expr_stmt|;
name|popLimit
argument_list|(
name|oldLimit
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|MessageLite
parameter_list|>
name|T
name|readMessage
parameter_list|(
specifier|final
name|Parser
argument_list|<
name|T
argument_list|>
name|parser
parameter_list|,
specifier|final
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|length
init|=
name|readRawVarint32
argument_list|()
decl_stmt|;
if|if
condition|(
name|recursionDepth
operator|>=
name|recursionLimit
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|recursionLimitExceeded
argument_list|()
throw|;
block|}
specifier|final
name|int
name|oldLimit
init|=
name|pushLimit
argument_list|(
name|length
argument_list|)
decl_stmt|;
operator|++
name|recursionDepth
expr_stmt|;
name|T
name|result
init|=
name|parser
operator|.
name|parsePartialFrom
argument_list|(
name|this
argument_list|,
name|extensionRegistry
argument_list|)
decl_stmt|;
name|checkLastTagWas
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|--
name|recursionDepth
expr_stmt|;
name|popLimit
argument_list|(
name|oldLimit
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|ByteString
name|readBytes
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|size
init|=
name|readRawVarint32
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|<=
name|remaining
argument_list|()
condition|)
block|{
name|ByteBuffer
name|result
decl_stmt|;
if|if
condition|(
name|immutable
operator|&&
name|enableAliasing
condition|)
block|{
name|result
operator|=
name|slice
argument_list|(
name|pos
argument_list|,
name|pos
operator|+
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|copy
argument_list|(
name|pos
argument_list|,
name|pos
operator|+
name|size
argument_list|)
expr_stmt|;
block|}
name|pos
operator|+=
name|size
expr_stmt|;
return|return
name|ByteString
operator|.
name|wrap
argument_list|(
name|result
argument_list|)
return|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
name|ByteString
operator|.
name|EMPTY
return|;
block|}
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|negativeSize
argument_list|()
throw|;
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|readByteArray
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawBytes
argument_list|(
name|readRawVarint32
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|ByteBuffer
name|readByteBuffer
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|size
init|=
name|readRawVarint32
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|<=
name|remaining
argument_list|()
condition|)
block|{
name|ByteBuffer
name|result
decl_stmt|;
comment|// "Immutable" implies that buffer is backing a ByteString.
comment|// Disallow slicing in this case to prevent the caller from modifying the contents
comment|// of the ByteString.
if|if
condition|(
operator|!
name|immutable
operator|&&
name|enableAliasing
condition|)
block|{
name|result
operator|=
name|slice
argument_list|(
name|pos
argument_list|,
name|pos
operator|+
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|copy
argument_list|(
name|pos
argument_list|,
name|pos
operator|+
name|size
argument_list|)
expr_stmt|;
block|}
name|pos
operator|+=
name|size
expr_stmt|;
comment|// TODO(nathanmittler): Investigate making the ByteBuffer be made read-only
return|return
name|result
return|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
name|EMPTY_BYTE_BUFFER
return|;
block|}
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|negativeSize
argument_list|()
throw|;
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readUInt32
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawVarint32
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readEnum
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawVarint32
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readSFixed32
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawLittleEndian32
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readSFixed64
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawLittleEndian64
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readSInt32
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|decodeZigZag32
argument_list|(
name|readRawVarint32
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readSInt64
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|decodeZigZag64
argument_list|(
name|readRawVarint64
argument_list|()
argument_list|)
return|;
block|}
comment|// =================================================================
annotation|@
name|Override
specifier|public
name|int
name|readRawVarint32
parameter_list|()
throws|throws
name|IOException
block|{
comment|// See implementation notes for readRawVarint64
name|fastpath
label|:
block|{
name|long
name|tempPos
init|=
name|pos
decl_stmt|;
if|if
condition|(
name|limit
operator|==
name|tempPos
condition|)
block|{
break|break
name|fastpath
break|;
block|}
name|int
name|x
decl_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|pos
operator|=
name|tempPos
expr_stmt|;
return|return
name|x
return|;
block|}
elseif|else
if|if
condition|(
name|limit
operator|-
name|tempPos
operator|<
literal|9
condition|)
block|{
break|break
name|fastpath
break|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|^=
operator|(
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<<
literal|7
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|^=
operator|(
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<<
literal|14
operator|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|14
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|^=
operator|(
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<<
literal|21
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|21
operator|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|y
init|=
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|++
argument_list|)
decl_stmt|;
name|x
operator|^=
name|y
operator|<<
literal|28
expr_stmt|;
name|x
operator|^=
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|21
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|28
operator|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
operator|&&
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<
literal|0
operator|&&
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<
literal|0
operator|&&
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<
literal|0
operator|&&
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<
literal|0
operator|&&
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<
literal|0
condition|)
block|{
break|break
name|fastpath
break|;
comment|// Will throw malformedVarint()
block|}
block|}
name|pos
operator|=
name|tempPos
expr_stmt|;
return|return
name|x
return|;
block|}
return|return
operator|(
name|int
operator|)
name|readRawVarint64SlowPath
argument_list|()
return|;
block|}
specifier|private
name|void
name|skipRawVarint
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|remaining
argument_list|()
operator|>=
name|MAX_VARINT_SIZE
condition|)
block|{
name|skipRawVarintFastPath
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|skipRawVarintSlowPath
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|skipRawVarintFastPath
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VARINT_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|pos
operator|++
argument_list|)
operator|>=
literal|0
condition|)
block|{
return|return;
block|}
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|malformedVarint
argument_list|()
throw|;
block|}
specifier|private
name|void
name|skipRawVarintSlowPath
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VARINT_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|readRawByte
argument_list|()
operator|>=
literal|0
condition|)
block|{
return|return;
block|}
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|malformedVarint
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readRawVarint64
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Implementation notes:
comment|//
comment|// Optimized for one-byte values, expected to be common.
comment|// The particular code below was selected from various candidates
comment|// empirically, by winning VarintBenchmark.
comment|//
comment|// Sign extension of (signed) Java bytes is usually a nuisance, but
comment|// we exploit it here to more easily obtain the sign of bytes read.
comment|// Instead of cleaning up the sign extension bits by masking eagerly,
comment|// we delay until we find the final (positive) byte, when we clear all
comment|// accumulated bits with one xor.  We depend on javac to constant fold.
name|fastpath
label|:
block|{
name|long
name|tempPos
init|=
name|pos
decl_stmt|;
if|if
condition|(
name|limit
operator|==
name|tempPos
condition|)
block|{
break|break
name|fastpath
break|;
block|}
name|long
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|pos
operator|=
name|tempPos
expr_stmt|;
return|return
name|y
return|;
block|}
elseif|else
if|if
condition|(
name|limit
operator|-
name|tempPos
operator|<
literal|9
condition|)
block|{
break|break
name|fastpath
break|;
block|}
elseif|else
if|if
condition|(
operator|(
name|y
operator|^=
operator|(
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<<
literal|7
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
name|x
operator|=
name|y
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|y
operator|^=
operator|(
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<<
literal|14
operator|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|x
operator|=
name|y
operator|^
operator|(
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|14
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|y
operator|^=
operator|(
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<<
literal|21
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
name|x
operator|=
name|y
operator|^
operator|(
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|21
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|=
name|y
operator|^
operator|(
operator|(
name|long
operator|)
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<<
literal|28
operator|)
operator|)
operator|>=
literal|0L
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0L
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|21
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|28
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|^=
operator|(
operator|(
name|long
operator|)
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<<
literal|35
operator|)
operator|)
operator|<
literal|0L
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0L
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|21
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|28
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|35
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|^=
operator|(
operator|(
name|long
operator|)
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<<
literal|42
operator|)
operator|)
operator|>=
literal|0L
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0L
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|21
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|28
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|35
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|42
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|^=
operator|(
operator|(
name|long
operator|)
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<<
literal|49
operator|)
operator|)
operator|<
literal|0L
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0L
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|21
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|28
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|35
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|42
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|49
operator|)
expr_stmt|;
block|}
else|else
block|{
name|x
operator|^=
operator|(
operator|(
name|long
operator|)
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<<
literal|56
operator|)
expr_stmt|;
name|x
operator|^=
operator|(
operator|~
literal|0L
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|21
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|28
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|35
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|42
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|49
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|56
operator|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0L
condition|)
block|{
if|if
condition|(
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<
literal|0L
condition|)
block|{
break|break
name|fastpath
break|;
comment|// Will throw malformedVarint()
block|}
block|}
block|}
name|pos
operator|=
name|tempPos
expr_stmt|;
return|return
name|x
return|;
block|}
return|return
name|readRawVarint64SlowPath
argument_list|()
return|;
block|}
annotation|@
name|Override
name|long
name|readRawVarint64SlowPath
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|result
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|shift
init|=
literal|0
init|;
name|shift
operator|<
literal|64
condition|;
name|shift
operator|+=
literal|7
control|)
block|{
specifier|final
name|byte
name|b
init|=
name|readRawByte
argument_list|()
decl_stmt|;
name|result
operator||=
call|(
name|long
call|)
argument_list|(
name|b
operator|&
literal|0x7F
argument_list|)
operator|<<
name|shift
expr_stmt|;
if|if
condition|(
operator|(
name|b
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|malformedVarint
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readRawLittleEndian32
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|tempPos
init|=
name|pos
decl_stmt|;
if|if
condition|(
name|limit
operator|-
name|tempPos
operator|<
name|FIXED_32_SIZE
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
name|pos
operator|=
name|tempPos
operator|+
name|FIXED_32_SIZE
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
argument_list|)
operator|&
literal|0xff
operator|)
operator|)
operator||
operator|(
operator|(
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|+
literal|1
argument_list|)
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|+
literal|2
argument_list|)
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|+
literal|3
argument_list|)
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readRawLittleEndian64
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|tempPos
init|=
name|pos
decl_stmt|;
if|if
condition|(
name|limit
operator|-
name|tempPos
operator|<
name|FIXED_64_SIZE
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
name|pos
operator|=
name|tempPos
operator|+
name|FIXED_64_SIZE
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
argument_list|)
operator|&
literal|0xffL
operator|)
operator|)
operator||
operator|(
operator|(
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|+
literal|1
argument_list|)
operator|&
literal|0xffL
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|+
literal|2
argument_list|)
operator|&
literal|0xffL
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|+
literal|3
argument_list|)
operator|&
literal|0xffL
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|+
literal|4
argument_list|)
operator|&
literal|0xffL
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|+
literal|5
argument_list|)
operator|&
literal|0xffL
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|+
literal|6
argument_list|)
operator|&
literal|0xffL
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|tempPos
operator|+
literal|7
argument_list|)
operator|&
literal|0xffL
operator|)
operator|<<
literal|56
operator|)
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|enableAliasing
parameter_list|(
name|boolean
name|enabled
parameter_list|)
block|{
name|this
operator|.
name|enableAliasing
operator|=
name|enabled
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|resetSizeCounter
parameter_list|()
block|{
name|startPos
operator|=
name|pos
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|pushLimit
parameter_list|(
name|int
name|byteLimit
parameter_list|)
throws|throws
name|InvalidProtocolBufferException
block|{
if|if
condition|(
name|byteLimit
operator|<
literal|0
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|negativeSize
argument_list|()
throw|;
block|}
name|byteLimit
operator|+=
name|getTotalBytesRead
argument_list|()
expr_stmt|;
specifier|final
name|int
name|oldLimit
init|=
name|currentLimit
decl_stmt|;
if|if
condition|(
name|byteLimit
operator|>
name|oldLimit
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
name|currentLimit
operator|=
name|byteLimit
expr_stmt|;
name|recomputeBufferSizeAfterLimit
argument_list|()
expr_stmt|;
return|return
name|oldLimit
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|popLimit
parameter_list|(
specifier|final
name|int
name|oldLimit
parameter_list|)
block|{
name|currentLimit
operator|=
name|oldLimit
expr_stmt|;
name|recomputeBufferSizeAfterLimit
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getBytesUntilLimit
parameter_list|()
block|{
if|if
condition|(
name|currentLimit
operator|==
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
name|currentLimit
operator|-
name|getTotalBytesRead
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isAtEnd
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|pos
operator|==
name|limit
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getTotalBytesRead
parameter_list|()
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|pos
operator|-
name|startPos
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
name|readRawByte
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|pos
operator|==
name|limit
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
return|return
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|pos
operator|++
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|readRawBytes
parameter_list|(
specifier|final
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|length
operator|>=
literal|0
operator|&&
name|length
operator|<=
name|remaining
argument_list|()
condition|)
block|{
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|length
index|]
decl_stmt|;
name|slice
argument_list|(
name|pos
argument_list|,
name|pos
operator|+
name|length
argument_list|)
operator|.
name|get
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|length
expr_stmt|;
return|return
name|bytes
return|;
block|}
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|EMPTY_BYTE_ARRAY
return|;
block|}
else|else
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|negativeSize
argument_list|()
throw|;
block|}
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|skipRawBytes
parameter_list|(
specifier|final
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|length
operator|>=
literal|0
operator|&&
name|length
operator|<=
name|remaining
argument_list|()
condition|)
block|{
comment|// We have all the bytes we need already.
name|pos
operator|+=
name|length
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|negativeSize
argument_list|()
throw|;
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
specifier|private
name|void
name|recomputeBufferSizeAfterLimit
parameter_list|()
block|{
name|limit
operator|+=
name|bufferSizeAfterLimit
expr_stmt|;
specifier|final
name|int
name|bufferEnd
init|=
call|(
name|int
call|)
argument_list|(
name|limit
operator|-
name|startPos
argument_list|)
decl_stmt|;
if|if
condition|(
name|bufferEnd
operator|>
name|currentLimit
condition|)
block|{
comment|// Limit is in current buffer.
name|bufferSizeAfterLimit
operator|=
name|bufferEnd
operator|-
name|currentLimit
expr_stmt|;
name|limit
operator|-=
name|bufferSizeAfterLimit
expr_stmt|;
block|}
else|else
block|{
name|bufferSizeAfterLimit
operator|=
literal|0
expr_stmt|;
block|}
block|}
specifier|private
name|int
name|remaining
parameter_list|()
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|limit
operator|-
name|pos
argument_list|)
return|;
block|}
specifier|private
name|int
name|bufferPos
parameter_list|(
name|long
name|pos
parameter_list|)
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|pos
operator|-
name|address
argument_list|)
return|;
block|}
specifier|private
name|ByteBuffer
name|slice
parameter_list|(
name|long
name|begin
parameter_list|,
name|long
name|end
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|prevPos
init|=
name|buffer
operator|.
name|position
argument_list|()
decl_stmt|;
name|int
name|prevLimit
init|=
name|buffer
operator|.
name|limit
argument_list|()
decl_stmt|;
try|try
block|{
name|buffer
operator|.
name|position
argument_list|(
name|bufferPos
argument_list|(
name|begin
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|limit
argument_list|(
name|bufferPos
argument_list|(
name|end
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buffer
operator|.
name|slice
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
finally|finally
block|{
name|buffer
operator|.
name|position
argument_list|(
name|prevPos
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|limit
argument_list|(
name|prevLimit
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|ByteBuffer
name|copy
parameter_list|(
name|long
name|begin
parameter_list|,
name|long
name|end
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|copyToArray
argument_list|(
name|begin
argument_list|,
name|end
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|byte
index|[]
name|copyToArray
parameter_list|(
name|long
name|begin
parameter_list|,
name|long
name|end
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|prevPos
init|=
name|buffer
operator|.
name|position
argument_list|()
decl_stmt|;
name|int
name|prevLimit
init|=
name|buffer
operator|.
name|limit
argument_list|()
decl_stmt|;
try|try
block|{
name|buffer
operator|.
name|position
argument_list|(
name|bufferPos
argument_list|(
name|begin
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|limit
argument_list|(
name|bufferPos
argument_list|(
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
call|(
name|int
call|)
argument_list|(
name|end
operator|-
name|begin
argument_list|)
index|]
decl_stmt|;
name|buffer
operator|.
name|get
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
return|return
name|bytes
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
finally|finally
block|{
name|buffer
operator|.
name|position
argument_list|(
name|prevPos
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|limit
argument_list|(
name|prevLimit
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Implementation of {@link CodedInputStream} that uses an {@link InputStream} as the data source.    */
specifier|private
specifier|static
specifier|final
class|class
name|StreamDecoder
extends|extends
name|CodedInputStream
block|{
specifier|private
specifier|final
name|InputStream
name|input
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|buffer
decl_stmt|;
comment|/** bufferSize represents how many bytes are currently filled in the buffer */
specifier|private
name|int
name|bufferSize
decl_stmt|;
specifier|private
name|int
name|bufferSizeAfterLimit
decl_stmt|;
specifier|private
name|int
name|pos
decl_stmt|;
specifier|private
name|int
name|lastTag
decl_stmt|;
comment|/**      * The total number of bytes read before the current buffer. The total bytes read up to the      * current position can be computed as {@code totalBytesRetired + pos}. This value may be      * negative if reading started in the middle of the current buffer (e.g. if the constructor that      * takes a byte array and an offset was used).      */
specifier|private
name|int
name|totalBytesRetired
decl_stmt|;
comment|/** The absolute position of the end of the current message. */
specifier|private
name|int
name|currentLimit
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
specifier|private
name|StreamDecoder
parameter_list|(
specifier|final
name|InputStream
name|input
parameter_list|,
name|int
name|bufferSize
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|input
argument_list|,
literal|"input"
argument_list|)
expr_stmt|;
name|this
operator|.
name|input
operator|=
name|input
expr_stmt|;
name|this
operator|.
name|buffer
operator|=
operator|new
name|byte
index|[
name|bufferSize
index|]
expr_stmt|;
name|this
operator|.
name|bufferSize
operator|=
literal|0
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
name|totalBytesRetired
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readTag
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|isAtEnd
argument_list|()
condition|)
block|{
name|lastTag
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lastTag
operator|=
name|readRawVarint32
argument_list|()
expr_stmt|;
if|if
condition|(
name|WireFormat
operator|.
name|getTagFieldNumber
argument_list|(
name|lastTag
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// If we actually read zero (or any tag number corresponding to field
comment|// number zero), that's not a valid tag.
throw|throw
name|InvalidProtocolBufferException
operator|.
name|invalidTag
argument_list|()
throw|;
block|}
return|return
name|lastTag
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|checkLastTagWas
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|InvalidProtocolBufferException
block|{
if|if
condition|(
name|lastTag
operator|!=
name|value
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|invalidEndTag
argument_list|()
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|getLastTag
parameter_list|()
block|{
return|return
name|lastTag
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|skipField
parameter_list|(
specifier|final
name|int
name|tag
parameter_list|)
throws|throws
name|IOException
block|{
switch|switch
condition|(
name|WireFormat
operator|.
name|getTagWireType
argument_list|(
name|tag
argument_list|)
condition|)
block|{
case|case
name|WireFormat
operator|.
name|WIRETYPE_VARINT
case|:
name|skipRawVarint
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
case|case
name|WireFormat
operator|.
name|WIRETYPE_FIXED64
case|:
name|skipRawBytes
argument_list|(
name|FIXED_64_SIZE
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
case|:
name|skipRawBytes
argument_list|(
name|readRawVarint32
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
name|WireFormat
operator|.
name|WIRETYPE_START_GROUP
case|:
name|skipMessage
argument_list|()
expr_stmt|;
name|checkLastTagWas
argument_list|(
name|WireFormat
operator|.
name|makeTag
argument_list|(
name|WireFormat
operator|.
name|getTagFieldNumber
argument_list|(
name|tag
argument_list|)
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
case|:
return|return
literal|false
return|;
case|case
name|WireFormat
operator|.
name|WIRETYPE_FIXED32
case|:
name|skipRawBytes
argument_list|(
name|FIXED_32_SIZE
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
default|default:
throw|throw
name|InvalidProtocolBufferException
operator|.
name|invalidWireType
argument_list|()
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|skipField
parameter_list|(
specifier|final
name|int
name|tag
parameter_list|,
specifier|final
name|CodedOutputStream
name|output
parameter_list|)
throws|throws
name|IOException
block|{
switch|switch
condition|(
name|WireFormat
operator|.
name|getTagWireType
argument_list|(
name|tag
argument_list|)
condition|)
block|{
case|case
name|WireFormat
operator|.
name|WIRETYPE_VARINT
case|:
block|{
name|long
name|value
init|=
name|readInt64
argument_list|()
decl_stmt|;
name|output
operator|.
name|writeRawVarint32
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|output
operator|.
name|writeUInt64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
case|case
name|WireFormat
operator|.
name|WIRETYPE_FIXED64
case|:
block|{
name|long
name|value
init|=
name|readRawLittleEndian64
argument_list|()
decl_stmt|;
name|output
operator|.
name|writeRawVarint32
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|output
operator|.
name|writeFixed64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
case|case
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
case|:
block|{
name|ByteString
name|value
init|=
name|readBytes
argument_list|()
decl_stmt|;
name|output
operator|.
name|writeRawVarint32
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|output
operator|.
name|writeBytesNoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
case|case
name|WireFormat
operator|.
name|WIRETYPE_START_GROUP
case|:
block|{
name|output
operator|.
name|writeRawVarint32
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|skipMessage
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|int
name|endtag
init|=
name|WireFormat
operator|.
name|makeTag
argument_list|(
name|WireFormat
operator|.
name|getTagFieldNumber
argument_list|(
name|tag
argument_list|)
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
argument_list|)
decl_stmt|;
name|checkLastTagWas
argument_list|(
name|endtag
argument_list|)
expr_stmt|;
name|output
operator|.
name|writeRawVarint32
argument_list|(
name|endtag
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
case|case
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
case|:
block|{
return|return
literal|false
return|;
block|}
case|case
name|WireFormat
operator|.
name|WIRETYPE_FIXED32
case|:
block|{
name|int
name|value
init|=
name|readRawLittleEndian32
argument_list|()
decl_stmt|;
name|output
operator|.
name|writeRawVarint32
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|output
operator|.
name|writeFixed32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
default|default:
throw|throw
name|InvalidProtocolBufferException
operator|.
name|invalidWireType
argument_list|()
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|skipMessage
parameter_list|()
throws|throws
name|IOException
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|tag
init|=
name|readTag
argument_list|()
decl_stmt|;
if|if
condition|(
name|tag
operator|==
literal|0
operator|||
operator|!
name|skipField
argument_list|(
name|tag
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|skipMessage
parameter_list|(
name|CodedOutputStream
name|output
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|tag
init|=
name|readTag
argument_list|()
decl_stmt|;
if|if
condition|(
name|tag
operator|==
literal|0
operator|||
operator|!
name|skipField
argument_list|(
name|tag
argument_list|,
name|output
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
block|}
comment|/** Collects the bytes skipped and returns the data in a ByteBuffer. */
specifier|private
class|class
name|SkippedDataSink
implements|implements
name|RefillCallback
block|{
specifier|private
name|int
name|lastPos
init|=
name|pos
decl_stmt|;
specifier|private
name|ByteArrayOutputStream
name|byteArrayStream
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|onRefill
parameter_list|()
block|{
if|if
condition|(
name|byteArrayStream
operator|==
literal|null
condition|)
block|{
name|byteArrayStream
operator|=
operator|new
name|ByteArrayOutputStream
argument_list|()
expr_stmt|;
block|}
name|byteArrayStream
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
name|lastPos
argument_list|,
name|pos
operator|-
name|lastPos
argument_list|)
expr_stmt|;
name|lastPos
operator|=
literal|0
expr_stmt|;
block|}
comment|/** Gets skipped data in a ByteBuffer. This method should only be called once. */
name|ByteBuffer
name|getSkippedData
parameter_list|()
block|{
if|if
condition|(
name|byteArrayStream
operator|==
literal|null
condition|)
block|{
return|return
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|buffer
argument_list|,
name|lastPos
argument_list|,
name|pos
operator|-
name|lastPos
argument_list|)
return|;
block|}
else|else
block|{
name|byteArrayStream
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
name|lastPos
argument_list|,
name|pos
argument_list|)
expr_stmt|;
return|return
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|byteArrayStream
operator|.
name|toByteArray
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
comment|// -----------------------------------------------------------------
annotation|@
name|Override
specifier|public
name|double
name|readDouble
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|Double
operator|.
name|longBitsToDouble
argument_list|(
name|readRawLittleEndian64
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|float
name|readFloat
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|Float
operator|.
name|intBitsToFloat
argument_list|(
name|readRawLittleEndian32
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readUInt64
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawVarint64
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readInt64
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawVarint64
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readInt32
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawVarint32
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readFixed64
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawLittleEndian64
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readFixed32
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawLittleEndian32
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|readBool
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawVarint64
argument_list|()
operator|!=
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|readString
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|size
init|=
name|readRawVarint32
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|<=
operator|(
name|bufferSize
operator|-
name|pos
operator|)
condition|)
block|{
comment|// Fast path:  We already have the bytes in a contiguous buffer, so
comment|//   just copy directly from it.
specifier|final
name|String
name|result
init|=
operator|new
name|String
argument_list|(
name|buffer
argument_list|,
name|pos
argument_list|,
name|size
argument_list|,
name|UTF_8
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|size
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
literal|""
return|;
block|}
if|if
condition|(
name|size
operator|<=
name|bufferSize
condition|)
block|{
name|refillBuffer
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|String
name|result
init|=
operator|new
name|String
argument_list|(
name|buffer
argument_list|,
name|pos
argument_list|,
name|size
argument_list|,
name|UTF_8
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|size
expr_stmt|;
return|return
name|result
return|;
block|}
comment|// Slow path:  Build a byte array first then copy it.
return|return
operator|new
name|String
argument_list|(
name|readRawBytesSlowPath
argument_list|(
name|size
argument_list|)
argument_list|,
name|UTF_8
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|readStringRequireUtf8
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|size
init|=
name|readRawVarint32
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|bytes
decl_stmt|;
specifier|final
name|int
name|oldPos
init|=
name|pos
decl_stmt|;
specifier|final
name|int
name|tempPos
decl_stmt|;
if|if
condition|(
name|size
operator|<=
operator|(
name|bufferSize
operator|-
name|oldPos
operator|)
operator|&&
name|size
operator|>
literal|0
condition|)
block|{
comment|// Fast path:  We already have the bytes in a contiguous buffer, so
comment|//   just copy directly from it.
name|bytes
operator|=
name|buffer
expr_stmt|;
name|pos
operator|=
name|oldPos
operator|+
name|size
expr_stmt|;
name|tempPos
operator|=
name|oldPos
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
literal|""
return|;
block|}
elseif|else
if|if
condition|(
name|size
operator|<=
name|bufferSize
condition|)
block|{
name|refillBuffer
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|buffer
expr_stmt|;
name|tempPos
operator|=
literal|0
expr_stmt|;
name|pos
operator|=
name|tempPos
operator|+
name|size
expr_stmt|;
block|}
else|else
block|{
comment|// Slow path:  Build a byte array first then copy it.
name|bytes
operator|=
name|readRawBytesSlowPath
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|tempPos
operator|=
literal|0
expr_stmt|;
block|}
comment|// TODO(martinrb): We could save a pass by validating while decoding.
if|if
condition|(
operator|!
name|Utf8
operator|.
name|isValidUtf8
argument_list|(
name|bytes
argument_list|,
name|tempPos
argument_list|,
name|tempPos
operator|+
name|size
argument_list|)
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|invalidUtf8
argument_list|()
throw|;
block|}
return|return
operator|new
name|String
argument_list|(
name|bytes
argument_list|,
name|tempPos
argument_list|,
name|size
argument_list|,
name|UTF_8
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readGroup
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|MessageLite
operator|.
name|Builder
name|builder
parameter_list|,
specifier|final
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|recursionDepth
operator|>=
name|recursionLimit
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|recursionLimitExceeded
argument_list|()
throw|;
block|}
operator|++
name|recursionDepth
expr_stmt|;
name|builder
operator|.
name|mergeFrom
argument_list|(
name|this
argument_list|,
name|extensionRegistry
argument_list|)
expr_stmt|;
name|checkLastTagWas
argument_list|(
name|WireFormat
operator|.
name|makeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|recursionDepth
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|MessageLite
parameter_list|>
name|T
name|readGroup
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|Parser
argument_list|<
name|T
argument_list|>
name|parser
parameter_list|,
specifier|final
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|recursionDepth
operator|>=
name|recursionLimit
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|recursionLimitExceeded
argument_list|()
throw|;
block|}
operator|++
name|recursionDepth
expr_stmt|;
name|T
name|result
init|=
name|parser
operator|.
name|parsePartialFrom
argument_list|(
name|this
argument_list|,
name|extensionRegistry
argument_list|)
decl_stmt|;
name|checkLastTagWas
argument_list|(
name|WireFormat
operator|.
name|makeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|recursionDepth
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Deprecated
annotation|@
name|Override
specifier|public
name|void
name|readUnknownGroup
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|MessageLite
operator|.
name|Builder
name|builder
parameter_list|)
throws|throws
name|IOException
block|{
name|readGroup
argument_list|(
name|fieldNumber
argument_list|,
name|builder
argument_list|,
name|ExtensionRegistryLite
operator|.
name|getEmptyRegistry
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readMessage
parameter_list|(
specifier|final
name|MessageLite
operator|.
name|Builder
name|builder
parameter_list|,
specifier|final
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|length
init|=
name|readRawVarint32
argument_list|()
decl_stmt|;
if|if
condition|(
name|recursionDepth
operator|>=
name|recursionLimit
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|recursionLimitExceeded
argument_list|()
throw|;
block|}
specifier|final
name|int
name|oldLimit
init|=
name|pushLimit
argument_list|(
name|length
argument_list|)
decl_stmt|;
operator|++
name|recursionDepth
expr_stmt|;
name|builder
operator|.
name|mergeFrom
argument_list|(
name|this
argument_list|,
name|extensionRegistry
argument_list|)
expr_stmt|;
name|checkLastTagWas
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|--
name|recursionDepth
expr_stmt|;
name|popLimit
argument_list|(
name|oldLimit
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|MessageLite
parameter_list|>
name|T
name|readMessage
parameter_list|(
specifier|final
name|Parser
argument_list|<
name|T
argument_list|>
name|parser
parameter_list|,
specifier|final
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|length
init|=
name|readRawVarint32
argument_list|()
decl_stmt|;
if|if
condition|(
name|recursionDepth
operator|>=
name|recursionLimit
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|recursionLimitExceeded
argument_list|()
throw|;
block|}
specifier|final
name|int
name|oldLimit
init|=
name|pushLimit
argument_list|(
name|length
argument_list|)
decl_stmt|;
operator|++
name|recursionDepth
expr_stmt|;
name|T
name|result
init|=
name|parser
operator|.
name|parsePartialFrom
argument_list|(
name|this
argument_list|,
name|extensionRegistry
argument_list|)
decl_stmt|;
name|checkLastTagWas
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|--
name|recursionDepth
expr_stmt|;
name|popLimit
argument_list|(
name|oldLimit
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|ByteString
name|readBytes
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|size
init|=
name|readRawVarint32
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|<=
operator|(
name|bufferSize
operator|-
name|pos
operator|)
operator|&&
name|size
operator|>
literal|0
condition|)
block|{
comment|// Fast path:  We already have the bytes in a contiguous buffer, so
comment|//   just copy directly from it.
specifier|final
name|ByteString
name|result
init|=
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|buffer
argument_list|,
name|pos
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|size
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
name|ByteString
operator|.
name|EMPTY
return|;
block|}
comment|// Slow path:  Build a byte array first then copy it.
return|return
name|ByteString
operator|.
name|wrap
argument_list|(
name|readRawBytesSlowPath
argument_list|(
name|size
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|readByteArray
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|size
init|=
name|readRawVarint32
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|<=
operator|(
name|bufferSize
operator|-
name|pos
operator|)
operator|&&
name|size
operator|>
literal|0
condition|)
block|{
comment|// Fast path: We already have the bytes in a contiguous buffer, so
comment|// just copy directly from it.
specifier|final
name|byte
index|[]
name|result
init|=
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|buffer
argument_list|,
name|pos
argument_list|,
name|pos
operator|+
name|size
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|size
expr_stmt|;
return|return
name|result
return|;
block|}
else|else
block|{
comment|// Slow path: Build a byte array first then copy it.
return|return
name|readRawBytesSlowPath
argument_list|(
name|size
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|ByteBuffer
name|readByteBuffer
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|size
init|=
name|readRawVarint32
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|<=
operator|(
name|bufferSize
operator|-
name|pos
operator|)
operator|&&
name|size
operator|>
literal|0
condition|)
block|{
comment|// Fast path: We already have the bytes in a contiguous buffer.
name|ByteBuffer
name|result
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|buffer
argument_list|,
name|pos
argument_list|,
name|pos
operator|+
name|size
argument_list|)
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|size
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
name|Internal
operator|.
name|EMPTY_BYTE_BUFFER
return|;
block|}
comment|// Slow path: Build a byte array first then copy it.
return|return
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|readRawBytesSlowPath
argument_list|(
name|size
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readUInt32
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawVarint32
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readEnum
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawVarint32
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readSFixed32
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawLittleEndian32
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readSFixed64
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawLittleEndian64
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readSInt32
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|decodeZigZag32
argument_list|(
name|readRawVarint32
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readSInt64
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|decodeZigZag64
argument_list|(
name|readRawVarint64
argument_list|()
argument_list|)
return|;
block|}
comment|// =================================================================
annotation|@
name|Override
specifier|public
name|int
name|readRawVarint32
parameter_list|()
throws|throws
name|IOException
block|{
comment|// See implementation notes for readRawVarint64
name|fastpath
label|:
block|{
name|int
name|tempPos
init|=
name|pos
decl_stmt|;
if|if
condition|(
name|bufferSize
operator|==
name|tempPos
condition|)
block|{
break|break
name|fastpath
break|;
block|}
specifier|final
name|byte
index|[]
name|buffer
init|=
name|this
operator|.
name|buffer
decl_stmt|;
name|int
name|x
decl_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|)
operator|>=
literal|0
condition|)
block|{
name|pos
operator|=
name|tempPos
expr_stmt|;
return|return
name|x
return|;
block|}
elseif|else
if|if
condition|(
name|bufferSize
operator|-
name|tempPos
operator|<
literal|9
condition|)
block|{
break|break
name|fastpath
break|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|^=
operator|(
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<<
literal|7
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|^=
operator|(
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<<
literal|14
operator|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|14
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|^=
operator|(
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<<
literal|21
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|21
operator|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|y
init|=
name|buffer
index|[
name|tempPos
operator|++
index|]
decl_stmt|;
name|x
operator|^=
name|y
operator|<<
literal|28
expr_stmt|;
name|x
operator|^=
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|21
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|28
operator|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
operator|&&
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<
literal|0
operator|&&
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<
literal|0
operator|&&
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<
literal|0
operator|&&
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<
literal|0
operator|&&
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<
literal|0
condition|)
block|{
break|break
name|fastpath
break|;
comment|// Will throw malformedVarint()
block|}
block|}
name|pos
operator|=
name|tempPos
expr_stmt|;
return|return
name|x
return|;
block|}
return|return
operator|(
name|int
operator|)
name|readRawVarint64SlowPath
argument_list|()
return|;
block|}
specifier|private
name|void
name|skipRawVarint
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|bufferSize
operator|-
name|pos
operator|>=
name|MAX_VARINT_SIZE
condition|)
block|{
name|skipRawVarintFastPath
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|skipRawVarintSlowPath
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|skipRawVarintFastPath
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VARINT_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|buffer
index|[
name|pos
operator|++
index|]
operator|>=
literal|0
condition|)
block|{
return|return;
block|}
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|malformedVarint
argument_list|()
throw|;
block|}
specifier|private
name|void
name|skipRawVarintSlowPath
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VARINT_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|readRawByte
argument_list|()
operator|>=
literal|0
condition|)
block|{
return|return;
block|}
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|malformedVarint
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readRawVarint64
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Implementation notes:
comment|//
comment|// Optimized for one-byte values, expected to be common.
comment|// The particular code below was selected from various candidates
comment|// empirically, by winning VarintBenchmark.
comment|//
comment|// Sign extension of (signed) Java bytes is usually a nuisance, but
comment|// we exploit it here to more easily obtain the sign of bytes read.
comment|// Instead of cleaning up the sign extension bits by masking eagerly,
comment|// we delay until we find the final (positive) byte, when we clear all
comment|// accumulated bits with one xor.  We depend on javac to constant fold.
name|fastpath
label|:
block|{
name|int
name|tempPos
init|=
name|pos
decl_stmt|;
if|if
condition|(
name|bufferSize
operator|==
name|tempPos
condition|)
block|{
break|break
name|fastpath
break|;
block|}
specifier|final
name|byte
index|[]
name|buffer
init|=
name|this
operator|.
name|buffer
decl_stmt|;
name|long
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|)
operator|>=
literal|0
condition|)
block|{
name|pos
operator|=
name|tempPos
expr_stmt|;
return|return
name|y
return|;
block|}
elseif|else
if|if
condition|(
name|bufferSize
operator|-
name|tempPos
operator|<
literal|9
condition|)
block|{
break|break
name|fastpath
break|;
block|}
elseif|else
if|if
condition|(
operator|(
name|y
operator|^=
operator|(
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<<
literal|7
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
name|x
operator|=
name|y
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|y
operator|^=
operator|(
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<<
literal|14
operator|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|x
operator|=
name|y
operator|^
operator|(
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|14
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|y
operator|^=
operator|(
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<<
literal|21
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
name|x
operator|=
name|y
operator|^
operator|(
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|21
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|=
name|y
operator|^
operator|(
operator|(
name|long
operator|)
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<<
literal|28
operator|)
operator|)
operator|>=
literal|0L
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0L
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|21
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|28
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|^=
operator|(
operator|(
name|long
operator|)
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<<
literal|35
operator|)
operator|)
operator|<
literal|0L
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0L
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|21
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|28
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|35
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|^=
operator|(
operator|(
name|long
operator|)
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<<
literal|42
operator|)
operator|)
operator|>=
literal|0L
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0L
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|21
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|28
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|35
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|42
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|^=
operator|(
operator|(
name|long
operator|)
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<<
literal|49
operator|)
operator|)
operator|<
literal|0L
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0L
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|21
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|28
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|35
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|42
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|49
operator|)
expr_stmt|;
block|}
else|else
block|{
name|x
operator|^=
operator|(
operator|(
name|long
operator|)
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<<
literal|56
operator|)
expr_stmt|;
name|x
operator|^=
operator|(
operator|~
literal|0L
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|21
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|28
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|35
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|42
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|49
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|56
operator|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0L
condition|)
block|{
if|if
condition|(
name|buffer
index|[
name|tempPos
operator|++
index|]
operator|<
literal|0L
condition|)
block|{
break|break
name|fastpath
break|;
comment|// Will throw malformedVarint()
block|}
block|}
block|}
name|pos
operator|=
name|tempPos
expr_stmt|;
return|return
name|x
return|;
block|}
return|return
name|readRawVarint64SlowPath
argument_list|()
return|;
block|}
annotation|@
name|Override
name|long
name|readRawVarint64SlowPath
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|result
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|shift
init|=
literal|0
init|;
name|shift
operator|<
literal|64
condition|;
name|shift
operator|+=
literal|7
control|)
block|{
specifier|final
name|byte
name|b
init|=
name|readRawByte
argument_list|()
decl_stmt|;
name|result
operator||=
call|(
name|long
call|)
argument_list|(
name|b
operator|&
literal|0x7F
argument_list|)
operator|<<
name|shift
expr_stmt|;
if|if
condition|(
operator|(
name|b
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|malformedVarint
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readRawLittleEndian32
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|tempPos
init|=
name|pos
decl_stmt|;
if|if
condition|(
name|bufferSize
operator|-
name|tempPos
operator|<
name|FIXED_32_SIZE
condition|)
block|{
name|refillBuffer
argument_list|(
name|FIXED_32_SIZE
argument_list|)
expr_stmt|;
name|tempPos
operator|=
name|pos
expr_stmt|;
block|}
specifier|final
name|byte
index|[]
name|buffer
init|=
name|this
operator|.
name|buffer
decl_stmt|;
name|pos
operator|=
name|tempPos
operator|+
name|FIXED_32_SIZE
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|buffer
index|[
name|tempPos
index|]
operator|&
literal|0xff
operator|)
operator|)
operator||
operator|(
operator|(
name|buffer
index|[
name|tempPos
operator|+
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|buffer
index|[
name|tempPos
operator|+
literal|2
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|buffer
index|[
name|tempPos
operator|+
literal|3
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readRawLittleEndian64
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|tempPos
init|=
name|pos
decl_stmt|;
if|if
condition|(
name|bufferSize
operator|-
name|tempPos
operator|<
name|FIXED_64_SIZE
condition|)
block|{
name|refillBuffer
argument_list|(
name|FIXED_64_SIZE
argument_list|)
expr_stmt|;
name|tempPos
operator|=
name|pos
expr_stmt|;
block|}
specifier|final
name|byte
index|[]
name|buffer
init|=
name|this
operator|.
name|buffer
decl_stmt|;
name|pos
operator|=
name|tempPos
operator|+
name|FIXED_64_SIZE
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|buffer
index|[
name|tempPos
index|]
operator|&
literal|0xffL
operator|)
operator|)
operator||
operator|(
operator|(
name|buffer
index|[
name|tempPos
operator|+
literal|1
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|buffer
index|[
name|tempPos
operator|+
literal|2
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|buffer
index|[
name|tempPos
operator|+
literal|3
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|buffer
index|[
name|tempPos
operator|+
literal|4
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|buffer
index|[
name|tempPos
operator|+
literal|5
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
name|buffer
index|[
name|tempPos
operator|+
literal|6
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
name|buffer
index|[
name|tempPos
operator|+
literal|7
index|]
operator|&
literal|0xffL
operator|)
operator|<<
literal|56
operator|)
operator|)
return|;
block|}
comment|// -----------------------------------------------------------------
annotation|@
name|Override
specifier|public
name|void
name|enableAliasing
parameter_list|(
name|boolean
name|enabled
parameter_list|)
block|{
comment|// TODO(nathanmittler): Ideally we should throw here. Do nothing for backward compatibility.
block|}
annotation|@
name|Override
specifier|public
name|void
name|resetSizeCounter
parameter_list|()
block|{
name|totalBytesRetired
operator|=
operator|-
name|pos
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|pushLimit
parameter_list|(
name|int
name|byteLimit
parameter_list|)
throws|throws
name|InvalidProtocolBufferException
block|{
if|if
condition|(
name|byteLimit
operator|<
literal|0
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|negativeSize
argument_list|()
throw|;
block|}
name|byteLimit
operator|+=
name|totalBytesRetired
operator|+
name|pos
expr_stmt|;
specifier|final
name|int
name|oldLimit
init|=
name|currentLimit
decl_stmt|;
if|if
condition|(
name|byteLimit
operator|>
name|oldLimit
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
name|currentLimit
operator|=
name|byteLimit
expr_stmt|;
name|recomputeBufferSizeAfterLimit
argument_list|()
expr_stmt|;
return|return
name|oldLimit
return|;
block|}
specifier|private
name|void
name|recomputeBufferSizeAfterLimit
parameter_list|()
block|{
name|bufferSize
operator|+=
name|bufferSizeAfterLimit
expr_stmt|;
specifier|final
name|int
name|bufferEnd
init|=
name|totalBytesRetired
operator|+
name|bufferSize
decl_stmt|;
if|if
condition|(
name|bufferEnd
operator|>
name|currentLimit
condition|)
block|{
comment|// Limit is in current buffer.
name|bufferSizeAfterLimit
operator|=
name|bufferEnd
operator|-
name|currentLimit
expr_stmt|;
name|bufferSize
operator|-=
name|bufferSizeAfterLimit
expr_stmt|;
block|}
else|else
block|{
name|bufferSizeAfterLimit
operator|=
literal|0
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|popLimit
parameter_list|(
specifier|final
name|int
name|oldLimit
parameter_list|)
block|{
name|currentLimit
operator|=
name|oldLimit
expr_stmt|;
name|recomputeBufferSizeAfterLimit
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getBytesUntilLimit
parameter_list|()
block|{
if|if
condition|(
name|currentLimit
operator|==
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
specifier|final
name|int
name|currentAbsolutePosition
init|=
name|totalBytesRetired
operator|+
name|pos
decl_stmt|;
return|return
name|currentLimit
operator|-
name|currentAbsolutePosition
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isAtEnd
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|pos
operator|==
name|bufferSize
operator|&&
operator|!
name|tryRefillBuffer
argument_list|(
literal|1
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getTotalBytesRead
parameter_list|()
block|{
return|return
name|totalBytesRetired
operator|+
name|pos
return|;
block|}
specifier|private
interface|interface
name|RefillCallback
block|{
name|void
name|onRefill
parameter_list|()
function_decl|;
block|}
specifier|private
name|RefillCallback
name|refillCallback
init|=
literal|null
decl_stmt|;
comment|/**      * Reads more bytes from the input, making at least {@code n} bytes available in the buffer.      * Caller must ensure that the requested space is not yet available, and that the requested      * space is less than BUFFER_SIZE.      *      * @throws InvalidProtocolBufferException The end of the stream or the current limit was      *     reached.      */
specifier|private
name|void
name|refillBuffer
parameter_list|(
name|int
name|n
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|tryRefillBuffer
argument_list|(
name|n
argument_list|)
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
block|}
comment|/**      * Tries to read more bytes from the input, making at least {@code n} bytes available in the      * buffer. Caller must ensure that the requested space is not yet available, and that the      * requested space is less than BUFFER_SIZE.      *      * @return {@code true} if the bytes could be made available; {@code false} if the end of the      *     stream or the current limit was reached.      */
specifier|private
name|boolean
name|tryRefillBuffer
parameter_list|(
name|int
name|n
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|pos
operator|+
name|n
operator|<=
name|bufferSize
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"refillBuffer() called when "
operator|+
name|n
operator|+
literal|" bytes were already available in buffer"
argument_list|)
throw|;
block|}
if|if
condition|(
name|totalBytesRetired
operator|+
name|pos
operator|+
name|n
operator|>
name|currentLimit
condition|)
block|{
comment|// Oops, we hit a limit.
return|return
literal|false
return|;
block|}
if|if
condition|(
name|refillCallback
operator|!=
literal|null
condition|)
block|{
name|refillCallback
operator|.
name|onRefill
argument_list|()
expr_stmt|;
block|}
name|int
name|tempPos
init|=
name|pos
decl_stmt|;
if|if
condition|(
name|tempPos
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bufferSize
operator|>
name|tempPos
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|buffer
argument_list|,
name|tempPos
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|,
name|bufferSize
operator|-
name|tempPos
argument_list|)
expr_stmt|;
block|}
name|totalBytesRetired
operator|+=
name|tempPos
expr_stmt|;
name|bufferSize
operator|-=
name|tempPos
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
name|int
name|bytesRead
init|=
name|input
operator|.
name|read
argument_list|(
name|buffer
argument_list|,
name|bufferSize
argument_list|,
name|buffer
operator|.
name|length
operator|-
name|bufferSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytesRead
operator|==
literal|0
operator|||
name|bytesRead
argument_list|<
operator|-
literal|1
operator|||
name|bytesRead
argument_list|>
name|buffer
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"InputStream#read(byte[]) returned invalid result: "
operator|+
name|bytesRead
operator|+
literal|"\nThe InputStream implementation is buggy."
argument_list|)
throw|;
block|}
if|if
condition|(
name|bytesRead
operator|>
literal|0
condition|)
block|{
name|bufferSize
operator|+=
name|bytesRead
expr_stmt|;
comment|// Integer-overflow-conscious check against sizeLimit
if|if
condition|(
name|totalBytesRetired
operator|+
name|n
operator|-
name|sizeLimit
operator|>
literal|0
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|sizeLimitExceeded
argument_list|()
throw|;
block|}
name|recomputeBufferSizeAfterLimit
argument_list|()
expr_stmt|;
return|return
operator|(
name|bufferSize
operator|>=
name|n
operator|)
condition|?
literal|true
else|:
name|tryRefillBuffer
argument_list|(
name|n
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
name|readRawByte
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|pos
operator|==
name|bufferSize
condition|)
block|{
name|refillBuffer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
index|[
name|pos
operator|++
index|]
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|readRawBytes
parameter_list|(
specifier|final
name|int
name|size
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|tempPos
init|=
name|pos
decl_stmt|;
if|if
condition|(
name|size
operator|<=
operator|(
name|bufferSize
operator|-
name|tempPos
operator|)
operator|&&
name|size
operator|>
literal|0
condition|)
block|{
name|pos
operator|=
name|tempPos
operator|+
name|size
expr_stmt|;
return|return
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|buffer
argument_list|,
name|tempPos
argument_list|,
name|tempPos
operator|+
name|size
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|readRawBytesSlowPath
argument_list|(
name|size
argument_list|)
return|;
block|}
block|}
comment|/**      * Exactly like readRawBytes, but caller must have already checked the fast path: (size<=      * (bufferSize - pos)&& size> 0)      */
specifier|private
name|byte
index|[]
name|readRawBytesSlowPath
parameter_list|(
specifier|final
name|int
name|size
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
name|Internal
operator|.
name|EMPTY_BYTE_ARRAY
return|;
block|}
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|negativeSize
argument_list|()
throw|;
block|}
comment|// Verify that the message size so far has not exceeded sizeLimit.
name|int
name|currentMessageSize
init|=
name|totalBytesRetired
operator|+
name|pos
operator|+
name|size
decl_stmt|;
if|if
condition|(
name|currentMessageSize
operator|>
name|sizeLimit
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|sizeLimitExceeded
argument_list|()
throw|;
block|}
comment|// Verify that the message size so far has not exceeded currentLimit.
if|if
condition|(
name|currentMessageSize
operator|>
name|currentLimit
condition|)
block|{
comment|// Read to the end of the stream anyway.
name|skipRawBytes
argument_list|(
name|currentLimit
operator|-
name|totalBytesRetired
operator|-
name|pos
argument_list|)
expr_stmt|;
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
specifier|final
name|int
name|originalBufferPos
init|=
name|pos
decl_stmt|;
specifier|final
name|int
name|bufferedBytes
init|=
name|bufferSize
operator|-
name|pos
decl_stmt|;
comment|// Mark the current buffer consumed.
name|totalBytesRetired
operator|+=
name|bufferSize
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
name|bufferSize
operator|=
literal|0
expr_stmt|;
comment|// Determine the number of bytes we need to read from the input stream.
name|int
name|sizeLeft
init|=
name|size
operator|-
name|bufferedBytes
decl_stmt|;
comment|// TODO(nathanmittler): Consider using a value larger than DEFAULT_BUFFER_SIZE.
if|if
condition|(
name|sizeLeft
operator|<
name|DEFAULT_BUFFER_SIZE
operator|||
name|sizeLeft
operator|<=
name|input
operator|.
name|available
argument_list|()
condition|)
block|{
comment|// Either the bytes we need are known to be available, or the required buffer is
comment|// within an allowed threshold - go ahead and allocate the buffer now.
specifier|final
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|size
index|]
decl_stmt|;
comment|// Copy all of the buffered bytes to the result buffer.
name|System
operator|.
name|arraycopy
argument_list|(
name|buffer
argument_list|,
name|originalBufferPos
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|,
name|bufferedBytes
argument_list|)
expr_stmt|;
comment|// Fill the remaining bytes from the input stream.
name|int
name|tempPos
init|=
name|bufferedBytes
decl_stmt|;
while|while
condition|(
name|tempPos
operator|<
name|bytes
operator|.
name|length
condition|)
block|{
name|int
name|n
init|=
name|input
operator|.
name|read
argument_list|(
name|bytes
argument_list|,
name|tempPos
argument_list|,
name|size
operator|-
name|tempPos
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
name|totalBytesRetired
operator|+=
name|n
expr_stmt|;
name|tempPos
operator|+=
name|n
expr_stmt|;
block|}
return|return
name|bytes
return|;
block|}
comment|// The size is very large.  For security reasons, we can't allocate the
comment|// entire byte array yet.  The size comes directly from the input, so a
comment|// maliciously-crafted message could provide a bogus very large size in
comment|// order to trick the app into allocating a lot of memory.  We avoid this
comment|// by allocating and reading only a small chunk at a time, so that the
comment|// malicious message must actually *be* extremely large to cause
comment|// problems.  Meanwhile, we limit the allowed size of a message elsewhere.
specifier|final
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|chunks
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|sizeLeft
operator|>
literal|0
condition|)
block|{
comment|// TODO(nathanmittler): Consider using a value larger than DEFAULT_BUFFER_SIZE.
specifier|final
name|byte
index|[]
name|chunk
init|=
operator|new
name|byte
index|[
name|Math
operator|.
name|min
argument_list|(
name|sizeLeft
argument_list|,
name|DEFAULT_BUFFER_SIZE
argument_list|)
index|]
decl_stmt|;
name|int
name|tempPos
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|tempPos
operator|<
name|chunk
operator|.
name|length
condition|)
block|{
specifier|final
name|int
name|n
init|=
name|input
operator|.
name|read
argument_list|(
name|chunk
argument_list|,
name|tempPos
argument_list|,
name|chunk
operator|.
name|length
operator|-
name|tempPos
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
name|totalBytesRetired
operator|+=
name|n
expr_stmt|;
name|tempPos
operator|+=
name|n
expr_stmt|;
block|}
name|sizeLeft
operator|-=
name|chunk
operator|.
name|length
expr_stmt|;
name|chunks
operator|.
name|add
argument_list|(
name|chunk
argument_list|)
expr_stmt|;
block|}
comment|// OK, got everything.  Now concatenate it all into one buffer.
specifier|final
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|size
index|]
decl_stmt|;
comment|// Start by copying the leftover bytes from this.buffer.
name|System
operator|.
name|arraycopy
argument_list|(
name|buffer
argument_list|,
name|originalBufferPos
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|,
name|bufferedBytes
argument_list|)
expr_stmt|;
comment|// And now all the chunks.
name|int
name|tempPos
init|=
name|bufferedBytes
decl_stmt|;
for|for
control|(
specifier|final
name|byte
index|[]
name|chunk
range|:
name|chunks
control|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|chunk
argument_list|,
literal|0
argument_list|,
name|bytes
argument_list|,
name|tempPos
argument_list|,
name|chunk
operator|.
name|length
argument_list|)
expr_stmt|;
name|tempPos
operator|+=
name|chunk
operator|.
name|length
expr_stmt|;
block|}
comment|// Done.
return|return
name|bytes
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|skipRawBytes
parameter_list|(
specifier|final
name|int
name|size
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|size
operator|<=
operator|(
name|bufferSize
operator|-
name|pos
operator|)
operator|&&
name|size
operator|>=
literal|0
condition|)
block|{
comment|// We have all the bytes we need already.
name|pos
operator|+=
name|size
expr_stmt|;
block|}
else|else
block|{
name|skipRawBytesSlowPath
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Exactly like skipRawBytes, but caller must have already checked the fast path: (size<=      * (bufferSize - pos)&& size>= 0)      */
specifier|private
name|void
name|skipRawBytesSlowPath
parameter_list|(
specifier|final
name|int
name|size
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|negativeSize
argument_list|()
throw|;
block|}
if|if
condition|(
name|totalBytesRetired
operator|+
name|pos
operator|+
name|size
operator|>
name|currentLimit
condition|)
block|{
comment|// Read to the end of the stream anyway.
name|skipRawBytes
argument_list|(
name|currentLimit
operator|-
name|totalBytesRetired
operator|-
name|pos
argument_list|)
expr_stmt|;
comment|// Then fail.
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
comment|// Skipping more bytes than are in the buffer.  First skip what we have.
name|int
name|tempPos
init|=
name|bufferSize
operator|-
name|pos
decl_stmt|;
name|pos
operator|=
name|bufferSize
expr_stmt|;
comment|// Keep refilling the buffer until we get to the point we wanted to skip to.
comment|// This has the side effect of ensuring the limits are updated correctly.
name|refillBuffer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|-
name|tempPos
operator|>
name|bufferSize
condition|)
block|{
name|tempPos
operator|+=
name|bufferSize
expr_stmt|;
name|pos
operator|=
name|bufferSize
expr_stmt|;
name|refillBuffer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|pos
operator|=
name|size
operator|-
name|tempPos
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
specifier|final
class|class
name|ByteInputDecoder
extends|extends
name|CodedInputStream
block|{
specifier|private
specifier|final
name|ByteInput
name|buffer
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|immutable
decl_stmt|;
specifier|private
name|int
name|limit
decl_stmt|;
specifier|private
name|int
name|bufferSizeAfterLimit
decl_stmt|;
specifier|private
name|int
name|pos
decl_stmt|;
specifier|private
name|int
name|startPos
decl_stmt|;
specifier|private
name|int
name|lastTag
decl_stmt|;
specifier|private
name|boolean
name|enableAliasing
decl_stmt|;
comment|/** The absolute position of the end of the current message. */
specifier|private
name|int
name|currentLimit
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
specifier|private
name|ByteInputDecoder
parameter_list|(
name|ByteInput
name|buffer
parameter_list|,
name|boolean
name|immutable
parameter_list|)
block|{
name|this
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|buffer
operator|.
name|size
argument_list|()
argument_list|,
name|immutable
argument_list|)
expr_stmt|;
block|}
specifier|private
name|ByteInputDecoder
parameter_list|(
name|ByteInput
name|buffer
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|,
name|boolean
name|immutable
parameter_list|)
block|{
name|this
operator|.
name|buffer
operator|=
name|buffer
expr_stmt|;
name|pos
operator|=
name|off
expr_stmt|;
name|limit
operator|=
name|off
operator|+
name|len
expr_stmt|;
name|startPos
operator|=
name|pos
expr_stmt|;
name|this
operator|.
name|immutable
operator|=
name|immutable
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readTag
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|isAtEnd
argument_list|()
condition|)
block|{
name|lastTag
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lastTag
operator|=
name|readRawVarint32
argument_list|()
expr_stmt|;
if|if
condition|(
name|WireFormat
operator|.
name|getTagFieldNumber
argument_list|(
name|lastTag
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// If we actually read zero (or any tag number corresponding to field
comment|// number zero), that's not a valid tag.
throw|throw
name|InvalidProtocolBufferException
operator|.
name|invalidTag
argument_list|()
throw|;
block|}
return|return
name|lastTag
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|checkLastTagWas
parameter_list|(
name|int
name|value
parameter_list|)
throws|throws
name|InvalidProtocolBufferException
block|{
if|if
condition|(
name|lastTag
operator|!=
name|value
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|invalidEndTag
argument_list|()
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|getLastTag
parameter_list|()
block|{
return|return
name|lastTag
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|skipField
parameter_list|(
name|int
name|tag
parameter_list|)
throws|throws
name|IOException
block|{
switch|switch
condition|(
name|WireFormat
operator|.
name|getTagWireType
argument_list|(
name|tag
argument_list|)
condition|)
block|{
case|case
name|WireFormat
operator|.
name|WIRETYPE_VARINT
case|:
name|skipRawVarint
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
case|case
name|WireFormat
operator|.
name|WIRETYPE_FIXED64
case|:
name|skipRawBytes
argument_list|(
name|FIXED_64_SIZE
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
case|:
name|skipRawBytes
argument_list|(
name|readRawVarint32
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
name|WireFormat
operator|.
name|WIRETYPE_START_GROUP
case|:
name|skipMessage
argument_list|()
expr_stmt|;
name|checkLastTagWas
argument_list|(
name|WireFormat
operator|.
name|makeTag
argument_list|(
name|WireFormat
operator|.
name|getTagFieldNumber
argument_list|(
name|tag
argument_list|)
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
case|:
return|return
literal|false
return|;
case|case
name|WireFormat
operator|.
name|WIRETYPE_FIXED32
case|:
name|skipRawBytes
argument_list|(
name|FIXED_32_SIZE
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
default|default:
throw|throw
name|InvalidProtocolBufferException
operator|.
name|invalidWireType
argument_list|()
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|skipField
parameter_list|(
name|int
name|tag
parameter_list|,
name|CodedOutputStream
name|output
parameter_list|)
throws|throws
name|IOException
block|{
switch|switch
condition|(
name|WireFormat
operator|.
name|getTagWireType
argument_list|(
name|tag
argument_list|)
condition|)
block|{
case|case
name|WireFormat
operator|.
name|WIRETYPE_VARINT
case|:
block|{
name|long
name|value
init|=
name|readInt64
argument_list|()
decl_stmt|;
name|output
operator|.
name|writeRawVarint32
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|output
operator|.
name|writeUInt64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
case|case
name|WireFormat
operator|.
name|WIRETYPE_FIXED64
case|:
block|{
name|long
name|value
init|=
name|readRawLittleEndian64
argument_list|()
decl_stmt|;
name|output
operator|.
name|writeRawVarint32
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|output
operator|.
name|writeFixed64NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
case|case
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
case|:
block|{
name|ByteString
name|value
init|=
name|readBytes
argument_list|()
decl_stmt|;
name|output
operator|.
name|writeRawVarint32
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|output
operator|.
name|writeBytesNoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
case|case
name|WireFormat
operator|.
name|WIRETYPE_START_GROUP
case|:
block|{
name|output
operator|.
name|writeRawVarint32
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|skipMessage
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|int
name|endtag
init|=
name|WireFormat
operator|.
name|makeTag
argument_list|(
name|WireFormat
operator|.
name|getTagFieldNumber
argument_list|(
name|tag
argument_list|)
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
argument_list|)
decl_stmt|;
name|checkLastTagWas
argument_list|(
name|endtag
argument_list|)
expr_stmt|;
name|output
operator|.
name|writeRawVarint32
argument_list|(
name|endtag
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
case|case
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
case|:
block|{
return|return
literal|false
return|;
block|}
case|case
name|WireFormat
operator|.
name|WIRETYPE_FIXED32
case|:
block|{
name|int
name|value
init|=
name|readRawLittleEndian32
argument_list|()
decl_stmt|;
name|output
operator|.
name|writeRawVarint32
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|output
operator|.
name|writeFixed32NoTag
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
default|default:
throw|throw
name|InvalidProtocolBufferException
operator|.
name|invalidWireType
argument_list|()
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|skipMessage
parameter_list|()
throws|throws
name|IOException
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|tag
init|=
name|readTag
argument_list|()
decl_stmt|;
if|if
condition|(
name|tag
operator|==
literal|0
operator|||
operator|!
name|skipField
argument_list|(
name|tag
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|skipMessage
parameter_list|(
name|CodedOutputStream
name|output
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|tag
init|=
name|readTag
argument_list|()
decl_stmt|;
if|if
condition|(
name|tag
operator|==
literal|0
operator|||
operator|!
name|skipField
argument_list|(
name|tag
argument_list|,
name|output
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
block|}
specifier|public
name|double
name|readDouble
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|Double
operator|.
name|longBitsToDouble
argument_list|(
name|readRawLittleEndian64
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|float
name|readFloat
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|Float
operator|.
name|intBitsToFloat
argument_list|(
name|readRawLittleEndian32
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readUInt64
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawVarint64
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readInt64
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawVarint64
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readInt32
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawVarint32
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readFixed64
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawLittleEndian64
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readFixed32
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawLittleEndian32
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|readBool
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawVarint64
argument_list|()
operator|!=
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|readString
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|size
init|=
name|readRawVarint32
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|<=
name|remaining
argument_list|()
condition|)
block|{
name|byte
index|[]
name|bytes
init|=
name|copyToArray
argument_list|(
name|pos
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|size
expr_stmt|;
return|return
operator|new
name|String
argument_list|(
name|bytes
argument_list|,
name|UTF_8
argument_list|)
return|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
literal|""
return|;
block|}
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|negativeSize
argument_list|()
throw|;
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|readStringRequireUtf8
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|size
init|=
name|readRawVarint32
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|<=
name|remaining
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|Utf8
operator|.
name|isValidUtf8
argument_list|(
name|buffer
argument_list|,
name|pos
argument_list|,
name|pos
operator|+
name|size
argument_list|)
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|invalidUtf8
argument_list|()
throw|;
block|}
name|byte
index|[]
name|bytes
init|=
name|copyToArray
argument_list|(
name|pos
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|size
expr_stmt|;
return|return
operator|new
name|String
argument_list|(
name|bytes
argument_list|,
name|UTF_8
argument_list|)
return|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
literal|""
return|;
block|}
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|negativeSize
argument_list|()
throw|;
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readGroup
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|MessageLite
operator|.
name|Builder
name|builder
parameter_list|,
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|recursionDepth
operator|>=
name|recursionLimit
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|recursionLimitExceeded
argument_list|()
throw|;
block|}
operator|++
name|recursionDepth
expr_stmt|;
name|builder
operator|.
name|mergeFrom
argument_list|(
name|this
argument_list|,
name|extensionRegistry
argument_list|)
expr_stmt|;
name|checkLastTagWas
argument_list|(
name|WireFormat
operator|.
name|makeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|recursionDepth
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|MessageLite
parameter_list|>
name|T
name|readGroup
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|Parser
argument_list|<
name|T
argument_list|>
name|parser
parameter_list|,
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|recursionDepth
operator|>=
name|recursionLimit
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|recursionLimitExceeded
argument_list|()
throw|;
block|}
operator|++
name|recursionDepth
expr_stmt|;
name|T
name|result
init|=
name|parser
operator|.
name|parsePartialFrom
argument_list|(
name|this
argument_list|,
name|extensionRegistry
argument_list|)
decl_stmt|;
name|checkLastTagWas
argument_list|(
name|WireFormat
operator|.
name|makeTag
argument_list|(
name|fieldNumber
argument_list|,
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|recursionDepth
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Deprecated
annotation|@
name|Override
specifier|public
name|void
name|readUnknownGroup
parameter_list|(
name|int
name|fieldNumber
parameter_list|,
name|MessageLite
operator|.
name|Builder
name|builder
parameter_list|)
throws|throws
name|IOException
block|{
name|readGroup
argument_list|(
name|fieldNumber
argument_list|,
name|builder
argument_list|,
name|ExtensionRegistryLite
operator|.
name|getEmptyRegistry
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readMessage
parameter_list|(
name|MessageLite
operator|.
name|Builder
name|builder
parameter_list|,
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|length
init|=
name|readRawVarint32
argument_list|()
decl_stmt|;
if|if
condition|(
name|recursionDepth
operator|>=
name|recursionLimit
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|recursionLimitExceeded
argument_list|()
throw|;
block|}
specifier|final
name|int
name|oldLimit
init|=
name|pushLimit
argument_list|(
name|length
argument_list|)
decl_stmt|;
operator|++
name|recursionDepth
expr_stmt|;
name|builder
operator|.
name|mergeFrom
argument_list|(
name|this
argument_list|,
name|extensionRegistry
argument_list|)
expr_stmt|;
name|checkLastTagWas
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|--
name|recursionDepth
expr_stmt|;
name|popLimit
argument_list|(
name|oldLimit
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|MessageLite
parameter_list|>
name|T
name|readMessage
parameter_list|(
name|Parser
argument_list|<
name|T
argument_list|>
name|parser
parameter_list|,
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|length
init|=
name|readRawVarint32
argument_list|()
decl_stmt|;
if|if
condition|(
name|recursionDepth
operator|>=
name|recursionLimit
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|recursionLimitExceeded
argument_list|()
throw|;
block|}
specifier|final
name|int
name|oldLimit
init|=
name|pushLimit
argument_list|(
name|length
argument_list|)
decl_stmt|;
operator|++
name|recursionDepth
expr_stmt|;
name|T
name|result
init|=
name|parser
operator|.
name|parsePartialFrom
argument_list|(
name|this
argument_list|,
name|extensionRegistry
argument_list|)
decl_stmt|;
name|checkLastTagWas
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|--
name|recursionDepth
expr_stmt|;
name|popLimit
argument_list|(
name|oldLimit
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|ByteString
name|readBytes
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|size
init|=
name|readRawVarint32
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|<=
operator|(
name|limit
operator|-
name|pos
operator|)
condition|)
block|{
comment|// Fast path:  We already have the bytes in a contiguous buffer, so
comment|//   just copy directly from it.
specifier|final
name|ByteString
name|result
init|=
name|immutable
operator|&&
name|enableAliasing
condition|?
name|ByteString
operator|.
name|wrap
argument_list|(
name|buffer
argument_list|,
name|pos
argument_list|,
name|size
argument_list|)
else|:
name|ByteString
operator|.
name|wrap
argument_list|(
name|copyToArray
argument_list|(
name|pos
argument_list|,
name|size
argument_list|)
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|size
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
name|ByteString
operator|.
name|EMPTY
return|;
block|}
comment|// Slow path:  Build a byte array first then copy it.
return|return
name|ByteString
operator|.
name|wrap
argument_list|(
name|readRawBytes
argument_list|(
name|size
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|readByteArray
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawBytes
argument_list|(
name|readRawVarint32
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|ByteBuffer
name|readByteBuffer
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|readByteArray
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readUInt32
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawVarint32
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readEnum
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawVarint32
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readSFixed32
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawLittleEndian32
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readSFixed64
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|readRawLittleEndian64
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readSInt32
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|decodeZigZag32
argument_list|(
name|readRawVarint32
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readSInt64
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|decodeZigZag64
argument_list|(
name|readRawVarint64
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readRawVarint32
parameter_list|()
throws|throws
name|IOException
block|{
comment|// See implementation notes for readRawVarint64
name|fastpath
label|:
block|{
name|int
name|tempPos
init|=
name|pos
decl_stmt|;
if|if
condition|(
name|limit
operator|==
name|tempPos
condition|)
block|{
break|break
name|fastpath
break|;
block|}
name|int
name|x
decl_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|pos
operator|=
name|tempPos
expr_stmt|;
return|return
name|x
return|;
block|}
elseif|else
if|if
condition|(
name|limit
operator|-
name|tempPos
operator|<
literal|9
condition|)
block|{
break|break
name|fastpath
break|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|^=
operator|(
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<<
literal|7
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|^=
operator|(
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<<
literal|14
operator|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|14
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|^=
operator|(
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<<
literal|21
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|21
operator|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|y
init|=
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|++
argument_list|)
decl_stmt|;
name|x
operator|^=
name|y
operator|<<
literal|28
expr_stmt|;
name|x
operator|^=
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|21
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|28
operator|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
operator|&&
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<
literal|0
operator|&&
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<
literal|0
operator|&&
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<
literal|0
operator|&&
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<
literal|0
operator|&&
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<
literal|0
condition|)
block|{
break|break
name|fastpath
break|;
comment|// Will throw malformedVarint()
block|}
block|}
name|pos
operator|=
name|tempPos
expr_stmt|;
return|return
name|x
return|;
block|}
return|return
operator|(
name|int
operator|)
name|readRawVarint64SlowPath
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readRawVarint64
parameter_list|()
throws|throws
name|IOException
block|{
name|fastpath
label|:
block|{
name|int
name|tempPos
init|=
name|pos
decl_stmt|;
if|if
condition|(
name|limit
operator|==
name|tempPos
condition|)
block|{
break|break
name|fastpath
break|;
block|}
name|long
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|pos
operator|=
name|tempPos
expr_stmt|;
return|return
name|y
return|;
block|}
elseif|else
if|if
condition|(
name|limit
operator|-
name|tempPos
operator|<
literal|9
condition|)
block|{
break|break
name|fastpath
break|;
block|}
elseif|else
if|if
condition|(
operator|(
name|y
operator|^=
operator|(
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<<
literal|7
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
name|x
operator|=
name|y
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|y
operator|^=
operator|(
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<<
literal|14
operator|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|x
operator|=
name|y
operator|^
operator|(
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|14
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|y
operator|^=
operator|(
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<<
literal|21
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
name|x
operator|=
name|y
operator|^
operator|(
operator|(
operator|~
literal|0
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0
operator|<<
literal|21
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|=
name|y
operator|^
operator|(
operator|(
name|long
operator|)
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<<
literal|28
operator|)
operator|)
operator|>=
literal|0L
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0L
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|21
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|28
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|^=
operator|(
operator|(
name|long
operator|)
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<<
literal|35
operator|)
operator|)
operator|<
literal|0L
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0L
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|21
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|28
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|35
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|^=
operator|(
operator|(
name|long
operator|)
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<<
literal|42
operator|)
operator|)
operator|>=
literal|0L
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0L
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|21
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|28
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|35
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|42
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|^=
operator|(
operator|(
name|long
operator|)
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<<
literal|49
operator|)
operator|)
operator|<
literal|0L
condition|)
block|{
name|x
operator|^=
operator|(
operator|~
literal|0L
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|21
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|28
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|35
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|42
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|49
operator|)
expr_stmt|;
block|}
else|else
block|{
name|x
operator|^=
operator|(
operator|(
name|long
operator|)
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<<
literal|56
operator|)
expr_stmt|;
name|x
operator|^=
operator|(
operator|~
literal|0L
operator|<<
literal|7
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|14
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|21
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|28
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|35
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|42
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|49
operator|)
operator|^
operator|(
operator|~
literal|0L
operator|<<
literal|56
operator|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0L
condition|)
block|{
if|if
condition|(
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|++
argument_list|)
operator|<
literal|0L
condition|)
block|{
break|break
name|fastpath
break|;
comment|// Will throw malformedVarint()
block|}
block|}
block|}
name|pos
operator|=
name|tempPos
expr_stmt|;
return|return
name|x
return|;
block|}
return|return
name|readRawVarint64SlowPath
argument_list|()
return|;
block|}
annotation|@
name|Override
name|long
name|readRawVarint64SlowPath
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|result
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|shift
init|=
literal|0
init|;
name|shift
operator|<
literal|64
condition|;
name|shift
operator|+=
literal|7
control|)
block|{
specifier|final
name|byte
name|b
init|=
name|readRawByte
argument_list|()
decl_stmt|;
name|result
operator||=
call|(
name|long
call|)
argument_list|(
name|b
operator|&
literal|0x7F
argument_list|)
operator|<<
name|shift
expr_stmt|;
if|if
condition|(
operator|(
name|b
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|malformedVarint
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|readRawLittleEndian32
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|tempPos
init|=
name|pos
decl_stmt|;
if|if
condition|(
name|limit
operator|-
name|tempPos
operator|<
name|FIXED_32_SIZE
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
name|pos
operator|=
name|tempPos
operator|+
name|FIXED_32_SIZE
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
argument_list|)
operator|&
literal|0xff
operator|)
operator|)
operator||
operator|(
operator|(
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|+
literal|1
argument_list|)
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|+
literal|2
argument_list|)
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|+
literal|3
argument_list|)
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|readRawLittleEndian64
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|tempPos
init|=
name|pos
decl_stmt|;
if|if
condition|(
name|limit
operator|-
name|tempPos
operator|<
name|FIXED_64_SIZE
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
name|pos
operator|=
name|tempPos
operator|+
name|FIXED_64_SIZE
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
argument_list|)
operator|&
literal|0xffL
operator|)
operator|)
operator||
operator|(
operator|(
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|+
literal|1
argument_list|)
operator|&
literal|0xffL
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|+
literal|2
argument_list|)
operator|&
literal|0xffL
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|+
literal|3
argument_list|)
operator|&
literal|0xffL
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|+
literal|4
argument_list|)
operator|&
literal|0xffL
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|+
literal|5
argument_list|)
operator|&
literal|0xffL
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|+
literal|6
argument_list|)
operator|&
literal|0xffL
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
name|buffer
operator|.
name|read
argument_list|(
name|tempPos
operator|+
literal|7
argument_list|)
operator|&
literal|0xffL
operator|)
operator|<<
literal|56
operator|)
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|enableAliasing
parameter_list|(
name|boolean
name|enabled
parameter_list|)
block|{
name|this
operator|.
name|enableAliasing
operator|=
name|enabled
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|resetSizeCounter
parameter_list|()
block|{
name|startPos
operator|=
name|pos
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|pushLimit
parameter_list|(
name|int
name|byteLimit
parameter_list|)
throws|throws
name|InvalidProtocolBufferException
block|{
if|if
condition|(
name|byteLimit
operator|<
literal|0
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|negativeSize
argument_list|()
throw|;
block|}
name|byteLimit
operator|+=
name|getTotalBytesRead
argument_list|()
expr_stmt|;
specifier|final
name|int
name|oldLimit
init|=
name|currentLimit
decl_stmt|;
if|if
condition|(
name|byteLimit
operator|>
name|oldLimit
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
name|currentLimit
operator|=
name|byteLimit
expr_stmt|;
name|recomputeBufferSizeAfterLimit
argument_list|()
expr_stmt|;
return|return
name|oldLimit
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|popLimit
parameter_list|(
name|int
name|oldLimit
parameter_list|)
block|{
name|currentLimit
operator|=
name|oldLimit
expr_stmt|;
name|recomputeBufferSizeAfterLimit
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getBytesUntilLimit
parameter_list|()
block|{
if|if
condition|(
name|currentLimit
operator|==
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
name|currentLimit
operator|-
name|getTotalBytesRead
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isAtEnd
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|pos
operator|==
name|limit
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getTotalBytesRead
parameter_list|()
block|{
return|return
name|pos
operator|-
name|startPos
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
name|readRawByte
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|pos
operator|==
name|limit
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
return|return
name|buffer
operator|.
name|read
argument_list|(
name|pos
operator|++
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|readRawBytes
parameter_list|(
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|length
operator|>
literal|0
operator|&&
name|length
operator|<=
operator|(
name|limit
operator|-
name|pos
operator|)
condition|)
block|{
name|byte
index|[]
name|bytes
init|=
name|copyToArray
argument_list|(
name|pos
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|length
expr_stmt|;
return|return
name|bytes
return|;
block|}
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|Internal
operator|.
name|EMPTY_BYTE_ARRAY
return|;
block|}
else|else
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|negativeSize
argument_list|()
throw|;
block|}
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|skipRawBytes
parameter_list|(
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|length
operator|>=
literal|0
operator|&&
name|length
operator|<=
operator|(
name|limit
operator|-
name|pos
operator|)
condition|)
block|{
comment|// We have all the bytes we need already.
name|pos
operator|+=
name|length
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|negativeSize
argument_list|()
throw|;
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
specifier|private
name|void
name|recomputeBufferSizeAfterLimit
parameter_list|()
block|{
name|limit
operator|+=
name|bufferSizeAfterLimit
expr_stmt|;
specifier|final
name|int
name|bufferEnd
init|=
name|limit
operator|-
name|startPos
decl_stmt|;
if|if
condition|(
name|bufferEnd
operator|>
name|currentLimit
condition|)
block|{
comment|// Limit is in current buffer.
name|bufferSizeAfterLimit
operator|=
name|bufferEnd
operator|-
name|currentLimit
expr_stmt|;
name|limit
operator|-=
name|bufferSizeAfterLimit
expr_stmt|;
block|}
else|else
block|{
name|bufferSizeAfterLimit
operator|=
literal|0
expr_stmt|;
block|}
block|}
specifier|private
name|int
name|remaining
parameter_list|()
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|limit
operator|-
name|pos
argument_list|)
return|;
block|}
specifier|private
name|byte
index|[]
name|copyToArray
parameter_list|(
name|int
name|begin
parameter_list|,
name|int
name|size
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|size
index|]
decl_stmt|;
name|buffer
operator|.
name|read
argument_list|(
name|begin
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
return|return
name|bytes
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
name|InvalidProtocolBufferException
operator|.
name|truncatedMessage
argument_list|()
throw|;
block|}
block|}
specifier|private
name|void
name|skipRawVarint
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|limit
operator|-
name|pos
operator|>=
name|MAX_VARINT_SIZE
condition|)
block|{
name|skipRawVarintFastPath
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|skipRawVarintSlowPath
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|skipRawVarintFastPath
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VARINT_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|buffer
operator|.
name|read
argument_list|(
name|pos
operator|++
argument_list|)
operator|>=
literal|0
condition|)
block|{
return|return;
block|}
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|malformedVarint
argument_list|()
throw|;
block|}
specifier|private
name|void
name|skipRawVarintSlowPath
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MAX_VARINT_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|readRawByte
argument_list|()
operator|>=
literal|0
condition|)
block|{
return|return;
block|}
block|}
throw|throw
name|InvalidProtocolBufferException
operator|.
name|malformedVarint
argument_list|()
throw|;
block|}
block|}
block|}
end_class

end_unit

