begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|// Protocol Buffers - Google's data interchange format
end_comment

begin_comment
comment|// Copyright 2008 Google Inc.  All rights reserved.
end_comment

begin_comment
comment|// https://developers.google.com/protocol-buffers/
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Redistribution and use in source and binary forms, with or without
end_comment

begin_comment
comment|// modification, are permitted provided that the following conditions are
end_comment

begin_comment
comment|// met:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//     * Redistributions of source code must retain the above copyright
end_comment

begin_comment
comment|// notice, this list of conditions and the following disclaimer.
end_comment

begin_comment
comment|//     * Redistributions in binary form must reproduce the above
end_comment

begin_comment
comment|// copyright notice, this list of conditions and the following disclaimer
end_comment

begin_comment
comment|// in the documentation and/or other materials provided with the
end_comment

begin_comment
comment|// distribution.
end_comment

begin_comment
comment|//     * Neither the name of Google Inc. nor the names of its
end_comment

begin_comment
comment|// contributors may be used to endorse or promote products derived from
end_comment

begin_comment
comment|// this software without specific prior written permission.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
end_comment

begin_comment
comment|// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
end_comment

begin_comment
comment|// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
end_comment

begin_comment
comment|// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
end_comment

begin_comment
comment|// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
end_comment

begin_comment
comment|// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
end_comment

begin_comment
comment|// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
end_comment

begin_comment
comment|// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
end_comment

begin_comment
comment|// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|AbstractMessageLite
operator|.
name|Builder
operator|.
name|LimitedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_comment
comment|/**  * {@code UnknownFieldSet} is used to keep track of fields which were seen when  * parsing a protocol message but whose field numbers or types are unrecognized.  * This most frequently occurs when new fields are added to a message type  * and then messages containing those fields are read by old software that was  * compiled before the new types were added.  *  *<p>Every {@link Message} contains an {@code UnknownFieldSet} (and every  * {@link Message.Builder} contains an {@link Builder}).  *  *<p>Most users will never need to use this class.  *  * @author kenton@google.com Kenton Varda  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|UnknownFieldSet
implements|implements
name|MessageLite
block|{
specifier|private
name|UnknownFieldSet
parameter_list|()
block|{}
comment|/** Create a new {@link Builder}. */
specifier|public
specifier|static
name|Builder
name|newBuilder
parameter_list|()
block|{
return|return
name|Builder
operator|.
name|create
argument_list|()
return|;
block|}
comment|/**    * Create a new {@link Builder} and initialize it to be a copy    * of {@code copyFrom}.    */
specifier|public
specifier|static
name|Builder
name|newBuilder
parameter_list|(
specifier|final
name|UnknownFieldSet
name|copyFrom
parameter_list|)
block|{
return|return
name|newBuilder
argument_list|()
operator|.
name|mergeFrom
argument_list|(
name|copyFrom
argument_list|)
return|;
block|}
comment|/** Get an empty {@code UnknownFieldSet}. */
specifier|public
specifier|static
name|UnknownFieldSet
name|getDefaultInstance
parameter_list|()
block|{
return|return
name|defaultInstance
return|;
block|}
annotation|@
name|Override
specifier|public
name|UnknownFieldSet
name|getDefaultInstanceForType
parameter_list|()
block|{
return|return
name|defaultInstance
return|;
block|}
specifier|private
specifier|static
specifier|final
name|UnknownFieldSet
name|defaultInstance
init|=
operator|new
name|UnknownFieldSet
argument_list|(
name|Collections
operator|.
expr|<
name|Integer
argument_list|,
name|Field
operator|>
name|emptyMap
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Construct an {@code UnknownFieldSet} around the given map.  The map is    * expected to be immutable.    */
specifier|private
name|UnknownFieldSet
parameter_list|(
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Field
argument_list|>
name|fields
parameter_list|)
block|{
name|this
operator|.
name|fields
operator|=
name|fields
expr_stmt|;
block|}
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|Field
argument_list|>
name|fields
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
specifier|final
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|other
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
operator|(
name|other
operator|instanceof
name|UnknownFieldSet
operator|)
operator|&&
name|fields
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|UnknownFieldSet
operator|)
name|other
operator|)
operator|.
name|fields
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|fields
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|/** Get a map of fields in the set by number. */
specifier|public
name|Map
argument_list|<
name|Integer
argument_list|,
name|Field
argument_list|>
name|asMap
parameter_list|()
block|{
return|return
name|fields
return|;
block|}
comment|/** Check if the given field number is present in the set. */
specifier|public
name|boolean
name|hasField
parameter_list|(
specifier|final
name|int
name|number
parameter_list|)
block|{
return|return
name|fields
operator|.
name|containsKey
argument_list|(
name|number
argument_list|)
return|;
block|}
comment|/**    * Get a field by number.  Returns an empty field if not present.  Never    * returns {@code null}.    */
specifier|public
name|Field
name|getField
parameter_list|(
specifier|final
name|int
name|number
parameter_list|)
block|{
specifier|final
name|Field
name|result
init|=
name|fields
operator|.
name|get
argument_list|(
name|number
argument_list|)
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|Field
operator|.
name|getDefaultInstance
argument_list|()
else|:
name|result
return|;
block|}
comment|/** Serializes the set and writes it to {@code output}. */
annotation|@
name|Override
specifier|public
name|void
name|writeTo
parameter_list|(
specifier|final
name|CodedOutputStream
name|output
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|Field
argument_list|>
name|entry
range|:
name|fields
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Field
name|field
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|field
operator|.
name|writeTo
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Converts the set to a string in protocol buffer text format. This is    * just a trivial wrapper around    * {@link TextFormat#printToString(UnknownFieldSet)}.    */
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|TextFormat
operator|.
name|printToString
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * Serializes the message to a {@code ByteString} and returns it. This is    * just a trivial wrapper around {@link #writeTo(CodedOutputStream)}.    */
annotation|@
name|Override
specifier|public
name|ByteString
name|toByteString
parameter_list|()
block|{
try|try
block|{
specifier|final
name|ByteString
operator|.
name|CodedBuilder
name|out
init|=
name|ByteString
operator|.
name|newCodedBuilder
argument_list|(
name|getSerializedSize
argument_list|()
argument_list|)
decl_stmt|;
name|writeTo
argument_list|(
name|out
operator|.
name|getCodedOutput
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|out
operator|.
name|build
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Serializing to a ByteString threw an IOException (should "
operator|+
literal|"never happen)."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Serializes the message to a {@code byte} array and returns it.  This is    * just a trivial wrapper around {@link #writeTo(CodedOutputStream)}.    */
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|toByteArray
parameter_list|()
block|{
try|try
block|{
specifier|final
name|byte
index|[]
name|result
init|=
operator|new
name|byte
index|[
name|getSerializedSize
argument_list|()
index|]
decl_stmt|;
specifier|final
name|CodedOutputStream
name|output
init|=
name|CodedOutputStream
operator|.
name|newInstance
argument_list|(
name|result
argument_list|)
decl_stmt|;
name|writeTo
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|output
operator|.
name|checkNoSpaceLeft
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Serializing to a byte array threw an IOException "
operator|+
literal|"(should never happen)."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Serializes the message and writes it to {@code output}.  This is just a    * trivial wrapper around {@link #writeTo(CodedOutputStream)}.    */
annotation|@
name|Override
specifier|public
name|void
name|writeTo
parameter_list|(
specifier|final
name|OutputStream
name|output
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|CodedOutputStream
name|codedOutput
init|=
name|CodedOutputStream
operator|.
name|newInstance
argument_list|(
name|output
argument_list|)
decl_stmt|;
name|writeTo
argument_list|(
name|codedOutput
argument_list|)
expr_stmt|;
name|codedOutput
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeDelimitedTo
parameter_list|(
name|OutputStream
name|output
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|CodedOutputStream
name|codedOutput
init|=
name|CodedOutputStream
operator|.
name|newInstance
argument_list|(
name|output
argument_list|)
decl_stmt|;
name|codedOutput
operator|.
name|writeRawVarint32
argument_list|(
name|getSerializedSize
argument_list|()
argument_list|)
expr_stmt|;
name|writeTo
argument_list|(
name|codedOutput
argument_list|)
expr_stmt|;
name|codedOutput
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/** Get the number of bytes required to encode this set. */
annotation|@
name|Override
specifier|public
name|int
name|getSerializedSize
parameter_list|()
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|Field
argument_list|>
name|entry
range|:
name|fields
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|result
operator|+=
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getSerializedSize
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Serializes the set and writes it to {@code output} using    * {@code MessageSet} wire format.    */
specifier|public
name|void
name|writeAsMessageSetTo
parameter_list|(
specifier|final
name|CodedOutputStream
name|output
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|Field
argument_list|>
name|entry
range|:
name|fields
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|writeAsMessageSetExtensionTo
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get the number of bytes required to encode this set using    * {@code MessageSet} wire format.    */
specifier|public
name|int
name|getSerializedSizeAsMessageSet
parameter_list|()
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|Field
argument_list|>
name|entry
range|:
name|fields
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|result
operator|+=
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getSerializedSizeAsMessageSetExtension
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isInitialized
parameter_list|()
block|{
comment|// UnknownFieldSets do not have required fields, so they are always
comment|// initialized.
return|return
literal|true
return|;
block|}
comment|/** Parse an {@code UnknownFieldSet} from the given input stream. */
specifier|public
specifier|static
name|UnknownFieldSet
name|parseFrom
parameter_list|(
specifier|final
name|CodedInputStream
name|input
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|newBuilder
argument_list|()
operator|.
name|mergeFrom
argument_list|(
name|input
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Parse {@code data} as an {@code UnknownFieldSet} and return it. */
specifier|public
specifier|static
name|UnknownFieldSet
name|parseFrom
parameter_list|(
specifier|final
name|ByteString
name|data
parameter_list|)
throws|throws
name|InvalidProtocolBufferException
block|{
return|return
name|newBuilder
argument_list|()
operator|.
name|mergeFrom
argument_list|(
name|data
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Parse {@code data} as an {@code UnknownFieldSet} and return it. */
specifier|public
specifier|static
name|UnknownFieldSet
name|parseFrom
parameter_list|(
specifier|final
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|InvalidProtocolBufferException
block|{
return|return
name|newBuilder
argument_list|()
operator|.
name|mergeFrom
argument_list|(
name|data
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Parse an {@code UnknownFieldSet} from {@code input} and return it. */
specifier|public
specifier|static
name|UnknownFieldSet
name|parseFrom
parameter_list|(
specifier|final
name|InputStream
name|input
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|newBuilder
argument_list|()
operator|.
name|mergeFrom
argument_list|(
name|input
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Builder
name|newBuilderForType
parameter_list|()
block|{
return|return
name|newBuilder
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Builder
name|toBuilder
parameter_list|()
block|{
return|return
name|newBuilder
argument_list|()
operator|.
name|mergeFrom
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * Builder for {@link UnknownFieldSet}s.    *    *<p>Note that this class maintains {@link Field.Builder}s for all fields    * in the set.  Thus, adding one element to an existing {@link Field} does not    * require making a copy.  This is important for efficient parsing of    * unknown repeated fields.  However, it implies that {@link Field}s cannot    * be constructed independently, nor can two {@link UnknownFieldSet}s share    * the same {@code Field} object.    *    *<p>Use {@link UnknownFieldSet#newBuilder()} to construct a {@code Builder}.    */
specifier|public
specifier|static
specifier|final
class|class
name|Builder
implements|implements
name|MessageLite
operator|.
name|Builder
block|{
comment|// This constructor should never be called directly (except from 'create').
specifier|private
name|Builder
parameter_list|()
block|{}
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|Field
argument_list|>
name|fields
decl_stmt|;
comment|// Optimization:  We keep around a builder for the last field that was
comment|//   modified so that we can efficiently add to it multiple times in a
comment|//   row (important when parsing an unknown repeated field).
specifier|private
name|int
name|lastFieldNumber
decl_stmt|;
specifier|private
name|Field
operator|.
name|Builder
name|lastField
decl_stmt|;
specifier|private
specifier|static
name|Builder
name|create
parameter_list|()
block|{
name|Builder
name|builder
init|=
operator|new
name|Builder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|reinitialize
argument_list|()
expr_stmt|;
return|return
name|builder
return|;
block|}
comment|/**      * Get a field builder for the given field number which includes any      * values that already exist.      */
specifier|private
name|Field
operator|.
name|Builder
name|getFieldBuilder
parameter_list|(
specifier|final
name|int
name|number
parameter_list|)
block|{
if|if
condition|(
name|lastField
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|number
operator|==
name|lastFieldNumber
condition|)
block|{
return|return
name|lastField
return|;
block|}
comment|// Note:  addField() will reset lastField and lastFieldNumber.
name|addField
argument_list|(
name|lastFieldNumber
argument_list|,
name|lastField
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|number
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
specifier|final
name|Field
name|existing
init|=
name|fields
operator|.
name|get
argument_list|(
name|number
argument_list|)
decl_stmt|;
name|lastFieldNumber
operator|=
name|number
expr_stmt|;
name|lastField
operator|=
name|Field
operator|.
name|newBuilder
argument_list|()
expr_stmt|;
if|if
condition|(
name|existing
operator|!=
literal|null
condition|)
block|{
name|lastField
operator|.
name|mergeFrom
argument_list|(
name|existing
argument_list|)
expr_stmt|;
block|}
return|return
name|lastField
return|;
block|}
block|}
comment|/**      * Build the {@link UnknownFieldSet} and return it.      *      *<p>Once {@code build()} has been called, the {@code Builder} will no      * longer be usable.  Calling any method after {@code build()} will result      * in undefined behavior and can cause a {@code NullPointerException} to be      * thrown.      */
annotation|@
name|Override
specifier|public
name|UnknownFieldSet
name|build
parameter_list|()
block|{
name|getFieldBuilder
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// Force lastField to be built.
specifier|final
name|UnknownFieldSet
name|result
decl_stmt|;
if|if
condition|(
name|fields
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|result
operator|=
name|getDefaultInstance
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
operator|new
name|UnknownFieldSet
argument_list|(
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|fields
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fields
operator|=
literal|null
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|UnknownFieldSet
name|buildPartial
parameter_list|()
block|{
comment|// No required fields, so this is the same as build().
return|return
name|build
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Builder
name|clone
parameter_list|()
block|{
name|getFieldBuilder
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// Force lastField to be built.
return|return
name|UnknownFieldSet
operator|.
name|newBuilder
argument_list|()
operator|.
name|mergeFrom
argument_list|(
operator|new
name|UnknownFieldSet
argument_list|(
name|fields
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|UnknownFieldSet
name|getDefaultInstanceForType
parameter_list|()
block|{
return|return
name|UnknownFieldSet
operator|.
name|getDefaultInstance
argument_list|()
return|;
block|}
specifier|private
name|void
name|reinitialize
parameter_list|()
block|{
name|fields
operator|=
name|Collections
operator|.
name|emptyMap
argument_list|()
expr_stmt|;
name|lastFieldNumber
operator|=
literal|0
expr_stmt|;
name|lastField
operator|=
literal|null
expr_stmt|;
block|}
comment|/** Reset the builder to an empty set. */
annotation|@
name|Override
specifier|public
name|Builder
name|clear
parameter_list|()
block|{
name|reinitialize
argument_list|()
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Clear fields from the set with a given field number. */
specifier|public
name|Builder
name|clearField
parameter_list|(
specifier|final
name|int
name|number
parameter_list|)
block|{
if|if
condition|(
name|number
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Zero is not a valid field number."
argument_list|)
throw|;
block|}
if|if
condition|(
name|lastField
operator|!=
literal|null
operator|&&
name|lastFieldNumber
operator|==
name|number
condition|)
block|{
comment|// Discard this.
name|lastField
operator|=
literal|null
expr_stmt|;
name|lastFieldNumber
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|fields
operator|.
name|containsKey
argument_list|(
name|number
argument_list|)
condition|)
block|{
name|fields
operator|.
name|remove
argument_list|(
name|number
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/**      * Merge the fields from {@code other} into this set.  If a field number      * exists in both sets, {@code other}'s values for that field will be      * appended to the values in this set.      */
specifier|public
name|Builder
name|mergeFrom
parameter_list|(
specifier|final
name|UnknownFieldSet
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|!=
name|getDefaultInstance
argument_list|()
condition|)
block|{
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|Field
argument_list|>
name|entry
range|:
name|other
operator|.
name|fields
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|mergeField
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|this
return|;
block|}
comment|/**      * Add a field to the {@code UnknownFieldSet}.  If a field with the same      * number already exists, the two are merged.      */
specifier|public
name|Builder
name|mergeField
parameter_list|(
specifier|final
name|int
name|number
parameter_list|,
specifier|final
name|Field
name|field
parameter_list|)
block|{
if|if
condition|(
name|number
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Zero is not a valid field number."
argument_list|)
throw|;
block|}
if|if
condition|(
name|hasField
argument_list|(
name|number
argument_list|)
condition|)
block|{
name|getFieldBuilder
argument_list|(
name|number
argument_list|)
operator|.
name|mergeFrom
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Optimization:  We could call getFieldBuilder(number).mergeFrom(field)
comment|// in this case, but that would create a copy of the Field object.
comment|// We'd rather reuse the one passed to us, so call addField() instead.
name|addField
argument_list|(
name|number
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/**      * Convenience method for merging a new field containing a single varint      * value.  This is used in particular when an unknown enum value is      * encountered.      */
specifier|public
name|Builder
name|mergeVarintField
parameter_list|(
specifier|final
name|int
name|number
parameter_list|,
specifier|final
name|int
name|value
parameter_list|)
block|{
if|if
condition|(
name|number
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Zero is not a valid field number."
argument_list|)
throw|;
block|}
name|getFieldBuilder
argument_list|(
name|number
argument_list|)
operator|.
name|addVarint
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Convenience method for merging a length-delimited field.      *      *<p>For use by generated code only.      */
specifier|public
name|Builder
name|mergeLengthDelimitedField
parameter_list|(
specifier|final
name|int
name|number
parameter_list|,
specifier|final
name|ByteString
name|value
parameter_list|)
block|{
if|if
condition|(
name|number
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Zero is not a valid field number."
argument_list|)
throw|;
block|}
name|getFieldBuilder
argument_list|(
name|number
argument_list|)
operator|.
name|addLengthDelimited
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Check if the given field number is present in the set. */
specifier|public
name|boolean
name|hasField
parameter_list|(
specifier|final
name|int
name|number
parameter_list|)
block|{
if|if
condition|(
name|number
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Zero is not a valid field number."
argument_list|)
throw|;
block|}
return|return
name|number
operator|==
name|lastFieldNumber
operator|||
name|fields
operator|.
name|containsKey
argument_list|(
name|number
argument_list|)
return|;
block|}
comment|/**      * Add a field to the {@code UnknownFieldSet}.  If a field with the same      * number already exists, it is removed.      */
specifier|public
name|Builder
name|addField
parameter_list|(
specifier|final
name|int
name|number
parameter_list|,
specifier|final
name|Field
name|field
parameter_list|)
block|{
if|if
condition|(
name|number
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Zero is not a valid field number."
argument_list|)
throw|;
block|}
if|if
condition|(
name|lastField
operator|!=
literal|null
operator|&&
name|lastFieldNumber
operator|==
name|number
condition|)
block|{
comment|// Discard this.
name|lastField
operator|=
literal|null
expr_stmt|;
name|lastFieldNumber
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|fields
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fields
operator|=
operator|new
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|Field
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|fields
operator|.
name|put
argument_list|(
name|number
argument_list|,
name|field
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Get all present {@code Field}s as an immutable {@code Map}.  If more      * fields are added, the changes may or may not be reflected in this map.      */
specifier|public
name|Map
argument_list|<
name|Integer
argument_list|,
name|Field
argument_list|>
name|asMap
parameter_list|()
block|{
name|getFieldBuilder
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// Force lastField to be built.
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|fields
argument_list|)
return|;
block|}
comment|/**      * Parse an entire message from {@code input} and merge its fields into      * this set.      */
annotation|@
name|Override
specifier|public
name|Builder
name|mergeFrom
parameter_list|(
specifier|final
name|CodedInputStream
name|input
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|tag
init|=
name|input
operator|.
name|readTag
argument_list|()
decl_stmt|;
if|if
condition|(
name|tag
operator|==
literal|0
operator|||
operator|!
name|mergeFieldFrom
argument_list|(
name|tag
argument_list|,
name|input
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
return|return
name|this
return|;
block|}
comment|/**      * Parse a single field from {@code input} and merge it into this set.      * @param tag The field's tag number, which was already parsed.      * @return {@code false} if the tag is an end group tag.      */
specifier|public
name|boolean
name|mergeFieldFrom
parameter_list|(
specifier|final
name|int
name|tag
parameter_list|,
specifier|final
name|CodedInputStream
name|input
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|number
init|=
name|WireFormat
operator|.
name|getTagFieldNumber
argument_list|(
name|tag
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|WireFormat
operator|.
name|getTagWireType
argument_list|(
name|tag
argument_list|)
condition|)
block|{
case|case
name|WireFormat
operator|.
name|WIRETYPE_VARINT
case|:
name|getFieldBuilder
argument_list|(
name|number
argument_list|)
operator|.
name|addVarint
argument_list|(
name|input
operator|.
name|readInt64
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
name|WireFormat
operator|.
name|WIRETYPE_FIXED64
case|:
name|getFieldBuilder
argument_list|(
name|number
argument_list|)
operator|.
name|addFixed64
argument_list|(
name|input
operator|.
name|readFixed64
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
name|WireFormat
operator|.
name|WIRETYPE_LENGTH_DELIMITED
case|:
name|getFieldBuilder
argument_list|(
name|number
argument_list|)
operator|.
name|addLengthDelimited
argument_list|(
name|input
operator|.
name|readBytes
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
name|WireFormat
operator|.
name|WIRETYPE_START_GROUP
case|:
specifier|final
name|Builder
name|subBuilder
init|=
name|newBuilder
argument_list|()
decl_stmt|;
name|input
operator|.
name|readGroup
argument_list|(
name|number
argument_list|,
name|subBuilder
argument_list|,
name|ExtensionRegistry
operator|.
name|getEmptyRegistry
argument_list|()
argument_list|)
expr_stmt|;
name|getFieldBuilder
argument_list|(
name|number
argument_list|)
operator|.
name|addGroup
argument_list|(
name|subBuilder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
case|case
name|WireFormat
operator|.
name|WIRETYPE_END_GROUP
case|:
return|return
literal|false
return|;
case|case
name|WireFormat
operator|.
name|WIRETYPE_FIXED32
case|:
name|getFieldBuilder
argument_list|(
name|number
argument_list|)
operator|.
name|addFixed32
argument_list|(
name|input
operator|.
name|readFixed32
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
default|default:
throw|throw
name|InvalidProtocolBufferException
operator|.
name|invalidWireType
argument_list|()
throw|;
block|}
block|}
comment|/**      * Parse {@code data} as an {@code UnknownFieldSet} and merge it with the      * set being built.  This is just a small wrapper around      * {@link #mergeFrom(CodedInputStream)}.      */
annotation|@
name|Override
specifier|public
name|Builder
name|mergeFrom
parameter_list|(
specifier|final
name|ByteString
name|data
parameter_list|)
throws|throws
name|InvalidProtocolBufferException
block|{
try|try
block|{
specifier|final
name|CodedInputStream
name|input
init|=
name|data
operator|.
name|newCodedInput
argument_list|()
decl_stmt|;
name|mergeFrom
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|input
operator|.
name|checkLastTagWas
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|InvalidProtocolBufferException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Reading from a ByteString threw an IOException (should "
operator|+
literal|"never happen)."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Parse {@code data} as an {@code UnknownFieldSet} and merge it with the      * set being built.  This is just a small wrapper around      * {@link #mergeFrom(CodedInputStream)}.      */
annotation|@
name|Override
specifier|public
name|Builder
name|mergeFrom
parameter_list|(
specifier|final
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|InvalidProtocolBufferException
block|{
try|try
block|{
specifier|final
name|CodedInputStream
name|input
init|=
name|CodedInputStream
operator|.
name|newInstance
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|mergeFrom
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|input
operator|.
name|checkLastTagWas
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|InvalidProtocolBufferException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Reading from a byte array threw an IOException (should "
operator|+
literal|"never happen)."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Parse an {@code UnknownFieldSet} from {@code input} and merge it with the      * set being built.  This is just a small wrapper around      * {@link #mergeFrom(CodedInputStream)}.      */
annotation|@
name|Override
specifier|public
name|Builder
name|mergeFrom
parameter_list|(
specifier|final
name|InputStream
name|input
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|CodedInputStream
name|codedInput
init|=
name|CodedInputStream
operator|.
name|newInstance
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|mergeFrom
argument_list|(
name|codedInput
argument_list|)
expr_stmt|;
name|codedInput
operator|.
name|checkLastTagWas
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|mergeDelimitedFrom
parameter_list|(
name|InputStream
name|input
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|firstByte
init|=
name|input
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|firstByte
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|int
name|size
init|=
name|CodedInputStream
operator|.
name|readRawVarint32
argument_list|(
name|firstByte
argument_list|,
name|input
argument_list|)
decl_stmt|;
specifier|final
name|InputStream
name|limitedInput
init|=
operator|new
name|LimitedInputStream
argument_list|(
name|input
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|mergeFrom
argument_list|(
name|limitedInput
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|mergeDelimitedFrom
parameter_list|(
name|InputStream
name|input
parameter_list|,
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|)
throws|throws
name|IOException
block|{
comment|// UnknownFieldSet has no extensions.
return|return
name|mergeDelimitedFrom
argument_list|(
name|input
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Builder
name|mergeFrom
parameter_list|(
name|CodedInputStream
name|input
parameter_list|,
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|)
throws|throws
name|IOException
block|{
comment|// UnknownFieldSet has no extensions.
return|return
name|mergeFrom
argument_list|(
name|input
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Builder
name|mergeFrom
parameter_list|(
name|ByteString
name|data
parameter_list|,
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|)
throws|throws
name|InvalidProtocolBufferException
block|{
comment|// UnknownFieldSet has no extensions.
return|return
name|mergeFrom
argument_list|(
name|data
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Builder
name|mergeFrom
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|InvalidProtocolBufferException
block|{
try|try
block|{
specifier|final
name|CodedInputStream
name|input
init|=
name|CodedInputStream
operator|.
name|newInstance
argument_list|(
name|data
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|mergeFrom
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|input
operator|.
name|checkLastTagWas
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
catch|catch
parameter_list|(
name|InvalidProtocolBufferException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Reading from a byte array threw an IOException (should "
operator|+
literal|"never happen)."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Builder
name|mergeFrom
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|)
throws|throws
name|InvalidProtocolBufferException
block|{
comment|// UnknownFieldSet has no extensions.
return|return
name|mergeFrom
argument_list|(
name|data
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Builder
name|mergeFrom
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|,
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|)
throws|throws
name|InvalidProtocolBufferException
block|{
comment|// UnknownFieldSet has no extensions.
return|return
name|mergeFrom
argument_list|(
name|data
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Builder
name|mergeFrom
parameter_list|(
name|InputStream
name|input
parameter_list|,
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|)
throws|throws
name|IOException
block|{
comment|// UnknownFieldSet has no extensions.
return|return
name|mergeFrom
argument_list|(
name|input
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Builder
name|mergeFrom
parameter_list|(
name|MessageLite
name|m
parameter_list|)
block|{
if|if
condition|(
name|m
operator|instanceof
name|UnknownFieldSet
condition|)
block|{
return|return
name|mergeFrom
argument_list|(
operator|(
name|UnknownFieldSet
operator|)
name|m
argument_list|)
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"mergeFrom(MessageLite) can only merge messages of the same type."
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isInitialized
parameter_list|()
block|{
comment|// UnknownFieldSets do not have required fields, so they are always
comment|// initialized.
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Represents a single field in an {@code UnknownFieldSet}.    *    *<p>A {@code Field} consists of five lists of values.  The lists correspond    * to the five "wire types" used in the protocol buffer binary format.    * The wire type of each field can be determined from the encoded form alone,    * without knowing the field's declared type.  So, we are able to parse    * unknown values at least this far and separate them.  Normally, only one    * of the five lists will contain any values, since it is impossible to    * define a valid message type that declares two different types for the    * same field number.  However, the code is designed to allow for the case    * where the same unknown field number is encountered using multiple different    * wire types.    *    *<p>{@code Field} is an immutable class.  To construct one, you must use a    * {@link Builder}.    *    * @see UnknownFieldSet    */
specifier|public
specifier|static
specifier|final
class|class
name|Field
block|{
specifier|private
name|Field
parameter_list|()
block|{}
comment|/** Construct a new {@link Builder}. */
specifier|public
specifier|static
name|Builder
name|newBuilder
parameter_list|()
block|{
return|return
name|Builder
operator|.
name|create
argument_list|()
return|;
block|}
comment|/**      * Construct a new {@link Builder} and initialize it to a copy of      * {@code copyFrom}.      */
specifier|public
specifier|static
name|Builder
name|newBuilder
parameter_list|(
specifier|final
name|Field
name|copyFrom
parameter_list|)
block|{
return|return
name|newBuilder
argument_list|()
operator|.
name|mergeFrom
argument_list|(
name|copyFrom
argument_list|)
return|;
block|}
comment|/** Get an empty {@code Field}. */
specifier|public
specifier|static
name|Field
name|getDefaultInstance
parameter_list|()
block|{
return|return
name|fieldDefaultInstance
return|;
block|}
specifier|private
specifier|static
specifier|final
name|Field
name|fieldDefaultInstance
init|=
name|newBuilder
argument_list|()
operator|.
name|build
argument_list|()
decl_stmt|;
comment|/** Get the list of varint values for this field. */
specifier|public
name|List
argument_list|<
name|Long
argument_list|>
name|getVarintList
parameter_list|()
block|{
return|return
name|varint
return|;
block|}
comment|/** Get the list of fixed32 values for this field. */
specifier|public
name|List
argument_list|<
name|Integer
argument_list|>
name|getFixed32List
parameter_list|()
block|{
return|return
name|fixed32
return|;
block|}
comment|/** Get the list of fixed64 values for this field. */
specifier|public
name|List
argument_list|<
name|Long
argument_list|>
name|getFixed64List
parameter_list|()
block|{
return|return
name|fixed64
return|;
block|}
comment|/** Get the list of length-delimited values for this field. */
specifier|public
name|List
argument_list|<
name|ByteString
argument_list|>
name|getLengthDelimitedList
parameter_list|()
block|{
return|return
name|lengthDelimited
return|;
block|}
comment|/**      * Get the list of embedded group values for this field.  These are      * represented using {@link UnknownFieldSet}s rather than {@link Message}s      * since the group's type is presumably unknown.      */
specifier|public
name|List
argument_list|<
name|UnknownFieldSet
argument_list|>
name|getGroupList
parameter_list|()
block|{
return|return
name|group
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
specifier|final
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|other
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|other
operator|instanceof
name|Field
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|Arrays
operator|.
name|equals
argument_list|(
name|getIdentityArray
argument_list|()
argument_list|,
operator|(
operator|(
name|Field
operator|)
name|other
operator|)
operator|.
name|getIdentityArray
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Arrays
operator|.
name|hashCode
argument_list|(
name|getIdentityArray
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns the array of objects to be used to uniquely identify this      * {@link Field} instance.      */
specifier|private
name|Object
index|[]
name|getIdentityArray
parameter_list|()
block|{
return|return
operator|new
name|Object
index|[]
block|{
name|varint
block|,
name|fixed32
block|,
name|fixed64
block|,
name|lengthDelimited
block|,
name|group
block|}
return|;
block|}
comment|/**      * Serializes the field, including field number, and writes it to      * {@code output}.      */
specifier|public
name|void
name|writeTo
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|CodedOutputStream
name|output
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
specifier|final
name|long
name|value
range|:
name|varint
control|)
block|{
name|output
operator|.
name|writeUInt64
argument_list|(
name|fieldNumber
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|int
name|value
range|:
name|fixed32
control|)
block|{
name|output
operator|.
name|writeFixed32
argument_list|(
name|fieldNumber
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|long
name|value
range|:
name|fixed64
control|)
block|{
name|output
operator|.
name|writeFixed64
argument_list|(
name|fieldNumber
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|ByteString
name|value
range|:
name|lengthDelimited
control|)
block|{
name|output
operator|.
name|writeBytes
argument_list|(
name|fieldNumber
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|UnknownFieldSet
name|value
range|:
name|group
control|)
block|{
name|output
operator|.
name|writeGroup
argument_list|(
name|fieldNumber
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Get the number of bytes required to encode this field, including field      * number.      */
specifier|public
name|int
name|getSerializedSize
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|final
name|long
name|value
range|:
name|varint
control|)
block|{
name|result
operator|+=
name|CodedOutputStream
operator|.
name|computeUInt64Size
argument_list|(
name|fieldNumber
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|int
name|value
range|:
name|fixed32
control|)
block|{
name|result
operator|+=
name|CodedOutputStream
operator|.
name|computeFixed32Size
argument_list|(
name|fieldNumber
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|long
name|value
range|:
name|fixed64
control|)
block|{
name|result
operator|+=
name|CodedOutputStream
operator|.
name|computeFixed64Size
argument_list|(
name|fieldNumber
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|ByteString
name|value
range|:
name|lengthDelimited
control|)
block|{
name|result
operator|+=
name|CodedOutputStream
operator|.
name|computeBytesSize
argument_list|(
name|fieldNumber
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|UnknownFieldSet
name|value
range|:
name|group
control|)
block|{
name|result
operator|+=
name|CodedOutputStream
operator|.
name|computeGroupSize
argument_list|(
name|fieldNumber
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**      * Serializes the field, including field number, and writes it to      * {@code output}, using {@code MessageSet} wire format.      */
specifier|public
name|void
name|writeAsMessageSetExtensionTo
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|CodedOutputStream
name|output
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
specifier|final
name|ByteString
name|value
range|:
name|lengthDelimited
control|)
block|{
name|output
operator|.
name|writeRawMessageSetExtension
argument_list|(
name|fieldNumber
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Get the number of bytes required to encode this field, including field      * number, using {@code MessageSet} wire format.      */
specifier|public
name|int
name|getSerializedSizeAsMessageSetExtension
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|final
name|ByteString
name|value
range|:
name|lengthDelimited
control|)
block|{
name|result
operator|+=
name|CodedOutputStream
operator|.
name|computeRawMessageSetExtensionSize
argument_list|(
name|fieldNumber
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|private
name|List
argument_list|<
name|Long
argument_list|>
name|varint
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Integer
argument_list|>
name|fixed32
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Long
argument_list|>
name|fixed64
decl_stmt|;
specifier|private
name|List
argument_list|<
name|ByteString
argument_list|>
name|lengthDelimited
decl_stmt|;
specifier|private
name|List
argument_list|<
name|UnknownFieldSet
argument_list|>
name|group
decl_stmt|;
comment|/**      * Used to build a {@link Field} within an {@link UnknownFieldSet}.      *      *<p>Use {@link Field#newBuilder()} to construct a {@code Builder}.      */
specifier|public
specifier|static
specifier|final
class|class
name|Builder
block|{
comment|// This constructor should never be called directly (except from 'create').
specifier|private
name|Builder
parameter_list|()
block|{}
specifier|private
specifier|static
name|Builder
name|create
parameter_list|()
block|{
name|Builder
name|builder
init|=
operator|new
name|Builder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|result
operator|=
operator|new
name|Field
argument_list|()
expr_stmt|;
return|return
name|builder
return|;
block|}
specifier|private
name|Field
name|result
decl_stmt|;
comment|/**        * Build the field.  After {@code build()} has been called, the        * {@code Builder} is no longer usable.  Calling any other method will        * result in undefined behavior and can cause a        * {@code NullPointerException} to be thrown.        */
specifier|public
name|Field
name|build
parameter_list|()
block|{
if|if
condition|(
name|result
operator|.
name|varint
operator|==
literal|null
condition|)
block|{
name|result
operator|.
name|varint
operator|=
name|Collections
operator|.
name|emptyList
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|varint
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|result
operator|.
name|varint
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|.
name|fixed32
operator|==
literal|null
condition|)
block|{
name|result
operator|.
name|fixed32
operator|=
name|Collections
operator|.
name|emptyList
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|fixed32
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|result
operator|.
name|fixed32
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|.
name|fixed64
operator|==
literal|null
condition|)
block|{
name|result
operator|.
name|fixed64
operator|=
name|Collections
operator|.
name|emptyList
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|fixed64
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|result
operator|.
name|fixed64
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|.
name|lengthDelimited
operator|==
literal|null
condition|)
block|{
name|result
operator|.
name|lengthDelimited
operator|=
name|Collections
operator|.
name|emptyList
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|lengthDelimited
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|result
operator|.
name|lengthDelimited
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|.
name|group
operator|==
literal|null
condition|)
block|{
name|result
operator|.
name|group
operator|=
name|Collections
operator|.
name|emptyList
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|group
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|result
operator|.
name|group
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Field
name|returnMe
init|=
name|result
decl_stmt|;
name|result
operator|=
literal|null
expr_stmt|;
return|return
name|returnMe
return|;
block|}
comment|/** Discard the field's contents. */
specifier|public
name|Builder
name|clear
parameter_list|()
block|{
name|result
operator|=
operator|new
name|Field
argument_list|()
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**        * Merge the values in {@code other} into this field.  For each list        * of values, {@code other}'s values are append to the ones in this        * field.        */
specifier|public
name|Builder
name|mergeFrom
parameter_list|(
specifier|final
name|Field
name|other
parameter_list|)
block|{
if|if
condition|(
operator|!
name|other
operator|.
name|varint
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|result
operator|.
name|varint
operator|==
literal|null
condition|)
block|{
name|result
operator|.
name|varint
operator|=
operator|new
name|ArrayList
argument_list|<
name|Long
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|result
operator|.
name|varint
operator|.
name|addAll
argument_list|(
name|other
operator|.
name|varint
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|other
operator|.
name|fixed32
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|result
operator|.
name|fixed32
operator|==
literal|null
condition|)
block|{
name|result
operator|.
name|fixed32
operator|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|result
operator|.
name|fixed32
operator|.
name|addAll
argument_list|(
name|other
operator|.
name|fixed32
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|other
operator|.
name|fixed64
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|result
operator|.
name|fixed64
operator|==
literal|null
condition|)
block|{
name|result
operator|.
name|fixed64
operator|=
operator|new
name|ArrayList
argument_list|<
name|Long
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|result
operator|.
name|fixed64
operator|.
name|addAll
argument_list|(
name|other
operator|.
name|fixed64
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|other
operator|.
name|lengthDelimited
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|result
operator|.
name|lengthDelimited
operator|==
literal|null
condition|)
block|{
name|result
operator|.
name|lengthDelimited
operator|=
operator|new
name|ArrayList
argument_list|<
name|ByteString
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|result
operator|.
name|lengthDelimited
operator|.
name|addAll
argument_list|(
name|other
operator|.
name|lengthDelimited
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|other
operator|.
name|group
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|result
operator|.
name|group
operator|==
literal|null
condition|)
block|{
name|result
operator|.
name|group
operator|=
operator|new
name|ArrayList
argument_list|<
name|UnknownFieldSet
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|result
operator|.
name|group
operator|.
name|addAll
argument_list|(
name|other
operator|.
name|group
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/** Add a varint value. */
specifier|public
name|Builder
name|addVarint
parameter_list|(
specifier|final
name|long
name|value
parameter_list|)
block|{
if|if
condition|(
name|result
operator|.
name|varint
operator|==
literal|null
condition|)
block|{
name|result
operator|.
name|varint
operator|=
operator|new
name|ArrayList
argument_list|<
name|Long
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|result
operator|.
name|varint
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Add a fixed32 value. */
specifier|public
name|Builder
name|addFixed32
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
block|{
if|if
condition|(
name|result
operator|.
name|fixed32
operator|==
literal|null
condition|)
block|{
name|result
operator|.
name|fixed32
operator|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|result
operator|.
name|fixed32
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Add a fixed64 value. */
specifier|public
name|Builder
name|addFixed64
parameter_list|(
specifier|final
name|long
name|value
parameter_list|)
block|{
if|if
condition|(
name|result
operator|.
name|fixed64
operator|==
literal|null
condition|)
block|{
name|result
operator|.
name|fixed64
operator|=
operator|new
name|ArrayList
argument_list|<
name|Long
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|result
operator|.
name|fixed64
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Add a length-delimited value. */
specifier|public
name|Builder
name|addLengthDelimited
parameter_list|(
specifier|final
name|ByteString
name|value
parameter_list|)
block|{
if|if
condition|(
name|result
operator|.
name|lengthDelimited
operator|==
literal|null
condition|)
block|{
name|result
operator|.
name|lengthDelimited
operator|=
operator|new
name|ArrayList
argument_list|<
name|ByteString
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|result
operator|.
name|lengthDelimited
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Add an embedded group. */
specifier|public
name|Builder
name|addGroup
parameter_list|(
specifier|final
name|UnknownFieldSet
name|value
parameter_list|)
block|{
if|if
condition|(
name|result
operator|.
name|group
operator|==
literal|null
condition|)
block|{
name|result
operator|.
name|group
operator|=
operator|new
name|ArrayList
argument_list|<
name|UnknownFieldSet
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|result
operator|.
name|group
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
block|}
comment|/**    * Parser to implement MessageLite interface.    */
specifier|public
specifier|static
specifier|final
class|class
name|Parser
extends|extends
name|AbstractParser
argument_list|<
name|UnknownFieldSet
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|UnknownFieldSet
name|parsePartialFrom
parameter_list|(
name|CodedInputStream
name|input
parameter_list|,
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|)
throws|throws
name|InvalidProtocolBufferException
block|{
name|Builder
name|builder
init|=
name|newBuilder
argument_list|()
decl_stmt|;
try|try
block|{
name|builder
operator|.
name|mergeFrom
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidProtocolBufferException
name|e
parameter_list|)
block|{
throw|throw
name|e
operator|.
name|setUnfinishedMessage
argument_list|(
name|builder
operator|.
name|buildPartial
argument_list|()
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InvalidProtocolBufferException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
operator|.
name|setUnfinishedMessage
argument_list|(
name|builder
operator|.
name|buildPartial
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|builder
operator|.
name|buildPartial
argument_list|()
return|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|Parser
name|PARSER
init|=
operator|new
name|Parser
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
specifier|final
name|Parser
name|getParserForType
parameter_list|()
block|{
return|return
name|PARSER
return|;
block|}
block|}
end_class

end_unit

