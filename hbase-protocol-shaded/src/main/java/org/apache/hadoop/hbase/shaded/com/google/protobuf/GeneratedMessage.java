begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|// Protocol Buffers - Google's data interchange format
end_comment

begin_comment
comment|// Copyright 2008 Google Inc.  All rights reserved.
end_comment

begin_comment
comment|// https://developers.google.com/protocol-buffers/
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Redistribution and use in source and binary forms, with or without
end_comment

begin_comment
comment|// modification, are permitted provided that the following conditions are
end_comment

begin_comment
comment|// met:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//     * Redistributions of source code must retain the above copyright
end_comment

begin_comment
comment|// notice, this list of conditions and the following disclaimer.
end_comment

begin_comment
comment|//     * Redistributions in binary form must reproduce the above
end_comment

begin_comment
comment|// copyright notice, this list of conditions and the following disclaimer
end_comment

begin_comment
comment|// in the documentation and/or other materials provided with the
end_comment

begin_comment
comment|// distribution.
end_comment

begin_comment
comment|//     * Neither the name of Google Inc. nor the names of its
end_comment

begin_comment
comment|// contributors may be used to endorse or promote products derived from
end_comment

begin_comment
comment|// this software without specific prior written permission.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
end_comment

begin_comment
comment|// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
end_comment

begin_comment
comment|// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
end_comment

begin_comment
comment|// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
end_comment

begin_comment
comment|// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
end_comment

begin_comment
comment|// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
end_comment

begin_comment
comment|// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
end_comment

begin_comment
comment|// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
end_comment

begin_comment
comment|// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Descriptors
operator|.
name|Descriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Descriptors
operator|.
name|EnumDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Descriptors
operator|.
name|EnumValueDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Descriptors
operator|.
name|FieldDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Descriptors
operator|.
name|FileDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Descriptors
operator|.
name|OneofDescriptor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectStreamException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_comment
comment|/**  * All generated protocol message classes extend this class.  This class  * implements most of the Message and Builder interfaces using Java reflection.  * Users can ignore this class and pretend that generated messages implement  * the Message interface directly.  *  * @author kenton@google.com Kenton Varda  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|GeneratedMessage
extends|extends
name|AbstractMessage
implements|implements
name|Serializable
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
comment|/**    * For testing. Allows a test to disable the optimization that avoids using    * field builders for nested messages until they are requested. By disabling    * this optimization, existing tests can be reused to test the field builders.    */
specifier|protected
specifier|static
name|boolean
name|alwaysUseFieldBuilders
init|=
literal|false
decl_stmt|;
comment|/** For use by generated code only.  */
specifier|protected
name|UnknownFieldSet
name|unknownFields
decl_stmt|;
specifier|protected
name|GeneratedMessage
parameter_list|()
block|{
name|unknownFields
operator|=
name|UnknownFieldSet
operator|.
name|getDefaultInstance
argument_list|()
expr_stmt|;
block|}
specifier|protected
name|GeneratedMessage
parameter_list|(
name|Builder
argument_list|<
name|?
argument_list|>
name|builder
parameter_list|)
block|{
name|unknownFields
operator|=
name|builder
operator|.
name|getUnknownFields
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Parser
argument_list|<
name|?
extends|extends
name|GeneratedMessage
argument_list|>
name|getParserForType
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This is supposed to be overridden by subclasses."
argument_list|)
throw|;
block|}
comment|/**   * For testing. Allows a test to disable the optimization that avoids using   * field builders for nested messages until they are requested. By disabling   * this optimization, existing tests can be reused to test the field builders.   * See {@link RepeatedFieldBuilder} and {@link SingleFieldBuilder}.   */
specifier|static
name|void
name|enableAlwaysUseFieldBuildersForTesting
parameter_list|()
block|{
name|alwaysUseFieldBuilders
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * Get the FieldAccessorTable for this type.  We can't have the message    * class pass this in to the constructor because of bootstrapping trouble    * with DescriptorProtos.    */
specifier|protected
specifier|abstract
name|FieldAccessorTable
name|internalGetFieldAccessorTable
parameter_list|()
function_decl|;
annotation|@
name|Override
specifier|public
name|Descriptor
name|getDescriptorForType
parameter_list|()
block|{
return|return
name|internalGetFieldAccessorTable
argument_list|()
operator|.
name|descriptor
return|;
block|}
comment|/**    * Internal helper to return a modifiable map containing all the fields.    * The returned Map is modifialbe so that the caller can add additional    * extension fields to implement {@link #getAllFields()}.    *    * @param getBytesForString whether to generate ByteString for string fields    */
specifier|private
name|Map
argument_list|<
name|FieldDescriptor
argument_list|,
name|Object
argument_list|>
name|getAllFieldsMutable
parameter_list|(
name|boolean
name|getBytesForString
parameter_list|)
block|{
specifier|final
name|TreeMap
argument_list|<
name|FieldDescriptor
argument_list|,
name|Object
argument_list|>
name|result
init|=
operator|new
name|TreeMap
argument_list|<
name|FieldDescriptor
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|Descriptor
name|descriptor
init|=
name|internalGetFieldAccessorTable
argument_list|()
operator|.
name|descriptor
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FieldDescriptor
argument_list|>
name|fields
init|=
name|descriptor
operator|.
name|getFields
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|FieldDescriptor
name|field
init|=
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|OneofDescriptor
name|oneofDescriptor
init|=
name|field
operator|.
name|getContainingOneof
argument_list|()
decl_stmt|;
comment|/*        * If the field is part of a Oneof, then at maximum one field in the Oneof is set        * and it is not repeated. There is no need to iterate through the others.        */
if|if
condition|(
name|oneofDescriptor
operator|!=
literal|null
condition|)
block|{
comment|// Skip other fields in the Oneof we know are not set
name|i
operator|+=
name|oneofDescriptor
operator|.
name|getFieldCount
argument_list|()
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|hasOneof
argument_list|(
name|oneofDescriptor
argument_list|)
condition|)
block|{
comment|// If no field is set in the Oneof, skip all the fields in the Oneof
continue|continue;
block|}
comment|// Get the pointer to the only field which is set in the Oneof
name|field
operator|=
name|getOneofFieldDescriptor
argument_list|(
name|oneofDescriptor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If we are not in a Oneof, we need to check if the field is set and if it is repeated
if|if
condition|(
name|field
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
specifier|final
name|List
argument_list|<
name|?
argument_list|>
name|value
init|=
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|result
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|!
name|hasField
argument_list|(
name|field
argument_list|)
condition|)
block|{
continue|continue;
block|}
block|}
comment|// Add the field to the map
if|if
condition|(
name|getBytesForString
operator|&&
name|field
operator|.
name|getJavaType
argument_list|()
operator|==
name|FieldDescriptor
operator|.
name|JavaType
operator|.
name|STRING
condition|)
block|{
name|result
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|getFieldRaw
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|getField
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isInitialized
parameter_list|()
block|{
for|for
control|(
specifier|final
name|FieldDescriptor
name|field
range|:
name|getDescriptorForType
argument_list|()
operator|.
name|getFields
argument_list|()
control|)
block|{
comment|// Check that all required fields are present.
if|if
condition|(
name|field
operator|.
name|isRequired
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|hasField
argument_list|(
name|field
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|// Check that embedded messages are initialized.
if|if
condition|(
name|field
operator|.
name|getJavaType
argument_list|()
operator|==
name|FieldDescriptor
operator|.
name|JavaType
operator|.
name|MESSAGE
condition|)
block|{
if|if
condition|(
name|field
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|List
argument_list|<
name|Message
argument_list|>
name|messageList
init|=
operator|(
name|List
argument_list|<
name|Message
argument_list|>
operator|)
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|Message
name|element
range|:
name|messageList
control|)
block|{
if|if
condition|(
operator|!
name|element
operator|.
name|isInitialized
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|hasField
argument_list|(
name|field
argument_list|)
operator|&&
operator|!
operator|(
operator|(
name|Message
operator|)
name|getField
argument_list|(
name|field
argument_list|)
operator|)
operator|.
name|isInitialized
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|FieldDescriptor
argument_list|,
name|Object
argument_list|>
name|getAllFields
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|getAllFieldsMutable
argument_list|(
comment|/* getBytesForString = */
literal|false
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a collection of all the fields in this message which are set    * and their corresponding values.  A singular ("required" or "optional")    * field is set iff hasField() returns true for that field.  A "repeated"    * field is set iff getRepeatedFieldCount() is greater than zero.  The    * values are exactly what would be returned by calling    * {@link #getFieldRaw(Descriptors.FieldDescriptor)} for each field.  The map    * is guaranteed to be a sorted map, so iterating over it will return fields    * in order by field number.    */
name|Map
argument_list|<
name|FieldDescriptor
argument_list|,
name|Object
argument_list|>
name|getAllFieldsRaw
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|getAllFieldsMutable
argument_list|(
comment|/* getBytesForString = */
literal|true
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasOneof
parameter_list|(
specifier|final
name|OneofDescriptor
name|oneof
parameter_list|)
block|{
return|return
name|internalGetFieldAccessorTable
argument_list|()
operator|.
name|getOneof
argument_list|(
name|oneof
argument_list|)
operator|.
name|has
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|FieldDescriptor
name|getOneofFieldDescriptor
parameter_list|(
specifier|final
name|OneofDescriptor
name|oneof
parameter_list|)
block|{
return|return
name|internalGetFieldAccessorTable
argument_list|()
operator|.
name|getOneof
argument_list|(
name|oneof
argument_list|)
operator|.
name|get
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasField
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|)
block|{
return|return
name|internalGetFieldAccessorTable
argument_list|()
operator|.
name|getField
argument_list|(
name|field
argument_list|)
operator|.
name|has
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getField
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|)
block|{
return|return
name|internalGetFieldAccessorTable
argument_list|()
operator|.
name|getField
argument_list|(
name|field
argument_list|)
operator|.
name|get
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * Obtains the value of the given field, or the default value if it is    * not set.  For primitive fields, the boxed primitive value is returned.    * For enum fields, the EnumValueDescriptor for the value is returned. For    * embedded message fields, the sub-message is returned.  For repeated    * fields, a java.util.List is returned. For present string fields, a    * ByteString is returned representing the bytes that the field contains.    */
name|Object
name|getFieldRaw
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|)
block|{
return|return
name|internalGetFieldAccessorTable
argument_list|()
operator|.
name|getField
argument_list|(
name|field
argument_list|)
operator|.
name|getRaw
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getRepeatedFieldCount
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|)
block|{
return|return
name|internalGetFieldAccessorTable
argument_list|()
operator|.
name|getField
argument_list|(
name|field
argument_list|)
operator|.
name|getRepeatedCount
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getRepeatedField
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|,
specifier|final
name|int
name|index
parameter_list|)
block|{
return|return
name|internalGetFieldAccessorTable
argument_list|()
operator|.
name|getField
argument_list|(
name|field
argument_list|)
operator|.
name|getRepeated
argument_list|(
name|this
argument_list|,
name|index
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|UnknownFieldSet
name|getUnknownFields
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This is supposed to be overridden by subclasses."
argument_list|)
throw|;
block|}
comment|/**    * Called by subclasses to parse an unknown field.    * @return {@code true} unless the tag is an end-group tag.    */
specifier|protected
name|boolean
name|parseUnknownField
parameter_list|(
name|CodedInputStream
name|input
parameter_list|,
name|UnknownFieldSet
operator|.
name|Builder
name|unknownFields
parameter_list|,
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|,
name|int
name|tag
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|unknownFields
operator|.
name|mergeFieldFrom
argument_list|(
name|tag
argument_list|,
name|input
argument_list|)
return|;
block|}
specifier|protected
specifier|static
parameter_list|<
name|M
extends|extends
name|Message
parameter_list|>
name|M
name|parseWithIOException
parameter_list|(
name|Parser
argument_list|<
name|M
argument_list|>
name|parser
parameter_list|,
name|InputStream
name|input
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|parser
operator|.
name|parseFrom
argument_list|(
name|input
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InvalidProtocolBufferException
name|e
parameter_list|)
block|{
throw|throw
name|e
operator|.
name|unwrapIOException
argument_list|()
throw|;
block|}
block|}
specifier|protected
specifier|static
parameter_list|<
name|M
extends|extends
name|Message
parameter_list|>
name|M
name|parseWithIOException
parameter_list|(
name|Parser
argument_list|<
name|M
argument_list|>
name|parser
parameter_list|,
name|InputStream
name|input
parameter_list|,
name|ExtensionRegistryLite
name|extensions
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|parser
operator|.
name|parseFrom
argument_list|(
name|input
argument_list|,
name|extensions
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InvalidProtocolBufferException
name|e
parameter_list|)
block|{
throw|throw
name|e
operator|.
name|unwrapIOException
argument_list|()
throw|;
block|}
block|}
specifier|protected
specifier|static
parameter_list|<
name|M
extends|extends
name|Message
parameter_list|>
name|M
name|parseWithIOException
parameter_list|(
name|Parser
argument_list|<
name|M
argument_list|>
name|parser
parameter_list|,
name|CodedInputStream
name|input
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|parser
operator|.
name|parseFrom
argument_list|(
name|input
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InvalidProtocolBufferException
name|e
parameter_list|)
block|{
throw|throw
name|e
operator|.
name|unwrapIOException
argument_list|()
throw|;
block|}
block|}
specifier|protected
specifier|static
parameter_list|<
name|M
extends|extends
name|Message
parameter_list|>
name|M
name|parseWithIOException
parameter_list|(
name|Parser
argument_list|<
name|M
argument_list|>
name|parser
parameter_list|,
name|CodedInputStream
name|input
parameter_list|,
name|ExtensionRegistryLite
name|extensions
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|parser
operator|.
name|parseFrom
argument_list|(
name|input
argument_list|,
name|extensions
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InvalidProtocolBufferException
name|e
parameter_list|)
block|{
throw|throw
name|e
operator|.
name|unwrapIOException
argument_list|()
throw|;
block|}
block|}
specifier|protected
specifier|static
parameter_list|<
name|M
extends|extends
name|Message
parameter_list|>
name|M
name|parseDelimitedWithIOException
parameter_list|(
name|Parser
argument_list|<
name|M
argument_list|>
name|parser
parameter_list|,
name|InputStream
name|input
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|parser
operator|.
name|parseDelimitedFrom
argument_list|(
name|input
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InvalidProtocolBufferException
name|e
parameter_list|)
block|{
throw|throw
name|e
operator|.
name|unwrapIOException
argument_list|()
throw|;
block|}
block|}
specifier|protected
specifier|static
parameter_list|<
name|M
extends|extends
name|Message
parameter_list|>
name|M
name|parseDelimitedWithIOException
parameter_list|(
name|Parser
argument_list|<
name|M
argument_list|>
name|parser
parameter_list|,
name|InputStream
name|input
parameter_list|,
name|ExtensionRegistryLite
name|extensions
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|parser
operator|.
name|parseDelimitedFrom
argument_list|(
name|input
argument_list|,
name|extensions
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InvalidProtocolBufferException
name|e
parameter_list|)
block|{
throw|throw
name|e
operator|.
name|unwrapIOException
argument_list|()
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeTo
parameter_list|(
specifier|final
name|CodedOutputStream
name|output
parameter_list|)
throws|throws
name|IOException
block|{
name|MessageReflection
operator|.
name|writeMessageTo
argument_list|(
name|this
argument_list|,
name|getAllFieldsRaw
argument_list|()
argument_list|,
name|output
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getSerializedSize
parameter_list|()
block|{
name|int
name|size
init|=
name|memoizedSize
decl_stmt|;
if|if
condition|(
name|size
operator|!=
operator|-
literal|1
condition|)
block|{
return|return
name|size
return|;
block|}
name|memoizedSize
operator|=
name|MessageReflection
operator|.
name|getSerializedSize
argument_list|(
name|this
argument_list|,
name|getAllFieldsRaw
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|memoizedSize
return|;
block|}
comment|/**    * Used by parsing constructors in generated classes.    */
specifier|protected
name|void
name|makeExtensionsImmutable
parameter_list|()
block|{
comment|// Noop for messages without extensions.
block|}
comment|/**    * TODO(xiaofeng): remove this after b/29368482 is fixed. We need to move this    * interface to AbstractMessage in order to versioning GeneratedMessage but    * this move breaks binary compatibility for AppEngine. After AppEngine is    * fixed we can exlude this from google3.    */
specifier|protected
interface|interface
name|BuilderParent
extends|extends
name|AbstractMessage
operator|.
name|BuilderParent
block|{}
comment|/**    * TODO(xiaofeng): remove this together with GeneratedMessage.BuilderParent.    */
specifier|protected
specifier|abstract
name|Message
operator|.
name|Builder
name|newBuilderForType
parameter_list|(
name|BuilderParent
name|parent
parameter_list|)
function_decl|;
annotation|@
name|Override
specifier|protected
name|Message
operator|.
name|Builder
name|newBuilderForType
parameter_list|(
specifier|final
name|AbstractMessage
operator|.
name|BuilderParent
name|parent
parameter_list|)
block|{
return|return
name|newBuilderForType
argument_list|(
operator|new
name|BuilderParent
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|markDirty
parameter_list|()
block|{
name|parent
operator|.
name|markDirty
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|abstract
specifier|static
class|class
name|Builder
parameter_list|<
name|BuilderType
extends|extends
name|Builder
parameter_list|<
name|BuilderType
parameter_list|>
parameter_list|>
extends|extends
name|AbstractMessage
operator|.
name|Builder
argument_list|<
name|BuilderType
argument_list|>
block|{
specifier|private
name|BuilderParent
name|builderParent
decl_stmt|;
specifier|private
name|BuilderParentImpl
name|meAsParent
decl_stmt|;
comment|// Indicates that we've built a message and so we are now obligated
comment|// to dispatch dirty invalidations. See GeneratedMessage.BuilderListener.
specifier|private
name|boolean
name|isClean
decl_stmt|;
specifier|private
name|UnknownFieldSet
name|unknownFields
init|=
name|UnknownFieldSet
operator|.
name|getDefaultInstance
argument_list|()
decl_stmt|;
specifier|protected
name|Builder
parameter_list|()
block|{
name|this
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|Builder
parameter_list|(
name|BuilderParent
name|builderParent
parameter_list|)
block|{
name|this
operator|.
name|builderParent
operator|=
name|builderParent
expr_stmt|;
block|}
annotation|@
name|Override
name|void
name|dispose
parameter_list|()
block|{
name|builderParent
operator|=
literal|null
expr_stmt|;
block|}
comment|/**      * Called by the subclass when a message is built.      */
specifier|protected
name|void
name|onBuilt
parameter_list|()
block|{
if|if
condition|(
name|builderParent
operator|!=
literal|null
condition|)
block|{
name|markClean
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Called by the subclass or a builder to notify us that a message was      * built and may be cached and therefore invalidations are needed.      */
annotation|@
name|Override
specifier|protected
name|void
name|markClean
parameter_list|()
block|{
name|this
operator|.
name|isClean
operator|=
literal|true
expr_stmt|;
block|}
comment|/**      * Gets whether invalidations are needed      *      * @return whether invalidations are needed      */
specifier|protected
name|boolean
name|isClean
parameter_list|()
block|{
return|return
name|isClean
return|;
block|}
annotation|@
name|Override
specifier|public
name|BuilderType
name|clone
parameter_list|()
block|{
name|BuilderType
name|builder
init|=
operator|(
name|BuilderType
operator|)
name|getDefaultInstanceForType
argument_list|()
operator|.
name|newBuilderForType
argument_list|()
decl_stmt|;
name|builder
operator|.
name|mergeFrom
argument_list|(
name|buildPartial
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|builder
return|;
block|}
comment|/**      * Called by the initialization and clear code paths to allow subclasses to      * reset any of their builtin fields back to the initial values.      */
annotation|@
name|Override
specifier|public
name|BuilderType
name|clear
parameter_list|()
block|{
name|unknownFields
operator|=
name|UnknownFieldSet
operator|.
name|getDefaultInstance
argument_list|()
expr_stmt|;
name|onChanged
argument_list|()
expr_stmt|;
return|return
operator|(
name|BuilderType
operator|)
name|this
return|;
block|}
comment|/**      * Get the FieldAccessorTable for this type.  We can't have the message      * class pass this in to the constructor because of bootstrapping trouble      * with DescriptorProtos.      */
specifier|protected
specifier|abstract
name|FieldAccessorTable
name|internalGetFieldAccessorTable
parameter_list|()
function_decl|;
annotation|@
name|Override
specifier|public
name|Descriptor
name|getDescriptorForType
parameter_list|()
block|{
return|return
name|internalGetFieldAccessorTable
argument_list|()
operator|.
name|descriptor
return|;
block|}
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|FieldDescriptor
argument_list|,
name|Object
argument_list|>
name|getAllFields
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|getAllFieldsMutable
argument_list|()
argument_list|)
return|;
block|}
comment|/** Internal helper which returns a mutable map. */
specifier|private
name|Map
argument_list|<
name|FieldDescriptor
argument_list|,
name|Object
argument_list|>
name|getAllFieldsMutable
parameter_list|()
block|{
specifier|final
name|TreeMap
argument_list|<
name|FieldDescriptor
argument_list|,
name|Object
argument_list|>
name|result
init|=
operator|new
name|TreeMap
argument_list|<
name|FieldDescriptor
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|Descriptor
name|descriptor
init|=
name|internalGetFieldAccessorTable
argument_list|()
operator|.
name|descriptor
decl_stmt|;
specifier|final
name|List
argument_list|<
name|FieldDescriptor
argument_list|>
name|fields
init|=
name|descriptor
operator|.
name|getFields
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|FieldDescriptor
name|field
init|=
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|OneofDescriptor
name|oneofDescriptor
init|=
name|field
operator|.
name|getContainingOneof
argument_list|()
decl_stmt|;
comment|/*          * If the field is part of a Oneof, then at maximum one field in the Oneof is set          * and it is not repeated. There is no need to iterate through the others.          */
if|if
condition|(
name|oneofDescriptor
operator|!=
literal|null
condition|)
block|{
comment|// Skip other fields in the Oneof we know are not set
name|i
operator|+=
name|oneofDescriptor
operator|.
name|getFieldCount
argument_list|()
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|hasOneof
argument_list|(
name|oneofDescriptor
argument_list|)
condition|)
block|{
comment|// If no field is set in the Oneof, skip all the fields in the Oneof
continue|continue;
block|}
comment|// Get the pointer to the only field which is set in the Oneof
name|field
operator|=
name|getOneofFieldDescriptor
argument_list|(
name|oneofDescriptor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If we are not in a Oneof, we need to check if the field is set and if it is repeated
if|if
condition|(
name|field
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
specifier|final
name|List
argument_list|<
name|?
argument_list|>
name|value
init|=
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|result
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|!
name|hasField
argument_list|(
name|field
argument_list|)
condition|)
block|{
continue|continue;
block|}
block|}
comment|// Add the field to the map
name|result
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|getField
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|Message
operator|.
name|Builder
name|newBuilderForField
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|)
block|{
return|return
name|internalGetFieldAccessorTable
argument_list|()
operator|.
name|getField
argument_list|(
name|field
argument_list|)
operator|.
name|newBuilder
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Message
operator|.
name|Builder
name|getFieldBuilder
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|)
block|{
return|return
name|internalGetFieldAccessorTable
argument_list|()
operator|.
name|getField
argument_list|(
name|field
argument_list|)
operator|.
name|getBuilder
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Message
operator|.
name|Builder
name|getRepeatedFieldBuilder
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|,
name|int
name|index
parameter_list|)
block|{
return|return
name|internalGetFieldAccessorTable
argument_list|()
operator|.
name|getField
argument_list|(
name|field
argument_list|)
operator|.
name|getRepeatedBuilder
argument_list|(
name|this
argument_list|,
name|index
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasOneof
parameter_list|(
specifier|final
name|OneofDescriptor
name|oneof
parameter_list|)
block|{
return|return
name|internalGetFieldAccessorTable
argument_list|()
operator|.
name|getOneof
argument_list|(
name|oneof
argument_list|)
operator|.
name|has
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|FieldDescriptor
name|getOneofFieldDescriptor
parameter_list|(
specifier|final
name|OneofDescriptor
name|oneof
parameter_list|)
block|{
return|return
name|internalGetFieldAccessorTable
argument_list|()
operator|.
name|getOneof
argument_list|(
name|oneof
argument_list|)
operator|.
name|get
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasField
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|)
block|{
return|return
name|internalGetFieldAccessorTable
argument_list|()
operator|.
name|getField
argument_list|(
name|field
argument_list|)
operator|.
name|has
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getField
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|)
block|{
name|Object
name|object
init|=
name|internalGetFieldAccessorTable
argument_list|()
operator|.
name|getField
argument_list|(
name|field
argument_list|)
operator|.
name|get
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
comment|// The underlying list object is still modifiable at this point.
comment|// Make sure not to expose the modifiable list to the caller.
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
operator|(
name|List
operator|)
name|object
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|object
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|BuilderType
name|setField
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
block|{
name|internalGetFieldAccessorTable
argument_list|()
operator|.
name|getField
argument_list|(
name|field
argument_list|)
operator|.
name|set
argument_list|(
name|this
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|BuilderType
operator|)
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|BuilderType
name|clearField
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|)
block|{
name|internalGetFieldAccessorTable
argument_list|()
operator|.
name|getField
argument_list|(
name|field
argument_list|)
operator|.
name|clear
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
operator|(
name|BuilderType
operator|)
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|BuilderType
name|clearOneof
parameter_list|(
specifier|final
name|OneofDescriptor
name|oneof
parameter_list|)
block|{
name|internalGetFieldAccessorTable
argument_list|()
operator|.
name|getOneof
argument_list|(
name|oneof
argument_list|)
operator|.
name|clear
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
operator|(
name|BuilderType
operator|)
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getRepeatedFieldCount
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|)
block|{
return|return
name|internalGetFieldAccessorTable
argument_list|()
operator|.
name|getField
argument_list|(
name|field
argument_list|)
operator|.
name|getRepeatedCount
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getRepeatedField
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|,
specifier|final
name|int
name|index
parameter_list|)
block|{
return|return
name|internalGetFieldAccessorTable
argument_list|()
operator|.
name|getField
argument_list|(
name|field
argument_list|)
operator|.
name|getRepeated
argument_list|(
name|this
argument_list|,
name|index
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|BuilderType
name|setRepeatedField
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|,
specifier|final
name|int
name|index
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
block|{
name|internalGetFieldAccessorTable
argument_list|()
operator|.
name|getField
argument_list|(
name|field
argument_list|)
operator|.
name|setRepeated
argument_list|(
name|this
argument_list|,
name|index
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|BuilderType
operator|)
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|BuilderType
name|addRepeatedField
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
block|{
name|internalGetFieldAccessorTable
argument_list|()
operator|.
name|getField
argument_list|(
name|field
argument_list|)
operator|.
name|addRepeated
argument_list|(
name|this
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|BuilderType
operator|)
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|BuilderType
name|setUnknownFields
parameter_list|(
specifier|final
name|UnknownFieldSet
name|unknownFields
parameter_list|)
block|{
name|this
operator|.
name|unknownFields
operator|=
name|unknownFields
expr_stmt|;
name|onChanged
argument_list|()
expr_stmt|;
return|return
operator|(
name|BuilderType
operator|)
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|BuilderType
name|mergeUnknownFields
parameter_list|(
specifier|final
name|UnknownFieldSet
name|unknownFields
parameter_list|)
block|{
name|this
operator|.
name|unknownFields
operator|=
name|UnknownFieldSet
operator|.
name|newBuilder
argument_list|(
name|this
operator|.
name|unknownFields
argument_list|)
operator|.
name|mergeFrom
argument_list|(
name|unknownFields
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|onChanged
argument_list|()
expr_stmt|;
return|return
operator|(
name|BuilderType
operator|)
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isInitialized
parameter_list|()
block|{
for|for
control|(
specifier|final
name|FieldDescriptor
name|field
range|:
name|getDescriptorForType
argument_list|()
operator|.
name|getFields
argument_list|()
control|)
block|{
comment|// Check that all required fields are present.
if|if
condition|(
name|field
operator|.
name|isRequired
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|hasField
argument_list|(
name|field
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|// Check that embedded messages are initialized.
if|if
condition|(
name|field
operator|.
name|getJavaType
argument_list|()
operator|==
name|FieldDescriptor
operator|.
name|JavaType
operator|.
name|MESSAGE
condition|)
block|{
if|if
condition|(
name|field
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|List
argument_list|<
name|Message
argument_list|>
name|messageList
init|=
operator|(
name|List
argument_list|<
name|Message
argument_list|>
operator|)
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|Message
name|element
range|:
name|messageList
control|)
block|{
if|if
condition|(
operator|!
name|element
operator|.
name|isInitialized
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|hasField
argument_list|(
name|field
argument_list|)
operator|&&
operator|!
operator|(
operator|(
name|Message
operator|)
name|getField
argument_list|(
name|field
argument_list|)
operator|)
operator|.
name|isInitialized
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|UnknownFieldSet
name|getUnknownFields
parameter_list|()
block|{
return|return
name|unknownFields
return|;
block|}
comment|/**      * Called by subclasses to parse an unknown field.      * @return {@code true} unless the tag is an end-group tag.      */
specifier|protected
name|boolean
name|parseUnknownField
parameter_list|(
specifier|final
name|CodedInputStream
name|input
parameter_list|,
specifier|final
name|UnknownFieldSet
operator|.
name|Builder
name|unknownFields
parameter_list|,
specifier|final
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|,
specifier|final
name|int
name|tag
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|unknownFields
operator|.
name|mergeFieldFrom
argument_list|(
name|tag
argument_list|,
name|input
argument_list|)
return|;
block|}
comment|/**      * Implementation of {@link BuilderParent} for giving to our children. This      * small inner class makes it so we don't publicly expose the BuilderParent      * methods.      */
specifier|private
class|class
name|BuilderParentImpl
implements|implements
name|BuilderParent
block|{
annotation|@
name|Override
specifier|public
name|void
name|markDirty
parameter_list|()
block|{
name|onChanged
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Gets the {@link BuilderParent} for giving to our children.      * @return The builder parent for our children.      */
specifier|protected
name|BuilderParent
name|getParentForChildren
parameter_list|()
block|{
if|if
condition|(
name|meAsParent
operator|==
literal|null
condition|)
block|{
name|meAsParent
operator|=
operator|new
name|BuilderParentImpl
argument_list|()
expr_stmt|;
block|}
return|return
name|meAsParent
return|;
block|}
comment|/**      * Called when a the builder or one of its nested children has changed      * and any parent should be notified of its invalidation.      */
specifier|protected
specifier|final
name|void
name|onChanged
parameter_list|()
block|{
if|if
condition|(
name|isClean
operator|&&
name|builderParent
operator|!=
literal|null
condition|)
block|{
name|builderParent
operator|.
name|markDirty
argument_list|()
expr_stmt|;
comment|// Don't keep dispatching invalidations until build is called again.
name|isClean
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|/**      * Gets the map field with the given field number. This method should be      * overridden in the generated message class if the message contains map      * fields.      *      * Unlike other field types, reflection support for map fields can't be      * implemented based on generated public API because we need to access a      * map field as a list in reflection API but the generated API only allows      * us to access it as a map. This method returns the underlying map field      * directly and thus enables us to access the map field as a list.      */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unused"
block|,
literal|"rawtypes"
block|}
argument_list|)
specifier|protected
name|MapField
name|internalGetMapField
parameter_list|(
name|int
name|fieldNumber
parameter_list|)
block|{
comment|// Note that we can't use descriptor names here because this method will
comment|// be called when descriptor is being initialized.
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"No map fields found in "
operator|+
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
comment|/** Like {@link #internalGetMapField} but return a mutable version. */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unused"
block|,
literal|"rawtypes"
block|}
argument_list|)
specifier|protected
name|MapField
name|internalGetMutableMapField
parameter_list|(
name|int
name|fieldNumber
parameter_list|)
block|{
comment|// Note that we can't use descriptor names here because this method will
comment|// be called when descriptor is being initialized.
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"No map fields found in "
operator|+
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|// =================================================================
comment|// Extensions-related stuff
specifier|public
interface|interface
name|ExtendableMessageOrBuilder
parameter_list|<
name|MessageType
extends|extends
name|ExtendableMessage
parameter_list|>
extends|extends
name|MessageOrBuilder
block|{
comment|// Re-define for return type covariance.
annotation|@
name|Override
name|Message
name|getDefaultInstanceForType
parameter_list|()
function_decl|;
comment|/** Check if a singular extension is present. */
parameter_list|<
name|Type
parameter_list|>
name|boolean
name|hasExtension
parameter_list|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
name|extension
parameter_list|)
function_decl|;
comment|/** Get the number of elements in a repeated extension. */
parameter_list|<
name|Type
parameter_list|>
name|int
name|getExtensionCount
parameter_list|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extension
parameter_list|)
function_decl|;
comment|/** Get the value of an extension. */
parameter_list|<
name|Type
parameter_list|>
name|Type
name|getExtension
parameter_list|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
name|extension
parameter_list|)
function_decl|;
comment|/** Get one element of a repeated extension. */
parameter_list|<
name|Type
parameter_list|>
name|Type
name|getExtension
parameter_list|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extension
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
comment|/** Check if a singular extension is present. */
parameter_list|<
name|Type
parameter_list|>
name|boolean
name|hasExtension
parameter_list|(
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
name|extension
parameter_list|)
function_decl|;
comment|/** Check if a singular extension is present. */
parameter_list|<
name|Type
parameter_list|>
name|boolean
name|hasExtension
parameter_list|(
name|GeneratedExtension
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
name|extension
parameter_list|)
function_decl|;
comment|/** Get the number of elements in a repeated extension. */
parameter_list|<
name|Type
parameter_list|>
name|int
name|getExtensionCount
parameter_list|(
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extension
parameter_list|)
function_decl|;
comment|/** Get the number of elements in a repeated extension. */
parameter_list|<
name|Type
parameter_list|>
name|int
name|getExtensionCount
parameter_list|(
name|GeneratedExtension
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extension
parameter_list|)
function_decl|;
comment|/** Get the value of an extension. */
parameter_list|<
name|Type
parameter_list|>
name|Type
name|getExtension
parameter_list|(
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
name|extension
parameter_list|)
function_decl|;
comment|/** Get the value of an extension. */
parameter_list|<
name|Type
parameter_list|>
name|Type
name|getExtension
parameter_list|(
name|GeneratedExtension
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
name|extension
parameter_list|)
function_decl|;
comment|/** Get one element of a repeated extension. */
parameter_list|<
name|Type
parameter_list|>
name|Type
name|getExtension
parameter_list|(
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extension
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
comment|/** Get one element of a repeated extension. */
parameter_list|<
name|Type
parameter_list|>
name|Type
name|getExtension
parameter_list|(
name|GeneratedExtension
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extension
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
block|}
comment|/**    * Generated message classes for message types that contain extension ranges    * subclass this.    *    *<p>This class implements type-safe accessors for extensions.  They    * implement all the same operations that you can do with normal fields --    * e.g. "has", "get", and "getCount" -- but for extensions.  The extensions    * are identified using instances of the class {@link GeneratedExtension};    * the protocol compiler generates a static instance of this class for every    * extension in its input.  Through the magic of generics, all is made    * type-safe.    *    *<p>For example, imagine you have the {@code .proto} file:    *    *<pre>    * option java_class = "MyProto";    *    * message Foo {    *   extensions 1000 to max;    * }    *    * extend Foo {    *   optional int32 bar;    * }    *</pre>    *    *<p>Then you might write code like:    *    *<pre>    * MyProto.Foo foo = getFoo();    * int i = foo.getExtension(MyProto.bar);    *</pre>    *    *<p>See also {@link ExtendableBuilder}.    */
specifier|public
specifier|abstract
specifier|static
class|class
name|ExtendableMessage
parameter_list|<
name|MessageType
extends|extends
name|ExtendableMessage
parameter_list|>
extends|extends
name|GeneratedMessage
implements|implements
name|ExtendableMessageOrBuilder
argument_list|<
name|MessageType
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
specifier|private
specifier|final
name|FieldSet
argument_list|<
name|FieldDescriptor
argument_list|>
name|extensions
decl_stmt|;
specifier|protected
name|ExtendableMessage
parameter_list|()
block|{
name|this
operator|.
name|extensions
operator|=
name|FieldSet
operator|.
name|newFieldSet
argument_list|()
expr_stmt|;
block|}
specifier|protected
name|ExtendableMessage
parameter_list|(
name|ExtendableBuilder
argument_list|<
name|MessageType
argument_list|,
name|?
argument_list|>
name|builder
parameter_list|)
block|{
name|super
argument_list|(
name|builder
argument_list|)
expr_stmt|;
name|this
operator|.
name|extensions
operator|=
name|builder
operator|.
name|buildExtensions
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|verifyExtensionContainingType
parameter_list|(
specifier|final
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|?
argument_list|>
name|extension
parameter_list|)
block|{
if|if
condition|(
name|extension
operator|.
name|getDescriptor
argument_list|()
operator|.
name|getContainingType
argument_list|()
operator|!=
name|getDescriptorForType
argument_list|()
condition|)
block|{
comment|// This can only happen if someone uses unchecked operations.
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Extension is for type \""
operator|+
name|extension
operator|.
name|getDescriptor
argument_list|()
operator|.
name|getContainingType
argument_list|()
operator|.
name|getFullName
argument_list|()
operator|+
literal|"\" which does not match message type \""
operator|+
name|getDescriptorForType
argument_list|()
operator|.
name|getFullName
argument_list|()
operator|+
literal|"\"."
argument_list|)
throw|;
block|}
block|}
comment|/** Check if a singular extension is present. */
annotation|@
name|Override
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|boolean
name|hasExtension
parameter_list|(
specifier|final
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
name|extensionLite
parameter_list|)
block|{
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
name|extension
init|=
name|checkNotLite
argument_list|(
name|extensionLite
argument_list|)
decl_stmt|;
name|verifyExtensionContainingType
argument_list|(
name|extension
argument_list|)
expr_stmt|;
return|return
name|extensions
operator|.
name|hasField
argument_list|(
name|extension
operator|.
name|getDescriptor
argument_list|()
argument_list|)
return|;
block|}
comment|/** Get the number of elements in a repeated extension. */
annotation|@
name|Override
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|int
name|getExtensionCount
parameter_list|(
specifier|final
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extensionLite
parameter_list|)
block|{
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extension
init|=
name|checkNotLite
argument_list|(
name|extensionLite
argument_list|)
decl_stmt|;
name|verifyExtensionContainingType
argument_list|(
name|extension
argument_list|)
expr_stmt|;
specifier|final
name|FieldDescriptor
name|descriptor
init|=
name|extension
operator|.
name|getDescriptor
argument_list|()
decl_stmt|;
return|return
name|extensions
operator|.
name|getRepeatedFieldCount
argument_list|(
name|descriptor
argument_list|)
return|;
block|}
comment|/** Get the value of an extension. */
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|Type
name|getExtension
parameter_list|(
specifier|final
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
name|extensionLite
parameter_list|)
block|{
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
name|extension
init|=
name|checkNotLite
argument_list|(
name|extensionLite
argument_list|)
decl_stmt|;
name|verifyExtensionContainingType
argument_list|(
name|extension
argument_list|)
expr_stmt|;
name|FieldDescriptor
name|descriptor
init|=
name|extension
operator|.
name|getDescriptor
argument_list|()
decl_stmt|;
specifier|final
name|Object
name|value
init|=
name|extensions
operator|.
name|getField
argument_list|(
name|descriptor
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|descriptor
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
return|return
operator|(
name|Type
operator|)
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|descriptor
operator|.
name|getJavaType
argument_list|()
operator|==
name|FieldDescriptor
operator|.
name|JavaType
operator|.
name|MESSAGE
condition|)
block|{
return|return
operator|(
name|Type
operator|)
name|extension
operator|.
name|getMessageDefaultInstance
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|Type
operator|)
name|extension
operator|.
name|fromReflectionType
argument_list|(
name|descriptor
operator|.
name|getDefaultValue
argument_list|()
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
operator|(
name|Type
operator|)
name|extension
operator|.
name|fromReflectionType
argument_list|(
name|value
argument_list|)
return|;
block|}
block|}
comment|/** Get one element of a repeated extension. */
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|Type
name|getExtension
parameter_list|(
specifier|final
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extensionLite
parameter_list|,
specifier|final
name|int
name|index
parameter_list|)
block|{
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extension
init|=
name|checkNotLite
argument_list|(
name|extensionLite
argument_list|)
decl_stmt|;
name|verifyExtensionContainingType
argument_list|(
name|extension
argument_list|)
expr_stmt|;
name|FieldDescriptor
name|descriptor
init|=
name|extension
operator|.
name|getDescriptor
argument_list|()
decl_stmt|;
return|return
operator|(
name|Type
operator|)
name|extension
operator|.
name|singularFromReflectionType
argument_list|(
name|extensions
operator|.
name|getRepeatedField
argument_list|(
name|descriptor
argument_list|,
name|index
argument_list|)
argument_list|)
return|;
block|}
comment|/** Check if a singular extension is present. */
annotation|@
name|Override
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|boolean
name|hasExtension
parameter_list|(
specifier|final
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
name|extension
parameter_list|)
block|{
return|return
name|hasExtension
argument_list|(
operator|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
operator|)
name|extension
argument_list|)
return|;
block|}
comment|/** Check if a singular extension is present. */
annotation|@
name|Override
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|boolean
name|hasExtension
parameter_list|(
specifier|final
name|GeneratedExtension
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
name|extension
parameter_list|)
block|{
return|return
name|hasExtension
argument_list|(
operator|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
operator|)
name|extension
argument_list|)
return|;
block|}
comment|/** Get the number of elements in a repeated extension. */
annotation|@
name|Override
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|int
name|getExtensionCount
parameter_list|(
specifier|final
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extension
parameter_list|)
block|{
return|return
name|getExtensionCount
argument_list|(
operator|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
operator|)
name|extension
argument_list|)
return|;
block|}
comment|/** Get the number of elements in a repeated extension. */
annotation|@
name|Override
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|int
name|getExtensionCount
parameter_list|(
specifier|final
name|GeneratedExtension
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extension
parameter_list|)
block|{
return|return
name|getExtensionCount
argument_list|(
operator|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
operator|)
name|extension
argument_list|)
return|;
block|}
comment|/** Get the value of an extension. */
annotation|@
name|Override
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|Type
name|getExtension
parameter_list|(
specifier|final
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
name|extension
parameter_list|)
block|{
return|return
name|getExtension
argument_list|(
operator|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
operator|)
name|extension
argument_list|)
return|;
block|}
comment|/** Get the value of an extension. */
annotation|@
name|Override
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|Type
name|getExtension
parameter_list|(
specifier|final
name|GeneratedExtension
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
name|extension
parameter_list|)
block|{
return|return
name|getExtension
argument_list|(
operator|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
operator|)
name|extension
argument_list|)
return|;
block|}
comment|/** Get one element of a repeated extension. */
annotation|@
name|Override
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|Type
name|getExtension
parameter_list|(
specifier|final
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extension
parameter_list|,
specifier|final
name|int
name|index
parameter_list|)
block|{
return|return
name|getExtension
argument_list|(
operator|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
operator|)
name|extension
argument_list|,
name|index
argument_list|)
return|;
block|}
comment|/** Get one element of a repeated extension. */
annotation|@
name|Override
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|Type
name|getExtension
parameter_list|(
specifier|final
name|GeneratedExtension
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extension
parameter_list|,
specifier|final
name|int
name|index
parameter_list|)
block|{
return|return
name|getExtension
argument_list|(
operator|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
operator|)
name|extension
argument_list|,
name|index
argument_list|)
return|;
block|}
comment|/** Called by subclasses to check if all extensions are initialized. */
specifier|protected
name|boolean
name|extensionsAreInitialized
parameter_list|()
block|{
return|return
name|extensions
operator|.
name|isInitialized
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isInitialized
parameter_list|()
block|{
return|return
name|super
operator|.
name|isInitialized
argument_list|()
operator|&&
name|extensionsAreInitialized
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|parseUnknownField
parameter_list|(
name|CodedInputStream
name|input
parameter_list|,
name|UnknownFieldSet
operator|.
name|Builder
name|unknownFields
parameter_list|,
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|,
name|int
name|tag
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|MessageReflection
operator|.
name|mergeFieldFrom
argument_list|(
name|input
argument_list|,
name|unknownFields
argument_list|,
name|extensionRegistry
argument_list|,
name|getDescriptorForType
argument_list|()
argument_list|,
operator|new
name|MessageReflection
operator|.
name|ExtensionAdapter
argument_list|(
name|extensions
argument_list|)
argument_list|,
name|tag
argument_list|)
return|;
block|}
comment|/**      * Used by parsing constructors in generated classes.      */
annotation|@
name|Override
specifier|protected
name|void
name|makeExtensionsImmutable
parameter_list|()
block|{
name|extensions
operator|.
name|makeImmutable
argument_list|()
expr_stmt|;
block|}
comment|/**      * Used by subclasses to serialize extensions.  Extension ranges may be      * interleaved with field numbers, but we must write them in canonical      * (sorted by field number) order.  ExtensionWriter helps us write      * individual ranges of extensions at once.      */
specifier|protected
class|class
name|ExtensionWriter
block|{
comment|// Imagine how much simpler this code would be if Java iterators had
comment|// a way to get the next element without advancing the iterator.
specifier|private
specifier|final
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|FieldDescriptor
argument_list|,
name|Object
argument_list|>
argument_list|>
name|iter
init|=
name|extensions
operator|.
name|iterator
argument_list|()
decl_stmt|;
specifier|private
name|Map
operator|.
name|Entry
argument_list|<
name|FieldDescriptor
argument_list|,
name|Object
argument_list|>
name|next
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|messageSetWireFormat
decl_stmt|;
specifier|private
name|ExtensionWriter
parameter_list|(
specifier|final
name|boolean
name|messageSetWireFormat
parameter_list|)
block|{
if|if
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|next
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|messageSetWireFormat
operator|=
name|messageSetWireFormat
expr_stmt|;
block|}
specifier|public
name|void
name|writeUntil
parameter_list|(
specifier|final
name|int
name|end
parameter_list|,
specifier|final
name|CodedOutputStream
name|output
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
name|next
operator|!=
literal|null
operator|&&
name|next
operator|.
name|getKey
argument_list|()
operator|.
name|getNumber
argument_list|()
operator|<
name|end
condition|)
block|{
name|FieldDescriptor
name|descriptor
init|=
name|next
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|messageSetWireFormat
operator|&&
name|descriptor
operator|.
name|getLiteJavaType
argument_list|()
operator|==
name|WireFormat
operator|.
name|JavaType
operator|.
name|MESSAGE
operator|&&
operator|!
name|descriptor
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
if|if
condition|(
name|next
operator|instanceof
name|LazyField
operator|.
name|LazyEntry
argument_list|<
name|?
argument_list|>
condition|)
block|{
name|output
operator|.
name|writeRawMessageSetExtension
argument_list|(
name|descriptor
operator|.
name|getNumber
argument_list|()
argument_list|,
operator|(
operator|(
name|LazyField
operator|.
name|LazyEntry
argument_list|<
name|?
argument_list|>
operator|)
name|next
operator|)
operator|.
name|getField
argument_list|()
operator|.
name|toByteString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output
operator|.
name|writeMessageSetExtension
argument_list|(
name|descriptor
operator|.
name|getNumber
argument_list|()
argument_list|,
operator|(
name|Message
operator|)
name|next
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// TODO(xiangl): Taken care of following code, it may cause
comment|// problem when we use LazyField for normal fields/extensions.
comment|// Due to the optional field can be duplicated at the end of
comment|// serialized bytes, which will make the serialized size change
comment|// after lazy field parsed. So when we use LazyField globally,
comment|// we need to change the following write method to write cached
comment|// bytes directly rather than write the parsed message.
name|FieldSet
operator|.
name|writeField
argument_list|(
name|descriptor
argument_list|,
name|next
operator|.
name|getValue
argument_list|()
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|next
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|protected
name|ExtensionWriter
name|newExtensionWriter
parameter_list|()
block|{
return|return
operator|new
name|ExtensionWriter
argument_list|(
literal|false
argument_list|)
return|;
block|}
specifier|protected
name|ExtensionWriter
name|newMessageSetExtensionWriter
parameter_list|()
block|{
return|return
operator|new
name|ExtensionWriter
argument_list|(
literal|true
argument_list|)
return|;
block|}
comment|/** Called by subclasses to compute the size of extensions. */
specifier|protected
name|int
name|extensionsSerializedSize
parameter_list|()
block|{
return|return
name|extensions
operator|.
name|getSerializedSize
argument_list|()
return|;
block|}
specifier|protected
name|int
name|extensionsSerializedSizeAsMessageSet
parameter_list|()
block|{
return|return
name|extensions
operator|.
name|getMessageSetSerializedSize
argument_list|()
return|;
block|}
comment|// ---------------------------------------------------------------
comment|// Reflection
specifier|protected
name|Map
argument_list|<
name|FieldDescriptor
argument_list|,
name|Object
argument_list|>
name|getExtensionFields
parameter_list|()
block|{
return|return
name|extensions
operator|.
name|getAllFields
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|FieldDescriptor
argument_list|,
name|Object
argument_list|>
name|getAllFields
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|FieldDescriptor
argument_list|,
name|Object
argument_list|>
name|result
init|=
name|super
operator|.
name|getAllFieldsMutable
argument_list|(
comment|/* getBytesForString = */
literal|false
argument_list|)
decl_stmt|;
name|result
operator|.
name|putAll
argument_list|(
name|getExtensionFields
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|result
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|FieldDescriptor
argument_list|,
name|Object
argument_list|>
name|getAllFieldsRaw
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|FieldDescriptor
argument_list|,
name|Object
argument_list|>
name|result
init|=
name|super
operator|.
name|getAllFieldsMutable
argument_list|(
comment|/* getBytesForString = */
literal|false
argument_list|)
decl_stmt|;
name|result
operator|.
name|putAll
argument_list|(
name|getExtensionFields
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|result
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasField
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|)
block|{
if|if
condition|(
name|field
operator|.
name|isExtension
argument_list|()
condition|)
block|{
name|verifyContainingType
argument_list|(
name|field
argument_list|)
expr_stmt|;
return|return
name|extensions
operator|.
name|hasField
argument_list|(
name|field
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|super
operator|.
name|hasField
argument_list|(
name|field
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getField
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|)
block|{
if|if
condition|(
name|field
operator|.
name|isExtension
argument_list|()
condition|)
block|{
name|verifyContainingType
argument_list|(
name|field
argument_list|)
expr_stmt|;
specifier|final
name|Object
name|value
init|=
name|extensions
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|field
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|getJavaType
argument_list|()
operator|==
name|FieldDescriptor
operator|.
name|JavaType
operator|.
name|MESSAGE
condition|)
block|{
comment|// Lacking an ExtensionRegistry, we have no way to determine the
comment|// extension's real type, so we return a DynamicMessage.
return|return
name|DynamicMessage
operator|.
name|getDefaultInstance
argument_list|(
name|field
operator|.
name|getMessageType
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|field
operator|.
name|getDefaultValue
argument_list|()
return|;
block|}
block|}
else|else
block|{
return|return
name|value
return|;
block|}
block|}
else|else
block|{
return|return
name|super
operator|.
name|getField
argument_list|(
name|field
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|getRepeatedFieldCount
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|)
block|{
if|if
condition|(
name|field
operator|.
name|isExtension
argument_list|()
condition|)
block|{
name|verifyContainingType
argument_list|(
name|field
argument_list|)
expr_stmt|;
return|return
name|extensions
operator|.
name|getRepeatedFieldCount
argument_list|(
name|field
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|super
operator|.
name|getRepeatedFieldCount
argument_list|(
name|field
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getRepeatedField
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|,
specifier|final
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|field
operator|.
name|isExtension
argument_list|()
condition|)
block|{
name|verifyContainingType
argument_list|(
name|field
argument_list|)
expr_stmt|;
return|return
name|extensions
operator|.
name|getRepeatedField
argument_list|(
name|field
argument_list|,
name|index
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|super
operator|.
name|getRepeatedField
argument_list|(
name|field
argument_list|,
name|index
argument_list|)
return|;
block|}
block|}
specifier|private
name|void
name|verifyContainingType
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|)
block|{
if|if
condition|(
name|field
operator|.
name|getContainingType
argument_list|()
operator|!=
name|getDescriptorForType
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"FieldDescriptor does not match message type."
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Generated message builders for message types that contain extension ranges    * subclass this.    *    *<p>This class implements type-safe accessors for extensions.  They    * implement all the same operations that you can do with normal fields --    * e.g. "get", "set", and "add" -- but for extensions.  The extensions are    * identified using instances of the class {@link GeneratedExtension}; the    * protocol compiler generates a static instance of this class for every    * extension in its input.  Through the magic of generics, all is made    * type-safe.    *    *<p>For example, imagine you have the {@code .proto} file:    *    *<pre>    * option java_class = "MyProto";    *    * message Foo {    *   extensions 1000 to max;    * }    *    * extend Foo {    *   optional int32 bar;    * }    *</pre>    *    *<p>Then you might write code like:    *    *<pre>    * MyProto.Foo foo =    *   MyProto.Foo.newBuilder()    *     .setExtension(MyProto.bar, 123)    *     .build();    *</pre>    *    *<p>See also {@link ExtendableMessage}.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|abstract
specifier|static
class|class
name|ExtendableBuilder
parameter_list|<
name|MessageType
extends|extends
name|ExtendableMessage
parameter_list|,
name|BuilderType
extends|extends
name|ExtendableBuilder
parameter_list|<
name|MessageType
parameter_list|,
name|BuilderType
parameter_list|>
parameter_list|>
extends|extends
name|Builder
argument_list|<
name|BuilderType
argument_list|>
implements|implements
name|ExtendableMessageOrBuilder
argument_list|<
name|MessageType
argument_list|>
block|{
specifier|private
name|FieldSet
argument_list|<
name|FieldDescriptor
argument_list|>
name|extensions
init|=
name|FieldSet
operator|.
name|emptySet
argument_list|()
decl_stmt|;
specifier|protected
name|ExtendableBuilder
parameter_list|()
block|{}
specifier|protected
name|ExtendableBuilder
parameter_list|(
name|BuilderParent
name|parent
parameter_list|)
block|{
name|super
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
comment|// For immutable message conversion.
name|void
name|internalSetExtensionSet
parameter_list|(
name|FieldSet
argument_list|<
name|FieldDescriptor
argument_list|>
name|extensions
parameter_list|)
block|{
name|this
operator|.
name|extensions
operator|=
name|extensions
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|BuilderType
name|clear
parameter_list|()
block|{
name|extensions
operator|=
name|FieldSet
operator|.
name|emptySet
argument_list|()
expr_stmt|;
return|return
name|super
operator|.
name|clear
argument_list|()
return|;
block|}
comment|// This is implemented here only to work around an apparent bug in the
comment|// Java compiler and/or build system.  See bug #1898463.  The mere presence
comment|// of this clone() implementation makes it go away.
annotation|@
name|Override
specifier|public
name|BuilderType
name|clone
parameter_list|()
block|{
return|return
name|super
operator|.
name|clone
argument_list|()
return|;
block|}
specifier|private
name|void
name|ensureExtensionsIsMutable
parameter_list|()
block|{
if|if
condition|(
name|extensions
operator|.
name|isImmutable
argument_list|()
condition|)
block|{
name|extensions
operator|=
name|extensions
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|verifyExtensionContainingType
parameter_list|(
specifier|final
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|?
argument_list|>
name|extension
parameter_list|)
block|{
if|if
condition|(
name|extension
operator|.
name|getDescriptor
argument_list|()
operator|.
name|getContainingType
argument_list|()
operator|!=
name|getDescriptorForType
argument_list|()
condition|)
block|{
comment|// This can only happen if someone uses unchecked operations.
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Extension is for type \""
operator|+
name|extension
operator|.
name|getDescriptor
argument_list|()
operator|.
name|getContainingType
argument_list|()
operator|.
name|getFullName
argument_list|()
operator|+
literal|"\" which does not match message type \""
operator|+
name|getDescriptorForType
argument_list|()
operator|.
name|getFullName
argument_list|()
operator|+
literal|"\"."
argument_list|)
throw|;
block|}
block|}
comment|/** Check if a singular extension is present. */
annotation|@
name|Override
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|boolean
name|hasExtension
parameter_list|(
specifier|final
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
name|extensionLite
parameter_list|)
block|{
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
name|extension
init|=
name|checkNotLite
argument_list|(
name|extensionLite
argument_list|)
decl_stmt|;
name|verifyExtensionContainingType
argument_list|(
name|extension
argument_list|)
expr_stmt|;
return|return
name|extensions
operator|.
name|hasField
argument_list|(
name|extension
operator|.
name|getDescriptor
argument_list|()
argument_list|)
return|;
block|}
comment|/** Get the number of elements in a repeated extension. */
annotation|@
name|Override
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|int
name|getExtensionCount
parameter_list|(
specifier|final
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extensionLite
parameter_list|)
block|{
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extension
init|=
name|checkNotLite
argument_list|(
name|extensionLite
argument_list|)
decl_stmt|;
name|verifyExtensionContainingType
argument_list|(
name|extension
argument_list|)
expr_stmt|;
specifier|final
name|FieldDescriptor
name|descriptor
init|=
name|extension
operator|.
name|getDescriptor
argument_list|()
decl_stmt|;
return|return
name|extensions
operator|.
name|getRepeatedFieldCount
argument_list|(
name|descriptor
argument_list|)
return|;
block|}
comment|/** Get the value of an extension. */
annotation|@
name|Override
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|Type
name|getExtension
parameter_list|(
specifier|final
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
name|extensionLite
parameter_list|)
block|{
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
name|extension
init|=
name|checkNotLite
argument_list|(
name|extensionLite
argument_list|)
decl_stmt|;
name|verifyExtensionContainingType
argument_list|(
name|extension
argument_list|)
expr_stmt|;
name|FieldDescriptor
name|descriptor
init|=
name|extension
operator|.
name|getDescriptor
argument_list|()
decl_stmt|;
specifier|final
name|Object
name|value
init|=
name|extensions
operator|.
name|getField
argument_list|(
name|descriptor
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|descriptor
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
return|return
operator|(
name|Type
operator|)
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|descriptor
operator|.
name|getJavaType
argument_list|()
operator|==
name|FieldDescriptor
operator|.
name|JavaType
operator|.
name|MESSAGE
condition|)
block|{
return|return
operator|(
name|Type
operator|)
name|extension
operator|.
name|getMessageDefaultInstance
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|Type
operator|)
name|extension
operator|.
name|fromReflectionType
argument_list|(
name|descriptor
operator|.
name|getDefaultValue
argument_list|()
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
operator|(
name|Type
operator|)
name|extension
operator|.
name|fromReflectionType
argument_list|(
name|value
argument_list|)
return|;
block|}
block|}
comment|/** Get one element of a repeated extension. */
annotation|@
name|Override
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|Type
name|getExtension
parameter_list|(
specifier|final
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extensionLite
parameter_list|,
specifier|final
name|int
name|index
parameter_list|)
block|{
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extension
init|=
name|checkNotLite
argument_list|(
name|extensionLite
argument_list|)
decl_stmt|;
name|verifyExtensionContainingType
argument_list|(
name|extension
argument_list|)
expr_stmt|;
name|FieldDescriptor
name|descriptor
init|=
name|extension
operator|.
name|getDescriptor
argument_list|()
decl_stmt|;
return|return
operator|(
name|Type
operator|)
name|extension
operator|.
name|singularFromReflectionType
argument_list|(
name|extensions
operator|.
name|getRepeatedField
argument_list|(
name|descriptor
argument_list|,
name|index
argument_list|)
argument_list|)
return|;
block|}
comment|/** Set the value of an extension. */
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|BuilderType
name|setExtension
parameter_list|(
specifier|final
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
name|extensionLite
parameter_list|,
specifier|final
name|Type
name|value
parameter_list|)
block|{
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
name|extension
init|=
name|checkNotLite
argument_list|(
name|extensionLite
argument_list|)
decl_stmt|;
name|verifyExtensionContainingType
argument_list|(
name|extension
argument_list|)
expr_stmt|;
name|ensureExtensionsIsMutable
argument_list|()
expr_stmt|;
specifier|final
name|FieldDescriptor
name|descriptor
init|=
name|extension
operator|.
name|getDescriptor
argument_list|()
decl_stmt|;
name|extensions
operator|.
name|setField
argument_list|(
name|descriptor
argument_list|,
name|extension
operator|.
name|toReflectionType
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|onChanged
argument_list|()
expr_stmt|;
return|return
operator|(
name|BuilderType
operator|)
name|this
return|;
block|}
comment|/** Set the value of one element of a repeated extension. */
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|BuilderType
name|setExtension
parameter_list|(
specifier|final
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extensionLite
parameter_list|,
specifier|final
name|int
name|index
parameter_list|,
specifier|final
name|Type
name|value
parameter_list|)
block|{
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extension
init|=
name|checkNotLite
argument_list|(
name|extensionLite
argument_list|)
decl_stmt|;
name|verifyExtensionContainingType
argument_list|(
name|extension
argument_list|)
expr_stmt|;
name|ensureExtensionsIsMutable
argument_list|()
expr_stmt|;
specifier|final
name|FieldDescriptor
name|descriptor
init|=
name|extension
operator|.
name|getDescriptor
argument_list|()
decl_stmt|;
name|extensions
operator|.
name|setRepeatedField
argument_list|(
name|descriptor
argument_list|,
name|index
argument_list|,
name|extension
operator|.
name|singularToReflectionType
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|onChanged
argument_list|()
expr_stmt|;
return|return
operator|(
name|BuilderType
operator|)
name|this
return|;
block|}
comment|/** Append a value to a repeated extension. */
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|BuilderType
name|addExtension
parameter_list|(
specifier|final
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extensionLite
parameter_list|,
specifier|final
name|Type
name|value
parameter_list|)
block|{
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extension
init|=
name|checkNotLite
argument_list|(
name|extensionLite
argument_list|)
decl_stmt|;
name|verifyExtensionContainingType
argument_list|(
name|extension
argument_list|)
expr_stmt|;
name|ensureExtensionsIsMutable
argument_list|()
expr_stmt|;
specifier|final
name|FieldDescriptor
name|descriptor
init|=
name|extension
operator|.
name|getDescriptor
argument_list|()
decl_stmt|;
name|extensions
operator|.
name|addRepeatedField
argument_list|(
name|descriptor
argument_list|,
name|extension
operator|.
name|singularToReflectionType
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|onChanged
argument_list|()
expr_stmt|;
return|return
operator|(
name|BuilderType
operator|)
name|this
return|;
block|}
comment|/** Clear an extension. */
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|BuilderType
name|clearExtension
parameter_list|(
specifier|final
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|?
argument_list|>
name|extensionLite
parameter_list|)
block|{
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|?
argument_list|>
name|extension
init|=
name|checkNotLite
argument_list|(
name|extensionLite
argument_list|)
decl_stmt|;
name|verifyExtensionContainingType
argument_list|(
name|extension
argument_list|)
expr_stmt|;
name|ensureExtensionsIsMutable
argument_list|()
expr_stmt|;
name|extensions
operator|.
name|clearField
argument_list|(
name|extension
operator|.
name|getDescriptor
argument_list|()
argument_list|)
expr_stmt|;
name|onChanged
argument_list|()
expr_stmt|;
return|return
operator|(
name|BuilderType
operator|)
name|this
return|;
block|}
comment|/** Check if a singular extension is present. */
annotation|@
name|Override
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|boolean
name|hasExtension
parameter_list|(
specifier|final
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
name|extension
parameter_list|)
block|{
return|return
name|hasExtension
argument_list|(
operator|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
operator|)
name|extension
argument_list|)
return|;
block|}
comment|/** Check if a singular extension is present. */
annotation|@
name|Override
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|boolean
name|hasExtension
parameter_list|(
specifier|final
name|GeneratedExtension
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
name|extension
parameter_list|)
block|{
return|return
name|hasExtension
argument_list|(
operator|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
operator|)
name|extension
argument_list|)
return|;
block|}
comment|/** Get the number of elements in a repeated extension. */
annotation|@
name|Override
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|int
name|getExtensionCount
parameter_list|(
specifier|final
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extension
parameter_list|)
block|{
return|return
name|getExtensionCount
argument_list|(
operator|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
operator|)
name|extension
argument_list|)
return|;
block|}
comment|/** Get the number of elements in a repeated extension. */
annotation|@
name|Override
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|int
name|getExtensionCount
parameter_list|(
specifier|final
name|GeneratedExtension
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extension
parameter_list|)
block|{
return|return
name|getExtensionCount
argument_list|(
operator|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
operator|)
name|extension
argument_list|)
return|;
block|}
comment|/** Get the value of an extension. */
annotation|@
name|Override
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|Type
name|getExtension
parameter_list|(
specifier|final
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
name|extension
parameter_list|)
block|{
return|return
name|getExtension
argument_list|(
operator|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
operator|)
name|extension
argument_list|)
return|;
block|}
comment|/** Get the value of an extension. */
annotation|@
name|Override
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|Type
name|getExtension
parameter_list|(
specifier|final
name|GeneratedExtension
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
name|extension
parameter_list|)
block|{
return|return
name|getExtension
argument_list|(
operator|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
operator|)
name|extension
argument_list|)
return|;
block|}
comment|/** Get the value of an extension. */
annotation|@
name|Override
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|Type
name|getExtension
parameter_list|(
specifier|final
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extension
parameter_list|,
specifier|final
name|int
name|index
parameter_list|)
block|{
return|return
name|getExtension
argument_list|(
operator|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
operator|)
name|extension
argument_list|,
name|index
argument_list|)
return|;
block|}
comment|/** Get the value of an extension. */
annotation|@
name|Override
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|Type
name|getExtension
parameter_list|(
specifier|final
name|GeneratedExtension
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extension
parameter_list|,
specifier|final
name|int
name|index
parameter_list|)
block|{
return|return
name|getExtension
argument_list|(
operator|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
operator|)
name|extension
argument_list|,
name|index
argument_list|)
return|;
block|}
comment|/** Set the value of an extension. */
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|BuilderType
name|setExtension
parameter_list|(
specifier|final
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
name|extension
parameter_list|,
specifier|final
name|Type
name|value
parameter_list|)
block|{
return|return
name|setExtension
argument_list|(
operator|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
operator|)
name|extension
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** Set the value of an extension. */
specifier|public
parameter_list|<
name|Type
parameter_list|>
name|BuilderType
name|setExtension
parameter_list|(
specifier|final
name|GeneratedExtension
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
name|extension
parameter_list|,
specifier|final
name|Type
name|value
parameter_list|)
block|{
return|return
name|setExtension
argument_list|(
operator|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|Type
argument_list|>
operator|)
name|extension
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** Set the value of one element of a repeated extension. */
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|BuilderType
name|setExtension
parameter_list|(
specifier|final
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extension
parameter_list|,
specifier|final
name|int
name|index
parameter_list|,
specifier|final
name|Type
name|value
parameter_list|)
block|{
return|return
name|setExtension
argument_list|(
operator|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
operator|)
name|extension
argument_list|,
name|index
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** Set the value of one element of a repeated extension. */
specifier|public
parameter_list|<
name|Type
parameter_list|>
name|BuilderType
name|setExtension
parameter_list|(
specifier|final
name|GeneratedExtension
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extension
parameter_list|,
specifier|final
name|int
name|index
parameter_list|,
specifier|final
name|Type
name|value
parameter_list|)
block|{
return|return
name|setExtension
argument_list|(
operator|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
operator|)
name|extension
argument_list|,
name|index
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** Append a value to a repeated extension. */
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|BuilderType
name|addExtension
parameter_list|(
specifier|final
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extension
parameter_list|,
specifier|final
name|Type
name|value
parameter_list|)
block|{
return|return
name|addExtension
argument_list|(
operator|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
operator|)
name|extension
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** Append a value to a repeated extension. */
specifier|public
parameter_list|<
name|Type
parameter_list|>
name|BuilderType
name|addExtension
parameter_list|(
specifier|final
name|GeneratedExtension
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
name|extension
parameter_list|,
specifier|final
name|Type
name|value
parameter_list|)
block|{
return|return
name|addExtension
argument_list|(
operator|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|List
argument_list|<
name|Type
argument_list|>
argument_list|>
operator|)
name|extension
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/** Clear an extension. */
specifier|public
specifier|final
parameter_list|<
name|Type
parameter_list|>
name|BuilderType
name|clearExtension
parameter_list|(
specifier|final
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|?
argument_list|>
name|extension
parameter_list|)
block|{
return|return
name|clearExtension
argument_list|(
operator|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|?
argument_list|>
operator|)
name|extension
argument_list|)
return|;
block|}
comment|/** Clear an extension. */
specifier|public
parameter_list|<
name|Type
parameter_list|>
name|BuilderType
name|clearExtension
parameter_list|(
specifier|final
name|GeneratedExtension
argument_list|<
name|MessageType
argument_list|,
name|?
argument_list|>
name|extension
parameter_list|)
block|{
return|return
name|clearExtension
argument_list|(
operator|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|?
argument_list|>
operator|)
name|extension
argument_list|)
return|;
block|}
comment|/** Called by subclasses to check if all extensions are initialized. */
specifier|protected
name|boolean
name|extensionsAreInitialized
parameter_list|()
block|{
return|return
name|extensions
operator|.
name|isInitialized
argument_list|()
return|;
block|}
comment|/**      * Called by the build code path to create a copy of the extensions for      * building the message.      */
specifier|private
name|FieldSet
argument_list|<
name|FieldDescriptor
argument_list|>
name|buildExtensions
parameter_list|()
block|{
name|extensions
operator|.
name|makeImmutable
argument_list|()
expr_stmt|;
return|return
name|extensions
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isInitialized
parameter_list|()
block|{
return|return
name|super
operator|.
name|isInitialized
argument_list|()
operator|&&
name|extensionsAreInitialized
argument_list|()
return|;
block|}
comment|/**      * Called by subclasses to parse an unknown field or an extension.      * @return {@code true} unless the tag is an end-group tag.      */
annotation|@
name|Override
specifier|protected
name|boolean
name|parseUnknownField
parameter_list|(
specifier|final
name|CodedInputStream
name|input
parameter_list|,
specifier|final
name|UnknownFieldSet
operator|.
name|Builder
name|unknownFields
parameter_list|,
specifier|final
name|ExtensionRegistryLite
name|extensionRegistry
parameter_list|,
specifier|final
name|int
name|tag
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|MessageReflection
operator|.
name|mergeFieldFrom
argument_list|(
name|input
argument_list|,
name|unknownFields
argument_list|,
name|extensionRegistry
argument_list|,
name|getDescriptorForType
argument_list|()
argument_list|,
operator|new
name|MessageReflection
operator|.
name|BuilderAdapter
argument_list|(
name|this
argument_list|)
argument_list|,
name|tag
argument_list|)
return|;
block|}
comment|// ---------------------------------------------------------------
comment|// Reflection
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|FieldDescriptor
argument_list|,
name|Object
argument_list|>
name|getAllFields
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|FieldDescriptor
argument_list|,
name|Object
argument_list|>
name|result
init|=
name|super
operator|.
name|getAllFieldsMutable
argument_list|()
decl_stmt|;
name|result
operator|.
name|putAll
argument_list|(
name|extensions
operator|.
name|getAllFields
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|result
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getField
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|)
block|{
if|if
condition|(
name|field
operator|.
name|isExtension
argument_list|()
condition|)
block|{
name|verifyContainingType
argument_list|(
name|field
argument_list|)
expr_stmt|;
specifier|final
name|Object
name|value
init|=
name|extensions
operator|.
name|getField
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|field
operator|.
name|getJavaType
argument_list|()
operator|==
name|FieldDescriptor
operator|.
name|JavaType
operator|.
name|MESSAGE
condition|)
block|{
comment|// Lacking an ExtensionRegistry, we have no way to determine the
comment|// extension's real type, so we return a DynamicMessage.
return|return
name|DynamicMessage
operator|.
name|getDefaultInstance
argument_list|(
name|field
operator|.
name|getMessageType
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|field
operator|.
name|getDefaultValue
argument_list|()
return|;
block|}
block|}
else|else
block|{
return|return
name|value
return|;
block|}
block|}
else|else
block|{
return|return
name|super
operator|.
name|getField
argument_list|(
name|field
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|getRepeatedFieldCount
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|)
block|{
if|if
condition|(
name|field
operator|.
name|isExtension
argument_list|()
condition|)
block|{
name|verifyContainingType
argument_list|(
name|field
argument_list|)
expr_stmt|;
return|return
name|extensions
operator|.
name|getRepeatedFieldCount
argument_list|(
name|field
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|super
operator|.
name|getRepeatedFieldCount
argument_list|(
name|field
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getRepeatedField
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|,
specifier|final
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|field
operator|.
name|isExtension
argument_list|()
condition|)
block|{
name|verifyContainingType
argument_list|(
name|field
argument_list|)
expr_stmt|;
return|return
name|extensions
operator|.
name|getRepeatedField
argument_list|(
name|field
argument_list|,
name|index
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|super
operator|.
name|getRepeatedField
argument_list|(
name|field
argument_list|,
name|index
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasField
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|)
block|{
if|if
condition|(
name|field
operator|.
name|isExtension
argument_list|()
condition|)
block|{
name|verifyContainingType
argument_list|(
name|field
argument_list|)
expr_stmt|;
return|return
name|extensions
operator|.
name|hasField
argument_list|(
name|field
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|super
operator|.
name|hasField
argument_list|(
name|field
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|BuilderType
name|setField
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|field
operator|.
name|isExtension
argument_list|()
condition|)
block|{
name|verifyContainingType
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|ensureExtensionsIsMutable
argument_list|()
expr_stmt|;
name|extensions
operator|.
name|setField
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|onChanged
argument_list|()
expr_stmt|;
return|return
operator|(
name|BuilderType
operator|)
name|this
return|;
block|}
else|else
block|{
return|return
name|super
operator|.
name|setField
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|BuilderType
name|clearField
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|)
block|{
if|if
condition|(
name|field
operator|.
name|isExtension
argument_list|()
condition|)
block|{
name|verifyContainingType
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|ensureExtensionsIsMutable
argument_list|()
expr_stmt|;
name|extensions
operator|.
name|clearField
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|onChanged
argument_list|()
expr_stmt|;
return|return
operator|(
name|BuilderType
operator|)
name|this
return|;
block|}
else|else
block|{
return|return
name|super
operator|.
name|clearField
argument_list|(
name|field
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|BuilderType
name|setRepeatedField
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|,
specifier|final
name|int
name|index
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|field
operator|.
name|isExtension
argument_list|()
condition|)
block|{
name|verifyContainingType
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|ensureExtensionsIsMutable
argument_list|()
expr_stmt|;
name|extensions
operator|.
name|setRepeatedField
argument_list|(
name|field
argument_list|,
name|index
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|onChanged
argument_list|()
expr_stmt|;
return|return
operator|(
name|BuilderType
operator|)
name|this
return|;
block|}
else|else
block|{
return|return
name|super
operator|.
name|setRepeatedField
argument_list|(
name|field
argument_list|,
name|index
argument_list|,
name|value
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|BuilderType
name|addRepeatedField
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|field
operator|.
name|isExtension
argument_list|()
condition|)
block|{
name|verifyContainingType
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|ensureExtensionsIsMutable
argument_list|()
expr_stmt|;
name|extensions
operator|.
name|addRepeatedField
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|onChanged
argument_list|()
expr_stmt|;
return|return
operator|(
name|BuilderType
operator|)
name|this
return|;
block|}
else|else
block|{
return|return
name|super
operator|.
name|addRepeatedField
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
return|;
block|}
block|}
specifier|protected
specifier|final
name|void
name|mergeExtensionFields
parameter_list|(
specifier|final
name|ExtendableMessage
name|other
parameter_list|)
block|{
name|ensureExtensionsIsMutable
argument_list|()
expr_stmt|;
name|extensions
operator|.
name|mergeFrom
argument_list|(
name|other
operator|.
name|extensions
argument_list|)
expr_stmt|;
name|onChanged
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|verifyContainingType
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|)
block|{
if|if
condition|(
name|field
operator|.
name|getContainingType
argument_list|()
operator|!=
name|getDescriptorForType
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"FieldDescriptor does not match message type."
argument_list|)
throw|;
block|}
block|}
block|}
comment|// -----------------------------------------------------------------
comment|/**    * Gets the descriptor for an extension. The implementation depends on whether    * the extension is scoped in the top level of a file or scoped in a Message.    */
specifier|static
interface|interface
name|ExtensionDescriptorRetriever
block|{
name|FieldDescriptor
name|getDescriptor
parameter_list|()
function_decl|;
block|}
comment|/** For use by generated code only. */
specifier|public
specifier|static
parameter_list|<
name|ContainingType
extends|extends
name|Message
parameter_list|,
name|Type
parameter_list|>
name|GeneratedExtension
argument_list|<
name|ContainingType
argument_list|,
name|Type
argument_list|>
name|newMessageScopedGeneratedExtension
parameter_list|(
specifier|final
name|Message
name|scope
parameter_list|,
specifier|final
name|int
name|descriptorIndex
parameter_list|,
specifier|final
name|Class
name|singularType
parameter_list|,
specifier|final
name|Message
name|defaultInstance
parameter_list|)
block|{
comment|// For extensions scoped within a Message, we use the Message to resolve
comment|// the outer class's descriptor, from which the extension descriptor is
comment|// obtained.
return|return
operator|new
name|GeneratedExtension
argument_list|<
name|ContainingType
argument_list|,
name|Type
argument_list|>
argument_list|(
operator|new
name|CachedDescriptorRetriever
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FieldDescriptor
name|loadDescriptor
parameter_list|()
block|{
return|return
name|scope
operator|.
name|getDescriptorForType
argument_list|()
operator|.
name|getExtensions
argument_list|()
operator|.
name|get
argument_list|(
name|descriptorIndex
argument_list|)
return|;
block|}
block|}
argument_list|,
name|singularType
argument_list|,
name|defaultInstance
argument_list|,
name|Extension
operator|.
name|ExtensionType
operator|.
name|IMMUTABLE
argument_list|)
return|;
block|}
comment|/** For use by generated code only. */
specifier|public
specifier|static
parameter_list|<
name|ContainingType
extends|extends
name|Message
parameter_list|,
name|Type
parameter_list|>
name|GeneratedExtension
argument_list|<
name|ContainingType
argument_list|,
name|Type
argument_list|>
name|newFileScopedGeneratedExtension
parameter_list|(
specifier|final
name|Class
name|singularType
parameter_list|,
specifier|final
name|Message
name|defaultInstance
parameter_list|)
block|{
comment|// For extensions scoped within a file, we rely on the outer class's
comment|// static initializer to call internalInit() on the extension when the
comment|// descriptor is available.
return|return
operator|new
name|GeneratedExtension
argument_list|<
name|ContainingType
argument_list|,
name|Type
argument_list|>
argument_list|(
literal|null
argument_list|,
comment|// ExtensionDescriptorRetriever is initialized in internalInit();
name|singularType
argument_list|,
name|defaultInstance
argument_list|,
name|Extension
operator|.
name|ExtensionType
operator|.
name|IMMUTABLE
argument_list|)
return|;
block|}
specifier|private
specifier|abstract
specifier|static
class|class
name|CachedDescriptorRetriever
implements|implements
name|ExtensionDescriptorRetriever
block|{
specifier|private
specifier|volatile
name|FieldDescriptor
name|descriptor
decl_stmt|;
specifier|protected
specifier|abstract
name|FieldDescriptor
name|loadDescriptor
parameter_list|()
function_decl|;
annotation|@
name|Override
specifier|public
name|FieldDescriptor
name|getDescriptor
parameter_list|()
block|{
if|if
condition|(
name|descriptor
operator|==
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|descriptor
operator|==
literal|null
condition|)
block|{
name|descriptor
operator|=
name|loadDescriptor
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
name|descriptor
return|;
block|}
block|}
comment|/**    * Used in proto1 generated code only.    *    * After enabling bridge, we can define proto2 extensions (the extended type    * is a proto2 mutable message) in a proto1 .proto file. For these extensions    * we should generate proto2 GeneratedExtensions.    */
specifier|public
specifier|static
parameter_list|<
name|ContainingType
extends|extends
name|Message
parameter_list|,
name|Type
parameter_list|>
name|GeneratedExtension
argument_list|<
name|ContainingType
argument_list|,
name|Type
argument_list|>
name|newMessageScopedGeneratedExtension
parameter_list|(
specifier|final
name|Message
name|scope
parameter_list|,
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|Class
name|singularType
parameter_list|,
specifier|final
name|Message
name|defaultInstance
parameter_list|)
block|{
comment|// For extensions scoped within a Message, we use the Message to resolve
comment|// the outer class's descriptor, from which the extension descriptor is
comment|// obtained.
return|return
operator|new
name|GeneratedExtension
argument_list|<
name|ContainingType
argument_list|,
name|Type
argument_list|>
argument_list|(
operator|new
name|CachedDescriptorRetriever
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|FieldDescriptor
name|loadDescriptor
parameter_list|()
block|{
return|return
name|scope
operator|.
name|getDescriptorForType
argument_list|()
operator|.
name|findFieldByName
argument_list|(
name|name
argument_list|)
return|;
block|}
block|}
argument_list|,
name|singularType
argument_list|,
name|defaultInstance
argument_list|,
name|Extension
operator|.
name|ExtensionType
operator|.
name|MUTABLE
argument_list|)
return|;
block|}
comment|/**    * Used in proto1 generated code only.    *    * After enabling bridge, we can define proto2 extensions (the extended type    * is a proto2 mutable message) in a proto1 .proto file. For these extensions    * we should generate proto2 GeneratedExtensions.    */
specifier|public
specifier|static
parameter_list|<
name|ContainingType
extends|extends
name|Message
parameter_list|,
name|Type
parameter_list|>
name|GeneratedExtension
argument_list|<
name|ContainingType
argument_list|,
name|Type
argument_list|>
name|newFileScopedGeneratedExtension
parameter_list|(
specifier|final
name|Class
name|singularType
parameter_list|,
specifier|final
name|Message
name|defaultInstance
parameter_list|,
specifier|final
name|String
name|descriptorOuterClass
parameter_list|,
specifier|final
name|String
name|extensionName
parameter_list|)
block|{
comment|// For extensions scoped within a file, we load the descriptor outer
comment|// class and rely on it to get the FileDescriptor which then can be
comment|// used to obtain the extension's FieldDescriptor.
return|return
operator|new
name|GeneratedExtension
argument_list|<
name|ContainingType
argument_list|,
name|Type
argument_list|>
argument_list|(
operator|new
name|CachedDescriptorRetriever
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|FieldDescriptor
name|loadDescriptor
parameter_list|()
block|{
try|try
block|{
name|Class
name|clazz
init|=
name|singularType
operator|.
name|getClassLoader
argument_list|()
operator|.
name|loadClass
argument_list|(
name|descriptorOuterClass
argument_list|)
decl_stmt|;
name|FileDescriptor
name|file
init|=
operator|(
name|FileDescriptor
operator|)
name|clazz
operator|.
name|getField
argument_list|(
literal|"descriptor"
argument_list|)
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
return|return
name|file
operator|.
name|findExtensionByName
argument_list|(
name|extensionName
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Cannot load descriptors: "
operator|+
name|descriptorOuterClass
operator|+
literal|" is not a valid descriptor class name"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
argument_list|,
name|singularType
argument_list|,
name|defaultInstance
argument_list|,
name|Extension
operator|.
name|ExtensionType
operator|.
name|MUTABLE
argument_list|)
return|;
block|}
comment|/**    * Type used to represent generated extensions.  The protocol compiler    * generates a static singleton instance of this class for each extension.    *    *<p>For example, imagine you have the {@code .proto} file:    *    *<pre>    * option java_class = "MyProto";    *    * message Foo {    *   extensions 1000 to max;    * }    *    * extend Foo {    *   optional int32 bar;    * }    *</pre>    *    *<p>Then, {@code MyProto.Foo.bar} has type    * {@code GeneratedExtension<MyProto.Foo, Integer>}.    *    *<p>In general, users should ignore the details of this type, and simply use    * these static singletons as parameters to the extension accessors defined    * in {@link ExtendableMessage} and {@link ExtendableBuilder}.    */
specifier|public
specifier|static
class|class
name|GeneratedExtension
parameter_list|<
name|ContainingType
extends|extends
name|Message
parameter_list|,
name|Type
parameter_list|>
extends|extends
name|Extension
argument_list|<
name|ContainingType
argument_list|,
name|Type
argument_list|>
block|{
comment|// TODO(kenton):  Find ways to avoid using Java reflection within this
comment|//   class.  Also try to avoid suppressing unchecked warnings.
comment|// We can't always initialize the descriptor of a GeneratedExtension when
comment|// we first construct it due to initialization order difficulties (namely,
comment|// the descriptor may not have been constructed yet, since it is often
comment|// constructed by the initializer of a separate module).
comment|//
comment|// In the case of nested extensions, we initialize the
comment|// ExtensionDescriptorRetriever with an instance that uses the scoping
comment|// Message's default instance to retrieve the extension's descriptor.
comment|//
comment|// In the case of non-nested extensions, we initialize the
comment|// ExtensionDescriptorRetriever to null and rely on the outer class's static
comment|// initializer to call internalInit() after the descriptor has been parsed.
name|GeneratedExtension
parameter_list|(
name|ExtensionDescriptorRetriever
name|descriptorRetriever
parameter_list|,
name|Class
name|singularType
parameter_list|,
name|Message
name|messageDefaultInstance
parameter_list|,
name|ExtensionType
name|extensionType
parameter_list|)
block|{
if|if
condition|(
name|Message
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|singularType
argument_list|)
operator|&&
operator|!
name|singularType
operator|.
name|isInstance
argument_list|(
name|messageDefaultInstance
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Bad messageDefaultInstance for "
operator|+
name|singularType
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
name|this
operator|.
name|descriptorRetriever
operator|=
name|descriptorRetriever
expr_stmt|;
name|this
operator|.
name|singularType
operator|=
name|singularType
expr_stmt|;
name|this
operator|.
name|messageDefaultInstance
operator|=
name|messageDefaultInstance
expr_stmt|;
if|if
condition|(
name|ProtocolMessageEnum
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|singularType
argument_list|)
condition|)
block|{
name|this
operator|.
name|enumValueOf
operator|=
name|getMethodOrDie
argument_list|(
name|singularType
argument_list|,
literal|"valueOf"
argument_list|,
name|EnumValueDescriptor
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|enumGetValueDescriptor
operator|=
name|getMethodOrDie
argument_list|(
name|singularType
argument_list|,
literal|"getValueDescriptor"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|enumValueOf
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|enumGetValueDescriptor
operator|=
literal|null
expr_stmt|;
block|}
name|this
operator|.
name|extensionType
operator|=
name|extensionType
expr_stmt|;
block|}
comment|/** For use by generated code only. */
specifier|public
name|void
name|internalInit
parameter_list|(
specifier|final
name|FieldDescriptor
name|descriptor
parameter_list|)
block|{
if|if
condition|(
name|descriptorRetriever
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Already initialized."
argument_list|)
throw|;
block|}
name|descriptorRetriever
operator|=
operator|new
name|ExtensionDescriptorRetriever
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FieldDescriptor
name|getDescriptor
parameter_list|()
block|{
return|return
name|descriptor
return|;
block|}
block|}
expr_stmt|;
block|}
specifier|private
name|ExtensionDescriptorRetriever
name|descriptorRetriever
decl_stmt|;
specifier|private
specifier|final
name|Class
name|singularType
decl_stmt|;
specifier|private
specifier|final
name|Message
name|messageDefaultInstance
decl_stmt|;
specifier|private
specifier|final
name|Method
name|enumValueOf
decl_stmt|;
specifier|private
specifier|final
name|Method
name|enumGetValueDescriptor
decl_stmt|;
specifier|private
specifier|final
name|ExtensionType
name|extensionType
decl_stmt|;
annotation|@
name|Override
specifier|public
name|FieldDescriptor
name|getDescriptor
parameter_list|()
block|{
if|if
condition|(
name|descriptorRetriever
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"getDescriptor() called before internalInit()"
argument_list|)
throw|;
block|}
return|return
name|descriptorRetriever
operator|.
name|getDescriptor
argument_list|()
return|;
block|}
comment|/**      * If the extension is an embedded message or group, returns the default      * instance of the message.      */
annotation|@
name|Override
specifier|public
name|Message
name|getMessageDefaultInstance
parameter_list|()
block|{
return|return
name|messageDefaultInstance
return|;
block|}
annotation|@
name|Override
specifier|protected
name|ExtensionType
name|getExtensionType
parameter_list|()
block|{
return|return
name|extensionType
return|;
block|}
comment|/**      * Convert from the type used by the reflection accessors to the type used      * by native accessors.  E.g., for enums, the reflection accessors use      * EnumValueDescriptors but the native accessors use the generated enum      * type.      */
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|protected
name|Object
name|fromReflectionType
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
name|FieldDescriptor
name|descriptor
init|=
name|getDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
name|descriptor
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
if|if
condition|(
name|descriptor
operator|.
name|getJavaType
argument_list|()
operator|==
name|FieldDescriptor
operator|.
name|JavaType
operator|.
name|MESSAGE
operator|||
name|descriptor
operator|.
name|getJavaType
argument_list|()
operator|==
name|FieldDescriptor
operator|.
name|JavaType
operator|.
name|ENUM
condition|)
block|{
comment|// Must convert the whole list.
specifier|final
name|List
name|result
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|Object
name|element
range|:
operator|(
name|List
operator|)
name|value
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|singularFromReflectionType
argument_list|(
name|element
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
else|else
block|{
return|return
name|value
return|;
block|}
block|}
else|else
block|{
return|return
name|singularFromReflectionType
argument_list|(
name|value
argument_list|)
return|;
block|}
block|}
comment|/**      * Like {@link #fromReflectionType(Object)}, but if the type is a repeated      * type, this converts a single element.      */
annotation|@
name|Override
specifier|protected
name|Object
name|singularFromReflectionType
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
name|FieldDescriptor
name|descriptor
init|=
name|getDescriptor
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|descriptor
operator|.
name|getJavaType
argument_list|()
condition|)
block|{
case|case
name|MESSAGE
case|:
if|if
condition|(
name|singularType
operator|.
name|isInstance
argument_list|(
name|value
argument_list|)
condition|)
block|{
return|return
name|value
return|;
block|}
else|else
block|{
return|return
name|messageDefaultInstance
operator|.
name|newBuilderForType
argument_list|()
operator|.
name|mergeFrom
argument_list|(
operator|(
name|Message
operator|)
name|value
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
case|case
name|ENUM
case|:
return|return
name|invokeOrDie
argument_list|(
name|enumValueOf
argument_list|,
literal|null
argument_list|,
operator|(
name|EnumValueDescriptor
operator|)
name|value
argument_list|)
return|;
default|default:
return|return
name|value
return|;
block|}
block|}
comment|/**      * Convert from the type used by the native accessors to the type used      * by reflection accessors.  E.g., for enums, the reflection accessors use      * EnumValueDescriptors but the native accessors use the generated enum      * type.      */
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|protected
name|Object
name|toReflectionType
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
name|FieldDescriptor
name|descriptor
init|=
name|getDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
name|descriptor
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
if|if
condition|(
name|descriptor
operator|.
name|getJavaType
argument_list|()
operator|==
name|FieldDescriptor
operator|.
name|JavaType
operator|.
name|ENUM
condition|)
block|{
comment|// Must convert the whole list.
specifier|final
name|List
name|result
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|Object
name|element
range|:
operator|(
name|List
operator|)
name|value
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|singularToReflectionType
argument_list|(
name|element
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
else|else
block|{
return|return
name|value
return|;
block|}
block|}
else|else
block|{
return|return
name|singularToReflectionType
argument_list|(
name|value
argument_list|)
return|;
block|}
block|}
comment|/**      * Like {@link #toReflectionType(Object)}, but if the type is a repeated      * type, this converts a single element.      */
annotation|@
name|Override
specifier|protected
name|Object
name|singularToReflectionType
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
name|FieldDescriptor
name|descriptor
init|=
name|getDescriptor
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|descriptor
operator|.
name|getJavaType
argument_list|()
condition|)
block|{
case|case
name|ENUM
case|:
return|return
name|invokeOrDie
argument_list|(
name|enumGetValueDescriptor
argument_list|,
name|value
argument_list|)
return|;
default|default:
return|return
name|value
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|getNumber
parameter_list|()
block|{
return|return
name|getDescriptor
argument_list|()
operator|.
name|getNumber
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|WireFormat
operator|.
name|FieldType
name|getLiteType
parameter_list|()
block|{
return|return
name|getDescriptor
argument_list|()
operator|.
name|getLiteType
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isRepeated
parameter_list|()
block|{
return|return
name|getDescriptor
argument_list|()
operator|.
name|isRepeated
argument_list|()
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|Type
name|getDefaultValue
parameter_list|()
block|{
if|if
condition|(
name|isRepeated
argument_list|()
condition|)
block|{
return|return
operator|(
name|Type
operator|)
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
if|if
condition|(
name|getDescriptor
argument_list|()
operator|.
name|getJavaType
argument_list|()
operator|==
name|FieldDescriptor
operator|.
name|JavaType
operator|.
name|MESSAGE
condition|)
block|{
return|return
operator|(
name|Type
operator|)
name|messageDefaultInstance
return|;
block|}
return|return
operator|(
name|Type
operator|)
name|singularFromReflectionType
argument_list|(
name|getDescriptor
argument_list|()
operator|.
name|getDefaultValue
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|// =================================================================
comment|/** Calls Class.getMethod and throws a RuntimeException if it fails. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
specifier|static
name|Method
name|getMethodOrDie
parameter_list|(
specifier|final
name|Class
name|clazz
parameter_list|,
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|Class
modifier|...
name|params
parameter_list|)
block|{
try|try
block|{
return|return
name|clazz
operator|.
name|getMethod
argument_list|(
name|name
argument_list|,
name|params
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Generated message class \""
operator|+
name|clazz
operator|.
name|getName
argument_list|()
operator|+
literal|"\" missing method \""
operator|+
name|name
operator|+
literal|"\"."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** Calls invoke and throws a RuntimeException if it fails. */
specifier|private
specifier|static
name|Object
name|invokeOrDie
parameter_list|(
specifier|final
name|Method
name|method
parameter_list|,
specifier|final
name|Object
name|object
parameter_list|,
specifier|final
name|Object
modifier|...
name|params
parameter_list|)
block|{
try|try
block|{
return|return
name|method
operator|.
name|invoke
argument_list|(
name|object
argument_list|,
name|params
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Couldn't use Java reflection to implement protocol message "
operator|+
literal|"reflection."
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e
parameter_list|)
block|{
specifier|final
name|Throwable
name|cause
init|=
name|e
operator|.
name|getCause
argument_list|()
decl_stmt|;
if|if
condition|(
name|cause
operator|instanceof
name|RuntimeException
condition|)
block|{
throw|throw
operator|(
name|RuntimeException
operator|)
name|cause
throw|;
block|}
elseif|else
if|if
condition|(
name|cause
operator|instanceof
name|Error
condition|)
block|{
throw|throw
operator|(
name|Error
operator|)
name|cause
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected exception thrown by generated accessor method."
argument_list|,
name|cause
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Gets the map field with the given field number. This method should be    * overridden in the generated message class if the message contains map    * fields.    *    * Unlike other field types, reflection support for map fields can't be    * implemented based on generated public API because we need to access a    * map field as a list in reflection API but the generated API only allows    * us to access it as a map. This method returns the underlying map field    * directly and thus enables us to access the map field as a list.    */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unused"
block|}
argument_list|)
specifier|protected
name|MapField
name|internalGetMapField
parameter_list|(
name|int
name|fieldNumber
parameter_list|)
block|{
comment|// Note that we can't use descriptor names here because this method will
comment|// be called when descriptor is being initialized.
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"No map fields found in "
operator|+
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
comment|/**    * Users should ignore this class.  This class provides the implementation    * with access to the fields of a message object using Java reflection.    */
specifier|public
specifier|static
specifier|final
class|class
name|FieldAccessorTable
block|{
comment|/**      * Construct a FieldAccessorTable for a particular message class.  Only      * one FieldAccessorTable should ever be constructed per class.      *      * @param descriptor     The type's descriptor.      * @param camelCaseNames The camelcase names of all fields in the message.      *                       These are used to derive the accessor method names.      * @param messageClass   The message type.      * @param builderClass   The builder type.      */
specifier|public
name|FieldAccessorTable
parameter_list|(
specifier|final
name|Descriptor
name|descriptor
parameter_list|,
specifier|final
name|String
index|[]
name|camelCaseNames
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|GeneratedMessage
argument_list|>
name|messageClass
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|Builder
argument_list|>
name|builderClass
parameter_list|)
block|{
name|this
argument_list|(
name|descriptor
argument_list|,
name|camelCaseNames
argument_list|)
expr_stmt|;
name|ensureFieldAccessorsInitialized
argument_list|(
name|messageClass
argument_list|,
name|builderClass
argument_list|)
expr_stmt|;
block|}
comment|/**      * Construct a FieldAccessorTable for a particular message class without      * initializing FieldAccessors.      */
specifier|public
name|FieldAccessorTable
parameter_list|(
specifier|final
name|Descriptor
name|descriptor
parameter_list|,
specifier|final
name|String
index|[]
name|camelCaseNames
parameter_list|)
block|{
name|this
operator|.
name|descriptor
operator|=
name|descriptor
expr_stmt|;
name|this
operator|.
name|camelCaseNames
operator|=
name|camelCaseNames
expr_stmt|;
name|fields
operator|=
operator|new
name|FieldAccessor
index|[
name|descriptor
operator|.
name|getFields
argument_list|()
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|oneofs
operator|=
operator|new
name|OneofAccessor
index|[
name|descriptor
operator|.
name|getOneofs
argument_list|()
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|initialized
operator|=
literal|false
expr_stmt|;
block|}
specifier|private
name|boolean
name|isMapFieldEnabled
parameter_list|(
name|FieldDescriptor
name|field
parameter_list|)
block|{
name|boolean
name|result
init|=
literal|true
decl_stmt|;
return|return
name|result
return|;
block|}
comment|/**      * Ensures the field accessors are initialized. This method is thread-safe.      *      * @param messageClass   The message type.      * @param builderClass   The builder type.      * @return this      */
specifier|public
name|FieldAccessorTable
name|ensureFieldAccessorsInitialized
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|GeneratedMessage
argument_list|>
name|messageClass
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Builder
argument_list|>
name|builderClass
parameter_list|)
block|{
if|if
condition|(
name|initialized
condition|)
block|{
return|return
name|this
return|;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|initialized
condition|)
block|{
return|return
name|this
return|;
block|}
name|int
name|fieldsSize
init|=
name|fields
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldsSize
condition|;
name|i
operator|++
control|)
block|{
name|FieldDescriptor
name|field
init|=
name|descriptor
operator|.
name|getFields
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|containingOneofCamelCaseName
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|getContainingOneof
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|containingOneofCamelCaseName
operator|=
name|camelCaseNames
index|[
name|fieldsSize
operator|+
name|field
operator|.
name|getContainingOneof
argument_list|()
operator|.
name|getIndex
argument_list|()
index|]
expr_stmt|;
block|}
if|if
condition|(
name|field
operator|.
name|isRepeated
argument_list|()
condition|)
block|{
if|if
condition|(
name|field
operator|.
name|getJavaType
argument_list|()
operator|==
name|FieldDescriptor
operator|.
name|JavaType
operator|.
name|MESSAGE
condition|)
block|{
if|if
condition|(
name|field
operator|.
name|isMapField
argument_list|()
operator|&&
name|isMapFieldEnabled
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|fields
index|[
name|i
index|]
operator|=
operator|new
name|MapFieldAccessor
argument_list|(
name|field
argument_list|,
name|camelCaseNames
index|[
name|i
index|]
argument_list|,
name|messageClass
argument_list|,
name|builderClass
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fields
index|[
name|i
index|]
operator|=
operator|new
name|RepeatedMessageFieldAccessor
argument_list|(
name|field
argument_list|,
name|camelCaseNames
index|[
name|i
index|]
argument_list|,
name|messageClass
argument_list|,
name|builderClass
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|getJavaType
argument_list|()
operator|==
name|FieldDescriptor
operator|.
name|JavaType
operator|.
name|ENUM
condition|)
block|{
name|fields
index|[
name|i
index|]
operator|=
operator|new
name|RepeatedEnumFieldAccessor
argument_list|(
name|field
argument_list|,
name|camelCaseNames
index|[
name|i
index|]
argument_list|,
name|messageClass
argument_list|,
name|builderClass
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fields
index|[
name|i
index|]
operator|=
operator|new
name|RepeatedFieldAccessor
argument_list|(
name|field
argument_list|,
name|camelCaseNames
index|[
name|i
index|]
argument_list|,
name|messageClass
argument_list|,
name|builderClass
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|field
operator|.
name|getJavaType
argument_list|()
operator|==
name|FieldDescriptor
operator|.
name|JavaType
operator|.
name|MESSAGE
condition|)
block|{
name|fields
index|[
name|i
index|]
operator|=
operator|new
name|SingularMessageFieldAccessor
argument_list|(
name|field
argument_list|,
name|camelCaseNames
index|[
name|i
index|]
argument_list|,
name|messageClass
argument_list|,
name|builderClass
argument_list|,
name|containingOneofCamelCaseName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|getJavaType
argument_list|()
operator|==
name|FieldDescriptor
operator|.
name|JavaType
operator|.
name|ENUM
condition|)
block|{
name|fields
index|[
name|i
index|]
operator|=
operator|new
name|SingularEnumFieldAccessor
argument_list|(
name|field
argument_list|,
name|camelCaseNames
index|[
name|i
index|]
argument_list|,
name|messageClass
argument_list|,
name|builderClass
argument_list|,
name|containingOneofCamelCaseName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|getJavaType
argument_list|()
operator|==
name|FieldDescriptor
operator|.
name|JavaType
operator|.
name|STRING
condition|)
block|{
name|fields
index|[
name|i
index|]
operator|=
operator|new
name|SingularStringFieldAccessor
argument_list|(
name|field
argument_list|,
name|camelCaseNames
index|[
name|i
index|]
argument_list|,
name|messageClass
argument_list|,
name|builderClass
argument_list|,
name|containingOneofCamelCaseName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fields
index|[
name|i
index|]
operator|=
operator|new
name|SingularFieldAccessor
argument_list|(
name|field
argument_list|,
name|camelCaseNames
index|[
name|i
index|]
argument_list|,
name|messageClass
argument_list|,
name|builderClass
argument_list|,
name|containingOneofCamelCaseName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|int
name|oneofsSize
init|=
name|oneofs
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|oneofsSize
condition|;
name|i
operator|++
control|)
block|{
name|oneofs
index|[
name|i
index|]
operator|=
operator|new
name|OneofAccessor
argument_list|(
name|descriptor
argument_list|,
name|camelCaseNames
index|[
name|i
operator|+
name|fieldsSize
index|]
argument_list|,
name|messageClass
argument_list|,
name|builderClass
argument_list|)
expr_stmt|;
block|}
name|initialized
operator|=
literal|true
expr_stmt|;
name|camelCaseNames
operator|=
literal|null
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
specifier|private
specifier|final
name|Descriptor
name|descriptor
decl_stmt|;
specifier|private
specifier|final
name|FieldAccessor
index|[]
name|fields
decl_stmt|;
specifier|private
name|String
index|[]
name|camelCaseNames
decl_stmt|;
specifier|private
specifier|final
name|OneofAccessor
index|[]
name|oneofs
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|initialized
decl_stmt|;
comment|/** Get the FieldAccessor for a particular field. */
specifier|private
name|FieldAccessor
name|getField
parameter_list|(
specifier|final
name|FieldDescriptor
name|field
parameter_list|)
block|{
if|if
condition|(
name|field
operator|.
name|getContainingType
argument_list|()
operator|!=
name|descriptor
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"FieldDescriptor does not match message type."
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|isExtension
argument_list|()
condition|)
block|{
comment|// If this type had extensions, it would subclass ExtendableMessage,
comment|// which overrides the reflection interface to handle extensions.
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"This type does not have extensions."
argument_list|)
throw|;
block|}
return|return
name|fields
index|[
name|field
operator|.
name|getIndex
argument_list|()
index|]
return|;
block|}
comment|/** Get the OneofAccessor for a particular oneof. */
specifier|private
name|OneofAccessor
name|getOneof
parameter_list|(
specifier|final
name|OneofDescriptor
name|oneof
parameter_list|)
block|{
if|if
condition|(
name|oneof
operator|.
name|getContainingType
argument_list|()
operator|!=
name|descriptor
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"OneofDescriptor does not match message type."
argument_list|)
throw|;
block|}
return|return
name|oneofs
index|[
name|oneof
operator|.
name|getIndex
argument_list|()
index|]
return|;
block|}
comment|/**      * Abstract interface that provides access to a single field.  This is      * implemented differently depending on the field type and cardinality.      */
specifier|private
interface|interface
name|FieldAccessor
block|{
name|Object
name|get
parameter_list|(
name|GeneratedMessage
name|message
parameter_list|)
function_decl|;
name|Object
name|get
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|)
function_decl|;
name|Object
name|getRaw
parameter_list|(
name|GeneratedMessage
name|message
parameter_list|)
function_decl|;
name|Object
name|getRaw
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|)
function_decl|;
name|void
name|set
parameter_list|(
name|Builder
name|builder
parameter_list|,
name|Object
name|value
parameter_list|)
function_decl|;
name|Object
name|getRepeated
parameter_list|(
name|GeneratedMessage
name|message
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
name|Object
name|getRepeated
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
name|Object
name|getRepeatedRaw
parameter_list|(
name|GeneratedMessage
name|message
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
name|Object
name|getRepeatedRaw
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
name|void
name|setRepeated
parameter_list|(
name|Builder
name|builder
parameter_list|,
name|int
name|index
parameter_list|,
name|Object
name|value
parameter_list|)
function_decl|;
name|void
name|addRepeated
parameter_list|(
name|Builder
name|builder
parameter_list|,
name|Object
name|value
parameter_list|)
function_decl|;
name|boolean
name|has
parameter_list|(
name|GeneratedMessage
name|message
parameter_list|)
function_decl|;
name|boolean
name|has
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|)
function_decl|;
name|int
name|getRepeatedCount
parameter_list|(
name|GeneratedMessage
name|message
parameter_list|)
function_decl|;
name|int
name|getRepeatedCount
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|)
function_decl|;
name|void
name|clear
parameter_list|(
name|Builder
name|builder
parameter_list|)
function_decl|;
name|Message
operator|.
name|Builder
name|newBuilder
parameter_list|()
function_decl|;
name|Message
operator|.
name|Builder
name|getBuilder
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|)
function_decl|;
name|Message
operator|.
name|Builder
name|getRepeatedBuilder
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
block|}
comment|/** OneofAccessor provides access to a single oneof. */
specifier|private
specifier|static
class|class
name|OneofAccessor
block|{
name|OneofAccessor
parameter_list|(
specifier|final
name|Descriptor
name|descriptor
parameter_list|,
specifier|final
name|String
name|camelCaseName
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|GeneratedMessage
argument_list|>
name|messageClass
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|Builder
argument_list|>
name|builderClass
parameter_list|)
block|{
name|this
operator|.
name|descriptor
operator|=
name|descriptor
expr_stmt|;
name|caseMethod
operator|=
name|getMethodOrDie
argument_list|(
name|messageClass
argument_list|,
literal|"get"
operator|+
name|camelCaseName
operator|+
literal|"Case"
argument_list|)
expr_stmt|;
name|caseMethodBuilder
operator|=
name|getMethodOrDie
argument_list|(
name|builderClass
argument_list|,
literal|"get"
operator|+
name|camelCaseName
operator|+
literal|"Case"
argument_list|)
expr_stmt|;
name|clearMethod
operator|=
name|getMethodOrDie
argument_list|(
name|builderClass
argument_list|,
literal|"clear"
operator|+
name|camelCaseName
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|final
name|Descriptor
name|descriptor
decl_stmt|;
specifier|private
specifier|final
name|Method
name|caseMethod
decl_stmt|;
specifier|private
specifier|final
name|Method
name|caseMethodBuilder
decl_stmt|;
specifier|private
specifier|final
name|Method
name|clearMethod
decl_stmt|;
specifier|public
name|boolean
name|has
parameter_list|(
specifier|final
name|GeneratedMessage
name|message
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|Internal
operator|.
name|EnumLite
operator|)
name|invokeOrDie
argument_list|(
name|caseMethod
argument_list|,
name|message
argument_list|)
operator|)
operator|.
name|getNumber
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|has
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|Internal
operator|.
name|EnumLite
operator|)
name|invokeOrDie
argument_list|(
name|caseMethodBuilder
argument_list|,
name|builder
argument_list|)
operator|)
operator|.
name|getNumber
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|FieldDescriptor
name|get
parameter_list|(
specifier|final
name|GeneratedMessage
name|message
parameter_list|)
block|{
name|int
name|fieldNumber
init|=
operator|(
operator|(
name|Internal
operator|.
name|EnumLite
operator|)
name|invokeOrDie
argument_list|(
name|caseMethod
argument_list|,
name|message
argument_list|)
operator|)
operator|.
name|getNumber
argument_list|()
decl_stmt|;
if|if
condition|(
name|fieldNumber
operator|>
literal|0
condition|)
block|{
return|return
name|descriptor
operator|.
name|findFieldByNumber
argument_list|(
name|fieldNumber
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|FieldDescriptor
name|get
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|)
block|{
name|int
name|fieldNumber
init|=
operator|(
operator|(
name|Internal
operator|.
name|EnumLite
operator|)
name|invokeOrDie
argument_list|(
name|caseMethodBuilder
argument_list|,
name|builder
argument_list|)
operator|)
operator|.
name|getNumber
argument_list|()
decl_stmt|;
if|if
condition|(
name|fieldNumber
operator|>
literal|0
condition|)
block|{
return|return
name|descriptor
operator|.
name|findFieldByNumber
argument_list|(
name|fieldNumber
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|void
name|clear
parameter_list|(
specifier|final
name|Builder
name|builder
parameter_list|)
block|{
name|invokeOrDie
argument_list|(
name|clearMethod
argument_list|,
name|builder
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|boolean
name|supportFieldPresence
parameter_list|(
name|FileDescriptor
name|file
parameter_list|)
block|{
return|return
name|file
operator|.
name|getSyntax
argument_list|()
operator|==
name|FileDescriptor
operator|.
name|Syntax
operator|.
name|PROTO2
return|;
block|}
comment|// ---------------------------------------------------------------
specifier|private
specifier|static
class|class
name|SingularFieldAccessor
implements|implements
name|FieldAccessor
block|{
name|SingularFieldAccessor
parameter_list|(
specifier|final
name|FieldDescriptor
name|descriptor
parameter_list|,
specifier|final
name|String
name|camelCaseName
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|GeneratedMessage
argument_list|>
name|messageClass
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|Builder
argument_list|>
name|builderClass
parameter_list|,
specifier|final
name|String
name|containingOneofCamelCaseName
parameter_list|)
block|{
name|field
operator|=
name|descriptor
expr_stmt|;
name|isOneofField
operator|=
name|descriptor
operator|.
name|getContainingOneof
argument_list|()
operator|!=
literal|null
expr_stmt|;
name|hasHasMethod
operator|=
name|supportFieldPresence
argument_list|(
name|descriptor
operator|.
name|getFile
argument_list|()
argument_list|)
operator|||
operator|(
operator|!
name|isOneofField
operator|&&
name|descriptor
operator|.
name|getJavaType
argument_list|()
operator|==
name|FieldDescriptor
operator|.
name|JavaType
operator|.
name|MESSAGE
operator|)
expr_stmt|;
name|getMethod
operator|=
name|getMethodOrDie
argument_list|(
name|messageClass
argument_list|,
literal|"get"
operator|+
name|camelCaseName
argument_list|)
expr_stmt|;
name|getMethodBuilder
operator|=
name|getMethodOrDie
argument_list|(
name|builderClass
argument_list|,
literal|"get"
operator|+
name|camelCaseName
argument_list|)
expr_stmt|;
name|type
operator|=
name|getMethod
operator|.
name|getReturnType
argument_list|()
expr_stmt|;
name|setMethod
operator|=
name|getMethodOrDie
argument_list|(
name|builderClass
argument_list|,
literal|"set"
operator|+
name|camelCaseName
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|hasMethod
operator|=
name|hasHasMethod
condition|?
name|getMethodOrDie
argument_list|(
name|messageClass
argument_list|,
literal|"has"
operator|+
name|camelCaseName
argument_list|)
else|:
literal|null
expr_stmt|;
name|hasMethodBuilder
operator|=
name|hasHasMethod
condition|?
name|getMethodOrDie
argument_list|(
name|builderClass
argument_list|,
literal|"has"
operator|+
name|camelCaseName
argument_list|)
else|:
literal|null
expr_stmt|;
name|clearMethod
operator|=
name|getMethodOrDie
argument_list|(
name|builderClass
argument_list|,
literal|"clear"
operator|+
name|camelCaseName
argument_list|)
expr_stmt|;
name|caseMethod
operator|=
name|isOneofField
condition|?
name|getMethodOrDie
argument_list|(
name|messageClass
argument_list|,
literal|"get"
operator|+
name|containingOneofCamelCaseName
operator|+
literal|"Case"
argument_list|)
else|:
literal|null
expr_stmt|;
name|caseMethodBuilder
operator|=
name|isOneofField
condition|?
name|getMethodOrDie
argument_list|(
name|builderClass
argument_list|,
literal|"get"
operator|+
name|containingOneofCamelCaseName
operator|+
literal|"Case"
argument_list|)
else|:
literal|null
expr_stmt|;
block|}
comment|// Note:  We use Java reflection to call public methods rather than
comment|//   access private fields directly as this avoids runtime security
comment|//   checks.
specifier|protected
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|type
decl_stmt|;
specifier|protected
specifier|final
name|Method
name|getMethod
decl_stmt|;
specifier|protected
specifier|final
name|Method
name|getMethodBuilder
decl_stmt|;
specifier|protected
specifier|final
name|Method
name|setMethod
decl_stmt|;
specifier|protected
specifier|final
name|Method
name|hasMethod
decl_stmt|;
specifier|protected
specifier|final
name|Method
name|hasMethodBuilder
decl_stmt|;
specifier|protected
specifier|final
name|Method
name|clearMethod
decl_stmt|;
specifier|protected
specifier|final
name|Method
name|caseMethod
decl_stmt|;
specifier|protected
specifier|final
name|Method
name|caseMethodBuilder
decl_stmt|;
specifier|protected
specifier|final
name|FieldDescriptor
name|field
decl_stmt|;
specifier|protected
specifier|final
name|boolean
name|isOneofField
decl_stmt|;
specifier|protected
specifier|final
name|boolean
name|hasHasMethod
decl_stmt|;
specifier|private
name|int
name|getOneofFieldNumber
parameter_list|(
specifier|final
name|GeneratedMessage
name|message
parameter_list|)
block|{
return|return
operator|(
operator|(
name|Internal
operator|.
name|EnumLite
operator|)
name|invokeOrDie
argument_list|(
name|caseMethod
argument_list|,
name|message
argument_list|)
operator|)
operator|.
name|getNumber
argument_list|()
return|;
block|}
specifier|private
name|int
name|getOneofFieldNumber
parameter_list|(
specifier|final
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|)
block|{
return|return
operator|(
operator|(
name|Internal
operator|.
name|EnumLite
operator|)
name|invokeOrDie
argument_list|(
name|caseMethodBuilder
argument_list|,
name|builder
argument_list|)
operator|)
operator|.
name|getNumber
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|get
parameter_list|(
specifier|final
name|GeneratedMessage
name|message
parameter_list|)
block|{
return|return
name|invokeOrDie
argument_list|(
name|getMethod
argument_list|,
name|message
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|get
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|)
block|{
return|return
name|invokeOrDie
argument_list|(
name|getMethodBuilder
argument_list|,
name|builder
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getRaw
parameter_list|(
specifier|final
name|GeneratedMessage
name|message
parameter_list|)
block|{
return|return
name|get
argument_list|(
name|message
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getRaw
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|)
block|{
return|return
name|get
argument_list|(
name|builder
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|set
parameter_list|(
specifier|final
name|Builder
name|builder
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
block|{
name|invokeOrDie
argument_list|(
name|setMethod
argument_list|,
name|builder
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getRepeated
parameter_list|(
specifier|final
name|GeneratedMessage
name|message
parameter_list|,
specifier|final
name|int
name|index
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"getRepeatedField() called on a singular field."
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getRepeatedRaw
parameter_list|(
specifier|final
name|GeneratedMessage
name|message
parameter_list|,
specifier|final
name|int
name|index
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"getRepeatedFieldRaw() called on a singular field."
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getRepeated
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|,
name|int
name|index
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"getRepeatedField() called on a singular field."
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getRepeatedRaw
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|,
name|int
name|index
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"getRepeatedFieldRaw() called on a singular field."
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setRepeated
parameter_list|(
specifier|final
name|Builder
name|builder
parameter_list|,
specifier|final
name|int
name|index
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"setRepeatedField() called on a singular field."
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addRepeated
parameter_list|(
specifier|final
name|Builder
name|builder
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"addRepeatedField() called on a singular field."
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|has
parameter_list|(
specifier|final
name|GeneratedMessage
name|message
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasHasMethod
condition|)
block|{
if|if
condition|(
name|isOneofField
condition|)
block|{
return|return
name|getOneofFieldNumber
argument_list|(
name|message
argument_list|)
operator|==
name|field
operator|.
name|getNumber
argument_list|()
return|;
block|}
return|return
operator|!
name|get
argument_list|(
name|message
argument_list|)
operator|.
name|equals
argument_list|(
name|field
operator|.
name|getDefaultValue
argument_list|()
argument_list|)
return|;
block|}
return|return
operator|(
name|Boolean
operator|)
name|invokeOrDie
argument_list|(
name|hasMethod
argument_list|,
name|message
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|has
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasHasMethod
condition|)
block|{
if|if
condition|(
name|isOneofField
condition|)
block|{
return|return
name|getOneofFieldNumber
argument_list|(
name|builder
argument_list|)
operator|==
name|field
operator|.
name|getNumber
argument_list|()
return|;
block|}
return|return
operator|!
name|get
argument_list|(
name|builder
argument_list|)
operator|.
name|equals
argument_list|(
name|field
operator|.
name|getDefaultValue
argument_list|()
argument_list|)
return|;
block|}
return|return
operator|(
name|Boolean
operator|)
name|invokeOrDie
argument_list|(
name|hasMethodBuilder
argument_list|,
name|builder
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getRepeatedCount
parameter_list|(
specifier|final
name|GeneratedMessage
name|message
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"getRepeatedFieldSize() called on a singular field."
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getRepeatedCount
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"getRepeatedFieldSize() called on a singular field."
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|(
specifier|final
name|Builder
name|builder
parameter_list|)
block|{
name|invokeOrDie
argument_list|(
name|clearMethod
argument_list|,
name|builder
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Message
operator|.
name|Builder
name|newBuilder
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"newBuilderForField() called on a non-Message type."
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|Message
operator|.
name|Builder
name|getBuilder
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"getFieldBuilder() called on a non-Message type."
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|Message
operator|.
name|Builder
name|getRepeatedBuilder
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|,
name|int
name|index
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"getRepeatedFieldBuilder() called on a non-Message type."
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
class|class
name|RepeatedFieldAccessor
implements|implements
name|FieldAccessor
block|{
specifier|protected
specifier|final
name|Class
name|type
decl_stmt|;
specifier|protected
specifier|final
name|Method
name|getMethod
decl_stmt|;
specifier|protected
specifier|final
name|Method
name|getMethodBuilder
decl_stmt|;
specifier|protected
specifier|final
name|Method
name|getRepeatedMethod
decl_stmt|;
specifier|protected
specifier|final
name|Method
name|getRepeatedMethodBuilder
decl_stmt|;
specifier|protected
specifier|final
name|Method
name|setRepeatedMethod
decl_stmt|;
specifier|protected
specifier|final
name|Method
name|addRepeatedMethod
decl_stmt|;
specifier|protected
specifier|final
name|Method
name|getCountMethod
decl_stmt|;
specifier|protected
specifier|final
name|Method
name|getCountMethodBuilder
decl_stmt|;
specifier|protected
specifier|final
name|Method
name|clearMethod
decl_stmt|;
name|RepeatedFieldAccessor
parameter_list|(
specifier|final
name|FieldDescriptor
name|descriptor
parameter_list|,
specifier|final
name|String
name|camelCaseName
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|GeneratedMessage
argument_list|>
name|messageClass
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|Builder
argument_list|>
name|builderClass
parameter_list|)
block|{
name|getMethod
operator|=
name|getMethodOrDie
argument_list|(
name|messageClass
argument_list|,
literal|"get"
operator|+
name|camelCaseName
operator|+
literal|"List"
argument_list|)
expr_stmt|;
name|getMethodBuilder
operator|=
name|getMethodOrDie
argument_list|(
name|builderClass
argument_list|,
literal|"get"
operator|+
name|camelCaseName
operator|+
literal|"List"
argument_list|)
expr_stmt|;
name|getRepeatedMethod
operator|=
name|getMethodOrDie
argument_list|(
name|messageClass
argument_list|,
literal|"get"
operator|+
name|camelCaseName
argument_list|,
name|Integer
operator|.
name|TYPE
argument_list|)
expr_stmt|;
name|getRepeatedMethodBuilder
operator|=
name|getMethodOrDie
argument_list|(
name|builderClass
argument_list|,
literal|"get"
operator|+
name|camelCaseName
argument_list|,
name|Integer
operator|.
name|TYPE
argument_list|)
expr_stmt|;
name|type
operator|=
name|getRepeatedMethod
operator|.
name|getReturnType
argument_list|()
expr_stmt|;
name|setRepeatedMethod
operator|=
name|getMethodOrDie
argument_list|(
name|builderClass
argument_list|,
literal|"set"
operator|+
name|camelCaseName
argument_list|,
name|Integer
operator|.
name|TYPE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|addRepeatedMethod
operator|=
name|getMethodOrDie
argument_list|(
name|builderClass
argument_list|,
literal|"add"
operator|+
name|camelCaseName
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|getCountMethod
operator|=
name|getMethodOrDie
argument_list|(
name|messageClass
argument_list|,
literal|"get"
operator|+
name|camelCaseName
operator|+
literal|"Count"
argument_list|)
expr_stmt|;
name|getCountMethodBuilder
operator|=
name|getMethodOrDie
argument_list|(
name|builderClass
argument_list|,
literal|"get"
operator|+
name|camelCaseName
operator|+
literal|"Count"
argument_list|)
expr_stmt|;
name|clearMethod
operator|=
name|getMethodOrDie
argument_list|(
name|builderClass
argument_list|,
literal|"clear"
operator|+
name|camelCaseName
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|get
parameter_list|(
specifier|final
name|GeneratedMessage
name|message
parameter_list|)
block|{
return|return
name|invokeOrDie
argument_list|(
name|getMethod
argument_list|,
name|message
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|get
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|)
block|{
return|return
name|invokeOrDie
argument_list|(
name|getMethodBuilder
argument_list|,
name|builder
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getRaw
parameter_list|(
specifier|final
name|GeneratedMessage
name|message
parameter_list|)
block|{
return|return
name|get
argument_list|(
name|message
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getRaw
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|)
block|{
return|return
name|get
argument_list|(
name|builder
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|set
parameter_list|(
specifier|final
name|Builder
name|builder
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
block|{
comment|// Add all the elements individually.  This serves two purposes:
comment|// 1) Verifies that each element has the correct type.
comment|// 2) Insures that the caller cannot modify the list later on and
comment|//    have the modifications be reflected in the message.
name|clear
argument_list|(
name|builder
argument_list|)
expr_stmt|;
for|for
control|(
specifier|final
name|Object
name|element
range|:
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|value
control|)
block|{
name|addRepeated
argument_list|(
name|builder
argument_list|,
name|element
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getRepeated
parameter_list|(
specifier|final
name|GeneratedMessage
name|message
parameter_list|,
specifier|final
name|int
name|index
parameter_list|)
block|{
return|return
name|invokeOrDie
argument_list|(
name|getRepeatedMethod
argument_list|,
name|message
argument_list|,
name|index
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getRepeated
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|,
name|int
name|index
parameter_list|)
block|{
return|return
name|invokeOrDie
argument_list|(
name|getRepeatedMethodBuilder
argument_list|,
name|builder
argument_list|,
name|index
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getRepeatedRaw
parameter_list|(
name|GeneratedMessage
name|message
parameter_list|,
name|int
name|index
parameter_list|)
block|{
return|return
name|getRepeated
argument_list|(
name|message
argument_list|,
name|index
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getRepeatedRaw
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|,
name|int
name|index
parameter_list|)
block|{
return|return
name|getRepeated
argument_list|(
name|builder
argument_list|,
name|index
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setRepeated
parameter_list|(
specifier|final
name|Builder
name|builder
parameter_list|,
specifier|final
name|int
name|index
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
block|{
name|invokeOrDie
argument_list|(
name|setRepeatedMethod
argument_list|,
name|builder
argument_list|,
name|index
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addRepeated
parameter_list|(
specifier|final
name|Builder
name|builder
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
block|{
name|invokeOrDie
argument_list|(
name|addRepeatedMethod
argument_list|,
name|builder
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|has
parameter_list|(
specifier|final
name|GeneratedMessage
name|message
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"hasField() called on a repeated field."
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|has
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"hasField() called on a repeated field."
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getRepeatedCount
parameter_list|(
specifier|final
name|GeneratedMessage
name|message
parameter_list|)
block|{
return|return
operator|(
name|Integer
operator|)
name|invokeOrDie
argument_list|(
name|getCountMethod
argument_list|,
name|message
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getRepeatedCount
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|)
block|{
return|return
operator|(
name|Integer
operator|)
name|invokeOrDie
argument_list|(
name|getCountMethodBuilder
argument_list|,
name|builder
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|(
specifier|final
name|Builder
name|builder
parameter_list|)
block|{
name|invokeOrDie
argument_list|(
name|clearMethod
argument_list|,
name|builder
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Message
operator|.
name|Builder
name|newBuilder
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"newBuilderForField() called on a non-Message type."
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|Message
operator|.
name|Builder
name|getBuilder
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"getFieldBuilder() called on a non-Message type."
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|Message
operator|.
name|Builder
name|getRepeatedBuilder
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|,
name|int
name|index
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"getRepeatedFieldBuilder() called on a non-Message type."
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
class|class
name|MapFieldAccessor
implements|implements
name|FieldAccessor
block|{
name|MapFieldAccessor
parameter_list|(
specifier|final
name|FieldDescriptor
name|descriptor
parameter_list|,
specifier|final
name|String
name|camelCaseName
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|GeneratedMessage
argument_list|>
name|messageClass
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|Builder
argument_list|>
name|builderClass
parameter_list|)
block|{
name|field
operator|=
name|descriptor
expr_stmt|;
name|Method
name|getDefaultInstanceMethod
init|=
name|getMethodOrDie
argument_list|(
name|messageClass
argument_list|,
literal|"getDefaultInstance"
argument_list|)
decl_stmt|;
name|MapField
name|defaultMapField
init|=
name|getMapField
argument_list|(
operator|(
name|GeneratedMessage
operator|)
name|invokeOrDie
argument_list|(
name|getDefaultInstanceMethod
argument_list|,
literal|null
argument_list|)
argument_list|)
decl_stmt|;
name|mapEntryMessageDefaultInstance
operator|=
name|defaultMapField
operator|.
name|getMapEntryMessageDefaultInstance
argument_list|()
expr_stmt|;
block|}
specifier|private
specifier|final
name|FieldDescriptor
name|field
decl_stmt|;
specifier|private
specifier|final
name|Message
name|mapEntryMessageDefaultInstance
decl_stmt|;
specifier|private
name|MapField
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|getMapField
parameter_list|(
name|GeneratedMessage
name|message
parameter_list|)
block|{
return|return
operator|(
name|MapField
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|message
operator|.
name|internalGetMapField
argument_list|(
name|field
operator|.
name|getNumber
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|MapField
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|getMapField
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|)
block|{
return|return
operator|(
name|MapField
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|builder
operator|.
name|internalGetMapField
argument_list|(
name|field
operator|.
name|getNumber
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|MapField
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|getMutableMapField
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|)
block|{
return|return
operator|(
name|MapField
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|builder
operator|.
name|internalGetMutableMapField
argument_list|(
name|field
operator|.
name|getNumber
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|get
parameter_list|(
name|GeneratedMessage
name|message
parameter_list|)
block|{
name|List
name|result
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|getRepeatedCount
argument_list|(
name|message
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|getRepeated
argument_list|(
name|message
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|result
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|get
parameter_list|(
name|Builder
name|builder
parameter_list|)
block|{
name|List
name|result
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|getRepeatedCount
argument_list|(
name|builder
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|getRepeated
argument_list|(
name|builder
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|result
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getRaw
parameter_list|(
name|GeneratedMessage
name|message
parameter_list|)
block|{
return|return
name|get
argument_list|(
name|message
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getRaw
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|)
block|{
return|return
name|get
argument_list|(
name|builder
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|set
parameter_list|(
name|Builder
name|builder
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|clear
argument_list|(
name|builder
argument_list|)
expr_stmt|;
for|for
control|(
name|Object
name|entry
range|:
operator|(
name|List
operator|)
name|value
control|)
block|{
name|addRepeated
argument_list|(
name|builder
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getRepeated
parameter_list|(
name|GeneratedMessage
name|message
parameter_list|,
name|int
name|index
parameter_list|)
block|{
return|return
name|getMapField
argument_list|(
name|message
argument_list|)
operator|.
name|getList
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getRepeated
parameter_list|(
name|Builder
name|builder
parameter_list|,
name|int
name|index
parameter_list|)
block|{
return|return
name|getMapField
argument_list|(
name|builder
argument_list|)
operator|.
name|getList
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getRepeatedRaw
parameter_list|(
name|GeneratedMessage
name|message
parameter_list|,
name|int
name|index
parameter_list|)
block|{
return|return
name|getRepeated
argument_list|(
name|message
argument_list|,
name|index
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getRepeatedRaw
parameter_list|(
name|Builder
name|builder
parameter_list|,
name|int
name|index
parameter_list|)
block|{
return|return
name|getRepeated
argument_list|(
name|builder
argument_list|,
name|index
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setRepeated
parameter_list|(
name|Builder
name|builder
parameter_list|,
name|int
name|index
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|getMutableMapField
argument_list|(
name|builder
argument_list|)
operator|.
name|getMutableList
argument_list|()
operator|.
name|set
argument_list|(
name|index
argument_list|,
operator|(
name|Message
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addRepeated
parameter_list|(
name|Builder
name|builder
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|getMutableMapField
argument_list|(
name|builder
argument_list|)
operator|.
name|getMutableList
argument_list|()
operator|.
name|add
argument_list|(
operator|(
name|Message
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|has
parameter_list|(
name|GeneratedMessage
name|message
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"hasField() is not supported for repeated fields."
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|has
parameter_list|(
name|Builder
name|builder
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"hasField() is not supported for repeated fields."
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getRepeatedCount
parameter_list|(
name|GeneratedMessage
name|message
parameter_list|)
block|{
return|return
name|getMapField
argument_list|(
name|message
argument_list|)
operator|.
name|getList
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getRepeatedCount
parameter_list|(
name|Builder
name|builder
parameter_list|)
block|{
return|return
name|getMapField
argument_list|(
name|builder
argument_list|)
operator|.
name|getList
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|(
name|Builder
name|builder
parameter_list|)
block|{
name|getMutableMapField
argument_list|(
name|builder
argument_list|)
operator|.
name|getMutableList
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Message
operator|.
name|Builder
name|newBuilder
parameter_list|()
block|{
return|return
name|mapEntryMessageDefaultInstance
operator|.
name|newBuilderForType
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Message
operator|.
name|Builder
name|getBuilder
parameter_list|(
name|Builder
name|builder
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Nested builder not supported for map fields."
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Message
operator|.
name|Builder
name|getRepeatedBuilder
parameter_list|(
name|Builder
name|builder
parameter_list|,
name|int
name|index
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Nested builder not supported for map fields."
argument_list|)
throw|;
block|}
block|}
comment|// ---------------------------------------------------------------
specifier|private
specifier|static
specifier|final
class|class
name|SingularEnumFieldAccessor
extends|extends
name|SingularFieldAccessor
block|{
name|SingularEnumFieldAccessor
parameter_list|(
specifier|final
name|FieldDescriptor
name|descriptor
parameter_list|,
specifier|final
name|String
name|camelCaseName
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|GeneratedMessage
argument_list|>
name|messageClass
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|Builder
argument_list|>
name|builderClass
parameter_list|,
specifier|final
name|String
name|containingOneofCamelCaseName
parameter_list|)
block|{
name|super
argument_list|(
name|descriptor
argument_list|,
name|camelCaseName
argument_list|,
name|messageClass
argument_list|,
name|builderClass
argument_list|,
name|containingOneofCamelCaseName
argument_list|)
expr_stmt|;
name|enumDescriptor
operator|=
name|descriptor
operator|.
name|getEnumType
argument_list|()
expr_stmt|;
name|valueOfMethod
operator|=
name|getMethodOrDie
argument_list|(
name|type
argument_list|,
literal|"valueOf"
argument_list|,
name|EnumValueDescriptor
operator|.
name|class
argument_list|)
expr_stmt|;
name|getValueDescriptorMethod
operator|=
name|getMethodOrDie
argument_list|(
name|type
argument_list|,
literal|"getValueDescriptor"
argument_list|)
expr_stmt|;
name|supportUnknownEnumValue
operator|=
name|descriptor
operator|.
name|getFile
argument_list|()
operator|.
name|supportsUnknownEnumValue
argument_list|()
expr_stmt|;
if|if
condition|(
name|supportUnknownEnumValue
condition|)
block|{
name|getValueMethod
operator|=
name|getMethodOrDie
argument_list|(
name|messageClass
argument_list|,
literal|"get"
operator|+
name|camelCaseName
operator|+
literal|"Value"
argument_list|)
expr_stmt|;
name|getValueMethodBuilder
operator|=
name|getMethodOrDie
argument_list|(
name|builderClass
argument_list|,
literal|"get"
operator|+
name|camelCaseName
operator|+
literal|"Value"
argument_list|)
expr_stmt|;
name|setValueMethod
operator|=
name|getMethodOrDie
argument_list|(
name|builderClass
argument_list|,
literal|"set"
operator|+
name|camelCaseName
operator|+
literal|"Value"
argument_list|,
name|int
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|EnumDescriptor
name|enumDescriptor
decl_stmt|;
specifier|private
name|Method
name|valueOfMethod
decl_stmt|;
specifier|private
name|Method
name|getValueDescriptorMethod
decl_stmt|;
specifier|private
name|boolean
name|supportUnknownEnumValue
decl_stmt|;
specifier|private
name|Method
name|getValueMethod
decl_stmt|;
specifier|private
name|Method
name|getValueMethodBuilder
decl_stmt|;
specifier|private
name|Method
name|setValueMethod
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Object
name|get
parameter_list|(
specifier|final
name|GeneratedMessage
name|message
parameter_list|)
block|{
if|if
condition|(
name|supportUnknownEnumValue
condition|)
block|{
name|int
name|value
init|=
operator|(
name|Integer
operator|)
name|invokeOrDie
argument_list|(
name|getValueMethod
argument_list|,
name|message
argument_list|)
decl_stmt|;
return|return
name|enumDescriptor
operator|.
name|findValueByNumberCreatingIfUnknown
argument_list|(
name|value
argument_list|)
return|;
block|}
return|return
name|invokeOrDie
argument_list|(
name|getValueDescriptorMethod
argument_list|,
name|super
operator|.
name|get
argument_list|(
name|message
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|get
parameter_list|(
specifier|final
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|)
block|{
if|if
condition|(
name|supportUnknownEnumValue
condition|)
block|{
name|int
name|value
init|=
operator|(
name|Integer
operator|)
name|invokeOrDie
argument_list|(
name|getValueMethodBuilder
argument_list|,
name|builder
argument_list|)
decl_stmt|;
return|return
name|enumDescriptor
operator|.
name|findValueByNumberCreatingIfUnknown
argument_list|(
name|value
argument_list|)
return|;
block|}
return|return
name|invokeOrDie
argument_list|(
name|getValueDescriptorMethod
argument_list|,
name|super
operator|.
name|get
argument_list|(
name|builder
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|set
parameter_list|(
specifier|final
name|Builder
name|builder
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|supportUnknownEnumValue
condition|)
block|{
name|invokeOrDie
argument_list|(
name|setValueMethod
argument_list|,
name|builder
argument_list|,
operator|(
operator|(
name|EnumValueDescriptor
operator|)
name|value
operator|)
operator|.
name|getNumber
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|super
operator|.
name|set
argument_list|(
name|builder
argument_list|,
name|invokeOrDie
argument_list|(
name|valueOfMethod
argument_list|,
literal|null
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
specifier|final
class|class
name|RepeatedEnumFieldAccessor
extends|extends
name|RepeatedFieldAccessor
block|{
name|RepeatedEnumFieldAccessor
parameter_list|(
specifier|final
name|FieldDescriptor
name|descriptor
parameter_list|,
specifier|final
name|String
name|camelCaseName
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|GeneratedMessage
argument_list|>
name|messageClass
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|Builder
argument_list|>
name|builderClass
parameter_list|)
block|{
name|super
argument_list|(
name|descriptor
argument_list|,
name|camelCaseName
argument_list|,
name|messageClass
argument_list|,
name|builderClass
argument_list|)
expr_stmt|;
name|enumDescriptor
operator|=
name|descriptor
operator|.
name|getEnumType
argument_list|()
expr_stmt|;
name|valueOfMethod
operator|=
name|getMethodOrDie
argument_list|(
name|type
argument_list|,
literal|"valueOf"
argument_list|,
name|EnumValueDescriptor
operator|.
name|class
argument_list|)
expr_stmt|;
name|getValueDescriptorMethod
operator|=
name|getMethodOrDie
argument_list|(
name|type
argument_list|,
literal|"getValueDescriptor"
argument_list|)
expr_stmt|;
name|supportUnknownEnumValue
operator|=
name|descriptor
operator|.
name|getFile
argument_list|()
operator|.
name|supportsUnknownEnumValue
argument_list|()
expr_stmt|;
if|if
condition|(
name|supportUnknownEnumValue
condition|)
block|{
name|getRepeatedValueMethod
operator|=
name|getMethodOrDie
argument_list|(
name|messageClass
argument_list|,
literal|"get"
operator|+
name|camelCaseName
operator|+
literal|"Value"
argument_list|,
name|int
operator|.
name|class
argument_list|)
expr_stmt|;
name|getRepeatedValueMethodBuilder
operator|=
name|getMethodOrDie
argument_list|(
name|builderClass
argument_list|,
literal|"get"
operator|+
name|camelCaseName
operator|+
literal|"Value"
argument_list|,
name|int
operator|.
name|class
argument_list|)
expr_stmt|;
name|setRepeatedValueMethod
operator|=
name|getMethodOrDie
argument_list|(
name|builderClass
argument_list|,
literal|"set"
operator|+
name|camelCaseName
operator|+
literal|"Value"
argument_list|,
name|int
operator|.
name|class
argument_list|,
name|int
operator|.
name|class
argument_list|)
expr_stmt|;
name|addRepeatedValueMethod
operator|=
name|getMethodOrDie
argument_list|(
name|builderClass
argument_list|,
literal|"add"
operator|+
name|camelCaseName
operator|+
literal|"Value"
argument_list|,
name|int
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|EnumDescriptor
name|enumDescriptor
decl_stmt|;
specifier|private
specifier|final
name|Method
name|valueOfMethod
decl_stmt|;
specifier|private
specifier|final
name|Method
name|getValueDescriptorMethod
decl_stmt|;
specifier|private
name|boolean
name|supportUnknownEnumValue
decl_stmt|;
specifier|private
name|Method
name|getRepeatedValueMethod
decl_stmt|;
specifier|private
name|Method
name|getRepeatedValueMethodBuilder
decl_stmt|;
specifier|private
name|Method
name|setRepeatedValueMethod
decl_stmt|;
specifier|private
name|Method
name|addRepeatedValueMethod
decl_stmt|;
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|Object
name|get
parameter_list|(
specifier|final
name|GeneratedMessage
name|message
parameter_list|)
block|{
specifier|final
name|List
name|newList
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|size
init|=
name|getRepeatedCount
argument_list|(
name|message
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|newList
operator|.
name|add
argument_list|(
name|getRepeated
argument_list|(
name|message
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|newList
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|Object
name|get
parameter_list|(
specifier|final
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|)
block|{
specifier|final
name|List
name|newList
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|size
init|=
name|getRepeatedCount
argument_list|(
name|builder
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|newList
operator|.
name|add
argument_list|(
name|getRepeated
argument_list|(
name|builder
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|newList
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getRepeated
parameter_list|(
specifier|final
name|GeneratedMessage
name|message
parameter_list|,
specifier|final
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|supportUnknownEnumValue
condition|)
block|{
name|int
name|value
init|=
operator|(
name|Integer
operator|)
name|invokeOrDie
argument_list|(
name|getRepeatedValueMethod
argument_list|,
name|message
argument_list|,
name|index
argument_list|)
decl_stmt|;
return|return
name|enumDescriptor
operator|.
name|findValueByNumberCreatingIfUnknown
argument_list|(
name|value
argument_list|)
return|;
block|}
return|return
name|invokeOrDie
argument_list|(
name|getValueDescriptorMethod
argument_list|,
name|super
operator|.
name|getRepeated
argument_list|(
name|message
argument_list|,
name|index
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getRepeated
parameter_list|(
specifier|final
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|,
specifier|final
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|supportUnknownEnumValue
condition|)
block|{
name|int
name|value
init|=
operator|(
name|Integer
operator|)
name|invokeOrDie
argument_list|(
name|getRepeatedValueMethodBuilder
argument_list|,
name|builder
argument_list|,
name|index
argument_list|)
decl_stmt|;
return|return
name|enumDescriptor
operator|.
name|findValueByNumberCreatingIfUnknown
argument_list|(
name|value
argument_list|)
return|;
block|}
return|return
name|invokeOrDie
argument_list|(
name|getValueDescriptorMethod
argument_list|,
name|super
operator|.
name|getRepeated
argument_list|(
name|builder
argument_list|,
name|index
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setRepeated
parameter_list|(
specifier|final
name|Builder
name|builder
parameter_list|,
specifier|final
name|int
name|index
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|supportUnknownEnumValue
condition|)
block|{
name|invokeOrDie
argument_list|(
name|setRepeatedValueMethod
argument_list|,
name|builder
argument_list|,
name|index
argument_list|,
operator|(
operator|(
name|EnumValueDescriptor
operator|)
name|value
operator|)
operator|.
name|getNumber
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|super
operator|.
name|setRepeated
argument_list|(
name|builder
argument_list|,
name|index
argument_list|,
name|invokeOrDie
argument_list|(
name|valueOfMethod
argument_list|,
literal|null
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addRepeated
parameter_list|(
specifier|final
name|Builder
name|builder
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|supportUnknownEnumValue
condition|)
block|{
name|invokeOrDie
argument_list|(
name|addRepeatedValueMethod
argument_list|,
name|builder
argument_list|,
operator|(
operator|(
name|EnumValueDescriptor
operator|)
name|value
operator|)
operator|.
name|getNumber
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|super
operator|.
name|addRepeated
argument_list|(
name|builder
argument_list|,
name|invokeOrDie
argument_list|(
name|valueOfMethod
argument_list|,
literal|null
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ---------------------------------------------------------------
comment|/**      * Field accessor for string fields.      *      *<p>This class makes getFooBytes() and setFooBytes() available for      * reflection API so that reflection based serialize/parse functions can      * access the raw bytes of the field to preserve non-UTF8 bytes in the      * string.      *      *<p>This ensures the serialize/parse round-trip safety, which is important      * for servers which forward messages.      */
specifier|private
specifier|static
specifier|final
class|class
name|SingularStringFieldAccessor
extends|extends
name|SingularFieldAccessor
block|{
name|SingularStringFieldAccessor
parameter_list|(
specifier|final
name|FieldDescriptor
name|descriptor
parameter_list|,
specifier|final
name|String
name|camelCaseName
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|GeneratedMessage
argument_list|>
name|messageClass
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|Builder
argument_list|>
name|builderClass
parameter_list|,
specifier|final
name|String
name|containingOneofCamelCaseName
parameter_list|)
block|{
name|super
argument_list|(
name|descriptor
argument_list|,
name|camelCaseName
argument_list|,
name|messageClass
argument_list|,
name|builderClass
argument_list|,
name|containingOneofCamelCaseName
argument_list|)
expr_stmt|;
name|getBytesMethod
operator|=
name|getMethodOrDie
argument_list|(
name|messageClass
argument_list|,
literal|"get"
operator|+
name|camelCaseName
operator|+
literal|"Bytes"
argument_list|)
expr_stmt|;
name|getBytesMethodBuilder
operator|=
name|getMethodOrDie
argument_list|(
name|builderClass
argument_list|,
literal|"get"
operator|+
name|camelCaseName
operator|+
literal|"Bytes"
argument_list|)
expr_stmt|;
name|setBytesMethodBuilder
operator|=
name|getMethodOrDie
argument_list|(
name|builderClass
argument_list|,
literal|"set"
operator|+
name|camelCaseName
operator|+
literal|"Bytes"
argument_list|,
name|ByteString
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|final
name|Method
name|getBytesMethod
decl_stmt|;
specifier|private
specifier|final
name|Method
name|getBytesMethodBuilder
decl_stmt|;
specifier|private
specifier|final
name|Method
name|setBytesMethodBuilder
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Object
name|getRaw
parameter_list|(
specifier|final
name|GeneratedMessage
name|message
parameter_list|)
block|{
return|return
name|invokeOrDie
argument_list|(
name|getBytesMethod
argument_list|,
name|message
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getRaw
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|)
block|{
return|return
name|invokeOrDie
argument_list|(
name|getBytesMethodBuilder
argument_list|,
name|builder
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|set
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|ByteString
condition|)
block|{
name|invokeOrDie
argument_list|(
name|setBytesMethodBuilder
argument_list|,
name|builder
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|super
operator|.
name|set
argument_list|(
name|builder
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// ---------------------------------------------------------------
specifier|private
specifier|static
specifier|final
class|class
name|SingularMessageFieldAccessor
extends|extends
name|SingularFieldAccessor
block|{
name|SingularMessageFieldAccessor
parameter_list|(
specifier|final
name|FieldDescriptor
name|descriptor
parameter_list|,
specifier|final
name|String
name|camelCaseName
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|GeneratedMessage
argument_list|>
name|messageClass
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|Builder
argument_list|>
name|builderClass
parameter_list|,
specifier|final
name|String
name|containingOneofCamelCaseName
parameter_list|)
block|{
name|super
argument_list|(
name|descriptor
argument_list|,
name|camelCaseName
argument_list|,
name|messageClass
argument_list|,
name|builderClass
argument_list|,
name|containingOneofCamelCaseName
argument_list|)
expr_stmt|;
name|newBuilderMethod
operator|=
name|getMethodOrDie
argument_list|(
name|type
argument_list|,
literal|"newBuilder"
argument_list|)
expr_stmt|;
name|getBuilderMethodBuilder
operator|=
name|getMethodOrDie
argument_list|(
name|builderClass
argument_list|,
literal|"get"
operator|+
name|camelCaseName
operator|+
literal|"Builder"
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|final
name|Method
name|newBuilderMethod
decl_stmt|;
specifier|private
specifier|final
name|Method
name|getBuilderMethodBuilder
decl_stmt|;
specifier|private
name|Object
name|coerceType
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|type
operator|.
name|isInstance
argument_list|(
name|value
argument_list|)
condition|)
block|{
return|return
name|value
return|;
block|}
else|else
block|{
comment|// The value is not the exact right message type.  However, if it
comment|// is an alternative implementation of the same type -- e.g. a
comment|// DynamicMessage -- we should accept it.  In this case we can make
comment|// a copy of the message.
return|return
operator|(
operator|(
name|Message
operator|.
name|Builder
operator|)
name|invokeOrDie
argument_list|(
name|newBuilderMethod
argument_list|,
literal|null
argument_list|)
operator|)
operator|.
name|mergeFrom
argument_list|(
operator|(
name|Message
operator|)
name|value
argument_list|)
operator|.
name|buildPartial
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|set
parameter_list|(
specifier|final
name|Builder
name|builder
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
block|{
name|super
operator|.
name|set
argument_list|(
name|builder
argument_list|,
name|coerceType
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Message
operator|.
name|Builder
name|newBuilder
parameter_list|()
block|{
return|return
operator|(
name|Message
operator|.
name|Builder
operator|)
name|invokeOrDie
argument_list|(
name|newBuilderMethod
argument_list|,
literal|null
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Message
operator|.
name|Builder
name|getBuilder
parameter_list|(
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|)
block|{
return|return
operator|(
name|Message
operator|.
name|Builder
operator|)
name|invokeOrDie
argument_list|(
name|getBuilderMethodBuilder
argument_list|,
name|builder
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
specifier|final
class|class
name|RepeatedMessageFieldAccessor
extends|extends
name|RepeatedFieldAccessor
block|{
name|RepeatedMessageFieldAccessor
parameter_list|(
specifier|final
name|FieldDescriptor
name|descriptor
parameter_list|,
specifier|final
name|String
name|camelCaseName
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|GeneratedMessage
argument_list|>
name|messageClass
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|Builder
argument_list|>
name|builderClass
parameter_list|)
block|{
name|super
argument_list|(
name|descriptor
argument_list|,
name|camelCaseName
argument_list|,
name|messageClass
argument_list|,
name|builderClass
argument_list|)
expr_stmt|;
name|newBuilderMethod
operator|=
name|getMethodOrDie
argument_list|(
name|type
argument_list|,
literal|"newBuilder"
argument_list|)
expr_stmt|;
name|getBuilderMethodBuilder
operator|=
name|getMethodOrDie
argument_list|(
name|builderClass
argument_list|,
literal|"get"
operator|+
name|camelCaseName
operator|+
literal|"Builder"
argument_list|,
name|Integer
operator|.
name|TYPE
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|final
name|Method
name|newBuilderMethod
decl_stmt|;
specifier|private
specifier|final
name|Method
name|getBuilderMethodBuilder
decl_stmt|;
specifier|private
name|Object
name|coerceType
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|type
operator|.
name|isInstance
argument_list|(
name|value
argument_list|)
condition|)
block|{
return|return
name|value
return|;
block|}
else|else
block|{
comment|// The value is not the exact right message type.  However, if it
comment|// is an alternative implementation of the same type -- e.g. a
comment|// DynamicMessage -- we should accept it.  In this case we can make
comment|// a copy of the message.
return|return
operator|(
operator|(
name|Message
operator|.
name|Builder
operator|)
name|invokeOrDie
argument_list|(
name|newBuilderMethod
argument_list|,
literal|null
argument_list|)
operator|)
operator|.
name|mergeFrom
argument_list|(
operator|(
name|Message
operator|)
name|value
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|setRepeated
parameter_list|(
specifier|final
name|Builder
name|builder
parameter_list|,
specifier|final
name|int
name|index
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
block|{
name|super
operator|.
name|setRepeated
argument_list|(
name|builder
argument_list|,
name|index
argument_list|,
name|coerceType
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addRepeated
parameter_list|(
specifier|final
name|Builder
name|builder
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
block|{
name|super
operator|.
name|addRepeated
argument_list|(
name|builder
argument_list|,
name|coerceType
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Message
operator|.
name|Builder
name|newBuilder
parameter_list|()
block|{
return|return
operator|(
name|Message
operator|.
name|Builder
operator|)
name|invokeOrDie
argument_list|(
name|newBuilderMethod
argument_list|,
literal|null
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Message
operator|.
name|Builder
name|getRepeatedBuilder
parameter_list|(
specifier|final
name|GeneratedMessage
operator|.
name|Builder
name|builder
parameter_list|,
specifier|final
name|int
name|index
parameter_list|)
block|{
return|return
operator|(
name|Message
operator|.
name|Builder
operator|)
name|invokeOrDie
argument_list|(
name|getBuilderMethodBuilder
argument_list|,
name|builder
argument_list|,
name|index
argument_list|)
return|;
block|}
block|}
block|}
comment|/**    * Replaces this object in the output stream with a serialized form.    * Part of Java's serialization magic.  Generated sub-classes must override    * this method by calling {@code return super.writeReplace();}    * @return a SerializedForm of this message    */
specifier|protected
name|Object
name|writeReplace
parameter_list|()
throws|throws
name|ObjectStreamException
block|{
return|return
operator|new
name|GeneratedMessageLite
operator|.
name|SerializedForm
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * Checks that the {@link Extension} is non-Lite and returns it as a    * {@link GeneratedExtension}.    */
specifier|private
specifier|static
parameter_list|<
name|MessageType
extends|extends
name|ExtendableMessage
argument_list|<
name|MessageType
argument_list|>
parameter_list|,
name|T
parameter_list|>
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|T
argument_list|>
name|checkNotLite
parameter_list|(
name|ExtensionLite
argument_list|<
name|MessageType
argument_list|,
name|T
argument_list|>
name|extension
parameter_list|)
block|{
if|if
condition|(
name|extension
operator|.
name|isLite
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Expected non-lite extension."
argument_list|)
throw|;
block|}
return|return
operator|(
name|Extension
argument_list|<
name|MessageType
argument_list|,
name|T
argument_list|>
operator|)
name|extension
return|;
block|}
specifier|protected
specifier|static
name|int
name|computeStringSize
parameter_list|(
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|String
condition|)
block|{
return|return
name|CodedOutputStream
operator|.
name|computeStringSize
argument_list|(
name|fieldNumber
argument_list|,
operator|(
name|String
operator|)
name|value
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|CodedOutputStream
operator|.
name|computeBytesSize
argument_list|(
name|fieldNumber
argument_list|,
operator|(
name|ByteString
operator|)
name|value
argument_list|)
return|;
block|}
block|}
specifier|protected
specifier|static
name|int
name|computeStringSizeNoTag
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|String
condition|)
block|{
return|return
name|CodedOutputStream
operator|.
name|computeStringSizeNoTag
argument_list|(
operator|(
name|String
operator|)
name|value
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|CodedOutputStream
operator|.
name|computeBytesSizeNoTag
argument_list|(
operator|(
name|ByteString
operator|)
name|value
argument_list|)
return|;
block|}
block|}
specifier|protected
specifier|static
name|void
name|writeString
parameter_list|(
name|CodedOutputStream
name|output
parameter_list|,
specifier|final
name|int
name|fieldNumber
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|value
operator|instanceof
name|String
condition|)
block|{
name|output
operator|.
name|writeString
argument_list|(
name|fieldNumber
argument_list|,
operator|(
name|String
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output
operator|.
name|writeBytes
argument_list|(
name|fieldNumber
argument_list|,
operator|(
name|ByteString
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
specifier|static
name|void
name|writeStringNoTag
parameter_list|(
name|CodedOutputStream
name|output
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|value
operator|instanceof
name|String
condition|)
block|{
name|output
operator|.
name|writeStringNoTag
argument_list|(
operator|(
name|String
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output
operator|.
name|writeBytesNoTag
argument_list|(
operator|(
name|ByteString
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

