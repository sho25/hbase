begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|// Protocol Buffers - Google's data interchange format
end_comment

begin_comment
comment|// Copyright 2008 Google Inc.  All rights reserved.
end_comment

begin_comment
comment|// https://developers.google.com/protocol-buffers/
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Redistribution and use in source and binary forms, with or without
end_comment

begin_comment
comment|// modification, are permitted provided that the following conditions are
end_comment

begin_comment
comment|// met:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//     * Redistributions of source code must retain the above copyright
end_comment

begin_comment
comment|// notice, this list of conditions and the following disclaimer.
end_comment

begin_comment
comment|//     * Redistributions in binary form must reproduce the above
end_comment

begin_comment
comment|// copyright notice, this list of conditions and the following disclaimer
end_comment

begin_comment
comment|// in the documentation and/or other materials provided with the
end_comment

begin_comment
comment|// distribution.
end_comment

begin_comment
comment|//     * Neither the name of Google Inc. nor the names of its
end_comment

begin_comment
comment|// contributors may be used to endorse or promote products derived from
end_comment

begin_comment
comment|// this software without specific prior written permission.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
end_comment

begin_comment
comment|// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
end_comment

begin_comment
comment|// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
end_comment

begin_comment
comment|// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
end_comment

begin_comment
comment|// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
end_comment

begin_comment
comment|// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
end_comment

begin_comment
comment|// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
end_comment

begin_comment
comment|// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
end_comment

begin_comment
comment|// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InvalidObjectException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_comment
comment|/**  * Class to represent {@code ByteStrings} formed by concatenation of other  * ByteStrings, without copying the data in the pieces. The concatenation is  * represented as a tree whose leaf nodes are each a  * {@link org.apache.hadoop.hbase.shaded.com.google.protobuf.ByteString.LeafByteString}.  *  *<p>Most of the operation here is inspired by the now-famous paper<a  * href="https://web.archive.org/web/20060202015456/http://www.cs.ubc.ca/local/reading/proceedings/spe91-95/spe/vol25/issue12/spe986.pdf">  * BAP95</a> Ropes: an Alternative to Strings hans-j. boehm, russ atkinson and  * michael plass  *  *<p>The algorithms described in the paper have been implemented for character  * strings in {@code com.google.common.string.Rope} and in the c++ class {@code  * cord.cc}.  *  *<p>Fundamentally the Rope algorithm represents the collection of pieces as a  * binary tree. BAP95 uses a Fibonacci bound relating depth to a minimum  * sequence length, sequences that are too short relative to their depth cause a  * tree rebalance.  More precisely, a tree of depth d is "balanced" in the  * terminology of BAP95 if its length is at least F(d+2), where F(n) is the  * n-the Fibonacci number. Thus for depths 0, 1, 2, 3, 4, 5,... we have minimum  * lengths 1, 2, 3, 5, 8, 13,...  *  * @author carlanton@google.com (Carl Haverl)  */
end_comment

begin_class
specifier|final
class|class
name|RopeByteString
extends|extends
name|ByteString
block|{
comment|/**    * BAP95. Let Fn be the nth Fibonacci number. A {@link RopeByteString} of    * depth n is "balanced", i.e flat enough, if its length is at least Fn+2,    * e.g. a "balanced" {@link RopeByteString} of depth 1 must have length at    * least 2, of depth 4 must have length>= 8, etc.    *    *<p>There's nothing special about using the Fibonacci numbers for this, but    * they are a reasonable sequence for encapsulating the idea that we are OK    * with longer strings being encoded in deeper binary trees.    *    *<p>For 32-bit integers, this array has length 46.    */
specifier|private
specifier|static
specifier|final
name|int
index|[]
name|minLengthByDepth
decl_stmt|;
static|static
block|{
comment|// Dynamically generate the list of Fibonacci numbers the first time this
comment|// class is accessed.
name|List
argument_list|<
name|Integer
argument_list|>
name|numbers
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
comment|// we skip the first Fibonacci number (1).  So instead of: 1 1 2 3 5 8 ...
comment|// we have: 1 2 3 5 8 ...
name|int
name|f1
init|=
literal|1
decl_stmt|;
name|int
name|f2
init|=
literal|1
decl_stmt|;
comment|// get all the values until we roll over.
while|while
condition|(
name|f2
operator|>
literal|0
condition|)
block|{
name|numbers
operator|.
name|add
argument_list|(
name|f2
argument_list|)
expr_stmt|;
name|int
name|temp
init|=
name|f1
operator|+
name|f2
decl_stmt|;
name|f1
operator|=
name|f2
expr_stmt|;
name|f2
operator|=
name|temp
expr_stmt|;
block|}
comment|// we include this here so that we can index this array to [x + 1] in the
comment|// loops below.
name|numbers
operator|.
name|add
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
name|minLengthByDepth
operator|=
operator|new
name|int
index|[
name|numbers
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|minLengthByDepth
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// unbox all the values
name|minLengthByDepth
index|[
name|i
index|]
operator|=
name|numbers
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|final
name|int
name|totalLength
decl_stmt|;
specifier|private
specifier|final
name|ByteString
name|left
decl_stmt|;
specifier|private
specifier|final
name|ByteString
name|right
decl_stmt|;
specifier|private
specifier|final
name|int
name|leftLength
decl_stmt|;
specifier|private
specifier|final
name|int
name|treeDepth
decl_stmt|;
comment|/**    * Create a new RopeByteString, which can be thought of as a new tree node, by    * recording references to the two given strings.    *    * @param left  string on the left of this node, should have {@code size()>    *              0}    * @param right string on the right of this node, should have {@code size()>    *              0}    */
specifier|private
name|RopeByteString
parameter_list|(
name|ByteString
name|left
parameter_list|,
name|ByteString
name|right
parameter_list|)
block|{
name|this
operator|.
name|left
operator|=
name|left
expr_stmt|;
name|this
operator|.
name|right
operator|=
name|right
expr_stmt|;
name|leftLength
operator|=
name|left
operator|.
name|size
argument_list|()
expr_stmt|;
name|totalLength
operator|=
name|leftLength
operator|+
name|right
operator|.
name|size
argument_list|()
expr_stmt|;
name|treeDepth
operator|=
name|Math
operator|.
name|max
argument_list|(
name|left
operator|.
name|getTreeDepth
argument_list|()
argument_list|,
name|right
operator|.
name|getTreeDepth
argument_list|()
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
comment|/**    * Concatenate the given strings while performing various optimizations to    * slow the growth rate of tree depth and tree node count. The result is    * either a {@link org.apache.hadoop.hbase.shaded.com.google.protobuf.ByteString.LeafByteString} or a    * {@link RopeByteString} depending on which optimizations, if any, were    * applied.    *    *<p>Small pieces of length less than {@link    * ByteString#CONCATENATE_BY_COPY_SIZE} may be copied by value here, as in    * BAP95.  Large pieces are referenced without copy.    *    * @param left  string on the left    * @param right string on the right    * @return concatenation representing the same sequence as the given strings    */
specifier|static
name|ByteString
name|concatenate
parameter_list|(
name|ByteString
name|left
parameter_list|,
name|ByteString
name|right
parameter_list|)
block|{
if|if
condition|(
name|right
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|left
return|;
block|}
if|if
condition|(
name|left
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|right
return|;
block|}
specifier|final
name|int
name|newLength
init|=
name|left
operator|.
name|size
argument_list|()
operator|+
name|right
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|newLength
operator|<
name|ByteString
operator|.
name|CONCATENATE_BY_COPY_SIZE
condition|)
block|{
comment|// Optimization from BAP95: For short (leaves in paper, but just short
comment|// here) total length, do a copy of data to a new leaf.
return|return
name|concatenateBytes
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
if|if
condition|(
name|left
operator|instanceof
name|RopeByteString
condition|)
block|{
specifier|final
name|RopeByteString
name|leftRope
init|=
operator|(
name|RopeByteString
operator|)
name|left
decl_stmt|;
if|if
condition|(
name|leftRope
operator|.
name|right
operator|.
name|size
argument_list|()
operator|+
name|right
operator|.
name|size
argument_list|()
operator|<
name|CONCATENATE_BY_COPY_SIZE
condition|)
block|{
comment|// Optimization from BAP95: As an optimization of the case where the
comment|// ByteString is constructed by repeated concatenate, recognize the case
comment|// where a short string is concatenated to a left-hand node whose
comment|// right-hand branch is short.  In the paper this applies to leaves, but
comment|// we just look at the length here. This has the advantage of shedding
comment|// references to unneeded data when substrings have been taken.
comment|//
comment|// When we recognize this case, we do a copy of the data and create a
comment|// new parent node so that the depth of the result is the same as the
comment|// given left tree.
name|ByteString
name|newRight
init|=
name|concatenateBytes
argument_list|(
name|leftRope
operator|.
name|right
argument_list|,
name|right
argument_list|)
decl_stmt|;
return|return
operator|new
name|RopeByteString
argument_list|(
name|leftRope
operator|.
name|left
argument_list|,
name|newRight
argument_list|)
return|;
block|}
if|if
condition|(
name|leftRope
operator|.
name|left
operator|.
name|getTreeDepth
argument_list|()
operator|>
name|leftRope
operator|.
name|right
operator|.
name|getTreeDepth
argument_list|()
operator|&&
name|leftRope
operator|.
name|getTreeDepth
argument_list|()
operator|>
name|right
operator|.
name|getTreeDepth
argument_list|()
condition|)
block|{
comment|// Typically for concatenate-built strings the left-side is deeper than
comment|// the right.  This is our final attempt to concatenate without
comment|// increasing the tree depth.  We'll redo the node on the RHS.  This
comment|// is yet another optimization for building the string by repeatedly
comment|// concatenating on the right.
name|ByteString
name|newRight
init|=
operator|new
name|RopeByteString
argument_list|(
name|leftRope
operator|.
name|right
argument_list|,
name|right
argument_list|)
decl_stmt|;
return|return
operator|new
name|RopeByteString
argument_list|(
name|leftRope
operator|.
name|left
argument_list|,
name|newRight
argument_list|)
return|;
block|}
block|}
comment|// Fine, we'll add a node and increase the tree depth--unless we rebalance ;^)
name|int
name|newDepth
init|=
name|Math
operator|.
name|max
argument_list|(
name|left
operator|.
name|getTreeDepth
argument_list|()
argument_list|,
name|right
operator|.
name|getTreeDepth
argument_list|()
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|newLength
operator|>=
name|minLengthByDepth
index|[
name|newDepth
index|]
condition|)
block|{
comment|// The tree is shallow enough, so don't rebalance
return|return
operator|new
name|RopeByteString
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
return|return
operator|new
name|Balancer
argument_list|()
operator|.
name|balance
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Concatenates two strings by copying data values. This is called in a few    * cases in order to reduce the growth of the number of tree nodes.    *    * @param left  string on the left    * @param right string on the right    * @return string formed by copying data bytes    */
specifier|private
specifier|static
name|ByteString
name|concatenateBytes
parameter_list|(
name|ByteString
name|left
parameter_list|,
name|ByteString
name|right
parameter_list|)
block|{
name|int
name|leftSize
init|=
name|left
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|rightSize
init|=
name|right
operator|.
name|size
argument_list|()
decl_stmt|;
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|leftSize
operator|+
name|rightSize
index|]
decl_stmt|;
name|left
operator|.
name|copyTo
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|leftSize
argument_list|)
expr_stmt|;
name|right
operator|.
name|copyTo
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|leftSize
argument_list|,
name|rightSize
argument_list|)
expr_stmt|;
return|return
name|ByteString
operator|.
name|wrap
argument_list|(
name|bytes
argument_list|)
return|;
comment|// Constructor wraps bytes
block|}
comment|/**    * Create a new RopeByteString for testing only while bypassing all the    * defenses of {@link #concatenate(ByteString, ByteString)}. This allows    * testing trees of specific structure. We are also able to insert empty    * leaves, though these are dis-allowed, so that we can make sure the    * implementation can withstand their presence.    *    * @param left  string on the left of this node    * @param right string on the right of this node    * @return an unsafe instance for testing only    */
specifier|static
name|RopeByteString
name|newInstanceForTest
parameter_list|(
name|ByteString
name|left
parameter_list|,
name|ByteString
name|right
parameter_list|)
block|{
return|return
operator|new
name|RopeByteString
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    * Gets the byte at the given index.    * Throws {@link ArrayIndexOutOfBoundsException} for backwards-compatibility    * reasons although it would more properly be {@link    * IndexOutOfBoundsException}.    *    * @param index index of byte    * @return the value    * @throws ArrayIndexOutOfBoundsException {@code index} is< 0 or>= size    */
annotation|@
name|Override
specifier|public
name|byte
name|byteAt
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|checkIndex
argument_list|(
name|index
argument_list|,
name|totalLength
argument_list|)
expr_stmt|;
comment|// Find the relevant piece by recursive descent
if|if
condition|(
name|index
operator|<
name|leftLength
condition|)
block|{
return|return
name|left
operator|.
name|byteAt
argument_list|(
name|index
argument_list|)
return|;
block|}
return|return
name|right
operator|.
name|byteAt
argument_list|(
name|index
operator|-
name|leftLength
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|totalLength
return|;
block|}
comment|// =================================================================
comment|// Pieces
annotation|@
name|Override
specifier|protected
name|int
name|getTreeDepth
parameter_list|()
block|{
return|return
name|treeDepth
return|;
block|}
comment|/**    * Determines if the tree is balanced according to BAP95, which means the tree    * is flat-enough with respect to the bounds. Note that this definition of    * balanced is one where sub-trees of balanced trees are not necessarily    * balanced.    *    * @return true if the tree is balanced    */
annotation|@
name|Override
specifier|protected
name|boolean
name|isBalanced
parameter_list|()
block|{
return|return
name|totalLength
operator|>=
name|minLengthByDepth
index|[
name|treeDepth
index|]
return|;
block|}
comment|/**    * Takes a substring of this one. This involves recursive descent along the    * left and right edges of the substring, and referencing any wholly contained    * segments in between. Any leaf nodes entirely uninvolved in the substring    * will not be referenced by the substring.    *    *<p>Substrings of {@code length< 2} should result in at most a single    * recursive call chain, terminating at a leaf node. Thus the result will be a    * {@link org.apache.hadoop.hbase.shaded.com.google.protobuf.ByteString.LeafByteString}.    *    * @param beginIndex start at this index    * @param endIndex   the last character is the one before this index    * @return substring leaf node or tree    */
annotation|@
name|Override
specifier|public
name|ByteString
name|substring
parameter_list|(
name|int
name|beginIndex
parameter_list|,
name|int
name|endIndex
parameter_list|)
block|{
specifier|final
name|int
name|length
init|=
name|checkRange
argument_list|(
name|beginIndex
argument_list|,
name|endIndex
argument_list|,
name|totalLength
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
comment|// Empty substring
return|return
name|ByteString
operator|.
name|EMPTY
return|;
block|}
if|if
condition|(
name|length
operator|==
name|totalLength
condition|)
block|{
comment|// The whole string
return|return
name|this
return|;
block|}
comment|// Proper substring
if|if
condition|(
name|endIndex
operator|<=
name|leftLength
condition|)
block|{
comment|// Substring on the left
return|return
name|left
operator|.
name|substring
argument_list|(
name|beginIndex
argument_list|,
name|endIndex
argument_list|)
return|;
block|}
if|if
condition|(
name|beginIndex
operator|>=
name|leftLength
condition|)
block|{
comment|// Substring on the right
return|return
name|right
operator|.
name|substring
argument_list|(
name|beginIndex
operator|-
name|leftLength
argument_list|,
name|endIndex
operator|-
name|leftLength
argument_list|)
return|;
block|}
comment|// Split substring
name|ByteString
name|leftSub
init|=
name|left
operator|.
name|substring
argument_list|(
name|beginIndex
argument_list|)
decl_stmt|;
name|ByteString
name|rightSub
init|=
name|right
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|endIndex
operator|-
name|leftLength
argument_list|)
decl_stmt|;
comment|// Intentionally not rebalancing, since in many cases these two
comment|// substrings will already be less deep than the top-level
comment|// RopeByteString we're taking a substring of.
return|return
operator|new
name|RopeByteString
argument_list|(
name|leftSub
argument_list|,
name|rightSub
argument_list|)
return|;
block|}
comment|// =================================================================
comment|// ByteString -> byte[]
annotation|@
name|Override
specifier|protected
name|void
name|copyToInternal
parameter_list|(
name|byte
index|[]
name|target
parameter_list|,
name|int
name|sourceOffset
parameter_list|,
name|int
name|targetOffset
parameter_list|,
name|int
name|numberToCopy
parameter_list|)
block|{
if|if
condition|(
name|sourceOffset
operator|+
name|numberToCopy
operator|<=
name|leftLength
condition|)
block|{
name|left
operator|.
name|copyToInternal
argument_list|(
name|target
argument_list|,
name|sourceOffset
argument_list|,
name|targetOffset
argument_list|,
name|numberToCopy
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sourceOffset
operator|>=
name|leftLength
condition|)
block|{
name|right
operator|.
name|copyToInternal
argument_list|(
name|target
argument_list|,
name|sourceOffset
operator|-
name|leftLength
argument_list|,
name|targetOffset
argument_list|,
name|numberToCopy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|leftLength
init|=
name|this
operator|.
name|leftLength
operator|-
name|sourceOffset
decl_stmt|;
name|left
operator|.
name|copyToInternal
argument_list|(
name|target
argument_list|,
name|sourceOffset
argument_list|,
name|targetOffset
argument_list|,
name|leftLength
argument_list|)
expr_stmt|;
name|right
operator|.
name|copyToInternal
argument_list|(
name|target
argument_list|,
literal|0
argument_list|,
name|targetOffset
operator|+
name|leftLength
argument_list|,
name|numberToCopy
operator|-
name|leftLength
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|copyTo
parameter_list|(
name|ByteBuffer
name|target
parameter_list|)
block|{
name|left
operator|.
name|copyTo
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|right
operator|.
name|copyTo
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|ByteBuffer
name|asReadOnlyByteBuffer
parameter_list|()
block|{
name|ByteBuffer
name|byteBuffer
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|toByteArray
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|byteBuffer
operator|.
name|asReadOnlyBuffer
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|ByteBuffer
argument_list|>
name|asReadOnlyByteBufferList
parameter_list|()
block|{
comment|// Walk through the list of LeafByteString's that make up this
comment|// rope, and add each one as a read-only ByteBuffer.
name|List
argument_list|<
name|ByteBuffer
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|ByteBuffer
argument_list|>
argument_list|()
decl_stmt|;
name|PieceIterator
name|pieces
init|=
operator|new
name|PieceIterator
argument_list|(
name|this
argument_list|)
decl_stmt|;
while|while
condition|(
name|pieces
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|LeafByteString
name|byteString
init|=
name|pieces
operator|.
name|next
argument_list|()
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|byteString
operator|.
name|asReadOnlyByteBuffer
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeTo
parameter_list|(
name|OutputStream
name|outputStream
parameter_list|)
throws|throws
name|IOException
block|{
name|left
operator|.
name|writeTo
argument_list|(
name|outputStream
argument_list|)
expr_stmt|;
name|right
operator|.
name|writeTo
argument_list|(
name|outputStream
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|void
name|writeToInternal
parameter_list|(
name|OutputStream
name|out
parameter_list|,
name|int
name|sourceOffset
parameter_list|,
name|int
name|numberToWrite
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|sourceOffset
operator|+
name|numberToWrite
operator|<=
name|leftLength
condition|)
block|{
name|left
operator|.
name|writeToInternal
argument_list|(
name|out
argument_list|,
name|sourceOffset
argument_list|,
name|numberToWrite
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sourceOffset
operator|>=
name|leftLength
condition|)
block|{
name|right
operator|.
name|writeToInternal
argument_list|(
name|out
argument_list|,
name|sourceOffset
operator|-
name|leftLength
argument_list|,
name|numberToWrite
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|numberToWriteInLeft
init|=
name|leftLength
operator|-
name|sourceOffset
decl_stmt|;
name|left
operator|.
name|writeToInternal
argument_list|(
name|out
argument_list|,
name|sourceOffset
argument_list|,
name|numberToWriteInLeft
argument_list|)
expr_stmt|;
name|right
operator|.
name|writeToInternal
argument_list|(
name|out
argument_list|,
literal|0
argument_list|,
name|numberToWrite
operator|-
name|numberToWriteInLeft
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
name|void
name|writeTo
parameter_list|(
name|ByteOutput
name|output
parameter_list|)
throws|throws
name|IOException
block|{
name|left
operator|.
name|writeTo
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|right
operator|.
name|writeTo
argument_list|(
name|output
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|toStringInternal
parameter_list|(
name|Charset
name|charset
parameter_list|)
block|{
return|return
operator|new
name|String
argument_list|(
name|toByteArray
argument_list|()
argument_list|,
name|charset
argument_list|)
return|;
block|}
comment|// =================================================================
comment|// UTF-8 decoding
annotation|@
name|Override
specifier|public
name|boolean
name|isValidUtf8
parameter_list|()
block|{
name|int
name|leftPartial
init|=
name|left
operator|.
name|partialIsValidUtf8
argument_list|(
name|Utf8
operator|.
name|COMPLETE
argument_list|,
literal|0
argument_list|,
name|leftLength
argument_list|)
decl_stmt|;
name|int
name|state
init|=
name|right
operator|.
name|partialIsValidUtf8
argument_list|(
name|leftPartial
argument_list|,
literal|0
argument_list|,
name|right
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|state
operator|==
name|Utf8
operator|.
name|COMPLETE
return|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|partialIsValidUtf8
parameter_list|(
name|int
name|state
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|toIndex
init|=
name|offset
operator|+
name|length
decl_stmt|;
if|if
condition|(
name|toIndex
operator|<=
name|leftLength
condition|)
block|{
return|return
name|left
operator|.
name|partialIsValidUtf8
argument_list|(
name|state
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|>=
name|leftLength
condition|)
block|{
return|return
name|right
operator|.
name|partialIsValidUtf8
argument_list|(
name|state
argument_list|,
name|offset
operator|-
name|leftLength
argument_list|,
name|length
argument_list|)
return|;
block|}
else|else
block|{
name|int
name|leftLength
init|=
name|this
operator|.
name|leftLength
operator|-
name|offset
decl_stmt|;
name|int
name|leftPartial
init|=
name|left
operator|.
name|partialIsValidUtf8
argument_list|(
name|state
argument_list|,
name|offset
argument_list|,
name|leftLength
argument_list|)
decl_stmt|;
return|return
name|right
operator|.
name|partialIsValidUtf8
argument_list|(
name|leftPartial
argument_list|,
literal|0
argument_list|,
name|length
operator|-
name|leftLength
argument_list|)
return|;
block|}
block|}
comment|// =================================================================
comment|// equals() and hashCode()
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|==
name|this
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|other
operator|instanceof
name|ByteString
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|ByteString
name|otherByteString
init|=
operator|(
name|ByteString
operator|)
name|other
decl_stmt|;
if|if
condition|(
name|totalLength
operator|!=
name|otherByteString
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|totalLength
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// You don't really want to be calling equals on long strings, but since
comment|// we cache the hashCode, we effectively cache inequality. We use the cached
comment|// hashCode if it's already computed.  It's arguable we should compute the
comment|// hashCode here, and if we're going to be testing a bunch of byteStrings,
comment|// it might even make sense.
name|int
name|thisHash
init|=
name|peekCachedHashCode
argument_list|()
decl_stmt|;
name|int
name|thatHash
init|=
name|otherByteString
operator|.
name|peekCachedHashCode
argument_list|()
decl_stmt|;
if|if
condition|(
name|thisHash
operator|!=
literal|0
operator|&&
name|thatHash
operator|!=
literal|0
operator|&&
name|thisHash
operator|!=
name|thatHash
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|equalsFragments
argument_list|(
name|otherByteString
argument_list|)
return|;
block|}
comment|/**    * Determines if this string is equal to another of the same length by    * iterating over the leaf nodes. On each step of the iteration, the    * overlapping segments of the leaves are compared.    *    * @param other string of the same length as this one    * @return true if the values of this string equals the value of the given    *         one    */
specifier|private
name|boolean
name|equalsFragments
parameter_list|(
name|ByteString
name|other
parameter_list|)
block|{
name|int
name|thisOffset
init|=
literal|0
decl_stmt|;
name|Iterator
argument_list|<
name|LeafByteString
argument_list|>
name|thisIter
init|=
operator|new
name|PieceIterator
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|LeafByteString
name|thisString
init|=
name|thisIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|int
name|thatOffset
init|=
literal|0
decl_stmt|;
name|Iterator
argument_list|<
name|LeafByteString
argument_list|>
name|thatIter
init|=
operator|new
name|PieceIterator
argument_list|(
name|other
argument_list|)
decl_stmt|;
name|LeafByteString
name|thatString
init|=
name|thatIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|thisRemaining
init|=
name|thisString
operator|.
name|size
argument_list|()
operator|-
name|thisOffset
decl_stmt|;
name|int
name|thatRemaining
init|=
name|thatString
operator|.
name|size
argument_list|()
operator|-
name|thatOffset
decl_stmt|;
name|int
name|bytesToCompare
init|=
name|Math
operator|.
name|min
argument_list|(
name|thisRemaining
argument_list|,
name|thatRemaining
argument_list|)
decl_stmt|;
comment|// At least one of the offsets will be zero
name|boolean
name|stillEqual
init|=
operator|(
name|thisOffset
operator|==
literal|0
operator|)
condition|?
name|thisString
operator|.
name|equalsRange
argument_list|(
name|thatString
argument_list|,
name|thatOffset
argument_list|,
name|bytesToCompare
argument_list|)
else|:
name|thatString
operator|.
name|equalsRange
argument_list|(
name|thisString
argument_list|,
name|thisOffset
argument_list|,
name|bytesToCompare
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|stillEqual
condition|)
block|{
return|return
literal|false
return|;
block|}
name|pos
operator|+=
name|bytesToCompare
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|totalLength
condition|)
block|{
if|if
condition|(
name|pos
operator|==
name|totalLength
condition|)
block|{
return|return
literal|true
return|;
block|}
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
comment|// We always get to the end of at least one of the pieces
if|if
condition|(
name|bytesToCompare
operator|==
name|thisRemaining
condition|)
block|{
comment|// If reached end of this
name|thisOffset
operator|=
literal|0
expr_stmt|;
name|thisString
operator|=
name|thisIter
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|thisOffset
operator|+=
name|bytesToCompare
expr_stmt|;
block|}
if|if
condition|(
name|bytesToCompare
operator|==
name|thatRemaining
condition|)
block|{
comment|// If reached end of that
name|thatOffset
operator|=
literal|0
expr_stmt|;
name|thatString
operator|=
name|thatIter
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|thatOffset
operator|+=
name|bytesToCompare
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|protected
name|int
name|partialHash
parameter_list|(
name|int
name|h
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|toIndex
init|=
name|offset
operator|+
name|length
decl_stmt|;
if|if
condition|(
name|toIndex
operator|<=
name|leftLength
condition|)
block|{
return|return
name|left
operator|.
name|partialHash
argument_list|(
name|h
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|>=
name|leftLength
condition|)
block|{
return|return
name|right
operator|.
name|partialHash
argument_list|(
name|h
argument_list|,
name|offset
operator|-
name|leftLength
argument_list|,
name|length
argument_list|)
return|;
block|}
else|else
block|{
name|int
name|leftLength
init|=
name|this
operator|.
name|leftLength
operator|-
name|offset
decl_stmt|;
name|int
name|leftPartial
init|=
name|left
operator|.
name|partialHash
argument_list|(
name|h
argument_list|,
name|offset
argument_list|,
name|leftLength
argument_list|)
decl_stmt|;
return|return
name|right
operator|.
name|partialHash
argument_list|(
name|leftPartial
argument_list|,
literal|0
argument_list|,
name|length
operator|-
name|leftLength
argument_list|)
return|;
block|}
block|}
comment|// =================================================================
comment|// Input stream
annotation|@
name|Override
specifier|public
name|CodedInputStream
name|newCodedInput
parameter_list|()
block|{
return|return
name|CodedInputStream
operator|.
name|newInstance
argument_list|(
operator|new
name|RopeInputStream
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|InputStream
name|newInput
parameter_list|()
block|{
return|return
operator|new
name|RopeInputStream
argument_list|()
return|;
block|}
comment|/**    * This class implements the balancing algorithm of BAP95. In the paper the    * authors use an array to keep track of pieces, while here we use a stack.    * The tree is balanced by traversing subtrees in left to right order, and the    * stack always contains the part of the string we've traversed so far.    *    *<p>One surprising aspect of the algorithm is the result of balancing is not    * necessarily balanced, though it is nearly balanced.  For details, see    * BAP95.    */
specifier|private
specifier|static
class|class
name|Balancer
block|{
comment|// Stack containing the part of the string, starting from the left, that
comment|// we've already traversed.  The final string should be the equivalent of
comment|// concatenating the strings on the stack from bottom to top.
specifier|private
specifier|final
name|Stack
argument_list|<
name|ByteString
argument_list|>
name|prefixesStack
init|=
operator|new
name|Stack
argument_list|<
name|ByteString
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|ByteString
name|balance
parameter_list|(
name|ByteString
name|left
parameter_list|,
name|ByteString
name|right
parameter_list|)
block|{
name|doBalance
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|doBalance
argument_list|(
name|right
argument_list|)
expr_stmt|;
comment|// Sweep stack to gather the result
name|ByteString
name|partialString
init|=
name|prefixesStack
operator|.
name|pop
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|prefixesStack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ByteString
name|newLeft
init|=
name|prefixesStack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|partialString
operator|=
operator|new
name|RopeByteString
argument_list|(
name|newLeft
argument_list|,
name|partialString
argument_list|)
expr_stmt|;
block|}
comment|// We should end up with a RopeByteString since at a minimum we will
comment|// create one from concatenating left and right
return|return
name|partialString
return|;
block|}
specifier|private
name|void
name|doBalance
parameter_list|(
name|ByteString
name|root
parameter_list|)
block|{
comment|// BAP95: Insert balanced subtrees whole. This means the result might not
comment|// be balanced, leading to repeated rebalancings on concatenate. However,
comment|// these rebalancings are shallow due to ignoring balanced subtrees, and
comment|// relatively few calls to insert() result.
if|if
condition|(
name|root
operator|.
name|isBalanced
argument_list|()
condition|)
block|{
name|insert
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|root
operator|instanceof
name|RopeByteString
condition|)
block|{
name|RopeByteString
name|rbs
init|=
operator|(
name|RopeByteString
operator|)
name|root
decl_stmt|;
name|doBalance
argument_list|(
name|rbs
operator|.
name|left
argument_list|)
expr_stmt|;
name|doBalance
argument_list|(
name|rbs
operator|.
name|right
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Has a new type of ByteString been created? Found "
operator|+
name|root
operator|.
name|getClass
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**      * Push a string on the balance stack (BAP95).  BAP95 uses an array and      * calls the elements in the array 'bins'.  We instead use a stack, so the      * 'bins' of lengths are represented by differences between the elements of      * minLengthByDepth.      *      *<p>If the length bin for our string, and all shorter length bins, are      * empty, we just push it on the stack.  Otherwise, we need to start      * concatenating, putting the given string in the "middle" and continuing      * until we land in an empty length bin that matches the length of our      * concatenation.      *      * @param byteString string to place on the balance stack      */
specifier|private
name|void
name|insert
parameter_list|(
name|ByteString
name|byteString
parameter_list|)
block|{
name|int
name|depthBin
init|=
name|getDepthBinForLength
argument_list|(
name|byteString
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|binEnd
init|=
name|minLengthByDepth
index|[
name|depthBin
operator|+
literal|1
index|]
decl_stmt|;
comment|// BAP95: Concatenate all trees occupying bins representing the length of
comment|// our new piece or of shorter pieces, to the extent that is possible.
comment|// The goal is to clear the bin which our piece belongs in, but that may
comment|// not be entirely possible if there aren't enough longer bins occupied.
if|if
condition|(
name|prefixesStack
operator|.
name|isEmpty
argument_list|()
operator|||
name|prefixesStack
operator|.
name|peek
argument_list|()
operator|.
name|size
argument_list|()
operator|>=
name|binEnd
condition|)
block|{
name|prefixesStack
operator|.
name|push
argument_list|(
name|byteString
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|binStart
init|=
name|minLengthByDepth
index|[
name|depthBin
index|]
decl_stmt|;
comment|// Concatenate the subtrees of shorter length
name|ByteString
name|newTree
init|=
name|prefixesStack
operator|.
name|pop
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|prefixesStack
operator|.
name|isEmpty
argument_list|()
operator|&&
name|prefixesStack
operator|.
name|peek
argument_list|()
operator|.
name|size
argument_list|()
operator|<
name|binStart
condition|)
block|{
name|ByteString
name|left
init|=
name|prefixesStack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|newTree
operator|=
operator|new
name|RopeByteString
argument_list|(
name|left
argument_list|,
name|newTree
argument_list|)
expr_stmt|;
block|}
comment|// Concatenate the given string
name|newTree
operator|=
operator|new
name|RopeByteString
argument_list|(
name|newTree
argument_list|,
name|byteString
argument_list|)
expr_stmt|;
comment|// Continue concatenating until we land in an empty bin
while|while
condition|(
operator|!
name|prefixesStack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|depthBin
operator|=
name|getDepthBinForLength
argument_list|(
name|newTree
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|binEnd
operator|=
name|minLengthByDepth
index|[
name|depthBin
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|prefixesStack
operator|.
name|peek
argument_list|()
operator|.
name|size
argument_list|()
operator|<
name|binEnd
condition|)
block|{
name|ByteString
name|left
init|=
name|prefixesStack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|newTree
operator|=
operator|new
name|RopeByteString
argument_list|(
name|left
argument_list|,
name|newTree
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|prefixesStack
operator|.
name|push
argument_list|(
name|newTree
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|int
name|getDepthBinForLength
parameter_list|(
name|int
name|length
parameter_list|)
block|{
name|int
name|depth
init|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|minLengthByDepth
argument_list|,
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|depth
operator|<
literal|0
condition|)
block|{
comment|// It wasn't an exact match, so convert to the index of the containing
comment|// fragment, which is one less even than the insertion point.
name|int
name|insertionPoint
init|=
operator|-
operator|(
name|depth
operator|+
literal|1
operator|)
decl_stmt|;
name|depth
operator|=
name|insertionPoint
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|depth
return|;
block|}
block|}
comment|/**    * This class is a continuable tree traversal, which keeps the state    * information which would exist on the stack in a recursive traversal instead    * on a stack of "Bread Crumbs". The maximum depth of the stack in this    * iterator is the same as the depth of the tree being traversed.    *    *<p>This iterator is used to implement    * {@link RopeByteString#equalsFragments(ByteString)}.    */
specifier|private
specifier|static
class|class
name|PieceIterator
implements|implements
name|Iterator
argument_list|<
name|LeafByteString
argument_list|>
block|{
specifier|private
specifier|final
name|Stack
argument_list|<
name|RopeByteString
argument_list|>
name|breadCrumbs
init|=
operator|new
name|Stack
argument_list|<
name|RopeByteString
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|LeafByteString
name|next
decl_stmt|;
specifier|private
name|PieceIterator
parameter_list|(
name|ByteString
name|root
parameter_list|)
block|{
name|next
operator|=
name|getLeafByLeft
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
specifier|private
name|LeafByteString
name|getLeafByLeft
parameter_list|(
name|ByteString
name|root
parameter_list|)
block|{
name|ByteString
name|pos
init|=
name|root
decl_stmt|;
while|while
condition|(
name|pos
operator|instanceof
name|RopeByteString
condition|)
block|{
name|RopeByteString
name|rbs
init|=
operator|(
name|RopeByteString
operator|)
name|pos
decl_stmt|;
name|breadCrumbs
operator|.
name|push
argument_list|(
name|rbs
argument_list|)
expr_stmt|;
name|pos
operator|=
name|rbs
operator|.
name|left
expr_stmt|;
block|}
return|return
operator|(
name|LeafByteString
operator|)
name|pos
return|;
block|}
specifier|private
name|LeafByteString
name|getNextNonEmptyLeaf
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
comment|// Almost always, we go through this loop exactly once.  However, if
comment|// we discover an empty string in the rope, we toss it and try again.
if|if
condition|(
name|breadCrumbs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|LeafByteString
name|result
init|=
name|getLeafByLeft
argument_list|(
name|breadCrumbs
operator|.
name|pop
argument_list|()
operator|.
name|right
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|next
operator|!=
literal|null
return|;
block|}
comment|/**      * Returns the next item and advances one      * {@link org.apache.hadoop.hbase.shaded.com.google.protobuf.ByteString.LeafByteString}.      *      * @return next non-empty LeafByteString or {@code null}      */
annotation|@
name|Override
specifier|public
name|LeafByteString
name|next
parameter_list|()
block|{
if|if
condition|(
name|next
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|LeafByteString
name|result
init|=
name|next
decl_stmt|;
name|next
operator|=
name|getNextNonEmptyLeaf
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
comment|// =================================================================
comment|// Serializable
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
name|Object
name|writeReplace
parameter_list|()
block|{
return|return
name|ByteString
operator|.
name|wrap
argument_list|(
name|toByteArray
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|void
name|readObject
parameter_list|(
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
name|ObjectInputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|InvalidObjectException
argument_list|(
literal|"RopeByteStream instances are not to be serialized directly"
argument_list|)
throw|;
block|}
comment|/**    * This class is the {@link RopeByteString} equivalent for    * {@link ByteArrayInputStream}.    */
specifier|private
class|class
name|RopeInputStream
extends|extends
name|InputStream
block|{
comment|// Iterates through the pieces of the rope
specifier|private
name|PieceIterator
name|pieceIterator
decl_stmt|;
comment|// The current piece
specifier|private
name|LeafByteString
name|currentPiece
decl_stmt|;
comment|// The size of the current piece
specifier|private
name|int
name|currentPieceSize
decl_stmt|;
comment|// The index of the next byte to read in the current piece
specifier|private
name|int
name|currentPieceIndex
decl_stmt|;
comment|// The offset of the start of the current piece in the rope byte string
specifier|private
name|int
name|currentPieceOffsetInRope
decl_stmt|;
comment|// Offset in the buffer at which user called mark();
specifier|private
name|int
name|mark
decl_stmt|;
specifier|public
name|RopeInputStream
parameter_list|()
block|{
name|initialize
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|(
name|byte
name|b
index|[]
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
name|b
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|length
argument_list|<
literal|0
operator|||
name|length
argument_list|>
name|b
operator|.
name|length
operator|-
name|offset
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|()
throw|;
block|}
return|return
name|readSkipInternal
argument_list|(
name|b
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|skip
parameter_list|(
name|long
name|length
parameter_list|)
block|{
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|()
throw|;
block|}
elseif|else
if|if
condition|(
name|length
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
name|length
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
return|return
name|readSkipInternal
argument_list|(
literal|null
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|length
argument_list|)
return|;
block|}
comment|/**      * Internal implementation of read and skip.  If b != null, then read the      * next {@code length} bytes into the buffer {@code b} at      * offset {@code offset}.  If b == null, then skip the next {@code length}      * bytes.      *<p>      * This method assumes that all error checking has already happened.      *<p>      * Returns the actual number of bytes read or skipped.      */
specifier|private
name|int
name|readSkipInternal
parameter_list|(
name|byte
name|b
index|[]
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|bytesRemaining
init|=
name|length
decl_stmt|;
while|while
condition|(
name|bytesRemaining
operator|>
literal|0
condition|)
block|{
name|advanceIfCurrentPieceFullyRead
argument_list|()
expr_stmt|;
if|if
condition|(
name|currentPiece
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|bytesRemaining
operator|==
name|length
condition|)
block|{
comment|// We didn't manage to read anything
return|return
operator|-
literal|1
return|;
block|}
break|break;
block|}
else|else
block|{
comment|// Copy the bytes from this piece.
name|int
name|currentPieceRemaining
init|=
name|currentPieceSize
operator|-
name|currentPieceIndex
decl_stmt|;
name|int
name|count
init|=
name|Math
operator|.
name|min
argument_list|(
name|currentPieceRemaining
argument_list|,
name|bytesRemaining
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|!=
literal|null
condition|)
block|{
name|currentPiece
operator|.
name|copyTo
argument_list|(
name|b
argument_list|,
name|currentPieceIndex
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|count
expr_stmt|;
block|}
name|currentPieceIndex
operator|+=
name|count
expr_stmt|;
name|bytesRemaining
operator|-=
name|count
expr_stmt|;
block|}
block|}
comment|// Return the number of bytes read.
return|return
name|length
operator|-
name|bytesRemaining
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
name|advanceIfCurrentPieceFullyRead
argument_list|()
expr_stmt|;
if|if
condition|(
name|currentPiece
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
name|currentPiece
operator|.
name|byteAt
argument_list|(
name|currentPieceIndex
operator|++
argument_list|)
operator|&
literal|0xFF
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|available
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|bytesRead
init|=
name|currentPieceOffsetInRope
operator|+
name|currentPieceIndex
decl_stmt|;
return|return
name|RopeByteString
operator|.
name|this
operator|.
name|size
argument_list|()
operator|-
name|bytesRead
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|markSupported
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|mark
parameter_list|(
name|int
name|readAheadLimit
parameter_list|)
block|{
comment|// Set the mark to our position in the byte string
name|mark
operator|=
name|currentPieceOffsetInRope
operator|+
name|currentPieceIndex
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|reset
parameter_list|()
block|{
comment|// Just reinitialize and skip the specified number of bytes.
name|initialize
argument_list|()
expr_stmt|;
name|readSkipInternal
argument_list|(
literal|null
argument_list|,
literal|0
argument_list|,
name|mark
argument_list|)
expr_stmt|;
block|}
comment|/** Common initialization code used by both the constructor and reset() */
specifier|private
name|void
name|initialize
parameter_list|()
block|{
name|pieceIterator
operator|=
operator|new
name|PieceIterator
argument_list|(
name|RopeByteString
operator|.
name|this
argument_list|)
expr_stmt|;
name|currentPiece
operator|=
name|pieceIterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|currentPieceSize
operator|=
name|currentPiece
operator|.
name|size
argument_list|()
expr_stmt|;
name|currentPieceIndex
operator|=
literal|0
expr_stmt|;
name|currentPieceOffsetInRope
operator|=
literal|0
expr_stmt|;
block|}
comment|/**      * Skips to the next piece if we have read all the data in the current      * piece.  Sets currentPiece to null if we have reached the end of the      * input.      */
specifier|private
name|void
name|advanceIfCurrentPieceFullyRead
parameter_list|()
block|{
if|if
condition|(
name|currentPiece
operator|!=
literal|null
operator|&&
name|currentPieceIndex
operator|==
name|currentPieceSize
condition|)
block|{
comment|// Generally, we can only go through this loop at most once, since
comment|// empty strings can't end up in a rope.  But better to test.
name|currentPieceOffsetInRope
operator|+=
name|currentPieceSize
expr_stmt|;
name|currentPieceIndex
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pieceIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|currentPiece
operator|=
name|pieceIterator
operator|.
name|next
argument_list|()
expr_stmt|;
name|currentPieceSize
operator|=
name|currentPiece
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|currentPiece
operator|=
literal|null
expr_stmt|;
name|currentPieceSize
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

