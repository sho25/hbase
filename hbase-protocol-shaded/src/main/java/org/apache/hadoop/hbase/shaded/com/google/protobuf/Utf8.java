begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|// Protocol Buffers - Google's data interchange format
end_comment

begin_comment
comment|// Copyright 2008 Google Inc.  All rights reserved.
end_comment

begin_comment
comment|// https://developers.google.com/protocol-buffers/
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Redistribution and use in source and binary forms, with or without
end_comment

begin_comment
comment|// modification, are permitted provided that the following conditions are
end_comment

begin_comment
comment|// met:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//     * Redistributions of source code must retain the above copyright
end_comment

begin_comment
comment|// notice, this list of conditions and the following disclaimer.
end_comment

begin_comment
comment|//     * Redistributions in binary form must reproduce the above
end_comment

begin_comment
comment|// copyright notice, this list of conditions and the following disclaimer
end_comment

begin_comment
comment|// in the documentation and/or other materials provided with the
end_comment

begin_comment
comment|// distribution.
end_comment

begin_comment
comment|//     * Neither the name of Google Inc. nor the names of its
end_comment

begin_comment
comment|// contributors may be used to endorse or promote products derived from
end_comment

begin_comment
comment|// this software without specific prior written permission.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
end_comment

begin_comment
comment|// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
end_comment

begin_comment
comment|// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
end_comment

begin_comment
comment|// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
end_comment

begin_comment
comment|// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
end_comment

begin_comment
comment|// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
end_comment

begin_comment
comment|// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
end_comment

begin_comment
comment|// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
end_comment

begin_comment
comment|// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|UnsafeUtil
operator|.
name|addressOffset
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|UnsafeUtil
operator|.
name|getArrayBaseOffset
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|UnsafeUtil
operator|.
name|hasUnsafeArrayOperations
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|UnsafeUtil
operator|.
name|hasUnsafeByteBufferOperations
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|Character
operator|.
name|MAX_SURROGATE
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|Character
operator|.
name|MIN_SURROGATE
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|Character
operator|.
name|isSurrogatePair
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|Character
operator|.
name|toCodePoint
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_comment
comment|/**  * A set of low-level, high-performance static utility methods related  * to the UTF-8 character encoding.  This class has no dependencies  * outside of the core JDK libraries.  *  *<p>There are several variants of UTF-8.  The one implemented by  * this class is the restricted definition of UTF-8 introduced in  * Unicode 3.1, which mandates the rejection of "overlong" byte  * sequences as well as rejection of 3-byte surrogate codepoint byte  * sequences.  Note that the UTF-8 decoder included in Oracle's JDK  * has been modified to also reject "overlong" byte sequences, but (as  * of 2011) still accepts 3-byte surrogate codepoint byte sequences.  *  *<p>The byte sequences considered valid by this class are exactly  * those that can be roundtrip converted to Strings and back to bytes  * using the UTF-8 charset, without loss:<pre> {@code  * Arrays.equals(bytes, new String(bytes, Internal.UTF_8).getBytes(Internal.UTF_8))  * }</pre>  *  *<p>See the Unicode Standard,</br>  * Table 3-6.<em>UTF-8 Bit Distribution</em>,</br>  * Table 3-7.<em>Well Formed UTF-8 Byte Sequences</em>.  *  *<p>This class supports decoding of partial byte sequences, so that the  * bytes in a complete UTF-8 byte sequences can be stored in multiple  * segments.  Methods typically return {@link #MALFORMED} if the partial  * byte sequence is definitely not well-formed, {@link #COMPLETE} if it is  * well-formed in the absence of additional input, or if the byte sequence  * apparently terminated in the middle of a character, an opaque integer  * "state" value containing enough information to decode the character when  * passed to a subsequent invocation of a partial decoding method.  *  * @author martinrb@google.com (Martin Buchholz)  */
end_comment

begin_comment
comment|// TODO(nathanmittler): Copy changes in this class back to Guava
end_comment

begin_class
specifier|final
class|class
name|Utf8
block|{
comment|/**    * UTF-8 is a runtime hot spot so we attempt to provide heavily optimized implementations    * depending on what is available on the platform. The processor is the platform-optimized    * delegate for which all methods are delegated directly to.    */
specifier|private
specifier|static
specifier|final
name|Processor
name|processor
init|=
name|UnsafeProcessor
operator|.
name|isAvailable
argument_list|()
condition|?
operator|new
name|UnsafeProcessor
argument_list|()
else|:
operator|new
name|SafeProcessor
argument_list|()
decl_stmt|;
comment|/**    * A mask used when performing unsafe reads to determine if a long value contains any non-ASCII    * characters (i.e. any byte>= 0x80).    */
specifier|private
specifier|static
specifier|final
name|long
name|ASCII_MASK_LONG
init|=
literal|0x8080808080808080L
decl_stmt|;
comment|/**    * Maximum number of bytes per Java UTF-16 char in UTF-8.    * @see java.nio.charset.CharsetEncoder#maxBytesPerChar()    */
specifier|static
specifier|final
name|int
name|MAX_BYTES_PER_CHAR
init|=
literal|3
decl_stmt|;
comment|/**    * State value indicating that the byte sequence is well-formed and    * complete (no further bytes are needed to complete a character).    */
specifier|public
specifier|static
specifier|final
name|int
name|COMPLETE
init|=
literal|0
decl_stmt|;
comment|/**    * State value indicating that the byte sequence is definitely not    * well-formed.    */
specifier|public
specifier|static
specifier|final
name|int
name|MALFORMED
init|=
operator|-
literal|1
decl_stmt|;
comment|/**    * Used by {@code Unsafe} UTF-8 string validation logic to determine the minimum string length    * above which to employ an optimized algorithm for counting ASCII characters. The reason for this    * threshold is that for small strings, the optimization may not be beneficial or may even    * negatively impact performance since it requires additional logic to avoid unaligned reads    * (when calling {@code Unsafe.getLong}). This threshold guarantees that even if the initial    * offset is unaligned, we're guaranteed to make at least one call to {@code Unsafe.getLong()}    * which provides a performance improvement that entirely subsumes the cost of the additional    * logic.    */
specifier|private
specifier|static
specifier|final
name|int
name|UNSAFE_COUNT_ASCII_THRESHOLD
init|=
literal|16
decl_stmt|;
comment|// Other state values include the partial bytes of the incomplete
comment|// character to be decoded in the simplest way: we pack the bytes
comment|// into the state int in little-endian order.  For example:
comment|//
comment|// int state = byte1 ^ (byte2<< 8) ^ (byte3<< 16);
comment|//
comment|// Such a state is unpacked thus (note the ~ operation for byte2 to
comment|// undo byte1's sign-extension bits):
comment|//
comment|// int byte1 = (byte) state;
comment|// int byte2 = (byte) ~(state>> 8);
comment|// int byte3 = (byte) (state>> 16);
comment|//
comment|// We cannot store a zero byte in the state because it would be
comment|// indistinguishable from the absence of a byte.  But we don't need
comment|// to, because partial bytes must always be negative.  When building
comment|// a state, we ensure that byte1 is negative and subsequent bytes
comment|// are valid trailing bytes.
comment|/**    * Returns {@code true} if the given byte array is a well-formed    * UTF-8 byte sequence.    *    *<p>This is a convenience method, equivalent to a call to {@code    * isValidUtf8(bytes, 0, bytes.length)}.    */
specifier|public
specifier|static
name|boolean
name|isValidUtf8
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|)
block|{
return|return
name|processor
operator|.
name|isValidUtf8
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * Returns {@code true} if the given byte array slice is a    * well-formed UTF-8 byte sequence.  The range of bytes to be    * checked extends from index {@code index}, inclusive, to {@code    * limit}, exclusive.    *    *<p>This is a convenience method, equivalent to {@code    * partialIsValidUtf8(bytes, index, limit) == Utf8.COMPLETE}.    */
specifier|public
specifier|static
name|boolean
name|isValidUtf8
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
return|return
name|processor
operator|.
name|isValidUtf8
argument_list|(
name|bytes
argument_list|,
name|index
argument_list|,
name|limit
argument_list|)
return|;
block|}
comment|/**    * Tells whether the given byte array slice is a well-formed,    * malformed, or incomplete UTF-8 byte sequence.  The range of bytes    * to be checked extends from index {@code index}, inclusive, to    * {@code limit}, exclusive.    *    * @param state either {@link Utf8#COMPLETE} (if this is the initial decoding    * operation) or the value returned from a call to a partial decoding method    * for the previous bytes    *    * @return {@link #MALFORMED} if the partial byte sequence is    * definitely not well-formed, {@link #COMPLETE} if it is well-formed    * (no additional input needed), or if the byte sequence is    * "incomplete", i.e. apparently terminated in the middle of a character,    * an opaque integer "state" value containing enough information to    * decode the character when passed to a subsequent invocation of a    * partial decoding method.    */
specifier|public
specifier|static
name|int
name|partialIsValidUtf8
parameter_list|(
name|int
name|state
parameter_list|,
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
return|return
name|processor
operator|.
name|partialIsValidUtf8
argument_list|(
name|state
argument_list|,
name|bytes
argument_list|,
name|index
argument_list|,
name|limit
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|int
name|incompleteStateFor
parameter_list|(
name|int
name|byte1
parameter_list|)
block|{
return|return
operator|(
name|byte1
operator|>
operator|(
name|byte
operator|)
literal|0xF4
operator|)
condition|?
name|MALFORMED
else|:
name|byte1
return|;
block|}
specifier|private
specifier|static
name|int
name|incompleteStateFor
parameter_list|(
name|int
name|byte1
parameter_list|,
name|int
name|byte2
parameter_list|)
block|{
return|return
operator|(
name|byte1
operator|>
operator|(
name|byte
operator|)
literal|0xF4
operator|||
name|byte2
operator|>
operator|(
name|byte
operator|)
literal|0xBF
operator|)
condition|?
name|MALFORMED
else|:
name|byte1
operator|^
operator|(
name|byte2
operator|<<
literal|8
operator|)
return|;
block|}
specifier|private
specifier|static
name|int
name|incompleteStateFor
parameter_list|(
name|int
name|byte1
parameter_list|,
name|int
name|byte2
parameter_list|,
name|int
name|byte3
parameter_list|)
block|{
return|return
operator|(
name|byte1
operator|>
operator|(
name|byte
operator|)
literal|0xF4
operator|||
name|byte2
operator|>
operator|(
name|byte
operator|)
literal|0xBF
operator|||
name|byte3
operator|>
operator|(
name|byte
operator|)
literal|0xBF
operator|)
condition|?
name|MALFORMED
else|:
name|byte1
operator|^
operator|(
name|byte2
operator|<<
literal|8
operator|)
operator|^
operator|(
name|byte3
operator|<<
literal|16
operator|)
return|;
block|}
specifier|private
specifier|static
name|int
name|incompleteStateFor
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|int
name|byte1
init|=
name|bytes
index|[
name|index
operator|-
literal|1
index|]
decl_stmt|;
switch|switch
condition|(
name|limit
operator|-
name|index
condition|)
block|{
case|case
literal|0
case|:
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|)
return|;
case|case
literal|1
case|:
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|,
name|bytes
index|[
name|index
index|]
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|,
name|bytes
index|[
name|index
index|]
argument_list|,
name|bytes
index|[
name|index
operator|+
literal|1
index|]
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
specifier|private
specifier|static
name|int
name|incompleteStateFor
parameter_list|(
specifier|final
name|ByteBuffer
name|buffer
parameter_list|,
specifier|final
name|int
name|byte1
parameter_list|,
specifier|final
name|int
name|index
parameter_list|,
specifier|final
name|int
name|remaining
parameter_list|)
block|{
switch|switch
condition|(
name|remaining
condition|)
block|{
case|case
literal|0
case|:
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|)
return|;
case|case
literal|1
case|:
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|,
name|buffer
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|,
name|buffer
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|,
name|buffer
operator|.
name|get
argument_list|(
name|index
operator|+
literal|1
argument_list|)
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
specifier|private
specifier|static
name|int
name|incompleteStateFor
parameter_list|(
name|ByteInput
name|bytes
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|int
name|byte1
init|=
name|bytes
operator|.
name|read
argument_list|(
name|index
operator|-
literal|1
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|limit
operator|-
name|index
condition|)
block|{
case|case
literal|0
case|:
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|)
return|;
case|case
literal|1
case|:
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|,
name|bytes
operator|.
name|read
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|,
name|bytes
operator|.
name|read
argument_list|(
name|index
argument_list|)
argument_list|,
name|bytes
operator|.
name|read
argument_list|(
name|index
operator|+
literal|1
argument_list|)
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
comment|// These UTF-8 handling methods are copied from Guava's Utf8 class with a modification to throw
comment|// a protocol buffer local exception. This exception is then caught in CodedOutputStream so it can
comment|// fallback to more lenient behavior.
specifier|static
class|class
name|UnpairedSurrogateException
extends|extends
name|IllegalArgumentException
block|{
name|UnpairedSurrogateException
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|super
argument_list|(
literal|"Unpaired surrogate at index "
operator|+
name|index
operator|+
literal|" of "
operator|+
name|length
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns the number of bytes in the UTF-8-encoded form of {@code sequence}. For a string,    * this method is equivalent to {@code string.getBytes(UTF_8).length}, but is more efficient in    * both time and space.    *    * @throws IllegalArgumentException if {@code sequence} contains ill-formed UTF-16 (unpaired    *     surrogates)    */
specifier|static
name|int
name|encodedLength
parameter_list|(
name|CharSequence
name|sequence
parameter_list|)
block|{
comment|// Warning to maintainers: this implementation is highly optimized.
name|int
name|utf16Length
init|=
name|sequence
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|utf8Length
init|=
name|utf16Length
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|// This loop optimizes for pure ASCII.
while|while
condition|(
name|i
operator|<
name|utf16Length
operator|&&
name|sequence
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|<
literal|0x80
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
comment|// This loop optimizes for chars less than 0x800.
for|for
control|(
init|;
name|i
operator|<
name|utf16Length
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|sequence
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|<
literal|0x800
condition|)
block|{
name|utf8Length
operator|+=
operator|(
operator|(
literal|0x7f
operator|-
name|c
operator|)
operator|>>>
literal|31
operator|)
expr_stmt|;
comment|// branch free!
block|}
else|else
block|{
name|utf8Length
operator|+=
name|encodedLengthGeneral
argument_list|(
name|sequence
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|utf8Length
operator|<
name|utf16Length
condition|)
block|{
comment|// Necessary and sufficient condition for overflow because of maximum 3x expansion
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"UTF-8 length does not fit in int: "
operator|+
operator|(
name|utf8Length
operator|+
operator|(
literal|1L
operator|<<
literal|32
operator|)
operator|)
argument_list|)
throw|;
block|}
return|return
name|utf8Length
return|;
block|}
specifier|private
specifier|static
name|int
name|encodedLengthGeneral
parameter_list|(
name|CharSequence
name|sequence
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|int
name|utf16Length
init|=
name|sequence
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|utf8Length
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|utf16Length
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|sequence
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|<
literal|0x800
condition|)
block|{
name|utf8Length
operator|+=
operator|(
literal|0x7f
operator|-
name|c
operator|)
operator|>>>
literal|31
expr_stmt|;
comment|// branch free!
block|}
else|else
block|{
name|utf8Length
operator|+=
literal|2
expr_stmt|;
comment|// jdk7+: if (Character.isSurrogate(c)) {
if|if
condition|(
name|Character
operator|.
name|MIN_SURROGATE
operator|<=
name|c
operator|&&
name|c
operator|<=
name|Character
operator|.
name|MAX_SURROGATE
condition|)
block|{
comment|// Check that we have a well-formed surrogate pair.
name|int
name|cp
init|=
name|Character
operator|.
name|codePointAt
argument_list|(
name|sequence
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp
operator|<
name|Character
operator|.
name|MIN_SUPPLEMENTARY_CODE_POINT
condition|)
block|{
throw|throw
operator|new
name|UnpairedSurrogateException
argument_list|(
name|i
argument_list|,
name|utf16Length
argument_list|)
throw|;
block|}
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|utf8Length
return|;
block|}
specifier|static
name|int
name|encode
parameter_list|(
name|CharSequence
name|in
parameter_list|,
name|byte
index|[]
name|out
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
return|return
name|processor
operator|.
name|encodeUtf8
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
comment|// End Guava UTF-8 methods.
comment|/**    * Determines if the given {@link ByteBuffer} is a valid UTF-8 string.    *    *<p>Selects an optimal algorithm based on the type of {@link ByteBuffer} (i.e. heap or direct)    * and the capabilities of the platform.    *    * @param buffer the buffer to check.    * @see Utf8#isValidUtf8(byte[], int, int)    */
specifier|static
name|boolean
name|isValidUtf8
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|)
block|{
return|return
name|processor
operator|.
name|isValidUtf8
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|.
name|position
argument_list|()
argument_list|,
name|buffer
operator|.
name|remaining
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Determines if the given {@link ByteBuffer} is a partially valid UTF-8 string.    *    *<p>Selects an optimal algorithm based on the type of {@link ByteBuffer} (i.e. heap or direct)    * and the capabilities of the platform.    *    * @param buffer the buffer to check.    * @see Utf8#partialIsValidUtf8(int, byte[], int, int)    */
specifier|static
name|int
name|partialIsValidUtf8
parameter_list|(
name|int
name|state
parameter_list|,
name|ByteBuffer
name|buffer
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
return|return
name|processor
operator|.
name|partialIsValidUtf8
argument_list|(
name|state
argument_list|,
name|buffer
argument_list|,
name|index
argument_list|,
name|limit
argument_list|)
return|;
block|}
comment|/**    * Determines if the given {@link ByteInput} is a valid UTF-8 string.    *    * @param buffer the buffer to check.    */
specifier|static
name|boolean
name|isValidUtf8
parameter_list|(
name|ByteInput
name|buffer
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
return|return
name|processor
operator|.
name|isValidUtf8
argument_list|(
name|buffer
argument_list|,
name|index
argument_list|,
name|limit
argument_list|)
return|;
block|}
comment|/**    * Determines if the given {@link ByteInput} is a partially valid UTF-8 string.    *    * @param buffer the buffer to check.    */
specifier|static
name|int
name|partialIsValidUtf8
parameter_list|(
name|int
name|state
parameter_list|,
name|ByteInput
name|buffer
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
return|return
name|processor
operator|.
name|partialIsValidUtf8
argument_list|(
name|state
argument_list|,
name|buffer
argument_list|,
name|index
argument_list|,
name|limit
argument_list|)
return|;
block|}
comment|/**    * Encodes the given characters to the target {@link ByteBuffer} using UTF-8 encoding.    *    *<p>Selects an optimal algorithm based on the type of {@link ByteBuffer} (i.e. heap or direct)    * and the capabilities of the platform.    *    * @param in the source string to be encoded    * @param out the target buffer to receive the encoded string.    * @see Utf8#encode(CharSequence, byte[], int, int)    */
specifier|static
name|void
name|encodeUtf8
parameter_list|(
name|CharSequence
name|in
parameter_list|,
name|ByteBuffer
name|out
parameter_list|)
block|{
name|processor
operator|.
name|encodeUtf8
argument_list|(
name|in
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
comment|/**    * Counts (approximately) the number of consecutive ASCII characters in the given buffer.    * The byte order of the {@link ByteBuffer} does not matter, so performance can be improved if    * native byte order is used (i.e. no byte-swapping in {@link ByteBuffer#getLong(int)}).    *    * @param buffer the buffer to be scanned for ASCII chars    * @param index the starting index of the scan    * @param limit the limit within buffer for the scan    * @return the number of ASCII characters found. The stopping position will be at or    * before the first non-ASCII byte.    */
specifier|private
specifier|static
name|int
name|estimateConsecutiveAscii
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|int
name|i
init|=
name|index
decl_stmt|;
specifier|final
name|int
name|lim
init|=
name|limit
operator|-
literal|7
decl_stmt|;
comment|// This simple loop stops when we encounter a byte>= 0x80 (i.e. non-ASCII).
comment|// To speed things up further, we're reading longs instead of bytes so we use a mask to
comment|// determine if any byte in the current long is non-ASCII.
for|for
control|(
init|;
name|i
operator|<
name|lim
operator|&&
operator|(
name|buffer
operator|.
name|getLong
argument_list|(
name|i
argument_list|)
operator|&
name|ASCII_MASK_LONG
operator|)
operator|==
literal|0
condition|;
name|i
operator|+=
literal|8
control|)
block|{}
return|return
name|i
operator|-
name|index
return|;
block|}
comment|/**    * A processor of UTF-8 strings, providing methods for checking validity and encoding.    */
comment|// TODO(nathanmittler): Add support for Memory/MemoryBlock on Android.
specifier|abstract
specifier|static
class|class
name|Processor
block|{
comment|/**      * Returns {@code true} if the given byte array slice is a      * well-formed UTF-8 byte sequence.  The range of bytes to be      * checked extends from index {@code index}, inclusive, to {@code      * limit}, exclusive.      *      *<p>This is a convenience method, equivalent to {@code      * partialIsValidUtf8(bytes, index, limit) == Utf8.COMPLETE}.      */
specifier|final
name|boolean
name|isValidUtf8
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
return|return
name|partialIsValidUtf8
argument_list|(
name|COMPLETE
argument_list|,
name|bytes
argument_list|,
name|index
argument_list|,
name|limit
argument_list|)
operator|==
name|COMPLETE
return|;
block|}
comment|/**      * Tells whether the given byte array slice is a well-formed,      * malformed, or incomplete UTF-8 byte sequence.  The range of bytes      * to be checked extends from index {@code index}, inclusive, to      * {@code limit}, exclusive.      *      * @param state either {@link Utf8#COMPLETE} (if this is the initial decoding      * operation) or the value returned from a call to a partial decoding method      * for the previous bytes      *      * @return {@link #MALFORMED} if the partial byte sequence is      * definitely not well-formed, {@link #COMPLETE} if it is well-formed      * (no additional input needed), or if the byte sequence is      * "incomplete", i.e. apparently terminated in the middle of a character,      * an opaque integer "state" value containing enough information to      * decode the character when passed to a subsequent invocation of a      * partial decoding method.      */
specifier|abstract
name|int
name|partialIsValidUtf8
parameter_list|(
name|int
name|state
parameter_list|,
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|limit
parameter_list|)
function_decl|;
comment|/**      * Returns {@code true} if the given portion of the {@link ByteBuffer} is a      * well-formed UTF-8 byte sequence.  The range of bytes to be      * checked extends from index {@code index}, inclusive, to {@code      * limit}, exclusive.      *      *<p>This is a convenience method, equivalent to {@code      * partialIsValidUtf8(bytes, index, limit) == Utf8.COMPLETE}.      */
specifier|final
name|boolean
name|isValidUtf8
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
return|return
name|partialIsValidUtf8
argument_list|(
name|COMPLETE
argument_list|,
name|buffer
argument_list|,
name|index
argument_list|,
name|limit
argument_list|)
operator|==
name|COMPLETE
return|;
block|}
comment|/**      * Indicates whether or not the given buffer contains a valid UTF-8 string.      *      * @param buffer the buffer to check.      * @return {@code true} if the given buffer contains a valid UTF-8 string.      */
specifier|final
name|int
name|partialIsValidUtf8
parameter_list|(
specifier|final
name|int
name|state
parameter_list|,
specifier|final
name|ByteBuffer
name|buffer
parameter_list|,
name|int
name|index
parameter_list|,
specifier|final
name|int
name|limit
parameter_list|)
block|{
if|if
condition|(
name|buffer
operator|.
name|hasArray
argument_list|()
condition|)
block|{
specifier|final
name|int
name|offset
init|=
name|buffer
operator|.
name|arrayOffset
argument_list|()
decl_stmt|;
return|return
name|partialIsValidUtf8
argument_list|(
name|state
argument_list|,
name|buffer
operator|.
name|array
argument_list|()
argument_list|,
name|offset
operator|+
name|index
argument_list|,
name|offset
operator|+
name|limit
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|buffer
operator|.
name|isDirect
argument_list|()
condition|)
block|{
return|return
name|partialIsValidUtf8Direct
argument_list|(
name|state
argument_list|,
name|buffer
argument_list|,
name|index
argument_list|,
name|limit
argument_list|)
return|;
block|}
return|return
name|partialIsValidUtf8Default
argument_list|(
name|state
argument_list|,
name|buffer
argument_list|,
name|index
argument_list|,
name|limit
argument_list|)
return|;
block|}
comment|/**      * Performs validation for direct {@link ByteBuffer} instances.      */
specifier|abstract
name|int
name|partialIsValidUtf8Direct
parameter_list|(
specifier|final
name|int
name|state
parameter_list|,
specifier|final
name|ByteBuffer
name|buffer
parameter_list|,
name|int
name|index
parameter_list|,
specifier|final
name|int
name|limit
parameter_list|)
function_decl|;
comment|/**      * Performs validation for {@link ByteBuffer} instances using the {@link ByteBuffer} API rather      * than potentially faster approaches. This first completes validation for the current      * character (provided by {@code state}) and then finishes validation for the sequence.      */
specifier|final
name|int
name|partialIsValidUtf8Default
parameter_list|(
specifier|final
name|int
name|state
parameter_list|,
specifier|final
name|ByteBuffer
name|buffer
parameter_list|,
name|int
name|index
parameter_list|,
specifier|final
name|int
name|limit
parameter_list|)
block|{
if|if
condition|(
name|state
operator|!=
name|COMPLETE
condition|)
block|{
comment|// The previous decoding operation was incomplete (or malformed).
comment|// We look for a well-formed sequence consisting of bytes from
comment|// the previous decoding operation (stored in state) together
comment|// with bytes from the array slice.
comment|//
comment|// We expect such "straddler characters" to be rare.
if|if
condition|(
name|index
operator|>=
name|limit
condition|)
block|{
comment|// No bytes? No progress.
return|return
name|state
return|;
block|}
name|byte
name|byte1
init|=
operator|(
name|byte
operator|)
name|state
decl_stmt|;
comment|// byte1 is never ASCII.
if|if
condition|(
name|byte1
operator|<
operator|(
name|byte
operator|)
literal|0xE0
condition|)
block|{
comment|// two-byte form
comment|// Simultaneously checks for illegal trailing-byte in
comment|// leading position and overlong 2-byte form.
if|if
condition|(
name|byte1
argument_list|<
operator|(
name|byte
operator|)
literal|0xC2
comment|// byte2 trailing-byte test
operator|||
name|buffer
operator|.
name|get
operator|(
name|index
operator|++
operator|)
argument_list|>
argument_list|(
name|byte
argument_list|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|byte1
operator|<
operator|(
name|byte
operator|)
literal|0xF0
condition|)
block|{
comment|// three-byte form
comment|// Get byte2 from saved state or array
name|byte
name|byte2
init|=
operator|(
name|byte
operator|)
operator|~
operator|(
name|state
operator|>>
literal|8
operator|)
decl_stmt|;
if|if
condition|(
name|byte2
operator|==
literal|0
condition|)
block|{
name|byte2
operator|=
name|buffer
operator|.
name|get
argument_list|(
name|index
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|limit
condition|)
block|{
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|,
name|byte2
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|byte2
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// overlong? 5 most significant bits must not all be zero
operator|||
operator|(
name|byte1
operator|==
operator|(
name|byte
operator|)
literal|0xE0
operator|&&
name|byte2
operator|<
operator|(
name|byte
operator|)
literal|0xA0
operator|)
comment|// illegal surrogate codepoint?
operator|||
operator|(
name|byte1
operator|==
operator|(
name|byte
operator|)
literal|0xED
operator|&&
name|byte2
operator|>=
operator|(
name|byte
operator|)
literal|0xA0
operator|)
comment|// byte3 trailing-byte test
operator|||
name|buffer
operator|.
name|get
argument_list|(
name|index
operator|++
argument_list|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
else|else
block|{
comment|// four-byte form
comment|// Get byte2 and byte3 from saved state or array
name|byte
name|byte2
init|=
operator|(
name|byte
operator|)
operator|~
operator|(
name|state
operator|>>
literal|8
operator|)
decl_stmt|;
name|byte
name|byte3
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|byte2
operator|==
literal|0
condition|)
block|{
name|byte2
operator|=
name|buffer
operator|.
name|get
argument_list|(
name|index
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|limit
condition|)
block|{
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|,
name|byte2
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|byte3
operator|=
call|(
name|byte
call|)
argument_list|(
name|state
operator|>>
literal|16
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|byte3
operator|==
literal|0
condition|)
block|{
name|byte3
operator|=
name|buffer
operator|.
name|get
argument_list|(
name|index
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|limit
condition|)
block|{
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|,
name|byte2
argument_list|,
name|byte3
argument_list|)
return|;
block|}
block|}
comment|// If we were called with state == MALFORMED, then byte1 is 0xFF,
comment|// which never occurs in well-formed UTF-8, and so we will return
comment|// MALFORMED again below.
if|if
condition|(
name|byte2
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// Check that 1<= plane<= 16.  Tricky optimized form of:
comment|// if (byte1> (byte) 0xF4 ||
comment|//     byte1 == (byte) 0xF0&& byte2< (byte) 0x90 ||
comment|//     byte1 == (byte) 0xF4&& byte2> (byte) 0x8F)
operator|||
operator|(
operator|(
operator|(
name|byte1
operator|<<
literal|28
operator|)
operator|+
operator|(
name|byte2
operator|-
operator|(
name|byte
operator|)
literal|0x90
operator|)
operator|)
operator|>>
literal|30
operator|)
operator|!=
literal|0
comment|// byte3 trailing-byte test
operator|||
name|byte3
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// byte4 trailing-byte test
operator|||
name|buffer
operator|.
name|get
argument_list|(
name|index
operator|++
argument_list|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
block|}
comment|// Finish validation for the sequence.
return|return
name|partialIsValidUtf8
argument_list|(
name|buffer
argument_list|,
name|index
argument_list|,
name|limit
argument_list|)
return|;
block|}
comment|/**      * Performs validation for {@link ByteBuffer} instances using the {@link ByteBuffer} API rather      * than potentially faster approaches.      */
specifier|private
specifier|static
name|int
name|partialIsValidUtf8
parameter_list|(
specifier|final
name|ByteBuffer
name|buffer
parameter_list|,
name|int
name|index
parameter_list|,
specifier|final
name|int
name|limit
parameter_list|)
block|{
name|index
operator|+=
name|estimateConsecutiveAscii
argument_list|(
name|buffer
argument_list|,
name|index
argument_list|,
name|limit
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|// Optimize for interior runs of ASCII bytes.
comment|// TODO(nathanmittler): Consider checking 8 bytes at a time after some threshold?
comment|// Maybe after seeing a few in a row that are ASCII, go back to fast mode?
name|int
name|byte1
decl_stmt|;
do|do
block|{
if|if
condition|(
name|index
operator|>=
name|limit
condition|)
block|{
return|return
name|COMPLETE
return|;
block|}
block|}
do|while
condition|(
operator|(
name|byte1
operator|=
name|buffer
operator|.
name|get
argument_list|(
name|index
operator|++
argument_list|)
operator|)
operator|>=
literal|0
condition|)
do|;
comment|// If we're here byte1 is not ASCII. Only need to handle 2-4 byte forms.
if|if
condition|(
name|byte1
operator|<
operator|(
name|byte
operator|)
literal|0xE0
condition|)
block|{
comment|// Two-byte form (110xxxxx 10xxxxxx)
if|if
condition|(
name|index
operator|>=
name|limit
condition|)
block|{
comment|// Incomplete sequence
return|return
name|byte1
return|;
block|}
comment|// Simultaneously checks for illegal trailing-byte in
comment|// leading position and overlong 2-byte form.
if|if
condition|(
name|byte1
argument_list|<
operator|(
name|byte
operator|)
literal|0xC2
operator|||
name|buffer
operator|.
name|get
operator|(
name|index
operator|)
argument_list|>
argument_list|(
name|byte
argument_list|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
name|index
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|byte1
operator|<
operator|(
name|byte
operator|)
literal|0xF0
condition|)
block|{
comment|// Three-byte form (1110xxxx 10xxxxxx 10xxxxxx)
if|if
condition|(
name|index
operator|>=
name|limit
operator|-
literal|1
condition|)
block|{
comment|// Incomplete sequence
return|return
name|incompleteStateFor
argument_list|(
name|buffer
argument_list|,
name|byte1
argument_list|,
name|index
argument_list|,
name|limit
operator|-
name|index
argument_list|)
return|;
block|}
specifier|final
name|byte
name|byte2
init|=
name|buffer
operator|.
name|get
argument_list|(
name|index
operator|++
argument_list|)
decl_stmt|;
if|if
condition|(
name|byte2
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// overlong? 5 most significant bits must not all be zero
operator|||
operator|(
name|byte1
operator|==
operator|(
name|byte
operator|)
literal|0xE0
operator|&&
name|byte2
operator|<
operator|(
name|byte
operator|)
literal|0xA0
operator|)
comment|// check for illegal surrogate codepoints
operator|||
operator|(
name|byte1
operator|==
operator|(
name|byte
operator|)
literal|0xED
operator|&&
name|byte2
operator|>=
operator|(
name|byte
operator|)
literal|0xA0
operator|)
comment|// byte3 trailing-byte test
operator|||
name|buffer
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
name|index
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|// Four-byte form (1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx)
if|if
condition|(
name|index
operator|>=
name|limit
operator|-
literal|2
condition|)
block|{
comment|// Incomplete sequence
return|return
name|incompleteStateFor
argument_list|(
name|buffer
argument_list|,
name|byte1
argument_list|,
name|index
argument_list|,
name|limit
operator|-
name|index
argument_list|)
return|;
block|}
comment|// TODO(nathanmittler): Consider using getInt() to improve performance.
specifier|final
name|int
name|byte2
init|=
name|buffer
operator|.
name|get
argument_list|(
name|index
operator|++
argument_list|)
decl_stmt|;
if|if
condition|(
name|byte2
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// Check that 1<= plane<= 16.  Tricky optimized form of:
comment|// if (byte1> (byte) 0xF4 ||
comment|//     byte1 == (byte) 0xF0&& byte2< (byte) 0x90 ||
comment|//     byte1 == (byte) 0xF4&& byte2> (byte) 0x8F)
operator|||
operator|(
operator|(
operator|(
name|byte1
operator|<<
literal|28
operator|)
operator|+
operator|(
name|byte2
operator|-
operator|(
name|byte
operator|)
literal|0x90
operator|)
operator|)
operator|>>
literal|30
operator|)
operator|!=
literal|0
comment|// byte3 trailing-byte test
operator|||
name|buffer
operator|.
name|get
argument_list|(
name|index
operator|++
argument_list|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// byte4 trailing-byte test
operator|||
name|buffer
operator|.
name|get
argument_list|(
name|index
operator|++
argument_list|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
block|}
block|}
specifier|public
name|boolean
name|isValidUtf8
parameter_list|(
name|ByteInput
name|buffer
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
return|return
name|partialIsValidUtf8
argument_list|(
name|COMPLETE
argument_list|,
name|buffer
argument_list|,
name|index
argument_list|,
name|limit
argument_list|)
operator|==
name|COMPLETE
return|;
block|}
name|int
name|partialIsValidUtf8
parameter_list|(
name|int
name|state
parameter_list|,
name|ByteInput
name|bytes
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
if|if
condition|(
name|state
operator|!=
name|COMPLETE
condition|)
block|{
comment|// The previous decoding operation was incomplete (or malformed).
comment|// We look for a well-formed sequence consisting of bytes from
comment|// the previous decoding operation (stored in state) together
comment|// with bytes from the array slice.
comment|//
comment|// We expect such "straddler characters" to be rare.
if|if
condition|(
name|index
operator|>=
name|limit
condition|)
block|{
comment|// No bytes? No progress.
return|return
name|state
return|;
block|}
name|int
name|byte1
init|=
operator|(
name|byte
operator|)
name|state
decl_stmt|;
comment|// byte1 is never ASCII.
if|if
condition|(
name|byte1
operator|<
operator|(
name|byte
operator|)
literal|0xE0
condition|)
block|{
comment|// two-byte form
comment|// Simultaneously checks for illegal trailing-byte in
comment|// leading position and overlong 2-byte form.
if|if
condition|(
name|byte1
argument_list|<
operator|(
name|byte
operator|)
literal|0xC2
comment|// byte2 trailing-byte test
operator|||
name|bytes
operator|.
name|read
operator|(
name|index
operator|++
operator|)
argument_list|>
argument_list|(
name|byte
argument_list|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|byte1
operator|<
operator|(
name|byte
operator|)
literal|0xF0
condition|)
block|{
comment|// three-byte form
comment|// Get byte2 from saved state or array
name|int
name|byte2
init|=
operator|(
name|byte
operator|)
operator|~
operator|(
name|state
operator|>>
literal|8
operator|)
decl_stmt|;
if|if
condition|(
name|byte2
operator|==
literal|0
condition|)
block|{
name|byte2
operator|=
name|bytes
operator|.
name|read
argument_list|(
name|index
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|limit
condition|)
block|{
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|,
name|byte2
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|byte2
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// overlong? 5 most significant bits must not all be zero
operator|||
operator|(
name|byte1
operator|==
operator|(
name|byte
operator|)
literal|0xE0
operator|&&
name|byte2
operator|<
operator|(
name|byte
operator|)
literal|0xA0
operator|)
comment|// illegal surrogate codepoint?
operator|||
operator|(
name|byte1
operator|==
operator|(
name|byte
operator|)
literal|0xED
operator|&&
name|byte2
operator|>=
operator|(
name|byte
operator|)
literal|0xA0
operator|)
comment|// byte3 trailing-byte test
operator|||
name|bytes
operator|.
name|read
argument_list|(
name|index
operator|++
argument_list|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
else|else
block|{
comment|// four-byte form
comment|// Get byte2 and byte3 from saved state or array
name|int
name|byte2
init|=
operator|(
name|byte
operator|)
operator|~
operator|(
name|state
operator|>>
literal|8
operator|)
decl_stmt|;
name|int
name|byte3
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|byte2
operator|==
literal|0
condition|)
block|{
name|byte2
operator|=
name|bytes
operator|.
name|read
argument_list|(
name|index
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|limit
condition|)
block|{
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|,
name|byte2
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|byte3
operator|=
call|(
name|byte
call|)
argument_list|(
name|state
operator|>>
literal|16
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|byte3
operator|==
literal|0
condition|)
block|{
name|byte3
operator|=
name|bytes
operator|.
name|read
argument_list|(
name|index
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|limit
condition|)
block|{
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|,
name|byte2
argument_list|,
name|byte3
argument_list|)
return|;
block|}
block|}
comment|// If we were called with state == MALFORMED, then byte1 is 0xFF,
comment|// which never occurs in well-formed UTF-8, and so we will return
comment|// MALFORMED again below.
if|if
condition|(
name|byte2
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// Check that 1<= plane<= 16.  Tricky optimized form of:
comment|// if (byte1> (byte) 0xF4 ||
comment|//     byte1 == (byte) 0xF0&& byte2< (byte) 0x90 ||
comment|//     byte1 == (byte) 0xF4&& byte2> (byte) 0x8F)
operator|||
operator|(
operator|(
operator|(
name|byte1
operator|<<
literal|28
operator|)
operator|+
operator|(
name|byte2
operator|-
operator|(
name|byte
operator|)
literal|0x90
operator|)
operator|)
operator|>>
literal|30
operator|)
operator|!=
literal|0
comment|// byte3 trailing-byte test
operator|||
name|byte3
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// byte4 trailing-byte test
operator|||
name|bytes
operator|.
name|read
argument_list|(
name|index
operator|++
argument_list|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
block|}
return|return
name|partialIsValidUtf8
argument_list|(
name|bytes
argument_list|,
name|index
argument_list|,
name|limit
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|int
name|partialIsValidUtf8
parameter_list|(
name|ByteInput
name|bytes
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
comment|// Optimize for 100% ASCII (Hotspot loves small simple top-level loops like this).
comment|// This simple loop stops when we encounter a byte>= 0x80 (i.e. non-ASCII).
while|while
condition|(
name|index
operator|<
name|limit
operator|&&
name|bytes
operator|.
name|read
argument_list|(
name|index
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|index
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|index
operator|>=
name|limit
operator|)
condition|?
name|COMPLETE
else|:
name|partialIsValidUtf8NonAscii
argument_list|(
name|bytes
argument_list|,
name|index
argument_list|,
name|limit
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|int
name|partialIsValidUtf8NonAscii
parameter_list|(
name|ByteInput
name|bytes
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|byte1
decl_stmt|,
name|byte2
decl_stmt|;
comment|// Optimize for interior runs of ASCII bytes.
do|do
block|{
if|if
condition|(
name|index
operator|>=
name|limit
condition|)
block|{
return|return
name|COMPLETE
return|;
block|}
block|}
do|while
condition|(
operator|(
name|byte1
operator|=
name|bytes
operator|.
name|read
argument_list|(
name|index
operator|++
argument_list|)
operator|)
operator|>=
literal|0
condition|)
do|;
if|if
condition|(
name|byte1
operator|<
operator|(
name|byte
operator|)
literal|0xE0
condition|)
block|{
comment|// two-byte form
if|if
condition|(
name|index
operator|>=
name|limit
condition|)
block|{
comment|// Incomplete sequence
return|return
name|byte1
return|;
block|}
comment|// Simultaneously checks for illegal trailing-byte in
comment|// leading position and overlong 2-byte form.
if|if
condition|(
name|byte1
argument_list|<
operator|(
name|byte
operator|)
literal|0xC2
operator|||
name|bytes
operator|.
name|read
operator|(
name|index
operator|++
operator|)
argument_list|>
argument_list|(
name|byte
argument_list|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|byte1
operator|<
operator|(
name|byte
operator|)
literal|0xF0
condition|)
block|{
comment|// three-byte form
if|if
condition|(
name|index
operator|>=
name|limit
operator|-
literal|1
condition|)
block|{
comment|// incomplete sequence
return|return
name|incompleteStateFor
argument_list|(
name|bytes
argument_list|,
name|index
argument_list|,
name|limit
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|byte2
operator|=
name|bytes
operator|.
name|read
argument_list|(
name|index
operator|++
argument_list|)
operator|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// overlong? 5 most significant bits must not all be zero
operator|||
operator|(
name|byte1
operator|==
operator|(
name|byte
operator|)
literal|0xE0
operator|&&
name|byte2
operator|<
operator|(
name|byte
operator|)
literal|0xA0
operator|)
comment|// check for illegal surrogate codepoints
operator|||
operator|(
name|byte1
operator|==
operator|(
name|byte
operator|)
literal|0xED
operator|&&
name|byte2
operator|>=
operator|(
name|byte
operator|)
literal|0xA0
operator|)
comment|// byte3 trailing-byte test
operator|||
name|bytes
operator|.
name|read
argument_list|(
name|index
operator|++
argument_list|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
else|else
block|{
comment|// four-byte form
if|if
condition|(
name|index
operator|>=
name|limit
operator|-
literal|2
condition|)
block|{
comment|// incomplete sequence
return|return
name|incompleteStateFor
argument_list|(
name|bytes
argument_list|,
name|index
argument_list|,
name|limit
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|byte2
operator|=
name|bytes
operator|.
name|read
argument_list|(
name|index
operator|++
argument_list|)
operator|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// Check that 1<= plane<= 16.  Tricky optimized form of:
comment|// if (byte1> (byte) 0xF4 ||
comment|//     byte1 == (byte) 0xF0&& byte2< (byte) 0x90 ||
comment|//     byte1 == (byte) 0xF4&& byte2> (byte) 0x8F)
operator|||
operator|(
operator|(
operator|(
name|byte1
operator|<<
literal|28
operator|)
operator|+
operator|(
name|byte2
operator|-
operator|(
name|byte
operator|)
literal|0x90
operator|)
operator|)
operator|>>
literal|30
operator|)
operator|!=
literal|0
comment|// byte3 trailing-byte test
operator|||
name|bytes
operator|.
name|read
argument_list|(
name|index
operator|++
argument_list|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// byte4 trailing-byte test
operator|||
name|bytes
operator|.
name|read
argument_list|(
name|index
operator|++
argument_list|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
block|}
block|}
comment|/**      * Encodes an input character sequence ({@code in}) to UTF-8 in the target array ({@code out}).      * For a string, this method is similar to      *<pre>{@code      * byte[] a = string.getBytes(UTF_8);      * System.arraycopy(a, 0, bytes, offset, a.length);      * return offset + a.length;      * }</pre>      *      * but is more efficient in both time and space. One key difference is that this method      * requires paired surrogates, and therefore does not support chunking.      * While {@code String.getBytes(UTF_8)} replaces unpaired surrogates with the default      * replacement character, this method throws {@link UnpairedSurrogateException}.      *      *<p>To ensure sufficient space in the output buffer, either call {@link #encodedLength} to      * compute the exact amount needed, or leave room for       * {@code Utf8.MAX_BYTES_PER_CHAR * sequence.length()}, which is the largest possible number      * of bytes that any input can be encoded to.      *      * @param in the input character sequence to be encoded      * @param out the target array      * @param offset the starting offset in {@code bytes} to start writing at      * @param length the length of the {@code bytes}, starting from {@code offset}      * @throws UnpairedSurrogateException if {@code sequence} contains ill-formed UTF-16 (unpaired      *     surrogates)      * @throws ArrayIndexOutOfBoundsException if {@code sequence} encoded in UTF-8 is longer than      *     {@code bytes.length - offset}      * @return the new offset, equivalent to {@code offset + Utf8.encodedLength(sequence)}      */
specifier|abstract
name|int
name|encodeUtf8
parameter_list|(
name|CharSequence
name|in
parameter_list|,
name|byte
index|[]
name|out
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
comment|/**      * Encodes an input character sequence ({@code in}) to UTF-8 in the target buffer ({@code out}).      * Upon returning from this method, the {@code out} position will point to the position after      * the last encoded byte. This method requires paired surrogates, and therefore does not      * support chunking.      *      *<p>To ensure sufficient space in the output buffer, either call {@link #encodedLength} to      * compute the exact amount needed, or leave room for      * {@code Utf8.MAX_BYTES_PER_CHAR * in.length()}, which is the largest possible number      * of bytes that any input can be encoded to.      *      * @param in the source character sequence to be encoded      * @param out the target buffer      * @throws UnpairedSurrogateException if {@code in} contains ill-formed UTF-16 (unpaired      *     surrogates)      * @throws ArrayIndexOutOfBoundsException if {@code in} encoded in UTF-8 is longer than      *     {@code out.remaining()}      */
specifier|final
name|void
name|encodeUtf8
parameter_list|(
name|CharSequence
name|in
parameter_list|,
name|ByteBuffer
name|out
parameter_list|)
block|{
if|if
condition|(
name|out
operator|.
name|hasArray
argument_list|()
condition|)
block|{
specifier|final
name|int
name|offset
init|=
name|out
operator|.
name|arrayOffset
argument_list|()
decl_stmt|;
name|int
name|endIndex
init|=
name|Utf8
operator|.
name|encode
argument_list|(
name|in
argument_list|,
name|out
operator|.
name|array
argument_list|()
argument_list|,
name|offset
operator|+
name|out
operator|.
name|position
argument_list|()
argument_list|,
name|out
operator|.
name|remaining
argument_list|()
argument_list|)
decl_stmt|;
name|out
operator|.
name|position
argument_list|(
name|endIndex
operator|-
name|offset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|out
operator|.
name|isDirect
argument_list|()
condition|)
block|{
name|encodeUtf8Direct
argument_list|(
name|in
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|encodeUtf8Default
argument_list|(
name|in
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Encodes the input character sequence to a direct {@link ByteBuffer} instance.      */
specifier|abstract
name|void
name|encodeUtf8Direct
parameter_list|(
name|CharSequence
name|in
parameter_list|,
name|ByteBuffer
name|out
parameter_list|)
function_decl|;
comment|/**      * Encodes the input character sequence to a {@link ByteBuffer} instance using the {@link      * ByteBuffer} API, rather than potentially faster approaches.      */
specifier|final
name|void
name|encodeUtf8Default
parameter_list|(
name|CharSequence
name|in
parameter_list|,
name|ByteBuffer
name|out
parameter_list|)
block|{
specifier|final
name|int
name|inLength
init|=
name|in
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|outIx
init|=
name|out
operator|.
name|position
argument_list|()
decl_stmt|;
name|int
name|inIx
init|=
literal|0
decl_stmt|;
comment|// Since ByteBuffer.putXXX() already checks boundaries for us, no need to explicitly check
comment|// access. Assume the buffer is big enough and let it handle the out of bounds exception
comment|// if it occurs.
try|try
block|{
comment|// Designed to take advantage of
comment|// https://wikis.oracle.com/display/HotSpotInternals/RangeCheckElimination
for|for
control|(
name|char
name|c
init|;
name|inIx
operator|<
name|inLength
operator|&&
operator|(
name|c
operator|=
name|in
operator|.
name|charAt
argument_list|(
name|inIx
argument_list|)
operator|)
operator|<
literal|0x80
condition|;
operator|++
name|inIx
control|)
block|{
name|out
operator|.
name|put
argument_list|(
name|outIx
operator|+
name|inIx
argument_list|,
operator|(
name|byte
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inIx
operator|==
name|inLength
condition|)
block|{
comment|// Successfully encoded the entire string.
name|out
operator|.
name|position
argument_list|(
name|outIx
operator|+
name|inIx
argument_list|)
expr_stmt|;
return|return;
block|}
name|outIx
operator|+=
name|inIx
expr_stmt|;
for|for
control|(
name|char
name|c
init|;
name|inIx
operator|<
name|inLength
condition|;
operator|++
name|inIx
operator|,
operator|++
name|outIx
control|)
block|{
name|c
operator|=
name|in
operator|.
name|charAt
argument_list|(
name|inIx
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0x80
condition|)
block|{
comment|// One byte (0xxx xxxx)
name|out
operator|.
name|put
argument_list|(
name|outIx
argument_list|,
operator|(
name|byte
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|0x800
condition|)
block|{
comment|// Two bytes (110x xxxx 10xx xxxx)
comment|// Benchmarks show put performs better than putShort here (for HotSpot).
name|out
operator|.
name|put
argument_list|(
name|outIx
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
literal|0xC0
operator||
operator|(
name|c
operator|>>>
literal|6
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|put
argument_list|(
name|outIx
argument_list|,
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
literal|0x3F
operator|&
name|c
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
name|MIN_SURROGATE
operator|||
name|MAX_SURROGATE
operator|<
name|c
condition|)
block|{
comment|// Three bytes (1110 xxxx 10xx xxxx 10xx xxxx)
comment|// Maximum single-char code point is 0xFFFF, 16 bits.
comment|// Benchmarks show put performs better than putShort here (for HotSpot).
name|out
operator|.
name|put
argument_list|(
name|outIx
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
literal|0xE0
operator||
operator|(
name|c
operator|>>>
literal|12
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|put
argument_list|(
name|outIx
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
literal|0x3F
operator|&
operator|(
name|c
operator|>>>
literal|6
operator|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|put
argument_list|(
name|outIx
argument_list|,
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
literal|0x3F
operator|&
name|c
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Four bytes (1111 xxxx 10xx xxxx 10xx xxxx 10xx xxxx)
comment|// Minimum code point represented by a surrogate pair is 0x10000, 17 bits, four UTF-8
comment|// bytes
specifier|final
name|char
name|low
decl_stmt|;
if|if
condition|(
name|inIx
operator|+
literal|1
operator|==
name|inLength
operator|||
operator|!
name|isSurrogatePair
argument_list|(
name|c
argument_list|,
operator|(
name|low
operator|=
name|in
operator|.
name|charAt
argument_list|(
operator|++
name|inIx
argument_list|)
operator|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|UnpairedSurrogateException
argument_list|(
name|inIx
argument_list|,
name|inLength
argument_list|)
throw|;
block|}
comment|// TODO(nathanmittler): Consider using putInt() to improve performance.
name|int
name|codePoint
init|=
name|toCodePoint
argument_list|(
name|c
argument_list|,
name|low
argument_list|)
decl_stmt|;
name|out
operator|.
name|put
argument_list|(
name|outIx
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
operator|(
literal|0xF
operator|<<
literal|4
operator|)
operator||
operator|(
name|codePoint
operator|>>>
literal|18
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|put
argument_list|(
name|outIx
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
literal|0x3F
operator|&
operator|(
name|codePoint
operator|>>>
literal|12
operator|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|put
argument_list|(
name|outIx
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
literal|0x3F
operator|&
operator|(
name|codePoint
operator|>>>
literal|6
operator|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|put
argument_list|(
name|outIx
argument_list|,
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
literal|0x3F
operator|&
name|codePoint
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Successfully encoded the entire string.
name|out
operator|.
name|position
argument_list|(
name|outIx
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
comment|// TODO(nathanmittler): Consider making the API throw IndexOutOfBoundsException instead.
comment|// If we failed in the outer ASCII loop, outIx will not have been updated. In this case,
comment|// use inIx to determine the bad write index.
name|int
name|badWriteIndex
init|=
name|out
operator|.
name|position
argument_list|()
operator|+
name|Math
operator|.
name|max
argument_list|(
name|inIx
argument_list|,
name|outIx
operator|-
name|out
operator|.
name|position
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
literal|"Failed writing "
operator|+
name|in
operator|.
name|charAt
argument_list|(
name|inIx
argument_list|)
operator|+
literal|" at index "
operator|+
name|badWriteIndex
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * {@link Processor} implementation that does not use any {@code sun.misc.Unsafe} methods.    */
specifier|static
specifier|final
class|class
name|SafeProcessor
extends|extends
name|Processor
block|{
annotation|@
name|Override
name|int
name|partialIsValidUtf8
parameter_list|(
name|int
name|state
parameter_list|,
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
if|if
condition|(
name|state
operator|!=
name|COMPLETE
condition|)
block|{
comment|// The previous decoding operation was incomplete (or malformed).
comment|// We look for a well-formed sequence consisting of bytes from
comment|// the previous decoding operation (stored in state) together
comment|// with bytes from the array slice.
comment|//
comment|// We expect such "straddler characters" to be rare.
if|if
condition|(
name|index
operator|>=
name|limit
condition|)
block|{
comment|// No bytes? No progress.
return|return
name|state
return|;
block|}
name|int
name|byte1
init|=
operator|(
name|byte
operator|)
name|state
decl_stmt|;
comment|// byte1 is never ASCII.
if|if
condition|(
name|byte1
operator|<
operator|(
name|byte
operator|)
literal|0xE0
condition|)
block|{
comment|// two-byte form
comment|// Simultaneously checks for illegal trailing-byte in
comment|// leading position and overlong 2-byte form.
if|if
condition|(
name|byte1
argument_list|<
operator|(
name|byte
operator|)
literal|0xC2
comment|// byte2 trailing-byte test
operator|||
name|bytes
index|[
name|index
operator|++
index|]
argument_list|>
argument_list|(
name|byte
argument_list|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|byte1
operator|<
operator|(
name|byte
operator|)
literal|0xF0
condition|)
block|{
comment|// three-byte form
comment|// Get byte2 from saved state or array
name|int
name|byte2
init|=
operator|(
name|byte
operator|)
operator|~
operator|(
name|state
operator|>>
literal|8
operator|)
decl_stmt|;
if|if
condition|(
name|byte2
operator|==
literal|0
condition|)
block|{
name|byte2
operator|=
name|bytes
index|[
name|index
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|limit
condition|)
block|{
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|,
name|byte2
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|byte2
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// overlong? 5 most significant bits must not all be zero
operator|||
operator|(
name|byte1
operator|==
operator|(
name|byte
operator|)
literal|0xE0
operator|&&
name|byte2
operator|<
operator|(
name|byte
operator|)
literal|0xA0
operator|)
comment|// illegal surrogate codepoint?
operator|||
operator|(
name|byte1
operator|==
operator|(
name|byte
operator|)
literal|0xED
operator|&&
name|byte2
operator|>=
operator|(
name|byte
operator|)
literal|0xA0
operator|)
comment|// byte3 trailing-byte test
operator|||
name|bytes
index|[
name|index
operator|++
index|]
operator|>
operator|(
name|byte
operator|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
else|else
block|{
comment|// four-byte form
comment|// Get byte2 and byte3 from saved state or array
name|int
name|byte2
init|=
operator|(
name|byte
operator|)
operator|~
operator|(
name|state
operator|>>
literal|8
operator|)
decl_stmt|;
name|int
name|byte3
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|byte2
operator|==
literal|0
condition|)
block|{
name|byte2
operator|=
name|bytes
index|[
name|index
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|limit
condition|)
block|{
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|,
name|byte2
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|byte3
operator|=
call|(
name|byte
call|)
argument_list|(
name|state
operator|>>
literal|16
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|byte3
operator|==
literal|0
condition|)
block|{
name|byte3
operator|=
name|bytes
index|[
name|index
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|limit
condition|)
block|{
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|,
name|byte2
argument_list|,
name|byte3
argument_list|)
return|;
block|}
block|}
comment|// If we were called with state == MALFORMED, then byte1 is 0xFF,
comment|// which never occurs in well-formed UTF-8, and so we will return
comment|// MALFORMED again below.
if|if
condition|(
name|byte2
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// Check that 1<= plane<= 16.  Tricky optimized form of:
comment|// if (byte1> (byte) 0xF4 ||
comment|//     byte1 == (byte) 0xF0&& byte2< (byte) 0x90 ||
comment|//     byte1 == (byte) 0xF4&& byte2> (byte) 0x8F)
operator|||
operator|(
operator|(
operator|(
name|byte1
operator|<<
literal|28
operator|)
operator|+
operator|(
name|byte2
operator|-
operator|(
name|byte
operator|)
literal|0x90
operator|)
operator|)
operator|>>
literal|30
operator|)
operator|!=
literal|0
comment|// byte3 trailing-byte test
operator|||
name|byte3
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// byte4 trailing-byte test
operator|||
name|bytes
index|[
name|index
operator|++
index|]
operator|>
operator|(
name|byte
operator|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
block|}
return|return
name|partialIsValidUtf8
argument_list|(
name|bytes
argument_list|,
name|index
argument_list|,
name|limit
argument_list|)
return|;
block|}
annotation|@
name|Override
name|int
name|partialIsValidUtf8Direct
parameter_list|(
name|int
name|state
parameter_list|,
name|ByteBuffer
name|buffer
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
comment|// For safe processing, we have to use the ByteBuffer API.
return|return
name|partialIsValidUtf8Default
argument_list|(
name|state
argument_list|,
name|buffer
argument_list|,
name|index
argument_list|,
name|limit
argument_list|)
return|;
block|}
annotation|@
name|Override
name|int
name|encodeUtf8
parameter_list|(
name|CharSequence
name|in
parameter_list|,
name|byte
index|[]
name|out
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|utf16Length
init|=
name|in
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|j
init|=
name|offset
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|limit
init|=
name|offset
operator|+
name|length
decl_stmt|;
comment|// Designed to take advantage of
comment|// https://wikis.oracle.com/display/HotSpotInternals/RangeCheckElimination
for|for
control|(
name|char
name|c
init|;
name|i
operator|<
name|utf16Length
operator|&&
name|i
operator|+
name|j
operator|<
name|limit
operator|&&
operator|(
name|c
operator|=
name|in
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|)
operator|<
literal|0x80
condition|;
name|i
operator|++
control|)
block|{
name|out
index|[
name|j
operator|+
name|i
index|]
operator|=
operator|(
name|byte
operator|)
name|c
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|utf16Length
condition|)
block|{
return|return
name|j
operator|+
name|utf16Length
return|;
block|}
name|j
operator|+=
name|i
expr_stmt|;
for|for
control|(
name|char
name|c
init|;
name|i
operator|<
name|utf16Length
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|in
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0x80
operator|&&
name|j
operator|<
name|limit
condition|)
block|{
name|out
index|[
name|j
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|0x800
operator|&&
name|j
operator|<=
name|limit
operator|-
literal|2
condition|)
block|{
comment|// 11 bits, two UTF-8 bytes
name|out
index|[
name|j
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
literal|0xF
operator|<<
literal|6
operator|)
operator||
operator|(
name|c
operator|>>>
literal|6
operator|)
argument_list|)
expr_stmt|;
name|out
index|[
name|j
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
literal|0x3F
operator|&
name|c
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|<
name|Character
operator|.
name|MIN_SURROGATE
operator|||
name|Character
operator|.
name|MAX_SURROGATE
operator|<
name|c
operator|)
operator|&&
name|j
operator|<=
name|limit
operator|-
literal|3
condition|)
block|{
comment|// Maximum single-char code point is 0xFFFF, 16 bits, three UTF-8 bytes
name|out
index|[
name|j
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
literal|0xF
operator|<<
literal|5
operator|)
operator||
operator|(
name|c
operator|>>>
literal|12
operator|)
argument_list|)
expr_stmt|;
name|out
index|[
name|j
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
literal|0x3F
operator|&
operator|(
name|c
operator|>>>
literal|6
operator|)
operator|)
argument_list|)
expr_stmt|;
name|out
index|[
name|j
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
literal|0x3F
operator|&
name|c
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|j
operator|<=
name|limit
operator|-
literal|4
condition|)
block|{
comment|// Minimum code point represented by a surrogate pair is 0x10000, 17 bits,
comment|// four UTF-8 bytes
specifier|final
name|char
name|low
decl_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|in
operator|.
name|length
argument_list|()
operator|||
operator|!
name|Character
operator|.
name|isSurrogatePair
argument_list|(
name|c
argument_list|,
operator|(
name|low
operator|=
name|in
operator|.
name|charAt
argument_list|(
operator|++
name|i
argument_list|)
operator|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|UnpairedSurrogateException
argument_list|(
operator|(
name|i
operator|-
literal|1
operator|)
argument_list|,
name|utf16Length
argument_list|)
throw|;
block|}
name|int
name|codePoint
init|=
name|Character
operator|.
name|toCodePoint
argument_list|(
name|c
argument_list|,
name|low
argument_list|)
decl_stmt|;
name|out
index|[
name|j
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
literal|0xF
operator|<<
literal|4
operator|)
operator||
operator|(
name|codePoint
operator|>>>
literal|18
operator|)
argument_list|)
expr_stmt|;
name|out
index|[
name|j
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
literal|0x3F
operator|&
operator|(
name|codePoint
operator|>>>
literal|12
operator|)
operator|)
argument_list|)
expr_stmt|;
name|out
index|[
name|j
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
literal|0x3F
operator|&
operator|(
name|codePoint
operator|>>>
literal|6
operator|)
operator|)
argument_list|)
expr_stmt|;
name|out
index|[
name|j
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
literal|0x3F
operator|&
name|codePoint
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If we are surrogates and we're not a surrogate pair, always throw an
comment|// UnpairedSurrogateException instead of an ArrayOutOfBoundsException.
if|if
condition|(
operator|(
name|Character
operator|.
name|MIN_SURROGATE
operator|<=
name|c
operator|&&
name|c
operator|<=
name|Character
operator|.
name|MAX_SURROGATE
operator|)
operator|&&
operator|(
name|i
operator|+
literal|1
operator|==
name|in
operator|.
name|length
argument_list|()
operator|||
operator|!
name|Character
operator|.
name|isSurrogatePair
argument_list|(
name|c
argument_list|,
name|in
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|UnpairedSurrogateException
argument_list|(
name|i
argument_list|,
name|utf16Length
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
literal|"Failed writing "
operator|+
name|c
operator|+
literal|" at index "
operator|+
name|j
argument_list|)
throw|;
block|}
block|}
return|return
name|j
return|;
block|}
annotation|@
name|Override
name|void
name|encodeUtf8Direct
parameter_list|(
name|CharSequence
name|in
parameter_list|,
name|ByteBuffer
name|out
parameter_list|)
block|{
comment|// For safe processing, we have to use the ByteBuffer API.
name|encodeUtf8Default
argument_list|(
name|in
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|int
name|partialIsValidUtf8
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
comment|// Optimize for 100% ASCII (Hotspot loves small simple top-level loops like this).
comment|// This simple loop stops when we encounter a byte>= 0x80 (i.e. non-ASCII).
while|while
condition|(
name|index
operator|<
name|limit
operator|&&
name|bytes
index|[
name|index
index|]
operator|>=
literal|0
condition|)
block|{
name|index
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|index
operator|>=
name|limit
operator|)
condition|?
name|COMPLETE
else|:
name|partialIsValidUtf8NonAscii
argument_list|(
name|bytes
argument_list|,
name|index
argument_list|,
name|limit
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|int
name|partialIsValidUtf8NonAscii
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|byte1
decl_stmt|,
name|byte2
decl_stmt|;
comment|// Optimize for interior runs of ASCII bytes.
do|do
block|{
if|if
condition|(
name|index
operator|>=
name|limit
condition|)
block|{
return|return
name|COMPLETE
return|;
block|}
block|}
do|while
condition|(
operator|(
name|byte1
operator|=
name|bytes
index|[
name|index
operator|++
index|]
operator|)
operator|>=
literal|0
condition|)
do|;
if|if
condition|(
name|byte1
operator|<
operator|(
name|byte
operator|)
literal|0xE0
condition|)
block|{
comment|// two-byte form
if|if
condition|(
name|index
operator|>=
name|limit
condition|)
block|{
comment|// Incomplete sequence
return|return
name|byte1
return|;
block|}
comment|// Simultaneously checks for illegal trailing-byte in
comment|// leading position and overlong 2-byte form.
if|if
condition|(
name|byte1
argument_list|<
operator|(
name|byte
operator|)
literal|0xC2
operator|||
name|bytes
index|[
name|index
operator|++
index|]
argument_list|>
argument_list|(
name|byte
argument_list|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|byte1
operator|<
operator|(
name|byte
operator|)
literal|0xF0
condition|)
block|{
comment|// three-byte form
if|if
condition|(
name|index
operator|>=
name|limit
operator|-
literal|1
condition|)
block|{
comment|// incomplete sequence
return|return
name|incompleteStateFor
argument_list|(
name|bytes
argument_list|,
name|index
argument_list|,
name|limit
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|byte2
operator|=
name|bytes
index|[
name|index
operator|++
index|]
operator|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// overlong? 5 most significant bits must not all be zero
operator|||
operator|(
name|byte1
operator|==
operator|(
name|byte
operator|)
literal|0xE0
operator|&&
name|byte2
operator|<
operator|(
name|byte
operator|)
literal|0xA0
operator|)
comment|// check for illegal surrogate codepoints
operator|||
operator|(
name|byte1
operator|==
operator|(
name|byte
operator|)
literal|0xED
operator|&&
name|byte2
operator|>=
operator|(
name|byte
operator|)
literal|0xA0
operator|)
comment|// byte3 trailing-byte test
operator|||
name|bytes
index|[
name|index
operator|++
index|]
operator|>
operator|(
name|byte
operator|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
else|else
block|{
comment|// four-byte form
if|if
condition|(
name|index
operator|>=
name|limit
operator|-
literal|2
condition|)
block|{
comment|// incomplete sequence
return|return
name|incompleteStateFor
argument_list|(
name|bytes
argument_list|,
name|index
argument_list|,
name|limit
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|byte2
operator|=
name|bytes
index|[
name|index
operator|++
index|]
operator|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// Check that 1<= plane<= 16.  Tricky optimized form of:
comment|// if (byte1> (byte) 0xF4 ||
comment|//     byte1 == (byte) 0xF0&& byte2< (byte) 0x90 ||
comment|//     byte1 == (byte) 0xF4&& byte2> (byte) 0x8F)
operator|||
operator|(
operator|(
operator|(
name|byte1
operator|<<
literal|28
operator|)
operator|+
operator|(
name|byte2
operator|-
operator|(
name|byte
operator|)
literal|0x90
operator|)
operator|)
operator|>>
literal|30
operator|)
operator|!=
literal|0
comment|// byte3 trailing-byte test
operator|||
name|bytes
index|[
name|index
operator|++
index|]
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// byte4 trailing-byte test
operator|||
name|bytes
index|[
name|index
operator|++
index|]
operator|>
operator|(
name|byte
operator|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
block|}
block|}
block|}
comment|/**    * {@link Processor} that uses {@code sun.misc.Unsafe} where possible to improve performance.    */
specifier|static
specifier|final
class|class
name|UnsafeProcessor
extends|extends
name|Processor
block|{
comment|/**      * Indicates whether or not all required unsafe operations are supported on this platform.      */
specifier|static
name|boolean
name|isAvailable
parameter_list|()
block|{
return|return
name|hasUnsafeArrayOperations
argument_list|()
operator|&&
name|hasUnsafeByteBufferOperations
argument_list|()
return|;
block|}
annotation|@
name|Override
name|int
name|partialIsValidUtf8
parameter_list|(
name|int
name|state
parameter_list|,
name|byte
index|[]
name|bytes
parameter_list|,
specifier|final
name|int
name|index
parameter_list|,
specifier|final
name|int
name|limit
parameter_list|)
block|{
if|if
condition|(
operator|(
name|index
operator||
name|limit
operator||
name|bytes
operator|.
name|length
operator|-
name|limit
operator|)
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Array length=%d, index=%d, limit=%d"
argument_list|,
name|bytes
operator|.
name|length
argument_list|,
name|index
argument_list|,
name|limit
argument_list|)
argument_list|)
throw|;
block|}
name|long
name|offset
init|=
name|getArrayBaseOffset
argument_list|()
operator|+
name|index
decl_stmt|;
specifier|final
name|long
name|offsetLimit
init|=
name|getArrayBaseOffset
argument_list|()
operator|+
name|limit
decl_stmt|;
if|if
condition|(
name|state
operator|!=
name|COMPLETE
condition|)
block|{
comment|// The previous decoding operation was incomplete (or malformed).
comment|// We look for a well-formed sequence consisting of bytes from
comment|// the previous decoding operation (stored in state) together
comment|// with bytes from the array slice.
comment|//
comment|// We expect such "straddler characters" to be rare.
if|if
condition|(
name|offset
operator|>=
name|offsetLimit
condition|)
block|{
comment|// No bytes? No progress.
return|return
name|state
return|;
block|}
name|int
name|byte1
init|=
operator|(
name|byte
operator|)
name|state
decl_stmt|;
comment|// byte1 is never ASCII.
if|if
condition|(
name|byte1
operator|<
operator|(
name|byte
operator|)
literal|0xE0
condition|)
block|{
comment|// two-byte form
comment|// Simultaneously checks for illegal trailing-byte in
comment|// leading position and overlong 2-byte form.
if|if
condition|(
name|byte1
operator|<
operator|(
name|byte
operator|)
literal|0xC2
comment|// byte2 trailing-byte test
operator|||
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|bytes
argument_list|,
name|offset
operator|++
argument_list|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|byte1
operator|<
operator|(
name|byte
operator|)
literal|0xF0
condition|)
block|{
comment|// three-byte form
comment|// Get byte2 from saved state or array
name|int
name|byte2
init|=
operator|(
name|byte
operator|)
operator|~
operator|(
name|state
operator|>>
literal|8
operator|)
decl_stmt|;
if|if
condition|(
name|byte2
operator|==
literal|0
condition|)
block|{
name|byte2
operator|=
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|bytes
argument_list|,
name|offset
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|offsetLimit
condition|)
block|{
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|,
name|byte2
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|byte2
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// overlong? 5 most significant bits must not all be zero
operator|||
operator|(
name|byte1
operator|==
operator|(
name|byte
operator|)
literal|0xE0
operator|&&
name|byte2
operator|<
operator|(
name|byte
operator|)
literal|0xA0
operator|)
comment|// illegal surrogate codepoint?
operator|||
operator|(
name|byte1
operator|==
operator|(
name|byte
operator|)
literal|0xED
operator|&&
name|byte2
operator|>=
operator|(
name|byte
operator|)
literal|0xA0
operator|)
comment|// byte3 trailing-byte test
operator|||
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|bytes
argument_list|,
name|offset
operator|++
argument_list|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
else|else
block|{
comment|// four-byte form
comment|// Get byte2 and byte3 from saved state or array
name|int
name|byte2
init|=
operator|(
name|byte
operator|)
operator|~
operator|(
name|state
operator|>>
literal|8
operator|)
decl_stmt|;
name|int
name|byte3
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|byte2
operator|==
literal|0
condition|)
block|{
name|byte2
operator|=
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|bytes
argument_list|,
name|offset
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|offsetLimit
condition|)
block|{
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|,
name|byte2
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|byte3
operator|=
call|(
name|byte
call|)
argument_list|(
name|state
operator|>>
literal|16
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|byte3
operator|==
literal|0
condition|)
block|{
name|byte3
operator|=
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|bytes
argument_list|,
name|offset
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|offsetLimit
condition|)
block|{
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|,
name|byte2
argument_list|,
name|byte3
argument_list|)
return|;
block|}
block|}
comment|// If we were called with state == MALFORMED, then byte1 is 0xFF,
comment|// which never occurs in well-formed UTF-8, and so we will return
comment|// MALFORMED again below.
if|if
condition|(
name|byte2
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// Check that 1<= plane<= 16.  Tricky optimized form of:
comment|// if (byte1> (byte) 0xF4 ||
comment|//     byte1 == (byte) 0xF0&& byte2< (byte) 0x90 ||
comment|//     byte1 == (byte) 0xF4&& byte2> (byte) 0x8F)
operator|||
operator|(
operator|(
operator|(
name|byte1
operator|<<
literal|28
operator|)
operator|+
operator|(
name|byte2
operator|-
operator|(
name|byte
operator|)
literal|0x90
operator|)
operator|)
operator|>>
literal|30
operator|)
operator|!=
literal|0
comment|// byte3 trailing-byte test
operator|||
name|byte3
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// byte4 trailing-byte test
operator|||
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|bytes
argument_list|,
name|offset
operator|++
argument_list|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
block|}
return|return
name|partialIsValidUtf8
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
call|(
name|int
call|)
argument_list|(
name|offsetLimit
operator|-
name|offset
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
name|int
name|partialIsValidUtf8Direct
parameter_list|(
specifier|final
name|int
name|state
parameter_list|,
name|ByteBuffer
name|buffer
parameter_list|,
specifier|final
name|int
name|index
parameter_list|,
specifier|final
name|int
name|limit
parameter_list|)
block|{
if|if
condition|(
operator|(
name|index
operator||
name|limit
operator||
name|buffer
operator|.
name|limit
argument_list|()
operator|-
name|limit
operator|)
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"buffer limit=%d, index=%d, limit=%d"
argument_list|,
name|buffer
operator|.
name|limit
argument_list|()
argument_list|,
name|index
argument_list|,
name|limit
argument_list|)
argument_list|)
throw|;
block|}
name|long
name|address
init|=
name|addressOffset
argument_list|(
name|buffer
argument_list|)
operator|+
name|index
decl_stmt|;
specifier|final
name|long
name|addressLimit
init|=
name|address
operator|+
operator|(
name|limit
operator|-
name|index
operator|)
decl_stmt|;
if|if
condition|(
name|state
operator|!=
name|COMPLETE
condition|)
block|{
comment|// The previous decoding operation was incomplete (or malformed).
comment|// We look for a well-formed sequence consisting of bytes from
comment|// the previous decoding operation (stored in state) together
comment|// with bytes from the array slice.
comment|//
comment|// We expect such "straddler characters" to be rare.
if|if
condition|(
name|address
operator|>=
name|addressLimit
condition|)
block|{
comment|// No bytes? No progress.
return|return
name|state
return|;
block|}
specifier|final
name|int
name|byte1
init|=
operator|(
name|byte
operator|)
name|state
decl_stmt|;
comment|// byte1 is never ASCII.
if|if
condition|(
name|byte1
operator|<
operator|(
name|byte
operator|)
literal|0xE0
condition|)
block|{
comment|// two-byte form
comment|// Simultaneously checks for illegal trailing-byte in
comment|// leading position and overlong 2-byte form.
if|if
condition|(
name|byte1
argument_list|<
operator|(
name|byte
operator|)
literal|0xC2
comment|// byte2 trailing-byte test
operator|||
name|UnsafeUtil
operator|.
name|getByte
operator|(
name|address
operator|++
operator|)
argument_list|>
argument_list|(
name|byte
argument_list|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|byte1
operator|<
operator|(
name|byte
operator|)
literal|0xF0
condition|)
block|{
comment|// three-byte form
comment|// Get byte2 from saved state or array
name|int
name|byte2
init|=
operator|(
name|byte
operator|)
operator|~
operator|(
name|state
operator|>>
literal|8
operator|)
decl_stmt|;
if|if
condition|(
name|byte2
operator|==
literal|0
condition|)
block|{
name|byte2
operator|=
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|address
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|address
operator|>=
name|addressLimit
condition|)
block|{
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|,
name|byte2
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|byte2
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// overlong? 5 most significant bits must not all be zero
operator|||
operator|(
name|byte1
operator|==
operator|(
name|byte
operator|)
literal|0xE0
operator|&&
name|byte2
operator|<
operator|(
name|byte
operator|)
literal|0xA0
operator|)
comment|// illegal surrogate codepoint?
operator|||
operator|(
name|byte1
operator|==
operator|(
name|byte
operator|)
literal|0xED
operator|&&
name|byte2
operator|>=
operator|(
name|byte
operator|)
literal|0xA0
operator|)
comment|// byte3 trailing-byte test
operator|||
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|address
operator|++
argument_list|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
else|else
block|{
comment|// four-byte form
comment|// Get byte2 and byte3 from saved state or array
name|int
name|byte2
init|=
operator|(
name|byte
operator|)
operator|~
operator|(
name|state
operator|>>
literal|8
operator|)
decl_stmt|;
name|int
name|byte3
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|byte2
operator|==
literal|0
condition|)
block|{
name|byte2
operator|=
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|address
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|address
operator|>=
name|addressLimit
condition|)
block|{
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|,
name|byte2
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|byte3
operator|=
call|(
name|byte
call|)
argument_list|(
name|state
operator|>>
literal|16
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|byte3
operator|==
literal|0
condition|)
block|{
name|byte3
operator|=
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|address
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|address
operator|>=
name|addressLimit
condition|)
block|{
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|,
name|byte2
argument_list|,
name|byte3
argument_list|)
return|;
block|}
block|}
comment|// If we were called with state == MALFORMED, then byte1 is 0xFF,
comment|// which never occurs in well-formed UTF-8, and so we will return
comment|// MALFORMED again below.
if|if
condition|(
name|byte2
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// Check that 1<= plane<= 16.  Tricky optimized form of:
comment|// if (byte1> (byte) 0xF4 ||
comment|//     byte1 == (byte) 0xF0&& byte2< (byte) 0x90 ||
comment|//     byte1 == (byte) 0xF4&& byte2> (byte) 0x8F)
operator|||
operator|(
operator|(
operator|(
name|byte1
operator|<<
literal|28
operator|)
operator|+
operator|(
name|byte2
operator|-
operator|(
name|byte
operator|)
literal|0x90
operator|)
operator|)
operator|>>
literal|30
operator|)
operator|!=
literal|0
comment|// byte3 trailing-byte test
operator|||
name|byte3
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// byte4 trailing-byte test
operator|||
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|address
operator|++
argument_list|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
block|}
return|return
name|partialIsValidUtf8
argument_list|(
name|address
argument_list|,
call|(
name|int
call|)
argument_list|(
name|addressLimit
operator|-
name|address
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
name|int
name|encodeUtf8
parameter_list|(
specifier|final
name|CharSequence
name|in
parameter_list|,
specifier|final
name|byte
index|[]
name|out
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|)
block|{
name|long
name|outIx
init|=
name|getArrayBaseOffset
argument_list|()
operator|+
name|offset
decl_stmt|;
specifier|final
name|long
name|outLimit
init|=
name|outIx
operator|+
name|length
decl_stmt|;
specifier|final
name|int
name|inLimit
init|=
name|in
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|inLimit
operator|>
name|length
operator|||
name|out
operator|.
name|length
operator|-
name|length
operator|<
name|offset
condition|)
block|{
comment|// Not even enough room for an ASCII-encoded string.
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
literal|"Failed writing "
operator|+
name|in
operator|.
name|charAt
argument_list|(
name|inLimit
operator|-
literal|1
argument_list|)
operator|+
literal|" at index "
operator|+
operator|(
name|offset
operator|+
name|length
operator|)
argument_list|)
throw|;
block|}
comment|// Designed to take advantage of
comment|// https://wikis.oracle.com/display/HotSpotInternals/RangeCheckElimination
name|int
name|inIx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|char
name|c
init|;
name|inIx
operator|<
name|inLimit
operator|&&
operator|(
name|c
operator|=
name|in
operator|.
name|charAt
argument_list|(
name|inIx
argument_list|)
operator|)
operator|<
literal|0x80
condition|;
operator|++
name|inIx
control|)
block|{
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|out
argument_list|,
name|outIx
operator|++
argument_list|,
operator|(
name|byte
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inIx
operator|==
name|inLimit
condition|)
block|{
comment|// We're done, it was ASCII encoded.
return|return
call|(
name|int
call|)
argument_list|(
name|outIx
operator|-
name|getArrayBaseOffset
argument_list|()
argument_list|)
return|;
block|}
for|for
control|(
name|char
name|c
init|;
name|inIx
operator|<
name|inLimit
condition|;
operator|++
name|inIx
control|)
block|{
name|c
operator|=
name|in
operator|.
name|charAt
argument_list|(
name|inIx
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0x80
operator|&&
name|outIx
operator|<
name|outLimit
condition|)
block|{
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|out
argument_list|,
name|outIx
operator|++
argument_list|,
operator|(
name|byte
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|0x800
operator|&&
name|outIx
operator|<=
name|outLimit
operator|-
literal|2L
condition|)
block|{
comment|// 11 bits, two UTF-8 bytes
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|out
argument_list|,
name|outIx
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
operator|(
literal|0xF
operator|<<
literal|6
operator|)
operator||
operator|(
name|c
operator|>>>
literal|6
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|out
argument_list|,
name|outIx
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
literal|0x3F
operator|&
name|c
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|<
name|MIN_SURROGATE
operator|||
name|MAX_SURROGATE
operator|<
name|c
operator|)
operator|&&
name|outIx
operator|<=
name|outLimit
operator|-
literal|3L
condition|)
block|{
comment|// Maximum single-char code point is 0xFFFF, 16 bits, three UTF-8 bytes
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|out
argument_list|,
name|outIx
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
operator|(
literal|0xF
operator|<<
literal|5
operator|)
operator||
operator|(
name|c
operator|>>>
literal|12
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|out
argument_list|,
name|outIx
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
literal|0x3F
operator|&
operator|(
name|c
operator|>>>
literal|6
operator|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|out
argument_list|,
name|outIx
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
literal|0x3F
operator|&
name|c
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|outIx
operator|<=
name|outLimit
operator|-
literal|4L
condition|)
block|{
comment|// Minimum code point represented by a surrogate pair is 0x10000, 17 bits, four UTF-8
comment|// bytes
specifier|final
name|char
name|low
decl_stmt|;
if|if
condition|(
name|inIx
operator|+
literal|1
operator|==
name|inLimit
operator|||
operator|!
name|isSurrogatePair
argument_list|(
name|c
argument_list|,
operator|(
name|low
operator|=
name|in
operator|.
name|charAt
argument_list|(
operator|++
name|inIx
argument_list|)
operator|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|UnpairedSurrogateException
argument_list|(
operator|(
name|inIx
operator|-
literal|1
operator|)
argument_list|,
name|inLimit
argument_list|)
throw|;
block|}
name|int
name|codePoint
init|=
name|toCodePoint
argument_list|(
name|c
argument_list|,
name|low
argument_list|)
decl_stmt|;
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|out
argument_list|,
name|outIx
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
operator|(
literal|0xF
operator|<<
literal|4
operator|)
operator||
operator|(
name|codePoint
operator|>>>
literal|18
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|out
argument_list|,
name|outIx
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
literal|0x3F
operator|&
operator|(
name|codePoint
operator|>>>
literal|12
operator|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|out
argument_list|,
name|outIx
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
literal|0x3F
operator|&
operator|(
name|codePoint
operator|>>>
literal|6
operator|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|out
argument_list|,
name|outIx
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
literal|0x3F
operator|&
name|codePoint
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|MIN_SURROGATE
operator|<=
name|c
operator|&&
name|c
operator|<=
name|MAX_SURROGATE
operator|)
operator|&&
operator|(
name|inIx
operator|+
literal|1
operator|==
name|inLimit
operator|||
operator|!
name|isSurrogatePair
argument_list|(
name|c
argument_list|,
name|in
operator|.
name|charAt
argument_list|(
name|inIx
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|// We are surrogates and we're not a surrogate pair.
throw|throw
operator|new
name|UnpairedSurrogateException
argument_list|(
name|inIx
argument_list|,
name|inLimit
argument_list|)
throw|;
block|}
comment|// Not enough space in the output buffer.
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
literal|"Failed writing "
operator|+
name|c
operator|+
literal|" at index "
operator|+
name|outIx
argument_list|)
throw|;
block|}
block|}
comment|// All bytes have been encoded.
return|return
call|(
name|int
call|)
argument_list|(
name|outIx
operator|-
name|getArrayBaseOffset
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
name|void
name|encodeUtf8Direct
parameter_list|(
name|CharSequence
name|in
parameter_list|,
name|ByteBuffer
name|out
parameter_list|)
block|{
specifier|final
name|long
name|address
init|=
name|addressOffset
argument_list|(
name|out
argument_list|)
decl_stmt|;
name|long
name|outIx
init|=
name|address
operator|+
name|out
operator|.
name|position
argument_list|()
decl_stmt|;
specifier|final
name|long
name|outLimit
init|=
name|address
operator|+
name|out
operator|.
name|limit
argument_list|()
decl_stmt|;
specifier|final
name|int
name|inLimit
init|=
name|in
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|inLimit
operator|>
name|outLimit
operator|-
name|outIx
condition|)
block|{
comment|// Not even enough room for an ASCII-encoded string.
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
literal|"Failed writing "
operator|+
name|in
operator|.
name|charAt
argument_list|(
name|inLimit
operator|-
literal|1
argument_list|)
operator|+
literal|" at index "
operator|+
name|out
operator|.
name|limit
argument_list|()
argument_list|)
throw|;
block|}
comment|// Designed to take advantage of
comment|// https://wikis.oracle.com/display/HotSpotInternals/RangeCheckElimination
name|int
name|inIx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|char
name|c
init|;
name|inIx
operator|<
name|inLimit
operator|&&
operator|(
name|c
operator|=
name|in
operator|.
name|charAt
argument_list|(
name|inIx
argument_list|)
operator|)
operator|<
literal|0x80
condition|;
operator|++
name|inIx
control|)
block|{
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|outIx
operator|++
argument_list|,
operator|(
name|byte
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inIx
operator|==
name|inLimit
condition|)
block|{
comment|// We're done, it was ASCII encoded.
name|out
operator|.
name|position
argument_list|(
call|(
name|int
call|)
argument_list|(
name|outIx
operator|-
name|address
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|char
name|c
init|;
name|inIx
operator|<
name|inLimit
condition|;
operator|++
name|inIx
control|)
block|{
name|c
operator|=
name|in
operator|.
name|charAt
argument_list|(
name|inIx
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0x80
operator|&&
name|outIx
operator|<
name|outLimit
condition|)
block|{
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|outIx
operator|++
argument_list|,
operator|(
name|byte
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|0x800
operator|&&
name|outIx
operator|<=
name|outLimit
operator|-
literal|2L
condition|)
block|{
comment|// 11 bits, two UTF-8 bytes
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|outIx
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
operator|(
literal|0xF
operator|<<
literal|6
operator|)
operator||
operator|(
name|c
operator|>>>
literal|6
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|outIx
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
literal|0x3F
operator|&
name|c
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|<
name|MIN_SURROGATE
operator|||
name|MAX_SURROGATE
operator|<
name|c
operator|)
operator|&&
name|outIx
operator|<=
name|outLimit
operator|-
literal|3L
condition|)
block|{
comment|// Maximum single-char code point is 0xFFFF, 16 bits, three UTF-8 bytes
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|outIx
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
operator|(
literal|0xF
operator|<<
literal|5
operator|)
operator||
operator|(
name|c
operator|>>>
literal|12
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|outIx
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
literal|0x3F
operator|&
operator|(
name|c
operator|>>>
literal|6
operator|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|outIx
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
literal|0x3F
operator|&
name|c
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|outIx
operator|<=
name|outLimit
operator|-
literal|4L
condition|)
block|{
comment|// Minimum code point represented by a surrogate pair is 0x10000, 17 bits, four UTF-8
comment|// bytes
specifier|final
name|char
name|low
decl_stmt|;
if|if
condition|(
name|inIx
operator|+
literal|1
operator|==
name|inLimit
operator|||
operator|!
name|isSurrogatePair
argument_list|(
name|c
argument_list|,
operator|(
name|low
operator|=
name|in
operator|.
name|charAt
argument_list|(
operator|++
name|inIx
argument_list|)
operator|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|UnpairedSurrogateException
argument_list|(
operator|(
name|inIx
operator|-
literal|1
operator|)
argument_list|,
name|inLimit
argument_list|)
throw|;
block|}
name|int
name|codePoint
init|=
name|toCodePoint
argument_list|(
name|c
argument_list|,
name|low
argument_list|)
decl_stmt|;
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|outIx
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
operator|(
literal|0xF
operator|<<
literal|4
operator|)
operator||
operator|(
name|codePoint
operator|>>>
literal|18
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|outIx
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
literal|0x3F
operator|&
operator|(
name|codePoint
operator|>>>
literal|12
operator|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|outIx
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
literal|0x3F
operator|&
operator|(
name|codePoint
operator|>>>
literal|6
operator|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|UnsafeUtil
operator|.
name|putByte
argument_list|(
name|outIx
operator|++
argument_list|,
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
operator|(
literal|0x3F
operator|&
name|codePoint
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|MIN_SURROGATE
operator|<=
name|c
operator|&&
name|c
operator|<=
name|MAX_SURROGATE
operator|)
operator|&&
operator|(
name|inIx
operator|+
literal|1
operator|==
name|inLimit
operator|||
operator|!
name|isSurrogatePair
argument_list|(
name|c
argument_list|,
name|in
operator|.
name|charAt
argument_list|(
name|inIx
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|// We are surrogates and we're not a surrogate pair.
throw|throw
operator|new
name|UnpairedSurrogateException
argument_list|(
name|inIx
argument_list|,
name|inLimit
argument_list|)
throw|;
block|}
comment|// Not enough space in the output buffer.
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
literal|"Failed writing "
operator|+
name|c
operator|+
literal|" at index "
operator|+
name|outIx
argument_list|)
throw|;
block|}
block|}
comment|// All bytes have been encoded.
name|out
operator|.
name|position
argument_list|(
call|(
name|int
call|)
argument_list|(
name|outIx
operator|-
name|address
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Counts (approximately) the number of consecutive ASCII characters starting from the given      * position, using the most efficient method available to the platform.      *      * @param bytes the array containing the character sequence      * @param offset the offset position of the index (same as index + arrayBaseOffset)      * @param maxChars the maximum number of characters to count      * @return the number of ASCII characters found. The stopping position will be at or      * before the first non-ASCII byte.      */
specifier|private
specifier|static
name|int
name|unsafeEstimateConsecutiveAscii
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|long
name|offset
parameter_list|,
specifier|final
name|int
name|maxChars
parameter_list|)
block|{
name|int
name|remaining
init|=
name|maxChars
decl_stmt|;
if|if
condition|(
name|remaining
operator|<
name|UNSAFE_COUNT_ASCII_THRESHOLD
condition|)
block|{
comment|// Don't bother with small strings.
return|return
literal|0
return|;
block|}
comment|// Read bytes until 8-byte aligned so that we can read longs in the loop below.
comment|// Byte arrays are already either 8 or 16-byte aligned, so we just need to make sure that
comment|// the index (relative to the start of the array) is also 8-byte aligned. We do this by
comment|// ANDing the index with 7 to determine the number of bytes that need to be read before
comment|// we're 8-byte aligned.
specifier|final
name|int
name|unaligned
init|=
operator|(
name|int
operator|)
name|offset
operator|&
literal|7
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|unaligned
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|bytes
argument_list|,
name|offset
operator|++
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|unaligned
operator|-
name|j
return|;
block|}
block|}
comment|// This simple loop stops when we encounter a byte>= 0x80 (i.e. non-ASCII).
comment|// To speed things up further, we're reading longs instead of bytes so we use a mask to
comment|// determine if any byte in the current long is non-ASCII.
name|remaining
operator|-=
name|unaligned
expr_stmt|;
for|for
control|(
init|;
name|remaining
operator|>=
literal|8
operator|&&
operator|(
name|UnsafeUtil
operator|.
name|getLong
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|)
operator|&
name|ASCII_MASK_LONG
operator|)
operator|==
literal|0
condition|;
name|offset
operator|+=
literal|8
operator|,
name|remaining
operator|-=
literal|8
control|)
block|{}
return|return
name|maxChars
operator|-
name|remaining
return|;
block|}
comment|/**      * Same as {@link Utf8#estimateConsecutiveAscii(ByteBuffer, int, int)} except that it uses the      * most efficient method available to the platform.      */
specifier|private
specifier|static
name|int
name|unsafeEstimateConsecutiveAscii
parameter_list|(
name|long
name|address
parameter_list|,
specifier|final
name|int
name|maxChars
parameter_list|)
block|{
name|int
name|remaining
init|=
name|maxChars
decl_stmt|;
if|if
condition|(
name|remaining
operator|<
name|UNSAFE_COUNT_ASCII_THRESHOLD
condition|)
block|{
comment|// Don't bother with small strings.
return|return
literal|0
return|;
block|}
comment|// Read bytes until 8-byte aligned so that we can read longs in the loop below.
comment|// We do this by ANDing the address with 7 to determine the number of bytes that need to
comment|// be read before we're 8-byte aligned.
specifier|final
name|int
name|unaligned
init|=
operator|(
name|int
operator|)
name|address
operator|&
literal|7
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
name|unaligned
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|address
operator|++
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|unaligned
operator|-
name|j
return|;
block|}
block|}
comment|// This simple loop stops when we encounter a byte>= 0x80 (i.e. non-ASCII).
comment|// To speed things up further, we're reading longs instead of bytes so we use a mask to
comment|// determine if any byte in the current long is non-ASCII.
name|remaining
operator|-=
name|unaligned
expr_stmt|;
for|for
control|(
init|;
name|remaining
operator|>=
literal|8
operator|&&
operator|(
name|UnsafeUtil
operator|.
name|getLong
argument_list|(
name|address
argument_list|)
operator|&
name|ASCII_MASK_LONG
operator|)
operator|==
literal|0
condition|;
name|address
operator|+=
literal|8
operator|,
name|remaining
operator|-=
literal|8
control|)
block|{}
return|return
name|maxChars
operator|-
name|remaining
return|;
block|}
specifier|private
specifier|static
name|int
name|partialIsValidUtf8
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|,
name|long
name|offset
parameter_list|,
name|int
name|remaining
parameter_list|)
block|{
comment|// Skip past ASCII characters as quickly as possible.
specifier|final
name|int
name|skipped
init|=
name|unsafeEstimateConsecutiveAscii
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|remaining
argument_list|)
decl_stmt|;
name|remaining
operator|-=
name|skipped
expr_stmt|;
name|offset
operator|+=
name|skipped
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|// Optimize for interior runs of ASCII bytes.
comment|// TODO(nathanmittler): Consider checking 8 bytes at a time after some threshold?
comment|// Maybe after seeing a few in a row that are ASCII, go back to fast mode?
name|int
name|byte1
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|remaining
operator|>
literal|0
operator|&&
operator|(
name|byte1
operator|=
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|bytes
argument_list|,
name|offset
operator|++
argument_list|)
operator|)
operator|>=
literal|0
condition|;
operator|--
name|remaining
control|)
block|{         }
if|if
condition|(
name|remaining
operator|==
literal|0
condition|)
block|{
return|return
name|COMPLETE
return|;
block|}
name|remaining
operator|--
expr_stmt|;
comment|// If we're here byte1 is not ASCII. Only need to handle 2-4 byte forms.
if|if
condition|(
name|byte1
operator|<
operator|(
name|byte
operator|)
literal|0xE0
condition|)
block|{
comment|// Two-byte form (110xxxxx 10xxxxxx)
if|if
condition|(
name|remaining
operator|==
literal|0
condition|)
block|{
comment|// Incomplete sequence
return|return
name|byte1
return|;
block|}
name|remaining
operator|--
expr_stmt|;
comment|// Simultaneously checks for illegal trailing-byte in
comment|// leading position and overlong 2-byte form.
if|if
condition|(
name|byte1
operator|<
operator|(
name|byte
operator|)
literal|0xC2
operator|||
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|bytes
argument_list|,
name|offset
operator|++
argument_list|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|byte1
operator|<
operator|(
name|byte
operator|)
literal|0xF0
condition|)
block|{
comment|// Three-byte form (1110xxxx 10xxxxxx 10xxxxxx)
if|if
condition|(
name|remaining
operator|<
literal|2
condition|)
block|{
comment|// Incomplete sequence
return|return
name|unsafeIncompleteStateFor
argument_list|(
name|bytes
argument_list|,
name|byte1
argument_list|,
name|offset
argument_list|,
name|remaining
argument_list|)
return|;
block|}
name|remaining
operator|-=
literal|2
expr_stmt|;
specifier|final
name|int
name|byte2
decl_stmt|;
if|if
condition|(
operator|(
name|byte2
operator|=
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|bytes
argument_list|,
name|offset
operator|++
argument_list|)
operator|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// overlong? 5 most significant bits must not all be zero
operator|||
operator|(
name|byte1
operator|==
operator|(
name|byte
operator|)
literal|0xE0
operator|&&
name|byte2
operator|<
operator|(
name|byte
operator|)
literal|0xA0
operator|)
comment|// check for illegal surrogate codepoints
operator|||
operator|(
name|byte1
operator|==
operator|(
name|byte
operator|)
literal|0xED
operator|&&
name|byte2
operator|>=
operator|(
name|byte
operator|)
literal|0xA0
operator|)
comment|// byte3 trailing-byte test
operator|||
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|bytes
argument_list|,
name|offset
operator|++
argument_list|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
else|else
block|{
comment|// Four-byte form (1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx)
if|if
condition|(
name|remaining
operator|<
literal|3
condition|)
block|{
comment|// Incomplete sequence
return|return
name|unsafeIncompleteStateFor
argument_list|(
name|bytes
argument_list|,
name|byte1
argument_list|,
name|offset
argument_list|,
name|remaining
argument_list|)
return|;
block|}
name|remaining
operator|-=
literal|3
expr_stmt|;
specifier|final
name|int
name|byte2
decl_stmt|;
if|if
condition|(
operator|(
name|byte2
operator|=
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|bytes
argument_list|,
name|offset
operator|++
argument_list|)
operator|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// Check that 1<= plane<= 16.  Tricky optimized form of:
comment|// if (byte1> (byte) 0xF4 ||
comment|//     byte1 == (byte) 0xF0&& byte2< (byte) 0x90 ||
comment|//     byte1 == (byte) 0xF4&& byte2> (byte) 0x8F)
operator|||
operator|(
operator|(
operator|(
name|byte1
operator|<<
literal|28
operator|)
operator|+
operator|(
name|byte2
operator|-
operator|(
name|byte
operator|)
literal|0x90
operator|)
operator|)
operator|>>
literal|30
operator|)
operator|!=
literal|0
comment|// byte3 trailing-byte test
operator|||
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|bytes
argument_list|,
name|offset
operator|++
argument_list|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// byte4 trailing-byte test
operator|||
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|bytes
argument_list|,
name|offset
operator|++
argument_list|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
block|}
block|}
specifier|private
specifier|static
name|int
name|partialIsValidUtf8
parameter_list|(
name|long
name|address
parameter_list|,
name|int
name|remaining
parameter_list|)
block|{
comment|// Skip past ASCII characters as quickly as possible.
specifier|final
name|int
name|skipped
init|=
name|unsafeEstimateConsecutiveAscii
argument_list|(
name|address
argument_list|,
name|remaining
argument_list|)
decl_stmt|;
name|address
operator|+=
name|skipped
expr_stmt|;
name|remaining
operator|-=
name|skipped
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|// Optimize for interior runs of ASCII bytes.
comment|// TODO(nathanmittler): Consider checking 8 bytes at a time after some threshold?
comment|// Maybe after seeing a few in a row that are ASCII, go back to fast mode?
name|int
name|byte1
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|remaining
operator|>
literal|0
operator|&&
operator|(
name|byte1
operator|=
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|address
operator|++
argument_list|)
operator|)
operator|>=
literal|0
condition|;
operator|--
name|remaining
control|)
block|{         }
if|if
condition|(
name|remaining
operator|==
literal|0
condition|)
block|{
return|return
name|COMPLETE
return|;
block|}
name|remaining
operator|--
expr_stmt|;
if|if
condition|(
name|byte1
operator|<
operator|(
name|byte
operator|)
literal|0xE0
condition|)
block|{
comment|// Two-byte form
if|if
condition|(
name|remaining
operator|==
literal|0
condition|)
block|{
comment|// Incomplete sequence
return|return
name|byte1
return|;
block|}
name|remaining
operator|--
expr_stmt|;
comment|// Simultaneously checks for illegal trailing-byte in
comment|// leading position and overlong 2-byte form.
if|if
condition|(
name|byte1
argument_list|<
operator|(
name|byte
operator|)
literal|0xC2
operator|||
name|UnsafeUtil
operator|.
name|getByte
operator|(
name|address
operator|++
operator|)
argument_list|>
argument_list|(
name|byte
argument_list|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|byte1
operator|<
operator|(
name|byte
operator|)
literal|0xF0
condition|)
block|{
comment|// Three-byte form
if|if
condition|(
name|remaining
operator|<
literal|2
condition|)
block|{
comment|// Incomplete sequence
return|return
name|unsafeIncompleteStateFor
argument_list|(
name|address
argument_list|,
name|byte1
argument_list|,
name|remaining
argument_list|)
return|;
block|}
name|remaining
operator|-=
literal|2
expr_stmt|;
specifier|final
name|byte
name|byte2
init|=
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|address
operator|++
argument_list|)
decl_stmt|;
if|if
condition|(
name|byte2
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// overlong? 5 most significant bits must not all be zero
operator|||
operator|(
name|byte1
operator|==
operator|(
name|byte
operator|)
literal|0xE0
operator|&&
name|byte2
operator|<
operator|(
name|byte
operator|)
literal|0xA0
operator|)
comment|// check for illegal surrogate codepoints
operator|||
operator|(
name|byte1
operator|==
operator|(
name|byte
operator|)
literal|0xED
operator|&&
name|byte2
operator|>=
operator|(
name|byte
operator|)
literal|0xA0
operator|)
comment|// byte3 trailing-byte test
operator|||
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|address
operator|++
argument_list|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
else|else
block|{
comment|// Four-byte form
if|if
condition|(
name|remaining
operator|<
literal|3
condition|)
block|{
comment|// Incomplete sequence
return|return
name|unsafeIncompleteStateFor
argument_list|(
name|address
argument_list|,
name|byte1
argument_list|,
name|remaining
argument_list|)
return|;
block|}
name|remaining
operator|-=
literal|3
expr_stmt|;
specifier|final
name|byte
name|byte2
init|=
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|address
operator|++
argument_list|)
decl_stmt|;
if|if
condition|(
name|byte2
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// Check that 1<= plane<= 16.  Tricky optimized form of:
comment|// if (byte1> (byte) 0xF4 ||
comment|//     byte1 == (byte) 0xF0&& byte2< (byte) 0x90 ||
comment|//     byte1 == (byte) 0xF4&& byte2> (byte) 0x8F)
operator|||
operator|(
operator|(
operator|(
name|byte1
operator|<<
literal|28
operator|)
operator|+
operator|(
name|byte2
operator|-
operator|(
name|byte
operator|)
literal|0x90
operator|)
operator|)
operator|>>
literal|30
operator|)
operator|!=
literal|0
comment|// byte3 trailing-byte test
operator|||
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|address
operator|++
argument_list|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
comment|// byte4 trailing-byte test
operator|||
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|address
operator|++
argument_list|)
operator|>
operator|(
name|byte
operator|)
literal|0xBF
condition|)
block|{
return|return
name|MALFORMED
return|;
block|}
block|}
block|}
block|}
specifier|private
specifier|static
name|int
name|unsafeIncompleteStateFor
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|byte1
parameter_list|,
name|long
name|offset
parameter_list|,
name|int
name|remaining
parameter_list|)
block|{
switch|switch
condition|(
name|remaining
condition|)
block|{
case|case
literal|0
case|:
block|{
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|)
return|;
block|}
case|case
literal|1
case|:
block|{
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|,
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|)
argument_list|)
return|;
block|}
case|case
literal|2
case|:
block|{
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|,
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|)
argument_list|,
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
literal|1
argument_list|)
argument_list|)
return|;
block|}
default|default:
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
block|}
specifier|private
specifier|static
name|int
name|unsafeIncompleteStateFor
parameter_list|(
name|long
name|address
parameter_list|,
specifier|final
name|int
name|byte1
parameter_list|,
name|int
name|remaining
parameter_list|)
block|{
switch|switch
condition|(
name|remaining
condition|)
block|{
case|case
literal|0
case|:
block|{
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|)
return|;
block|}
case|case
literal|1
case|:
block|{
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|,
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|address
argument_list|)
argument_list|)
return|;
block|}
case|case
literal|2
case|:
block|{
return|return
name|incompleteStateFor
argument_list|(
name|byte1
argument_list|,
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|address
argument_list|)
argument_list|,
name|UnsafeUtil
operator|.
name|getByte
argument_list|(
name|address
operator|+
literal|1
argument_list|)
argument_list|)
return|;
block|}
default|default:
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
block|}
block|}
specifier|private
name|Utf8
parameter_list|()
block|{}
block|}
end_class

end_unit

