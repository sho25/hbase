begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|store
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ProcedureProtos
import|;
end_import

begin_comment
comment|/**  * Keeps track of live procedures.  *  * It can be used by the ProcedureStore to identify which procedures are already  * deleted/completed to avoid the deserialization step on restart  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
class|class
name|ProcedureStoreTracker
block|{
comment|// Key is procedure id corresponding to first bit of the bitmap.
specifier|private
specifier|final
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|BitSetNode
argument_list|>
name|map
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * If true, do not remove bits corresponding to deleted procedures. Note that this can result    * in huge bitmaps overtime.    * Currently, it's set to true only when building tracker state from logs during recovery. During    * recovery, if we are sure that a procedure has been deleted, reading its old update entries    * can be skipped.    */
specifier|private
name|boolean
name|keepDeletes
init|=
literal|false
decl_stmt|;
comment|/**    * If true, it means tracker has incomplete information about the active/deleted procedures.    * It's set to true only when recovering from old logs. See {@link #isDeleted(long)} docs to    * understand it's real use.    */
name|boolean
name|partial
init|=
literal|false
decl_stmt|;
specifier|private
name|long
name|minModifiedProcId
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
specifier|private
name|long
name|maxModifiedProcId
init|=
name|Long
operator|.
name|MIN_VALUE
decl_stmt|;
specifier|public
enum|enum
name|DeleteState
block|{
name|YES
block|,
name|NO
block|,
name|MAYBE
block|}
specifier|public
name|void
name|resetToProto
parameter_list|(
name|ProcedureProtos
operator|.
name|ProcedureStoreTracker
name|trackerProtoBuf
parameter_list|)
block|{
name|reset
argument_list|()
expr_stmt|;
for|for
control|(
name|ProcedureProtos
operator|.
name|ProcedureStoreTracker
operator|.
name|TrackerNode
name|protoNode
range|:
name|trackerProtoBuf
operator|.
name|getNodeList
argument_list|()
control|)
block|{
specifier|final
name|BitSetNode
name|node
init|=
operator|new
name|BitSetNode
argument_list|(
name|protoNode
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|node
operator|.
name|getStart
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Resets internal state to same as given {@code tracker}. Does deep copy of the bitmap.    */
specifier|public
name|void
name|resetTo
parameter_list|(
name|ProcedureStoreTracker
name|tracker
parameter_list|)
block|{
name|resetTo
argument_list|(
name|tracker
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Resets internal state to same as given {@code tracker}, and change the deleted flag according    * to the modified flag if {@code resetDelete} is true. Does deep copy of the bitmap.    *<p/>    * The {@code resetDelete} will be set to true when building cleanup tracker, please see the    * comments in {@link BitSetNode#BitSetNode(BitSetNode, boolean)} to learn how we change the    * deleted flag if {@code resetDelete} is true.    */
specifier|public
name|void
name|resetTo
parameter_list|(
name|ProcedureStoreTracker
name|tracker
parameter_list|,
name|boolean
name|resetDelete
parameter_list|)
block|{
name|reset
argument_list|()
expr_stmt|;
name|this
operator|.
name|partial
operator|=
name|tracker
operator|.
name|partial
expr_stmt|;
name|this
operator|.
name|minModifiedProcId
operator|=
name|tracker
operator|.
name|minModifiedProcId
expr_stmt|;
name|this
operator|.
name|maxModifiedProcId
operator|=
name|tracker
operator|.
name|maxModifiedProcId
expr_stmt|;
name|this
operator|.
name|keepDeletes
operator|=
name|tracker
operator|.
name|keepDeletes
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|BitSetNode
argument_list|>
name|entry
range|:
name|tracker
operator|.
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|map
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
operator|new
name|BitSetNode
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|resetDelete
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|insert
parameter_list|(
name|long
name|procId
parameter_list|)
block|{
name|insert
argument_list|(
literal|null
argument_list|,
name|procId
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|insert
parameter_list|(
name|long
index|[]
name|procIds
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|procIds
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|insert
argument_list|(
name|procIds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|insert
parameter_list|(
name|long
name|procId
parameter_list|,
name|long
index|[]
name|subProcIds
parameter_list|)
block|{
name|BitSetNode
name|node
init|=
name|update
argument_list|(
literal|null
argument_list|,
name|procId
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subProcIds
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|node
operator|=
name|insert
argument_list|(
name|node
argument_list|,
name|subProcIds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|BitSetNode
name|insert
parameter_list|(
name|BitSetNode
name|node
parameter_list|,
name|long
name|procId
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
literal|null
operator|||
operator|!
name|node
operator|.
name|contains
argument_list|(
name|procId
argument_list|)
condition|)
block|{
name|node
operator|=
name|getOrCreateNode
argument_list|(
name|procId
argument_list|)
expr_stmt|;
block|}
name|node
operator|.
name|insertOrUpdate
argument_list|(
name|procId
argument_list|)
expr_stmt|;
name|trackProcIds
argument_list|(
name|procId
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
specifier|public
name|void
name|update
parameter_list|(
name|long
name|procId
parameter_list|)
block|{
name|update
argument_list|(
literal|null
argument_list|,
name|procId
argument_list|)
expr_stmt|;
block|}
specifier|private
name|BitSetNode
name|update
parameter_list|(
name|BitSetNode
name|node
parameter_list|,
name|long
name|procId
parameter_list|)
block|{
name|node
operator|=
name|lookupClosestNode
argument_list|(
name|node
argument_list|,
name|procId
argument_list|)
expr_stmt|;
assert|assert
name|node
operator|!=
literal|null
operator|:
literal|"expected node to update procId="
operator|+
name|procId
assert|;
assert|assert
name|node
operator|.
name|contains
argument_list|(
name|procId
argument_list|)
operator|:
literal|"expected procId="
operator|+
name|procId
operator|+
literal|" in the node"
assert|;
name|node
operator|.
name|insertOrUpdate
argument_list|(
name|procId
argument_list|)
expr_stmt|;
name|trackProcIds
argument_list|(
name|procId
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
specifier|public
name|void
name|delete
parameter_list|(
name|long
name|procId
parameter_list|)
block|{
name|delete
argument_list|(
literal|null
argument_list|,
name|procId
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|delete
parameter_list|(
specifier|final
name|long
index|[]
name|procIds
parameter_list|)
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|procIds
argument_list|)
expr_stmt|;
name|BitSetNode
name|node
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|procIds
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|node
operator|=
name|delete
argument_list|(
name|node
argument_list|,
name|procIds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|BitSetNode
name|delete
parameter_list|(
name|BitSetNode
name|node
parameter_list|,
name|long
name|procId
parameter_list|)
block|{
name|node
operator|=
name|lookupClosestNode
argument_list|(
name|node
argument_list|,
name|procId
argument_list|)
expr_stmt|;
assert|assert
name|node
operator|!=
literal|null
operator|:
literal|"expected node to delete procId="
operator|+
name|procId
assert|;
assert|assert
name|node
operator|.
name|contains
argument_list|(
name|procId
argument_list|)
operator|:
literal|"expected procId="
operator|+
name|procId
operator|+
literal|" in the node"
assert|;
name|node
operator|.
name|delete
argument_list|(
name|procId
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|keepDeletes
operator|&&
name|node
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// TODO: RESET if (map.size() == 1)
name|map
operator|.
name|remove
argument_list|(
name|node
operator|.
name|getStart
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|trackProcIds
argument_list|(
name|procId
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
comment|/**    * Will be called when restarting where we need to rebuild the ProcedureStoreTracker.    */
specifier|public
name|void
name|setMinMaxModifiedProcIds
parameter_list|(
name|long
name|min
parameter_list|,
name|long
name|max
parameter_list|)
block|{
name|this
operator|.
name|minModifiedProcId
operator|=
name|min
expr_stmt|;
name|this
operator|.
name|maxModifiedProcId
operator|=
name|max
expr_stmt|;
block|}
comment|/**    * This method is used when restarting where we need to rebuild the ProcedureStoreTracker. The    * {@link #delete(long)} method above assume that the {@link BitSetNode} exists, but when restart    * this is not true, as we will read the wal files in reverse order so a delete may come first.    */
specifier|public
name|void
name|setDeleted
parameter_list|(
name|long
name|procId
parameter_list|,
name|boolean
name|isDeleted
parameter_list|)
block|{
name|BitSetNode
name|node
init|=
name|getOrCreateNode
argument_list|(
name|procId
argument_list|)
decl_stmt|;
assert|assert
name|node
operator|.
name|contains
argument_list|(
name|procId
argument_list|)
operator|:
literal|"expected procId="
operator|+
name|procId
operator|+
literal|" in the node="
operator|+
name|node
assert|;
name|node
operator|.
name|updateState
argument_list|(
name|procId
argument_list|,
name|isDeleted
argument_list|)
expr_stmt|;
name|trackProcIds
argument_list|(
name|procId
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the given bit for the procId to delete if it was modified before.    *<p/>    * This method is used to test whether a procedure wal file can be safely deleted, as if all the    * procedures in the given procedure wal file has been modified in the new procedure wal files,    * then we can delete it.    */
specifier|public
name|void
name|setDeletedIfModified
parameter_list|(
name|long
modifier|...
name|procId
parameter_list|)
block|{
name|BitSetNode
name|node
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|procId
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|node
operator|=
name|lookupClosestNode
argument_list|(
name|node
argument_list|,
name|procId
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
operator|&&
name|node
operator|.
name|isModified
argument_list|(
name|procId
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|node
operator|.
name|delete
argument_list|(
name|procId
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Similar with {@link #setDeletedIfModified(long...)}, but here the {@code procId} are given by    * the {@code tracker}. If a procedure is modified by us, and also by the given {@code tracker},    * then we mark it as deleted.    * @see #setDeletedIfModified(long...)    */
specifier|public
name|void
name|setDeletedIfModifiedInBoth
parameter_list|(
name|ProcedureStoreTracker
name|tracker
parameter_list|)
block|{
name|BitSetNode
name|trackerNode
init|=
literal|null
decl_stmt|;
for|for
control|(
name|BitSetNode
name|node
range|:
name|map
operator|.
name|values
argument_list|()
control|)
block|{
specifier|final
name|long
name|minProcId
init|=
name|node
operator|.
name|getStart
argument_list|()
decl_stmt|;
specifier|final
name|long
name|maxProcId
init|=
name|node
operator|.
name|getEnd
argument_list|()
decl_stmt|;
for|for
control|(
name|long
name|procId
init|=
name|minProcId
init|;
name|procId
operator|<=
name|maxProcId
condition|;
operator|++
name|procId
control|)
block|{
if|if
condition|(
operator|!
name|node
operator|.
name|isModified
argument_list|(
name|procId
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|trackerNode
operator|=
name|tracker
operator|.
name|lookupClosestNode
argument_list|(
name|trackerNode
argument_list|,
name|procId
argument_list|)
expr_stmt|;
if|if
condition|(
name|trackerNode
operator|==
literal|null
operator|||
operator|!
name|trackerNode
operator|.
name|contains
argument_list|(
name|procId
argument_list|)
operator|||
name|trackerNode
operator|.
name|isModified
argument_list|(
name|procId
argument_list|)
condition|)
block|{
comment|// the procedure was removed or modified
name|node
operator|.
name|delete
argument_list|(
name|procId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * lookup the node containing the specified procId.    * @param node cached node to check before doing a lookup    * @param procId the procId to lookup    * @return the node that may contains the procId or null    */
specifier|private
name|BitSetNode
name|lookupClosestNode
parameter_list|(
specifier|final
name|BitSetNode
name|node
parameter_list|,
specifier|final
name|long
name|procId
parameter_list|)
block|{
if|if
condition|(
name|node
operator|!=
literal|null
operator|&&
name|node
operator|.
name|contains
argument_list|(
name|procId
argument_list|)
condition|)
return|return
name|node
return|;
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|BitSetNode
argument_list|>
name|entry
init|=
name|map
operator|.
name|floorEntry
argument_list|(
name|procId
argument_list|)
decl_stmt|;
return|return
name|entry
operator|!=
literal|null
condition|?
name|entry
operator|.
name|getValue
argument_list|()
else|:
literal|null
return|;
block|}
specifier|private
name|void
name|trackProcIds
parameter_list|(
name|long
name|procId
parameter_list|)
block|{
name|minModifiedProcId
operator|=
name|Math
operator|.
name|min
argument_list|(
name|minModifiedProcId
argument_list|,
name|procId
argument_list|)
expr_stmt|;
name|maxModifiedProcId
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxModifiedProcId
argument_list|,
name|procId
argument_list|)
expr_stmt|;
block|}
specifier|public
name|long
name|getModifiedMinProcId
parameter_list|()
block|{
return|return
name|minModifiedProcId
return|;
block|}
specifier|public
name|long
name|getModifiedMaxProcId
parameter_list|()
block|{
return|return
name|maxModifiedProcId
return|;
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|this
operator|.
name|keepDeletes
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|partial
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
name|resetModified
argument_list|()
expr_stmt|;
block|}
specifier|public
name|boolean
name|isModified
parameter_list|(
name|long
name|procId
parameter_list|)
block|{
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|BitSetNode
argument_list|>
name|entry
init|=
name|map
operator|.
name|floorEntry
argument_list|(
name|procId
argument_list|)
decl_stmt|;
return|return
name|entry
operator|!=
literal|null
operator|&&
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|contains
argument_list|(
name|procId
argument_list|)
operator|&&
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|isModified
argument_list|(
name|procId
argument_list|)
return|;
block|}
comment|/**    * If {@link #partial} is false, returns state from the bitmap. If no state is found for    * {@code procId}, returns YES.    * If partial is true, tracker doesn't have complete view of system state, so it returns MAYBE    * if there is no update for the procedure or if it doesn't have a state in bitmap. Otherwise,    * returns state from the bitmap.    */
specifier|public
name|DeleteState
name|isDeleted
parameter_list|(
name|long
name|procId
parameter_list|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|BitSetNode
argument_list|>
name|entry
init|=
name|map
operator|.
name|floorEntry
argument_list|(
name|procId
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
operator|&&
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|contains
argument_list|(
name|procId
argument_list|)
condition|)
block|{
name|BitSetNode
name|node
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|DeleteState
name|state
init|=
name|node
operator|.
name|isDeleted
argument_list|(
name|procId
argument_list|)
decl_stmt|;
return|return
name|partial
operator|&&
operator|!
name|node
operator|.
name|isModified
argument_list|(
name|procId
argument_list|)
condition|?
name|DeleteState
operator|.
name|MAYBE
else|:
name|state
return|;
block|}
return|return
name|partial
condition|?
name|DeleteState
operator|.
name|MAYBE
else|:
name|DeleteState
operator|.
name|YES
return|;
block|}
specifier|public
name|long
name|getActiveMinProcId
parameter_list|()
block|{
comment|// TODO: Cache?
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|BitSetNode
argument_list|>
name|entry
init|=
name|map
operator|.
name|firstEntry
argument_list|()
decl_stmt|;
return|return
name|entry
operator|==
literal|null
condition|?
literal|0
else|:
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getActiveMinProcId
argument_list|()
return|;
block|}
specifier|public
name|void
name|setKeepDeletes
parameter_list|(
name|boolean
name|keepDeletes
parameter_list|)
block|{
name|this
operator|.
name|keepDeletes
operator|=
name|keepDeletes
expr_stmt|;
comment|// If not to keep deletes, remove the BitSetNodes which are empty (i.e. contains ids of deleted
comment|// procedures).
if|if
condition|(
operator|!
name|keepDeletes
condition|)
block|{
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|BitSetNode
argument_list|>
argument_list|>
name|it
init|=
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|BitSetNode
argument_list|>
name|entry
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|public
name|boolean
name|isPartial
parameter_list|()
block|{
return|return
name|partial
return|;
block|}
specifier|public
name|void
name|setPartialFlag
parameter_list|(
name|boolean
name|isPartial
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|partial
operator|&&
operator|!
name|isPartial
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|BitSetNode
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|unsetPartialFlag
argument_list|()
expr_stmt|;
block|}
block|}
name|this
operator|.
name|partial
operator|=
name|isPartial
expr_stmt|;
block|}
comment|/**    * @return true, if no procedure is active, else false.    */
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|BitSetNode
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * @return true if all procedure was modified or deleted since last call to    *         {@link #resetModified()}.    */
specifier|public
name|boolean
name|isAllModified
parameter_list|()
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|BitSetNode
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|isAllModified
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Clears the list of updated procedure ids. This doesn't affect global list of active    * procedure ids.    */
specifier|public
name|void
name|resetModified
parameter_list|()
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|BitSetNode
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|resetModified
argument_list|()
expr_stmt|;
block|}
name|minModifiedProcId
operator|=
name|Long
operator|.
name|MAX_VALUE
expr_stmt|;
name|maxModifiedProcId
operator|=
name|Long
operator|.
name|MIN_VALUE
expr_stmt|;
block|}
specifier|private
name|BitSetNode
name|getOrCreateNode
parameter_list|(
name|long
name|procId
parameter_list|)
block|{
comment|// If procId can fit in left node (directly or by growing it)
name|BitSetNode
name|leftNode
init|=
literal|null
decl_stmt|;
name|boolean
name|leftCanGrow
init|=
literal|false
decl_stmt|;
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|BitSetNode
argument_list|>
name|leftEntry
init|=
name|map
operator|.
name|floorEntry
argument_list|(
name|procId
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftEntry
operator|!=
literal|null
condition|)
block|{
name|leftNode
operator|=
name|leftEntry
operator|.
name|getValue
argument_list|()
expr_stmt|;
if|if
condition|(
name|leftNode
operator|.
name|contains
argument_list|(
name|procId
argument_list|)
condition|)
block|{
return|return
name|leftNode
return|;
block|}
name|leftCanGrow
operator|=
name|leftNode
operator|.
name|canGrow
argument_list|(
name|procId
argument_list|)
expr_stmt|;
block|}
comment|// If procId can fit in right node (directly or by growing it)
name|BitSetNode
name|rightNode
init|=
literal|null
decl_stmt|;
name|boolean
name|rightCanGrow
init|=
literal|false
decl_stmt|;
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|BitSetNode
argument_list|>
name|rightEntry
init|=
name|map
operator|.
name|ceilingEntry
argument_list|(
name|procId
argument_list|)
decl_stmt|;
if|if
condition|(
name|rightEntry
operator|!=
literal|null
condition|)
block|{
name|rightNode
operator|=
name|rightEntry
operator|.
name|getValue
argument_list|()
expr_stmt|;
name|rightCanGrow
operator|=
name|rightNode
operator|.
name|canGrow
argument_list|(
name|procId
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftNode
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|leftNode
operator|.
name|canMerge
argument_list|(
name|rightNode
argument_list|)
condition|)
block|{
comment|// merge left and right node
return|return
name|mergeNodes
argument_list|(
name|leftNode
argument_list|,
name|rightNode
argument_list|)
return|;
block|}
comment|// If left and right nodes can not merge, decide which one to grow.
if|if
condition|(
name|leftCanGrow
operator|&&
name|rightCanGrow
condition|)
block|{
if|if
condition|(
operator|(
name|procId
operator|-
name|leftNode
operator|.
name|getEnd
argument_list|()
operator|)
operator|<=
operator|(
name|rightNode
operator|.
name|getStart
argument_list|()
operator|-
name|procId
operator|)
condition|)
block|{
return|return
name|growNode
argument_list|(
name|leftNode
argument_list|,
name|procId
argument_list|)
return|;
block|}
return|return
name|growNode
argument_list|(
name|rightNode
argument_list|,
name|procId
argument_list|)
return|;
block|}
block|}
block|}
comment|// grow the left node
if|if
condition|(
name|leftCanGrow
condition|)
block|{
return|return
name|growNode
argument_list|(
name|leftNode
argument_list|,
name|procId
argument_list|)
return|;
block|}
comment|// grow the right node
if|if
condition|(
name|rightCanGrow
condition|)
block|{
return|return
name|growNode
argument_list|(
name|rightNode
argument_list|,
name|procId
argument_list|)
return|;
block|}
comment|// add new node if there are no left/right nodes which can be used.
name|BitSetNode
name|node
init|=
operator|new
name|BitSetNode
argument_list|(
name|procId
argument_list|,
name|partial
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|node
operator|.
name|getStart
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
comment|/**    * Grows {@code node} to contain {@code procId} and updates the map.    * @return {@link BitSetNode} instance which contains {@code procId}.    */
specifier|private
name|BitSetNode
name|growNode
parameter_list|(
name|BitSetNode
name|node
parameter_list|,
name|long
name|procId
parameter_list|)
block|{
name|map
operator|.
name|remove
argument_list|(
name|node
operator|.
name|getStart
argument_list|()
argument_list|)
expr_stmt|;
name|node
operator|.
name|grow
argument_list|(
name|procId
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|node
operator|.
name|getStart
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
comment|/**    * Merges {@code leftNode}& {@code rightNode} and updates the map.    */
specifier|private
name|BitSetNode
name|mergeNodes
parameter_list|(
name|BitSetNode
name|leftNode
parameter_list|,
name|BitSetNode
name|rightNode
parameter_list|)
block|{
assert|assert
name|leftNode
operator|.
name|getStart
argument_list|()
operator|<
name|rightNode
operator|.
name|getStart
argument_list|()
assert|;
name|leftNode
operator|.
name|merge
argument_list|(
name|rightNode
argument_list|)
expr_stmt|;
name|map
operator|.
name|remove
argument_list|(
name|rightNode
operator|.
name|getStart
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|leftNode
return|;
block|}
specifier|public
name|void
name|dump
parameter_list|()
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"map "
operator|+
name|map
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"isAllModified "
operator|+
name|isAllModified
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"isEmpty "
operator|+
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|BitSetNode
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|dump
argument_list|()
expr_stmt|;
block|}
block|}
comment|// ========================================================================
comment|//  Convert to/from Protocol Buffer.
comment|// ========================================================================
comment|/**    * Builds    * org.apache.hadoop.hbase.protobuf.generated.ProcedureProtos.ProcedureStoreTracker    * protocol buffer from current state.    */
specifier|public
name|ProcedureProtos
operator|.
name|ProcedureStoreTracker
name|toProto
parameter_list|()
throws|throws
name|IOException
block|{
name|ProcedureProtos
operator|.
name|ProcedureStoreTracker
operator|.
name|Builder
name|builder
init|=
name|ProcedureProtos
operator|.
name|ProcedureStoreTracker
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|BitSetNode
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|builder
operator|.
name|addNode
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|convert
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
block|}
end_class

end_unit

