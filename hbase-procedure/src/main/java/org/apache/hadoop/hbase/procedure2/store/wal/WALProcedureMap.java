begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|store
operator|.
name|wal
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|Procedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|ProcedureUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|store
operator|.
name|ProcedureStore
operator|.
name|ProcedureIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ProcedureProtos
import|;
end_import

begin_comment
comment|/**  * We keep an in-memory map of the procedures sorted by replay order. (see the details in the  * beginning of {@link ProcedureWALFormatReader}).  *  *<pre>  *      procedureMap = | A |   | E |   | C |   |   |   |   | G |   |   |  *                       D               B  *      replayOrderHead = C<-> B<-> E<-> D<-> A<-> G  *  *  We also have a lazy grouping by "root procedure", and a list of  *  unlinked procedures. If after reading all the WALs we have unlinked  *  procedures it means that we had a missing WAL or a corruption.  *      rootHead = A<-> D<-> G  *                 B     E  *                 C  *      unlinkFromLinkList = None  *</pre>  */
end_comment

begin_class
class|class
name|WALProcedureMap
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|WALProcedureMap
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
class|class
name|Entry
block|{
comment|// For bucketed linked lists in hash-table.
specifier|private
name|Entry
name|hashNext
decl_stmt|;
comment|// child head
specifier|private
name|Entry
name|childHead
decl_stmt|;
comment|// double-link for rootHead or childHead
specifier|private
name|Entry
name|linkNext
decl_stmt|;
specifier|private
name|Entry
name|linkPrev
decl_stmt|;
comment|// replay double-linked-list
specifier|private
name|Entry
name|replayNext
decl_stmt|;
specifier|private
name|Entry
name|replayPrev
decl_stmt|;
comment|// procedure-infos
specifier|private
name|Procedure
argument_list|<
name|?
argument_list|>
name|procedure
decl_stmt|;
specifier|private
name|ProcedureProtos
operator|.
name|Procedure
name|proto
decl_stmt|;
specifier|private
name|boolean
name|ready
init|=
literal|false
decl_stmt|;
specifier|public
name|Entry
parameter_list|(
name|Entry
name|hashNext
parameter_list|)
block|{
name|this
operator|.
name|hashNext
operator|=
name|hashNext
expr_stmt|;
block|}
specifier|public
name|long
name|getProcId
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getProcId
argument_list|()
return|;
block|}
specifier|public
name|long
name|getParentId
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getParentId
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|hasParent
parameter_list|()
block|{
return|return
name|proto
operator|.
name|hasParentId
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|isReady
parameter_list|()
block|{
return|return
name|ready
return|;
block|}
specifier|public
name|boolean
name|isFinished
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasParent
argument_list|()
condition|)
block|{
comment|// we only consider 'root' procedures. because for the user 'finished'
comment|// means when everything up to the 'root' is finished.
switch|switch
condition|(
name|proto
operator|.
name|getState
argument_list|()
condition|)
block|{
case|case
name|ROLLEDBACK
case|:
case|case
name|SUCCESS
case|:
return|return
literal|true
return|;
default|default:
break|break;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|Procedure
argument_list|<
name|?
argument_list|>
name|convert
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|procedure
operator|==
literal|null
condition|)
block|{
name|procedure
operator|=
name|ProcedureUtil
operator|.
name|convertToProcedure
argument_list|(
name|proto
argument_list|)
expr_stmt|;
block|}
return|return
name|procedure
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"Entry("
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getProcId
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", parentId="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getParentId
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", class="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|proto
operator|.
name|getClassName
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|EntryIterator
implements|implements
name|ProcedureIterator
block|{
specifier|private
specifier|final
name|Entry
name|replayHead
decl_stmt|;
specifier|private
name|Entry
name|current
decl_stmt|;
specifier|public
name|EntryIterator
parameter_list|(
name|Entry
name|replayHead
parameter_list|)
block|{
name|this
operator|.
name|replayHead
operator|=
name|replayHead
expr_stmt|;
name|this
operator|.
name|current
operator|=
name|replayHead
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|this
operator|.
name|current
operator|=
name|replayHead
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|current
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isNextFinished
parameter_list|()
block|{
return|return
name|current
operator|!=
literal|null
operator|&&
name|current
operator|.
name|isFinished
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|skipNext
parameter_list|()
block|{
name|current
operator|=
name|current
operator|.
name|replayNext
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Procedure
argument_list|<
name|?
argument_list|>
name|next
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|current
operator|.
name|convert
argument_list|()
return|;
block|}
finally|finally
block|{
name|current
operator|=
name|current
operator|.
name|replayNext
expr_stmt|;
block|}
block|}
block|}
comment|// procedure hash table
specifier|private
name|Entry
index|[]
name|procedureMap
decl_stmt|;
comment|// replay-order double-linked-list
specifier|private
name|Entry
name|replayOrderHead
decl_stmt|;
specifier|private
name|Entry
name|replayOrderTail
decl_stmt|;
comment|// root linked-list
specifier|private
name|Entry
name|rootHead
decl_stmt|;
comment|// pending unlinked children (root not present yet)
specifier|private
name|Entry
name|childUnlinkedHead
decl_stmt|;
comment|// Track ProcId range
specifier|private
name|long
name|minModifiedProcId
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
specifier|private
name|long
name|maxModifiedProcId
init|=
name|Long
operator|.
name|MIN_VALUE
decl_stmt|;
specifier|public
name|WALProcedureMap
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|procedureMap
operator|=
operator|new
name|Entry
index|[
name|size
index|]
expr_stmt|;
name|replayOrderHead
operator|=
literal|null
expr_stmt|;
name|replayOrderTail
operator|=
literal|null
expr_stmt|;
name|rootHead
operator|=
literal|null
expr_stmt|;
name|childUnlinkedHead
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
name|void
name|add
parameter_list|(
name|ProcedureProtos
operator|.
name|Procedure
name|procProto
parameter_list|)
block|{
name|trackProcIds
argument_list|(
name|procProto
operator|.
name|getProcId
argument_list|()
argument_list|)
expr_stmt|;
name|Entry
name|entry
init|=
name|addToMap
argument_list|(
name|procProto
operator|.
name|getProcId
argument_list|()
argument_list|,
name|procProto
operator|.
name|hasParentId
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|newEntry
init|=
name|entry
operator|.
name|proto
operator|==
literal|null
decl_stmt|;
comment|// We have seen procedure WALs where the entries are out of order; see HBASE-18152.
comment|// To compensate, only replace the Entry procedure if for sure this new procedure
comment|// is indeed an entry that came later.
comment|// TODO: Fix the writing of procedure info so it does not violate basic expectation, that WALs
comment|// contain procedure changes goingfrom start to finish in sequence.
if|if
condition|(
name|newEntry
operator|||
name|isIncreasing
argument_list|(
name|entry
operator|.
name|proto
argument_list|,
name|procProto
argument_list|)
condition|)
block|{
name|entry
operator|.
name|proto
operator|=
name|procProto
expr_stmt|;
block|}
name|addToReplayList
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|newEntry
condition|)
block|{
if|if
condition|(
name|procProto
operator|.
name|hasParentId
argument_list|()
condition|)
block|{
name|childUnlinkedHead
operator|=
name|addToLinkList
argument_list|(
name|entry
argument_list|,
name|childUnlinkedHead
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rootHead
operator|=
name|addToLinkList
argument_list|(
name|entry
argument_list|,
name|rootHead
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * @return True if this new procedure is 'richer' than the current one else false and we log this    *         incidence where it appears that the WAL has older entries appended after newer ones.    *         See HBASE-18152.    */
specifier|private
specifier|static
name|boolean
name|isIncreasing
parameter_list|(
name|ProcedureProtos
operator|.
name|Procedure
name|current
parameter_list|,
name|ProcedureProtos
operator|.
name|Procedure
name|candidate
parameter_list|)
block|{
comment|// Check that the procedures we see are 'increasing'. We used to compare
comment|// procedure id first and then update time but it can legitimately go backwards if the
comment|// procedure is failed or rolled back so that was unreliable. Was going to compare
comment|// state but lets see if comparing update time enough (unfortunately this issue only
comment|// seen under load...)
name|boolean
name|increasing
init|=
name|current
operator|.
name|getLastUpdate
argument_list|()
operator|<=
name|candidate
operator|.
name|getLastUpdate
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|increasing
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"NOT INCREASING! current="
operator|+
name|current
operator|+
literal|", candidate="
operator|+
name|candidate
argument_list|)
expr_stmt|;
block|}
return|return
name|increasing
return|;
block|}
specifier|public
name|boolean
name|remove
parameter_list|(
name|long
name|procId
parameter_list|)
block|{
name|trackProcIds
argument_list|(
name|procId
argument_list|)
expr_stmt|;
name|Entry
name|entry
init|=
name|removeFromMap
argument_list|(
name|procId
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
name|unlinkFromReplayList
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|unlinkFromLinkList
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|void
name|trackProcIds
parameter_list|(
name|long
name|procId
parameter_list|)
block|{
name|minModifiedProcId
operator|=
name|Math
operator|.
name|min
argument_list|(
name|minModifiedProcId
argument_list|,
name|procId
argument_list|)
expr_stmt|;
name|maxModifiedProcId
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxModifiedProcId
argument_list|,
name|procId
argument_list|)
expr_stmt|;
block|}
specifier|public
name|long
name|getMinModifiedProcId
parameter_list|()
block|{
return|return
name|minModifiedProcId
return|;
block|}
specifier|public
name|long
name|getMaxModifiedProcId
parameter_list|()
block|{
return|return
name|maxModifiedProcId
return|;
block|}
specifier|public
name|boolean
name|contains
parameter_list|(
name|long
name|procId
parameter_list|)
block|{
return|return
name|getProcedure
argument_list|(
name|procId
argument_list|)
operator|!=
literal|null
return|;
block|}
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|replayOrderHead
operator|==
literal|null
return|;
block|}
specifier|public
name|void
name|clear
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|procedureMap
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|procedureMap
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
name|replayOrderHead
operator|=
literal|null
expr_stmt|;
name|replayOrderTail
operator|=
literal|null
expr_stmt|;
name|rootHead
operator|=
literal|null
expr_stmt|;
name|childUnlinkedHead
operator|=
literal|null
expr_stmt|;
name|minModifiedProcId
operator|=
name|Long
operator|.
name|MAX_VALUE
expr_stmt|;
name|maxModifiedProcId
operator|=
name|Long
operator|.
name|MIN_VALUE
expr_stmt|;
block|}
comment|/*    * Merges two WalProcedureMap, the target is the "global" map, the source is the "local" map. -    * The entries in the hashtables are guaranteed to be unique. On replay we don't load procedures    * that already exist in the "global" map (the one we are merging the "local" in to). - The    * replayOrderList of the "local" nao will be appended to the "global" map replay list. - The    * "local" map will be cleared at the end of the operation.    */
specifier|public
name|void
name|mergeTail
parameter_list|(
name|WALProcedureMap
name|other
parameter_list|)
block|{
for|for
control|(
name|Entry
name|p
init|=
name|other
operator|.
name|replayOrderHead
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|p
operator|.
name|replayNext
control|)
block|{
name|int
name|slotIndex
init|=
name|getMapSlot
argument_list|(
name|p
operator|.
name|getProcId
argument_list|()
argument_list|)
decl_stmt|;
name|p
operator|.
name|hashNext
operator|=
name|procedureMap
index|[
name|slotIndex
index|]
expr_stmt|;
name|procedureMap
index|[
name|slotIndex
index|]
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|replayOrderHead
operator|==
literal|null
condition|)
block|{
name|replayOrderHead
operator|=
name|other
operator|.
name|replayOrderHead
expr_stmt|;
name|replayOrderTail
operator|=
name|other
operator|.
name|replayOrderTail
expr_stmt|;
name|rootHead
operator|=
name|other
operator|.
name|rootHead
expr_stmt|;
name|childUnlinkedHead
operator|=
name|other
operator|.
name|childUnlinkedHead
expr_stmt|;
block|}
else|else
block|{
comment|// append replay list
assert|assert
name|replayOrderTail
operator|.
name|replayNext
operator|==
literal|null
assert|;
assert|assert
name|other
operator|.
name|replayOrderHead
operator|.
name|replayPrev
operator|==
literal|null
assert|;
name|replayOrderTail
operator|.
name|replayNext
operator|=
name|other
operator|.
name|replayOrderHead
expr_stmt|;
name|other
operator|.
name|replayOrderHead
operator|.
name|replayPrev
operator|=
name|replayOrderTail
expr_stmt|;
name|replayOrderTail
operator|=
name|other
operator|.
name|replayOrderTail
expr_stmt|;
comment|// merge rootHead
if|if
condition|(
name|rootHead
operator|==
literal|null
condition|)
block|{
name|rootHead
operator|=
name|other
operator|.
name|rootHead
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|other
operator|.
name|rootHead
operator|!=
literal|null
condition|)
block|{
name|Entry
name|otherTail
init|=
name|findLinkListTail
argument_list|(
name|other
operator|.
name|rootHead
argument_list|)
decl_stmt|;
name|otherTail
operator|.
name|linkNext
operator|=
name|rootHead
expr_stmt|;
name|rootHead
operator|.
name|linkPrev
operator|=
name|otherTail
expr_stmt|;
name|rootHead
operator|=
name|other
operator|.
name|rootHead
expr_stmt|;
block|}
comment|// merge childUnlinkedHead
if|if
condition|(
name|childUnlinkedHead
operator|==
literal|null
condition|)
block|{
name|childUnlinkedHead
operator|=
name|other
operator|.
name|childUnlinkedHead
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|other
operator|.
name|childUnlinkedHead
operator|!=
literal|null
condition|)
block|{
name|Entry
name|otherTail
init|=
name|findLinkListTail
argument_list|(
name|other
operator|.
name|childUnlinkedHead
argument_list|)
decl_stmt|;
name|otherTail
operator|.
name|linkNext
operator|=
name|childUnlinkedHead
expr_stmt|;
name|childUnlinkedHead
operator|.
name|linkPrev
operator|=
name|otherTail
expr_stmt|;
name|childUnlinkedHead
operator|=
name|other
operator|.
name|childUnlinkedHead
expr_stmt|;
block|}
block|}
name|maxModifiedProcId
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxModifiedProcId
argument_list|,
name|other
operator|.
name|maxModifiedProcId
argument_list|)
expr_stmt|;
name|minModifiedProcId
operator|=
name|Math
operator|.
name|max
argument_list|(
name|minModifiedProcId
argument_list|,
name|other
operator|.
name|minModifiedProcId
argument_list|)
expr_stmt|;
name|other
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * Returns an EntryIterator with the list of procedures ready to be added to the executor. A    * Procedure is ready if its children and parent are ready.    */
specifier|public
name|ProcedureIterator
name|fetchReady
parameter_list|()
block|{
name|buildGraph
argument_list|()
expr_stmt|;
name|Entry
name|readyHead
init|=
literal|null
decl_stmt|;
name|Entry
name|readyTail
init|=
literal|null
decl_stmt|;
name|Entry
name|p
init|=
name|replayOrderHead
decl_stmt|;
while|while
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|Entry
name|next
init|=
name|p
operator|.
name|replayNext
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|isReady
argument_list|()
condition|)
block|{
name|unlinkFromReplayList
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|readyTail
operator|!=
literal|null
condition|)
block|{
name|readyTail
operator|.
name|replayNext
operator|=
name|p
expr_stmt|;
name|p
operator|.
name|replayPrev
operator|=
name|readyTail
expr_stmt|;
block|}
else|else
block|{
name|p
operator|.
name|replayPrev
operator|=
literal|null
expr_stmt|;
name|readyHead
operator|=
name|p
expr_stmt|;
block|}
name|readyTail
operator|=
name|p
expr_stmt|;
name|p
operator|.
name|replayNext
operator|=
literal|null
expr_stmt|;
block|}
name|p
operator|=
name|next
expr_stmt|;
block|}
comment|// we need the hash-table lookups for parents, so this must be done
comment|// out of the loop where we check isReadyToRun()
for|for
control|(
name|p
operator|=
name|readyHead
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|p
operator|.
name|replayNext
control|)
block|{
name|removeFromMap
argument_list|(
name|p
operator|.
name|getProcId
argument_list|()
argument_list|)
expr_stmt|;
name|unlinkFromLinkList
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|readyHead
operator|!=
literal|null
condition|?
operator|new
name|EntryIterator
argument_list|(
name|readyHead
argument_list|)
else|:
literal|null
return|;
block|}
comment|/**    * Drain this map and return all procedures in it.    */
specifier|public
name|ProcedureIterator
name|fetchAll
parameter_list|()
block|{
name|Entry
name|head
init|=
name|replayOrderHead
decl_stmt|;
for|for
control|(
name|Entry
name|p
init|=
name|head
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|p
operator|.
name|replayNext
control|)
block|{
name|removeFromMap
argument_list|(
name|p
operator|.
name|getProcId
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|procedureMap
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
assert|assert
name|procedureMap
index|[
name|i
index|]
operator|==
literal|null
operator|:
literal|"map not empty i="
operator|+
name|i
assert|;
block|}
name|replayOrderHead
operator|=
literal|null
expr_stmt|;
name|replayOrderTail
operator|=
literal|null
expr_stmt|;
name|childUnlinkedHead
operator|=
literal|null
expr_stmt|;
name|rootHead
operator|=
literal|null
expr_stmt|;
return|return
name|head
operator|!=
literal|null
condition|?
operator|new
name|EntryIterator
argument_list|(
name|head
argument_list|)
else|:
literal|null
return|;
block|}
specifier|private
name|void
name|buildGraph
parameter_list|()
block|{
name|Entry
name|p
init|=
name|childUnlinkedHead
decl_stmt|;
while|while
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|Entry
name|next
init|=
name|p
operator|.
name|linkNext
decl_stmt|;
name|Entry
name|rootProc
init|=
name|getRootProcedure
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|rootProc
operator|!=
literal|null
condition|)
block|{
name|rootProc
operator|.
name|childHead
operator|=
name|addToLinkList
argument_list|(
name|p
argument_list|,
name|rootProc
operator|.
name|childHead
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|next
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|rootHead
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|p
operator|.
name|linkNext
control|)
block|{
name|checkReadyToRun
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|Entry
name|getRootProcedure
parameter_list|(
name|Entry
name|entry
parameter_list|)
block|{
while|while
condition|(
name|entry
operator|!=
literal|null
operator|&&
name|entry
operator|.
name|hasParent
argument_list|()
condition|)
block|{
name|entry
operator|=
name|getProcedure
argument_list|(
name|entry
operator|.
name|getParentId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
comment|/**    * (see the comprehensive explanation in the beginning of {@link ProcedureWALFormatReader}). A    * Procedure is ready when parent and children are ready. "ready" means that we all the    * information that we need in-memory.    *<p/>    * Example-1:<br/>    * We have two WALs, we start reading from the newest (wal-2)    *    *<pre>    *    wal-2 | C B |    *    wal-1 | A B C |    *</pre>    *    * If C and B don't depend on A (A is not the parent), we can start them before reading wal-1. If    * B is the only one with parent A we can start C. We have to read one more WAL before being able    * to start B.    *<p/>    * How do we know with the only information in B that we are not ready.    *<ul>    *<li>easy case, the parent is missing from the global map</li>    *<li>more complex case we look at the Stack IDs.</li>    *</ul>    * The Stack-IDs are added to the procedure order as an incremental index tracking how many times    * that procedure was executed, which is equivalent to the number of times we wrote the procedure    * to the WAL.<br/>    * In the example above:    *    *<pre>    *   wal-2: B has stackId = [1, 2]    *   wal-1: B has stackId = [1]    *   wal-1: A has stackId = [0]    *</pre>    *    * Since we know that the Stack-IDs are incremental for a Procedure, we notice that there is a gap    * in the stackIds of B, so something was executed before.    *<p/>    * To identify when a Procedure is ready we do the sum of the stackIds of the procedure and the    * parent. if the stackIdSum is equal to the sum of {1..maxStackId} then everything we need is    * available.    *<p/>    * Example-2    *    *<pre>    *    wal-2 | A |              A stackIds = [0, 2]    *    wal-1 | A B |            B stackIds = [1]    *</pre>    *    * There is a gap between A stackIds so something was executed in between.    */
specifier|private
name|boolean
name|checkReadyToRun
parameter_list|(
name|Entry
name|rootEntry
parameter_list|)
block|{
assert|assert
operator|!
name|rootEntry
operator|.
name|hasParent
argument_list|()
operator|:
literal|"expected root procedure, got "
operator|+
name|rootEntry
assert|;
if|if
condition|(
name|rootEntry
operator|.
name|isFinished
argument_list|()
condition|)
block|{
comment|// If the root procedure is finished, sub-procedures should be gone
if|if
condition|(
name|rootEntry
operator|.
name|childHead
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"unexpected active children for root-procedure: {}"
argument_list|,
name|rootEntry
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
name|p
init|=
name|rootEntry
operator|.
name|childHead
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|p
operator|.
name|linkNext
control|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"unexpected active children: {}"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
assert|assert
name|rootEntry
operator|.
name|childHead
operator|==
literal|null
operator|:
literal|"unexpected children on root completion. "
operator|+
name|rootEntry
assert|;
name|rootEntry
operator|.
name|ready
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
name|int
name|stackIdSum
init|=
literal|0
decl_stmt|;
name|int
name|maxStackId
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rootEntry
operator|.
name|proto
operator|.
name|getStackIdCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|int
name|stackId
init|=
literal|1
operator|+
name|rootEntry
operator|.
name|proto
operator|.
name|getStackId
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|maxStackId
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxStackId
argument_list|,
name|stackId
argument_list|)
expr_stmt|;
name|stackIdSum
operator|+=
name|stackId
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"stackId={} stackIdSum={} maxStackid={} {}"
argument_list|,
name|stackId
argument_list|,
name|stackIdSum
argument_list|,
name|maxStackId
argument_list|,
name|rootEntry
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Entry
name|p
init|=
name|rootEntry
operator|.
name|childHead
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|p
operator|.
name|linkNext
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|p
operator|.
name|proto
operator|.
name|getStackIdCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|int
name|stackId
init|=
literal|1
operator|+
name|p
operator|.
name|proto
operator|.
name|getStackId
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|maxStackId
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxStackId
argument_list|,
name|stackId
argument_list|)
expr_stmt|;
name|stackIdSum
operator|+=
name|stackId
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"stackId={} stackIdSum={} maxStackid={} {}"
argument_list|,
name|stackId
argument_list|,
name|stackIdSum
argument_list|,
name|maxStackId
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|// The cmpStackIdSum is this formula for finding the sum of a series of numbers:
comment|// http://www.wikihow.com/Sum-the-Integers-from-1-to-N#/Image:Sum-the-Integers-from-1-to-N-Step-2-Version-3.jpg
specifier|final
name|int
name|cmpStackIdSum
init|=
operator|(
name|maxStackId
operator|*
operator|(
name|maxStackId
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
decl_stmt|;
if|if
condition|(
name|cmpStackIdSum
operator|==
name|stackIdSum
condition|)
block|{
name|rootEntry
operator|.
name|ready
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|Entry
name|p
init|=
name|rootEntry
operator|.
name|childHead
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|p
operator|.
name|linkNext
control|)
block|{
name|p
operator|.
name|ready
operator|=
literal|true
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|void
name|unlinkFromReplayList
parameter_list|(
name|Entry
name|entry
parameter_list|)
block|{
if|if
condition|(
name|replayOrderHead
operator|==
name|entry
condition|)
block|{
name|replayOrderHead
operator|=
name|entry
operator|.
name|replayNext
expr_stmt|;
block|}
if|if
condition|(
name|replayOrderTail
operator|==
name|entry
condition|)
block|{
name|replayOrderTail
operator|=
name|entry
operator|.
name|replayPrev
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|.
name|replayPrev
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|replayPrev
operator|.
name|replayNext
operator|=
name|entry
operator|.
name|replayNext
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|.
name|replayNext
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|replayNext
operator|.
name|replayPrev
operator|=
name|entry
operator|.
name|replayPrev
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|addToReplayList
parameter_list|(
specifier|final
name|Entry
name|entry
parameter_list|)
block|{
name|unlinkFromReplayList
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|.
name|replayNext
operator|=
name|replayOrderHead
expr_stmt|;
name|entry
operator|.
name|replayPrev
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|replayOrderHead
operator|!=
literal|null
condition|)
block|{
name|replayOrderHead
operator|.
name|replayPrev
operator|=
name|entry
expr_stmt|;
block|}
else|else
block|{
name|replayOrderTail
operator|=
name|entry
expr_stmt|;
block|}
name|replayOrderHead
operator|=
name|entry
expr_stmt|;
block|}
specifier|private
name|void
name|unlinkFromLinkList
parameter_list|(
name|Entry
name|entry
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|==
name|rootHead
condition|)
block|{
name|rootHead
operator|=
name|entry
operator|.
name|linkNext
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|==
name|childUnlinkedHead
condition|)
block|{
name|childUnlinkedHead
operator|=
name|entry
operator|.
name|linkNext
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|.
name|linkPrev
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|linkPrev
operator|.
name|linkNext
operator|=
name|entry
operator|.
name|linkNext
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|.
name|linkNext
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|linkNext
operator|.
name|linkPrev
operator|=
name|entry
operator|.
name|linkPrev
expr_stmt|;
block|}
block|}
specifier|private
name|Entry
name|addToLinkList
parameter_list|(
name|Entry
name|entry
parameter_list|,
name|Entry
name|linkHead
parameter_list|)
block|{
name|unlinkFromLinkList
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|.
name|linkNext
operator|=
name|linkHead
expr_stmt|;
name|entry
operator|.
name|linkPrev
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|linkHead
operator|!=
literal|null
condition|)
block|{
name|linkHead
operator|.
name|linkPrev
operator|=
name|entry
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
specifier|private
name|Entry
name|findLinkListTail
parameter_list|(
name|Entry
name|linkHead
parameter_list|)
block|{
name|Entry
name|tail
init|=
name|linkHead
decl_stmt|;
while|while
condition|(
name|tail
operator|.
name|linkNext
operator|!=
literal|null
condition|)
block|{
name|tail
operator|=
name|tail
operator|.
name|linkNext
expr_stmt|;
block|}
return|return
name|tail
return|;
block|}
specifier|private
name|Entry
name|addToMap
parameter_list|(
name|long
name|procId
parameter_list|,
name|boolean
name|hasParent
parameter_list|)
block|{
name|int
name|slotIndex
init|=
name|getMapSlot
argument_list|(
name|procId
argument_list|)
decl_stmt|;
name|Entry
name|entry
init|=
name|getProcedure
argument_list|(
name|slotIndex
argument_list|,
name|procId
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
return|return
name|entry
return|;
block|}
name|entry
operator|=
operator|new
name|Entry
argument_list|(
name|procedureMap
index|[
name|slotIndex
index|]
argument_list|)
expr_stmt|;
name|procedureMap
index|[
name|slotIndex
index|]
operator|=
name|entry
expr_stmt|;
return|return
name|entry
return|;
block|}
specifier|private
name|Entry
name|removeFromMap
parameter_list|(
specifier|final
name|long
name|procId
parameter_list|)
block|{
name|int
name|slotIndex
init|=
name|getMapSlot
argument_list|(
name|procId
argument_list|)
decl_stmt|;
name|Entry
name|prev
init|=
literal|null
decl_stmt|;
name|Entry
name|entry
init|=
name|procedureMap
index|[
name|slotIndex
index|]
decl_stmt|;
while|while
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|procId
operator|==
name|entry
operator|.
name|getProcId
argument_list|()
condition|)
block|{
if|if
condition|(
name|prev
operator|!=
literal|null
condition|)
block|{
name|prev
operator|.
name|hashNext
operator|=
name|entry
operator|.
name|hashNext
expr_stmt|;
block|}
else|else
block|{
name|procedureMap
index|[
name|slotIndex
index|]
operator|=
name|entry
operator|.
name|hashNext
expr_stmt|;
block|}
name|entry
operator|.
name|hashNext
operator|=
literal|null
expr_stmt|;
return|return
name|entry
return|;
block|}
name|prev
operator|=
name|entry
expr_stmt|;
name|entry
operator|=
name|entry
operator|.
name|hashNext
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|Entry
name|getProcedure
parameter_list|(
name|long
name|procId
parameter_list|)
block|{
return|return
name|getProcedure
argument_list|(
name|getMapSlot
argument_list|(
name|procId
argument_list|)
argument_list|,
name|procId
argument_list|)
return|;
block|}
specifier|private
name|Entry
name|getProcedure
parameter_list|(
name|int
name|slotIndex
parameter_list|,
name|long
name|procId
parameter_list|)
block|{
name|Entry
name|entry
init|=
name|procedureMap
index|[
name|slotIndex
index|]
decl_stmt|;
while|while
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|procId
operator|==
name|entry
operator|.
name|getProcId
argument_list|()
condition|)
block|{
return|return
name|entry
return|;
block|}
name|entry
operator|=
name|entry
operator|.
name|hashNext
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|int
name|getMapSlot
parameter_list|(
name|long
name|procId
parameter_list|)
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|Procedure
operator|.
name|getProcIdHashCode
argument_list|(
name|procId
argument_list|)
operator|%
name|procedureMap
operator|.
name|length
argument_list|)
return|;
block|}
block|}
end_class

end_unit

