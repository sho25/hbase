begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|store
operator|.
name|wal
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|InvalidProtocolBufferException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|Procedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|ProcedureUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|store
operator|.
name|ProcedureStore
operator|.
name|ProcedureIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|store
operator|.
name|ProcedureStoreTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ProcedureProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ProcedureProtos
operator|.
name|ProcedureWALEntry
import|;
end_import

begin_comment
comment|/**  * Helper class that loads the procedures stored in a WAL  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
class|class
name|ProcedureWALFormatReader
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ProcedureWALFormatReader
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// ==============================================================================================
comment|//  We read the WALs in reverse order from the newest to the oldest.
comment|//  We have different entry types:
comment|//   - INIT: Procedure submitted by the user (also known as 'root procedure')
comment|//   - INSERT: Children added to the procedure<parentId>:[<childId>, ...]
comment|//   - UPDATE: The specified procedure was updated
comment|//   - DELETE: The procedure was removed (finished/rolledback and result TTL expired)
comment|//
comment|// In the WAL we can find multiple times the same procedure as UPDATE or INSERT.
comment|// We read the WAL from top to bottom, so every time we find an entry of the
comment|// same procedure, that will be the "latest" update (Caveat: with multiple threads writing
comment|// the store, this assumption does not hold).
comment|//
comment|// We keep two in-memory maps:
comment|//  - localProcedureMap: is the map containing the entries in the WAL we are processing
comment|//  - procedureMap: is the map containing all the procedures we found up to the WAL in process.
comment|// localProcedureMap is merged with the procedureMap once we reach the WAL EOF.
comment|//
comment|// Since we are reading the WALs in reverse order (newest to oldest),
comment|// if we find an entry related to a procedure we already have in 'procedureMap' we can discard it.
comment|//
comment|// The WAL is append-only so the last procedure in the WAL is the one that
comment|// was in execution at the time we crashed/closed the server.
comment|// Given that, the procedure replay order can be inferred by the WAL order.
comment|//
comment|// Example:
comment|//    WAL-2: [A, B, A, C, D]
comment|//    WAL-1: [F, G, A, F, B]
comment|//    Replay-Order: [D, C, A, B, F, G]
comment|//
comment|// The "localProcedureMap" keeps a "replayOrder" list. Every time we add the
comment|// record to the map that record is moved to the head of the "replayOrder" list.
comment|// Using the example above:
comment|//    WAL-2 localProcedureMap.replayOrder is [D, C, A, B]
comment|//    WAL-1 localProcedureMap.replayOrder is [F, G]
comment|//
comment|// Each time we reach the WAL-EOF, the "replayOrder" list is merged/appended in 'procedureMap'
comment|// so using the example above we end up with: [D, C, A, B] + [F, G] as replay order.
comment|//
comment|//  Fast Start: INIT/INSERT record and StackIDs
comment|// ---------------------------------------------
comment|// We have two special records, INIT and INSERT, that track the first time
comment|// the procedure was added to the WAL. We can use this information to be able
comment|// to start procedures before reaching the end of the WAL, or before reading all WALs.
comment|// But in some cases, the WAL with that record can be already gone.
comment|// As an alternative, we can use the stackIds on each procedure,
comment|// to identify when a procedure is ready to start.
comment|// If there are gaps in the sum of the stackIds we need to read more WALs.
comment|//
comment|// Example (all procs child of A):
comment|//   WAL-2: [A, B]                   A stackIds = [0, 4], B stackIds = [1, 5]
comment|//   WAL-1: [A, B, C, D]
comment|//
comment|// In the case above we need to read one more WAL to be able to consider
comment|// the root procedure A and all children as ready.
comment|// ==============================================================================================
specifier|private
specifier|final
name|WalProcedureMap
name|localProcedureMap
init|=
operator|new
name|WalProcedureMap
argument_list|(
literal|1024
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|WalProcedureMap
name|procedureMap
init|=
operator|new
name|WalProcedureMap
argument_list|(
literal|1024
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|ProcedureWALFormat
operator|.
name|Loader
name|loader
decl_stmt|;
comment|/**    * Global tracker that will be used by the WALProcedureStore after load.    * If the last WAL was closed cleanly we already have a full tracker ready to be used.    * If the last WAL was truncated (e.g. master killed) the tracker will be empty    * and the 'partial' flag will be set. In this case, on WAL replay we are going    * to rebuild the tracker.    */
specifier|private
specifier|final
name|ProcedureStoreTracker
name|tracker
decl_stmt|;
comment|// TODO: private final boolean hasFastStartSupport;
comment|/**    * If tracker for a log file is partial (see {@link ProcedureStoreTracker#partial}), we    * re-build the list of procedures updated in that WAL because we need it for log cleaning    * purposes. If all procedures updated in a WAL are found to be obsolete, it can be safely deleted.    * (see {@link WALProcedureStore#removeInactiveLogs()}).    * However, we don't need deleted part of a WAL's tracker for this purpose, so we don't bother    * re-building it.    */
specifier|private
name|ProcedureStoreTracker
name|localTracker
decl_stmt|;
comment|// private long compactionLogId;
specifier|private
name|long
name|maxProcId
init|=
literal|0
decl_stmt|;
specifier|public
name|ProcedureWALFormatReader
parameter_list|(
specifier|final
name|ProcedureStoreTracker
name|tracker
parameter_list|,
name|ProcedureWALFormat
operator|.
name|Loader
name|loader
parameter_list|)
block|{
name|this
operator|.
name|tracker
operator|=
name|tracker
expr_stmt|;
name|this
operator|.
name|loader
operator|=
name|loader
expr_stmt|;
comment|// we support fast-start only if we have a clean shutdown.
comment|// this.hasFastStartSupport = !tracker.isEmpty();
block|}
specifier|public
name|void
name|read
parameter_list|(
specifier|final
name|ProcedureWALFile
name|log
parameter_list|)
throws|throws
name|IOException
block|{
name|localTracker
operator|=
name|log
operator|.
name|getTracker
argument_list|()
operator|.
name|isPartial
argument_list|()
condition|?
name|log
operator|.
name|getTracker
argument_list|()
else|:
literal|null
expr_stmt|;
if|if
condition|(
name|localTracker
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Rebuilding tracker for "
operator|+
name|log
argument_list|)
expr_stmt|;
block|}
name|long
name|count
init|=
literal|0
decl_stmt|;
name|FSDataInputStream
name|stream
init|=
name|log
operator|.
name|getStream
argument_list|()
decl_stmt|;
try|try
block|{
name|boolean
name|hasMore
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|hasMore
condition|)
block|{
name|ProcedureWALEntry
name|entry
init|=
name|ProcedureWALFormat
operator|.
name|readEntry
argument_list|(
name|stream
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Nothing left to decode. Exiting with missing EOF, log="
operator|+
name|log
argument_list|)
expr_stmt|;
break|break;
block|}
name|count
operator|++
expr_stmt|;
switch|switch
condition|(
name|entry
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|PROCEDURE_WAL_INIT
case|:
name|readInitEntry
argument_list|(
name|entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROCEDURE_WAL_INSERT
case|:
name|readInsertEntry
argument_list|(
name|entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROCEDURE_WAL_UPDATE
case|:
case|case
name|PROCEDURE_WAL_COMPACT
case|:
name|readUpdateEntry
argument_list|(
name|entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROCEDURE_WAL_DELETE
case|:
name|readDeleteEntry
argument_list|(
name|entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROCEDURE_WAL_EOF
case|:
name|hasMore
operator|=
literal|false
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|CorruptedWALProcedureStoreException
argument_list|(
literal|"Invalid entry: "
operator|+
name|entry
argument_list|)
throw|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Read {} entries in {}"
argument_list|,
name|count
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidProtocolBufferException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"While reading entry #{} in {}"
argument_list|,
name|count
argument_list|,
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|loader
operator|.
name|markCorruptedWAL
argument_list|(
name|log
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|localTracker
operator|!=
literal|null
condition|)
block|{
name|localTracker
operator|.
name|setPartialFlag
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|localProcedureMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|log
operator|.
name|setProcIds
argument_list|(
name|localProcedureMap
operator|.
name|getMinProcId
argument_list|()
argument_list|,
name|localProcedureMap
operator|.
name|getMaxProcId
argument_list|()
argument_list|)
expr_stmt|;
name|procedureMap
operator|.
name|mergeTail
argument_list|(
name|localProcedureMap
argument_list|)
expr_stmt|;
comment|//if (hasFastStartSupport) {
comment|// TODO: Some procedure may be already runnables (see readInitEntry())
comment|//       (we can also check the "update map" in the log trackers)
comment|// --------------------------------------------------
comment|//EntryIterator iter = procedureMap.fetchReady();
comment|//if (iter != null) loader.load(iter);
comment|// --------------------------------------------------
comment|//}
block|}
block|}
specifier|public
name|void
name|finish
parameter_list|()
throws|throws
name|IOException
block|{
comment|// notify the loader about the max proc ID
name|loader
operator|.
name|setMaxProcId
argument_list|(
name|maxProcId
argument_list|)
expr_stmt|;
comment|// fetch the procedure ready to run.
name|ProcedureIterator
name|procIter
init|=
name|procedureMap
operator|.
name|fetchReady
argument_list|()
decl_stmt|;
if|if
condition|(
name|procIter
operator|!=
literal|null
condition|)
name|loader
operator|.
name|load
argument_list|(
name|procIter
argument_list|)
expr_stmt|;
comment|// remaining procedures have missing link or dependencies
comment|// consider them as corrupted, manual fix is probably required.
name|procIter
operator|=
name|procedureMap
operator|.
name|fetchAll
argument_list|()
expr_stmt|;
if|if
condition|(
name|procIter
operator|!=
literal|null
condition|)
name|loader
operator|.
name|handleCorrupted
argument_list|(
name|procIter
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|loadProcedure
parameter_list|(
specifier|final
name|ProcedureWALEntry
name|entry
parameter_list|,
specifier|final
name|ProcedureProtos
operator|.
name|Procedure
name|proc
parameter_list|)
block|{
name|maxProcId
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxProcId
argument_list|,
name|proc
operator|.
name|getProcId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|isRequired
argument_list|(
name|proc
operator|.
name|getProcId
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Read "
operator|+
name|entry
operator|.
name|getType
argument_list|()
operator|+
literal|" entry "
operator|+
name|proc
operator|.
name|getProcId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|localProcedureMap
operator|.
name|add
argument_list|(
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tracker
operator|.
name|isPartial
argument_list|()
condition|)
block|{
name|tracker
operator|.
name|insert
argument_list|(
name|proc
operator|.
name|getProcId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|localTracker
operator|!=
literal|null
condition|)
block|{
name|localTracker
operator|.
name|insert
argument_list|(
name|proc
operator|.
name|getProcId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|readInitEntry
parameter_list|(
specifier|final
name|ProcedureWALEntry
name|entry
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|entry
operator|.
name|getProcedureCount
argument_list|()
operator|==
literal|1
operator|:
literal|"Expected only one procedure"
assert|;
name|loadProcedure
argument_list|(
name|entry
argument_list|,
name|entry
operator|.
name|getProcedure
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|readInsertEntry
parameter_list|(
specifier|final
name|ProcedureWALEntry
name|entry
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|entry
operator|.
name|getProcedureCount
argument_list|()
operator|>=
literal|1
operator|:
literal|"Expected one or more procedures"
assert|;
name|loadProcedure
argument_list|(
name|entry
argument_list|,
name|entry
operator|.
name|getProcedure
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|entry
operator|.
name|getProcedureCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|loadProcedure
argument_list|(
name|entry
argument_list|,
name|entry
operator|.
name|getProcedure
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|readUpdateEntry
parameter_list|(
specifier|final
name|ProcedureWALEntry
name|entry
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|entry
operator|.
name|getProcedureCount
argument_list|()
operator|==
literal|1
operator|:
literal|"Expected only one procedure"
assert|;
name|loadProcedure
argument_list|(
name|entry
argument_list|,
name|entry
operator|.
name|getProcedure
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|readDeleteEntry
parameter_list|(
specifier|final
name|ProcedureWALEntry
name|entry
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|entry
operator|.
name|hasProcId
argument_list|()
operator|:
literal|"expected ProcID"
assert|;
if|if
condition|(
name|entry
operator|.
name|getChildIdCount
argument_list|()
operator|>
literal|0
condition|)
block|{
assert|assert
name|entry
operator|.
name|getProcedureCount
argument_list|()
operator|==
literal|1
operator|:
literal|"Expected only one procedure"
assert|;
comment|// update the parent procedure
name|loadProcedure
argument_list|(
name|entry
argument_list|,
name|entry
operator|.
name|getProcedure
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// remove the child procedures of entry.getProcId()
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|count
init|=
name|entry
operator|.
name|getChildIdCount
argument_list|()
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|deleteEntry
argument_list|(
name|entry
operator|.
name|getChildId
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
assert|assert
name|entry
operator|.
name|getProcedureCount
argument_list|()
operator|==
literal|0
operator|:
literal|"Expected no procedures"
assert|;
comment|// delete the procedure
name|deleteEntry
argument_list|(
name|entry
operator|.
name|getProcId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|deleteEntry
parameter_list|(
specifier|final
name|long
name|procId
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"delete entry "
operator|+
name|procId
argument_list|)
expr_stmt|;
block|}
name|maxProcId
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxProcId
argument_list|,
name|procId
argument_list|)
expr_stmt|;
name|localProcedureMap
operator|.
name|remove
argument_list|(
name|procId
argument_list|)
expr_stmt|;
assert|assert
operator|!
name|procedureMap
operator|.
name|contains
argument_list|(
name|procId
argument_list|)
assert|;
if|if
condition|(
name|tracker
operator|.
name|isPartial
argument_list|()
condition|)
block|{
name|tracker
operator|.
name|setDeleted
argument_list|(
name|procId
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|localTracker
operator|!=
literal|null
condition|)
block|{
comment|// In case there is only delete entry for this procedure in current log.
name|localTracker
operator|.
name|setDeleted
argument_list|(
name|procId
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|isDeleted
parameter_list|(
specifier|final
name|long
name|procId
parameter_list|)
block|{
return|return
name|tracker
operator|.
name|isDeleted
argument_list|(
name|procId
argument_list|)
operator|==
name|ProcedureStoreTracker
operator|.
name|DeleteState
operator|.
name|YES
return|;
block|}
specifier|private
name|boolean
name|isRequired
parameter_list|(
specifier|final
name|long
name|procId
parameter_list|)
block|{
return|return
operator|!
name|isDeleted
argument_list|(
name|procId
argument_list|)
operator|&&
operator|!
name|procedureMap
operator|.
name|contains
argument_list|(
name|procId
argument_list|)
return|;
block|}
comment|// ==========================================================================
comment|//  We keep an in-memory map of the procedures sorted by replay order.
comment|//  (see the details in the beginning of the file)
comment|//                      _______________________________________________
comment|//      procedureMap = | A |   | E |   | C |   |   |   |   | G |   |   |
comment|//                       D               B
comment|//      replayOrderHead = C<-> B<-> E<-> D<-> A<-> G
comment|//
comment|//  We also have a lazy grouping by "root procedure", and a list of
comment|//  unlinked procedures. If after reading all the WALs we have unlinked
comment|//  procedures it means that we had a missing WAL or a corruption.
comment|//      rootHead = A<-> D<-> G
comment|//                 B     E
comment|//                 C
comment|//      unlinkFromLinkList = None
comment|// ==========================================================================
specifier|private
specifier|static
class|class
name|Entry
block|{
comment|// For bucketed linked lists in hash-table.
specifier|protected
name|Entry
name|hashNext
decl_stmt|;
comment|// child head
specifier|protected
name|Entry
name|childHead
decl_stmt|;
comment|// double-link for rootHead or childHead
specifier|protected
name|Entry
name|linkNext
decl_stmt|;
specifier|protected
name|Entry
name|linkPrev
decl_stmt|;
comment|// replay double-linked-list
specifier|protected
name|Entry
name|replayNext
decl_stmt|;
specifier|protected
name|Entry
name|replayPrev
decl_stmt|;
comment|// procedure-infos
specifier|protected
name|Procedure
name|procedure
decl_stmt|;
specifier|protected
name|ProcedureProtos
operator|.
name|Procedure
name|proto
decl_stmt|;
specifier|protected
name|boolean
name|ready
init|=
literal|false
decl_stmt|;
specifier|public
name|Entry
parameter_list|(
name|Entry
name|hashNext
parameter_list|)
block|{
name|this
operator|.
name|hashNext
operator|=
name|hashNext
expr_stmt|;
block|}
specifier|public
name|long
name|getProcId
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getProcId
argument_list|()
return|;
block|}
specifier|public
name|long
name|getParentId
parameter_list|()
block|{
return|return
name|proto
operator|.
name|getParentId
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|hasParent
parameter_list|()
block|{
return|return
name|proto
operator|.
name|hasParentId
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|isReady
parameter_list|()
block|{
return|return
name|ready
return|;
block|}
specifier|public
name|boolean
name|isFinished
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasParent
argument_list|()
condition|)
block|{
comment|// we only consider 'root' procedures. because for the user 'finished'
comment|// means when everything up to the 'root' is finished.
switch|switch
condition|(
name|proto
operator|.
name|getState
argument_list|()
condition|)
block|{
case|case
name|ROLLEDBACK
case|:
case|case
name|SUCCESS
case|:
return|return
literal|true
return|;
default|default:
break|break;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|Procedure
name|convert
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|procedure
operator|==
literal|null
condition|)
block|{
name|procedure
operator|=
name|ProcedureUtil
operator|.
name|convertToProcedure
argument_list|(
name|proto
argument_list|)
expr_stmt|;
block|}
return|return
name|procedure
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"Entry("
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getProcId
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", parentId="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getParentId
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", class="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|proto
operator|.
name|getClassName
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|EntryIterator
implements|implements
name|ProcedureIterator
block|{
specifier|private
specifier|final
name|Entry
name|replayHead
decl_stmt|;
specifier|private
name|Entry
name|current
decl_stmt|;
specifier|public
name|EntryIterator
parameter_list|(
name|Entry
name|replayHead
parameter_list|)
block|{
name|this
operator|.
name|replayHead
operator|=
name|replayHead
expr_stmt|;
name|this
operator|.
name|current
operator|=
name|replayHead
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|this
operator|.
name|current
operator|=
name|replayHead
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|current
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isNextFinished
parameter_list|()
block|{
return|return
name|current
operator|!=
literal|null
operator|&&
name|current
operator|.
name|isFinished
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|skipNext
parameter_list|()
block|{
name|current
operator|=
name|current
operator|.
name|replayNext
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Procedure
name|next
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|current
operator|.
name|convert
argument_list|()
return|;
block|}
finally|finally
block|{
name|current
operator|=
name|current
operator|.
name|replayNext
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
class|class
name|WalProcedureMap
block|{
comment|// procedure hash table
specifier|private
name|Entry
index|[]
name|procedureMap
decl_stmt|;
comment|// replay-order double-linked-list
specifier|private
name|Entry
name|replayOrderHead
decl_stmt|;
specifier|private
name|Entry
name|replayOrderTail
decl_stmt|;
comment|// root linked-list
specifier|private
name|Entry
name|rootHead
decl_stmt|;
comment|// pending unlinked children (root not present yet)
specifier|private
name|Entry
name|childUnlinkedHead
decl_stmt|;
comment|// Track ProcId range
specifier|private
name|long
name|minProcId
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
specifier|private
name|long
name|maxProcId
init|=
name|Long
operator|.
name|MIN_VALUE
decl_stmt|;
specifier|public
name|WalProcedureMap
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|procedureMap
operator|=
operator|new
name|Entry
index|[
name|size
index|]
expr_stmt|;
name|replayOrderHead
operator|=
literal|null
expr_stmt|;
name|replayOrderTail
operator|=
literal|null
expr_stmt|;
name|rootHead
operator|=
literal|null
expr_stmt|;
name|childUnlinkedHead
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
name|void
name|add
parameter_list|(
name|ProcedureProtos
operator|.
name|Procedure
name|procProto
parameter_list|)
block|{
name|trackProcIds
argument_list|(
name|procProto
operator|.
name|getProcId
argument_list|()
argument_list|)
expr_stmt|;
name|Entry
name|entry
init|=
name|addToMap
argument_list|(
name|procProto
operator|.
name|getProcId
argument_list|()
argument_list|,
name|procProto
operator|.
name|hasParentId
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|newEntry
init|=
name|entry
operator|.
name|proto
operator|==
literal|null
decl_stmt|;
comment|// We have seen procedure WALs where the entries are out of order; see HBASE-18152.
comment|// To compensate, only replace the Entry procedure if for sure this new procedure
comment|// is indeed an entry that came later. TODO: Fix the writing of procedure info so
comment|// it does not violate basic expectation, that WALs contain procedure changes going
comment|// from start to finish in sequence.
if|if
condition|(
name|newEntry
operator|||
name|isIncreasing
argument_list|(
name|entry
operator|.
name|proto
argument_list|,
name|procProto
argument_list|)
condition|)
block|{
name|entry
operator|.
name|proto
operator|=
name|procProto
expr_stmt|;
block|}
name|addToReplayList
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|newEntry
condition|)
block|{
if|if
condition|(
name|procProto
operator|.
name|hasParentId
argument_list|()
condition|)
block|{
name|childUnlinkedHead
operator|=
name|addToLinkList
argument_list|(
name|entry
argument_list|,
name|childUnlinkedHead
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rootHead
operator|=
name|addToLinkList
argument_list|(
name|entry
argument_list|,
name|rootHead
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * @return True if this new procedure is 'richer' than the current one else      * false and we log this incidence where it appears that the WAL has older entries      * appended after newer ones. See HBASE-18152.      */
specifier|private
specifier|static
name|boolean
name|isIncreasing
parameter_list|(
name|ProcedureProtos
operator|.
name|Procedure
name|current
parameter_list|,
name|ProcedureProtos
operator|.
name|Procedure
name|candidate
parameter_list|)
block|{
comment|// Check that the procedures we see are 'increasing'. We used to compare
comment|// procedure id first and then update time but it can legitimately go backwards if the
comment|// procedure is failed or rolled back so that was unreliable. Was going to compare
comment|// state but lets see if comparing update time enough (unfortunately this issue only
comment|// seen under load...)
name|boolean
name|increasing
init|=
name|current
operator|.
name|getLastUpdate
argument_list|()
operator|<=
name|candidate
operator|.
name|getLastUpdate
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|increasing
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"NOT INCREASING! current="
operator|+
name|current
operator|+
literal|", candidate="
operator|+
name|candidate
argument_list|)
expr_stmt|;
block|}
return|return
name|increasing
return|;
block|}
specifier|public
name|boolean
name|remove
parameter_list|(
name|long
name|procId
parameter_list|)
block|{
name|trackProcIds
argument_list|(
name|procId
argument_list|)
expr_stmt|;
name|Entry
name|entry
init|=
name|removeFromMap
argument_list|(
name|procId
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
name|unlinkFromReplayList
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|unlinkFromLinkList
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|void
name|trackProcIds
parameter_list|(
name|long
name|procId
parameter_list|)
block|{
name|minProcId
operator|=
name|Math
operator|.
name|min
argument_list|(
name|minProcId
argument_list|,
name|procId
argument_list|)
expr_stmt|;
name|maxProcId
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxProcId
argument_list|,
name|procId
argument_list|)
expr_stmt|;
block|}
specifier|public
name|long
name|getMinProcId
parameter_list|()
block|{
return|return
name|minProcId
return|;
block|}
specifier|public
name|long
name|getMaxProcId
parameter_list|()
block|{
return|return
name|maxProcId
return|;
block|}
specifier|public
name|boolean
name|contains
parameter_list|(
name|long
name|procId
parameter_list|)
block|{
return|return
name|getProcedure
argument_list|(
name|procId
argument_list|)
operator|!=
literal|null
return|;
block|}
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|replayOrderHead
operator|==
literal|null
return|;
block|}
specifier|public
name|void
name|clear
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|procedureMap
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|procedureMap
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
name|replayOrderHead
operator|=
literal|null
expr_stmt|;
name|replayOrderTail
operator|=
literal|null
expr_stmt|;
name|rootHead
operator|=
literal|null
expr_stmt|;
name|childUnlinkedHead
operator|=
literal|null
expr_stmt|;
name|minProcId
operator|=
name|Long
operator|.
name|MAX_VALUE
expr_stmt|;
name|maxProcId
operator|=
name|Long
operator|.
name|MIN_VALUE
expr_stmt|;
block|}
comment|/*      * Merges two WalProcedureMap,      * the target is the "global" map, the source is the "local" map.      *  - The entries in the hashtables are guaranteed to be unique.      *    On replay we don't load procedures that already exist in the "global"      *    map (the one we are merging the "local" in to).      *  - The replayOrderList of the "local" nao will be appended to the "global"      *    map replay list.      *  - The "local" map will be cleared at the end of the operation.      */
specifier|public
name|void
name|mergeTail
parameter_list|(
name|WalProcedureMap
name|other
parameter_list|)
block|{
for|for
control|(
name|Entry
name|p
init|=
name|other
operator|.
name|replayOrderHead
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|p
operator|.
name|replayNext
control|)
block|{
name|int
name|slotIndex
init|=
name|getMapSlot
argument_list|(
name|p
operator|.
name|getProcId
argument_list|()
argument_list|)
decl_stmt|;
name|p
operator|.
name|hashNext
operator|=
name|procedureMap
index|[
name|slotIndex
index|]
expr_stmt|;
name|procedureMap
index|[
name|slotIndex
index|]
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|replayOrderHead
operator|==
literal|null
condition|)
block|{
name|replayOrderHead
operator|=
name|other
operator|.
name|replayOrderHead
expr_stmt|;
name|replayOrderTail
operator|=
name|other
operator|.
name|replayOrderTail
expr_stmt|;
name|rootHead
operator|=
name|other
operator|.
name|rootHead
expr_stmt|;
name|childUnlinkedHead
operator|=
name|other
operator|.
name|childUnlinkedHead
expr_stmt|;
block|}
else|else
block|{
comment|// append replay list
assert|assert
name|replayOrderTail
operator|.
name|replayNext
operator|==
literal|null
assert|;
assert|assert
name|other
operator|.
name|replayOrderHead
operator|.
name|replayPrev
operator|==
literal|null
assert|;
name|replayOrderTail
operator|.
name|replayNext
operator|=
name|other
operator|.
name|replayOrderHead
expr_stmt|;
name|other
operator|.
name|replayOrderHead
operator|.
name|replayPrev
operator|=
name|replayOrderTail
expr_stmt|;
name|replayOrderTail
operator|=
name|other
operator|.
name|replayOrderTail
expr_stmt|;
comment|// merge rootHead
if|if
condition|(
name|rootHead
operator|==
literal|null
condition|)
block|{
name|rootHead
operator|=
name|other
operator|.
name|rootHead
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|other
operator|.
name|rootHead
operator|!=
literal|null
condition|)
block|{
name|Entry
name|otherTail
init|=
name|findLinkListTail
argument_list|(
name|other
operator|.
name|rootHead
argument_list|)
decl_stmt|;
name|otherTail
operator|.
name|linkNext
operator|=
name|rootHead
expr_stmt|;
name|rootHead
operator|.
name|linkPrev
operator|=
name|otherTail
expr_stmt|;
name|rootHead
operator|=
name|other
operator|.
name|rootHead
expr_stmt|;
block|}
comment|// merge childUnlinkedHead
if|if
condition|(
name|childUnlinkedHead
operator|==
literal|null
condition|)
block|{
name|childUnlinkedHead
operator|=
name|other
operator|.
name|childUnlinkedHead
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|other
operator|.
name|childUnlinkedHead
operator|!=
literal|null
condition|)
block|{
name|Entry
name|otherTail
init|=
name|findLinkListTail
argument_list|(
name|other
operator|.
name|childUnlinkedHead
argument_list|)
decl_stmt|;
name|otherTail
operator|.
name|linkNext
operator|=
name|childUnlinkedHead
expr_stmt|;
name|childUnlinkedHead
operator|.
name|linkPrev
operator|=
name|otherTail
expr_stmt|;
name|childUnlinkedHead
operator|=
name|other
operator|.
name|childUnlinkedHead
expr_stmt|;
block|}
block|}
name|maxProcId
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxProcId
argument_list|,
name|other
operator|.
name|maxProcId
argument_list|)
expr_stmt|;
name|minProcId
operator|=
name|Math
operator|.
name|max
argument_list|(
name|minProcId
argument_list|,
name|other
operator|.
name|minProcId
argument_list|)
expr_stmt|;
name|other
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/*      * Returns an EntryIterator with the list of procedures ready      * to be added to the executor.      * A Procedure is ready if its children and parent are ready.      */
specifier|public
name|EntryIterator
name|fetchReady
parameter_list|()
block|{
name|buildGraph
argument_list|()
expr_stmt|;
name|Entry
name|readyHead
init|=
literal|null
decl_stmt|;
name|Entry
name|readyTail
init|=
literal|null
decl_stmt|;
name|Entry
name|p
init|=
name|replayOrderHead
decl_stmt|;
while|while
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|Entry
name|next
init|=
name|p
operator|.
name|replayNext
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|isReady
argument_list|()
condition|)
block|{
name|unlinkFromReplayList
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|readyTail
operator|!=
literal|null
condition|)
block|{
name|readyTail
operator|.
name|replayNext
operator|=
name|p
expr_stmt|;
name|p
operator|.
name|replayPrev
operator|=
name|readyTail
expr_stmt|;
block|}
else|else
block|{
name|p
operator|.
name|replayPrev
operator|=
literal|null
expr_stmt|;
name|readyHead
operator|=
name|p
expr_stmt|;
block|}
name|readyTail
operator|=
name|p
expr_stmt|;
name|p
operator|.
name|replayNext
operator|=
literal|null
expr_stmt|;
block|}
name|p
operator|=
name|next
expr_stmt|;
block|}
comment|// we need the hash-table lookups for parents, so this must be done
comment|// out of the loop where we check isReadyToRun()
for|for
control|(
name|p
operator|=
name|readyHead
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|p
operator|.
name|replayNext
control|)
block|{
name|removeFromMap
argument_list|(
name|p
operator|.
name|getProcId
argument_list|()
argument_list|)
expr_stmt|;
name|unlinkFromLinkList
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|readyHead
operator|!=
literal|null
condition|?
operator|new
name|EntryIterator
argument_list|(
name|readyHead
argument_list|)
else|:
literal|null
return|;
block|}
comment|/*      * Drain this map and return all procedures in it.      */
specifier|public
name|EntryIterator
name|fetchAll
parameter_list|()
block|{
name|Entry
name|head
init|=
name|replayOrderHead
decl_stmt|;
for|for
control|(
name|Entry
name|p
init|=
name|head
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|p
operator|.
name|replayNext
control|)
block|{
name|removeFromMap
argument_list|(
name|p
operator|.
name|getProcId
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|procedureMap
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
assert|assert
name|procedureMap
index|[
name|i
index|]
operator|==
literal|null
operator|:
literal|"map not empty i="
operator|+
name|i
assert|;
block|}
name|replayOrderHead
operator|=
literal|null
expr_stmt|;
name|replayOrderTail
operator|=
literal|null
expr_stmt|;
name|childUnlinkedHead
operator|=
literal|null
expr_stmt|;
name|rootHead
operator|=
literal|null
expr_stmt|;
return|return
name|head
operator|!=
literal|null
condition|?
operator|new
name|EntryIterator
argument_list|(
name|head
argument_list|)
else|:
literal|null
return|;
block|}
specifier|private
name|void
name|buildGraph
parameter_list|()
block|{
name|Entry
name|p
init|=
name|childUnlinkedHead
decl_stmt|;
while|while
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|Entry
name|next
init|=
name|p
operator|.
name|linkNext
decl_stmt|;
name|Entry
name|rootProc
init|=
name|getRootProcedure
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|rootProc
operator|!=
literal|null
condition|)
block|{
name|rootProc
operator|.
name|childHead
operator|=
name|addToLinkList
argument_list|(
name|p
argument_list|,
name|rootProc
operator|.
name|childHead
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|next
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|rootHead
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|p
operator|.
name|linkNext
control|)
block|{
name|checkReadyToRun
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|Entry
name|getRootProcedure
parameter_list|(
name|Entry
name|entry
parameter_list|)
block|{
while|while
condition|(
name|entry
operator|!=
literal|null
operator|&&
name|entry
operator|.
name|hasParent
argument_list|()
condition|)
block|{
name|entry
operator|=
name|getProcedure
argument_list|(
name|entry
operator|.
name|getParentId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
comment|/*      * (see the comprehensive explanation in the beginning of the file)      * A Procedure is ready when parent and children are ready.      * "ready" means that we all the information that we need in-memory.      *      * Example-1:      * We have two WALs, we start reading from the newest (wal-2)      *    wal-2 | C B |      *    wal-1 | A B C |      *      * If C and B don't depend on A (A is not the parent), we can start them      * before reading wal-1. If B is the only one with parent A we can start C.      * We have to read one more WAL before being able to start B.      *      * How do we know with the only information in B that we are not ready.      *  - easy case, the parent is missing from the global map      *  - more complex case we look at the Stack IDs.      *      * The Stack-IDs are added to the procedure order as an incremental index      * tracking how many times that procedure was executed, which is equivalent      * to the number of times we wrote the procedure to the WAL.      * In the example above:      *   wal-2: B has stackId = [1, 2]      *   wal-1: B has stackId = [1]      *   wal-1: A has stackId = [0]      *      * Since we know that the Stack-IDs are incremental for a Procedure,      * we notice that there is a gap in the stackIds of B, so something was      * executed before.      * To identify when a Procedure is ready we do the sum of the stackIds of      * the procedure and the parent. if the stackIdSum is equal to the      * sum of {1..maxStackId} then everything we need is available.      *      * Example-2      *    wal-2 | A |              A stackIds = [0, 2]      *    wal-1 | A B |            B stackIds = [1]      *      * There is a gap between A stackIds so something was executed in between.      */
specifier|private
name|boolean
name|checkReadyToRun
parameter_list|(
name|Entry
name|rootEntry
parameter_list|)
block|{
assert|assert
operator|!
name|rootEntry
operator|.
name|hasParent
argument_list|()
operator|:
literal|"expected root procedure, got "
operator|+
name|rootEntry
assert|;
if|if
condition|(
name|rootEntry
operator|.
name|isFinished
argument_list|()
condition|)
block|{
comment|// If the root procedure is finished, sub-procedures should be gone
if|if
condition|(
name|rootEntry
operator|.
name|childHead
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"unexpected active children for root-procedure: "
operator|+
name|rootEntry
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
name|p
init|=
name|rootEntry
operator|.
name|childHead
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|p
operator|.
name|linkNext
control|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"unexpected active children: "
operator|+
name|p
argument_list|)
expr_stmt|;
block|}
block|}
assert|assert
name|rootEntry
operator|.
name|childHead
operator|==
literal|null
operator|:
literal|"unexpected children on root completion. "
operator|+
name|rootEntry
assert|;
name|rootEntry
operator|.
name|ready
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
name|int
name|stackIdSum
init|=
literal|0
decl_stmt|;
name|int
name|maxStackId
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rootEntry
operator|.
name|proto
operator|.
name|getStackIdCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|int
name|stackId
init|=
literal|1
operator|+
name|rootEntry
operator|.
name|proto
operator|.
name|getStackId
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|maxStackId
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxStackId
argument_list|,
name|stackId
argument_list|)
expr_stmt|;
name|stackIdSum
operator|+=
name|stackId
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"stackId="
operator|+
name|stackId
operator|+
literal|" stackIdSum="
operator|+
name|stackIdSum
operator|+
literal|" maxStackid="
operator|+
name|maxStackId
operator|+
literal|" "
operator|+
name|rootEntry
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Entry
name|p
init|=
name|rootEntry
operator|.
name|childHead
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|p
operator|.
name|linkNext
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|p
operator|.
name|proto
operator|.
name|getStackIdCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|int
name|stackId
init|=
literal|1
operator|+
name|p
operator|.
name|proto
operator|.
name|getStackId
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|maxStackId
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxStackId
argument_list|,
name|stackId
argument_list|)
expr_stmt|;
name|stackIdSum
operator|+=
name|stackId
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"stackId="
operator|+
name|stackId
operator|+
literal|" stackIdSum="
operator|+
name|stackIdSum
operator|+
literal|" maxStackid="
operator|+
name|maxStackId
operator|+
literal|" "
operator|+
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// The cmpStackIdSum is this formula for finding the sum of a series of numbers:
comment|// http://www.wikihow.com/Sum-the-Integers-from-1-to-N#/Image:Sum-the-Integers-from-1-to-N-Step-2-Version-3.jpg
specifier|final
name|int
name|cmpStackIdSum
init|=
operator|(
name|maxStackId
operator|*
operator|(
name|maxStackId
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
decl_stmt|;
if|if
condition|(
name|cmpStackIdSum
operator|==
name|stackIdSum
condition|)
block|{
name|rootEntry
operator|.
name|ready
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|Entry
name|p
init|=
name|rootEntry
operator|.
name|childHead
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|p
operator|.
name|linkNext
control|)
block|{
name|p
operator|.
name|ready
operator|=
literal|true
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|void
name|unlinkFromReplayList
parameter_list|(
name|Entry
name|entry
parameter_list|)
block|{
if|if
condition|(
name|replayOrderHead
operator|==
name|entry
condition|)
block|{
name|replayOrderHead
operator|=
name|entry
operator|.
name|replayNext
expr_stmt|;
block|}
if|if
condition|(
name|replayOrderTail
operator|==
name|entry
condition|)
block|{
name|replayOrderTail
operator|=
name|entry
operator|.
name|replayPrev
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|.
name|replayPrev
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|replayPrev
operator|.
name|replayNext
operator|=
name|entry
operator|.
name|replayNext
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|.
name|replayNext
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|replayNext
operator|.
name|replayPrev
operator|=
name|entry
operator|.
name|replayPrev
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|addToReplayList
parameter_list|(
specifier|final
name|Entry
name|entry
parameter_list|)
block|{
name|unlinkFromReplayList
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|.
name|replayNext
operator|=
name|replayOrderHead
expr_stmt|;
name|entry
operator|.
name|replayPrev
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|replayOrderHead
operator|!=
literal|null
condition|)
block|{
name|replayOrderHead
operator|.
name|replayPrev
operator|=
name|entry
expr_stmt|;
block|}
else|else
block|{
name|replayOrderTail
operator|=
name|entry
expr_stmt|;
block|}
name|replayOrderHead
operator|=
name|entry
expr_stmt|;
block|}
specifier|private
name|void
name|unlinkFromLinkList
parameter_list|(
name|Entry
name|entry
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|==
name|rootHead
condition|)
block|{
name|rootHead
operator|=
name|entry
operator|.
name|linkNext
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|==
name|childUnlinkedHead
condition|)
block|{
name|childUnlinkedHead
operator|=
name|entry
operator|.
name|linkNext
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|.
name|linkPrev
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|linkPrev
operator|.
name|linkNext
operator|=
name|entry
operator|.
name|linkNext
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|.
name|linkNext
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|linkNext
operator|.
name|linkPrev
operator|=
name|entry
operator|.
name|linkPrev
expr_stmt|;
block|}
block|}
specifier|private
name|Entry
name|addToLinkList
parameter_list|(
name|Entry
name|entry
parameter_list|,
name|Entry
name|linkHead
parameter_list|)
block|{
name|unlinkFromLinkList
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|.
name|linkNext
operator|=
name|linkHead
expr_stmt|;
name|entry
operator|.
name|linkPrev
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|linkHead
operator|!=
literal|null
condition|)
block|{
name|linkHead
operator|.
name|linkPrev
operator|=
name|entry
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
specifier|private
name|Entry
name|findLinkListTail
parameter_list|(
name|Entry
name|linkHead
parameter_list|)
block|{
name|Entry
name|tail
init|=
name|linkHead
decl_stmt|;
while|while
condition|(
name|tail
operator|.
name|linkNext
operator|!=
literal|null
condition|)
block|{
name|tail
operator|=
name|tail
operator|.
name|linkNext
expr_stmt|;
block|}
return|return
name|tail
return|;
block|}
specifier|private
name|Entry
name|addToMap
parameter_list|(
specifier|final
name|long
name|procId
parameter_list|,
specifier|final
name|boolean
name|hasParent
parameter_list|)
block|{
name|int
name|slotIndex
init|=
name|getMapSlot
argument_list|(
name|procId
argument_list|)
decl_stmt|;
name|Entry
name|entry
init|=
name|getProcedure
argument_list|(
name|slotIndex
argument_list|,
name|procId
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
return|return
name|entry
return|;
name|entry
operator|=
operator|new
name|Entry
argument_list|(
name|procedureMap
index|[
name|slotIndex
index|]
argument_list|)
expr_stmt|;
name|procedureMap
index|[
name|slotIndex
index|]
operator|=
name|entry
expr_stmt|;
return|return
name|entry
return|;
block|}
specifier|private
name|Entry
name|removeFromMap
parameter_list|(
specifier|final
name|long
name|procId
parameter_list|)
block|{
name|int
name|slotIndex
init|=
name|getMapSlot
argument_list|(
name|procId
argument_list|)
decl_stmt|;
name|Entry
name|prev
init|=
literal|null
decl_stmt|;
name|Entry
name|entry
init|=
name|procedureMap
index|[
name|slotIndex
index|]
decl_stmt|;
while|while
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|procId
operator|==
name|entry
operator|.
name|getProcId
argument_list|()
condition|)
block|{
if|if
condition|(
name|prev
operator|!=
literal|null
condition|)
block|{
name|prev
operator|.
name|hashNext
operator|=
name|entry
operator|.
name|hashNext
expr_stmt|;
block|}
else|else
block|{
name|procedureMap
index|[
name|slotIndex
index|]
operator|=
name|entry
operator|.
name|hashNext
expr_stmt|;
block|}
name|entry
operator|.
name|hashNext
operator|=
literal|null
expr_stmt|;
return|return
name|entry
return|;
block|}
name|prev
operator|=
name|entry
expr_stmt|;
name|entry
operator|=
name|entry
operator|.
name|hashNext
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|Entry
name|getProcedure
parameter_list|(
specifier|final
name|long
name|procId
parameter_list|)
block|{
return|return
name|getProcedure
argument_list|(
name|getMapSlot
argument_list|(
name|procId
argument_list|)
argument_list|,
name|procId
argument_list|)
return|;
block|}
specifier|private
name|Entry
name|getProcedure
parameter_list|(
specifier|final
name|int
name|slotIndex
parameter_list|,
specifier|final
name|long
name|procId
parameter_list|)
block|{
name|Entry
name|entry
init|=
name|procedureMap
index|[
name|slotIndex
index|]
decl_stmt|;
while|while
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|procId
operator|==
name|entry
operator|.
name|getProcId
argument_list|()
condition|)
block|{
return|return
name|entry
return|;
block|}
name|entry
operator|=
name|entry
operator|.
name|hashNext
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|int
name|getMapSlot
parameter_list|(
specifier|final
name|long
name|procId
parameter_list|)
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|Procedure
operator|.
name|getProcIdHashCode
argument_list|(
name|procId
argument_list|)
operator|%
name|procedureMap
operator|.
name|length
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

