begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|TimeoutIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|metrics
operator|.
name|Counter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|metrics
operator|.
name|Histogram
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|store
operator|.
name|ProcedureStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|User
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|NonceKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ProcedureProtos
operator|.
name|ProcedureState
import|;
end_import

begin_comment
comment|/**  * Base Procedure class responsible for Procedure Metadata; e.g. state, submittedTime, lastUpdate,  * stack-indexes, etc.  *<p/>  * Procedures are run by a {@link ProcedureExecutor} instance. They are submitted and then the  * ProcedureExecutor keeps calling {@link #execute(Object)} until the Procedure is done. Execute may  * be called multiple times in the case of failure or a restart, so code must be idempotent. The  * return from an execute call is either: null to indicate we are done; ourself if there is more to  * do; or, a set of sub-procedures that need to be run to completion before the framework resumes  * our execution.  *<p/>  * The ProcedureExecutor keeps its notion of Procedure State in the Procedure itself; e.g. it stamps  * the Procedure as INITIALIZING, RUNNABLE, SUCCESS, etc. Here are some of the States defined in the  * ProcedureState enum from protos:  *<ul>  *<li>{@link #isFailed()} A procedure has executed at least once and has failed. The procedure may  * or may not have rolled back yet. Any procedure in FAILED state will be eventually moved to  * ROLLEDBACK state.</li>  *<li>{@link #isSuccess()} A procedure is completed successfully without exception.</li>  *<li>{@link #isFinished()} As a procedure in FAILED state will be tried forever for rollback, only  * condition when scheduler/ executor will drop procedure from further processing is when procedure  * state is ROLLEDBACK or isSuccess() returns true. This is a terminal state of the procedure.</li>  *<li>{@link #isWaiting()} - Procedure is in one of the two waiting states  * ({@link ProcedureState#WAITING}, {@link ProcedureState#WAITING_TIMEOUT}).</li>  *</ul>  * NOTE: These states are of the ProcedureExecutor. Procedure implementations in turn can keep their  * own state. This can lead to confusion. Try to keep the two distinct.  *<p/>  * rollback() is called when the procedure or one of the sub-procedures has failed. The rollback  * step is supposed to cleanup the resources created during the execute() step. In case of failure  * and restart, rollback() may be called multiple times, so again the code must be idempotent.  *<p/>  * Procedure can be made respect a locking regime. It has acquire/release methods as well as an  * {@link #hasLock()}. The lock implementation is up to the implementor. If an entity needs to be  * locked for the life of a procedure -- not just the calls to execute -- then implementations  * should say so with the {@link #holdLock(Object)} method.  *<p/>  * And since we need to restore the lock when restarting to keep the logic correct(HBASE-20846), the  * implementation is a bit tricky so we add some comments hrre about it.  *<ul>  *<li>Make {@link #hasLock()} method final, and add a {@link #locked} field in Procedure to record  * whether we have the lock. We will set it to {@code true} in  * {@link #doAcquireLock(Object, ProcedureStore)} and to {@code false} in  * {@link #doReleaseLock(Object, ProcedureStore)}. The sub classes do not need to manage it any  * more.</li>  *<li>Also added a locked field in the proto message. When storing, the field will be set according  * to the return value of {@link #hasLock()}. And when loading, there is a new field in Procedure  * called {@link #lockedWhenLoading}. We will set it to {@code true} if the locked field in proto  * message is {@code true}.</li>  *<li>The reason why we can not set the {@link #locked} field directly to {@code true} by calling  * {@link #doAcquireLock(Object, ProcedureStore)} is that, during initialization, most procedures  * need to wait until master is initialized. So the solution here is that, we introduced a new  * method called {@link #waitInitialized(Object)} in Procedure, and move the wait master initialized  * related code from {@link #acquireLock(Object)} to this method. And we added a restoreLock method  * to Procedure, if {@link #lockedWhenLoading} is {@code true}, we will call the  * {@link #acquireLock(Object)} to get the lock, but do not set {@link #locked} to true. And later  * when we call {@link #doAcquireLock(Object, ProcedureStore)} and pass the  * {@link #waitInitialized(Object)} check, we will test {@link #lockedWhenLoading}, if it is  * {@code true}, when we just set the {@link #locked} field to true and return, without actually  * calling the {@link #acquireLock(Object)} method since we have already called it once.</li>  *</ul>  *<p/>  * Procedures can be suspended or put in wait state with a callback that gets executed on  * Procedure-specified timeout. See {@link #setTimeout(int)}}, and  * {@link #setTimeoutFailure(Object)}. See TestProcedureEvents and the TestTimeoutEventProcedure  * class for an example usage.  *</p>  *<p/>  * There are hooks for collecting metrics on submit of the procedure and on finish. See  * {@link #updateMetricsOnSubmit(Object)} and {@link #updateMetricsOnFinish(Object, long, boolean)}.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|abstract
class|class
name|Procedure
parameter_list|<
name|TEnvironment
parameter_list|>
implements|implements
name|Comparable
argument_list|<
name|Procedure
argument_list|<
name|TEnvironment
argument_list|>
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|Procedure
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|long
name|NO_PROC_ID
init|=
operator|-
literal|1
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|int
name|NO_TIMEOUT
init|=
operator|-
literal|1
decl_stmt|;
specifier|public
enum|enum
name|LockState
block|{
name|LOCK_ACQUIRED
block|,
comment|// Lock acquired and ready to execute
name|LOCK_YIELD_WAIT
block|,
comment|// Lock not acquired, framework needs to yield
name|LOCK_EVENT_WAIT
block|,
comment|// Lock not acquired, an event will yield the procedure
block|}
comment|// Unchanged after initialization
specifier|private
name|NonceKey
name|nonceKey
init|=
literal|null
decl_stmt|;
specifier|private
name|String
name|owner
init|=
literal|null
decl_stmt|;
specifier|private
name|long
name|parentProcId
init|=
name|NO_PROC_ID
decl_stmt|;
specifier|private
name|long
name|rootProcId
init|=
name|NO_PROC_ID
decl_stmt|;
specifier|private
name|long
name|procId
init|=
name|NO_PROC_ID
decl_stmt|;
specifier|private
name|long
name|submittedTime
decl_stmt|;
comment|// Runtime state, updated every operation
specifier|private
name|ProcedureState
name|state
init|=
name|ProcedureState
operator|.
name|INITIALIZING
decl_stmt|;
specifier|private
name|RemoteProcedureException
name|exception
init|=
literal|null
decl_stmt|;
specifier|private
name|int
index|[]
name|stackIndexes
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|childrenLatch
init|=
literal|0
decl_stmt|;
specifier|private
specifier|volatile
name|int
name|timeout
init|=
name|NO_TIMEOUT
decl_stmt|;
specifier|private
specifier|volatile
name|long
name|lastUpdate
decl_stmt|;
specifier|private
specifier|volatile
name|byte
index|[]
name|result
init|=
literal|null
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|locked
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|lockedWhenLoading
init|=
literal|false
decl_stmt|;
comment|/**    * Used for override complete of the procedure without actually doing any logic in the procedure.    * If bypass is set to true, when executing it will return null when    * {@link #doExecute(Object)} is called to finish the procedure and release any locks    * it may currently hold. The bypass does cleanup around the Procedure as far as the    * Procedure framework is concerned. It does not clean any internal state that the    * Procedure's themselves may have set. That is for the Procedures to do themselves    * when bypass is called. They should override bypass and do their cleanup in the    * overridden bypass method (be sure to call the parent bypass to ensure proper    * processing).    *<p></p>Bypassing a procedure is not like aborting. Aborting a procedure will trigger    * a rollback. And since the {@link #abort(Object)} method is overrideable    * Some procedures may have chosen to ignore the aborting.    */
specifier|private
specifier|volatile
name|boolean
name|bypass
init|=
literal|false
decl_stmt|;
comment|/**    * Indicate whether we need to persist the procedure to ProcedureStore after execution. Default to    * true, and the implementation can all {@link #skipPersistence()} to let the framework skip the    * persistence of the procedure.    *<p/>    * This is useful when the procedure is in error and you want to retry later. The retry interval    * and the number of retries are usually not critical so skip the persistence can save some    * resources, and also speed up the restart processing.    *<p/>    * Notice that this value will be reset to true every time before execution. And when rolling back    * we do not test this value.    */
specifier|private
name|boolean
name|persist
init|=
literal|true
decl_stmt|;
specifier|public
name|boolean
name|isBypass
parameter_list|()
block|{
return|return
name|bypass
return|;
block|}
comment|/**    * Set the bypass to true.    * Only called in {@link ProcedureExecutor#bypassProcedure(long, long, boolean, boolean)} for now.    * DO NOT use this method alone, since we can't just bypass one single procedure. We need to    * bypass its ancestor too. If your Procedure has set state, it needs to undo it in here.    * @param env Current environment. May be null because of context; e.g. pretty-printing    *            procedure WALs where there is no 'environment' (and where Procedures that require    *            an 'environment' won't be run.    */
specifier|protected
name|void
name|bypass
parameter_list|(
name|TEnvironment
name|env
parameter_list|)
block|{
name|this
operator|.
name|bypass
operator|=
literal|true
expr_stmt|;
block|}
name|boolean
name|needPersistence
parameter_list|()
block|{
return|return
name|persist
return|;
block|}
name|void
name|resetPersistence
parameter_list|()
block|{
name|persist
operator|=
literal|true
expr_stmt|;
block|}
specifier|protected
specifier|final
name|void
name|skipPersistence
parameter_list|()
block|{
name|persist
operator|=
literal|false
expr_stmt|;
block|}
comment|/**    * The main code of the procedure. It must be idempotent since execute()    * may be called multiple times in case of machine failure in the middle    * of the execution.    * @param env the environment passed to the ProcedureExecutor    * @return a set of sub-procedures to run or ourselves if there is more work to do or null if the    * procedure is done.    * @throws ProcedureYieldException the procedure will be added back to the queue and retried later.    * @throws InterruptedException the procedure will be added back to the queue and retried later.    * @throws ProcedureSuspendedException Signal to the executor that Procedure has suspended itself and    * has set itself up waiting for an external event to wake it back up again.    */
specifier|protected
specifier|abstract
name|Procedure
argument_list|<
name|TEnvironment
argument_list|>
index|[]
name|execute
parameter_list|(
name|TEnvironment
name|env
parameter_list|)
throws|throws
name|ProcedureYieldException
throws|,
name|ProcedureSuspendedException
throws|,
name|InterruptedException
function_decl|;
comment|/**    * The code to undo what was done by the execute() code.    * It is called when the procedure or one of the sub-procedures failed or an    * abort was requested. It should cleanup all the resources created by    * the execute() call. The implementation must be idempotent since rollback()    * may be called multiple time in case of machine failure in the middle    * of the execution.    * @param env the environment passed to the ProcedureExecutor    * @throws IOException temporary failure, the rollback will retry later    * @throws InterruptedException the procedure will be added back to the queue and retried later    */
specifier|protected
specifier|abstract
name|void
name|rollback
parameter_list|(
name|TEnvironment
name|env
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
function_decl|;
comment|/**    * The abort() call is asynchronous and each procedure must decide how to deal    * with it, if they want to be abortable. The simplest implementation    * is to have an AtomicBoolean set in the abort() method and then the execute()    * will check if the abort flag is set or not.    * abort() may be called multiple times from the client, so the implementation    * must be idempotent.    *    *<p>NOTE: abort() is not like Thread.interrupt(). It is just a notification    * that allows the procedure implementor abort.    */
specifier|protected
specifier|abstract
name|boolean
name|abort
parameter_list|(
name|TEnvironment
name|env
parameter_list|)
function_decl|;
comment|/**    * The user-level code of the procedure may have some state to    * persist (e.g. input arguments or current position in the processing state) to    * be able to resume on failure.    * @param serializer stores the serializable state    */
specifier|protected
specifier|abstract
name|void
name|serializeStateData
parameter_list|(
name|ProcedureStateSerializer
name|serializer
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Called on store load to allow the user to decode the previously serialized    * state.    * @param serializer contains the serialized state    */
specifier|protected
specifier|abstract
name|void
name|deserializeStateData
parameter_list|(
name|ProcedureStateSerializer
name|serializer
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * The {@link #doAcquireLock(Object, ProcedureStore)} will be split into two steps, first, it will    * call us to determine whether we need to wait for initialization, second, it will call    * {@link #acquireLock(Object)} to actually handle the lock for this procedure.    *<p/>    * This is because that when master restarts, we need to restore the lock state for all the    * procedures to not break the semantic if {@link #holdLock(Object)} is true. But the    * {@link ProcedureExecutor} will be started before the master finish initialization(as it is part    * of the initialization!), so we need to split the code into two steps, and when restore, we just    * restore the lock part and ignore the waitInitialized part. Otherwise there will be dead lock.    * @return true means we need to wait until the environment has been initialized, otherwise true.    */
specifier|protected
name|boolean
name|waitInitialized
parameter_list|(
name|TEnvironment
name|env
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
comment|/**    * The user should override this method if they need a lock on an Entity. A lock can be anything,    * and it is up to the implementor. The Procedure Framework will call this method just before it    * invokes {@link #execute(Object)}. It calls {@link #releaseLock(Object)} after the call to    * execute.    *<p/>    * If you need to hold the lock for the life of the Procedure -- i.e. you do not want any other    * Procedure interfering while this Procedure is running, see {@link #holdLock(Object)}.    *<p/>    * Example: in our Master we can execute request in parallel for different tables. We can create    * t1 and create t2 and these creates can be executed at the same time. Anything else on t1/t2 is    * queued waiting that specific table create to happen.    *<p/>    * There are 3 LockState:    *<ul>    *<li>LOCK_ACQUIRED should be returned when the proc has the lock and the proc is ready to    * execute.</li>    *<li>LOCK_YIELD_WAIT should be returned when the proc has not the lock and the framework should    * take care of readding the procedure back to the runnable set for retry</li>    *<li>LOCK_EVENT_WAIT should be returned when the proc has not the lock and someone will take    * care of readding the procedure back to the runnable set when the lock is available.</li>    *</ul>    * @return the lock state as described above.    */
specifier|protected
name|LockState
name|acquireLock
parameter_list|(
name|TEnvironment
name|env
parameter_list|)
block|{
return|return
name|LockState
operator|.
name|LOCK_ACQUIRED
return|;
block|}
comment|/**    * The user should override this method, and release lock if necessary.    */
specifier|protected
name|void
name|releaseLock
parameter_list|(
name|TEnvironment
name|env
parameter_list|)
block|{
comment|// no-op
block|}
comment|/**    * Used to keep the procedure lock even when the procedure is yielding or suspended.    * @return true if the procedure should hold on the lock until completionCleanup()    */
specifier|protected
name|boolean
name|holdLock
parameter_list|(
name|TEnvironment
name|env
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
comment|/**    * This is used in conjunction with {@link #holdLock(Object)}. If {@link #holdLock(Object)}    * returns true, the procedure executor will call acquireLock() once and thereafter    * not call {@link #releaseLock(Object)} until the Procedure is done (Normally, it calls    * release/acquire around each invocation of {@link #execute(Object)}.    * @see #holdLock(Object)    * @return true if the procedure has the lock, false otherwise.    */
annotation|@
name|VisibleForTesting
specifier|public
specifier|final
name|boolean
name|hasLock
parameter_list|()
block|{
return|return
name|locked
return|;
block|}
comment|/**    * Called when the procedure is loaded for replay.    * The procedure implementor may use this method to perform some quick    * operation before replay.    * e.g. failing the procedure if the state on replay may be unknown.    */
specifier|protected
name|void
name|beforeReplay
parameter_list|(
name|TEnvironment
name|env
parameter_list|)
block|{
comment|// no-op
block|}
comment|/**    * Called when the procedure is ready to be added to the queue after    * the loading/replay operation.    */
specifier|protected
name|void
name|afterReplay
parameter_list|(
name|TEnvironment
name|env
parameter_list|)
block|{
comment|// no-op
block|}
comment|/**    * Called when the procedure is marked as completed (success or rollback).    * The procedure implementor may use this method to cleanup in-memory states.    * This operation will not be retried on failure. If a procedure took a lock,    * it will have been released when this method runs.    */
specifier|protected
name|void
name|completionCleanup
parameter_list|(
name|TEnvironment
name|env
parameter_list|)
block|{
comment|// no-op
block|}
comment|/**    * By default, the procedure framework/executor will try to run procedures start to finish.    * Return true to make the executor yield between each execution step to    * give other procedures a chance to run.    * @param env the environment passed to the ProcedureExecutor    * @return Return true if the executor should yield on completion of an execution step.    *         Defaults to return false.    */
specifier|protected
name|boolean
name|isYieldAfterExecutionStep
parameter_list|(
name|TEnvironment
name|env
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
comment|/**    * By default, the executor will keep the procedure result around util    * the eviction TTL is expired. The client can cut down the waiting time    * by requesting that the result is removed from the executor.    * In case of system started procedure, we can force the executor to auto-ack.    * @param env the environment passed to the ProcedureExecutor    * @return true if the executor should wait the client ack for the result.    *         Defaults to return true.    */
specifier|protected
name|boolean
name|shouldWaitClientAck
parameter_list|(
name|TEnvironment
name|env
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
comment|/**    * Override this method to provide procedure specific counters for submitted count, failed    * count and time histogram.    * @param env The environment passed to the procedure executor    * @return Container object for procedure related metric    */
specifier|protected
name|ProcedureMetrics
name|getProcedureMetrics
parameter_list|(
name|TEnvironment
name|env
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
comment|/**    * This function will be called just when procedure is submitted for execution. Override this    * method to update the metrics at the beginning of the procedure. The default implementation    * updates submitted counter if {@link #getProcedureMetrics(Object)} returns non-null    * {@link ProcedureMetrics}.    */
specifier|protected
name|void
name|updateMetricsOnSubmit
parameter_list|(
name|TEnvironment
name|env
parameter_list|)
block|{
name|ProcedureMetrics
name|metrics
init|=
name|getProcedureMetrics
argument_list|(
name|env
argument_list|)
decl_stmt|;
if|if
condition|(
name|metrics
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|Counter
name|submittedCounter
init|=
name|metrics
operator|.
name|getSubmittedCounter
argument_list|()
decl_stmt|;
if|if
condition|(
name|submittedCounter
operator|!=
literal|null
condition|)
block|{
name|submittedCounter
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * This function will be called just after procedure execution is finished. Override this method    * to update metrics at the end of the procedure. If {@link #getProcedureMetrics(Object)} returns    * non-null {@link ProcedureMetrics}, the default implementation adds runtime of a procedure to a    * time histogram for successfully completed procedures. Increments failed counter for failed    * procedures.    *<p/>    * TODO: As any of the sub-procedures on failure rolls back all procedures in the stack, including    * successfully finished siblings, this function may get called twice in certain cases for certain    * procedures. Explore further if this can be called once.    * @param env The environment passed to the procedure executor    * @param runtime Runtime of the procedure in milliseconds    * @param success true if procedure is completed successfully    */
specifier|protected
name|void
name|updateMetricsOnFinish
parameter_list|(
name|TEnvironment
name|env
parameter_list|,
name|long
name|runtime
parameter_list|,
name|boolean
name|success
parameter_list|)
block|{
name|ProcedureMetrics
name|metrics
init|=
name|getProcedureMetrics
argument_list|(
name|env
argument_list|)
decl_stmt|;
if|if
condition|(
name|metrics
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|Histogram
name|timeHisto
init|=
name|metrics
operator|.
name|getTimeHisto
argument_list|()
decl_stmt|;
if|if
condition|(
name|timeHisto
operator|!=
literal|null
condition|)
block|{
name|timeHisto
operator|.
name|update
argument_list|(
name|runtime
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Counter
name|failedCounter
init|=
name|metrics
operator|.
name|getFailedCounter
argument_list|()
decl_stmt|;
if|if
condition|(
name|failedCounter
operator|!=
literal|null
condition|)
block|{
name|failedCounter
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
comment|// Return the simple String presentation of the procedure.
return|return
name|toStringSimpleSB
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Build the StringBuilder for the simple form of procedure string.    * @return the StringBuilder    */
specifier|protected
name|StringBuilder
name|toStringSimpleSB
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"pid="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getProcId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasParent
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", ppid="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getParentProcId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * TODO      * Enable later when this is being used.      * Currently owner not used.     if (hasOwner()) {       sb.append(", owner=");       sb.append(getOwner());     }*/
name|sb
operator|.
name|append
argument_list|(
literal|", state="
argument_list|)
expr_stmt|;
comment|// pState for Procedure State as opposed to any other kind.
name|toStringState
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", hasLock="
argument_list|)
operator|.
name|append
argument_list|(
name|locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", bypass="
argument_list|)
operator|.
name|append
argument_list|(
name|bypass
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hasException
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", exception="
operator|+
name|getException
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"; "
argument_list|)
expr_stmt|;
name|toStringClassDetails
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
name|sb
return|;
block|}
comment|/**    * Extend the toString() information with more procedure details    */
specifier|public
name|String
name|toStringDetails
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|sb
init|=
name|toStringSimpleSB
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" submittedTime="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getSubmittedTime
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", lastUpdate="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getLastUpdate
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|int
index|[]
name|stackIndices
init|=
name|getStackIndexes
argument_list|()
decl_stmt|;
if|if
condition|(
name|stackIndices
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"stackIndexes="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|Arrays
operator|.
name|toString
argument_list|(
name|stackIndices
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|protected
name|String
name|toStringClass
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|toStringClassDetails
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Called from {@link #toString()} when interpolating {@link Procedure} State. Allows decorating    * generic Procedure State with Procedure particulars.    * @param builder Append current {@link ProcedureState}    */
specifier|protected
name|void
name|toStringState
parameter_list|(
name|StringBuilder
name|builder
parameter_list|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|getState
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Extend the toString() information with the procedure details    * e.g. className and parameters    * @param builder the string builder to use to append the proc specific information    */
specifier|protected
name|void
name|toStringClassDetails
parameter_list|(
name|StringBuilder
name|builder
parameter_list|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// ==========================================================================
comment|//  Those fields are unchanged after initialization.
comment|//
comment|//  Each procedure will get created from the user or during
comment|//  ProcedureExecutor.start() during the load() phase and then submitted
comment|//  to the executor. these fields will never be changed after initialization
comment|// ==========================================================================
specifier|public
name|long
name|getProcId
parameter_list|()
block|{
return|return
name|procId
return|;
block|}
specifier|public
name|boolean
name|hasParent
parameter_list|()
block|{
return|return
name|parentProcId
operator|!=
name|NO_PROC_ID
return|;
block|}
specifier|public
name|long
name|getParentProcId
parameter_list|()
block|{
return|return
name|parentProcId
return|;
block|}
specifier|public
name|long
name|getRootProcId
parameter_list|()
block|{
return|return
name|rootProcId
return|;
block|}
specifier|public
name|String
name|getProcName
parameter_list|()
block|{
return|return
name|toStringClass
argument_list|()
return|;
block|}
specifier|public
name|NonceKey
name|getNonceKey
parameter_list|()
block|{
return|return
name|nonceKey
return|;
block|}
specifier|public
name|long
name|getSubmittedTime
parameter_list|()
block|{
return|return
name|submittedTime
return|;
block|}
specifier|public
name|String
name|getOwner
parameter_list|()
block|{
return|return
name|owner
return|;
block|}
specifier|public
name|boolean
name|hasOwner
parameter_list|()
block|{
return|return
name|owner
operator|!=
literal|null
return|;
block|}
comment|/**    * Called by the ProcedureExecutor to assign the ID to the newly created procedure.    */
annotation|@
name|VisibleForTesting
specifier|protected
name|void
name|setProcId
parameter_list|(
name|long
name|procId
parameter_list|)
block|{
name|this
operator|.
name|procId
operator|=
name|procId
expr_stmt|;
name|this
operator|.
name|submittedTime
operator|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
expr_stmt|;
name|setState
argument_list|(
name|ProcedureState
operator|.
name|RUNNABLE
argument_list|)
expr_stmt|;
block|}
comment|/**    * Called by the ProcedureExecutor to assign the parent to the newly created procedure.    */
specifier|protected
name|void
name|setParentProcId
parameter_list|(
name|long
name|parentProcId
parameter_list|)
block|{
name|this
operator|.
name|parentProcId
operator|=
name|parentProcId
expr_stmt|;
block|}
specifier|protected
name|void
name|setRootProcId
parameter_list|(
name|long
name|rootProcId
parameter_list|)
block|{
name|this
operator|.
name|rootProcId
operator|=
name|rootProcId
expr_stmt|;
block|}
comment|/**    * Called by the ProcedureExecutor to set the value to the newly created procedure.    */
annotation|@
name|VisibleForTesting
specifier|protected
name|void
name|setNonceKey
parameter_list|(
name|NonceKey
name|nonceKey
parameter_list|)
block|{
name|this
operator|.
name|nonceKey
operator|=
name|nonceKey
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|void
name|setOwner
parameter_list|(
name|String
name|owner
parameter_list|)
block|{
name|this
operator|.
name|owner
operator|=
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|owner
argument_list|)
condition|?
literal|null
else|:
name|owner
expr_stmt|;
block|}
specifier|public
name|void
name|setOwner
parameter_list|(
name|User
name|owner
parameter_list|)
block|{
assert|assert
name|owner
operator|!=
literal|null
operator|:
literal|"expected owner to be not null"
assert|;
name|setOwner
argument_list|(
name|owner
operator|.
name|getShortName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Called on store load to initialize the Procedure internals after    * the creation/deserialization.    */
specifier|protected
name|void
name|setSubmittedTime
parameter_list|(
name|long
name|submittedTime
parameter_list|)
block|{
name|this
operator|.
name|submittedTime
operator|=
name|submittedTime
expr_stmt|;
block|}
comment|// ==========================================================================
comment|//  runtime state - timeout related
comment|// ==========================================================================
comment|/**    * @param timeout timeout interval in msec    */
specifier|protected
name|void
name|setTimeout
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
name|this
operator|.
name|timeout
operator|=
name|timeout
expr_stmt|;
block|}
specifier|public
name|boolean
name|hasTimeout
parameter_list|()
block|{
return|return
name|timeout
operator|!=
name|NO_TIMEOUT
return|;
block|}
comment|/**    * @return the timeout in msec    */
specifier|public
name|int
name|getTimeout
parameter_list|()
block|{
return|return
name|timeout
return|;
block|}
comment|/**    * Called on store load to initialize the Procedure internals after    * the creation/deserialization.    */
specifier|protected
name|void
name|setLastUpdate
parameter_list|(
name|long
name|lastUpdate
parameter_list|)
block|{
name|this
operator|.
name|lastUpdate
operator|=
name|lastUpdate
expr_stmt|;
block|}
comment|/**    * Called by ProcedureExecutor after each time a procedure step is executed.    */
specifier|protected
name|void
name|updateTimestamp
parameter_list|()
block|{
name|this
operator|.
name|lastUpdate
operator|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
expr_stmt|;
block|}
specifier|public
name|long
name|getLastUpdate
parameter_list|()
block|{
return|return
name|lastUpdate
return|;
block|}
comment|/**    * Timeout of the next timeout.    * Called by the ProcedureExecutor if the procedure has timeout set and    * the procedure is in the waiting queue.    * @return the timestamp of the next timeout.    */
specifier|protected
name|long
name|getTimeoutTimestamp
parameter_list|()
block|{
return|return
name|getLastUpdate
argument_list|()
operator|+
name|getTimeout
argument_list|()
return|;
block|}
comment|// ==========================================================================
comment|//  runtime state
comment|// ==========================================================================
comment|/**    * @return the time elapsed between the last update and the start time of the procedure.    */
specifier|public
name|long
name|elapsedTime
parameter_list|()
block|{
return|return
name|getLastUpdate
argument_list|()
operator|-
name|getSubmittedTime
argument_list|()
return|;
block|}
comment|/**    * @return the serialized result if any, otherwise null    */
specifier|public
name|byte
index|[]
name|getResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
comment|/**    * The procedure may leave a "result" on completion.    * @param result the serialized result that will be passed to the client    */
specifier|protected
name|void
name|setResult
parameter_list|(
name|byte
index|[]
name|result
parameter_list|)
block|{
name|this
operator|.
name|result
operator|=
name|result
expr_stmt|;
block|}
comment|/**    * Will only be called when loading procedures from procedure store, where we need to record    * whether the procedure has already held a lock. Later we will call    * {@link #doAcquireLock(Object, ProcedureStore)} to actually acquire the lock.    */
specifier|final
name|void
name|lockedWhenLoading
parameter_list|()
block|{
name|this
operator|.
name|lockedWhenLoading
operator|=
literal|true
expr_stmt|;
block|}
specifier|public
name|boolean
name|isLockedWhenLoading
parameter_list|()
block|{
return|return
name|lockedWhenLoading
return|;
block|}
comment|// ==============================================================================================
comment|//  Runtime state, updated every operation by the ProcedureExecutor
comment|//
comment|//  There is always 1 thread at the time operating on the state of the procedure.
comment|//  The ProcedureExecutor may check and set states, or some Procecedure may
comment|//  update its own state. but no concurrent updates. we use synchronized here
comment|//  just because the procedure can get scheduled on different executor threads on each step.
comment|// ==============================================================================================
comment|/**    * @return true if the procedure is in a RUNNABLE state.    */
specifier|public
specifier|synchronized
name|boolean
name|isRunnable
parameter_list|()
block|{
return|return
name|state
operator|==
name|ProcedureState
operator|.
name|RUNNABLE
return|;
block|}
specifier|public
specifier|synchronized
name|boolean
name|isInitializing
parameter_list|()
block|{
return|return
name|state
operator|==
name|ProcedureState
operator|.
name|INITIALIZING
return|;
block|}
comment|/**    * @return true if the procedure has failed. It may or may not have rolled back.    */
specifier|public
specifier|synchronized
name|boolean
name|isFailed
parameter_list|()
block|{
return|return
name|state
operator|==
name|ProcedureState
operator|.
name|FAILED
operator|||
name|state
operator|==
name|ProcedureState
operator|.
name|ROLLEDBACK
return|;
block|}
comment|/**    * @return true if the procedure is finished successfully.    */
specifier|public
specifier|synchronized
name|boolean
name|isSuccess
parameter_list|()
block|{
return|return
name|state
operator|==
name|ProcedureState
operator|.
name|SUCCESS
operator|&&
operator|!
name|hasException
argument_list|()
return|;
block|}
comment|/**    * @return true if the procedure is finished. The Procedure may be completed successfully or    * rolledback.    */
specifier|public
specifier|synchronized
name|boolean
name|isFinished
parameter_list|()
block|{
return|return
name|isSuccess
argument_list|()
operator|||
name|state
operator|==
name|ProcedureState
operator|.
name|ROLLEDBACK
return|;
block|}
comment|/**    * @return true if the procedure is waiting for a child to finish or for an external event.    */
specifier|public
specifier|synchronized
name|boolean
name|isWaiting
parameter_list|()
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|WAITING
case|:
case|case
name|WAITING_TIMEOUT
case|:
return|return
literal|true
return|;
default|default:
break|break;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|VisibleForTesting
specifier|protected
specifier|synchronized
name|void
name|setState
parameter_list|(
specifier|final
name|ProcedureState
name|state
parameter_list|)
block|{
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
name|updateTimestamp
argument_list|()
expr_stmt|;
block|}
specifier|public
specifier|synchronized
name|ProcedureState
name|getState
parameter_list|()
block|{
return|return
name|state
return|;
block|}
specifier|protected
name|void
name|setFailure
parameter_list|(
specifier|final
name|String
name|source
parameter_list|,
specifier|final
name|Throwable
name|cause
parameter_list|)
block|{
name|setFailure
argument_list|(
operator|new
name|RemoteProcedureException
argument_list|(
name|source
argument_list|,
name|cause
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|protected
specifier|synchronized
name|void
name|setFailure
parameter_list|(
specifier|final
name|RemoteProcedureException
name|exception
parameter_list|)
block|{
name|this
operator|.
name|exception
operator|=
name|exception
expr_stmt|;
if|if
condition|(
operator|!
name|isFinished
argument_list|()
condition|)
block|{
name|setState
argument_list|(
name|ProcedureState
operator|.
name|FAILED
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|setAbortFailure
parameter_list|(
specifier|final
name|String
name|source
parameter_list|,
specifier|final
name|String
name|msg
parameter_list|)
block|{
name|setFailure
argument_list|(
name|source
argument_list|,
operator|new
name|ProcedureAbortedException
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Called by the ProcedureExecutor when the timeout set by setTimeout() is expired.    *<p/>    * Another usage for this method is to implement retrying. A procedure can set the state to    * {@code WAITING_TIMEOUT} by calling {@code setState} method, and throw a    * {@link ProcedureSuspendedException} to halt the execution of the procedure, and do not forget a    * call {@link #setTimeout(int)} method to set the timeout. And you should also override this    * method to wake up the procedure, and also return false to tell the ProcedureExecutor that the    * timeout event has been handled.    * @return true to let the framework handle the timeout as abort, false in case the procedure    *         handled the timeout itself.    */
specifier|protected
specifier|synchronized
name|boolean
name|setTimeoutFailure
parameter_list|(
name|TEnvironment
name|env
parameter_list|)
block|{
if|if
condition|(
name|state
operator|==
name|ProcedureState
operator|.
name|WAITING_TIMEOUT
condition|)
block|{
name|long
name|timeDiff
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|-
name|lastUpdate
decl_stmt|;
name|setFailure
argument_list|(
literal|"ProcedureExecutor"
argument_list|,
operator|new
name|TimeoutIOException
argument_list|(
literal|"Operation timed out after "
operator|+
name|StringUtils
operator|.
name|humanTimeDiff
argument_list|(
name|timeDiff
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
specifier|synchronized
name|boolean
name|hasException
parameter_list|()
block|{
return|return
name|exception
operator|!=
literal|null
return|;
block|}
specifier|public
specifier|synchronized
name|RemoteProcedureException
name|getException
parameter_list|()
block|{
return|return
name|exception
return|;
block|}
comment|/**    * Called by the ProcedureExecutor on procedure-load to restore the latch state    */
specifier|protected
specifier|synchronized
name|void
name|setChildrenLatch
parameter_list|(
name|int
name|numChildren
parameter_list|)
block|{
name|this
operator|.
name|childrenLatch
operator|=
name|numChildren
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"CHILD LATCH INCREMENT SET "
operator|+
name|this
operator|.
name|childrenLatch
argument_list|,
operator|new
name|Throwable
argument_list|(
name|this
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Called by the ProcedureExecutor on procedure-load to restore the latch state    */
specifier|protected
specifier|synchronized
name|void
name|incChildrenLatch
parameter_list|()
block|{
comment|// TODO: can this be inferred from the stack? I think so...
name|this
operator|.
name|childrenLatch
operator|++
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"CHILD LATCH INCREMENT "
operator|+
name|this
operator|.
name|childrenLatch
argument_list|,
operator|new
name|Throwable
argument_list|(
name|this
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Called by the ProcedureExecutor to notify that one of the sub-procedures has completed.    */
specifier|private
specifier|synchronized
name|boolean
name|childrenCountDown
parameter_list|()
block|{
assert|assert
name|childrenLatch
operator|>
literal|0
operator|:
name|this
assert|;
name|boolean
name|b
init|=
operator|--
name|childrenLatch
operator|==
literal|0
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"CHILD LATCH DECREMENT "
operator|+
name|childrenLatch
argument_list|,
operator|new
name|Throwable
argument_list|(
name|this
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
comment|/**    * Try to set this procedure into RUNNABLE state.    * Succeeds if all subprocedures/children are done.    * @return True if we were able to move procedure to RUNNABLE state.    */
specifier|synchronized
name|boolean
name|tryRunnable
parameter_list|()
block|{
comment|// Don't use isWaiting in the below; it returns true for WAITING and WAITING_TIMEOUT
if|if
condition|(
name|getState
argument_list|()
operator|==
name|ProcedureState
operator|.
name|WAITING
operator|&&
name|childrenCountDown
argument_list|()
condition|)
block|{
name|setState
argument_list|(
name|ProcedureState
operator|.
name|RUNNABLE
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
specifier|protected
specifier|synchronized
name|boolean
name|hasChildren
parameter_list|()
block|{
return|return
name|childrenLatch
operator|>
literal|0
return|;
block|}
specifier|protected
specifier|synchronized
name|int
name|getChildrenLatch
parameter_list|()
block|{
return|return
name|childrenLatch
return|;
block|}
comment|/**    * Called by the RootProcedureState on procedure execution.    * Each procedure store its stack-index positions.    */
specifier|protected
specifier|synchronized
name|void
name|addStackIndex
parameter_list|(
specifier|final
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|stackIndexes
operator|==
literal|null
condition|)
block|{
name|stackIndexes
operator|=
operator|new
name|int
index|[]
block|{
name|index
block|}
expr_stmt|;
block|}
else|else
block|{
name|int
name|count
init|=
name|stackIndexes
operator|.
name|length
decl_stmt|;
name|stackIndexes
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|stackIndexes
argument_list|,
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|stackIndexes
index|[
name|count
index|]
operator|=
name|index
expr_stmt|;
block|}
block|}
specifier|protected
specifier|synchronized
name|boolean
name|removeStackIndex
parameter_list|()
block|{
if|if
condition|(
name|stackIndexes
operator|!=
literal|null
operator|&&
name|stackIndexes
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|stackIndexes
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|stackIndexes
argument_list|,
name|stackIndexes
operator|.
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
name|stackIndexes
operator|=
literal|null
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Called on store load to initialize the Procedure internals after    * the creation/deserialization.    */
specifier|protected
specifier|synchronized
name|void
name|setStackIndexes
parameter_list|(
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|stackIndexes
parameter_list|)
block|{
name|this
operator|.
name|stackIndexes
operator|=
operator|new
name|int
index|[
name|stackIndexes
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|this
operator|.
name|stackIndexes
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|this
operator|.
name|stackIndexes
index|[
name|i
index|]
operator|=
name|stackIndexes
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
specifier|synchronized
name|boolean
name|wasExecuted
parameter_list|()
block|{
return|return
name|stackIndexes
operator|!=
literal|null
return|;
block|}
specifier|protected
specifier|synchronized
name|int
index|[]
name|getStackIndexes
parameter_list|()
block|{
return|return
name|stackIndexes
return|;
block|}
comment|// ==========================================================================
comment|//  Internal methods - called by the ProcedureExecutor
comment|// ==========================================================================
comment|/**    * Internal method called by the ProcedureExecutor that starts the user-level code execute().    * @throws ProcedureSuspendedException This is used when procedure wants to halt processing and    *           skip out without changing states or releasing any locks held.    */
specifier|protected
name|Procedure
argument_list|<
name|TEnvironment
argument_list|>
index|[]
name|doExecute
parameter_list|(
name|TEnvironment
name|env
parameter_list|)
throws|throws
name|ProcedureYieldException
throws|,
name|ProcedureSuspendedException
throws|,
name|InterruptedException
block|{
try|try
block|{
name|updateTimestamp
argument_list|()
expr_stmt|;
if|if
condition|(
name|bypass
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"{} bypassed, returning null to finish it"
argument_list|,
name|this
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|execute
argument_list|(
name|env
argument_list|)
return|;
block|}
finally|finally
block|{
name|updateTimestamp
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Internal method called by the ProcedureExecutor that starts the user-level code rollback().    */
specifier|protected
name|void
name|doRollback
parameter_list|(
name|TEnvironment
name|env
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
try|try
block|{
name|updateTimestamp
argument_list|()
expr_stmt|;
if|if
condition|(
name|bypass
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"{} bypassed, skipping rollback"
argument_list|,
name|this
argument_list|)
expr_stmt|;
return|return;
block|}
name|rollback
argument_list|(
name|env
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|updateTimestamp
argument_list|()
expr_stmt|;
block|}
block|}
specifier|final
name|void
name|restoreLock
parameter_list|(
name|TEnvironment
name|env
parameter_list|)
block|{
if|if
condition|(
operator|!
name|lockedWhenLoading
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"{} didn't hold the lock before restarting, skip acquiring lock."
argument_list|,
name|this
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|isFinished
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"{} is already finished, skip acquiring lock."
argument_list|,
name|this
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|isBypass
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"{} is already bypassed, skip acquiring lock."
argument_list|,
name|this
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// this can happen if the parent stores the sub procedures but before it can
comment|// release its lock, the master restarts
if|if
condition|(
name|getState
argument_list|()
operator|==
name|ProcedureState
operator|.
name|WAITING
operator|&&
operator|!
name|holdLock
argument_list|(
name|env
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"{} is in WAITING STATE, and holdLock= false, skip acquiring lock."
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|lockedWhenLoading
operator|=
literal|false
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"{} held the lock before restarting, call acquireLock to restore it."
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|LockState
name|state
init|=
name|acquireLock
argument_list|(
name|env
argument_list|)
decl_stmt|;
assert|assert
name|state
operator|==
name|LockState
operator|.
name|LOCK_ACQUIRED
assert|;
block|}
comment|/**    * Internal method called by the ProcedureExecutor that starts the user-level code acquireLock().    */
specifier|final
name|LockState
name|doAcquireLock
parameter_list|(
name|TEnvironment
name|env
parameter_list|,
name|ProcedureStore
name|store
parameter_list|)
block|{
if|if
condition|(
name|waitInitialized
argument_list|(
name|env
argument_list|)
condition|)
block|{
return|return
name|LockState
operator|.
name|LOCK_EVENT_WAIT
return|;
block|}
if|if
condition|(
name|lockedWhenLoading
condition|)
block|{
comment|// reset it so we will not consider it anymore
name|lockedWhenLoading
operator|=
literal|false
expr_stmt|;
name|locked
operator|=
literal|true
expr_stmt|;
comment|// Here we return without persist the locked state, as lockedWhenLoading is true means
comment|// that the locked field of the procedure stored in procedure store is true, so we do not need
comment|// to store it again.
return|return
name|LockState
operator|.
name|LOCK_ACQUIRED
return|;
block|}
name|LockState
name|state
init|=
name|acquireLock
argument_list|(
name|env
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|LockState
operator|.
name|LOCK_ACQUIRED
condition|)
block|{
name|locked
operator|=
literal|true
expr_stmt|;
comment|// persist that we have held the lock. This must be done before we actually execute the
comment|// procedure, otherwise when restarting, we may consider the procedure does not have a lock,
comment|// but it may have already done some changes as we have already executed it, and if another
comment|// procedure gets the lock, then the semantic will be broken if the holdLock is true, as we do
comment|// not expect that another procedure can be executed in the middle.
name|store
operator|.
name|update
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
return|return
name|state
return|;
block|}
comment|/**    * Internal method called by the ProcedureExecutor that starts the user-level code releaseLock().    */
specifier|final
name|void
name|doReleaseLock
parameter_list|(
name|TEnvironment
name|env
parameter_list|,
name|ProcedureStore
name|store
parameter_list|)
block|{
name|locked
operator|=
literal|false
expr_stmt|;
comment|// persist that we have released the lock. This must be done before we actually release the
comment|// lock. Another procedure may take this lock immediately after we release the lock, and if we
comment|// crash before persist the information that we have already released the lock, then when
comment|// restarting there will be two procedures which both have the lock and cause problems.
if|if
condition|(
name|getState
argument_list|()
operator|!=
name|ProcedureState
operator|.
name|ROLLEDBACK
condition|)
block|{
comment|// If the state is ROLLEDBACK, it means that we have already deleted the procedure from
comment|// procedure store, so do not need to log the release operation any more.
name|store
operator|.
name|update
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|releaseLock
argument_list|(
name|env
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
specifier|final
name|Procedure
argument_list|<
name|TEnvironment
argument_list|>
name|other
parameter_list|)
block|{
return|return
name|Long
operator|.
name|compare
argument_list|(
name|getProcId
argument_list|()
argument_list|,
name|other
operator|.
name|getProcId
argument_list|()
argument_list|)
return|;
block|}
comment|// ==========================================================================
comment|//  misc utils
comment|// ==========================================================================
comment|/**    * Get an hashcode for the specified Procedure ID    * @return the hashcode for the specified procId    */
specifier|public
specifier|static
name|long
name|getProcIdHashCode
parameter_list|(
name|long
name|procId
parameter_list|)
block|{
name|long
name|h
init|=
name|procId
decl_stmt|;
name|h
operator|^=
name|h
operator|>>
literal|16
expr_stmt|;
name|h
operator|*=
literal|0x85ebca6b
expr_stmt|;
name|h
operator|^=
name|h
operator|>>
literal|13
expr_stmt|;
name|h
operator|*=
literal|0xc2b2ae35
expr_stmt|;
name|h
operator|^=
name|h
operator|>>
literal|16
expr_stmt|;
return|return
name|h
return|;
block|}
comment|/**    * Helper to lookup the root Procedure ID given a specified procedure.    */
specifier|protected
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Long
name|getRootProcedureId
parameter_list|(
name|Map
argument_list|<
name|Long
argument_list|,
name|Procedure
argument_list|<
name|T
argument_list|>
argument_list|>
name|procedures
parameter_list|,
name|Procedure
argument_list|<
name|T
argument_list|>
name|proc
parameter_list|)
block|{
while|while
condition|(
name|proc
operator|.
name|hasParent
argument_list|()
condition|)
block|{
name|proc
operator|=
name|procedures
operator|.
name|get
argument_list|(
name|proc
operator|.
name|getParentProcId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
return|return
name|proc
operator|.
name|getProcId
argument_list|()
return|;
block|}
comment|/**    * @param a the first procedure to be compared.    * @param b the second procedure to be compared.    * @return true if the two procedures have the same parent    */
specifier|public
specifier|static
name|boolean
name|haveSameParent
parameter_list|(
name|Procedure
argument_list|<
name|?
argument_list|>
name|a
parameter_list|,
name|Procedure
argument_list|<
name|?
argument_list|>
name|b
parameter_list|)
block|{
return|return
name|a
operator|.
name|hasParent
argument_list|()
operator|&&
name|b
operator|.
name|hasParent
argument_list|()
operator|&&
operator|(
name|a
operator|.
name|getParentProcId
argument_list|()
operator|==
name|b
operator|.
name|getParentProcId
argument_list|()
operator|)
return|;
block|}
block|}
end_class

end_unit

