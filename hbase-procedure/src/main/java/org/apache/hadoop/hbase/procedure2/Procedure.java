begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ProcedureProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ProcedureProtos
operator|.
name|ProcedureState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ByteStringer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|ByteString
import|;
end_import

begin_comment
comment|/**  * Base Procedure class responsible to handle the Procedure Metadata  * e.g. state, startTime, lastUpdate, stack-indexes, ...  *  * execute() is called each time the procedure is executed.  * it may be called multiple times in case of failure and restart, so the  * code must be idempotent.  * the return is a set of sub-procedures or null in case the procedure doesn't  * have sub-procedures. Once the sub-procedures are successfully completed  * the execute() method is called again, you should think at it as a stack:  *  -&gt; step 1  *  ---&gt; step 2  *  -&gt; step 1  *  * rollback() is called when the procedure or one of the sub-procedures is failed.  * the rollback step is supposed to cleanup the resources created during the  * execute() step. in case of failure and restart rollback() may be called  * multiple times, so the code must be idempotent.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
specifier|abstract
class|class
name|Procedure
parameter_list|<
name|TEnvironment
parameter_list|>
implements|implements
name|Comparable
argument_list|<
name|Procedure
argument_list|>
block|{
comment|// unchanged after initialization
specifier|private
name|String
name|owner
init|=
literal|null
decl_stmt|;
specifier|private
name|Long
name|parentProcId
init|=
literal|null
decl_stmt|;
specifier|private
name|Long
name|procId
init|=
literal|null
decl_stmt|;
specifier|private
name|long
name|startTime
decl_stmt|;
comment|// runtime state, updated every operation
specifier|private
name|ProcedureState
name|state
init|=
name|ProcedureState
operator|.
name|INITIALIZING
decl_stmt|;
specifier|private
name|Integer
name|timeout
init|=
literal|null
decl_stmt|;
specifier|private
name|int
index|[]
name|stackIndexes
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|childrenLatch
init|=
literal|0
decl_stmt|;
specifier|private
name|long
name|lastUpdate
decl_stmt|;
specifier|private
name|RemoteProcedureException
name|exception
init|=
literal|null
decl_stmt|;
specifier|private
name|byte
index|[]
name|result
init|=
literal|null
decl_stmt|;
comment|/**    * The main code of the procedure. It must be idempotent since execute()    * may be called multiple time in case of machine failure in the middle    * of the execution.    * @param env the environment passed to the ProcedureExecutor    * @return a set of sub-procedures or null if there is nothing else to execute.    * @throws ProcedureYieldException the procedure will be added back to the queue and retried later    * @throws InterruptedException the procedure will be added back to the queue and retried later    */
specifier|protected
specifier|abstract
name|Procedure
index|[]
name|execute
parameter_list|(
name|TEnvironment
name|env
parameter_list|)
throws|throws
name|ProcedureYieldException
throws|,
name|InterruptedException
function_decl|;
comment|/**    * The code to undo what done by the execute() code.    * It is called when the procedure or one of the sub-procedure failed or an    * abort was requested. It should cleanup all the resources created by    * the execute() call. The implementation must be idempotent since rollback()    * may be called multiple time in case of machine failure in the middle    * of the execution.    * @param env the environment passed to the ProcedureExecutor    * @throws IOException temporary failure, the rollback will retry later    * @throws InterruptedException the procedure will be added back to the queue and retried later    */
specifier|protected
specifier|abstract
name|void
name|rollback
parameter_list|(
name|TEnvironment
name|env
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
function_decl|;
comment|/**    * The abort() call is asynchronous and each procedure must decide how to deal    * with that, if they want to be abortable. The simplest implementation    * is to have an AtomicBoolean set in the abort() method and then the execute()    * will check if the abort flag is set or not.    * abort() may be called multiple times from the client, so the implementation    * must be idempotent.    *    * NOTE: abort() is not like Thread.interrupt() it is just a notification    * that allows the procedure implementor where to abort to avoid leak and    * have a better control on what was executed and what not.    */
specifier|protected
specifier|abstract
name|boolean
name|abort
parameter_list|(
name|TEnvironment
name|env
parameter_list|)
function_decl|;
comment|/**    * The user-level code of the procedure may have some state to    * persist (e.g. input arguments) to be able to resume on failure.    * @param stream the stream that will contain the user serialized data    */
specifier|protected
specifier|abstract
name|void
name|serializeStateData
parameter_list|(
specifier|final
name|OutputStream
name|stream
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Called on store load to allow the user to decode the previously serialized    * state.    * @param stream the stream that contains the user serialized data    */
specifier|protected
specifier|abstract
name|void
name|deserializeStateData
parameter_list|(
specifier|final
name|InputStream
name|stream
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * The user should override this method, and try to take a lock if necessary.    * A lock can be anything, and it is up to the implementor.    * Example: in our Master we can execute request in parallel for different tables    *          create t1 and create t2 can be executed at the same time.    *          anything else on t1/t2 is queued waiting that specific table create to happen.    *    * @return true if the lock was acquired and false otherwise    */
specifier|protected
name|boolean
name|acquireLock
parameter_list|(
specifier|final
name|TEnvironment
name|env
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
comment|/**    * The user should override this method, and release lock if necessary.    */
specifier|protected
name|void
name|releaseLock
parameter_list|(
specifier|final
name|TEnvironment
name|env
parameter_list|)
block|{
comment|// no-op
block|}
comment|/**    * Called when the procedure is loaded for replay.    * The procedure implementor may use this method to perform some quick    * operation before replay.    * e.g. failing the procedure if the state on replay may be unknown.    */
specifier|protected
name|void
name|beforeReplay
parameter_list|(
specifier|final
name|TEnvironment
name|env
parameter_list|)
block|{
comment|// no-op
block|}
comment|/**    * Called when the procedure is marked as completed (success or rollback).    * The procedure implementor may use this method to cleanup in-memory states.    * This operation will not be retried on failure.    */
specifier|protected
name|void
name|completionCleanup
parameter_list|(
specifier|final
name|TEnvironment
name|env
parameter_list|)
block|{
comment|// no-op
block|}
comment|/**    * By default, the executor will try ro run procedures start to finish.    * Return true to make the executor yield between each execution step to    * give other procedures time to run their steps.    * @param env the environment passed to the ProcedureExecutor    * @return Return true if the executor should yield on completion of an execution step.    *         Defaults to return false.    */
specifier|protected
name|boolean
name|isYieldAfterExecutionStep
parameter_list|(
specifier|final
name|TEnvironment
name|env
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|toStringClassDetails
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|procId
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" id="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getProcId
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hasParent
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" parent="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getParentProcId
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hasOwner
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" owner="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getOwner
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|" state="
argument_list|)
expr_stmt|;
name|toStringState
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Called from {@link #toString()} when interpolating {@link Procedure} state    * @param builder Append current {@link ProcedureState}    */
specifier|protected
name|void
name|toStringState
parameter_list|(
name|StringBuilder
name|builder
parameter_list|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|getState
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Extend the toString() information with the procedure details    * e.g. className and parameters    * @param builder the string builder to use to append the proc specific information    */
specifier|protected
name|void
name|toStringClassDetails
parameter_list|(
name|StringBuilder
name|builder
parameter_list|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return the serialized result if any, otherwise null    */
specifier|public
name|byte
index|[]
name|getResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
comment|/**    * The procedure may leave a "result" on completion.    * @param result the serialized result that will be passed to the client    */
specifier|protected
name|void
name|setResult
parameter_list|(
specifier|final
name|byte
index|[]
name|result
parameter_list|)
block|{
name|this
operator|.
name|result
operator|=
name|result
expr_stmt|;
block|}
specifier|public
name|long
name|getProcId
parameter_list|()
block|{
return|return
name|procId
return|;
block|}
specifier|public
name|boolean
name|hasParent
parameter_list|()
block|{
return|return
name|parentProcId
operator|!=
literal|null
return|;
block|}
specifier|public
name|boolean
name|hasException
parameter_list|()
block|{
return|return
name|exception
operator|!=
literal|null
return|;
block|}
specifier|public
name|boolean
name|hasTimeout
parameter_list|()
block|{
return|return
name|timeout
operator|!=
literal|null
return|;
block|}
specifier|public
name|long
name|getParentProcId
parameter_list|()
block|{
return|return
name|parentProcId
return|;
block|}
comment|/**    * @return true if the procedure has failed.    *         true may mean failed but not yet rolledback or failed and rolledback.    */
specifier|public
specifier|synchronized
name|boolean
name|isFailed
parameter_list|()
block|{
return|return
name|exception
operator|!=
literal|null
operator|||
name|state
operator|==
name|ProcedureState
operator|.
name|ROLLEDBACK
return|;
block|}
comment|/**    * @return true if the procedure is finished successfully.    */
specifier|public
specifier|synchronized
name|boolean
name|isSuccess
parameter_list|()
block|{
return|return
name|state
operator|==
name|ProcedureState
operator|.
name|FINISHED
operator|&&
name|exception
operator|==
literal|null
return|;
block|}
comment|/**    * @return true if the procedure is finished. The Procedure may be completed    *         successfuly or failed and rolledback.    */
specifier|public
specifier|synchronized
name|boolean
name|isFinished
parameter_list|()
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ROLLEDBACK
case|:
return|return
literal|true
return|;
case|case
name|FINISHED
case|:
return|return
name|exception
operator|==
literal|null
return|;
default|default:
break|break;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * @return true if the procedure is waiting for a child to finish or for an external event.    */
specifier|public
specifier|synchronized
name|boolean
name|isWaiting
parameter_list|()
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|WAITING
case|:
case|case
name|WAITING_TIMEOUT
case|:
return|return
literal|true
return|;
default|default:
break|break;
block|}
return|return
literal|false
return|;
block|}
specifier|public
specifier|synchronized
name|RemoteProcedureException
name|getException
parameter_list|()
block|{
return|return
name|exception
return|;
block|}
specifier|public
name|long
name|getStartTime
parameter_list|()
block|{
return|return
name|startTime
return|;
block|}
specifier|public
specifier|synchronized
name|long
name|getLastUpdate
parameter_list|()
block|{
return|return
name|lastUpdate
return|;
block|}
specifier|public
specifier|synchronized
name|long
name|elapsedTime
parameter_list|()
block|{
return|return
name|lastUpdate
operator|-
name|startTime
return|;
block|}
comment|/**    * @param timeout timeout in msec    */
specifier|protected
name|void
name|setTimeout
parameter_list|(
specifier|final
name|int
name|timeout
parameter_list|)
block|{
name|this
operator|.
name|timeout
operator|=
name|timeout
expr_stmt|;
block|}
comment|/**    * @return the timeout in msec    */
specifier|public
name|int
name|getTimeout
parameter_list|()
block|{
return|return
name|timeout
return|;
block|}
comment|/**    * @return the remaining time before the timeout    */
specifier|public
name|long
name|getTimeRemaining
parameter_list|()
block|{
return|return
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|timeout
operator|-
operator|(
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|-
name|startTime
operator|)
argument_list|)
return|;
block|}
specifier|protected
name|void
name|setOwner
parameter_list|(
specifier|final
name|String
name|owner
parameter_list|)
block|{
name|this
operator|.
name|owner
operator|=
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|owner
argument_list|)
condition|?
literal|null
else|:
name|owner
expr_stmt|;
block|}
specifier|public
name|String
name|getOwner
parameter_list|()
block|{
return|return
name|owner
return|;
block|}
specifier|public
name|boolean
name|hasOwner
parameter_list|()
block|{
return|return
name|owner
operator|!=
literal|null
return|;
block|}
annotation|@
name|VisibleForTesting
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
specifier|synchronized
name|void
name|setState
parameter_list|(
specifier|final
name|ProcedureState
name|state
parameter_list|)
block|{
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
name|updateTimestamp
argument_list|()
expr_stmt|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
specifier|synchronized
name|ProcedureState
name|getState
parameter_list|()
block|{
return|return
name|state
return|;
block|}
specifier|protected
name|void
name|setFailure
parameter_list|(
specifier|final
name|String
name|source
parameter_list|,
specifier|final
name|Throwable
name|cause
parameter_list|)
block|{
name|setFailure
argument_list|(
operator|new
name|RemoteProcedureException
argument_list|(
name|source
argument_list|,
name|cause
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|protected
specifier|synchronized
name|void
name|setFailure
parameter_list|(
specifier|final
name|RemoteProcedureException
name|exception
parameter_list|)
block|{
name|this
operator|.
name|exception
operator|=
name|exception
expr_stmt|;
if|if
condition|(
operator|!
name|isFinished
argument_list|()
condition|)
block|{
name|setState
argument_list|(
name|ProcedureState
operator|.
name|FINISHED
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|setAbortFailure
parameter_list|(
specifier|final
name|String
name|source
parameter_list|,
specifier|final
name|String
name|msg
parameter_list|)
block|{
name|setFailure
argument_list|(
name|source
argument_list|,
operator|new
name|ProcedureAbortedException
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
specifier|synchronized
name|boolean
name|setTimeoutFailure
parameter_list|()
block|{
if|if
condition|(
name|state
operator|==
name|ProcedureState
operator|.
name|WAITING_TIMEOUT
condition|)
block|{
name|long
name|timeDiff
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|-
name|lastUpdate
decl_stmt|;
name|setFailure
argument_list|(
literal|"ProcedureExecutor"
argument_list|,
operator|new
name|TimeoutException
argument_list|(
literal|"Operation timed out after "
operator|+
name|StringUtils
operator|.
name|humanTimeDiff
argument_list|(
name|timeDiff
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Called by the ProcedureExecutor to assign the ID to the newly created procedure.    */
annotation|@
name|VisibleForTesting
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
name|void
name|setProcId
parameter_list|(
specifier|final
name|long
name|procId
parameter_list|)
block|{
name|this
operator|.
name|procId
operator|=
name|procId
expr_stmt|;
name|this
operator|.
name|startTime
operator|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
expr_stmt|;
name|setState
argument_list|(
name|ProcedureState
operator|.
name|RUNNABLE
argument_list|)
expr_stmt|;
block|}
comment|/**    * Called by the ProcedureExecutor to assign the parent to the newly created procedure.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
name|void
name|setParentProcId
parameter_list|(
specifier|final
name|long
name|parentProcId
parameter_list|)
block|{
name|this
operator|.
name|parentProcId
operator|=
name|parentProcId
expr_stmt|;
block|}
comment|/**    * Internal method called by the ProcedureExecutor that starts the    * user-level code execute().    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
name|Procedure
index|[]
name|doExecute
parameter_list|(
specifier|final
name|TEnvironment
name|env
parameter_list|)
throws|throws
name|ProcedureYieldException
throws|,
name|InterruptedException
block|{
try|try
block|{
name|updateTimestamp
argument_list|()
expr_stmt|;
return|return
name|execute
argument_list|(
name|env
argument_list|)
return|;
block|}
finally|finally
block|{
name|updateTimestamp
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Internal method called by the ProcedureExecutor that starts the    * user-level code rollback().    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
name|void
name|doRollback
parameter_list|(
specifier|final
name|TEnvironment
name|env
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
try|try
block|{
name|updateTimestamp
argument_list|()
expr_stmt|;
name|rollback
argument_list|(
name|env
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|updateTimestamp
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Called on store load to initialize the Procedure internals after    * the creation/deserialization.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
name|void
name|setStartTime
parameter_list|(
specifier|final
name|long
name|startTime
parameter_list|)
block|{
name|this
operator|.
name|startTime
operator|=
name|startTime
expr_stmt|;
block|}
comment|/**    * Called on store load to initialize the Procedure internals after    * the creation/deserialization.    */
specifier|private
specifier|synchronized
name|void
name|setLastUpdate
parameter_list|(
specifier|final
name|long
name|lastUpdate
parameter_list|)
block|{
name|this
operator|.
name|lastUpdate
operator|=
name|lastUpdate
expr_stmt|;
block|}
specifier|protected
specifier|synchronized
name|void
name|updateTimestamp
parameter_list|()
block|{
name|this
operator|.
name|lastUpdate
operator|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
expr_stmt|;
block|}
comment|/**    * Called by the ProcedureExecutor on procedure-load to restore the latch state    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
specifier|synchronized
name|void
name|setChildrenLatch
parameter_list|(
specifier|final
name|int
name|numChildren
parameter_list|)
block|{
name|this
operator|.
name|childrenLatch
operator|=
name|numChildren
expr_stmt|;
block|}
comment|/**    * Called by the ProcedureExecutor on procedure-load to restore the latch state    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
specifier|synchronized
name|void
name|incChildrenLatch
parameter_list|()
block|{
comment|// TODO: can this be inferred from the stack? I think so...
name|this
operator|.
name|childrenLatch
operator|++
expr_stmt|;
block|}
comment|/**    * Called by the ProcedureExecutor to notify that one of the sub-procedures    * has completed.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
specifier|synchronized
name|boolean
name|childrenCountDown
parameter_list|()
block|{
assert|assert
name|childrenLatch
operator|>
literal|0
assert|;
return|return
operator|--
name|childrenLatch
operator|==
literal|0
return|;
block|}
comment|/**    * Called by the RootProcedureState on procedure execution.    * Each procedure store its stack-index positions.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
specifier|synchronized
name|void
name|addStackIndex
parameter_list|(
specifier|final
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|stackIndexes
operator|==
literal|null
condition|)
block|{
name|stackIndexes
operator|=
operator|new
name|int
index|[]
block|{
name|index
block|}
expr_stmt|;
block|}
else|else
block|{
name|int
name|count
init|=
name|stackIndexes
operator|.
name|length
decl_stmt|;
name|stackIndexes
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|stackIndexes
argument_list|,
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|stackIndexes
index|[
name|count
index|]
operator|=
name|index
expr_stmt|;
block|}
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
specifier|synchronized
name|boolean
name|removeStackIndex
parameter_list|()
block|{
if|if
condition|(
name|stackIndexes
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|stackIndexes
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|stackIndexes
argument_list|,
name|stackIndexes
operator|.
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
name|stackIndexes
operator|=
literal|null
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Called on store load to initialize the Procedure internals after    * the creation/deserialization.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
specifier|synchronized
name|void
name|setStackIndexes
parameter_list|(
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|stackIndexes
parameter_list|)
block|{
name|this
operator|.
name|stackIndexes
operator|=
operator|new
name|int
index|[
name|stackIndexes
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|this
operator|.
name|stackIndexes
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|this
operator|.
name|stackIndexes
index|[
name|i
index|]
operator|=
name|stackIndexes
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
specifier|synchronized
name|boolean
name|wasExecuted
parameter_list|()
block|{
return|return
name|stackIndexes
operator|!=
literal|null
return|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
specifier|synchronized
name|int
index|[]
name|getStackIndexes
parameter_list|()
block|{
return|return
name|stackIndexes
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
specifier|final
name|Procedure
name|other
parameter_list|)
block|{
name|long
name|diff
init|=
name|getProcId
argument_list|()
operator|-
name|other
operator|.
name|getProcId
argument_list|()
decl_stmt|;
return|return
operator|(
name|diff
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
operator|(
name|diff
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
comment|/**    * Get an hashcode for the specified Procedure ID    * @return the hashcode for the specified procId    */
specifier|public
specifier|static
name|long
name|getProcIdHashCode
parameter_list|(
specifier|final
name|long
name|procId
parameter_list|)
block|{
name|long
name|h
init|=
name|procId
decl_stmt|;
name|h
operator|^=
name|h
operator|>>
literal|16
expr_stmt|;
name|h
operator|*=
literal|0x85ebca6b
expr_stmt|;
name|h
operator|^=
name|h
operator|>>
literal|13
expr_stmt|;
name|h
operator|*=
literal|0xc2b2ae35
expr_stmt|;
name|h
operator|^=
name|h
operator|>>
literal|16
expr_stmt|;
return|return
name|h
return|;
block|}
comment|/*    * Helper to lookup the root Procedure ID given a specified procedure.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
specifier|static
name|Long
name|getRootProcedureId
parameter_list|(
specifier|final
name|Map
argument_list|<
name|Long
argument_list|,
name|Procedure
argument_list|>
name|procedures
parameter_list|,
name|Procedure
name|proc
parameter_list|)
block|{
while|while
condition|(
name|proc
operator|.
name|hasParent
argument_list|()
condition|)
block|{
name|proc
operator|=
name|procedures
operator|.
name|get
argument_list|(
name|proc
operator|.
name|getParentProcId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc
operator|==
literal|null
condition|)
return|return
literal|null
return|;
block|}
return|return
name|proc
operator|.
name|getProcId
argument_list|()
return|;
block|}
specifier|protected
specifier|static
name|Procedure
name|newInstance
parameter_list|(
specifier|final
name|String
name|className
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|Class
operator|.
name|forName
argument_list|(
name|className
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Modifier
operator|.
name|isPublic
argument_list|(
name|clazz
operator|.
name|getModifiers
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
literal|"the "
operator|+
name|clazz
operator|+
literal|" class is not public"
argument_list|)
throw|;
block|}
name|Constructor
argument_list|<
name|?
argument_list|>
name|ctor
init|=
name|clazz
operator|.
name|getConstructor
argument_list|()
decl_stmt|;
assert|assert
name|ctor
operator|!=
literal|null
operator|:
literal|"no constructor found"
assert|;
if|if
condition|(
operator|!
name|Modifier
operator|.
name|isPublic
argument_list|(
name|ctor
operator|.
name|getModifiers
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
literal|"the "
operator|+
name|clazz
operator|+
literal|" constructor is not public"
argument_list|)
throw|;
block|}
return|return
operator|(
name|Procedure
operator|)
name|ctor
operator|.
name|newInstance
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The procedure class "
operator|+
name|className
operator|+
literal|" must be accessible and have an empty constructor"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|protected
specifier|static
name|void
name|validateClass
parameter_list|(
specifier|final
name|Procedure
name|proc
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|proc
operator|.
name|getClass
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|Modifier
operator|.
name|isPublic
argument_list|(
name|clazz
operator|.
name|getModifiers
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
literal|"the "
operator|+
name|clazz
operator|+
literal|" class is not public"
argument_list|)
throw|;
block|}
name|Constructor
argument_list|<
name|?
argument_list|>
name|ctor
init|=
name|clazz
operator|.
name|getConstructor
argument_list|()
decl_stmt|;
assert|assert
name|ctor
operator|!=
literal|null
assert|;
if|if
condition|(
operator|!
name|Modifier
operator|.
name|isPublic
argument_list|(
name|ctor
operator|.
name|getModifiers
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
literal|"the "
operator|+
name|clazz
operator|+
literal|" constructor is not public"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The procedure class "
operator|+
name|proc
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" must be accessible and have an empty constructor"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Helper to convert the procedure to protobuf.    * Used by ProcedureStore implementations.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|static
name|ProcedureProtos
operator|.
name|Procedure
name|convert
parameter_list|(
specifier|final
name|Procedure
name|proc
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|proc
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|validateClass
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|ProcedureProtos
operator|.
name|Procedure
operator|.
name|Builder
name|builder
init|=
name|ProcedureProtos
operator|.
name|Procedure
operator|.
name|newBuilder
argument_list|()
operator|.
name|setClassName
argument_list|(
name|proc
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|setProcId
argument_list|(
name|proc
operator|.
name|getProcId
argument_list|()
argument_list|)
operator|.
name|setState
argument_list|(
name|proc
operator|.
name|getState
argument_list|()
argument_list|)
operator|.
name|setStartTime
argument_list|(
name|proc
operator|.
name|getStartTime
argument_list|()
argument_list|)
operator|.
name|setLastUpdate
argument_list|(
name|proc
operator|.
name|getLastUpdate
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|proc
operator|.
name|hasParent
argument_list|()
condition|)
block|{
name|builder
operator|.
name|setParentId
argument_list|(
name|proc
operator|.
name|getParentProcId
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|proc
operator|.
name|hasTimeout
argument_list|()
condition|)
block|{
name|builder
operator|.
name|setTimeout
argument_list|(
name|proc
operator|.
name|getTimeout
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|proc
operator|.
name|hasOwner
argument_list|()
condition|)
block|{
name|builder
operator|.
name|setOwner
argument_list|(
name|proc
operator|.
name|getOwner
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
index|[]
name|stackIds
init|=
name|proc
operator|.
name|getStackIndexes
argument_list|()
decl_stmt|;
if|if
condition|(
name|stackIds
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|stackIds
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|builder
operator|.
name|addStackId
argument_list|(
name|stackIds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|proc
operator|.
name|hasException
argument_list|()
condition|)
block|{
name|RemoteProcedureException
name|exception
init|=
name|proc
operator|.
name|getException
argument_list|()
decl_stmt|;
name|builder
operator|.
name|setException
argument_list|(
name|RemoteProcedureException
operator|.
name|toProto
argument_list|(
name|exception
operator|.
name|getSource
argument_list|()
argument_list|,
name|exception
operator|.
name|getCause
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|result
init|=
name|proc
operator|.
name|getResult
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setResult
argument_list|(
name|ByteStringer
operator|.
name|wrap
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ByteString
operator|.
name|Output
name|stateStream
init|=
name|ByteString
operator|.
name|newOutput
argument_list|()
decl_stmt|;
name|proc
operator|.
name|serializeStateData
argument_list|(
name|stateStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|stateStream
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|builder
operator|.
name|setStateData
argument_list|(
name|stateStream
operator|.
name|toByteString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Helper to convert the protobuf procedure.    * Used by ProcedureStore implementations.    *    * TODO: OPTIMIZATION: some of the field never change during the execution    *                     (e.g. className, procId, parentId, ...).    *                     We can split in 'data' and 'state', and the store    *                     may take advantage of it by storing the data only on insert().    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|static
name|Procedure
name|convert
parameter_list|(
specifier|final
name|ProcedureProtos
operator|.
name|Procedure
name|proto
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Procedure from class name
name|Procedure
name|proc
init|=
name|Procedure
operator|.
name|newInstance
argument_list|(
name|proto
operator|.
name|getClassName
argument_list|()
argument_list|)
decl_stmt|;
comment|// set fields
name|proc
operator|.
name|setProcId
argument_list|(
name|proto
operator|.
name|getProcId
argument_list|()
argument_list|)
expr_stmt|;
name|proc
operator|.
name|setState
argument_list|(
name|proto
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|proc
operator|.
name|setStartTime
argument_list|(
name|proto
operator|.
name|getStartTime
argument_list|()
argument_list|)
expr_stmt|;
name|proc
operator|.
name|setLastUpdate
argument_list|(
name|proto
operator|.
name|getLastUpdate
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
operator|.
name|hasParentId
argument_list|()
condition|)
block|{
name|proc
operator|.
name|setParentProcId
argument_list|(
name|proto
operator|.
name|getParentId
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|proto
operator|.
name|hasOwner
argument_list|()
condition|)
block|{
name|proc
operator|.
name|setOwner
argument_list|(
name|proto
operator|.
name|getOwner
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|proto
operator|.
name|hasTimeout
argument_list|()
condition|)
block|{
name|proc
operator|.
name|setTimeout
argument_list|(
name|proto
operator|.
name|getTimeout
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|proto
operator|.
name|getStackIdCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|proc
operator|.
name|setStackIndexes
argument_list|(
name|proto
operator|.
name|getStackIdList
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|proto
operator|.
name|hasException
argument_list|()
condition|)
block|{
assert|assert
name|proc
operator|.
name|getState
argument_list|()
operator|==
name|ProcedureState
operator|.
name|FINISHED
operator|||
name|proc
operator|.
name|getState
argument_list|()
operator|==
name|ProcedureState
operator|.
name|ROLLEDBACK
operator|:
literal|"The procedure must be failed (waiting to rollback) or rolledback"
assert|;
name|proc
operator|.
name|setFailure
argument_list|(
name|RemoteProcedureException
operator|.
name|fromProto
argument_list|(
name|proto
operator|.
name|getException
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|proto
operator|.
name|hasResult
argument_list|()
condition|)
block|{
name|proc
operator|.
name|setResult
argument_list|(
name|proto
operator|.
name|getResult
argument_list|()
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// we want to call deserialize even when the stream is empty, mainly for testing.
name|proc
operator|.
name|deserializeStateData
argument_list|(
name|proto
operator|.
name|getStateData
argument_list|()
operator|.
name|newInput
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|proc
return|;
block|}
block|}
end_class

end_unit

