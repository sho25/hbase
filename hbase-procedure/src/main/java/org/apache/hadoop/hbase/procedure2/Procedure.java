begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|TimeoutIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ProcedureProtos
operator|.
name|ProcedureState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|User
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|NonceKey
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * Base Procedure class responsible to handle the Procedure Metadata  * e.g. state, startTime, lastUpdate, stack-indexes, ...  *  * execute() is called each time the procedure is executed.  * it may be called multiple times in case of failure and restart, so the  * code must be idempotent.  * the return is a set of sub-procedures or null in case the procedure doesn't  * have sub-procedures. Once the sub-procedures are successfully completed  * the execute() method is called again, you should think at it as a stack:  *  -&gt; step 1  *  ---&gt; step 2  *  -&gt; step 1  *  * rollback() is called when the procedure or one of the sub-procedures is failed.  * the rollback step is supposed to cleanup the resources created during the  * execute() step. in case of failure and restart rollback() may be called  * multiple times, so the code must be idempotent.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
specifier|abstract
class|class
name|Procedure
parameter_list|<
name|TEnvironment
parameter_list|>
implements|implements
name|Comparable
argument_list|<
name|Procedure
argument_list|>
block|{
specifier|public
specifier|static
specifier|final
name|long
name|NO_PROC_ID
init|=
operator|-
literal|1
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|int
name|NO_TIMEOUT
init|=
operator|-
literal|1
decl_stmt|;
specifier|public
enum|enum
name|LockState
block|{
name|LOCK_ACQUIRED
block|,
comment|// lock acquired and ready to execute
name|LOCK_YIELD_WAIT
block|,
comment|// lock not acquired, framework needs to yield
name|LOCK_EVENT_WAIT
block|,
comment|// lock not acquired, an event will yield the procedure
block|}
comment|// unchanged after initialization
specifier|private
name|NonceKey
name|nonceKey
init|=
literal|null
decl_stmt|;
specifier|private
name|String
name|owner
init|=
literal|null
decl_stmt|;
specifier|private
name|long
name|parentProcId
init|=
name|NO_PROC_ID
decl_stmt|;
specifier|private
name|long
name|rootProcId
init|=
name|NO_PROC_ID
decl_stmt|;
specifier|private
name|long
name|procId
init|=
name|NO_PROC_ID
decl_stmt|;
specifier|private
name|long
name|startTime
decl_stmt|;
comment|// runtime state, updated every operation
specifier|private
name|ProcedureState
name|state
init|=
name|ProcedureState
operator|.
name|INITIALIZING
decl_stmt|;
specifier|private
name|RemoteProcedureException
name|exception
init|=
literal|null
decl_stmt|;
specifier|private
name|int
index|[]
name|stackIndexes
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|childrenLatch
init|=
literal|0
decl_stmt|;
specifier|private
specifier|volatile
name|int
name|timeout
init|=
name|NO_TIMEOUT
decl_stmt|;
specifier|private
specifier|volatile
name|long
name|lastUpdate
decl_stmt|;
specifier|private
specifier|volatile
name|byte
index|[]
name|result
init|=
literal|null
decl_stmt|;
comment|/**    * The main code of the procedure. It must be idempotent since execute()    * may be called multiple time in case of machine failure in the middle    * of the execution.    * @param env the environment passed to the ProcedureExecutor    * @return a set of sub-procedures or null if there is nothing else to execute.    * @throws ProcedureYieldException the procedure will be added back to the queue and retried later    * @throws InterruptedException the procedure will be added back to the queue and retried later    */
specifier|protected
specifier|abstract
name|Procedure
index|[]
name|execute
parameter_list|(
name|TEnvironment
name|env
parameter_list|)
throws|throws
name|ProcedureYieldException
throws|,
name|ProcedureSuspendedException
throws|,
name|InterruptedException
function_decl|;
comment|/**    * The code to undo what done by the execute() code.    * It is called when the procedure or one of the sub-procedure failed or an    * abort was requested. It should cleanup all the resources created by    * the execute() call. The implementation must be idempotent since rollback()    * may be called multiple time in case of machine failure in the middle    * of the execution.    * @param env the environment passed to the ProcedureExecutor    * @throws IOException temporary failure, the rollback will retry later    * @throws InterruptedException the procedure will be added back to the queue and retried later    */
specifier|protected
specifier|abstract
name|void
name|rollback
parameter_list|(
name|TEnvironment
name|env
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
function_decl|;
comment|/**    * The abort() call is asynchronous and each procedure must decide how to deal    * with that, if they want to be abortable. The simplest implementation    * is to have an AtomicBoolean set in the abort() method and then the execute()    * will check if the abort flag is set or not.    * abort() may be called multiple times from the client, so the implementation    * must be idempotent.    *    * NOTE: abort() is not like Thread.interrupt() it is just a notification    * that allows the procedure implementor where to abort to avoid leak and    * have a better control on what was executed and what not.    */
specifier|protected
specifier|abstract
name|boolean
name|abort
parameter_list|(
name|TEnvironment
name|env
parameter_list|)
function_decl|;
comment|/**    * The user-level code of the procedure may have some state to    * persist (e.g. input arguments) to be able to resume on failure.    * @param stream the stream that will contain the user serialized data    */
specifier|protected
specifier|abstract
name|void
name|serializeStateData
parameter_list|(
specifier|final
name|OutputStream
name|stream
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Called on store load to allow the user to decode the previously serialized    * state.    * @param stream the stream that contains the user serialized data    */
specifier|protected
specifier|abstract
name|void
name|deserializeStateData
parameter_list|(
specifier|final
name|InputStream
name|stream
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * The user should override this method, and try to take a lock if necessary.    * A lock can be anything, and it is up to the implementor.    *    *<p>Example: in our Master we can execute request in parallel for different tables.    * We can create t1 and create t2 and this can be executed at the same time.    * Anything else on t1/t2 is queued waiting that specific table create to happen.    *    *<p>There are 3 LockState:    *<ul><li>LOCK_ACQUIRED should be returned when the proc has the lock and the proc is    * ready to execute.</li>    *<li>LOCK_YIELD_WAIT should be returned when the proc has not the lock and the framework    * should take care of readding the procedure back to the runnable set for retry</li>    *<li>LOCK_EVENT_WAIT should be returned when the proc has not the lock and someone will    * take care of readding the procedure back to the runnable set when the lock is available.    *</li></ul>    * @return the lock state as described above.    */
specifier|protected
name|LockState
name|acquireLock
parameter_list|(
specifier|final
name|TEnvironment
name|env
parameter_list|)
block|{
return|return
name|LockState
operator|.
name|LOCK_ACQUIRED
return|;
block|}
comment|/**    * The user should override this method, and release lock if necessary.    */
specifier|protected
name|void
name|releaseLock
parameter_list|(
specifier|final
name|TEnvironment
name|env
parameter_list|)
block|{
comment|// no-op
block|}
comment|/**    * Used to keep the procedure lock even when the procedure is yielding or suspended.    * @return true if the procedure should hold on the lock until completionCleanup()    */
specifier|protected
name|boolean
name|holdLock
parameter_list|(
specifier|final
name|TEnvironment
name|env
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
comment|/**    * This is used in conjuction with holdLock(). If holdLock() is true    * the procedure executor will not call acquireLock() if hasLock() is true.    * @return true if the procedure has the lock, false otherwise.    */
specifier|protected
name|boolean
name|hasLock
parameter_list|(
specifier|final
name|TEnvironment
name|env
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
comment|/**    * Called when the procedure is loaded for replay.    * The procedure implementor may use this method to perform some quick    * operation before replay.    * e.g. failing the procedure if the state on replay may be unknown.    */
specifier|protected
name|void
name|beforeReplay
parameter_list|(
specifier|final
name|TEnvironment
name|env
parameter_list|)
block|{
comment|// no-op
block|}
comment|/**    * Called when the procedure is ready to be added to the queue after    * the loading/replay operation.    */
specifier|protected
name|void
name|afterReplay
parameter_list|(
specifier|final
name|TEnvironment
name|env
parameter_list|)
block|{
comment|// no-op
block|}
comment|/**    * Called when the procedure is marked as completed (success or rollback).    * The procedure implementor may use this method to cleanup in-memory states.    * This operation will not be retried on failure.    */
specifier|protected
name|void
name|completionCleanup
parameter_list|(
specifier|final
name|TEnvironment
name|env
parameter_list|)
block|{
comment|// no-op
block|}
comment|/**    * By default, the executor will try ro run procedures start to finish.    * Return true to make the executor yield between each execution step to    * give other procedures time to run their steps.    * @param env the environment passed to the ProcedureExecutor    * @return Return true if the executor should yield on completion of an execution step.    *         Defaults to return false.    */
specifier|protected
name|boolean
name|isYieldAfterExecutionStep
parameter_list|(
specifier|final
name|TEnvironment
name|env
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
comment|/**    * By default, the executor will keep the procedure result around util    * the eviction TTL is expired. The client can cut down the waiting time    * by requesting that the result is removed from the executor.    * In case of system started procedure, we can force the executor to auto-ack.    * @param env the environment passed to the ProcedureExecutor    * @return true if the executor should wait the client ack for the result.    *         Defaults to return true.    */
specifier|protected
name|boolean
name|shouldWaitClientAck
parameter_list|(
specifier|final
name|TEnvironment
name|env
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
comment|// Return the simple String presentation of the procedure.
return|return
name|toStringSimpleSB
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Build the StringBuilder for the simple form of    * procedure string.    * @return the StringBuilder    */
specifier|protected
name|StringBuilder
name|toStringSimpleSB
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"procId="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getProcId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasParent
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", parentProcId="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getParentProcId
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hasOwner
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", owner="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getOwner
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|", state="
argument_list|)
expr_stmt|;
name|toStringState
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasException
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", failed="
operator|+
name|getException
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|toStringClassDetails
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
name|sb
return|;
block|}
comment|/**    * Extend the toString() information with more procedure    * details    */
specifier|public
name|String
name|toStringDetails
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|sb
init|=
name|toStringSimpleSB
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" startTime="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getStartTime
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" lastUpdate="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getLastUpdate
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|int
index|[]
name|stackIndices
init|=
name|getStackIndexes
argument_list|()
decl_stmt|;
if|if
condition|(
name|stackIndices
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"stackIndexes="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|Arrays
operator|.
name|toString
argument_list|(
name|stackIndices
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|protected
name|String
name|toStringClass
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|toStringClassDetails
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Called from {@link #toString()} when interpolating {@link Procedure} state    * @param builder Append current {@link ProcedureState}    */
specifier|protected
name|void
name|toStringState
parameter_list|(
name|StringBuilder
name|builder
parameter_list|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|getState
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Extend the toString() information with the procedure details    * e.g. className and parameters    * @param builder the string builder to use to append the proc specific information    */
specifier|protected
name|void
name|toStringClassDetails
parameter_list|(
name|StringBuilder
name|builder
parameter_list|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// ==========================================================================
comment|//  Those fields are unchanged after initialization.
comment|//
comment|//  Each procedure will get created from the user or during
comment|//  ProcedureExecutor.start() during the load() phase and then submitted
comment|//  to the executor. these fields will never be changed after initialization
comment|// ==========================================================================
specifier|public
name|long
name|getProcId
parameter_list|()
block|{
return|return
name|procId
return|;
block|}
specifier|public
name|boolean
name|hasParent
parameter_list|()
block|{
return|return
name|parentProcId
operator|!=
name|NO_PROC_ID
return|;
block|}
specifier|public
name|long
name|getParentProcId
parameter_list|()
block|{
return|return
name|parentProcId
return|;
block|}
specifier|public
name|long
name|getRootProcId
parameter_list|()
block|{
return|return
name|rootProcId
return|;
block|}
specifier|public
name|NonceKey
name|getNonceKey
parameter_list|()
block|{
return|return
name|nonceKey
return|;
block|}
specifier|public
name|long
name|getStartTime
parameter_list|()
block|{
return|return
name|startTime
return|;
block|}
specifier|public
name|String
name|getOwner
parameter_list|()
block|{
return|return
name|owner
return|;
block|}
specifier|public
name|boolean
name|hasOwner
parameter_list|()
block|{
return|return
name|owner
operator|!=
literal|null
return|;
block|}
comment|/**    * Called by the ProcedureExecutor to assign the ID to the newly created procedure.    */
annotation|@
name|VisibleForTesting
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
name|void
name|setProcId
parameter_list|(
specifier|final
name|long
name|procId
parameter_list|)
block|{
name|this
operator|.
name|procId
operator|=
name|procId
expr_stmt|;
name|this
operator|.
name|startTime
operator|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
expr_stmt|;
name|setState
argument_list|(
name|ProcedureState
operator|.
name|RUNNABLE
argument_list|)
expr_stmt|;
block|}
comment|/**    * Called by the ProcedureExecutor to assign the parent to the newly created procedure.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
name|void
name|setParentProcId
parameter_list|(
specifier|final
name|long
name|parentProcId
parameter_list|)
block|{
name|this
operator|.
name|parentProcId
operator|=
name|parentProcId
expr_stmt|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
name|void
name|setRootProcId
parameter_list|(
specifier|final
name|long
name|rootProcId
parameter_list|)
block|{
name|this
operator|.
name|rootProcId
operator|=
name|rootProcId
expr_stmt|;
block|}
comment|/**    * Called by the ProcedureExecutor to set the value to the newly created procedure.    */
annotation|@
name|VisibleForTesting
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
name|void
name|setNonceKey
parameter_list|(
specifier|final
name|NonceKey
name|nonceKey
parameter_list|)
block|{
name|this
operator|.
name|nonceKey
operator|=
name|nonceKey
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
name|void
name|setOwner
parameter_list|(
specifier|final
name|String
name|owner
parameter_list|)
block|{
name|this
operator|.
name|owner
operator|=
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|owner
argument_list|)
condition|?
literal|null
else|:
name|owner
expr_stmt|;
block|}
specifier|public
name|void
name|setOwner
parameter_list|(
specifier|final
name|User
name|owner
parameter_list|)
block|{
assert|assert
name|owner
operator|!=
literal|null
operator|:
literal|"expected owner to be not null"
assert|;
name|setOwner
argument_list|(
name|owner
operator|.
name|getShortName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Called on store load to initialize the Procedure internals after    * the creation/deserialization.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
name|void
name|setStartTime
parameter_list|(
specifier|final
name|long
name|startTime
parameter_list|)
block|{
name|this
operator|.
name|startTime
operator|=
name|startTime
expr_stmt|;
block|}
comment|// ==========================================================================
comment|//  runtime state - timeout related
comment|// ==========================================================================
comment|/**    * @param timeout timeout interval in msec    */
specifier|protected
name|void
name|setTimeout
parameter_list|(
specifier|final
name|int
name|timeout
parameter_list|)
block|{
name|this
operator|.
name|timeout
operator|=
name|timeout
expr_stmt|;
block|}
specifier|public
name|boolean
name|hasTimeout
parameter_list|()
block|{
return|return
name|timeout
operator|!=
name|NO_TIMEOUT
return|;
block|}
comment|/**    * @return the timeout in msec    */
specifier|public
name|int
name|getTimeout
parameter_list|()
block|{
return|return
name|timeout
return|;
block|}
comment|/**    * Called on store load to initialize the Procedure internals after    * the creation/deserialization.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
name|void
name|setLastUpdate
parameter_list|(
specifier|final
name|long
name|lastUpdate
parameter_list|)
block|{
name|this
operator|.
name|lastUpdate
operator|=
name|lastUpdate
expr_stmt|;
block|}
comment|/**    * Called by ProcedureExecutor after each time a procedure step is executed.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
name|void
name|updateTimestamp
parameter_list|()
block|{
name|this
operator|.
name|lastUpdate
operator|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
expr_stmt|;
block|}
specifier|public
name|long
name|getLastUpdate
parameter_list|()
block|{
return|return
name|lastUpdate
return|;
block|}
comment|/**    * Timeout of the next timeout.    * Called by the ProcedureExecutor if the procedure has timeout set and    * the procedure is in the waiting queue.    * @return the timestamp of the next timeout.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
name|long
name|getTimeoutTimestamp
parameter_list|()
block|{
return|return
name|getLastUpdate
argument_list|()
operator|+
name|getTimeout
argument_list|()
return|;
block|}
comment|// ==========================================================================
comment|//  runtime state
comment|// ==========================================================================
comment|/**    * @return the time elapsed between the last update and the start time of the procedure.    */
specifier|public
name|long
name|elapsedTime
parameter_list|()
block|{
return|return
name|getLastUpdate
argument_list|()
operator|-
name|getStartTime
argument_list|()
return|;
block|}
comment|/**    * @return the serialized result if any, otherwise null    */
specifier|public
name|byte
index|[]
name|getResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
comment|/**    * The procedure may leave a "result" on completion.    * @param result the serialized result that will be passed to the client    */
specifier|protected
name|void
name|setResult
parameter_list|(
specifier|final
name|byte
index|[]
name|result
parameter_list|)
block|{
name|this
operator|.
name|result
operator|=
name|result
expr_stmt|;
block|}
comment|// ==============================================================================================
comment|//  Runtime state, updated every operation by the ProcedureExecutor
comment|//
comment|//  There is always 1 thread at the time operating on the state of the procedure.
comment|//  The ProcedureExecutor may check and set states, or some Procecedure may
comment|//  update its own state. but no concurrent updates. we use synchronized here
comment|//  just because the procedure can get scheduled on different executor threads on each step.
comment|// ==============================================================================================
comment|/**    * @return true if the procedure is in a RUNNABLE state.    */
specifier|protected
specifier|synchronized
name|boolean
name|isRunnable
parameter_list|()
block|{
return|return
name|state
operator|==
name|ProcedureState
operator|.
name|RUNNABLE
return|;
block|}
specifier|public
specifier|synchronized
name|boolean
name|isInitializing
parameter_list|()
block|{
return|return
name|state
operator|==
name|ProcedureState
operator|.
name|INITIALIZING
return|;
block|}
comment|/**    * @return true if the procedure has failed.    *         true may mean failed but not yet rolledback or failed and rolledback.    */
specifier|public
specifier|synchronized
name|boolean
name|isFailed
parameter_list|()
block|{
return|return
name|exception
operator|!=
literal|null
operator|||
name|state
operator|==
name|ProcedureState
operator|.
name|ROLLEDBACK
return|;
block|}
comment|/**    * @return true if the procedure is finished successfully.    */
specifier|public
specifier|synchronized
name|boolean
name|isSuccess
parameter_list|()
block|{
return|return
name|state
operator|==
name|ProcedureState
operator|.
name|FINISHED
operator|&&
name|exception
operator|==
literal|null
return|;
block|}
comment|/**    * @return true if the procedure is finished. The Procedure may be completed    *         successfuly or failed and rolledback.    */
specifier|public
specifier|synchronized
name|boolean
name|isFinished
parameter_list|()
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ROLLEDBACK
case|:
return|return
literal|true
return|;
case|case
name|FINISHED
case|:
return|return
name|exception
operator|==
literal|null
return|;
default|default:
break|break;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * @return true if the procedure is waiting for a child to finish or for an external event.    */
specifier|public
specifier|synchronized
name|boolean
name|isWaiting
parameter_list|()
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|WAITING
case|:
case|case
name|WAITING_TIMEOUT
case|:
return|return
literal|true
return|;
default|default:
break|break;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|VisibleForTesting
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
specifier|synchronized
name|void
name|setState
parameter_list|(
specifier|final
name|ProcedureState
name|state
parameter_list|)
block|{
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
name|updateTimestamp
argument_list|()
expr_stmt|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
specifier|synchronized
name|ProcedureState
name|getState
parameter_list|()
block|{
return|return
name|state
return|;
block|}
specifier|protected
name|void
name|setFailure
parameter_list|(
specifier|final
name|String
name|source
parameter_list|,
specifier|final
name|Throwable
name|cause
parameter_list|)
block|{
name|setFailure
argument_list|(
operator|new
name|RemoteProcedureException
argument_list|(
name|source
argument_list|,
name|cause
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|protected
specifier|synchronized
name|void
name|setFailure
parameter_list|(
specifier|final
name|RemoteProcedureException
name|exception
parameter_list|)
block|{
name|this
operator|.
name|exception
operator|=
name|exception
expr_stmt|;
if|if
condition|(
operator|!
name|isFinished
argument_list|()
condition|)
block|{
name|setState
argument_list|(
name|ProcedureState
operator|.
name|FINISHED
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|setAbortFailure
parameter_list|(
specifier|final
name|String
name|source
parameter_list|,
specifier|final
name|String
name|msg
parameter_list|)
block|{
name|setFailure
argument_list|(
name|source
argument_list|,
operator|new
name|ProcedureAbortedException
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Called by the ProcedureExecutor when the timeout set by setTimeout() is expired.    * @return true to let the framework handle the timeout as abort,    *         false in case the procedure handled the timeout itself.    */
specifier|protected
specifier|synchronized
name|boolean
name|setTimeoutFailure
parameter_list|(
specifier|final
name|TEnvironment
name|env
parameter_list|)
block|{
if|if
condition|(
name|state
operator|==
name|ProcedureState
operator|.
name|WAITING_TIMEOUT
condition|)
block|{
name|long
name|timeDiff
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|-
name|lastUpdate
decl_stmt|;
name|setFailure
argument_list|(
literal|"ProcedureExecutor"
argument_list|,
operator|new
name|TimeoutIOException
argument_list|(
literal|"Operation timed out after "
operator|+
name|StringUtils
operator|.
name|humanTimeDiff
argument_list|(
name|timeDiff
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
specifier|synchronized
name|boolean
name|hasException
parameter_list|()
block|{
return|return
name|exception
operator|!=
literal|null
return|;
block|}
specifier|public
specifier|synchronized
name|RemoteProcedureException
name|getException
parameter_list|()
block|{
return|return
name|exception
return|;
block|}
comment|/**    * Called by the ProcedureExecutor on procedure-load to restore the latch state    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
specifier|synchronized
name|void
name|setChildrenLatch
parameter_list|(
specifier|final
name|int
name|numChildren
parameter_list|)
block|{
name|this
operator|.
name|childrenLatch
operator|=
name|numChildren
expr_stmt|;
block|}
comment|/**    * Called by the ProcedureExecutor on procedure-load to restore the latch state    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
specifier|synchronized
name|void
name|incChildrenLatch
parameter_list|()
block|{
comment|// TODO: can this be inferred from the stack? I think so...
name|this
operator|.
name|childrenLatch
operator|++
expr_stmt|;
block|}
comment|/**    * Called by the ProcedureExecutor to notify that one of the sub-procedures has completed.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
specifier|synchronized
name|boolean
name|childrenCountDown
parameter_list|()
block|{
assert|assert
name|childrenLatch
operator|>
literal|0
operator|:
name|this
assert|;
return|return
operator|--
name|childrenLatch
operator|==
literal|0
return|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
specifier|synchronized
name|boolean
name|hasChildren
parameter_list|()
block|{
return|return
name|childrenLatch
operator|>
literal|0
return|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
specifier|synchronized
name|int
name|getChildrenLatch
parameter_list|()
block|{
return|return
name|childrenLatch
return|;
block|}
comment|/**    * Called by the RootProcedureState on procedure execution.    * Each procedure store its stack-index positions.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
specifier|synchronized
name|void
name|addStackIndex
parameter_list|(
specifier|final
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|stackIndexes
operator|==
literal|null
condition|)
block|{
name|stackIndexes
operator|=
operator|new
name|int
index|[]
block|{
name|index
block|}
expr_stmt|;
block|}
else|else
block|{
name|int
name|count
init|=
name|stackIndexes
operator|.
name|length
decl_stmt|;
name|stackIndexes
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|stackIndexes
argument_list|,
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|stackIndexes
index|[
name|count
index|]
operator|=
name|index
expr_stmt|;
block|}
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
specifier|synchronized
name|boolean
name|removeStackIndex
parameter_list|()
block|{
if|if
condition|(
name|stackIndexes
operator|!=
literal|null
operator|&&
name|stackIndexes
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|stackIndexes
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|stackIndexes
argument_list|,
name|stackIndexes
operator|.
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
name|stackIndexes
operator|=
literal|null
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Called on store load to initialize the Procedure internals after    * the creation/deserialization.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
specifier|synchronized
name|void
name|setStackIndexes
parameter_list|(
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|stackIndexes
parameter_list|)
block|{
name|this
operator|.
name|stackIndexes
operator|=
operator|new
name|int
index|[
name|stackIndexes
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|this
operator|.
name|stackIndexes
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|this
operator|.
name|stackIndexes
index|[
name|i
index|]
operator|=
name|stackIndexes
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
specifier|synchronized
name|boolean
name|wasExecuted
parameter_list|()
block|{
return|return
name|stackIndexes
operator|!=
literal|null
return|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
specifier|synchronized
name|int
index|[]
name|getStackIndexes
parameter_list|()
block|{
return|return
name|stackIndexes
return|;
block|}
comment|// ==========================================================================
comment|//  Internal methods - called by the ProcedureExecutor
comment|// ==========================================================================
comment|/**    * Internal method called by the ProcedureExecutor that starts the user-level code execute().    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
name|Procedure
index|[]
name|doExecute
parameter_list|(
specifier|final
name|TEnvironment
name|env
parameter_list|)
throws|throws
name|ProcedureYieldException
throws|,
name|ProcedureSuspendedException
throws|,
name|InterruptedException
block|{
try|try
block|{
name|updateTimestamp
argument_list|()
expr_stmt|;
return|return
name|execute
argument_list|(
name|env
argument_list|)
return|;
block|}
finally|finally
block|{
name|updateTimestamp
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Internal method called by the ProcedureExecutor that starts the user-level code rollback().    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
name|void
name|doRollback
parameter_list|(
specifier|final
name|TEnvironment
name|env
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
try|try
block|{
name|updateTimestamp
argument_list|()
expr_stmt|;
name|rollback
argument_list|(
name|env
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|updateTimestamp
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Internal method called by the ProcedureExecutor that starts the user-level code acquireLock().    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
name|LockState
name|doAcquireLock
parameter_list|(
specifier|final
name|TEnvironment
name|env
parameter_list|)
block|{
return|return
name|acquireLock
argument_list|(
name|env
argument_list|)
return|;
block|}
comment|/**    * Internal method called by the ProcedureExecutor that starts the user-level code releaseLock().    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
name|void
name|doReleaseLock
parameter_list|(
specifier|final
name|TEnvironment
name|env
parameter_list|)
block|{
name|releaseLock
argument_list|(
name|env
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
specifier|final
name|Procedure
name|other
parameter_list|)
block|{
return|return
name|Long
operator|.
name|compare
argument_list|(
name|getProcId
argument_list|()
argument_list|,
name|other
operator|.
name|getProcId
argument_list|()
argument_list|)
return|;
block|}
comment|// ==========================================================================
comment|//  misc utils
comment|// ==========================================================================
comment|/**    * Get an hashcode for the specified Procedure ID    * @return the hashcode for the specified procId    */
specifier|public
specifier|static
name|long
name|getProcIdHashCode
parameter_list|(
specifier|final
name|long
name|procId
parameter_list|)
block|{
name|long
name|h
init|=
name|procId
decl_stmt|;
name|h
operator|^=
name|h
operator|>>
literal|16
expr_stmt|;
name|h
operator|*=
literal|0x85ebca6b
expr_stmt|;
name|h
operator|^=
name|h
operator|>>
literal|13
expr_stmt|;
name|h
operator|*=
literal|0xc2b2ae35
expr_stmt|;
name|h
operator|^=
name|h
operator|>>
literal|16
expr_stmt|;
return|return
name|h
return|;
block|}
comment|/*    * Helper to lookup the root Procedure ID given a specified procedure.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
specifier|static
name|Long
name|getRootProcedureId
parameter_list|(
specifier|final
name|Map
argument_list|<
name|Long
argument_list|,
name|Procedure
argument_list|>
name|procedures
parameter_list|,
name|Procedure
name|proc
parameter_list|)
block|{
while|while
condition|(
name|proc
operator|.
name|hasParent
argument_list|()
condition|)
block|{
name|proc
operator|=
name|procedures
operator|.
name|get
argument_list|(
name|proc
operator|.
name|getParentProcId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc
operator|==
literal|null
condition|)
return|return
literal|null
return|;
block|}
return|return
name|proc
operator|.
name|getProcId
argument_list|()
return|;
block|}
comment|/**    * @param a the first procedure to be compared.    * @param b the second procedure to be compared.    * @return true if the two procedures have the same parent    */
specifier|public
specifier|static
name|boolean
name|haveSameParent
parameter_list|(
specifier|final
name|Procedure
name|a
parameter_list|,
specifier|final
name|Procedure
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|hasParent
argument_list|()
operator|&&
name|b
operator|.
name|hasParent
argument_list|()
condition|)
block|{
return|return
name|a
operator|.
name|getParentProcId
argument_list|()
operator|==
name|b
operator|.
name|getParentProcId
argument_list|()
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
end_class

end_unit

