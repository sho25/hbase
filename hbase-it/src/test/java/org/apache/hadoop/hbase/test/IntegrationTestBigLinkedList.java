begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|test
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|SecureRandom
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadLocalRandom
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configured
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocatedFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|RemoteIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Cell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseTestingUtility
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|IntegrationTestBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|IntegrationTestingUtility
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MasterNotRunningException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Admin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|BufferedMutator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|BufferedMutatorParams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ColumnFamilyDescriptorBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ConnectionConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ConnectionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Get
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Mutation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Put
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionLocator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ResultScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Scan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|TableDescriptorBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|fs
operator|.
name|HFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|ImmutableBytesWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|mapreduce
operator|.
name|TableMapReduceUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|mapreduce
operator|.
name|TableMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|mapreduce
operator|.
name|TableRecordReaderImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|mapreduce
operator|.
name|WALPlayer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|FlushAllLargeStoresPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|FlushPolicyFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|testclassification
operator|.
name|IntegrationTests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|AbstractHBaseTool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|CommonFSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Random64
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|RegionSplitter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALEdit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|BytesWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|NullWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Counter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|CounterGroup
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Counters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|InputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|InputSplit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Job
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Mapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|RecordReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Reducer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskAttemptContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskAttemptID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|FileInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|FileSplit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|SequenceFileAsBinaryInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|SequenceFileInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|output
operator|.
name|FileOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|output
operator|.
name|NullOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|output
operator|.
name|SequenceFileAsBinaryOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|output
operator|.
name|SequenceFileOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|output
operator|.
name|TextOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|task
operator|.
name|TaskAttemptContextImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Tool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ToolRunner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|experimental
operator|.
name|categories
operator|.
name|Category
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|CommandLine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|GnuParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|HelpFormatter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|ParseException
import|;
end_import

begin_comment
comment|/**  *<p>  * This is an integration test borrowed from goraci, written by Keith Turner,  * which is in turn inspired by the Accumulo test called continous ingest (ci).  * The original source code can be found here:  *<ul>  *<li>https://github.com/keith-turner/goraci</li>  *<li>https://github.com/enis/goraci/</li>  *</ul>  *</p>  *<p>  * Apache Accumulo [0] has a simple test suite that verifies that data is not  * lost at scale. This test suite is called continuous ingest. This test runs  * many ingest clients that continually create linked lists containing 25  * million nodes. At some point the clients are stopped and a map reduce job is  * run to ensure no linked list has a hole. A hole indicates data was lost.  *</p>  *<p>  * The nodes in the linked list are random. This causes each linked list to  * spread across the table. Therefore if one part of a table loses data, then it  * will be detected by references in another part of the table.  *</p>  *<p>  *<h3>THE ANATOMY OF THE TEST</h3>  *  * Below is rough sketch of how data is written. For specific details look at  * the Generator code.  *</p>  *<p>  *<ol>  *<li>Write out 1 million nodes</li>  *<li>Flush the client</li>  *<li>Write out 1 million that reference previous million</li>  *<li>If this is the 25th set of 1 million nodes, then update 1st set of  * million to point to last</li>  *<li>goto 1</li>  *</ol>  *</p>  *<p>  * The key is that nodes only reference flushed nodes. Therefore a node should  * never reference a missing node, even if the ingest client is killed at any  * point in time.  *</p>  *<p>  * When running this test suite w/ Accumulo there is a script running in  * parallel called the Aggitator that randomly and continuously kills server  * processes. The outcome was that many data loss bugs were found in Accumulo  * by doing this. This test suite can also help find bugs that impact uptime  * and stability when run for days or weeks.  *</p>  *<p>  * This test suite consists the following  *<ul>  *<li>a few Java programs</li>  *<li>a little helper script to run the java programs</li>  *<li>a maven script to build it</li>  *</ul>  *</p>  *<p>  * When generating data, its best to have each map task generate a multiple of  * 25 million. The reason for this is that circular linked list are generated  * every 25M. Not generating a multiple in 25M will result in some nodes in the  * linked list not having references. The loss of an unreferenced node can not  * be detected.  *</p>  *<p>  *<h3>Below is a description of the Java programs</h3>  *<ul>  *<li>  * {@code Generator} - A map only job that generates data. As stated previously, its best to  * generate data in multiples of 25M. An option is also available to allow concurrent walkers to  * select and walk random flushed loops during this phase.  *</li>  *<li>  * {@code Verify} - A map reduce job that looks for holes. Look at the counts after running.  * {@code REFERENCED} and {@code UNREFERENCED} are ok, any {@code UNDEFINED} counts are bad. Do not  * run at the same time as the Generator.  *</li>  *<li>  * {@code Walker} - A standalone program that start following a linked list and emits timing info.  *</li>  *<li>  * {@code Print} - A standalone program that prints nodes in the linked list  *</li>  *<li>  * {@code Delete} - A standalone program that deletes a single node  *</li>  *</ul>  *  * This class can be run as a unit test, as an integration test, or from the command line  *</p>  *<p>  * ex:  *<pre>  * ./hbase org.apache.hadoop.hbase.test.IntegrationTestBigLinkedList  *    loop 2 1 100000 /temp 1 1000 50 1 0  *</pre>  *</p>  */
end_comment

begin_class
annotation|@
name|Category
argument_list|(
name|IntegrationTests
operator|.
name|class
argument_list|)
specifier|public
class|class
name|IntegrationTestBigLinkedList
extends|extends
name|IntegrationTestBase
block|{
specifier|protected
specifier|static
specifier|final
name|byte
index|[]
name|NO_KEY
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
specifier|protected
specifier|static
name|String
name|TABLE_NAME_KEY
init|=
literal|"IntegrationTestBigLinkedList.table"
decl_stmt|;
specifier|protected
specifier|static
name|String
name|DEFAULT_TABLE_NAME
init|=
literal|"IntegrationTestBigLinkedList"
decl_stmt|;
specifier|protected
specifier|static
name|byte
index|[]
name|FAMILY_NAME
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"meta"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|byte
index|[]
name|BIG_FAMILY_NAME
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"big"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|byte
index|[]
name|TINY_FAMILY_NAME
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"tiny"
argument_list|)
decl_stmt|;
comment|//link to the id of the prev node in the linked list
specifier|protected
specifier|static
specifier|final
name|byte
index|[]
name|COLUMN_PREV
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"prev"
argument_list|)
decl_stmt|;
comment|//identifier of the mapred task that generated this row
specifier|protected
specifier|static
specifier|final
name|byte
index|[]
name|COLUMN_CLIENT
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"client"
argument_list|)
decl_stmt|;
comment|//the id of the row within the same client.
specifier|protected
specifier|static
specifier|final
name|byte
index|[]
name|COLUMN_COUNT
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"count"
argument_list|)
decl_stmt|;
comment|/** How many rows to write per map task. This has to be a multiple of 25M */
specifier|private
specifier|static
specifier|final
name|String
name|GENERATOR_NUM_ROWS_PER_MAP_KEY
init|=
literal|"IntegrationTestBigLinkedList.generator.num_rows"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|GENERATOR_NUM_MAPPERS_KEY
init|=
literal|"IntegrationTestBigLinkedList.generator.map.tasks"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|GENERATOR_WIDTH_KEY
init|=
literal|"IntegrationTestBigLinkedList.generator.width"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|GENERATOR_WRAP_KEY
init|=
literal|"IntegrationTestBigLinkedList.generator.wrap"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|CONCURRENT_WALKER_KEY
init|=
literal|"IntegrationTestBigLinkedList.generator.concurrentwalkers"
decl_stmt|;
specifier|protected
name|int
name|NUM_SLAVES_BASE
init|=
literal|3
decl_stmt|;
comment|// number of slaves for the cluster
specifier|private
specifier|static
specifier|final
name|int
name|MISSING_ROWS_TO_LOG
init|=
literal|10
decl_stmt|;
comment|// YARN complains when too many counters
specifier|private
specifier|static
specifier|final
name|int
name|WIDTH_DEFAULT
init|=
literal|1000000
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|WRAP_DEFAULT
init|=
literal|25
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|ROWKEY_LENGTH
init|=
literal|16
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|CONCURRENT_WALKER_DEFAULT
init|=
literal|0
decl_stmt|;
specifier|protected
name|String
name|toRun
decl_stmt|;
specifier|protected
name|String
index|[]
name|otherArgs
decl_stmt|;
specifier|static
class|class
name|CINode
block|{
name|byte
index|[]
name|key
decl_stmt|;
name|byte
index|[]
name|prev
decl_stmt|;
name|String
name|client
decl_stmt|;
name|long
name|count
decl_stmt|;
block|}
comment|/**    * A Map only job that generates random linked list and stores them.    */
specifier|static
class|class
name|Generator
extends|extends
name|Configured
implements|implements
name|Tool
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|Generator
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * Set this configuration if you want to test single-column family flush works. If set, we will      * add a big column family and a small column family on either side of the usual ITBLL 'meta'      * column family. When we write out the ITBLL, we will also add to the big column family a value      * bigger than that for ITBLL and for small, something way smaller. The idea is that when      * flush-by-column family rather than by region is enabled, we can see if ITBLL is broke in any      * way. Here is how you would pass it:      *<p>      * $ ./bin/hbase org.apache.hadoop.hbase.test.IntegrationTestBigLinkedList      * -Dgenerator.multiple.columnfamilies=true generator 1 10 g      */
specifier|public
specifier|static
specifier|final
name|String
name|MULTIPLE_UNEVEN_COLUMNFAMILIES_KEY
init|=
literal|"generator.multiple.columnfamilies"
decl_stmt|;
comment|/**      * Set this configuration if you want to scale up the size of test data quickly.      *<p>      * $ ./bin/hbase org.apache.hadoop.hbase.test.IntegrationTestBigLinkedList      * -Dgenerator.big.family.value.size=1024 generator 1 10 output      */
specifier|public
specifier|static
specifier|final
name|String
name|BIG_FAMILY_VALUE_SIZE_KEY
init|=
literal|"generator.big.family.value.size"
decl_stmt|;
specifier|public
specifier|static
enum|enum
name|Counts
block|{
name|SUCCESS
block|,
name|TERMINATING
block|,
name|UNDEFINED
block|,
name|IOEXCEPTION
block|}
specifier|public
specifier|static
specifier|final
name|String
name|USAGE
init|=
literal|"Usage : "
operator|+
name|Generator
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"<num mappers><num nodes per map><tmp output dir> [<width><wrap multiplier>"
operator|+
literal|"<num walker threads>] \n"
operator|+
literal|"where<num nodes per map> should be a multiple of width*wrap multiplier, 25M by default \n"
operator|+
literal|"walkers will verify random flushed loop during Generation."
decl_stmt|;
specifier|public
name|Job
name|job
decl_stmt|;
specifier|static
class|class
name|GeneratorInputFormat
extends|extends
name|InputFormat
argument_list|<
name|BytesWritable
argument_list|,
name|NullWritable
argument_list|>
block|{
specifier|static
class|class
name|GeneratorInputSplit
extends|extends
name|InputSplit
implements|implements
name|Writable
block|{
annotation|@
name|Override
specifier|public
name|long
name|getLength
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
literal|1
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
index|[]
name|getLocations
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
operator|new
name|String
index|[
literal|0
index|]
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|arg0
parameter_list|)
throws|throws
name|IOException
block|{         }
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|arg0
parameter_list|)
throws|throws
name|IOException
block|{         }
block|}
specifier|static
class|class
name|GeneratorRecordReader
extends|extends
name|RecordReader
argument_list|<
name|BytesWritable
argument_list|,
name|NullWritable
argument_list|>
block|{
specifier|private
name|long
name|count
decl_stmt|;
specifier|private
name|long
name|numNodes
decl_stmt|;
specifier|private
name|Random64
name|rand
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{         }
annotation|@
name|Override
specifier|public
name|BytesWritable
name|getCurrentKey
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|ROWKEY_LENGTH
index|]
decl_stmt|;
name|rand
operator|.
name|nextBytes
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
return|return
operator|new
name|BytesWritable
argument_list|(
name|bytes
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|NullWritable
name|getCurrentValue
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|NullWritable
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|float
name|getProgress
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
call|(
name|float
call|)
argument_list|(
name|count
operator|/
operator|(
name|double
operator|)
name|numNodes
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|initialize
parameter_list|(
name|InputSplit
name|arg0
parameter_list|,
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|numNodes
operator|=
name|context
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getLong
argument_list|(
name|GENERATOR_NUM_ROWS_PER_MAP_KEY
argument_list|,
literal|25000000
argument_list|)
expr_stmt|;
comment|// Use Random64 to avoid issue described in HBASE-21256.
name|rand
operator|=
operator|new
name|Random64
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|nextKeyValue
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|count
operator|++
operator|<
name|numNodes
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|RecordReader
argument_list|<
name|BytesWritable
argument_list|,
name|NullWritable
argument_list|>
name|createRecordReader
parameter_list|(
name|InputSplit
name|split
parameter_list|,
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|GeneratorRecordReader
name|rr
init|=
operator|new
name|GeneratorRecordReader
argument_list|()
decl_stmt|;
name|rr
operator|.
name|initialize
argument_list|(
name|split
argument_list|,
name|context
argument_list|)
expr_stmt|;
return|return
name|rr
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|InputSplit
argument_list|>
name|getSplits
parameter_list|(
name|JobContext
name|job
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|int
name|numMappers
init|=
name|job
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|GENERATOR_NUM_MAPPERS_KEY
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|InputSplit
argument_list|>
name|splits
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|numMappers
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numMappers
condition|;
name|i
operator|++
control|)
block|{
name|splits
operator|.
name|add
argument_list|(
operator|new
name|GeneratorInputSplit
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|splits
return|;
block|}
block|}
comment|/** Ensure output files from prev-job go to map inputs for current job */
specifier|static
class|class
name|OneFilePerMapperSFIF
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|SequenceFileInputFormat
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
annotation|@
name|Override
specifier|protected
name|boolean
name|isSplitable
parameter_list|(
name|JobContext
name|context
parameter_list|,
name|Path
name|filename
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**      * Some ASCII art time:      *<p>      * [ . . . ] represents one batch of random longs of length WIDTH      *<pre>      *                _________________________      *               |                  ______ |      *               |                 |      ||      *             .-+-----------------+-----.||      *             | |                 |     |||      * first   = [ . . . . . . . . . . . ]   |||      *             ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^     |||      *             | | | | | | | | | | |     |||      * prev    = [ . . . . . . . . . . . ]   |||      *             ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^     |||      *             | | | | | | | | | | |     |||      * current = [ . . . . . . . . . . . ]   |||      *                                       |||      * ...                                   |||      *                                       |||      * last    = [ . . . . . . . . . . . ]   |||      *             ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^_____|||      *             |                 |________||      *             |___________________________|      *</pre>      */
specifier|static
class|class
name|GeneratorMapper
extends|extends
name|Mapper
argument_list|<
name|BytesWritable
argument_list|,
name|NullWritable
argument_list|,
name|NullWritable
argument_list|,
name|NullWritable
argument_list|>
block|{
name|byte
index|[]
index|[]
name|first
init|=
literal|null
decl_stmt|;
name|byte
index|[]
index|[]
name|prev
init|=
literal|null
decl_stmt|;
name|byte
index|[]
index|[]
name|current
init|=
literal|null
decl_stmt|;
name|byte
index|[]
name|id
decl_stmt|;
name|long
name|count
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|BufferedMutator
name|mutator
decl_stmt|;
name|Connection
name|connection
decl_stmt|;
name|long
name|numNodes
decl_stmt|;
name|long
name|wrap
decl_stmt|;
name|int
name|width
decl_stmt|;
name|boolean
name|multipleUnevenColumnFamilies
decl_stmt|;
name|byte
index|[]
name|tinyValue
init|=
operator|new
name|byte
index|[]
block|{
literal|'t'
block|}
decl_stmt|;
name|byte
index|[]
name|bigValue
init|=
literal|null
decl_stmt|;
name|Configuration
name|conf
decl_stmt|;
specifier|volatile
name|boolean
name|walkersStop
decl_stmt|;
name|int
name|numWalkers
decl_stmt|;
specifier|volatile
name|List
argument_list|<
name|Long
argument_list|>
name|flushedLoops
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Thread
argument_list|>
name|walkers
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|protected
name|void
name|setup
parameter_list|(
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|id
operator|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"Job: "
operator|+
name|context
operator|.
name|getJobID
argument_list|()
operator|+
literal|" Task: "
operator|+
name|context
operator|.
name|getTaskAttemptID
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|connection
operator|=
name|ConnectionFactory
operator|.
name|createConnection
argument_list|(
name|context
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
name|instantiateHTable
argument_list|()
expr_stmt|;
name|this
operator|.
name|width
operator|=
name|context
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|GENERATOR_WIDTH_KEY
argument_list|,
name|WIDTH_DEFAULT
argument_list|)
expr_stmt|;
name|current
operator|=
operator|new
name|byte
index|[
name|this
operator|.
name|width
index|]
index|[]
expr_stmt|;
name|int
name|wrapMultiplier
init|=
name|context
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|GENERATOR_WRAP_KEY
argument_list|,
name|WRAP_DEFAULT
argument_list|)
decl_stmt|;
name|this
operator|.
name|wrap
operator|=
operator|(
name|long
operator|)
name|wrapMultiplier
operator|*
name|width
expr_stmt|;
name|this
operator|.
name|numNodes
operator|=
name|context
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getLong
argument_list|(
name|GENERATOR_NUM_ROWS_PER_MAP_KEY
argument_list|,
operator|(
name|long
operator|)
name|WIDTH_DEFAULT
operator|*
name|WRAP_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|numNodes
operator|<
name|this
operator|.
name|wrap
condition|)
block|{
name|this
operator|.
name|wrap
operator|=
name|this
operator|.
name|numNodes
expr_stmt|;
block|}
name|this
operator|.
name|multipleUnevenColumnFamilies
operator|=
name|isMultiUnevenColumnFamilies
argument_list|(
name|context
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|numWalkers
operator|=
name|context
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|CONCURRENT_WALKER_KEY
argument_list|,
name|CONCURRENT_WALKER_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|walkersStop
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|context
operator|.
name|getConfiguration
argument_list|()
expr_stmt|;
if|if
condition|(
name|multipleUnevenColumnFamilies
condition|)
block|{
name|int
name|n
init|=
name|context
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|BIG_FAMILY_VALUE_SIZE_KEY
argument_list|,
literal|256
argument_list|)
decl_stmt|;
name|int
name|limit
init|=
name|context
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|ConnectionConfiguration
operator|.
name|MAX_KEYVALUE_SIZE_KEY
argument_list|,
name|ConnectionConfiguration
operator|.
name|MAX_KEYVALUE_SIZE_DEFAULT
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|n
operator|<=
name|limit
argument_list|,
literal|"%s(%s)> %s(%s)"
argument_list|,
name|BIG_FAMILY_VALUE_SIZE_KEY
argument_list|,
name|n
argument_list|,
name|ConnectionConfiguration
operator|.
name|MAX_KEYVALUE_SIZE_KEY
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|bigValue
operator|=
operator|new
name|byte
index|[
name|n
index|]
expr_stmt|;
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextBytes
argument_list|(
name|bigValue
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Create a bigValue with "
operator|+
name|n
operator|+
literal|" bytes."
argument_list|)
expr_stmt|;
block|}
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|numNodes
operator|>
literal|0
argument_list|,
literal|"numNodes(%s)<= 0"
argument_list|,
name|numNodes
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|numNodes
operator|%
name|width
operator|==
literal|0
argument_list|,
literal|"numNodes(%s) mod width(%s) != 0"
argument_list|,
name|numNodes
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|numNodes
operator|%
name|wrap
operator|==
literal|0
argument_list|,
literal|"numNodes(%s) mod wrap(%s) != 0"
argument_list|,
name|numNodes
argument_list|,
name|wrap
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|instantiateHTable
parameter_list|()
throws|throws
name|IOException
block|{
name|mutator
operator|=
name|connection
operator|.
name|getBufferedMutator
argument_list|(
operator|new
name|BufferedMutatorParams
argument_list|(
name|getTableName
argument_list|(
name|connection
operator|.
name|getConfiguration
argument_list|()
argument_list|)
argument_list|)
operator|.
name|writeBufferSize
argument_list|(
literal|4
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|cleanup
parameter_list|(
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|joinWalkers
argument_list|()
expr_stmt|;
name|mutator
operator|.
name|close
argument_list|()
expr_stmt|;
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|map
parameter_list|(
name|BytesWritable
name|key
parameter_list|,
name|NullWritable
name|value
parameter_list|,
name|Context
name|output
parameter_list|)
throws|throws
name|IOException
block|{
name|current
index|[
name|i
index|]
operator|=
operator|new
name|byte
index|[
name|key
operator|.
name|getLength
argument_list|()
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|key
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|current
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|current
operator|.
name|length
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Persisting current.length={}, count={}, id={}, current={}, i="
argument_list|,
name|current
operator|.
name|length
argument_list|,
name|count
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|id
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|current
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|persist
argument_list|(
name|output
argument_list|,
name|count
argument_list|,
name|prev
argument_list|,
name|current
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|first
operator|==
literal|null
condition|)
block|{
name|first
operator|=
name|current
expr_stmt|;
block|}
name|prev
operator|=
name|current
expr_stmt|;
name|current
operator|=
operator|new
name|byte
index|[
name|this
operator|.
name|width
index|]
index|[]
expr_stmt|;
name|count
operator|+=
name|current
operator|.
name|length
expr_stmt|;
name|output
operator|.
name|setStatus
argument_list|(
literal|"Count "
operator|+
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|%
name|wrap
operator|==
literal|0
condition|)
block|{
comment|// this block of code turns the 1 million linked list of length 25 into one giant
comment|//circular linked list of 25 million
name|circularLeftShift
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|persist
argument_list|(
name|output
argument_list|,
operator|-
literal|1
argument_list|,
name|prev
argument_list|,
name|first
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// At this point the entire loop has been flushed so we can add one of its nodes to the
comment|// concurrent walker
if|if
condition|(
name|numWalkers
operator|>
literal|0
condition|)
block|{
name|addFlushed
argument_list|(
name|key
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|walkers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|startWalkers
argument_list|(
name|numWalkers
argument_list|,
name|conf
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
block|}
name|first
operator|=
literal|null
expr_stmt|;
name|prev
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|void
name|circularLeftShift
parameter_list|(
name|T
index|[]
name|first
parameter_list|)
block|{
name|T
name|ez
init|=
name|first
index|[
literal|0
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|first
argument_list|,
literal|1
argument_list|,
name|first
argument_list|,
literal|0
argument_list|,
name|first
operator|.
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
name|first
index|[
name|first
operator|.
name|length
operator|-
literal|1
index|]
operator|=
name|ez
expr_stmt|;
block|}
specifier|private
name|void
name|addFlushed
parameter_list|(
name|byte
index|[]
name|rowKey
parameter_list|)
block|{
synchronized|synchronized
init|(
name|flushedLoops
init|)
block|{
name|flushedLoops
operator|.
name|add
argument_list|(
name|Bytes
operator|.
name|toLong
argument_list|(
name|rowKey
argument_list|)
argument_list|)
expr_stmt|;
name|flushedLoops
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|persist
parameter_list|(
name|Context
name|output
parameter_list|,
name|long
name|count
parameter_list|,
name|byte
index|[]
index|[]
name|prev
parameter_list|,
name|byte
index|[]
index|[]
name|current
parameter_list|,
name|byte
index|[]
name|id
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|current
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|100
operator|==
literal|0
condition|)
block|{
comment|// Tickle progress every so often else maprunner will think us hung
name|output
operator|.
name|progress
argument_list|()
expr_stmt|;
block|}
name|Put
name|put
init|=
operator|new
name|Put
argument_list|(
name|current
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|put
operator|.
name|addColumn
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_PREV
argument_list|,
name|prev
operator|==
literal|null
condition|?
name|NO_KEY
else|:
name|prev
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
literal|0
condition|)
block|{
name|put
operator|.
name|addColumn
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_COUNT
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|count
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|id
operator|!=
literal|null
condition|)
block|{
name|put
operator|.
name|addColumn
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_CLIENT
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
comment|// See if we are to write multiple columns.
if|if
condition|(
name|this
operator|.
name|multipleUnevenColumnFamilies
condition|)
block|{
comment|// Use any column name.
name|put
operator|.
name|addColumn
argument_list|(
name|TINY_FAMILY_NAME
argument_list|,
name|TINY_FAMILY_NAME
argument_list|,
name|this
operator|.
name|tinyValue
argument_list|)
expr_stmt|;
comment|// Use any column name.
name|put
operator|.
name|addColumn
argument_list|(
name|BIG_FAMILY_NAME
argument_list|,
name|BIG_FAMILY_NAME
argument_list|,
name|this
operator|.
name|bigValue
argument_list|)
expr_stmt|;
block|}
name|mutator
operator|.
name|mutate
argument_list|(
name|put
argument_list|)
expr_stmt|;
block|}
name|mutator
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|startWalkers
parameter_list|(
name|int
name|numWalkers
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Context
name|context
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting "
operator|+
name|numWalkers
operator|+
literal|" concurrent walkers"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numWalkers
condition|;
name|i
operator|++
control|)
block|{
name|Thread
name|walker
init|=
operator|new
name|Thread
argument_list|(
operator|new
name|ContinuousConcurrentWalker
argument_list|(
name|conf
argument_list|,
name|context
argument_list|)
argument_list|)
decl_stmt|;
name|walker
operator|.
name|start
argument_list|()
expr_stmt|;
name|walkers
operator|.
name|add
argument_list|(
name|walker
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|joinWalkers
parameter_list|()
block|{
name|walkersStop
operator|=
literal|true
expr_stmt|;
synchronized|synchronized
init|(
name|flushedLoops
init|)
block|{
name|flushedLoops
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Thread
name|walker
range|:
name|walkers
control|)
block|{
try|try
block|{
name|walker
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// no-op
block|}
block|}
block|}
comment|/**        * Randomly selects and walks a random flushed loop concurrently with the Generator Mapper by        * spawning ConcurrentWalker's with specified StartNodes. These ConcurrentWalker's are        * configured to only log erroneous nodes.        */
specifier|public
class|class
name|ContinuousConcurrentWalker
implements|implements
name|Runnable
block|{
name|ConcurrentWalker
name|walker
decl_stmt|;
name|Configuration
name|conf
decl_stmt|;
name|Context
name|context
decl_stmt|;
name|Random
name|rand
decl_stmt|;
specifier|public
name|ContinuousConcurrentWalker
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Context
name|context
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|rand
operator|=
operator|new
name|Random
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
operator|!
name|walkersStop
condition|)
block|{
try|try
block|{
name|long
name|node
init|=
name|selectLoop
argument_list|()
decl_stmt|;
try|try
block|{
name|walkLoop
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|context
operator|.
name|getCounter
argument_list|(
name|Counts
operator|.
name|IOEXCEPTION
argument_list|)
operator|.
name|increment
argument_list|(
literal|1l
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
return|return;
block|}
block|}
block|}
specifier|private
name|void
name|walkLoop
parameter_list|(
name|long
name|node
parameter_list|)
throws|throws
name|IOException
block|{
name|walker
operator|=
operator|new
name|ConcurrentWalker
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|walker
operator|.
name|setConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|walker
operator|.
name|run
argument_list|(
name|node
argument_list|,
name|wrap
argument_list|)
expr_stmt|;
block|}
specifier|private
name|long
name|selectLoop
parameter_list|()
throws|throws
name|InterruptedException
block|{
synchronized|synchronized
init|(
name|flushedLoops
init|)
block|{
while|while
condition|(
name|flushedLoops
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|walkersStop
condition|)
block|{
name|flushedLoops
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|walkersStop
condition|)
block|{
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
return|return
name|flushedLoops
operator|.
name|get
argument_list|(
name|rand
operator|.
name|nextInt
argument_list|(
name|flushedLoops
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
specifier|public
specifier|static
class|class
name|ConcurrentWalker
extends|extends
name|WalkerBase
block|{
name|Context
name|context
decl_stmt|;
specifier|public
name|ConcurrentWalker
parameter_list|(
name|Context
name|context
parameter_list|)
block|{
name|this
operator|.
name|context
operator|=
name|context
expr_stmt|;
block|}
specifier|public
name|void
name|run
parameter_list|(
name|long
name|startKeyIn
parameter_list|,
name|long
name|maxQueriesIn
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|maxQueries
init|=
name|maxQueriesIn
operator|>
literal|0
condition|?
name|maxQueriesIn
else|:
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
name|byte
index|[]
name|startKey
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|startKeyIn
argument_list|)
decl_stmt|;
name|Connection
name|connection
init|=
name|ConnectionFactory
operator|.
name|createConnection
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|Table
name|table
init|=
name|connection
operator|.
name|getTable
argument_list|(
name|getTableName
argument_list|(
name|getConf
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|numQueries
init|=
literal|0
decl_stmt|;
comment|// If isSpecificStart is set, only walk one list from that particular node.
comment|// Note that in case of circular (or P-shaped) list it will walk forever, as is
comment|// the case in normal run without startKey.
name|CINode
name|node
init|=
name|findStartNode
argument_list|(
name|table
argument_list|,
name|startKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Start node not found: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|startKey
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Start node not found: "
operator|+
name|startKeyIn
argument_list|)
throw|;
block|}
while|while
condition|(
name|numQueries
operator|<
name|maxQueries
condition|)
block|{
name|numQueries
operator|++
expr_stmt|;
name|byte
index|[]
name|prev
init|=
name|node
operator|.
name|prev
decl_stmt|;
name|long
name|t1
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|node
operator|=
name|getNode
argument_list|(
name|prev
argument_list|,
name|table
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|long
name|t2
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"ConcurrentWalker found UNDEFINED NODE: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|prev
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|getCounter
argument_list|(
name|Counts
operator|.
name|UNDEFINED
argument_list|)
operator|.
name|increment
argument_list|(
literal|1l
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|prev
operator|.
name|length
operator|==
name|NO_KEY
operator|.
name|length
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"ConcurrentWalker found TERMINATING NODE: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|node
operator|.
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|getCounter
argument_list|(
name|Counts
operator|.
name|TERMINATING
argument_list|)
operator|.
name|increment
argument_list|(
literal|1l
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Increment for successful walk
name|context
operator|.
name|getCounter
argument_list|(
name|Counts
operator|.
name|SUCCESS
argument_list|)
operator|.
name|increment
argument_list|(
literal|1l
argument_list|)
expr_stmt|;
block|}
block|}
name|table
operator|.
name|close
argument_list|()
expr_stmt|;
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|args
operator|.
name|length
operator|<
literal|3
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|USAGE
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
try|try
block|{
name|int
name|numMappers
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|long
name|numNodes
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|Path
name|tmpOutput
init|=
operator|new
name|Path
argument_list|(
name|args
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|Integer
name|width
init|=
operator|(
name|args
operator|.
name|length
operator|<
literal|4
operator|)
condition|?
literal|null
else|:
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
name|Integer
name|wrapMultiplier
init|=
operator|(
name|args
operator|.
name|length
operator|<
literal|5
operator|)
condition|?
literal|null
else|:
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|4
index|]
argument_list|)
decl_stmt|;
name|Integer
name|numWalkers
init|=
operator|(
name|args
operator|.
name|length
operator|<
literal|6
operator|)
condition|?
literal|null
else|:
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|5
index|]
argument_list|)
decl_stmt|;
return|return
name|run
argument_list|(
name|numMappers
argument_list|,
name|numNodes
argument_list|,
name|tmpOutput
argument_list|,
name|width
argument_list|,
name|wrapMultiplier
argument_list|,
name|numWalkers
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Parsing generator arguments failed: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|USAGE
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
specifier|protected
name|void
name|createSchema
parameter_list|()
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|TableName
name|tableName
init|=
name|getTableName
argument_list|(
name|conf
argument_list|)
decl_stmt|;
try|try
init|(
name|Connection
name|conn
init|=
name|ConnectionFactory
operator|.
name|createConnection
argument_list|(
name|conf
argument_list|)
init|;
name|Admin
name|admin
operator|=
name|conn
operator|.
name|getAdmin
argument_list|()
init|)
block|{
if|if
condition|(
operator|!
name|admin
operator|.
name|tableExists
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|TableDescriptorBuilder
operator|.
name|ModifyableTableDescriptor
name|tableDescriptor
init|=
operator|new
name|TableDescriptorBuilder
operator|.
name|ModifyableTableDescriptor
argument_list|(
name|getTableName
argument_list|(
name|getConf
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|ColumnFamilyDescriptorBuilder
operator|.
name|ModifyableColumnFamilyDescriptor
name|familyDescriptor
init|=
operator|new
name|ColumnFamilyDescriptorBuilder
operator|.
name|ModifyableColumnFamilyDescriptor
argument_list|(
name|FAMILY_NAME
argument_list|)
decl_stmt|;
comment|// if -DuseMob=true force all data through mob path.
name|setMobProperties
argument_list|(
name|conf
argument_list|,
name|familyDescriptor
argument_list|)
expr_stmt|;
name|tableDescriptor
operator|.
name|setColumnFamily
argument_list|(
name|familyDescriptor
argument_list|)
expr_stmt|;
comment|// Always add these families. Just skip writing to them when we do not test per CF flush.
name|familyDescriptor
operator|=
operator|new
name|ColumnFamilyDescriptorBuilder
operator|.
name|ModifyableColumnFamilyDescriptor
argument_list|(
name|BIG_FAMILY_NAME
argument_list|)
expr_stmt|;
name|setMobProperties
argument_list|(
name|conf
argument_list|,
name|familyDescriptor
argument_list|)
expr_stmt|;
name|tableDescriptor
operator|.
name|setColumnFamily
argument_list|(
name|familyDescriptor
argument_list|)
expr_stmt|;
name|familyDescriptor
operator|=
operator|new
name|ColumnFamilyDescriptorBuilder
operator|.
name|ModifyableColumnFamilyDescriptor
argument_list|(
name|TINY_FAMILY_NAME
argument_list|)
expr_stmt|;
name|setMobProperties
argument_list|(
name|conf
argument_list|,
name|familyDescriptor
argument_list|)
expr_stmt|;
name|tableDescriptor
operator|.
name|setColumnFamily
argument_list|(
name|familyDescriptor
argument_list|)
expr_stmt|;
comment|// If we want to pre-split compute how many splits.
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|HBaseTestingUtility
operator|.
name|PRESPLIT_TEST_TABLE_KEY
argument_list|,
name|HBaseTestingUtility
operator|.
name|PRESPLIT_TEST_TABLE
argument_list|)
condition|)
block|{
name|int
name|numberOfServers
init|=
name|admin
operator|.
name|getRegionServers
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|numberOfServers
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"No live regionservers"
argument_list|)
throw|;
block|}
name|int
name|regionsPerServer
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|HBaseTestingUtility
operator|.
name|REGIONS_PER_SERVER_KEY
argument_list|,
name|HBaseTestingUtility
operator|.
name|DEFAULT_REGIONS_PER_SERVER
argument_list|)
decl_stmt|;
name|int
name|totalNumberOfRegions
init|=
name|numberOfServers
operator|*
name|regionsPerServer
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Number of live regionservers: "
operator|+
name|numberOfServers
operator|+
literal|", "
operator|+
literal|"pre-splitting table into "
operator|+
name|totalNumberOfRegions
operator|+
literal|" regions "
operator|+
literal|"(default regions per server: "
operator|+
name|regionsPerServer
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|byte
index|[]
index|[]
name|splits
init|=
operator|new
name|RegionSplitter
operator|.
name|UniformSplit
argument_list|()
operator|.
name|split
argument_list|(
name|totalNumberOfRegions
argument_list|)
decl_stmt|;
name|admin
operator|.
name|createTable
argument_list|(
name|tableDescriptor
argument_list|,
name|splits
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Looks like we're just letting things play out.
comment|// Create a table with on region by default.
comment|// This will make the splitting work hard.
name|admin
operator|.
name|createTable
argument_list|(
name|tableDescriptor
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|MasterNotRunningException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Master not running"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|public
name|int
name|runRandomInputGenerator
parameter_list|(
name|int
name|numMappers
parameter_list|,
name|long
name|numNodes
parameter_list|,
name|Path
name|tmpOutput
parameter_list|,
name|Integer
name|width
parameter_list|,
name|Integer
name|wrapMultiplier
parameter_list|,
name|Integer
name|numWalkers
parameter_list|)
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Running RandomInputGenerator with numMappers="
operator|+
name|numMappers
operator|+
literal|", numNodes="
operator|+
name|numNodes
argument_list|)
expr_stmt|;
name|Job
name|job
init|=
name|Job
operator|.
name|getInstance
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|job
operator|.
name|setJobName
argument_list|(
literal|"Random Input Generator"
argument_list|)
expr_stmt|;
name|job
operator|.
name|setNumReduceTasks
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|job
operator|.
name|setJarByClass
argument_list|(
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|job
operator|.
name|setInputFormatClass
argument_list|(
name|GeneratorInputFormat
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputKeyClass
argument_list|(
name|BytesWritable
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputValueClass
argument_list|(
name|NullWritable
operator|.
name|class
argument_list|)
expr_stmt|;
name|setJobConf
argument_list|(
name|job
argument_list|,
name|numMappers
argument_list|,
name|numNodes
argument_list|,
name|width
argument_list|,
name|wrapMultiplier
argument_list|,
name|numWalkers
argument_list|)
expr_stmt|;
name|job
operator|.
name|setMapperClass
argument_list|(
name|Mapper
operator|.
name|class
argument_list|)
expr_stmt|;
comment|//identity mapper
name|FileOutputFormat
operator|.
name|setOutputPath
argument_list|(
name|job
argument_list|,
name|tmpOutput
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputFormatClass
argument_list|(
name|SequenceFileOutputFormat
operator|.
name|class
argument_list|)
expr_stmt|;
name|TableMapReduceUtil
operator|.
name|addDependencyJarsForClasses
argument_list|(
name|job
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|Random64
operator|.
name|class
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
name|jobCompletion
argument_list|(
name|job
argument_list|)
decl_stmt|;
return|return
name|success
condition|?
literal|0
else|:
literal|1
return|;
block|}
specifier|public
name|int
name|runGenerator
parameter_list|(
name|int
name|numMappers
parameter_list|,
name|long
name|numNodes
parameter_list|,
name|Path
name|tmpOutput
parameter_list|,
name|Integer
name|width
parameter_list|,
name|Integer
name|wrapMultiplier
parameter_list|,
name|Integer
name|numWalkers
parameter_list|)
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Running Generator with numMappers="
operator|+
name|numMappers
operator|+
literal|", numNodes="
operator|+
name|numNodes
argument_list|)
expr_stmt|;
name|createSchema
argument_list|()
expr_stmt|;
name|job
operator|=
name|Job
operator|.
name|getInstance
argument_list|(
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
name|job
operator|.
name|setJobName
argument_list|(
literal|"Link Generator"
argument_list|)
expr_stmt|;
name|job
operator|.
name|setNumReduceTasks
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|job
operator|.
name|setJarByClass
argument_list|(
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|tmpOutput
argument_list|)
expr_stmt|;
name|job
operator|.
name|setInputFormatClass
argument_list|(
name|OneFilePerMapperSFIF
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputKeyClass
argument_list|(
name|NullWritable
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputValueClass
argument_list|(
name|NullWritable
operator|.
name|class
argument_list|)
expr_stmt|;
name|setJobConf
argument_list|(
name|job
argument_list|,
name|numMappers
argument_list|,
name|numNodes
argument_list|,
name|width
argument_list|,
name|wrapMultiplier
argument_list|,
name|numWalkers
argument_list|)
expr_stmt|;
name|setMapperForGenerator
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputFormatClass
argument_list|(
name|NullOutputFormat
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|getConfiguration
argument_list|()
operator|.
name|setBoolean
argument_list|(
literal|"mapreduce.map.speculative"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|TableMapReduceUtil
operator|.
name|addDependencyJars
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|TableMapReduceUtil
operator|.
name|addDependencyJarsForClasses
argument_list|(
name|job
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|AbstractHBaseTool
operator|.
name|class
argument_list|)
expr_stmt|;
name|TableMapReduceUtil
operator|.
name|initCredentials
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
name|jobCompletion
argument_list|(
name|job
argument_list|)
decl_stmt|;
return|return
name|success
condition|?
literal|0
else|:
literal|1
return|;
block|}
specifier|protected
name|boolean
name|jobCompletion
parameter_list|(
name|Job
name|job
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|ClassNotFoundException
block|{
name|boolean
name|success
init|=
name|job
operator|.
name|waitForCompletion
argument_list|(
literal|true
argument_list|)
decl_stmt|;
return|return
name|success
return|;
block|}
specifier|protected
name|void
name|setMapperForGenerator
parameter_list|(
name|Job
name|job
parameter_list|)
block|{
name|job
operator|.
name|setMapperClass
argument_list|(
name|GeneratorMapper
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
name|run
parameter_list|(
name|int
name|numMappers
parameter_list|,
name|long
name|numNodes
parameter_list|,
name|Path
name|tmpOutput
parameter_list|,
name|Integer
name|width
parameter_list|,
name|Integer
name|wrapMultiplier
parameter_list|,
name|Integer
name|numWalkers
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|ret
init|=
name|runRandomInputGenerator
argument_list|(
name|numMappers
argument_list|,
name|numNodes
argument_list|,
name|tmpOutput
argument_list|,
name|width
argument_list|,
name|wrapMultiplier
argument_list|,
name|numWalkers
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
return|return
name|ret
return|;
block|}
return|return
name|runGenerator
argument_list|(
name|numMappers
argument_list|,
name|numNodes
argument_list|,
name|tmpOutput
argument_list|,
name|width
argument_list|,
name|wrapMultiplier
argument_list|,
name|numWalkers
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|verify
parameter_list|()
block|{
try|try
block|{
name|Counters
name|counters
init|=
name|job
operator|.
name|getCounters
argument_list|()
decl_stmt|;
if|if
condition|(
name|counters
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Counters object was null, Generator verification cannot be performed."
operator|+
literal|" This is commonly a result of insufficient YARN configuration."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|counters
operator|.
name|findCounter
argument_list|(
name|Counts
operator|.
name|TERMINATING
argument_list|)
operator|.
name|getValue
argument_list|()
operator|>
literal|0
operator|||
name|counters
operator|.
name|findCounter
argument_list|(
name|Counts
operator|.
name|UNDEFINED
argument_list|)
operator|.
name|getValue
argument_list|()
operator|>
literal|0
operator|||
name|counters
operator|.
name|findCounter
argument_list|(
name|Counts
operator|.
name|IOEXCEPTION
argument_list|)
operator|.
name|getValue
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Concurrent walker failed to verify during Generation phase"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"TERMINATING nodes: "
operator|+
name|counters
operator|.
name|findCounter
argument_list|(
name|Counts
operator|.
name|TERMINATING
argument_list|)
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"UNDEFINED nodes: "
operator|+
name|counters
operator|.
name|findCounter
argument_list|(
name|Counts
operator|.
name|UNDEFINED
argument_list|)
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"IOEXCEPTION nodes: "
operator|+
name|counters
operator|.
name|findCounter
argument_list|(
name|Counts
operator|.
name|IOEXCEPTION
argument_list|)
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Generator verification could not find counter"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
specifier|private
specifier|static
name|void
name|setMobProperties
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|ColumnFamilyDescriptorBuilder
operator|.
name|ModifyableColumnFamilyDescriptor
name|familyDescriptor
parameter_list|)
block|{
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"useMob"
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|familyDescriptor
operator|.
name|setMobEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|familyDescriptor
operator|.
name|setMobThreshold
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Tool to search missing rows in WALs and hfiles.    * Pass in file or dir of keys to search for. Key file must have been written by Verify step    * (we depend on the format it writes out. We'll read them in and then search in hbase    * WALs and oldWALs dirs (Some of this is TODO).    */
specifier|static
class|class
name|Search
extends|extends
name|Configured
implements|implements
name|Tool
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|Search
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|protected
name|Job
name|job
decl_stmt|;
specifier|private
specifier|static
name|void
name|printUsage
parameter_list|(
specifier|final
name|String
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
operator|!=
literal|null
operator|&&
name|error
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"ERROR: "
operator|+
name|error
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Usage: search<KEYS_DIR> [<MAPPERS_COUNT>]"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|args
operator|.
name|length
argument_list|<
literal|1
operator|||
name|args
operator|.
name|length
argument_list|>
literal|2
condition|)
block|{
name|printUsage
argument_list|(
literal|null
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|Path
name|inputDir
init|=
operator|new
name|Path
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|numMappers
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|numMappers
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|run
argument_list|(
name|inputDir
argument_list|,
name|numMappers
argument_list|)
return|;
block|}
comment|/**      * WALPlayer override that searches for keys loaded in the setup.      */
specifier|public
specifier|static
class|class
name|WALSearcher
extends|extends
name|WALPlayer
block|{
specifier|public
name|WALSearcher
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**        * The actual searcher mapper.        */
specifier|public
specifier|static
class|class
name|WALMapperSearcher
extends|extends
name|WALMapper
block|{
specifier|private
name|SortedSet
argument_list|<
name|byte
index|[]
argument_list|>
name|keysToFind
decl_stmt|;
specifier|private
name|AtomicInteger
name|rows
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|setup
parameter_list|(
name|Mapper
argument_list|<
name|WALKey
argument_list|,
name|WALEdit
argument_list|,
name|ImmutableBytesWritable
argument_list|,
name|Mutation
argument_list|>
operator|.
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|setup
argument_list|(
name|context
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|keysToFind
operator|=
name|readKeysToSearch
argument_list|(
name|context
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Loaded keys to find: count="
operator|+
name|this
operator|.
name|keysToFind
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InterruptedIOException
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|filter
parameter_list|(
name|Context
name|context
parameter_list|,
name|Cell
name|cell
parameter_list|)
block|{
comment|// TODO: Can I do a better compare than this copying out key?
name|byte
index|[]
name|row
init|=
operator|new
name|byte
index|[
name|cell
operator|.
name|getRowLength
argument_list|()
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|cell
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|row
argument_list|,
literal|0
argument_list|,
name|cell
operator|.
name|getRowLength
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|b
init|=
name|this
operator|.
name|keysToFind
operator|.
name|contains
argument_list|(
name|row
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
condition|)
block|{
name|String
name|keyStr
init|=
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|row
argument_list|)
decl_stmt|;
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Found cell="
operator|+
name|cell
operator|+
literal|" , walKey="
operator|+
name|context
operator|.
name|getCurrentKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rows
operator|.
name|addAndGet
argument_list|(
literal|1
argument_list|)
operator|<
name|MISSING_ROWS_TO_LOG
condition|)
block|{
name|context
operator|.
name|getCounter
argument_list|(
name|FOUND_GROUP_KEY
argument_list|,
name|keyStr
argument_list|)
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|context
operator|.
name|getCounter
argument_list|(
name|FOUND_GROUP_KEY
argument_list|,
literal|"CELL_WITH_MISSING_ROW"
argument_list|)
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
block|}
comment|// Put in place the above WALMapperSearcher.
annotation|@
name|Override
specifier|public
name|Job
name|createSubmittableJob
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|IOException
block|{
name|Job
name|job
init|=
name|super
operator|.
name|createSubmittableJob
argument_list|(
name|args
argument_list|)
decl_stmt|;
comment|// Call my class instead.
name|job
operator|.
name|setJarByClass
argument_list|(
name|WALMapperSearcher
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setMapperClass
argument_list|(
name|WALMapperSearcher
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputFormatClass
argument_list|(
name|NullOutputFormat
operator|.
name|class
argument_list|)
expr_stmt|;
return|return
name|job
return|;
block|}
block|}
specifier|static
specifier|final
name|String
name|FOUND_GROUP_KEY
init|=
literal|"Found"
decl_stmt|;
specifier|static
specifier|final
name|String
name|SEARCHER_INPUTDIR_KEY
init|=
literal|"searcher.keys.inputdir"
decl_stmt|;
specifier|public
name|int
name|run
parameter_list|(
name|Path
name|inputDir
parameter_list|,
name|int
name|numMappers
parameter_list|)
throws|throws
name|Exception
block|{
name|getConf
argument_list|()
operator|.
name|set
argument_list|(
name|SEARCHER_INPUTDIR_KEY
argument_list|,
name|inputDir
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|SortedSet
argument_list|<
name|byte
index|[]
argument_list|>
name|keys
init|=
name|readKeysToSearch
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|keys
operator|.
name|isEmpty
argument_list|()
condition|)
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"No keys to find"
argument_list|)
throw|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Count of keys to find: "
operator|+
name|keys
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|byte
index|[]
name|key
range|:
name|keys
control|)
name|LOG
operator|.
name|info
argument_list|(
literal|"Key: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
comment|// Now read all WALs. In two dirs. Presumes certain layout.
name|Path
name|walsDir
init|=
operator|new
name|Path
argument_list|(
name|CommonFSUtils
operator|.
name|getWALRootDir
argument_list|(
name|getConf
argument_list|()
argument_list|)
argument_list|,
name|HConstants
operator|.
name|HREGION_LOGDIR_NAME
argument_list|)
decl_stmt|;
name|Path
name|oldWalsDir
init|=
operator|new
name|Path
argument_list|(
name|CommonFSUtils
operator|.
name|getWALRootDir
argument_list|(
name|getConf
argument_list|()
argument_list|)
argument_list|,
name|HConstants
operator|.
name|HREGION_OLDLOGDIR_NAME
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Running Search with keys inputDir="
operator|+
name|inputDir
operator|+
literal|", numMappers="
operator|+
name|numMappers
operator|+
literal|" against "
operator|+
name|getConf
argument_list|()
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|HBASE_DIR
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|ret
init|=
name|ToolRunner
operator|.
name|run
argument_list|(
name|getConf
argument_list|()
argument_list|,
operator|new
name|WALSearcher
argument_list|(
name|getConf
argument_list|()
argument_list|)
argument_list|,
operator|new
name|String
index|[]
block|{
name|walsDir
operator|.
name|toString
argument_list|()
block|,
literal|""
block|}
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
return|return
name|ret
return|;
block|}
return|return
name|ToolRunner
operator|.
name|run
argument_list|(
name|getConf
argument_list|()
argument_list|,
operator|new
name|WALSearcher
argument_list|(
name|getConf
argument_list|()
argument_list|)
argument_list|,
operator|new
name|String
index|[]
block|{
name|oldWalsDir
operator|.
name|toString
argument_list|()
block|,
literal|""
block|}
argument_list|)
return|;
block|}
specifier|static
name|SortedSet
argument_list|<
name|byte
index|[]
argument_list|>
name|readKeysToSearch
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|Path
name|keysInputDir
init|=
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|SEARCHER_INPUTDIR_KEY
argument_list|)
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|SortedSet
argument_list|<
name|byte
index|[]
argument_list|>
name|result
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|keysInputDir
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|keysInputDir
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|fs
operator|.
name|isDirectory
argument_list|(
name|keysInputDir
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"TODO"
argument_list|)
throw|;
block|}
else|else
block|{
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|iterator
init|=
name|fs
operator|.
name|listFiles
argument_list|(
name|keysInputDir
argument_list|,
literal|false
argument_list|)
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|LocatedFileStatus
name|keyFileStatus
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// Skip "_SUCCESS" file.
if|if
condition|(
name|keyFileStatus
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"_"
argument_list|)
condition|)
continue|continue;
name|result
operator|.
name|addAll
argument_list|(
name|readFileToSearch
argument_list|(
name|conf
argument_list|,
name|fs
argument_list|,
name|keyFileStatus
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
specifier|private
specifier|static
name|SortedSet
argument_list|<
name|byte
index|[]
argument_list|>
name|readFileToSearch
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|LocatedFileStatus
name|keyFileStatus
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|SortedSet
argument_list|<
name|byte
index|[]
argument_list|>
name|result
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
comment|// Return entries that are flagged Counts.UNDEFINED in the value. Return the row. This is
comment|// what is missing.
name|TaskAttemptContext
name|context
init|=
operator|new
name|TaskAttemptContextImpl
argument_list|(
name|conf
argument_list|,
operator|new
name|TaskAttemptID
argument_list|()
argument_list|)
decl_stmt|;
try|try
init|(
name|SequenceFileAsBinaryInputFormat
operator|.
name|SequenceFileAsBinaryRecordReader
name|rr
init|=
operator|new
name|SequenceFileAsBinaryInputFormat
operator|.
name|SequenceFileAsBinaryRecordReader
argument_list|()
init|)
block|{
name|InputSplit
name|is
init|=
operator|new
name|FileSplit
argument_list|(
name|keyFileStatus
operator|.
name|getPath
argument_list|()
argument_list|,
literal|0
argument_list|,
name|keyFileStatus
operator|.
name|getLen
argument_list|()
argument_list|,
operator|new
name|String
index|[]
block|{}
argument_list|)
decl_stmt|;
name|rr
operator|.
name|initialize
argument_list|(
name|is
argument_list|,
name|context
argument_list|)
expr_stmt|;
while|while
condition|(
name|rr
operator|.
name|nextKeyValue
argument_list|()
condition|)
block|{
name|rr
operator|.
name|getCurrentKey
argument_list|()
expr_stmt|;
name|BytesWritable
name|bw
init|=
name|rr
operator|.
name|getCurrentValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|Verify
operator|.
name|VerifyReducer
operator|.
name|whichType
argument_list|(
name|bw
operator|.
name|getBytes
argument_list|()
argument_list|)
operator|==
name|Verify
operator|.
name|Counts
operator|.
name|UNDEFINED
condition|)
block|{
name|byte
index|[]
name|key
init|=
operator|new
name|byte
index|[
name|rr
operator|.
name|getCurrentKey
argument_list|()
operator|.
name|getLength
argument_list|()
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|rr
operator|.
name|getCurrentKey
argument_list|()
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|key
argument_list|,
literal|0
argument_list|,
name|rr
operator|.
name|getCurrentKey
argument_list|()
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
block|}
comment|/**    * A Map Reduce job that verifies that the linked lists generated by    * {@link Generator} do not have any holes.    */
specifier|static
class|class
name|Verify
extends|extends
name|Configured
implements|implements
name|Tool
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|Verify
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|BytesWritable
name|DEF
init|=
operator|new
name|BytesWritable
argument_list|(
operator|new
name|byte
index|[]
block|{
literal|0
block|}
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|BytesWritable
name|DEF_LOST_FAMILIES
init|=
operator|new
name|BytesWritable
argument_list|(
operator|new
name|byte
index|[]
block|{
literal|1
block|}
argument_list|)
decl_stmt|;
specifier|protected
name|Job
name|job
decl_stmt|;
specifier|public
specifier|static
class|class
name|VerifyMapper
extends|extends
name|TableMapper
argument_list|<
name|BytesWritable
argument_list|,
name|BytesWritable
argument_list|>
block|{
specifier|private
name|BytesWritable
name|row
init|=
operator|new
name|BytesWritable
argument_list|()
decl_stmt|;
specifier|private
name|BytesWritable
name|ref
init|=
operator|new
name|BytesWritable
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|multipleUnevenColumnFamilies
decl_stmt|;
annotation|@
name|Override
specifier|protected
name|void
name|setup
parameter_list|(
name|Mapper
argument_list|<
name|ImmutableBytesWritable
argument_list|,
name|Result
argument_list|,
name|BytesWritable
argument_list|,
name|BytesWritable
argument_list|>
operator|.
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|this
operator|.
name|multipleUnevenColumnFamilies
operator|=
name|isMultiUnevenColumnFamilies
argument_list|(
name|context
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|map
parameter_list|(
name|ImmutableBytesWritable
name|key
parameter_list|,
name|Result
name|value
parameter_list|,
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|byte
index|[]
name|rowKey
init|=
name|key
operator|.
name|get
argument_list|()
decl_stmt|;
name|row
operator|.
name|set
argument_list|(
name|rowKey
argument_list|,
literal|0
argument_list|,
name|rowKey
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|multipleUnevenColumnFamilies
operator|&&
operator|(
operator|!
name|value
operator|.
name|containsColumn
argument_list|(
name|BIG_FAMILY_NAME
argument_list|,
name|BIG_FAMILY_NAME
argument_list|)
operator|||
operator|!
name|value
operator|.
name|containsColumn
argument_list|(
name|TINY_FAMILY_NAME
argument_list|,
name|TINY_FAMILY_NAME
argument_list|)
operator|)
condition|)
block|{
name|context
operator|.
name|write
argument_list|(
name|row
argument_list|,
name|DEF_LOST_FAMILIES
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|context
operator|.
name|write
argument_list|(
name|row
argument_list|,
name|DEF
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|prev
init|=
name|value
operator|.
name|getValue
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_PREV
argument_list|)
decl_stmt|;
if|if
condition|(
name|prev
operator|!=
literal|null
operator|&&
name|prev
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|ref
operator|.
name|set
argument_list|(
name|prev
argument_list|,
literal|0
argument_list|,
name|prev
operator|.
name|length
argument_list|)
expr_stmt|;
name|context
operator|.
name|write
argument_list|(
name|ref
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Prev is not set for: %s"
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|rowKey
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Don't change the order of these enums. Their ordinals are used as type flag when we emit      * problems found from the reducer.      */
specifier|public
specifier|static
enum|enum
name|Counts
block|{
name|UNREFERENCED
block|,
name|UNDEFINED
block|,
name|REFERENCED
block|,
name|CORRUPT
block|,
name|EXTRAREFERENCES
block|,
name|EXTRA_UNDEF_REFERENCES
block|,
name|LOST_FAMILIES
block|}
comment|/**      * Per reducer, we output problem rows as byte arrasy so can be used as input for      * subsequent investigative mapreduce jobs. Each emitted value is prefaced by a one byte flag      * saying what sort of emission it is. Flag is the Count enum ordinal as a short.      */
specifier|public
specifier|static
class|class
name|VerifyReducer
extends|extends
name|Reducer
argument_list|<
name|BytesWritable
argument_list|,
name|BytesWritable
argument_list|,
name|BytesWritable
argument_list|,
name|BytesWritable
argument_list|>
block|{
specifier|private
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
name|refs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|BytesWritable
name|UNREF
init|=
operator|new
name|BytesWritable
argument_list|(
name|addPrefixFlag
argument_list|(
name|Counts
operator|.
name|UNREFERENCED
operator|.
name|ordinal
argument_list|()
argument_list|,
operator|new
name|byte
index|[]
block|{}
argument_list|)
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|BytesWritable
name|LOSTFAM
init|=
operator|new
name|BytesWritable
argument_list|(
name|addPrefixFlag
argument_list|(
name|Counts
operator|.
name|LOST_FAMILIES
operator|.
name|ordinal
argument_list|()
argument_list|,
operator|new
name|byte
index|[]
block|{}
argument_list|)
argument_list|)
decl_stmt|;
specifier|private
name|AtomicInteger
name|rows
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|private
name|Connection
name|connection
decl_stmt|;
annotation|@
name|Override
specifier|protected
name|void
name|setup
parameter_list|(
name|Reducer
argument_list|<
name|BytesWritable
argument_list|,
name|BytesWritable
argument_list|,
name|BytesWritable
argument_list|,
name|BytesWritable
argument_list|>
operator|.
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|super
operator|.
name|setup
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|this
operator|.
name|connection
operator|=
name|ConnectionFactory
operator|.
name|createConnection
argument_list|(
name|context
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|cleanup
parameter_list|(
name|Reducer
argument_list|<
name|BytesWritable
argument_list|,
name|BytesWritable
argument_list|,
name|BytesWritable
argument_list|,
name|BytesWritable
argument_list|>
operator|.
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|this
operator|.
name|connection
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|super
operator|.
name|cleanup
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
comment|/**        * @param ordinal        * @param r        * @return Return new byte array that has<code>ordinal</code> as prefix on front taking up        * Bytes.SIZEOF_SHORT bytes followed by<code>r</code>        */
specifier|public
specifier|static
name|byte
index|[]
name|addPrefixFlag
parameter_list|(
specifier|final
name|int
name|ordinal
parameter_list|,
specifier|final
name|byte
index|[]
name|r
parameter_list|)
block|{
name|byte
index|[]
name|prefix
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
operator|(
name|short
operator|)
name|ordinal
argument_list|)
decl_stmt|;
if|if
condition|(
name|prefix
operator|.
name|length
operator|!=
name|Bytes
operator|.
name|SIZEOF_SHORT
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected size: "
operator|+
name|prefix
operator|.
name|length
argument_list|)
throw|;
block|}
name|byte
index|[]
name|result
init|=
operator|new
name|byte
index|[
name|prefix
operator|.
name|length
operator|+
name|r
operator|.
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|prefix
argument_list|,
literal|0
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
name|prefix
operator|.
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
name|result
argument_list|,
name|prefix
operator|.
name|length
argument_list|,
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**        * @param bs        * @return Type from the Counts enum of this row. Reads prefix added by        * {@link #addPrefixFlag(int, byte[])}        */
specifier|public
specifier|static
name|Counts
name|whichType
parameter_list|(
specifier|final
name|byte
index|[]
name|bs
parameter_list|)
block|{
name|int
name|ordinal
init|=
name|Bytes
operator|.
name|toShort
argument_list|(
name|bs
argument_list|,
literal|0
argument_list|,
name|Bytes
operator|.
name|SIZEOF_SHORT
argument_list|)
decl_stmt|;
return|return
name|Counts
operator|.
name|values
argument_list|()
index|[
name|ordinal
index|]
return|;
block|}
comment|/**        * @param bw        * @return Row bytes minus the type flag.        */
specifier|public
specifier|static
name|byte
index|[]
name|getRowOnly
parameter_list|(
name|BytesWritable
name|bw
parameter_list|)
block|{
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|bw
operator|.
name|getLength
argument_list|()
operator|-
name|Bytes
operator|.
name|SIZEOF_SHORT
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|bw
operator|.
name|getBytes
argument_list|()
argument_list|,
name|Bytes
operator|.
name|SIZEOF_SHORT
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|bytes
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|reduce
parameter_list|(
name|BytesWritable
name|key
parameter_list|,
name|Iterable
argument_list|<
name|BytesWritable
argument_list|>
name|values
parameter_list|,
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|int
name|defCount
init|=
literal|0
decl_stmt|;
name|boolean
name|lostFamilies
init|=
literal|false
decl_stmt|;
name|refs
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|BytesWritable
name|type
range|:
name|values
control|)
block|{
if|if
condition|(
name|type
operator|.
name|getLength
argument_list|()
operator|==
name|DEF
operator|.
name|getLength
argument_list|()
condition|)
block|{
name|defCount
operator|++
expr_stmt|;
if|if
condition|(
name|type
operator|.
name|getBytes
argument_list|()
index|[
literal|0
index|]
operator|==
literal|1
condition|)
block|{
name|lostFamilies
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|type
operator|.
name|getLength
argument_list|()
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|type
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|,
name|type
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|refs
operator|.
name|add
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO check for more than one def, should not happen
name|StringBuilder
name|refsSb
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|defCount
operator|==
literal|0
operator|||
name|refs
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|String
name|keyString
init|=
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|key
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|getLength
argument_list|()
argument_list|)
decl_stmt|;
name|refsSb
operator|=
name|dumpExtraInfoOnRefs
argument_list|(
name|key
argument_list|,
name|context
argument_list|,
name|refs
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"LinkedListError: key="
operator|+
name|keyString
operator|+
literal|", reference(s)="
operator|+
operator|(
name|refsSb
operator|!=
literal|null
condition|?
name|refsSb
operator|.
name|toString
argument_list|()
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lostFamilies
condition|)
block|{
name|String
name|keyString
init|=
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|key
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|getLength
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"LinkedListError: key="
operator|+
name|keyString
operator|+
literal|", lost big or tiny families"
argument_list|)
expr_stmt|;
name|context
operator|.
name|getCounter
argument_list|(
name|Counts
operator|.
name|LOST_FAMILIES
argument_list|)
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|context
operator|.
name|write
argument_list|(
name|key
argument_list|,
name|LOSTFAM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|defCount
operator|==
literal|0
operator|&&
name|refs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// This is bad, found a node that is referenced but not defined. It must have been
comment|// lost, emit some info about this node for debugging purposes.
comment|// Write out a line per reference. If more than one, flag it.;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|refs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|byte
index|[]
name|bs
init|=
name|refs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|ordinal
decl_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
name|ordinal
operator|=
name|Counts
operator|.
name|UNDEFINED
operator|.
name|ordinal
argument_list|()
expr_stmt|;
name|context
operator|.
name|write
argument_list|(
name|key
argument_list|,
operator|new
name|BytesWritable
argument_list|(
name|addPrefixFlag
argument_list|(
name|ordinal
argument_list|,
name|bs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|getCounter
argument_list|(
name|Counts
operator|.
name|UNDEFINED
argument_list|)
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ordinal
operator|=
name|Counts
operator|.
name|EXTRA_UNDEF_REFERENCES
operator|.
name|ordinal
argument_list|()
expr_stmt|;
name|context
operator|.
name|write
argument_list|(
name|key
argument_list|,
operator|new
name|BytesWritable
argument_list|(
name|addPrefixFlag
argument_list|(
name|ordinal
argument_list|,
name|bs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rows
operator|.
name|addAndGet
argument_list|(
literal|1
argument_list|)
operator|<
name|MISSING_ROWS_TO_LOG
condition|)
block|{
comment|// Print out missing row; doing get on reference gives info on when the referencer
comment|// was added which can help a little debugging. This info is only available in mapper
comment|// output -- the 'Linked List error Key...' log message above. What we emit here is
comment|// useless for debugging.
name|String
name|keyString
init|=
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|key
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|getLength
argument_list|()
argument_list|)
decl_stmt|;
name|context
operator|.
name|getCounter
argument_list|(
literal|"undef"
argument_list|,
name|keyString
argument_list|)
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|defCount
operator|>
literal|0
operator|&&
name|refs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// node is defined but not referenced
name|context
operator|.
name|write
argument_list|(
name|key
argument_list|,
name|UNREF
argument_list|)
expr_stmt|;
name|context
operator|.
name|getCounter
argument_list|(
name|Counts
operator|.
name|UNREFERENCED
argument_list|)
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rows
operator|.
name|addAndGet
argument_list|(
literal|1
argument_list|)
operator|<
name|MISSING_ROWS_TO_LOG
condition|)
block|{
name|String
name|keyString
init|=
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|key
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|getLength
argument_list|()
argument_list|)
decl_stmt|;
name|context
operator|.
name|getCounter
argument_list|(
literal|"unref"
argument_list|,
name|keyString
argument_list|)
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|refs
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// Skip first reference.
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|refs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|context
operator|.
name|write
argument_list|(
name|key
argument_list|,
operator|new
name|BytesWritable
argument_list|(
name|addPrefixFlag
argument_list|(
name|Counts
operator|.
name|EXTRAREFERENCES
operator|.
name|ordinal
argument_list|()
argument_list|,
name|refs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|context
operator|.
name|getCounter
argument_list|(
name|Counts
operator|.
name|EXTRAREFERENCES
argument_list|)
operator|.
name|increment
argument_list|(
name|refs
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// node is defined and referenced
name|context
operator|.
name|getCounter
argument_list|(
name|Counts
operator|.
name|REFERENCED
argument_list|)
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**        * Dump out extra info around references if there are any. Helps debugging.        * @return StringBuilder filled with references if any.        * @throws IOException        */
specifier|private
name|StringBuilder
name|dumpExtraInfoOnRefs
parameter_list|(
specifier|final
name|BytesWritable
name|key
parameter_list|,
specifier|final
name|Context
name|context
parameter_list|,
specifier|final
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|refs
parameter_list|)
throws|throws
name|IOException
block|{
name|StringBuilder
name|refsSb
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|refs
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|refsSb
return|;
name|refsSb
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
name|String
name|comma
init|=
literal|""
decl_stmt|;
comment|// If a row is a reference but has no define, print the content of the row that has
comment|// this row as a 'prev'; it will help debug.  The missing row was written just before
comment|// the row we are dumping out here.
name|TableName
name|tn
init|=
name|getTableName
argument_list|(
name|context
operator|.
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
try|try
init|(
name|Table
name|t
init|=
name|this
operator|.
name|connection
operator|.
name|getTable
argument_list|(
name|tn
argument_list|)
init|)
block|{
for|for
control|(
name|byte
index|[]
name|ref
range|:
name|refs
control|)
block|{
name|Result
name|r
init|=
name|t
operator|.
name|get
argument_list|(
operator|new
name|Get
argument_list|(
name|ref
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Cell
argument_list|>
name|cells
init|=
name|r
operator|.
name|listCells
argument_list|()
decl_stmt|;
name|String
name|ts
init|=
operator|(
name|cells
operator|!=
literal|null
operator|&&
operator|!
name|cells
operator|.
name|isEmpty
argument_list|()
operator|)
condition|?
operator|new
name|java
operator|.
name|util
operator|.
name|Date
argument_list|(
name|cells
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTimestamp
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
else|:
literal|""
decl_stmt|;
name|byte
index|[]
name|b
init|=
name|r
operator|.
name|getValue
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_CLIENT
argument_list|)
decl_stmt|;
name|String
name|jobStr
init|=
operator|(
name|b
operator|!=
literal|null
operator|&&
name|b
operator|.
name|length
operator|>
literal|0
operator|)
condition|?
name|Bytes
operator|.
name|toString
argument_list|(
name|b
argument_list|)
else|:
literal|""
decl_stmt|;
name|b
operator|=
name|r
operator|.
name|getValue
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_COUNT
argument_list|)
expr_stmt|;
name|long
name|count
init|=
operator|(
name|b
operator|!=
literal|null
operator|&&
name|b
operator|.
name|length
operator|>
literal|0
operator|)
condition|?
name|Bytes
operator|.
name|toLong
argument_list|(
name|b
argument_list|)
else|:
operator|-
literal|1
decl_stmt|;
name|b
operator|=
name|r
operator|.
name|getValue
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_PREV
argument_list|)
expr_stmt|;
name|String
name|refRegionLocation
init|=
literal|""
decl_stmt|;
name|String
name|keyRegionLocation
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|b
operator|!=
literal|null
operator|&&
name|b
operator|.
name|length
operator|>
literal|0
condition|)
block|{
try|try
init|(
name|RegionLocator
name|rl
init|=
name|this
operator|.
name|connection
operator|.
name|getRegionLocator
argument_list|(
name|tn
argument_list|)
init|)
block|{
name|HRegionLocation
name|hrl
init|=
name|rl
operator|.
name|getRegionLocation
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|hrl
operator|!=
literal|null
condition|)
name|refRegionLocation
operator|=
name|hrl
operator|.
name|toString
argument_list|()
expr_stmt|;
comment|// Key here probably has trailing zeros on it.
name|hrl
operator|=
name|rl
operator|.
name|getRegionLocation
argument_list|(
name|key
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|hrl
operator|!=
literal|null
condition|)
name|keyRegionLocation
operator|=
name|hrl
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Extras on ref without a def, ref="
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|ref
argument_list|)
operator|+
literal|", refPrevEqualsKey="
operator|+
operator|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|key
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|getLength
argument_list|()
argument_list|,
name|b
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|length
argument_list|)
operator|==
literal|0
operator|)
operator|+
literal|", key="
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|key
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|getLength
argument_list|()
argument_list|)
operator|+
literal|", ref row date="
operator|+
name|ts
operator|+
literal|", jobStr="
operator|+
name|jobStr
operator|+
literal|", ref row count="
operator|+
name|count
operator|+
literal|", ref row regionLocation="
operator|+
name|refRegionLocation
operator|+
literal|", key row regionLocation="
operator|+
name|keyRegionLocation
argument_list|)
expr_stmt|;
name|refsSb
operator|.
name|append
argument_list|(
name|comma
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|","
expr_stmt|;
name|refsSb
operator|.
name|append
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|refsSb
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|args
operator|.
name|length
operator|!=
literal|2
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Usage : "
operator|+
name|Verify
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"<output dir><num reducers>"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|String
name|outputDir
init|=
name|args
index|[
literal|0
index|]
decl_stmt|;
name|int
name|numReducers
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
return|return
name|run
argument_list|(
name|outputDir
argument_list|,
name|numReducers
argument_list|)
return|;
block|}
specifier|public
name|int
name|run
parameter_list|(
name|String
name|outputDir
parameter_list|,
name|int
name|numReducers
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|run
argument_list|(
operator|new
name|Path
argument_list|(
name|outputDir
argument_list|)
argument_list|,
name|numReducers
argument_list|)
return|;
block|}
specifier|public
name|int
name|run
parameter_list|(
name|Path
name|outputDir
parameter_list|,
name|int
name|numReducers
parameter_list|)
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Running Verify with outputDir="
operator|+
name|outputDir
operator|+
literal|", numReducers="
operator|+
name|numReducers
argument_list|)
expr_stmt|;
name|job
operator|=
name|Job
operator|.
name|getInstance
argument_list|(
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
name|job
operator|.
name|setJobName
argument_list|(
literal|"Link Verifier"
argument_list|)
expr_stmt|;
name|job
operator|.
name|setNumReduceTasks
argument_list|(
name|numReducers
argument_list|)
expr_stmt|;
name|job
operator|.
name|setJarByClass
argument_list|(
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|setJobScannerConf
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|Scan
name|scan
init|=
operator|new
name|Scan
argument_list|()
decl_stmt|;
name|scan
operator|.
name|addColumn
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_PREV
argument_list|)
expr_stmt|;
name|scan
operator|.
name|setCaching
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|scan
operator|.
name|setCacheBlocks
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|isMultiUnevenColumnFamilies
argument_list|(
name|getConf
argument_list|()
argument_list|)
condition|)
block|{
name|scan
operator|.
name|addColumn
argument_list|(
name|BIG_FAMILY_NAME
argument_list|,
name|BIG_FAMILY_NAME
argument_list|)
expr_stmt|;
name|scan
operator|.
name|addColumn
argument_list|(
name|TINY_FAMILY_NAME
argument_list|,
name|TINY_FAMILY_NAME
argument_list|)
expr_stmt|;
block|}
name|TableMapReduceUtil
operator|.
name|initTableMapperJob
argument_list|(
name|getTableName
argument_list|(
name|getConf
argument_list|()
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|,
name|scan
argument_list|,
name|VerifyMapper
operator|.
name|class
argument_list|,
name|BytesWritable
operator|.
name|class
argument_list|,
name|BytesWritable
operator|.
name|class
argument_list|,
name|job
argument_list|)
expr_stmt|;
name|TableMapReduceUtil
operator|.
name|addDependencyJarsForClasses
argument_list|(
name|job
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|AbstractHBaseTool
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|getConfiguration
argument_list|()
operator|.
name|setBoolean
argument_list|(
literal|"mapreduce.map.speculative"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|job
operator|.
name|setReducerClass
argument_list|(
name|VerifyReducer
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputFormatClass
argument_list|(
name|SequenceFileAsBinaryOutputFormat
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputKeyClass
argument_list|(
name|BytesWritable
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputValueClass
argument_list|(
name|BytesWritable
operator|.
name|class
argument_list|)
expr_stmt|;
name|TextOutputFormat
operator|.
name|setOutputPath
argument_list|(
name|job
argument_list|,
name|outputDir
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
name|job
operator|.
name|waitForCompletion
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|Counters
name|counters
init|=
name|job
operator|.
name|getCounters
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|counters
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Counters were null, cannot verify Job completion."
operator|+
literal|" This is commonly a result of insufficient YARN configuration."
argument_list|)
expr_stmt|;
comment|// We don't have access to the counters to know if we have "bad" counts
return|return
literal|0
return|;
block|}
comment|// If we find no unexpected values, the job didn't outright fail
if|if
condition|(
name|verifyUnexpectedValues
argument_list|(
name|counters
argument_list|)
condition|)
block|{
comment|// We didn't check referenced+unreferenced counts, leave that to visual inspection
return|return
literal|0
return|;
block|}
block|}
comment|// We failed
return|return
literal|1
return|;
block|}
specifier|public
name|boolean
name|verify
parameter_list|(
name|long
name|expectedReferenced
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|job
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"You should call run() first"
argument_list|)
throw|;
block|}
name|Counters
name|counters
init|=
name|job
operator|.
name|getCounters
argument_list|()
decl_stmt|;
if|if
condition|(
name|counters
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Counters object was null, write verification cannot be performed."
operator|+
literal|" This is commonly a result of insufficient YARN configuration."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Run through each check, even if we fail one early
name|boolean
name|success
init|=
name|verifyExpectedValues
argument_list|(
name|expectedReferenced
argument_list|,
name|counters
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|verifyUnexpectedValues
argument_list|(
name|counters
argument_list|)
condition|)
block|{
comment|// We found counter objects which imply failure
name|success
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|handleFailure
argument_list|(
name|counters
argument_list|)
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
comment|/**      * Verify the values in the Counters against the expected number of entries written.      *      * @param expectedReferenced      *          Expected number of referenced entrires      * @param counters      *          The Job's Counters object      * @return True if the values match what's expected, false otherwise      */
specifier|protected
name|boolean
name|verifyExpectedValues
parameter_list|(
name|long
name|expectedReferenced
parameter_list|,
name|Counters
name|counters
parameter_list|)
block|{
specifier|final
name|Counter
name|referenced
init|=
name|counters
operator|.
name|findCounter
argument_list|(
name|Counts
operator|.
name|REFERENCED
argument_list|)
decl_stmt|;
specifier|final
name|Counter
name|unreferenced
init|=
name|counters
operator|.
name|findCounter
argument_list|(
name|Counts
operator|.
name|UNREFERENCED
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|expectedReferenced
operator|!=
name|referenced
operator|.
name|getValue
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Expected referenced count does not match with actual referenced count. "
operator|+
literal|"expected referenced="
operator|+
name|expectedReferenced
operator|+
literal|" ,actual="
operator|+
name|referenced
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|success
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|unreferenced
operator|.
name|getValue
argument_list|()
operator|>
literal|0
condition|)
block|{
specifier|final
name|Counter
name|multiref
init|=
name|counters
operator|.
name|findCounter
argument_list|(
name|Counts
operator|.
name|EXTRAREFERENCES
argument_list|)
decl_stmt|;
name|boolean
name|couldBeMultiRef
init|=
operator|(
name|multiref
operator|.
name|getValue
argument_list|()
operator|==
name|unreferenced
operator|.
name|getValue
argument_list|()
operator|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Unreferenced nodes were not expected. Unreferenced count="
operator|+
name|unreferenced
operator|.
name|getValue
argument_list|()
operator|+
operator|(
name|couldBeMultiRef
condition|?
literal|"; could be due to duplicate random numbers"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|success
operator|=
literal|false
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
comment|/**      * Verify that the Counters don't contain values which indicate an outright failure from the Reducers.      *      * @param counters      *          The Job's counters      * @return True if the "bad" counter objects are 0, false otherwise      */
specifier|protected
name|boolean
name|verifyUnexpectedValues
parameter_list|(
name|Counters
name|counters
parameter_list|)
block|{
specifier|final
name|Counter
name|undefined
init|=
name|counters
operator|.
name|findCounter
argument_list|(
name|Counts
operator|.
name|UNDEFINED
argument_list|)
decl_stmt|;
specifier|final
name|Counter
name|lostfamilies
init|=
name|counters
operator|.
name|findCounter
argument_list|(
name|Counts
operator|.
name|LOST_FAMILIES
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|undefined
operator|.
name|getValue
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Found an undefined node. Undefined count="
operator|+
name|undefined
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|success
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|lostfamilies
operator|.
name|getValue
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Found nodes which lost big or tiny families, count="
operator|+
name|lostfamilies
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|success
operator|=
literal|false
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
specifier|protected
name|void
name|handleFailure
parameter_list|(
name|Counters
name|counters
parameter_list|)
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
name|job
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|TableName
name|tableName
init|=
name|getTableName
argument_list|(
name|conf
argument_list|)
decl_stmt|;
try|try
init|(
name|Connection
name|conn
init|=
name|ConnectionFactory
operator|.
name|createConnection
argument_list|(
name|conf
argument_list|)
init|)
block|{
try|try
init|(
name|RegionLocator
name|rl
init|=
name|conn
operator|.
name|getRegionLocator
argument_list|(
name|tableName
argument_list|)
init|)
block|{
name|CounterGroup
name|g
init|=
name|counters
operator|.
name|getGroup
argument_list|(
literal|"undef"
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|Counter
argument_list|>
name|it
init|=
name|g
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|keyString
init|=
name|it
operator|.
name|next
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|byte
index|[]
name|key
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|keyString
argument_list|)
decl_stmt|;
name|HRegionLocation
name|loc
init|=
name|rl
operator|.
name|getRegionLocation
argument_list|(
name|key
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"undefined row "
operator|+
name|keyString
operator|+
literal|", "
operator|+
name|loc
argument_list|)
expr_stmt|;
block|}
name|g
operator|=
name|counters
operator|.
name|getGroup
argument_list|(
literal|"unref"
argument_list|)
expr_stmt|;
name|it
operator|=
name|g
operator|.
name|iterator
argument_list|()
expr_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|keyString
init|=
name|it
operator|.
name|next
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|byte
index|[]
name|key
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|keyString
argument_list|)
decl_stmt|;
name|HRegionLocation
name|loc
init|=
name|rl
operator|.
name|getRegionLocation
argument_list|(
name|key
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"unreferred row "
operator|+
name|keyString
operator|+
literal|", "
operator|+
name|loc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**    * Executes Generate and Verify in a loop. Data is not cleaned between runs, so each iteration    * adds more data.    */
specifier|static
class|class
name|Loop
extends|extends
name|Configured
implements|implements
name|Tool
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|Loop
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|USAGE
init|=
literal|"Usage: Loop<num iterations><num mappers> "
operator|+
literal|"<num nodes per mapper><output dir><num reducers> [<width><wrap multiplier>"
operator|+
literal|"<num walker threads>] \n"
operator|+
literal|"where<num nodes per map> should be a multiple of width*wrap multiplier, 25M by default \n"
operator|+
literal|"walkers will select and verify random flushed loop during Generation."
decl_stmt|;
name|IntegrationTestBigLinkedList
name|it
decl_stmt|;
specifier|protected
name|void
name|runGenerator
parameter_list|(
name|int
name|numMappers
parameter_list|,
name|long
name|numNodes
parameter_list|,
name|String
name|outputDir
parameter_list|,
name|Integer
name|width
parameter_list|,
name|Integer
name|wrapMultiplier
parameter_list|,
name|Integer
name|numWalkers
parameter_list|)
throws|throws
name|Exception
block|{
name|Path
name|outputPath
init|=
operator|new
name|Path
argument_list|(
name|outputDir
argument_list|)
decl_stmt|;
name|UUID
name|uuid
init|=
name|UUID
operator|.
name|randomUUID
argument_list|()
decl_stmt|;
comment|//create a random UUID.
name|Path
name|generatorOutput
init|=
operator|new
name|Path
argument_list|(
name|outputPath
argument_list|,
name|uuid
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Generator
name|generator
init|=
operator|new
name|Generator
argument_list|()
decl_stmt|;
name|generator
operator|.
name|setConf
argument_list|(
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|retCode
init|=
name|generator
operator|.
name|run
argument_list|(
name|numMappers
argument_list|,
name|numNodes
argument_list|,
name|generatorOutput
argument_list|,
name|width
argument_list|,
name|wrapMultiplier
argument_list|,
name|numWalkers
argument_list|)
decl_stmt|;
if|if
condition|(
name|retCode
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Generator failed with return code: "
operator|+
name|retCode
argument_list|)
throw|;
block|}
if|if
condition|(
name|numWalkers
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|generator
operator|.
name|verify
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Generator.verify failed"
argument_list|)
throw|;
block|}
block|}
block|}
specifier|protected
name|void
name|runVerify
parameter_list|(
name|String
name|outputDir
parameter_list|,
name|int
name|numReducers
parameter_list|,
name|long
name|expectedNumNodes
parameter_list|)
throws|throws
name|Exception
block|{
name|Path
name|outputPath
init|=
operator|new
name|Path
argument_list|(
name|outputDir
argument_list|)
decl_stmt|;
name|UUID
name|uuid
init|=
name|UUID
operator|.
name|randomUUID
argument_list|()
decl_stmt|;
comment|//create a random UUID.
name|Path
name|iterationOutput
init|=
operator|new
name|Path
argument_list|(
name|outputPath
argument_list|,
name|uuid
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Verify
name|verify
init|=
operator|new
name|Verify
argument_list|()
decl_stmt|;
name|verify
operator|.
name|setConf
argument_list|(
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|retCode
init|=
name|verify
operator|.
name|run
argument_list|(
name|iterationOutput
argument_list|,
name|numReducers
argument_list|)
decl_stmt|;
if|if
condition|(
name|retCode
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Verify.run failed with return code: "
operator|+
name|retCode
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|verify
operator|.
name|verify
argument_list|(
name|expectedNumNodes
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Verify.verify failed"
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Verify finished with success. Total nodes="
operator|+
name|expectedNumNodes
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|args
operator|.
name|length
operator|<
literal|5
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|USAGE
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
try|try
block|{
name|int
name|numIterations
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|numMappers
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|long
name|numNodes
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|args
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|String
name|outputDir
init|=
name|args
index|[
literal|3
index|]
decl_stmt|;
name|int
name|numReducers
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|4
index|]
argument_list|)
decl_stmt|;
name|Integer
name|width
init|=
operator|(
name|args
operator|.
name|length
operator|<
literal|6
operator|)
condition|?
literal|null
else|:
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|5
index|]
argument_list|)
decl_stmt|;
name|Integer
name|wrapMultiplier
init|=
operator|(
name|args
operator|.
name|length
operator|<
literal|7
operator|)
condition|?
literal|null
else|:
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|6
index|]
argument_list|)
decl_stmt|;
name|Integer
name|numWalkers
init|=
operator|(
name|args
operator|.
name|length
operator|<
literal|8
operator|)
condition|?
literal|0
else|:
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|7
index|]
argument_list|)
decl_stmt|;
name|long
name|expectedNumNodes
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|numIterations
operator|<
literal|0
condition|)
block|{
name|numIterations
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
comment|//run indefinitely (kind of)
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Running Loop with args:"
operator|+
name|Arrays
operator|.
name|deepToString
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numIterations
condition|;
name|i
operator|++
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting iteration = "
operator|+
name|i
argument_list|)
expr_stmt|;
name|runGenerator
argument_list|(
name|numMappers
argument_list|,
name|numNodes
argument_list|,
name|outputDir
argument_list|,
name|width
argument_list|,
name|wrapMultiplier
argument_list|,
name|numWalkers
argument_list|)
expr_stmt|;
name|expectedNumNodes
operator|+=
name|numMappers
operator|*
name|numNodes
expr_stmt|;
name|runVerify
argument_list|(
name|outputDir
argument_list|,
name|numReducers
argument_list|,
name|expectedNumNodes
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Parsing loop arguments failed: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|USAGE
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
comment|/**    * A stand alone program that prints out portions of a list created by {@link Generator}    */
specifier|private
specifier|static
class|class
name|Print
extends|extends
name|Configured
implements|implements
name|Tool
block|{
annotation|@
name|Override
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|Options
name|options
init|=
operator|new
name|Options
argument_list|()
decl_stmt|;
name|options
operator|.
name|addOption
argument_list|(
literal|"s"
argument_list|,
literal|"start"
argument_list|,
literal|true
argument_list|,
literal|"start key"
argument_list|)
expr_stmt|;
name|options
operator|.
name|addOption
argument_list|(
literal|"e"
argument_list|,
literal|"end"
argument_list|,
literal|true
argument_list|,
literal|"end key"
argument_list|)
expr_stmt|;
name|options
operator|.
name|addOption
argument_list|(
literal|"l"
argument_list|,
literal|"limit"
argument_list|,
literal|true
argument_list|,
literal|"number to print"
argument_list|)
expr_stmt|;
name|GnuParser
name|parser
init|=
operator|new
name|GnuParser
argument_list|()
decl_stmt|;
name|CommandLine
name|cmd
init|=
literal|null
decl_stmt|;
try|try
block|{
name|cmd
operator|=
name|parser
operator|.
name|parse
argument_list|(
name|options
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|.
name|getArgs
argument_list|()
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"Command takes no arguments"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Failed to parse command line "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|()
expr_stmt|;
name|HelpFormatter
name|formatter
init|=
operator|new
name|HelpFormatter
argument_list|()
decl_stmt|;
name|formatter
operator|.
name|printHelp
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|Connection
name|connection
init|=
name|ConnectionFactory
operator|.
name|createConnection
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|Table
name|table
init|=
name|connection
operator|.
name|getTable
argument_list|(
name|getTableName
argument_list|(
name|getConf
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|Scan
name|scan
init|=
operator|new
name|Scan
argument_list|()
decl_stmt|;
name|scan
operator|.
name|setBatch
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"s"
argument_list|)
condition|)
name|scan
operator|.
name|setStartRow
argument_list|(
name|Bytes
operator|.
name|toBytesBinary
argument_list|(
name|cmd
operator|.
name|getOptionValue
argument_list|(
literal|"s"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"e"
argument_list|)
condition|)
name|scan
operator|.
name|setStopRow
argument_list|(
name|Bytes
operator|.
name|toBytesBinary
argument_list|(
name|cmd
operator|.
name|getOptionValue
argument_list|(
literal|"e"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|limit
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"l"
argument_list|)
condition|)
name|limit
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|cmd
operator|.
name|getOptionValue
argument_list|(
literal|"l"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|limit
operator|=
literal|100
expr_stmt|;
name|ResultScanner
name|scanner
init|=
name|table
operator|.
name|getScanner
argument_list|(
name|scan
argument_list|)
decl_stmt|;
name|CINode
name|node
init|=
operator|new
name|CINode
argument_list|()
decl_stmt|;
name|Result
name|result
init|=
name|scanner
operator|.
name|next
argument_list|()
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|result
operator|!=
literal|null
operator|&&
name|count
operator|++
operator|<
name|limit
condition|)
block|{
name|node
operator|=
name|getCINode
argument_list|(
name|result
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|printf
argument_list|(
literal|"%s:%s:%012d:%s\n"
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|node
operator|.
name|key
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|node
operator|.
name|prev
argument_list|)
argument_list|,
name|node
operator|.
name|count
argument_list|,
name|node
operator|.
name|client
argument_list|)
expr_stmt|;
name|result
operator|=
name|scanner
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
name|scanner
operator|.
name|close
argument_list|()
expr_stmt|;
name|table
operator|.
name|close
argument_list|()
expr_stmt|;
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/**    * A stand alone program that deletes a single node.    */
specifier|private
specifier|static
class|class
name|Delete
extends|extends
name|Configured
implements|implements
name|Tool
block|{
annotation|@
name|Override
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|args
operator|.
name|length
operator|!=
literal|1
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Usage : "
operator|+
name|Delete
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"<node to delete>"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|byte
index|[]
name|val
init|=
name|Bytes
operator|.
name|toBytesBinary
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Delete
name|delete
init|=
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Delete
argument_list|(
name|val
argument_list|)
decl_stmt|;
try|try
init|(
name|Connection
name|connection
init|=
name|ConnectionFactory
operator|.
name|createConnection
argument_list|(
name|getConf
argument_list|()
argument_list|)
init|;
name|Table
name|table
operator|=
name|connection
operator|.
name|getTable
argument_list|(
name|getTableName
argument_list|(
name|getConf
argument_list|()
argument_list|)
argument_list|)
init|)
block|{
name|table
operator|.
name|delete
argument_list|(
name|delete
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Delete successful"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
specifier|abstract
specifier|static
class|class
name|WalkerBase
extends|extends
name|Configured
block|{
specifier|protected
specifier|static
name|CINode
name|findStartNode
parameter_list|(
name|Table
name|table
parameter_list|,
name|byte
index|[]
name|startKey
parameter_list|)
throws|throws
name|IOException
block|{
name|Scan
name|scan
init|=
operator|new
name|Scan
argument_list|()
decl_stmt|;
name|scan
operator|.
name|setStartRow
argument_list|(
name|startKey
argument_list|)
expr_stmt|;
name|scan
operator|.
name|setBatch
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|scan
operator|.
name|addColumn
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_PREV
argument_list|)
expr_stmt|;
name|long
name|t1
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|ResultScanner
name|scanner
init|=
name|table
operator|.
name|getScanner
argument_list|(
name|scan
argument_list|)
decl_stmt|;
name|Result
name|result
init|=
name|scanner
operator|.
name|next
argument_list|()
decl_stmt|;
name|long
name|t2
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|scanner
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
name|CINode
name|node
init|=
name|getCINode
argument_list|(
name|result
argument_list|,
operator|new
name|CINode
argument_list|()
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|printf
argument_list|(
literal|"FSR %d %s\n"
argument_list|,
name|t2
operator|-
name|t1
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|node
operator|.
name|key
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FSR "
operator|+
operator|(
name|t2
operator|-
name|t1
operator|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|protected
name|CINode
name|getNode
parameter_list|(
name|byte
index|[]
name|row
parameter_list|,
name|Table
name|table
parameter_list|,
name|CINode
name|node
parameter_list|)
throws|throws
name|IOException
block|{
name|Get
name|get
init|=
operator|new
name|Get
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|get
operator|.
name|addColumn
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_PREV
argument_list|)
expr_stmt|;
name|Result
name|result
init|=
name|table
operator|.
name|get
argument_list|(
name|get
argument_list|)
decl_stmt|;
return|return
name|getCINode
argument_list|(
name|result
argument_list|,
name|node
argument_list|)
return|;
block|}
block|}
comment|/**    * A stand alone program that follows a linked list created by {@link Generator} and prints    * timing info.    */
specifier|private
specifier|static
class|class
name|Walker
extends|extends
name|WalkerBase
implements|implements
name|Tool
block|{
specifier|public
name|Walker
parameter_list|()
block|{}
annotation|@
name|Override
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|IOException
block|{
name|Options
name|options
init|=
operator|new
name|Options
argument_list|()
decl_stmt|;
name|options
operator|.
name|addOption
argument_list|(
literal|"n"
argument_list|,
literal|"num"
argument_list|,
literal|true
argument_list|,
literal|"number of queries"
argument_list|)
expr_stmt|;
name|options
operator|.
name|addOption
argument_list|(
literal|"s"
argument_list|,
literal|"start"
argument_list|,
literal|true
argument_list|,
literal|"key to start at, binary string"
argument_list|)
expr_stmt|;
name|options
operator|.
name|addOption
argument_list|(
literal|"l"
argument_list|,
literal|"logevery"
argument_list|,
literal|true
argument_list|,
literal|"log every N queries"
argument_list|)
expr_stmt|;
name|GnuParser
name|parser
init|=
operator|new
name|GnuParser
argument_list|()
decl_stmt|;
name|CommandLine
name|cmd
init|=
literal|null
decl_stmt|;
try|try
block|{
name|cmd
operator|=
name|parser
operator|.
name|parse
argument_list|(
name|options
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|.
name|getArgs
argument_list|()
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"Command takes no arguments"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Failed to parse command line "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|()
expr_stmt|;
name|HelpFormatter
name|formatter
init|=
operator|new
name|HelpFormatter
argument_list|()
decl_stmt|;
name|formatter
operator|.
name|printHelp
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|long
name|maxQueries
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
if|if
condition|(
name|cmd
operator|.
name|hasOption
argument_list|(
literal|'n'
argument_list|)
condition|)
block|{
name|maxQueries
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|cmd
operator|.
name|getOptionValue
argument_list|(
literal|"n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Random
name|rand
init|=
operator|new
name|SecureRandom
argument_list|()
decl_stmt|;
name|boolean
name|isSpecificStart
init|=
name|cmd
operator|.
name|hasOption
argument_list|(
literal|'s'
argument_list|)
decl_stmt|;
name|byte
index|[]
name|startKey
init|=
name|isSpecificStart
condition|?
name|Bytes
operator|.
name|toBytesBinary
argument_list|(
name|cmd
operator|.
name|getOptionValue
argument_list|(
literal|'s'
argument_list|)
argument_list|)
else|:
literal|null
decl_stmt|;
name|int
name|logEvery
init|=
name|cmd
operator|.
name|hasOption
argument_list|(
literal|'l'
argument_list|)
condition|?
name|Integer
operator|.
name|parseInt
argument_list|(
name|cmd
operator|.
name|getOptionValue
argument_list|(
literal|'l'
argument_list|)
argument_list|)
else|:
literal|1
decl_stmt|;
name|Connection
name|connection
init|=
name|ConnectionFactory
operator|.
name|createConnection
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|Table
name|table
init|=
name|connection
operator|.
name|getTable
argument_list|(
name|getTableName
argument_list|(
name|getConf
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|numQueries
init|=
literal|0
decl_stmt|;
comment|// If isSpecificStart is set, only walk one list from that particular node.
comment|// Note that in case of circular (or P-shaped) list it will walk forever, as is
comment|// the case in normal run without startKey.
while|while
condition|(
name|numQueries
operator|<
name|maxQueries
operator|&&
operator|(
name|numQueries
operator|==
literal|0
operator|||
operator|!
name|isSpecificStart
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|isSpecificStart
condition|)
block|{
name|startKey
operator|=
operator|new
name|byte
index|[
name|ROWKEY_LENGTH
index|]
expr_stmt|;
name|rand
operator|.
name|nextBytes
argument_list|(
name|startKey
argument_list|)
expr_stmt|;
block|}
name|CINode
name|node
init|=
name|findStartNode
argument_list|(
name|table
argument_list|,
name|startKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
operator|&&
name|isSpecificStart
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|printf
argument_list|(
literal|"Start node not found: %s \n"
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|startKey
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|numQueries
operator|++
expr_stmt|;
while|while
condition|(
name|node
operator|!=
literal|null
operator|&&
name|node
operator|.
name|prev
operator|.
name|length
operator|!=
name|NO_KEY
operator|.
name|length
operator|&&
name|numQueries
operator|<
name|maxQueries
condition|)
block|{
name|byte
index|[]
name|prev
init|=
name|node
operator|.
name|prev
decl_stmt|;
name|long
name|t1
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|node
operator|=
name|getNode
argument_list|(
name|prev
argument_list|,
name|table
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|long
name|t2
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|logEvery
operator|>
literal|0
operator|&&
name|numQueries
operator|%
name|logEvery
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|printf
argument_list|(
literal|"CQ %d: %d %s \n"
argument_list|,
name|numQueries
argument_list|,
name|t2
operator|-
name|t1
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|prev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|numQueries
operator|++
expr_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|printf
argument_list|(
literal|"UNDEFINED NODE %s \n"
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|prev
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|prev
operator|.
name|length
operator|==
name|NO_KEY
operator|.
name|length
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|printf
argument_list|(
literal|"TERMINATING NODE %s \n"
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|node
operator|.
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|table
operator|.
name|close
argument_list|()
expr_stmt|;
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|Clean
extends|extends
name|Configured
implements|implements
name|Tool
block|{
annotation|@
name|Override
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|args
operator|.
name|length
operator|<
literal|1
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Usage: Clean<output dir>"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|Path
name|p
init|=
operator|new
name|Path
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|TableName
name|tableName
init|=
name|getTableName
argument_list|(
name|conf
argument_list|)
decl_stmt|;
try|try
init|(
name|FileSystem
name|fs
init|=
name|HFileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
init|;
name|Connection
name|conn
operator|=
name|ConnectionFactory
operator|.
name|createConnection
argument_list|(
name|conf
argument_list|)
init|;
name|Admin
name|admin
operator|=
name|conn
operator|.
name|getAdmin
argument_list|()
init|)
block|{
if|if
condition|(
name|admin
operator|.
name|tableExists
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|admin
operator|.
name|disableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|admin
operator|.
name|deleteTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|fs
operator|.
name|delete
argument_list|(
name|p
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
block|}
specifier|static
name|TableName
name|getTableName
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|TableName
operator|.
name|valueOf
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|TABLE_NAME_KEY
argument_list|,
name|DEFAULT_TABLE_NAME
argument_list|)
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|CINode
name|getCINode
parameter_list|(
name|Result
name|result
parameter_list|,
name|CINode
name|node
parameter_list|)
block|{
name|node
operator|.
name|key
operator|=
name|Bytes
operator|.
name|copy
argument_list|(
name|result
operator|.
name|getRow
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|containsColumn
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_PREV
argument_list|)
condition|)
block|{
name|node
operator|.
name|prev
operator|=
name|Bytes
operator|.
name|copy
argument_list|(
name|result
operator|.
name|getValue
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_PREV
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|node
operator|.
name|prev
operator|=
name|NO_KEY
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|.
name|containsColumn
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_COUNT
argument_list|)
condition|)
block|{
name|node
operator|.
name|count
operator|=
name|Bytes
operator|.
name|toLong
argument_list|(
name|result
operator|.
name|getValue
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_COUNT
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|node
operator|.
name|count
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|.
name|containsColumn
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_CLIENT
argument_list|)
condition|)
block|{
name|node
operator|.
name|client
operator|=
name|Bytes
operator|.
name|toString
argument_list|(
name|result
operator|.
name|getValue
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_CLIENT
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|node
operator|.
name|client
operator|=
literal|""
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
specifier|protected
name|IntegrationTestingUtility
name|util
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|setUpCluster
parameter_list|()
throws|throws
name|Exception
block|{
name|util
operator|=
name|getTestingUtil
argument_list|(
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|isDistributed
init|=
name|util
operator|.
name|isDistributedCluster
argument_list|()
decl_stmt|;
name|util
operator|.
name|initializeCluster
argument_list|(
name|isDistributed
condition|?
literal|1
else|:
name|this
operator|.
name|NUM_SLAVES_BASE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isDistributed
condition|)
block|{
name|util
operator|.
name|startMiniMapReduceCluster
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|setConf
argument_list|(
name|util
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|cleanUpCluster
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|cleanUpCluster
argument_list|()
expr_stmt|;
if|if
condition|(
name|util
operator|.
name|isDistributedCluster
argument_list|()
condition|)
block|{
name|util
operator|.
name|shutdownMiniMapReduceCluster
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|boolean
name|isMultiUnevenColumnFamilies
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|getBoolean
argument_list|(
name|Generator
operator|.
name|MULTIPLE_UNEVEN_COLUMNFAMILIES_KEY
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testContinuousIngest
parameter_list|()
throws|throws
name|IOException
throws|,
name|Exception
block|{
comment|//Loop<num iterations><num mappers><num nodes per mapper><output dir><num reducers>
name|Configuration
name|conf
init|=
name|getTestingUtil
argument_list|(
name|getConf
argument_list|()
argument_list|)
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
if|if
condition|(
name|isMultiUnevenColumnFamilies
argument_list|(
name|getConf
argument_list|()
argument_list|)
condition|)
block|{
comment|// make sure per CF flush is on
name|conf
operator|.
name|set
argument_list|(
name|FlushPolicyFactory
operator|.
name|HBASE_FLUSH_POLICY_KEY
argument_list|,
name|FlushAllLargeStoresPolicy
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
name|ret
init|=
name|ToolRunner
operator|.
name|run
argument_list|(
name|conf
argument_list|,
operator|new
name|Loop
argument_list|()
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"1"
block|,
literal|"1"
block|,
literal|"2000000"
block|,
name|util
operator|.
name|getDataTestDirOnTestFS
argument_list|(
literal|"IntegrationTestBigLinkedList"
argument_list|)
operator|.
name|toString
argument_list|()
block|,
literal|"1"
block|}
argument_list|)
decl_stmt|;
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|usage
parameter_list|()
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Usage: "
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" COMMAND [COMMAND options]"
argument_list|)
expr_stmt|;
name|printCommands
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|printCommands
parameter_list|()
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Commands:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" generator  Map only job that generates data."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" verify     A map reduce job that looks for holes. Check return code and"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"            look at the counts after running. See REFERENCED and"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"            UNREFERENCED are ok. Any UNDEFINED counts are bad. Do not run"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"            with the Generator."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" walker     "
operator|+
literal|"Standalone program that starts following a linked list& emits timing info."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" print      Standalone program that prints nodes in the linked list."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" delete     Standalone program that deletes a single node."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" loop       Program to Loop through Generator and Verify steps"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" clean      Program to clean all left over detritus."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" search     Search for missing keys."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"General options:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" -D"
operator|+
name|TABLE_NAME_KEY
operator|+
literal|"=<tableName>"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"    Run using the<tableName> as the tablename.  Defaults to "
operator|+
name|DEFAULT_TABLE_NAME
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" -D"
operator|+
name|HBaseTestingUtility
operator|.
name|REGIONS_PER_SERVER_KEY
operator|+
literal|"=<# regions>"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"    Create table with presplit regions per server.  Defaults to "
operator|+
name|HBaseTestingUtility
operator|.
name|DEFAULT_REGIONS_PER_SERVER
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" -DuseMob=<true|false>"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"    Create table so that the mob read/write path is forced.  "
operator|+
literal|"Defaults to false"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|processOptions
parameter_list|(
name|CommandLine
name|cmd
parameter_list|)
block|{
name|super
operator|.
name|processOptions
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|String
index|[]
name|args
init|=
name|cmd
operator|.
name|getArgs
argument_list|()
decl_stmt|;
comment|//get the class, run with the conf
if|if
condition|(
name|args
operator|.
name|length
operator|<
literal|1
condition|)
block|{
name|printUsage
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"<general options> COMMAND [<COMMAND options>]"
argument_list|,
literal|"General options:"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printCommands
argument_list|()
expr_stmt|;
comment|// Have to throw an exception here to stop the processing. Looks ugly but gets message across.
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Incorrect Number of args."
argument_list|)
throw|;
block|}
name|toRun
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|otherArgs
operator|=
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|args
argument_list|,
literal|1
argument_list|,
name|args
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|runTestFromCommandLine
parameter_list|()
throws|throws
name|Exception
block|{
name|Tool
name|tool
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|toRun
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"Generator"
argument_list|)
condition|)
block|{
name|tool
operator|=
operator|new
name|Generator
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toRun
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"Verify"
argument_list|)
condition|)
block|{
name|tool
operator|=
operator|new
name|Verify
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toRun
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"Loop"
argument_list|)
condition|)
block|{
name|Loop
name|loop
init|=
operator|new
name|Loop
argument_list|()
decl_stmt|;
name|loop
operator|.
name|it
operator|=
name|this
expr_stmt|;
name|tool
operator|=
name|loop
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toRun
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"Walker"
argument_list|)
condition|)
block|{
name|tool
operator|=
operator|new
name|Walker
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toRun
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"Print"
argument_list|)
condition|)
block|{
name|tool
operator|=
operator|new
name|Print
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toRun
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"Delete"
argument_list|)
condition|)
block|{
name|tool
operator|=
operator|new
name|Delete
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toRun
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"Clean"
argument_list|)
condition|)
block|{
name|tool
operator|=
operator|new
name|Clean
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toRun
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"Search"
argument_list|)
condition|)
block|{
name|tool
operator|=
operator|new
name|Search
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|usage
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unknown arg"
argument_list|)
throw|;
block|}
return|return
name|ToolRunner
operator|.
name|run
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|tool
argument_list|,
name|otherArgs
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|TableName
name|getTablename
parameter_list|()
block|{
name|Configuration
name|c
init|=
name|getConf
argument_list|()
decl_stmt|;
return|return
name|TableName
operator|.
name|valueOf
argument_list|(
name|c
operator|.
name|get
argument_list|(
name|TABLE_NAME_KEY
argument_list|,
name|DEFAULT_TABLE_NAME
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|Set
argument_list|<
name|String
argument_list|>
name|getColumnFamilies
parameter_list|()
block|{
if|if
condition|(
name|isMultiUnevenColumnFamilies
argument_list|(
name|getConf
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|Sets
operator|.
name|newHashSet
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|FAMILY_NAME
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toString
argument_list|(
name|BIG_FAMILY_NAME
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toString
argument_list|(
name|TINY_FAMILY_NAME
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Sets
operator|.
name|newHashSet
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|FAMILY_NAME
argument_list|)
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
name|void
name|setJobConf
parameter_list|(
name|Job
name|job
parameter_list|,
name|int
name|numMappers
parameter_list|,
name|long
name|numNodes
parameter_list|,
name|Integer
name|width
parameter_list|,
name|Integer
name|wrapMultiplier
parameter_list|,
name|Integer
name|numWalkers
parameter_list|)
block|{
name|job
operator|.
name|getConfiguration
argument_list|()
operator|.
name|setInt
argument_list|(
name|GENERATOR_NUM_MAPPERS_KEY
argument_list|,
name|numMappers
argument_list|)
expr_stmt|;
name|job
operator|.
name|getConfiguration
argument_list|()
operator|.
name|setLong
argument_list|(
name|GENERATOR_NUM_ROWS_PER_MAP_KEY
argument_list|,
name|numNodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|!=
literal|null
condition|)
block|{
name|job
operator|.
name|getConfiguration
argument_list|()
operator|.
name|setInt
argument_list|(
name|GENERATOR_WIDTH_KEY
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrapMultiplier
operator|!=
literal|null
condition|)
block|{
name|job
operator|.
name|getConfiguration
argument_list|()
operator|.
name|setInt
argument_list|(
name|GENERATOR_WRAP_KEY
argument_list|,
name|wrapMultiplier
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numWalkers
operator|!=
literal|null
condition|)
block|{
name|job
operator|.
name|getConfiguration
argument_list|()
operator|.
name|setInt
argument_list|(
name|CONCURRENT_WALKER_KEY
argument_list|,
name|numWalkers
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|void
name|setJobScannerConf
parameter_list|(
name|Job
name|job
parameter_list|)
block|{
name|job
operator|.
name|getConfiguration
argument_list|()
operator|.
name|setInt
argument_list|(
name|TableRecordReaderImpl
operator|.
name|LOG_PER_ROW_COUNT
argument_list|,
literal|100000
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|Configuration
name|conf
init|=
name|HBaseConfiguration
operator|.
name|create
argument_list|()
decl_stmt|;
name|IntegrationTestingUtility
operator|.
name|setUseDistributedCluster
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|int
name|ret
init|=
name|ToolRunner
operator|.
name|run
argument_list|(
name|conf
argument_list|,
operator|new
name|IntegrationTestBigLinkedList
argument_list|()
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|System
operator|.
name|exit
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

