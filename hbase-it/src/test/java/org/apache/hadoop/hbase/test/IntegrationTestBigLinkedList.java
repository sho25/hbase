begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|test
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|CommandLine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|GnuParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|HelpFormatter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configured
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseTestingUtility
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HColumnDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|IntegrationTestBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|IntegrationTestingUtility
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MasterNotRunningException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Admin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|BufferedMutator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|BufferedMutatorParams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ConnectionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Get
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|HBaseAdmin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|HConnection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|HConnectionManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Put
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ResultScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Scan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ScannerCallable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|fs
operator|.
name|HFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|ImmutableBytesWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|mapreduce
operator|.
name|TableMapReduceUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|mapreduce
operator|.
name|TableMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|mapreduce
operator|.
name|TableRecordReaderImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|testclassification
operator|.
name|IntegrationTests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|AbstractHBaseTool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|RegionSplitter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|BytesWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|NullWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Counter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|CounterGroup
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Counters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|InputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|InputSplit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Job
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Mapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|RecordReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Reducer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskAttemptContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|FileInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|SequenceFileInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|output
operator|.
name|FileOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|output
operator|.
name|NullOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|output
operator|.
name|SequenceFileOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|output
operator|.
name|TextOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Tool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ToolRunner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|experimental
operator|.
name|categories
operator|.
name|Category
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_comment
comment|/**  * This is an integration test borrowed from goraci, written by Keith Turner,  * which is in turn inspired by the Accumulo test called continous ingest (ci).  * The original source code can be found here:  * https://github.com/keith-turner/goraci  * https://github.com/enis/goraci/  *  * Apache Accumulo [0] has a simple test suite that verifies that data is not  * lost at scale. This test suite is called continuous ingest. This test runs  * many ingest clients that continually create linked lists containing 25  * million nodes. At some point the clients are stopped and a map reduce job is  * run to ensure no linked list has a hole. A hole indicates data was lost.··  *  * The nodes in the linked list are random. This causes each linked list to  * spread across the table. Therefore if one part of a table loses data, then it  * will be detected by references in another part of the table.  *  * THE ANATOMY OF THE TEST  *  * Below is rough sketch of how data is written. For specific details look at  * the Generator code.  *  * 1 Write out 1 million nodes· 2 Flush the client· 3 Write out 1 million that  * reference previous million· 4 If this is the 25th set of 1 million nodes,  * then update 1st set of million to point to last· 5 goto 1  *  * The key is that nodes only reference flushed nodes. Therefore a node should  * never reference a missing node, even if the ingest client is killed at any  * point in time.  *  * When running this test suite w/ Accumulo there is a script running in  * parallel called the Aggitator that randomly and continuously kills server  * processes.·· The outcome was that many data loss bugs were found in Accumulo  * by doing this.· This test suite can also help find bugs that impact uptime  * and stability when· run for days or weeks.··  *  * This test suite consists the following· - a few Java programs· - a little  * helper script to run the java programs - a maven script to build it.··  *  * When generating data, its best to have each map task generate a multiple of  * 25 million. The reason for this is that circular linked list are generated  * every 25M. Not generating a multiple in 25M will result in some nodes in the  * linked list not having references. The loss of an unreferenced node can not  * be detected.  *  *  * Below is a description of the Java programs  *  * Generator - A map only job that generates data. As stated previously,·  * its best to generate data in multiples of 25M.  *  * Verify - A map reduce job that looks for holes. Look at the counts after running. REFERENCED and  * UNREFERENCED are· ok, any UNDEFINED counts are bad. Do not run at the· same  * time as the Generator.  *  * Walker - A standalone program that start following a linked list· and emits timing info.··  *  * Print - A standalone program that prints nodes in the linked list  *  * Delete - A standalone program that deletes a single node  *  * This class can be run as a unit test, as an integration test, or from the command line  */
end_comment

begin_class
annotation|@
name|Category
argument_list|(
name|IntegrationTests
operator|.
name|class
argument_list|)
specifier|public
class|class
name|IntegrationTestBigLinkedList
extends|extends
name|IntegrationTestBase
block|{
specifier|protected
specifier|static
specifier|final
name|byte
index|[]
name|NO_KEY
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
specifier|protected
specifier|static
name|String
name|TABLE_NAME_KEY
init|=
literal|"IntegrationTestBigLinkedList.table"
decl_stmt|;
specifier|protected
specifier|static
name|String
name|DEFAULT_TABLE_NAME
init|=
literal|"IntegrationTestBigLinkedList"
decl_stmt|;
specifier|protected
specifier|static
name|byte
index|[]
name|FAMILY_NAME
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"meta"
argument_list|)
decl_stmt|;
comment|//link to the id of the prev node in the linked list
specifier|protected
specifier|static
specifier|final
name|byte
index|[]
name|COLUMN_PREV
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"prev"
argument_list|)
decl_stmt|;
comment|//identifier of the mapred task that generated this row
specifier|protected
specifier|static
specifier|final
name|byte
index|[]
name|COLUMN_CLIENT
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"client"
argument_list|)
decl_stmt|;
comment|//the id of the row within the same client.
specifier|protected
specifier|static
specifier|final
name|byte
index|[]
name|COLUMN_COUNT
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"count"
argument_list|)
decl_stmt|;
comment|/** How many rows to write per map task. This has to be a multiple of 25M */
specifier|private
specifier|static
specifier|final
name|String
name|GENERATOR_NUM_ROWS_PER_MAP_KEY
init|=
literal|"IntegrationTestBigLinkedList.generator.num_rows"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|GENERATOR_NUM_MAPPERS_KEY
init|=
literal|"IntegrationTestBigLinkedList.generator.map.tasks"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|GENERATOR_WIDTH_KEY
init|=
literal|"IntegrationTestBigLinkedList.generator.width"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|GENERATOR_WRAP_KEY
init|=
literal|"IntegrationTestBigLinkedList.generator.wrap"
decl_stmt|;
specifier|protected
name|int
name|NUM_SLAVES_BASE
init|=
literal|3
decl_stmt|;
comment|// number of slaves for the cluster
specifier|private
specifier|static
specifier|final
name|int
name|MISSING_ROWS_TO_LOG
init|=
literal|50
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|WIDTH_DEFAULT
init|=
literal|1000000
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|WRAP_DEFAULT
init|=
literal|25
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|ROWKEY_LENGTH
init|=
literal|16
decl_stmt|;
specifier|protected
name|String
name|toRun
decl_stmt|;
specifier|protected
name|String
index|[]
name|otherArgs
decl_stmt|;
specifier|static
class|class
name|CINode
block|{
name|byte
index|[]
name|key
decl_stmt|;
name|byte
index|[]
name|prev
decl_stmt|;
name|String
name|client
decl_stmt|;
name|long
name|count
decl_stmt|;
block|}
comment|/**    * A Map only job that generates random linked list and stores them.    */
specifier|static
class|class
name|Generator
extends|extends
name|Configured
implements|implements
name|Tool
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|Generator
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|static
class|class
name|GeneratorInputFormat
extends|extends
name|InputFormat
argument_list|<
name|BytesWritable
argument_list|,
name|NullWritable
argument_list|>
block|{
specifier|static
class|class
name|GeneratorInputSplit
extends|extends
name|InputSplit
implements|implements
name|Writable
block|{
annotation|@
name|Override
specifier|public
name|long
name|getLength
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
literal|1
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
index|[]
name|getLocations
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
operator|new
name|String
index|[
literal|0
index|]
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|arg0
parameter_list|)
throws|throws
name|IOException
block|{         }
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|arg0
parameter_list|)
throws|throws
name|IOException
block|{         }
block|}
specifier|static
class|class
name|GeneratorRecordReader
extends|extends
name|RecordReader
argument_list|<
name|BytesWritable
argument_list|,
name|NullWritable
argument_list|>
block|{
specifier|private
name|long
name|count
decl_stmt|;
specifier|private
name|long
name|numNodes
decl_stmt|;
specifier|private
name|Random
name|rand
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{         }
annotation|@
name|Override
specifier|public
name|BytesWritable
name|getCurrentKey
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|ROWKEY_LENGTH
index|]
decl_stmt|;
name|rand
operator|.
name|nextBytes
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
return|return
operator|new
name|BytesWritable
argument_list|(
name|bytes
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|NullWritable
name|getCurrentValue
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|NullWritable
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|float
name|getProgress
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
call|(
name|float
call|)
argument_list|(
name|count
operator|/
operator|(
name|double
operator|)
name|numNodes
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|initialize
parameter_list|(
name|InputSplit
name|arg0
parameter_list|,
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|numNodes
operator|=
name|context
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getLong
argument_list|(
name|GENERATOR_NUM_ROWS_PER_MAP_KEY
argument_list|,
literal|25000000
argument_list|)
expr_stmt|;
name|rand
operator|=
operator|new
name|Random
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|nextKeyValue
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|count
operator|++
operator|<
name|numNodes
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|RecordReader
argument_list|<
name|BytesWritable
argument_list|,
name|NullWritable
argument_list|>
name|createRecordReader
parameter_list|(
name|InputSplit
name|split
parameter_list|,
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|GeneratorRecordReader
name|rr
init|=
operator|new
name|GeneratorRecordReader
argument_list|()
decl_stmt|;
name|rr
operator|.
name|initialize
argument_list|(
name|split
argument_list|,
name|context
argument_list|)
expr_stmt|;
return|return
name|rr
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|InputSplit
argument_list|>
name|getSplits
parameter_list|(
name|JobContext
name|job
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|int
name|numMappers
init|=
name|job
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|GENERATOR_NUM_MAPPERS_KEY
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|InputSplit
argument_list|>
name|splits
init|=
operator|new
name|ArrayList
argument_list|<
name|InputSplit
argument_list|>
argument_list|(
name|numMappers
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numMappers
condition|;
name|i
operator|++
control|)
block|{
name|splits
operator|.
name|add
argument_list|(
operator|new
name|GeneratorInputSplit
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|splits
return|;
block|}
block|}
comment|/** Ensure output files from prev-job go to map inputs for current job */
specifier|static
class|class
name|OneFilePerMapperSFIF
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|SequenceFileInputFormat
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
annotation|@
name|Override
specifier|protected
name|boolean
name|isSplitable
parameter_list|(
name|JobContext
name|context
parameter_list|,
name|Path
name|filename
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**      * Some ASCII art time:      * [ . . . ] represents one batch of random longs of length WIDTH      *      *                _________________________      *               |                  ______ |      *               |                 |      ||      *             .-+-----------------+-----.||      *             | |                 |     |||      * first   = [ . . . . . . . . . . . ]   |||      *             ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^     |||      *             | | | | | | | | | | |     |||      * prev    = [ . . . . . . . . . . . ]   |||      *             ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^     |||      *             | | | | | | | | | | |     |||      * current = [ . . . . . . . . . . . ]   |||      *                                       |||      * ...                                   |||      *                                       |||      * last    = [ . . . . . . . . . . . ]   |||      *             ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^_____|||      *             |                 |________||      *             |___________________________|      */
specifier|static
class|class
name|GeneratorMapper
extends|extends
name|Mapper
argument_list|<
name|BytesWritable
argument_list|,
name|NullWritable
argument_list|,
name|NullWritable
argument_list|,
name|NullWritable
argument_list|>
block|{
name|byte
index|[]
index|[]
name|first
init|=
literal|null
decl_stmt|;
name|byte
index|[]
index|[]
name|prev
init|=
literal|null
decl_stmt|;
name|byte
index|[]
index|[]
name|current
init|=
literal|null
decl_stmt|;
name|byte
index|[]
name|id
decl_stmt|;
name|long
name|count
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|BufferedMutator
name|mutator
decl_stmt|;
name|Connection
name|connection
decl_stmt|;
name|long
name|numNodes
decl_stmt|;
name|long
name|wrap
decl_stmt|;
name|int
name|width
decl_stmt|;
annotation|@
name|Override
specifier|protected
name|void
name|setup
parameter_list|(
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|id
operator|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"Job: "
operator|+
name|context
operator|.
name|getJobID
argument_list|()
operator|+
literal|" Task: "
operator|+
name|context
operator|.
name|getTaskAttemptID
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|connection
operator|=
name|ConnectionFactory
operator|.
name|createConnection
argument_list|(
name|context
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
name|instantiateHTable
argument_list|()
expr_stmt|;
name|this
operator|.
name|width
operator|=
name|context
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|GENERATOR_WIDTH_KEY
argument_list|,
name|WIDTH_DEFAULT
argument_list|)
expr_stmt|;
name|current
operator|=
operator|new
name|byte
index|[
name|this
operator|.
name|width
index|]
index|[]
expr_stmt|;
name|int
name|wrapMultiplier
init|=
name|context
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|GENERATOR_WRAP_KEY
argument_list|,
name|WRAP_DEFAULT
argument_list|)
decl_stmt|;
name|this
operator|.
name|wrap
operator|=
operator|(
name|long
operator|)
name|wrapMultiplier
operator|*
name|width
expr_stmt|;
name|this
operator|.
name|numNodes
operator|=
name|context
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getLong
argument_list|(
name|GENERATOR_NUM_ROWS_PER_MAP_KEY
argument_list|,
operator|(
name|long
operator|)
name|WIDTH_DEFAULT
operator|*
name|WRAP_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|numNodes
operator|<
name|this
operator|.
name|wrap
condition|)
block|{
name|this
operator|.
name|wrap
operator|=
name|this
operator|.
name|numNodes
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|instantiateHTable
parameter_list|()
throws|throws
name|IOException
block|{
name|mutator
operator|=
name|connection
operator|.
name|getBufferedMutator
argument_list|(
operator|new
name|BufferedMutatorParams
argument_list|(
name|getTableName
argument_list|(
name|connection
operator|.
name|getConfiguration
argument_list|()
argument_list|)
argument_list|)
operator|.
name|writeBufferSize
argument_list|(
literal|4
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|cleanup
parameter_list|(
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|mutator
operator|.
name|close
argument_list|()
expr_stmt|;
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|map
parameter_list|(
name|BytesWritable
name|key
parameter_list|,
name|NullWritable
name|value
parameter_list|,
name|Context
name|output
parameter_list|)
throws|throws
name|IOException
block|{
name|current
index|[
name|i
index|]
operator|=
operator|new
name|byte
index|[
name|key
operator|.
name|getLength
argument_list|()
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|key
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|current
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|current
operator|.
name|length
condition|)
block|{
name|persist
argument_list|(
name|output
argument_list|,
name|count
argument_list|,
name|prev
argument_list|,
name|current
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|first
operator|==
literal|null
condition|)
name|first
operator|=
name|current
expr_stmt|;
name|prev
operator|=
name|current
expr_stmt|;
name|current
operator|=
operator|new
name|byte
index|[
name|this
operator|.
name|width
index|]
index|[]
expr_stmt|;
name|count
operator|+=
name|current
operator|.
name|length
expr_stmt|;
name|output
operator|.
name|setStatus
argument_list|(
literal|"Count "
operator|+
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|%
name|wrap
operator|==
literal|0
condition|)
block|{
comment|// this block of code turns the 1 million linked list of length 25 into one giant
comment|//circular linked list of 25 million
name|circularLeftShift
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|persist
argument_list|(
name|output
argument_list|,
operator|-
literal|1
argument_list|,
name|prev
argument_list|,
name|first
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|first
operator|=
literal|null
expr_stmt|;
name|prev
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|void
name|circularLeftShift
parameter_list|(
name|T
index|[]
name|first
parameter_list|)
block|{
name|T
name|ez
init|=
name|first
index|[
literal|0
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|first
argument_list|,
literal|1
argument_list|,
name|first
argument_list|,
literal|0
argument_list|,
name|first
operator|.
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
name|first
index|[
name|first
operator|.
name|length
operator|-
literal|1
index|]
operator|=
name|ez
expr_stmt|;
block|}
specifier|protected
name|void
name|persist
parameter_list|(
name|Context
name|output
parameter_list|,
name|long
name|count
parameter_list|,
name|byte
index|[]
index|[]
name|prev
parameter_list|,
name|byte
index|[]
index|[]
name|current
parameter_list|,
name|byte
index|[]
name|id
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|current
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Put
name|put
init|=
operator|new
name|Put
argument_list|(
name|current
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|put
operator|.
name|add
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_PREV
argument_list|,
name|prev
operator|==
literal|null
condition|?
name|NO_KEY
else|:
name|prev
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
literal|0
condition|)
block|{
name|put
operator|.
name|add
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_COUNT
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|count
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|id
operator|!=
literal|null
condition|)
block|{
name|put
operator|.
name|add
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_CLIENT
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
name|mutator
operator|.
name|mutate
argument_list|(
name|put
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|1000
operator|==
literal|0
condition|)
block|{
comment|// Tickle progress every so often else maprunner will think us hung
name|output
operator|.
name|progress
argument_list|()
expr_stmt|;
block|}
block|}
name|mutator
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|args
operator|.
name|length
operator|<
literal|3
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Usage : "
operator|+
name|Generator
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"<num mappers><num nodes per map><tmp output dir> [<width><wrap multiplier>]"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"   where<num nodes per map> should be a multiple of "
operator|+
literal|" width*wrap multiplier, 25M by default"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|int
name|numMappers
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|long
name|numNodes
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|Path
name|tmpOutput
init|=
operator|new
name|Path
argument_list|(
name|args
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|Integer
name|width
init|=
operator|(
name|args
operator|.
name|length
operator|<
literal|4
operator|)
condition|?
literal|null
else|:
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
name|Integer
name|wrapMuplitplier
init|=
operator|(
name|args
operator|.
name|length
operator|<
literal|5
operator|)
condition|?
literal|null
else|:
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|4
index|]
argument_list|)
decl_stmt|;
return|return
name|run
argument_list|(
name|numMappers
argument_list|,
name|numNodes
argument_list|,
name|tmpOutput
argument_list|,
name|width
argument_list|,
name|wrapMuplitplier
argument_list|)
return|;
block|}
specifier|protected
name|void
name|createSchema
parameter_list|()
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|Admin
name|admin
init|=
operator|new
name|HBaseAdmin
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|TableName
name|tableName
init|=
name|getTableName
argument_list|(
name|conf
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|admin
operator|.
name|tableExists
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|HTableDescriptor
name|htd
init|=
operator|new
name|HTableDescriptor
argument_list|(
name|getTableName
argument_list|(
name|getConf
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|htd
operator|.
name|addFamily
argument_list|(
operator|new
name|HColumnDescriptor
argument_list|(
name|FAMILY_NAME
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|numberOfServers
init|=
name|admin
operator|.
name|getClusterStatus
argument_list|()
operator|.
name|getServers
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|numberOfServers
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"No live regionservers"
argument_list|)
throw|;
block|}
name|int
name|regionsPerServer
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|HBaseTestingUtility
operator|.
name|REGIONS_PER_SERVER_KEY
argument_list|,
name|HBaseTestingUtility
operator|.
name|DEFAULT_REGIONS_PER_SERVER
argument_list|)
decl_stmt|;
name|int
name|totalNumberOfRegions
init|=
name|numberOfServers
operator|*
name|regionsPerServer
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Number of live regionservers: "
operator|+
name|numberOfServers
operator|+
literal|", "
operator|+
literal|"pre-splitting table into "
operator|+
name|totalNumberOfRegions
operator|+
literal|" regions "
operator|+
literal|"(default regions per server: "
operator|+
name|regionsPerServer
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|byte
index|[]
index|[]
name|splits
init|=
operator|new
name|RegionSplitter
operator|.
name|UniformSplit
argument_list|()
operator|.
name|split
argument_list|(
name|totalNumberOfRegions
argument_list|)
decl_stmt|;
name|admin
operator|.
name|createTable
argument_list|(
name|htd
argument_list|,
name|splits
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|MasterNotRunningException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Master not running"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|admin
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|int
name|runRandomInputGenerator
parameter_list|(
name|int
name|numMappers
parameter_list|,
name|long
name|numNodes
parameter_list|,
name|Path
name|tmpOutput
parameter_list|,
name|Integer
name|width
parameter_list|,
name|Integer
name|wrapMuplitplier
parameter_list|)
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Running RandomInputGenerator with numMappers="
operator|+
name|numMappers
operator|+
literal|", numNodes="
operator|+
name|numNodes
argument_list|)
expr_stmt|;
name|Job
name|job
init|=
operator|new
name|Job
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|job
operator|.
name|setJobName
argument_list|(
literal|"Random Input Generator"
argument_list|)
expr_stmt|;
name|job
operator|.
name|setNumReduceTasks
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|job
operator|.
name|setJarByClass
argument_list|(
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|job
operator|.
name|setInputFormatClass
argument_list|(
name|GeneratorInputFormat
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputKeyClass
argument_list|(
name|BytesWritable
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputValueClass
argument_list|(
name|NullWritable
operator|.
name|class
argument_list|)
expr_stmt|;
name|setJobConf
argument_list|(
name|job
argument_list|,
name|numMappers
argument_list|,
name|numNodes
argument_list|,
name|width
argument_list|,
name|wrapMuplitplier
argument_list|)
expr_stmt|;
name|job
operator|.
name|setMapperClass
argument_list|(
name|Mapper
operator|.
name|class
argument_list|)
expr_stmt|;
comment|//identity mapper
name|FileOutputFormat
operator|.
name|setOutputPath
argument_list|(
name|job
argument_list|,
name|tmpOutput
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputFormatClass
argument_list|(
name|SequenceFileOutputFormat
operator|.
name|class
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
name|jobCompletion
argument_list|(
name|job
argument_list|)
decl_stmt|;
return|return
name|success
condition|?
literal|0
else|:
literal|1
return|;
block|}
specifier|public
name|int
name|runGenerator
parameter_list|(
name|int
name|numMappers
parameter_list|,
name|long
name|numNodes
parameter_list|,
name|Path
name|tmpOutput
parameter_list|,
name|Integer
name|width
parameter_list|,
name|Integer
name|wrapMuplitplier
parameter_list|)
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Running Generator with numMappers="
operator|+
name|numMappers
operator|+
literal|", numNodes="
operator|+
name|numNodes
argument_list|)
expr_stmt|;
name|createSchema
argument_list|()
expr_stmt|;
name|Job
name|job
init|=
operator|new
name|Job
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|job
operator|.
name|setJobName
argument_list|(
literal|"Link Generator"
argument_list|)
expr_stmt|;
name|job
operator|.
name|setNumReduceTasks
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|job
operator|.
name|setJarByClass
argument_list|(
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|tmpOutput
argument_list|)
expr_stmt|;
name|job
operator|.
name|setInputFormatClass
argument_list|(
name|OneFilePerMapperSFIF
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputKeyClass
argument_list|(
name|NullWritable
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputValueClass
argument_list|(
name|NullWritable
operator|.
name|class
argument_list|)
expr_stmt|;
name|setJobConf
argument_list|(
name|job
argument_list|,
name|numMappers
argument_list|,
name|numNodes
argument_list|,
name|width
argument_list|,
name|wrapMuplitplier
argument_list|)
expr_stmt|;
name|setMapperForGenerator
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputFormatClass
argument_list|(
name|NullOutputFormat
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|getConfiguration
argument_list|()
operator|.
name|setBoolean
argument_list|(
literal|"mapreduce.map.speculative"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|TableMapReduceUtil
operator|.
name|addDependencyJars
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|TableMapReduceUtil
operator|.
name|addDependencyJars
argument_list|(
name|job
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|AbstractHBaseTool
operator|.
name|class
argument_list|)
expr_stmt|;
name|TableMapReduceUtil
operator|.
name|initCredentials
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
name|jobCompletion
argument_list|(
name|job
argument_list|)
decl_stmt|;
return|return
name|success
condition|?
literal|0
else|:
literal|1
return|;
block|}
specifier|protected
name|boolean
name|jobCompletion
parameter_list|(
name|Job
name|job
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|ClassNotFoundException
block|{
name|boolean
name|success
init|=
name|job
operator|.
name|waitForCompletion
argument_list|(
literal|true
argument_list|)
decl_stmt|;
return|return
name|success
return|;
block|}
specifier|protected
name|void
name|setMapperForGenerator
parameter_list|(
name|Job
name|job
parameter_list|)
block|{
name|job
operator|.
name|setMapperClass
argument_list|(
name|GeneratorMapper
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
name|run
parameter_list|(
name|int
name|numMappers
parameter_list|,
name|long
name|numNodes
parameter_list|,
name|Path
name|tmpOutput
parameter_list|,
name|Integer
name|width
parameter_list|,
name|Integer
name|wrapMuplitplier
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|ret
init|=
name|runRandomInputGenerator
argument_list|(
name|numMappers
argument_list|,
name|numNodes
argument_list|,
name|tmpOutput
argument_list|,
name|width
argument_list|,
name|wrapMuplitplier
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
return|return
name|ret
return|;
block|}
return|return
name|runGenerator
argument_list|(
name|numMappers
argument_list|,
name|numNodes
argument_list|,
name|tmpOutput
argument_list|,
name|width
argument_list|,
name|wrapMuplitplier
argument_list|)
return|;
block|}
block|}
comment|/**    * A Map Reduce job that verifies that the linked lists generated by    * {@link Generator} do not have any holes.    */
specifier|static
class|class
name|Verify
extends|extends
name|Configured
implements|implements
name|Tool
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|Verify
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|BytesWritable
name|DEF
init|=
operator|new
name|BytesWritable
argument_list|(
name|NO_KEY
argument_list|)
decl_stmt|;
specifier|protected
name|Job
name|job
decl_stmt|;
specifier|public
specifier|static
class|class
name|VerifyMapper
extends|extends
name|TableMapper
argument_list|<
name|BytesWritable
argument_list|,
name|BytesWritable
argument_list|>
block|{
specifier|private
name|BytesWritable
name|row
init|=
operator|new
name|BytesWritable
argument_list|()
decl_stmt|;
specifier|private
name|BytesWritable
name|ref
init|=
operator|new
name|BytesWritable
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|protected
name|void
name|map
parameter_list|(
name|ImmutableBytesWritable
name|key
parameter_list|,
name|Result
name|value
parameter_list|,
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|byte
index|[]
name|rowKey
init|=
name|key
operator|.
name|get
argument_list|()
decl_stmt|;
name|row
operator|.
name|set
argument_list|(
name|rowKey
argument_list|,
literal|0
argument_list|,
name|rowKey
operator|.
name|length
argument_list|)
expr_stmt|;
name|context
operator|.
name|write
argument_list|(
name|row
argument_list|,
name|DEF
argument_list|)
expr_stmt|;
name|byte
index|[]
name|prev
init|=
name|value
operator|.
name|getValue
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_PREV
argument_list|)
decl_stmt|;
if|if
condition|(
name|prev
operator|!=
literal|null
operator|&&
name|prev
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|ref
operator|.
name|set
argument_list|(
name|prev
argument_list|,
literal|0
argument_list|,
name|prev
operator|.
name|length
argument_list|)
expr_stmt|;
name|context
operator|.
name|write
argument_list|(
name|ref
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Prev is not set for: %s"
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|rowKey
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
specifier|static
enum|enum
name|Counts
block|{
name|UNREFERENCED
block|,
name|UNDEFINED
block|,
name|REFERENCED
block|,
name|CORRUPT
block|,
name|EXTRAREFERENCES
block|}
specifier|public
specifier|static
class|class
name|VerifyReducer
extends|extends
name|Reducer
argument_list|<
name|BytesWritable
argument_list|,
name|BytesWritable
argument_list|,
name|Text
argument_list|,
name|Text
argument_list|>
block|{
specifier|private
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
name|refs
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|AtomicInteger
name|rows
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|reduce
parameter_list|(
name|BytesWritable
name|key
parameter_list|,
name|Iterable
argument_list|<
name|BytesWritable
argument_list|>
name|values
parameter_list|,
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|int
name|defCount
init|=
literal|0
decl_stmt|;
name|refs
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|BytesWritable
name|type
range|:
name|values
control|)
block|{
if|if
condition|(
name|type
operator|.
name|getLength
argument_list|()
operator|==
name|DEF
operator|.
name|getLength
argument_list|()
condition|)
block|{
name|defCount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|type
operator|.
name|getLength
argument_list|()
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|type
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|,
name|type
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|refs
operator|.
name|add
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO check for more than one def, should not happen
name|StringBuilder
name|refsSb
init|=
literal|null
decl_stmt|;
name|String
name|keyString
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|defCount
operator|==
literal|0
operator|||
name|refs
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|refsSb
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
name|String
name|comma
init|=
literal|""
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|ref
range|:
name|refs
control|)
block|{
name|refsSb
operator|.
name|append
argument_list|(
name|comma
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|","
expr_stmt|;
name|refsSb
operator|.
name|append
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|keyString
operator|=
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|key
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Linked List error: Key = "
operator|+
name|keyString
operator|+
literal|" References = "
operator|+
name|refsSb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|defCount
operator|==
literal|0
operator|&&
name|refs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// this is bad, found a node that is referenced but not defined. It must have been
comment|// lost, emit some info about this node for debugging purposes.
name|context
operator|.
name|write
argument_list|(
operator|new
name|Text
argument_list|(
name|keyString
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
name|refsSb
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|getCounter
argument_list|(
name|Counts
operator|.
name|UNDEFINED
argument_list|)
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rows
operator|.
name|addAndGet
argument_list|(
literal|1
argument_list|)
operator|<
name|MISSING_ROWS_TO_LOG
condition|)
block|{
name|context
operator|.
name|getCounter
argument_list|(
literal|"undef"
argument_list|,
name|keyString
argument_list|)
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|defCount
operator|>
literal|0
operator|&&
name|refs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// node is defined but not referenced
name|context
operator|.
name|write
argument_list|(
operator|new
name|Text
argument_list|(
name|keyString
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
literal|"none"
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|getCounter
argument_list|(
name|Counts
operator|.
name|UNREFERENCED
argument_list|)
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rows
operator|.
name|addAndGet
argument_list|(
literal|1
argument_list|)
operator|<
name|MISSING_ROWS_TO_LOG
condition|)
block|{
name|context
operator|.
name|getCounter
argument_list|(
literal|"unref"
argument_list|,
name|keyString
argument_list|)
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|refs
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|refsSb
operator|!=
literal|null
condition|)
block|{
name|context
operator|.
name|write
argument_list|(
operator|new
name|Text
argument_list|(
name|keyString
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
name|refsSb
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|context
operator|.
name|getCounter
argument_list|(
name|Counts
operator|.
name|EXTRAREFERENCES
argument_list|)
operator|.
name|increment
argument_list|(
name|refs
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// node is defined and referenced
name|context
operator|.
name|getCounter
argument_list|(
name|Counts
operator|.
name|REFERENCED
argument_list|)
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|args
operator|.
name|length
operator|!=
literal|2
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Usage : "
operator|+
name|Verify
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"<output dir><num reducers>"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|String
name|outputDir
init|=
name|args
index|[
literal|0
index|]
decl_stmt|;
name|int
name|numReducers
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
return|return
name|run
argument_list|(
name|outputDir
argument_list|,
name|numReducers
argument_list|)
return|;
block|}
specifier|public
name|int
name|run
parameter_list|(
name|String
name|outputDir
parameter_list|,
name|int
name|numReducers
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|run
argument_list|(
operator|new
name|Path
argument_list|(
name|outputDir
argument_list|)
argument_list|,
name|numReducers
argument_list|)
return|;
block|}
specifier|public
name|int
name|run
parameter_list|(
name|Path
name|outputDir
parameter_list|,
name|int
name|numReducers
parameter_list|)
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Running Verify with outputDir="
operator|+
name|outputDir
operator|+
literal|", numReducers="
operator|+
name|numReducers
argument_list|)
expr_stmt|;
name|job
operator|=
operator|new
name|Job
argument_list|(
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
name|job
operator|.
name|setJobName
argument_list|(
literal|"Link Verifier"
argument_list|)
expr_stmt|;
name|job
operator|.
name|setNumReduceTasks
argument_list|(
name|numReducers
argument_list|)
expr_stmt|;
name|job
operator|.
name|setJarByClass
argument_list|(
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|setJobScannerConf
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|Scan
name|scan
init|=
operator|new
name|Scan
argument_list|()
decl_stmt|;
name|scan
operator|.
name|addColumn
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_PREV
argument_list|)
expr_stmt|;
name|scan
operator|.
name|setCaching
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|scan
operator|.
name|setCacheBlocks
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|TableMapReduceUtil
operator|.
name|initTableMapperJob
argument_list|(
name|getTableName
argument_list|(
name|getConf
argument_list|()
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|,
name|scan
argument_list|,
name|VerifyMapper
operator|.
name|class
argument_list|,
name|BytesWritable
operator|.
name|class
argument_list|,
name|BytesWritable
operator|.
name|class
argument_list|,
name|job
argument_list|)
expr_stmt|;
name|TableMapReduceUtil
operator|.
name|addDependencyJars
argument_list|(
name|job
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|AbstractHBaseTool
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|getConfiguration
argument_list|()
operator|.
name|setBoolean
argument_list|(
literal|"mapreduce.map.speculative"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|job
operator|.
name|setReducerClass
argument_list|(
name|VerifyReducer
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputFormatClass
argument_list|(
name|TextOutputFormat
operator|.
name|class
argument_list|)
expr_stmt|;
name|TextOutputFormat
operator|.
name|setOutputPath
argument_list|(
name|job
argument_list|,
name|outputDir
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
name|job
operator|.
name|waitForCompletion
argument_list|(
literal|true
argument_list|)
decl_stmt|;
return|return
name|success
condition|?
literal|0
else|:
literal|1
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|public
name|boolean
name|verify
parameter_list|(
name|long
name|expectedReferenced
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|job
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"You should call run() first"
argument_list|)
throw|;
block|}
name|Counters
name|counters
init|=
name|job
operator|.
name|getCounters
argument_list|()
decl_stmt|;
name|Counter
name|referenced
init|=
name|counters
operator|.
name|findCounter
argument_list|(
name|Counts
operator|.
name|REFERENCED
argument_list|)
decl_stmt|;
name|Counter
name|unreferenced
init|=
name|counters
operator|.
name|findCounter
argument_list|(
name|Counts
operator|.
name|UNREFERENCED
argument_list|)
decl_stmt|;
name|Counter
name|undefined
init|=
name|counters
operator|.
name|findCounter
argument_list|(
name|Counts
operator|.
name|UNDEFINED
argument_list|)
decl_stmt|;
name|Counter
name|multiref
init|=
name|counters
operator|.
name|findCounter
argument_list|(
name|Counts
operator|.
name|EXTRAREFERENCES
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|true
decl_stmt|;
comment|//assert
if|if
condition|(
name|expectedReferenced
operator|!=
name|referenced
operator|.
name|getValue
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Expected referenced count does not match with actual referenced count. "
operator|+
literal|"expected referenced="
operator|+
name|expectedReferenced
operator|+
literal|" ,actual="
operator|+
name|referenced
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|success
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|unreferenced
operator|.
name|getValue
argument_list|()
operator|>
literal|0
condition|)
block|{
name|boolean
name|couldBeMultiRef
init|=
operator|(
name|multiref
operator|.
name|getValue
argument_list|()
operator|==
name|unreferenced
operator|.
name|getValue
argument_list|()
operator|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Unreferenced nodes were not expected. Unreferenced count="
operator|+
name|unreferenced
operator|.
name|getValue
argument_list|()
operator|+
operator|(
name|couldBeMultiRef
condition|?
literal|"; could be due to duplicate random numbers"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|success
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|undefined
operator|.
name|getValue
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Found an undefined node. Undefined count="
operator|+
name|undefined
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|success
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|handleFailure
argument_list|(
name|counters
argument_list|)
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
specifier|protected
name|void
name|handleFailure
parameter_list|(
name|Counters
name|counters
parameter_list|)
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
name|job
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|HConnection
name|conn
init|=
name|HConnectionManager
operator|.
name|getConnection
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|TableName
name|tableName
init|=
name|getTableName
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|CounterGroup
name|g
init|=
name|counters
operator|.
name|getGroup
argument_list|(
literal|"undef"
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|Counter
argument_list|>
name|it
init|=
name|g
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|keyString
init|=
name|it
operator|.
name|next
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|byte
index|[]
name|key
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|keyString
argument_list|)
decl_stmt|;
name|HRegionLocation
name|loc
init|=
name|conn
operator|.
name|relocateRegion
argument_list|(
name|tableName
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"undefined row "
operator|+
name|keyString
operator|+
literal|", "
operator|+
name|loc
argument_list|)
expr_stmt|;
block|}
name|g
operator|=
name|counters
operator|.
name|getGroup
argument_list|(
literal|"unref"
argument_list|)
expr_stmt|;
name|it
operator|=
name|g
operator|.
name|iterator
argument_list|()
expr_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|keyString
init|=
name|it
operator|.
name|next
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|byte
index|[]
name|key
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|keyString
argument_list|)
decl_stmt|;
name|HRegionLocation
name|loc
init|=
name|conn
operator|.
name|relocateRegion
argument_list|(
name|tableName
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"unreferred row "
operator|+
name|keyString
operator|+
literal|", "
operator|+
name|loc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Executes Generate and Verify in a loop. Data is not cleaned between runs, so each iteration    * adds more data.    */
specifier|static
class|class
name|Loop
extends|extends
name|Configured
implements|implements
name|Tool
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|Loop
operator|.
name|class
argument_list|)
decl_stmt|;
name|IntegrationTestBigLinkedList
name|it
decl_stmt|;
specifier|protected
name|void
name|runGenerator
parameter_list|(
name|int
name|numMappers
parameter_list|,
name|long
name|numNodes
parameter_list|,
name|String
name|outputDir
parameter_list|,
name|Integer
name|width
parameter_list|,
name|Integer
name|wrapMuplitplier
parameter_list|)
throws|throws
name|Exception
block|{
name|Path
name|outputPath
init|=
operator|new
name|Path
argument_list|(
name|outputDir
argument_list|)
decl_stmt|;
name|UUID
name|uuid
init|=
name|UUID
operator|.
name|randomUUID
argument_list|()
decl_stmt|;
comment|//create a random UUID.
name|Path
name|generatorOutput
init|=
operator|new
name|Path
argument_list|(
name|outputPath
argument_list|,
name|uuid
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Generator
name|generator
init|=
operator|new
name|Generator
argument_list|()
decl_stmt|;
name|generator
operator|.
name|setConf
argument_list|(
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|retCode
init|=
name|generator
operator|.
name|run
argument_list|(
name|numMappers
argument_list|,
name|numNodes
argument_list|,
name|generatorOutput
argument_list|,
name|width
argument_list|,
name|wrapMuplitplier
argument_list|)
decl_stmt|;
if|if
condition|(
name|retCode
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Generator failed with return code: "
operator|+
name|retCode
argument_list|)
throw|;
block|}
block|}
specifier|protected
name|void
name|runVerify
parameter_list|(
name|String
name|outputDir
parameter_list|,
name|int
name|numReducers
parameter_list|,
name|long
name|expectedNumNodes
parameter_list|)
throws|throws
name|Exception
block|{
name|Path
name|outputPath
init|=
operator|new
name|Path
argument_list|(
name|outputDir
argument_list|)
decl_stmt|;
name|UUID
name|uuid
init|=
name|UUID
operator|.
name|randomUUID
argument_list|()
decl_stmt|;
comment|//create a random UUID.
name|Path
name|iterationOutput
init|=
operator|new
name|Path
argument_list|(
name|outputPath
argument_list|,
name|uuid
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Verify
name|verify
init|=
operator|new
name|Verify
argument_list|()
decl_stmt|;
name|verify
operator|.
name|setConf
argument_list|(
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|retCode
init|=
name|verify
operator|.
name|run
argument_list|(
name|iterationOutput
argument_list|,
name|numReducers
argument_list|)
decl_stmt|;
if|if
condition|(
name|retCode
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Verify.run failed with return code: "
operator|+
name|retCode
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|verify
operator|.
name|verify
argument_list|(
name|expectedNumNodes
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Verify.verify failed"
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Verify finished with succees. Total nodes="
operator|+
name|expectedNumNodes
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|args
operator|.
name|length
operator|<
literal|5
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Usage: Loop<num iterations><num mappers><num nodes per mapper><output dir><num reducers> [<width><wrap multiplier>]"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Running Loop with args:"
operator|+
name|Arrays
operator|.
name|deepToString
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|numIterations
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|numMappers
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|long
name|numNodes
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|args
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|String
name|outputDir
init|=
name|args
index|[
literal|3
index|]
decl_stmt|;
name|int
name|numReducers
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|4
index|]
argument_list|)
decl_stmt|;
name|Integer
name|width
init|=
operator|(
name|args
operator|.
name|length
operator|<
literal|6
operator|)
condition|?
literal|null
else|:
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|5
index|]
argument_list|)
decl_stmt|;
name|Integer
name|wrapMuplitplier
init|=
operator|(
name|args
operator|.
name|length
operator|<
literal|7
operator|)
condition|?
literal|null
else|:
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|6
index|]
argument_list|)
decl_stmt|;
name|long
name|expectedNumNodes
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|numIterations
operator|<
literal|0
condition|)
block|{
name|numIterations
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
comment|//run indefinitely (kind of)
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numIterations
condition|;
name|i
operator|++
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting iteration = "
operator|+
name|i
argument_list|)
expr_stmt|;
name|runGenerator
argument_list|(
name|numMappers
argument_list|,
name|numNodes
argument_list|,
name|outputDir
argument_list|,
name|width
argument_list|,
name|wrapMuplitplier
argument_list|)
expr_stmt|;
name|expectedNumNodes
operator|+=
name|numMappers
operator|*
name|numNodes
expr_stmt|;
name|runVerify
argument_list|(
name|outputDir
argument_list|,
name|numReducers
argument_list|,
name|expectedNumNodes
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
block|}
comment|/**    * A stand alone program that prints out portions of a list created by {@link Generator}    */
specifier|private
specifier|static
class|class
name|Print
extends|extends
name|Configured
implements|implements
name|Tool
block|{
annotation|@
name|Override
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|Options
name|options
init|=
operator|new
name|Options
argument_list|()
decl_stmt|;
name|options
operator|.
name|addOption
argument_list|(
literal|"s"
argument_list|,
literal|"start"
argument_list|,
literal|true
argument_list|,
literal|"start key"
argument_list|)
expr_stmt|;
name|options
operator|.
name|addOption
argument_list|(
literal|"e"
argument_list|,
literal|"end"
argument_list|,
literal|true
argument_list|,
literal|"end key"
argument_list|)
expr_stmt|;
name|options
operator|.
name|addOption
argument_list|(
literal|"l"
argument_list|,
literal|"limit"
argument_list|,
literal|true
argument_list|,
literal|"number to print"
argument_list|)
expr_stmt|;
name|GnuParser
name|parser
init|=
operator|new
name|GnuParser
argument_list|()
decl_stmt|;
name|CommandLine
name|cmd
init|=
literal|null
decl_stmt|;
try|try
block|{
name|cmd
operator|=
name|parser
operator|.
name|parse
argument_list|(
name|options
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|.
name|getArgs
argument_list|()
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"Command takes no arguments"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Failed to parse command line "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|()
expr_stmt|;
name|HelpFormatter
name|formatter
init|=
operator|new
name|HelpFormatter
argument_list|()
decl_stmt|;
name|formatter
operator|.
name|printHelp
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|Connection
name|connection
init|=
name|ConnectionFactory
operator|.
name|createConnection
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|Table
name|table
init|=
name|connection
operator|.
name|getTable
argument_list|(
name|getTableName
argument_list|(
name|getConf
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|Scan
name|scan
init|=
operator|new
name|Scan
argument_list|()
decl_stmt|;
name|scan
operator|.
name|setBatch
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"s"
argument_list|)
condition|)
name|scan
operator|.
name|setStartRow
argument_list|(
name|Bytes
operator|.
name|toBytesBinary
argument_list|(
name|cmd
operator|.
name|getOptionValue
argument_list|(
literal|"s"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"e"
argument_list|)
condition|)
name|scan
operator|.
name|setStopRow
argument_list|(
name|Bytes
operator|.
name|toBytesBinary
argument_list|(
name|cmd
operator|.
name|getOptionValue
argument_list|(
literal|"e"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|limit
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cmd
operator|.
name|hasOption
argument_list|(
literal|"l"
argument_list|)
condition|)
name|limit
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|cmd
operator|.
name|getOptionValue
argument_list|(
literal|"l"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|limit
operator|=
literal|100
expr_stmt|;
name|ResultScanner
name|scanner
init|=
name|table
operator|.
name|getScanner
argument_list|(
name|scan
argument_list|)
decl_stmt|;
name|CINode
name|node
init|=
operator|new
name|CINode
argument_list|()
decl_stmt|;
name|Result
name|result
init|=
name|scanner
operator|.
name|next
argument_list|()
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|result
operator|!=
literal|null
operator|&&
name|count
operator|++
operator|<
name|limit
condition|)
block|{
name|node
operator|=
name|getCINode
argument_list|(
name|result
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|printf
argument_list|(
literal|"%s:%s:%012d:%s\n"
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|node
operator|.
name|key
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|node
operator|.
name|prev
argument_list|)
argument_list|,
name|node
operator|.
name|count
argument_list|,
name|node
operator|.
name|client
argument_list|)
expr_stmt|;
name|result
operator|=
name|scanner
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
name|scanner
operator|.
name|close
argument_list|()
expr_stmt|;
name|table
operator|.
name|close
argument_list|()
expr_stmt|;
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/**    * A stand alone program that deletes a single node.    */
specifier|private
specifier|static
class|class
name|Delete
extends|extends
name|Configured
implements|implements
name|Tool
block|{
annotation|@
name|Override
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|args
operator|.
name|length
operator|!=
literal|1
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Usage : "
operator|+
name|Delete
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"<node to delete>"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|byte
index|[]
name|val
init|=
name|Bytes
operator|.
name|toBytesBinary
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Delete
name|delete
init|=
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Delete
argument_list|(
name|val
argument_list|)
decl_stmt|;
try|try
init|(
name|Connection
name|connection
init|=
name|ConnectionFactory
operator|.
name|createConnection
argument_list|(
name|getConf
argument_list|()
argument_list|)
init|;
name|Table
name|table
operator|=
name|connection
operator|.
name|getTable
argument_list|(
name|getTableName
argument_list|(
name|getConf
argument_list|()
argument_list|)
argument_list|)
init|)
block|{
name|table
operator|.
name|delete
argument_list|(
name|delete
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Delete successful"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/**    * A stand alone program that follows a linked list created by {@link Generator} and prints timing info.    */
specifier|private
specifier|static
class|class
name|Walker
extends|extends
name|Configured
implements|implements
name|Tool
block|{
annotation|@
name|Override
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|IOException
block|{
name|Options
name|options
init|=
operator|new
name|Options
argument_list|()
decl_stmt|;
name|options
operator|.
name|addOption
argument_list|(
literal|"n"
argument_list|,
literal|"num"
argument_list|,
literal|true
argument_list|,
literal|"number of queries"
argument_list|)
expr_stmt|;
name|options
operator|.
name|addOption
argument_list|(
literal|"s"
argument_list|,
literal|"start"
argument_list|,
literal|true
argument_list|,
literal|"key to start at, binary string"
argument_list|)
expr_stmt|;
name|options
operator|.
name|addOption
argument_list|(
literal|"l"
argument_list|,
literal|"logevery"
argument_list|,
literal|true
argument_list|,
literal|"log every N queries"
argument_list|)
expr_stmt|;
name|GnuParser
name|parser
init|=
operator|new
name|GnuParser
argument_list|()
decl_stmt|;
name|CommandLine
name|cmd
init|=
literal|null
decl_stmt|;
try|try
block|{
name|cmd
operator|=
name|parser
operator|.
name|parse
argument_list|(
name|options
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|.
name|getArgs
argument_list|()
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|ParseException
argument_list|(
literal|"Command takes no arguments"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Failed to parse command line "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|()
expr_stmt|;
name|HelpFormatter
name|formatter
init|=
operator|new
name|HelpFormatter
argument_list|()
decl_stmt|;
name|formatter
operator|.
name|printHelp
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|long
name|maxQueries
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
if|if
condition|(
name|cmd
operator|.
name|hasOption
argument_list|(
literal|'n'
argument_list|)
condition|)
block|{
name|maxQueries
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|cmd
operator|.
name|getOptionValue
argument_list|(
literal|"n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
name|boolean
name|isSpecificStart
init|=
name|cmd
operator|.
name|hasOption
argument_list|(
literal|'s'
argument_list|)
decl_stmt|;
name|byte
index|[]
name|startKey
init|=
name|isSpecificStart
condition|?
name|Bytes
operator|.
name|toBytesBinary
argument_list|(
name|cmd
operator|.
name|getOptionValue
argument_list|(
literal|'s'
argument_list|)
argument_list|)
else|:
literal|null
decl_stmt|;
name|int
name|logEvery
init|=
name|cmd
operator|.
name|hasOption
argument_list|(
literal|'l'
argument_list|)
condition|?
name|Integer
operator|.
name|parseInt
argument_list|(
name|cmd
operator|.
name|getOptionValue
argument_list|(
literal|'l'
argument_list|)
argument_list|)
else|:
literal|1
decl_stmt|;
name|Connection
name|connection
init|=
name|ConnectionFactory
operator|.
name|createConnection
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|Table
name|table
init|=
name|connection
operator|.
name|getTable
argument_list|(
name|getTableName
argument_list|(
name|getConf
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|numQueries
init|=
literal|0
decl_stmt|;
comment|// If isSpecificStart is set, only walk one list from that particular node.
comment|// Note that in case of circular (or P-shaped) list it will walk forever, as is
comment|// the case in normal run without startKey.
while|while
condition|(
name|numQueries
operator|<
name|maxQueries
operator|&&
operator|(
name|numQueries
operator|==
literal|0
operator|||
operator|!
name|isSpecificStart
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|isSpecificStart
condition|)
block|{
name|startKey
operator|=
operator|new
name|byte
index|[
name|ROWKEY_LENGTH
index|]
expr_stmt|;
name|rand
operator|.
name|nextBytes
argument_list|(
name|startKey
argument_list|)
expr_stmt|;
block|}
name|CINode
name|node
init|=
name|findStartNode
argument_list|(
name|table
argument_list|,
name|startKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
operator|&&
name|isSpecificStart
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|printf
argument_list|(
literal|"Start node not found: %s \n"
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|startKey
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|numQueries
operator|++
expr_stmt|;
while|while
condition|(
name|node
operator|!=
literal|null
operator|&&
name|node
operator|.
name|prev
operator|.
name|length
operator|!=
name|NO_KEY
operator|.
name|length
operator|&&
name|numQueries
operator|<
name|maxQueries
condition|)
block|{
name|byte
index|[]
name|prev
init|=
name|node
operator|.
name|prev
decl_stmt|;
name|long
name|t1
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|node
operator|=
name|getNode
argument_list|(
name|prev
argument_list|,
name|table
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|long
name|t2
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|numQueries
operator|%
name|logEvery
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|printf
argument_list|(
literal|"CQ %d: %d %s \n"
argument_list|,
name|numQueries
argument_list|,
name|t2
operator|-
name|t1
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|prev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|numQueries
operator|++
expr_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|printf
argument_list|(
literal|"UNDEFINED NODE %s \n"
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|prev
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|prev
operator|.
name|length
operator|==
name|NO_KEY
operator|.
name|length
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|printf
argument_list|(
literal|"TERMINATING NODE %s \n"
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|node
operator|.
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|table
operator|.
name|close
argument_list|()
expr_stmt|;
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|private
specifier|static
name|CINode
name|findStartNode
parameter_list|(
name|Table
name|table
parameter_list|,
name|byte
index|[]
name|startKey
parameter_list|)
throws|throws
name|IOException
block|{
name|Scan
name|scan
init|=
operator|new
name|Scan
argument_list|()
decl_stmt|;
name|scan
operator|.
name|setStartRow
argument_list|(
name|startKey
argument_list|)
expr_stmt|;
name|scan
operator|.
name|setBatch
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|scan
operator|.
name|addColumn
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_PREV
argument_list|)
expr_stmt|;
name|long
name|t1
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|ResultScanner
name|scanner
init|=
name|table
operator|.
name|getScanner
argument_list|(
name|scan
argument_list|)
decl_stmt|;
name|Result
name|result
init|=
name|scanner
operator|.
name|next
argument_list|()
decl_stmt|;
name|long
name|t2
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|scanner
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
name|CINode
name|node
init|=
name|getCINode
argument_list|(
name|result
argument_list|,
operator|new
name|CINode
argument_list|()
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|printf
argument_list|(
literal|"FSR %d %s\n"
argument_list|,
name|t2
operator|-
name|t1
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|node
operator|.
name|key
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"FSR "
operator|+
operator|(
name|t2
operator|-
name|t1
operator|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|private
name|CINode
name|getNode
parameter_list|(
name|byte
index|[]
name|row
parameter_list|,
name|Table
name|table
parameter_list|,
name|CINode
name|node
parameter_list|)
throws|throws
name|IOException
block|{
name|Get
name|get
init|=
operator|new
name|Get
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|get
operator|.
name|addColumn
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_PREV
argument_list|)
expr_stmt|;
name|Result
name|result
init|=
name|table
operator|.
name|get
argument_list|(
name|get
argument_list|)
decl_stmt|;
return|return
name|getCINode
argument_list|(
name|result
argument_list|,
name|node
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|Clean
extends|extends
name|Configured
implements|implements
name|Tool
block|{
annotation|@
name|Override
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|args
operator|.
name|length
operator|<
literal|1
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Usage: Clean<output dir>"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|Path
name|p
init|=
operator|new
name|Path
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|TableName
name|tableName
init|=
name|getTableName
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|HFileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Admin
name|admin
init|=
operator|new
name|HBaseAdmin
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|admin
operator|.
name|tableExists
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|admin
operator|.
name|disableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|admin
operator|.
name|deleteTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|fs
operator|.
name|delete
argument_list|(
name|p
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
block|}
specifier|static
name|TableName
name|getTableName
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|TableName
operator|.
name|valueOf
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|TABLE_NAME_KEY
argument_list|,
name|DEFAULT_TABLE_NAME
argument_list|)
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|CINode
name|getCINode
parameter_list|(
name|Result
name|result
parameter_list|,
name|CINode
name|node
parameter_list|)
block|{
name|node
operator|.
name|key
operator|=
name|Bytes
operator|.
name|copy
argument_list|(
name|result
operator|.
name|getRow
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|containsColumn
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_PREV
argument_list|)
condition|)
block|{
name|node
operator|.
name|prev
operator|=
name|Bytes
operator|.
name|copy
argument_list|(
name|result
operator|.
name|getValue
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_PREV
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|node
operator|.
name|prev
operator|=
name|NO_KEY
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|.
name|containsColumn
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_COUNT
argument_list|)
condition|)
block|{
name|node
operator|.
name|count
operator|=
name|Bytes
operator|.
name|toLong
argument_list|(
name|result
operator|.
name|getValue
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_COUNT
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|node
operator|.
name|count
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|.
name|containsColumn
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_CLIENT
argument_list|)
condition|)
block|{
name|node
operator|.
name|client
operator|=
name|Bytes
operator|.
name|toString
argument_list|(
name|result
operator|.
name|getValue
argument_list|(
name|FAMILY_NAME
argument_list|,
name|COLUMN_CLIENT
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|node
operator|.
name|client
operator|=
literal|""
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
specifier|protected
name|IntegrationTestingUtility
name|util
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|setUpCluster
parameter_list|()
throws|throws
name|Exception
block|{
name|util
operator|=
name|getTestingUtil
argument_list|(
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|isDistributed
init|=
name|util
operator|.
name|isDistributedCluster
argument_list|()
decl_stmt|;
name|util
operator|.
name|initializeCluster
argument_list|(
name|isDistributed
condition|?
literal|1
else|:
name|this
operator|.
name|NUM_SLAVES_BASE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isDistributed
condition|)
block|{
name|util
operator|.
name|startMiniMapReduceCluster
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|setConf
argument_list|(
name|util
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|cleanUpCluster
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|cleanUpCluster
argument_list|()
expr_stmt|;
if|if
condition|(
name|util
operator|.
name|isDistributedCluster
argument_list|()
condition|)
block|{
name|util
operator|.
name|shutdownMiniMapReduceCluster
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testContinuousIngest
parameter_list|()
throws|throws
name|IOException
throws|,
name|Exception
block|{
comment|//Loop<num iterations><num mappers><num nodes per mapper><output dir><num reducers>
name|int
name|ret
init|=
name|ToolRunner
operator|.
name|run
argument_list|(
name|getTestingUtil
argument_list|(
name|getConf
argument_list|()
argument_list|)
operator|.
name|getConfiguration
argument_list|()
argument_list|,
operator|new
name|Loop
argument_list|()
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"1"
block|,
literal|"1"
block|,
literal|"2000000"
block|,
name|util
operator|.
name|getDataTestDirOnTestFS
argument_list|(
literal|"IntegrationTestBigLinkedList"
argument_list|)
operator|.
name|toString
argument_list|()
block|,
literal|"1"
block|}
argument_list|)
decl_stmt|;
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|usage
parameter_list|()
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Usage: "
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" COMMAND [COMMAND options]"
argument_list|)
expr_stmt|;
name|printCommands
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|printCommands
parameter_list|()
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Commands:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" Generator  Map only job that generates data."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" Verify     A map reduce job that looks for holes. Look at the counts "
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"            after running. See REFERENCED and UNREFERENCED are ok. Any "
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"            UNDEFINED counts are bad. Do not run with the Generator."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" Walker     "
operator|+
literal|"Standalong program that starts following a linked list& emits timing info."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" Print      Standalone program that prints nodes in the linked list."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" Delete     Standalone program that deletes a·single node."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" Loop       Program to Loop through Generator and Verify steps"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" Clean      Program to clean all left over detritus."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|processOptions
parameter_list|(
name|CommandLine
name|cmd
parameter_list|)
block|{
name|super
operator|.
name|processOptions
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|String
index|[]
name|args
init|=
name|cmd
operator|.
name|getArgs
argument_list|()
decl_stmt|;
comment|//get the class, run with the conf
if|if
condition|(
name|args
operator|.
name|length
operator|<
literal|1
condition|)
block|{
name|printUsage
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"<general options> COMMAND [<COMMAND options>]"
argument_list|,
literal|"General options:"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printCommands
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Incorrect Number of args."
argument_list|)
throw|;
block|}
name|toRun
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|otherArgs
operator|=
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|args
argument_list|,
literal|1
argument_list|,
name|args
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|runTestFromCommandLine
parameter_list|()
throws|throws
name|Exception
block|{
name|Tool
name|tool
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|toRun
operator|.
name|equals
argument_list|(
literal|"Generator"
argument_list|)
condition|)
block|{
name|tool
operator|=
operator|new
name|Generator
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toRun
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"Verify"
argument_list|)
condition|)
block|{
name|tool
operator|=
operator|new
name|Verify
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toRun
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"Loop"
argument_list|)
condition|)
block|{
name|Loop
name|loop
init|=
operator|new
name|Loop
argument_list|()
decl_stmt|;
name|loop
operator|.
name|it
operator|=
name|this
expr_stmt|;
name|tool
operator|=
name|loop
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toRun
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"Walker"
argument_list|)
condition|)
block|{
name|tool
operator|=
operator|new
name|Walker
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toRun
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"Print"
argument_list|)
condition|)
block|{
name|tool
operator|=
operator|new
name|Print
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toRun
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"Delete"
argument_list|)
condition|)
block|{
name|tool
operator|=
operator|new
name|Delete
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toRun
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"Clean"
argument_list|)
condition|)
block|{
name|tool
operator|=
operator|new
name|Clean
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|usage
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unknown arg"
argument_list|)
throw|;
block|}
return|return
name|ToolRunner
operator|.
name|run
argument_list|(
name|getConf
argument_list|()
argument_list|,
name|tool
argument_list|,
name|otherArgs
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|TableName
name|getTablename
parameter_list|()
block|{
name|Configuration
name|c
init|=
name|getConf
argument_list|()
decl_stmt|;
return|return
name|TableName
operator|.
name|valueOf
argument_list|(
name|c
operator|.
name|get
argument_list|(
name|TABLE_NAME_KEY
argument_list|,
name|DEFAULT_TABLE_NAME
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|Set
argument_list|<
name|String
argument_list|>
name|getColumnFamilies
parameter_list|()
block|{
return|return
name|Sets
operator|.
name|newHashSet
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|FAMILY_NAME
argument_list|)
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|void
name|setJobConf
parameter_list|(
name|Job
name|job
parameter_list|,
name|int
name|numMappers
parameter_list|,
name|long
name|numNodes
parameter_list|,
name|Integer
name|width
parameter_list|,
name|Integer
name|wrapMultiplier
parameter_list|)
block|{
name|job
operator|.
name|getConfiguration
argument_list|()
operator|.
name|setInt
argument_list|(
name|GENERATOR_NUM_MAPPERS_KEY
argument_list|,
name|numMappers
argument_list|)
expr_stmt|;
name|job
operator|.
name|getConfiguration
argument_list|()
operator|.
name|setLong
argument_list|(
name|GENERATOR_NUM_ROWS_PER_MAP_KEY
argument_list|,
name|numNodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|!=
literal|null
condition|)
block|{
name|job
operator|.
name|getConfiguration
argument_list|()
operator|.
name|setInt
argument_list|(
name|GENERATOR_WIDTH_KEY
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrapMultiplier
operator|!=
literal|null
condition|)
block|{
name|job
operator|.
name|getConfiguration
argument_list|()
operator|.
name|setInt
argument_list|(
name|GENERATOR_WRAP_KEY
argument_list|,
name|wrapMultiplier
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|void
name|setJobScannerConf
parameter_list|(
name|Job
name|job
parameter_list|)
block|{
comment|// Make sure scanners log something useful to make debugging possible.
name|job
operator|.
name|getConfiguration
argument_list|()
operator|.
name|setBoolean
argument_list|(
name|ScannerCallable
operator|.
name|LOG_SCANNER_ACTIVITY
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|job
operator|.
name|getConfiguration
argument_list|()
operator|.
name|setInt
argument_list|(
name|TableRecordReaderImpl
operator|.
name|LOG_PER_ROW_COUNT
argument_list|,
literal|100000
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|Configuration
name|conf
init|=
name|HBaseConfiguration
operator|.
name|create
argument_list|()
decl_stmt|;
name|IntegrationTestingUtility
operator|.
name|setUseDistributedCluster
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|int
name|ret
init|=
name|ToolRunner
operator|.
name|run
argument_list|(
name|conf
argument_list|,
operator|new
name|IntegrationTestBigLinkedList
argument_list|()
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|System
operator|.
name|exit
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

