begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|RandomStringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|RandomUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Admin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ColumnFamilyDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ColumnFamilyDescriptorBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ConnectionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Put
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|TableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|TableDescriptorBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|encoding
operator|.
name|DataBlockEncoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|log
operator|.
name|HBaseMarkers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|testclassification
operator|.
name|IntegrationTests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|HBaseFsck
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|hbck
operator|.
name|HbckTestingUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ToolRunner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|experimental
operator|.
name|categories
operator|.
name|Category
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  *  * Integration test that verifies Procedure V2.<br/><br/>  *  * DDL operations should go through (rollforward or rollback) when primary master is killed by  * ChaosMonkey (default MASTER_KILLING)<br/><br/>  *  * Multiple Worker threads are started to randomly do the following Actions in loops:<br/>  * Actions generating and populating tables:  *<ul>  *<li>CreateTableAction</li>  *<li>DisableTableAction</li>  *<li>EnableTableAction</li>  *<li>DeleteTableAction</li>  *<li>AddRowAction</li>  *</ul>  * Actions performing column family DDL operations:  *<ul>  *<li>AddColumnFamilyAction</li>  *<li>AlterColumnFamilyVersionsAction</li>  *<li>AlterColumnFamilyEncodingAction</li>  *<li>DeleteColumnFamilyAction</li>  *</ul>  * Actions performing namespace DDL operations:  *<ul>  *<li>AddNamespaceAction</li>  *<li>AlterNamespaceAction</li>  *<li>DeleteNamespaceAction</li>  *</ul>  *<br/>  *  * The threads run for a period of time (default 20 minutes) then are stopped at the end of  * runtime. Verification is performed towards those checkpoints:  *<ol>  *<li>No Actions throw Exceptions.</li>  *<li>No inconsistencies are detected in hbck.</li>  *</ol>  *  *<p>  * This test should be run by the hbase user since it invokes hbck at the end  *</p><p>  * Usage:  *  hbase org.apache.hadoop.hbase.IntegrationTestDDLMasterFailover  *    -Dhbase.IntegrationTestDDLMasterFailover.runtime=1200000  *    -Dhbase.IntegrationTestDDLMasterFailover.numThreads=20  *    -Dhbase.IntegrationTestDDLMasterFailover.numRegions=50 --monkey masterKilling  */
end_comment

begin_class
annotation|@
name|Category
argument_list|(
name|IntegrationTests
operator|.
name|class
argument_list|)
specifier|public
class|class
name|IntegrationTestDDLMasterFailover
extends|extends
name|IntegrationTestBase
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|IntegrationTestDDLMasterFailover
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|SERVER_COUNT
init|=
literal|1
decl_stmt|;
comment|// number of slaves for the smallest cluster
specifier|protected
specifier|static
specifier|final
name|long
name|DEFAULT_RUN_TIME
init|=
literal|20
operator|*
literal|60
operator|*
literal|1000
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|int
name|DEFAULT_NUM_THREADS
init|=
literal|20
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|int
name|DEFAULT_NUM_REGIONS
init|=
literal|50
decl_stmt|;
comment|// number of regions in pre-split tables
specifier|private
name|boolean
name|keepObjectsAtTheEnd
init|=
literal|false
decl_stmt|;
specifier|protected
name|HBaseCluster
name|cluster
decl_stmt|;
specifier|protected
name|Connection
name|connection
decl_stmt|;
comment|/**    * A soft limit on how long we should run    */
specifier|protected
specifier|static
specifier|final
name|String
name|RUN_TIME_KEY
init|=
literal|"hbase.%s.runtime"
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|NUM_THREADS_KEY
init|=
literal|"hbase.%s.numThreads"
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|NUM_REGIONS_KEY
init|=
literal|"hbase.%s.numRegions"
decl_stmt|;
specifier|protected
name|AtomicBoolean
name|running
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|protected
name|AtomicBoolean
name|create_table
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|protected
name|int
name|numThreads
decl_stmt|,
name|numRegions
decl_stmt|;
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|NamespaceDescriptor
argument_list|>
name|namespaceMap
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|ConcurrentHashMap
argument_list|<
name|TableName
argument_list|,
name|TableDescriptor
argument_list|>
name|enabledTables
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|ConcurrentHashMap
argument_list|<
name|TableName
argument_list|,
name|TableDescriptor
argument_list|>
name|disabledTables
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|ConcurrentHashMap
argument_list|<
name|TableName
argument_list|,
name|TableDescriptor
argument_list|>
name|deletedTables
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|setUpCluster
parameter_list|()
throws|throws
name|Exception
block|{
name|util
operator|=
name|getTestingUtil
argument_list|(
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Initializing/checking cluster has "
operator|+
name|SERVER_COUNT
operator|+
literal|" servers"
argument_list|)
expr_stmt|;
name|util
operator|.
name|initializeCluster
argument_list|(
name|getMinServerCount
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Done initializing/checking cluster"
argument_list|)
expr_stmt|;
name|cluster
operator|=
name|util
operator|.
name|getHBaseClusterInterface
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|cleanUpCluster
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|keepObjectsAtTheEnd
condition|)
block|{
name|Admin
name|admin
init|=
name|util
operator|.
name|getAdmin
argument_list|()
decl_stmt|;
name|admin
operator|.
name|disableTables
argument_list|(
literal|"ittable-\\d+"
argument_list|)
expr_stmt|;
name|admin
operator|.
name|deleteTables
argument_list|(
literal|"ittable-\\d+"
argument_list|)
expr_stmt|;
name|NamespaceDescriptor
index|[]
name|nsds
init|=
name|admin
operator|.
name|listNamespaceDescriptors
argument_list|()
decl_stmt|;
for|for
control|(
name|NamespaceDescriptor
name|nsd
range|:
name|nsds
control|)
block|{
if|if
condition|(
name|nsd
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"itnamespace\\d+"
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing namespace="
operator|+
name|nsd
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|admin
operator|.
name|deleteNamespace
argument_list|(
name|nsd
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|enabledTables
operator|.
name|clear
argument_list|()
expr_stmt|;
name|disabledTables
operator|.
name|clear
argument_list|()
expr_stmt|;
name|deletedTables
operator|.
name|clear
argument_list|()
expr_stmt|;
name|namespaceMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|Connection
name|connection
init|=
name|getConnection
argument_list|()
decl_stmt|;
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
name|super
operator|.
name|cleanUpCluster
argument_list|()
expr_stmt|;
block|}
specifier|protected
name|int
name|getMinServerCount
parameter_list|()
block|{
return|return
name|SERVER_COUNT
return|;
block|}
specifier|protected
specifier|synchronized
name|void
name|setConnection
parameter_list|(
name|Connection
name|connection
parameter_list|)
block|{
name|this
operator|.
name|connection
operator|=
name|connection
expr_stmt|;
block|}
specifier|protected
specifier|synchronized
name|Connection
name|getConnection
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|connection
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|Connection
name|connection
init|=
name|ConnectionFactory
operator|.
name|createConnection
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|setConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|HBaseMarkers
operator|.
name|FATAL
argument_list|,
literal|"Failed to establish connection."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|connection
return|;
block|}
specifier|protected
name|void
name|verifyNamespaces
parameter_list|()
throws|throws
name|IOException
block|{
name|Connection
name|connection
init|=
name|getConnection
argument_list|()
decl_stmt|;
name|Admin
name|admin
init|=
name|connection
operator|.
name|getAdmin
argument_list|()
decl_stmt|;
comment|// iterating concurrent map
for|for
control|(
name|String
name|nsName
range|:
name|namespaceMap
operator|.
name|keySet
argument_list|()
control|)
block|{
try|try
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"Namespace: "
operator|+
name|nsName
operator|+
literal|" in namespaceMap does not exist"
argument_list|,
name|admin
operator|.
name|getNamespaceDescriptor
argument_list|(
name|nsName
argument_list|)
operator|!=
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NamespaceNotFoundException
name|nsnfe
parameter_list|)
block|{
name|Assert
operator|.
name|fail
argument_list|(
literal|"Namespace: "
operator|+
name|nsName
operator|+
literal|" in namespaceMap does not exist: "
operator|+
name|nsnfe
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|admin
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
specifier|protected
name|void
name|verifyTables
parameter_list|()
throws|throws
name|IOException
block|{
name|Connection
name|connection
init|=
name|getConnection
argument_list|()
decl_stmt|;
name|Admin
name|admin
init|=
name|connection
operator|.
name|getAdmin
argument_list|()
decl_stmt|;
comment|// iterating concurrent map
for|for
control|(
name|TableName
name|tableName
range|:
name|enabledTables
operator|.
name|keySet
argument_list|()
control|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"Table: "
operator|+
name|tableName
operator|+
literal|" in enabledTables is not enabled"
argument_list|,
name|admin
operator|.
name|isTableEnabled
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|TableName
name|tableName
range|:
name|disabledTables
operator|.
name|keySet
argument_list|()
control|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"Table: "
operator|+
name|tableName
operator|+
literal|" in disabledTables is not disabled"
argument_list|,
name|admin
operator|.
name|isTableDisabled
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|TableName
name|tableName
range|:
name|deletedTables
operator|.
name|keySet
argument_list|()
control|)
block|{
name|Assert
operator|.
name|assertFalse
argument_list|(
literal|"Table: "
operator|+
name|tableName
operator|+
literal|" in deletedTables is not deleted"
argument_list|,
name|admin
operator|.
name|tableExists
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|admin
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAsUnitTest
parameter_list|()
throws|throws
name|Exception
block|{
name|runTest
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|runTestFromCommandLine
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|ret
init|=
name|runTest
argument_list|()
decl_stmt|;
return|return
name|ret
return|;
block|}
specifier|private
specifier|abstract
class|class
name|MasterAction
block|{
name|Connection
name|connection
init|=
name|getConnection
argument_list|()
decl_stmt|;
specifier|abstract
name|void
name|perform
parameter_list|()
throws|throws
name|IOException
function_decl|;
block|}
specifier|private
specifier|abstract
class|class
name|NamespaceAction
extends|extends
name|MasterAction
block|{
specifier|final
name|String
name|nsTestConfigKey
init|=
literal|"hbase.namespace.testKey"
decl_stmt|;
comment|// NamespaceAction has implemented selectNamespace() shared by multiple namespace Actions
specifier|protected
name|NamespaceDescriptor
name|selectNamespace
parameter_list|(
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|NamespaceDescriptor
argument_list|>
name|namespaceMap
parameter_list|)
block|{
comment|// synchronization to prevent removal from multiple threads
synchronized|synchronized
init|(
name|namespaceMap
init|)
block|{
comment|// randomly select namespace from namespaceMap
if|if
condition|(
name|namespaceMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ArrayList
argument_list|<
name|String
argument_list|>
name|namespaceList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|namespaceMap
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|randomKey
init|=
name|namespaceList
operator|.
name|get
argument_list|(
name|RandomUtils
operator|.
name|nextInt
argument_list|(
literal|0
argument_list|,
name|namespaceList
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|NamespaceDescriptor
name|randomNsd
init|=
name|namespaceMap
operator|.
name|get
argument_list|(
name|randomKey
argument_list|)
decl_stmt|;
comment|// remove from namespaceMap
name|namespaceMap
operator|.
name|remove
argument_list|(
name|randomKey
argument_list|)
expr_stmt|;
return|return
name|randomNsd
return|;
block|}
block|}
block|}
specifier|private
class|class
name|CreateNamespaceAction
extends|extends
name|NamespaceAction
block|{
annotation|@
name|Override
name|void
name|perform
parameter_list|()
throws|throws
name|IOException
block|{
name|Admin
name|admin
init|=
name|connection
operator|.
name|getAdmin
argument_list|()
decl_stmt|;
try|try
block|{
name|NamespaceDescriptor
name|nsd
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|nsd
operator|=
name|createNamespaceDesc
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|admin
operator|.
name|getNamespaceDescriptor
argument_list|(
name|nsd
operator|.
name|getName
argument_list|()
argument_list|)
operator|!=
literal|null
condition|)
block|{
comment|// the namespace has already existed.
continue|continue;
block|}
else|else
block|{
comment|// currently, the code never return null - always throws exception if
comment|// namespace is not found - this just a defensive programming to make
comment|// sure null situation is handled in case the method changes in the
comment|// future.
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|NamespaceNotFoundException
name|nsnfe
parameter_list|)
block|{
comment|// This is expected for a random generated NamespaceDescriptor
break|break;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Creating namespace:"
operator|+
name|nsd
argument_list|)
expr_stmt|;
name|admin
operator|.
name|createNamespace
argument_list|(
name|nsd
argument_list|)
expr_stmt|;
name|NamespaceDescriptor
name|freshNamespaceDesc
init|=
name|admin
operator|.
name|getNamespaceDescriptor
argument_list|(
name|nsd
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"Namespace: "
operator|+
name|nsd
operator|+
literal|" was not created"
argument_list|,
name|freshNamespaceDesc
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|namespaceMap
operator|.
name|put
argument_list|(
name|nsd
operator|.
name|getName
argument_list|()
argument_list|,
name|freshNamespaceDesc
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Created namespace:"
operator|+
name|freshNamespaceDesc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught exception in action: "
operator|+
name|this
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|admin
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|NamespaceDescriptor
name|createNamespaceDesc
parameter_list|()
block|{
name|String
name|namespaceName
init|=
literal|"itnamespace"
operator|+
name|String
operator|.
name|format
argument_list|(
literal|"%010d"
argument_list|,
name|RandomUtils
operator|.
name|nextInt
argument_list|()
argument_list|)
decl_stmt|;
name|NamespaceDescriptor
name|nsd
init|=
name|NamespaceDescriptor
operator|.
name|create
argument_list|(
name|namespaceName
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|nsd
operator|.
name|setConfiguration
argument_list|(
name|nsTestConfigKey
argument_list|,
name|String
operator|.
name|format
argument_list|(
literal|"%010d"
argument_list|,
name|RandomUtils
operator|.
name|nextInt
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|nsd
return|;
block|}
block|}
specifier|private
class|class
name|ModifyNamespaceAction
extends|extends
name|NamespaceAction
block|{
annotation|@
name|Override
name|void
name|perform
parameter_list|()
throws|throws
name|IOException
block|{
name|NamespaceDescriptor
name|selected
init|=
name|selectNamespace
argument_list|(
name|namespaceMap
argument_list|)
decl_stmt|;
if|if
condition|(
name|selected
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|Admin
name|admin
init|=
name|connection
operator|.
name|getAdmin
argument_list|()
decl_stmt|;
try|try
block|{
name|String
name|namespaceName
init|=
name|selected
operator|.
name|getName
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Modifying namespace :"
operator|+
name|selected
argument_list|)
expr_stmt|;
name|NamespaceDescriptor
name|modifiedNsd
init|=
name|NamespaceDescriptor
operator|.
name|create
argument_list|(
name|namespaceName
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|String
name|nsValueNew
decl_stmt|;
do|do
block|{
name|nsValueNew
operator|=
name|String
operator|.
name|format
argument_list|(
literal|"%010d"
argument_list|,
name|RandomUtils
operator|.
name|nextInt
argument_list|()
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|selected
operator|.
name|getConfigurationValue
argument_list|(
name|nsTestConfigKey
argument_list|)
operator|.
name|equals
argument_list|(
name|nsValueNew
argument_list|)
condition|)
do|;
name|modifiedNsd
operator|.
name|setConfiguration
argument_list|(
name|nsTestConfigKey
argument_list|,
name|nsValueNew
argument_list|)
expr_stmt|;
name|admin
operator|.
name|modifyNamespace
argument_list|(
name|modifiedNsd
argument_list|)
expr_stmt|;
name|NamespaceDescriptor
name|freshNamespaceDesc
init|=
name|admin
operator|.
name|getNamespaceDescriptor
argument_list|(
name|namespaceName
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"Namespace: "
operator|+
name|selected
operator|+
literal|" was not modified"
argument_list|,
name|freshNamespaceDesc
operator|.
name|getConfigurationValue
argument_list|(
name|nsTestConfigKey
argument_list|)
operator|.
name|equals
argument_list|(
name|nsValueNew
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"Namespace: "
operator|+
name|namespaceName
operator|+
literal|" does not exist"
argument_list|,
name|admin
operator|.
name|getNamespaceDescriptor
argument_list|(
name|namespaceName
argument_list|)
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|namespaceMap
operator|.
name|put
argument_list|(
name|namespaceName
argument_list|,
name|freshNamespaceDesc
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Modified namespace :"
operator|+
name|freshNamespaceDesc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught exception in action: "
operator|+
name|this
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|admin
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
class|class
name|DeleteNamespaceAction
extends|extends
name|NamespaceAction
block|{
annotation|@
name|Override
name|void
name|perform
parameter_list|()
throws|throws
name|IOException
block|{
name|NamespaceDescriptor
name|selected
init|=
name|selectNamespace
argument_list|(
name|namespaceMap
argument_list|)
decl_stmt|;
if|if
condition|(
name|selected
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|Admin
name|admin
init|=
name|connection
operator|.
name|getAdmin
argument_list|()
decl_stmt|;
try|try
block|{
name|String
name|namespaceName
init|=
name|selected
operator|.
name|getName
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleting namespace :"
operator|+
name|selected
argument_list|)
expr_stmt|;
name|admin
operator|.
name|deleteNamespace
argument_list|(
name|namespaceName
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|admin
operator|.
name|getNamespaceDescriptor
argument_list|(
name|namespaceName
argument_list|)
operator|!=
literal|null
condition|)
block|{
comment|// the namespace still exists.
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"Namespace: "
operator|+
name|selected
operator|+
literal|" was not deleted"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleted namespace :"
operator|+
name|selected
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NamespaceNotFoundException
name|nsnfe
parameter_list|)
block|{
comment|// This is expected result
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleted namespace :"
operator|+
name|selected
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught exception in action: "
operator|+
name|this
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|admin
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|abstract
class|class
name|TableAction
extends|extends
name|MasterAction
block|{
comment|// TableAction has implemented selectTable() shared by multiple table Actions
specifier|protected
name|TableDescriptor
name|selectTable
parameter_list|(
name|ConcurrentHashMap
argument_list|<
name|TableName
argument_list|,
name|TableDescriptor
argument_list|>
name|tableMap
parameter_list|)
block|{
comment|// synchronization to prevent removal from multiple threads
synchronized|synchronized
init|(
name|tableMap
init|)
block|{
comment|// randomly select table from tableMap
if|if
condition|(
name|tableMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ArrayList
argument_list|<
name|TableName
argument_list|>
name|tableList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|tableMap
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
name|TableName
name|randomKey
init|=
name|tableList
operator|.
name|get
argument_list|(
name|RandomUtils
operator|.
name|nextInt
argument_list|(
literal|0
argument_list|,
name|tableList
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|TableDescriptor
name|randomTd
init|=
name|tableMap
operator|.
name|remove
argument_list|(
name|randomKey
argument_list|)
decl_stmt|;
return|return
name|randomTd
return|;
block|}
block|}
block|}
specifier|private
class|class
name|CreateTableAction
extends|extends
name|TableAction
block|{
annotation|@
name|Override
name|void
name|perform
parameter_list|()
throws|throws
name|IOException
block|{
name|Admin
name|admin
init|=
name|connection
operator|.
name|getAdmin
argument_list|()
decl_stmt|;
try|try
block|{
name|TableDescriptor
name|td
init|=
name|createTableDesc
argument_list|()
decl_stmt|;
name|TableName
name|tableName
init|=
name|td
operator|.
name|getTableName
argument_list|()
decl_stmt|;
if|if
condition|(
name|admin
operator|.
name|tableExists
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
return|return;
block|}
name|String
name|numRegionKey
init|=
name|String
operator|.
name|format
argument_list|(
name|NUM_REGIONS_KEY
argument_list|,
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
decl_stmt|;
name|numRegions
operator|=
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
name|numRegionKey
argument_list|,
name|DEFAULT_NUM_REGIONS
argument_list|)
expr_stmt|;
name|byte
index|[]
name|startKey
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"row-0000000000"
argument_list|)
decl_stmt|;
name|byte
index|[]
name|endKey
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"row-"
operator|+
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Creating table:"
operator|+
name|td
argument_list|)
expr_stmt|;
name|admin
operator|.
name|createTable
argument_list|(
name|td
argument_list|,
name|startKey
argument_list|,
name|endKey
argument_list|,
name|numRegions
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"Table: "
operator|+
name|td
operator|+
literal|" was not created"
argument_list|,
name|admin
operator|.
name|tableExists
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
name|TableDescriptor
name|freshTableDesc
init|=
name|admin
operator|.
name|getDescriptor
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"After create, Table: "
operator|+
name|tableName
operator|+
literal|" in not enabled"
argument_list|,
name|admin
operator|.
name|isTableEnabled
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
name|enabledTables
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|freshTableDesc
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Created table:"
operator|+
name|freshTableDesc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught exception in action: "
operator|+
name|this
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|admin
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|TableDescriptor
name|createTableDesc
parameter_list|()
block|{
name|String
name|tableName
init|=
name|String
operator|.
name|format
argument_list|(
literal|"ittable-%010d"
argument_list|,
name|RandomUtils
operator|.
name|nextInt
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|familyName
init|=
literal|"cf-"
operator|+
name|Math
operator|.
name|abs
argument_list|(
name|RandomUtils
operator|.
name|nextInt
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|TableDescriptorBuilder
operator|.
name|newBuilder
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
operator|.
name|addColumnFamily
argument_list|(
name|ColumnFamilyDescriptorBuilder
operator|.
name|of
argument_list|(
name|familyName
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
block|}
specifier|private
class|class
name|DisableTableAction
extends|extends
name|TableAction
block|{
annotation|@
name|Override
name|void
name|perform
parameter_list|()
throws|throws
name|IOException
block|{
name|TableDescriptor
name|selected
init|=
name|selectTable
argument_list|(
name|enabledTables
argument_list|)
decl_stmt|;
if|if
condition|(
name|selected
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|Admin
name|admin
init|=
name|connection
operator|.
name|getAdmin
argument_list|()
decl_stmt|;
try|try
block|{
name|TableName
name|tableName
init|=
name|selected
operator|.
name|getTableName
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Disabling table :"
operator|+
name|selected
argument_list|)
expr_stmt|;
name|admin
operator|.
name|disableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"Table: "
operator|+
name|selected
operator|+
literal|" was not disabled"
argument_list|,
name|admin
operator|.
name|isTableDisabled
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
name|TableDescriptor
name|freshTableDesc
init|=
name|admin
operator|.
name|getDescriptor
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"After disable, Table: "
operator|+
name|tableName
operator|+
literal|" is not disabled"
argument_list|,
name|admin
operator|.
name|isTableDisabled
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
name|disabledTables
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|freshTableDesc
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Disabled table :"
operator|+
name|freshTableDesc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught exception in action: "
operator|+
name|this
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO workaround
comment|// loose restriction for TableNotDisabledException/TableNotEnabledException thrown in sync
comment|// operations
comment|// 1) when enable/disable starts, the table state is changed to ENABLING/DISABLING (ZK node
comment|// in 1.x), which will be further changed to ENABLED/DISABLED once the operation completes
comment|// 2) if master failover happens in the middle of the enable/disable operation, the new
comment|// master will try to recover the tables in ENABLING/DISABLING state, as programmed in
comment|// AssignmentManager#recoverTableInEnablingState() and
comment|// AssignmentManager#recoverTableInDisablingState()
comment|// 3) after the new master initialization completes, the procedure tries to re-do the
comment|// enable/disable operation, which was already done. Ignore those exceptions before change
comment|// of behaviors of AssignmentManager in presence of PV2
if|if
condition|(
name|e
operator|instanceof
name|TableNotEnabledException
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught TableNotEnabledException in action: "
operator|+
name|this
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
finally|finally
block|{
name|admin
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
class|class
name|EnableTableAction
extends|extends
name|TableAction
block|{
annotation|@
name|Override
name|void
name|perform
parameter_list|()
throws|throws
name|IOException
block|{
name|TableDescriptor
name|selected
init|=
name|selectTable
argument_list|(
name|disabledTables
argument_list|)
decl_stmt|;
if|if
condition|(
name|selected
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|Admin
name|admin
init|=
name|connection
operator|.
name|getAdmin
argument_list|()
decl_stmt|;
try|try
block|{
name|TableName
name|tableName
init|=
name|selected
operator|.
name|getTableName
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Enabling table :"
operator|+
name|selected
argument_list|)
expr_stmt|;
name|admin
operator|.
name|enableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"Table: "
operator|+
name|selected
operator|+
literal|" was not enabled"
argument_list|,
name|admin
operator|.
name|isTableEnabled
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
name|TableDescriptor
name|freshTableDesc
init|=
name|admin
operator|.
name|getDescriptor
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"After enable, Table: "
operator|+
name|tableName
operator|+
literal|" in not enabled"
argument_list|,
name|admin
operator|.
name|isTableEnabled
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
name|enabledTables
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|freshTableDesc
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Enabled table :"
operator|+
name|freshTableDesc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught exception in action: "
operator|+
name|this
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO workaround
comment|// loose restriction for TableNotDisabledException/TableNotEnabledException thrown in sync
comment|// operations 1) when enable/disable starts, the table state is changed to
comment|// ENABLING/DISABLING (ZK node in 1.x), which will be further changed to ENABLED/DISABLED
comment|// once the operation completes 2) if master failover happens in the middle of the
comment|// enable/disable operation, the new master will try to recover the tables in
comment|// ENABLING/DISABLING state, as programmed in
comment|// AssignmentManager#recoverTableInEnablingState() and
comment|// AssignmentManager#recoverTableInDisablingState()
comment|// 3) after the new master initialization completes, the procedure tries to re-do the
comment|// enable/disable operation, which was already done. Ignore those exceptions before
comment|// change of behaviors of AssignmentManager in presence of PV2
if|if
condition|(
name|e
operator|instanceof
name|TableNotDisabledException
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught TableNotDisabledException in action: "
operator|+
name|this
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
finally|finally
block|{
name|admin
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
class|class
name|DeleteTableAction
extends|extends
name|TableAction
block|{
annotation|@
name|Override
name|void
name|perform
parameter_list|()
throws|throws
name|IOException
block|{
name|TableDescriptor
name|selected
init|=
name|selectTable
argument_list|(
name|disabledTables
argument_list|)
decl_stmt|;
if|if
condition|(
name|selected
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|Admin
name|admin
init|=
name|connection
operator|.
name|getAdmin
argument_list|()
decl_stmt|;
try|try
block|{
name|TableName
name|tableName
init|=
name|selected
operator|.
name|getTableName
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleting table :"
operator|+
name|selected
argument_list|)
expr_stmt|;
name|admin
operator|.
name|deleteTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertFalse
argument_list|(
literal|"Table: "
operator|+
name|selected
operator|+
literal|" was not deleted"
argument_list|,
name|admin
operator|.
name|tableExists
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
name|deletedTables
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|selected
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleted table :"
operator|+
name|selected
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught exception in action: "
operator|+
name|this
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|admin
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|abstract
class|class
name|ColumnAction
extends|extends
name|TableAction
block|{
comment|// ColumnAction has implemented selectFamily() shared by multiple family Actions
specifier|protected
name|ColumnFamilyDescriptor
name|selectFamily
parameter_list|(
name|TableDescriptor
name|td
parameter_list|)
block|{
if|if
condition|(
name|td
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ColumnFamilyDescriptor
index|[]
name|families
init|=
name|td
operator|.
name|getColumnFamilies
argument_list|()
decl_stmt|;
if|if
condition|(
name|families
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No column families in table: "
operator|+
name|td
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|ColumnFamilyDescriptor
name|randomCfd
init|=
name|families
index|[
name|RandomUtils
operator|.
name|nextInt
argument_list|(
literal|0
argument_list|,
name|families
operator|.
name|length
argument_list|)
index|]
decl_stmt|;
return|return
name|randomCfd
return|;
block|}
block|}
specifier|private
class|class
name|AddColumnFamilyAction
extends|extends
name|ColumnAction
block|{
annotation|@
name|Override
name|void
name|perform
parameter_list|()
throws|throws
name|IOException
block|{
name|TableDescriptor
name|selected
init|=
name|selectTable
argument_list|(
name|disabledTables
argument_list|)
decl_stmt|;
if|if
condition|(
name|selected
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|Admin
name|admin
init|=
name|connection
operator|.
name|getAdmin
argument_list|()
decl_stmt|;
try|try
block|{
name|ColumnFamilyDescriptor
name|cfd
init|=
name|createFamilyDesc
argument_list|()
decl_stmt|;
if|if
condition|(
name|selected
operator|.
name|hasColumnFamily
argument_list|(
name|cfd
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
operator|new
name|String
argument_list|(
name|cfd
operator|.
name|getName
argument_list|()
argument_list|)
operator|+
literal|" already exists in table "
operator|+
name|selected
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|TableName
name|tableName
init|=
name|selected
operator|.
name|getTableName
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding column family: "
operator|+
name|cfd
operator|+
literal|" to table: "
operator|+
name|tableName
argument_list|)
expr_stmt|;
name|admin
operator|.
name|addColumnFamily
argument_list|(
name|tableName
argument_list|,
name|cfd
argument_list|)
expr_stmt|;
comment|// assertion
name|TableDescriptor
name|freshTableDesc
init|=
name|admin
operator|.
name|getDescriptor
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"Column family: "
operator|+
name|cfd
operator|+
literal|" was not added"
argument_list|,
name|freshTableDesc
operator|.
name|hasColumnFamily
argument_list|(
name|cfd
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"After add column family, Table: "
operator|+
name|tableName
operator|+
literal|" is not disabled"
argument_list|,
name|admin
operator|.
name|isTableDisabled
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
name|disabledTables
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|freshTableDesc
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Added column family: "
operator|+
name|cfd
operator|+
literal|" to table: "
operator|+
name|tableName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught exception in action: "
operator|+
name|this
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|admin
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|ColumnFamilyDescriptor
name|createFamilyDesc
parameter_list|()
block|{
name|String
name|familyName
init|=
name|String
operator|.
name|format
argument_list|(
literal|"cf-%010d"
argument_list|,
name|RandomUtils
operator|.
name|nextInt
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|ColumnFamilyDescriptorBuilder
operator|.
name|of
argument_list|(
name|familyName
argument_list|)
return|;
block|}
block|}
specifier|private
class|class
name|AlterFamilyVersionsAction
extends|extends
name|ColumnAction
block|{
annotation|@
name|Override
name|void
name|perform
parameter_list|()
throws|throws
name|IOException
block|{
name|TableDescriptor
name|selected
init|=
name|selectTable
argument_list|(
name|disabledTables
argument_list|)
decl_stmt|;
if|if
condition|(
name|selected
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|ColumnFamilyDescriptor
name|columnDesc
init|=
name|selectFamily
argument_list|(
name|selected
argument_list|)
decl_stmt|;
if|if
condition|(
name|columnDesc
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|Admin
name|admin
init|=
name|connection
operator|.
name|getAdmin
argument_list|()
decl_stmt|;
name|int
name|versions
init|=
name|RandomUtils
operator|.
name|nextInt
argument_list|(
literal|0
argument_list|,
literal|10
argument_list|)
operator|+
literal|3
decl_stmt|;
try|try
block|{
name|TableName
name|tableName
init|=
name|selected
operator|.
name|getTableName
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Altering versions of column family: "
operator|+
name|columnDesc
operator|+
literal|" to: "
operator|+
name|versions
operator|+
literal|" in table: "
operator|+
name|tableName
argument_list|)
expr_stmt|;
name|ColumnFamilyDescriptor
name|cfd
init|=
name|ColumnFamilyDescriptorBuilder
operator|.
name|newBuilder
argument_list|(
name|columnDesc
argument_list|)
operator|.
name|setMinVersions
argument_list|(
name|versions
argument_list|)
operator|.
name|setMaxVersions
argument_list|(
name|versions
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|TableDescriptor
name|td
init|=
name|TableDescriptorBuilder
operator|.
name|newBuilder
argument_list|(
name|selected
argument_list|)
operator|.
name|modifyColumnFamily
argument_list|(
name|cfd
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|admin
operator|.
name|modifyTable
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|// assertion
name|TableDescriptor
name|freshTableDesc
init|=
name|admin
operator|.
name|getDescriptor
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|ColumnFamilyDescriptor
name|freshColumnDesc
init|=
name|freshTableDesc
operator|.
name|getColumnFamily
argument_list|(
name|columnDesc
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Column family: "
operator|+
name|columnDesc
operator|+
literal|" was not altered"
argument_list|,
name|freshColumnDesc
operator|.
name|getMaxVersions
argument_list|()
argument_list|,
name|versions
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Column family: "
operator|+
name|freshColumnDesc
operator|+
literal|" was not altered"
argument_list|,
name|freshColumnDesc
operator|.
name|getMinVersions
argument_list|()
argument_list|,
name|versions
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"After alter versions of column family, Table: "
operator|+
name|tableName
operator|+
literal|" is not disabled"
argument_list|,
name|admin
operator|.
name|isTableDisabled
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
name|disabledTables
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|freshTableDesc
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Altered versions of column family: "
operator|+
name|columnDesc
operator|+
literal|" to: "
operator|+
name|versions
operator|+
literal|" in table: "
operator|+
name|tableName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught exception in action: "
operator|+
name|this
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|admin
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
class|class
name|AlterFamilyEncodingAction
extends|extends
name|ColumnAction
block|{
annotation|@
name|Override
name|void
name|perform
parameter_list|()
throws|throws
name|IOException
block|{
name|TableDescriptor
name|selected
init|=
name|selectTable
argument_list|(
name|disabledTables
argument_list|)
decl_stmt|;
if|if
condition|(
name|selected
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|ColumnFamilyDescriptor
name|columnDesc
init|=
name|selectFamily
argument_list|(
name|selected
argument_list|)
decl_stmt|;
if|if
condition|(
name|columnDesc
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|Admin
name|admin
init|=
name|connection
operator|.
name|getAdmin
argument_list|()
decl_stmt|;
try|try
block|{
name|TableName
name|tableName
init|=
name|selected
operator|.
name|getTableName
argument_list|()
decl_stmt|;
comment|// possible DataBlockEncoding ids
name|int
index|[]
name|possibleIds
init|=
block|{
literal|0
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|6
block|}
decl_stmt|;
name|short
name|id
init|=
operator|(
name|short
operator|)
name|possibleIds
index|[
name|RandomUtils
operator|.
name|nextInt
argument_list|(
literal|0
argument_list|,
name|possibleIds
operator|.
name|length
argument_list|)
index|]
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Altering encoding of column family: "
operator|+
name|columnDesc
operator|+
literal|" to: "
operator|+
name|id
operator|+
literal|" in table: "
operator|+
name|tableName
argument_list|)
expr_stmt|;
name|ColumnFamilyDescriptor
name|cfd
init|=
name|ColumnFamilyDescriptorBuilder
operator|.
name|newBuilder
argument_list|(
name|columnDesc
argument_list|)
operator|.
name|setDataBlockEncoding
argument_list|(
name|DataBlockEncoding
operator|.
name|getEncodingById
argument_list|(
name|id
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|TableDescriptor
name|td
init|=
name|TableDescriptorBuilder
operator|.
name|newBuilder
argument_list|(
name|selected
argument_list|)
operator|.
name|modifyColumnFamily
argument_list|(
name|cfd
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|admin
operator|.
name|modifyTable
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|// assertion
name|TableDescriptor
name|freshTableDesc
init|=
name|admin
operator|.
name|getTableDescriptor
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|ColumnFamilyDescriptor
name|freshColumnDesc
init|=
name|freshTableDesc
operator|.
name|getColumnFamily
argument_list|(
name|columnDesc
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Encoding of column family: "
operator|+
name|columnDesc
operator|+
literal|" was not altered"
argument_list|,
name|freshColumnDesc
operator|.
name|getDataBlockEncoding
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"After alter encoding of column family, Table: "
operator|+
name|tableName
operator|+
literal|" is not disabled"
argument_list|,
name|admin
operator|.
name|isTableDisabled
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
name|disabledTables
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|freshTableDesc
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Altered encoding of column family: "
operator|+
name|freshColumnDesc
operator|+
literal|" to: "
operator|+
name|id
operator|+
literal|" in table: "
operator|+
name|tableName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught exception in action: "
operator|+
name|this
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|admin
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
class|class
name|DeleteColumnFamilyAction
extends|extends
name|ColumnAction
block|{
annotation|@
name|Override
name|void
name|perform
parameter_list|()
throws|throws
name|IOException
block|{
name|TableDescriptor
name|selected
init|=
name|selectTable
argument_list|(
name|disabledTables
argument_list|)
decl_stmt|;
name|ColumnFamilyDescriptor
name|cfd
init|=
name|selectFamily
argument_list|(
name|selected
argument_list|)
decl_stmt|;
if|if
condition|(
name|selected
operator|==
literal|null
operator|||
name|cfd
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|Admin
name|admin
init|=
name|connection
operator|.
name|getAdmin
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|selected
operator|.
name|getColumnFamilyCount
argument_list|()
operator|<
literal|2
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No enough column families to delete in table "
operator|+
name|selected
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|TableName
name|tableName
init|=
name|selected
operator|.
name|getTableName
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleting column family: "
operator|+
name|cfd
operator|+
literal|" from table: "
operator|+
name|tableName
argument_list|)
expr_stmt|;
name|admin
operator|.
name|deleteColumnFamily
argument_list|(
name|tableName
argument_list|,
name|cfd
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// assertion
name|TableDescriptor
name|freshTableDesc
init|=
name|admin
operator|.
name|getDescriptor
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertFalse
argument_list|(
literal|"Column family: "
operator|+
name|cfd
operator|+
literal|" was not added"
argument_list|,
name|freshTableDesc
operator|.
name|hasColumnFamily
argument_list|(
name|cfd
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"After delete column family, Table: "
operator|+
name|tableName
operator|+
literal|" is not disabled"
argument_list|,
name|admin
operator|.
name|isTableDisabled
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
name|disabledTables
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|freshTableDesc
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleted column family: "
operator|+
name|cfd
operator|+
literal|" from table: "
operator|+
name|tableName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught exception in action: "
operator|+
name|this
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|admin
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
class|class
name|AddRowAction
extends|extends
name|ColumnAction
block|{
comment|// populate tables
annotation|@
name|Override
name|void
name|perform
parameter_list|()
throws|throws
name|IOException
block|{
name|TableDescriptor
name|selected
init|=
name|selectTable
argument_list|(
name|enabledTables
argument_list|)
decl_stmt|;
if|if
condition|(
name|selected
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|Admin
name|admin
init|=
name|connection
operator|.
name|getAdmin
argument_list|()
decl_stmt|;
name|TableName
name|tableName
init|=
name|selected
operator|.
name|getTableName
argument_list|()
decl_stmt|;
try|try
init|(
name|Table
name|table
init|=
name|connection
operator|.
name|getTable
argument_list|(
name|tableName
argument_list|)
init|)
block|{
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
name|regionInfos
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|admin
operator|.
name|getTableRegions
argument_list|(
name|selected
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|numRegions
init|=
name|regionInfos
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// average number of rows to be added per action to each region
name|int
name|average_rows
init|=
literal|1
decl_stmt|;
name|int
name|numRows
init|=
name|average_rows
operator|*
name|numRegions
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding "
operator|+
name|numRows
operator|+
literal|" rows to table: "
operator|+
name|selected
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numRows
condition|;
name|i
operator|++
control|)
block|{
comment|// nextInt(Integer.MAX_VALUE)) to return positive numbers only
name|byte
index|[]
name|rowKey
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"row-"
operator|+
name|String
operator|.
name|format
argument_list|(
literal|"%010d"
argument_list|,
name|RandomUtils
operator|.
name|nextInt
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|ColumnFamilyDescriptor
name|cfd
init|=
name|selectFamily
argument_list|(
name|selected
argument_list|)
decl_stmt|;
if|if
condition|(
name|cfd
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|byte
index|[]
name|family
init|=
name|cfd
operator|.
name|getName
argument_list|()
decl_stmt|;
name|byte
index|[]
name|qualifier
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"col-"
operator|+
name|RandomUtils
operator|.
name|nextInt
argument_list|()
operator|%
literal|10
argument_list|)
decl_stmt|;
name|byte
index|[]
name|value
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"val-"
operator|+
name|RandomStringUtils
operator|.
name|randomAlphanumeric
argument_list|(
literal|10
argument_list|)
argument_list|)
decl_stmt|;
name|Put
name|put
init|=
operator|new
name|Put
argument_list|(
name|rowKey
argument_list|)
decl_stmt|;
name|put
operator|.
name|addColumn
argument_list|(
name|family
argument_list|,
name|qualifier
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|table
operator|.
name|put
argument_list|(
name|put
argument_list|)
expr_stmt|;
block|}
name|TableDescriptor
name|freshTableDesc
init|=
name|admin
operator|.
name|getDescriptor
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"After insert, Table: "
operator|+
name|tableName
operator|+
literal|" in not enabled"
argument_list|,
name|admin
operator|.
name|isTableEnabled
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
name|enabledTables
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|freshTableDesc
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Added "
operator|+
name|numRows
operator|+
literal|" rows to table: "
operator|+
name|selected
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught exception in action: "
operator|+
name|this
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|admin
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
enum|enum
name|ACTION
block|{
name|CREATE_NAMESPACE
block|,
name|MODIFY_NAMESPACE
block|,
name|DELETE_NAMESPACE
block|,
name|CREATE_TABLE
block|,
name|DISABLE_TABLE
block|,
name|ENABLE_TABLE
block|,
name|DELETE_TABLE
block|,
name|ADD_COLUMNFAMILY
block|,
name|DELETE_COLUMNFAMILY
block|,
name|ALTER_FAMILYVERSIONS
block|,
name|ALTER_FAMILYENCODING
block|,
name|ADD_ROW
block|}
specifier|private
class|class
name|Worker
extends|extends
name|Thread
block|{
specifier|private
name|Exception
name|savedException
decl_stmt|;
specifier|private
name|ACTION
name|action
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|running
operator|.
name|get
argument_list|()
condition|)
block|{
comment|// select random action
name|ACTION
name|selectedAction
init|=
name|ACTION
operator|.
name|values
argument_list|()
index|[
name|RandomUtils
operator|.
name|nextInt
argument_list|()
operator|%
name|ACTION
operator|.
name|values
argument_list|()
operator|.
name|length
index|]
decl_stmt|;
name|this
operator|.
name|action
operator|=
name|selectedAction
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Performing Action: "
operator|+
name|selectedAction
argument_list|)
expr_stmt|;
try|try
block|{
switch|switch
condition|(
name|selectedAction
condition|)
block|{
case|case
name|CREATE_NAMESPACE
case|:
operator|new
name|CreateNamespaceAction
argument_list|()
operator|.
name|perform
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODIFY_NAMESPACE
case|:
operator|new
name|ModifyNamespaceAction
argument_list|()
operator|.
name|perform
argument_list|()
expr_stmt|;
break|break;
case|case
name|DELETE_NAMESPACE
case|:
operator|new
name|DeleteNamespaceAction
argument_list|()
operator|.
name|perform
argument_list|()
expr_stmt|;
break|break;
case|case
name|CREATE_TABLE
case|:
comment|// stop creating new tables in the later stage of the test to avoid too many empty
comment|// tables
if|if
condition|(
name|create_table
operator|.
name|get
argument_list|()
condition|)
block|{
operator|new
name|CreateTableAction
argument_list|()
operator|.
name|perform
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|ADD_ROW
case|:
operator|new
name|AddRowAction
argument_list|()
operator|.
name|perform
argument_list|()
expr_stmt|;
break|break;
case|case
name|DISABLE_TABLE
case|:
operator|new
name|DisableTableAction
argument_list|()
operator|.
name|perform
argument_list|()
expr_stmt|;
break|break;
case|case
name|ENABLE_TABLE
case|:
operator|new
name|EnableTableAction
argument_list|()
operator|.
name|perform
argument_list|()
expr_stmt|;
break|break;
case|case
name|DELETE_TABLE
case|:
comment|// reduce probability of deleting table to 20%
if|if
condition|(
name|RandomUtils
operator|.
name|nextInt
argument_list|(
literal|0
argument_list|,
literal|100
argument_list|)
operator|<
literal|20
condition|)
block|{
operator|new
name|DeleteTableAction
argument_list|()
operator|.
name|perform
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|ADD_COLUMNFAMILY
case|:
operator|new
name|AddColumnFamilyAction
argument_list|()
operator|.
name|perform
argument_list|()
expr_stmt|;
break|break;
case|case
name|DELETE_COLUMNFAMILY
case|:
comment|// reduce probability of deleting column family to 20%
if|if
condition|(
name|RandomUtils
operator|.
name|nextInt
argument_list|(
literal|0
argument_list|,
literal|100
argument_list|)
operator|<
literal|20
condition|)
block|{
operator|new
name|DeleteColumnFamilyAction
argument_list|()
operator|.
name|perform
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|ALTER_FAMILYVERSIONS
case|:
operator|new
name|AlterFamilyVersionsAction
argument_list|()
operator|.
name|perform
argument_list|()
expr_stmt|;
break|break;
case|case
name|ALTER_FAMILYENCODING
case|:
operator|new
name|AlterFamilyEncodingAction
argument_list|()
operator|.
name|perform
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|this
operator|.
name|savedException
operator|=
name|ex
expr_stmt|;
return|return;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|this
operator|.
name|getName
argument_list|()
operator|+
literal|" stopped"
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Exception
name|getSavedException
parameter_list|()
block|{
return|return
name|this
operator|.
name|savedException
return|;
block|}
specifier|public
name|ACTION
name|getAction
parameter_list|()
block|{
return|return
name|this
operator|.
name|action
return|;
block|}
block|}
specifier|private
name|void
name|checkException
parameter_list|(
name|List
argument_list|<
name|Worker
argument_list|>
name|workers
parameter_list|)
block|{
if|if
condition|(
name|workers
operator|==
literal|null
operator|||
name|workers
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
for|for
control|(
name|Worker
name|worker
range|:
name|workers
control|)
block|{
name|Exception
name|e
init|=
name|worker
operator|.
name|getSavedException
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Found exception in thread: "
operator|+
name|worker
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
name|Assert
operator|.
name|assertNull
argument_list|(
literal|"Action failed: "
operator|+
name|worker
operator|.
name|getAction
argument_list|()
operator|+
literal|" in thread: "
operator|+
name|worker
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|int
name|runTest
parameter_list|()
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting the test"
argument_list|)
expr_stmt|;
name|String
name|runtimeKey
init|=
name|String
operator|.
name|format
argument_list|(
name|RUN_TIME_KEY
argument_list|,
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|runtime
init|=
name|util
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getLong
argument_list|(
name|runtimeKey
argument_list|,
name|DEFAULT_RUN_TIME
argument_list|)
decl_stmt|;
name|String
name|numThreadKey
init|=
name|String
operator|.
name|format
argument_list|(
name|NUM_THREADS_KEY
argument_list|,
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
decl_stmt|;
name|numThreads
operator|=
name|util
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|numThreadKey
argument_list|,
name|DEFAULT_NUM_THREADS
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|Worker
argument_list|>
name|workers
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|numThreads
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numThreads
condition|;
name|i
operator|++
control|)
block|{
name|checkException
argument_list|(
name|workers
argument_list|)
expr_stmt|;
name|Worker
name|worker
init|=
operator|new
name|Worker
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Launching worker thread "
operator|+
name|worker
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|workers
operator|.
name|add
argument_list|(
name|worker
argument_list|)
expr_stmt|;
name|worker
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|Threads
operator|.
name|sleep
argument_list|(
name|runtime
operator|/
literal|2
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping creating new tables"
argument_list|)
expr_stmt|;
name|create_table
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|sleep
argument_list|(
name|runtime
operator|/
literal|2
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Runtime is up"
argument_list|)
expr_stmt|;
name|running
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|checkException
argument_list|(
name|workers
argument_list|)
expr_stmt|;
for|for
control|(
name|Worker
name|worker
range|:
name|workers
control|)
block|{
name|worker
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"All Worker threads stopped"
argument_list|)
expr_stmt|;
comment|// verify
name|LOG
operator|.
name|info
argument_list|(
literal|"Verify actions of all threads succeeded"
argument_list|)
expr_stmt|;
name|checkException
argument_list|(
name|workers
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Verify namespaces"
argument_list|)
expr_stmt|;
name|verifyNamespaces
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Verify states of all tables"
argument_list|)
expr_stmt|;
name|verifyTables
argument_list|()
expr_stmt|;
comment|// RUN HBCK
name|HBaseFsck
name|hbck
init|=
literal|null
decl_stmt|;
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Running hbck"
argument_list|)
expr_stmt|;
name|hbck
operator|=
name|HbckTestingUtil
operator|.
name|doFsck
argument_list|(
name|util
operator|.
name|getConfiguration
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|HbckTestingUtil
operator|.
name|inconsistencyFound
argument_list|(
name|hbck
argument_list|)
condition|)
block|{
comment|// Find the inconsistency during HBCK. Leave table and namespace undropped so that
comment|// we can check outside the test.
name|keepObjectsAtTheEnd
operator|=
literal|true
expr_stmt|;
block|}
name|HbckTestingUtil
operator|.
name|assertNoErrors
argument_list|(
name|hbck
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Finished hbck"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|hbck
operator|!=
literal|null
condition|)
block|{
name|hbck
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|TableName
name|getTablename
parameter_list|()
block|{
return|return
literal|null
return|;
comment|// This test is not inteded to run with stock Chaos Monkey
block|}
annotation|@
name|Override
specifier|protected
name|Set
argument_list|<
name|String
argument_list|>
name|getColumnFamilies
parameter_list|()
block|{
return|return
literal|null
return|;
comment|// This test is not inteded to run with stock Chaos Monkey
block|}
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|Configuration
name|conf
init|=
name|HBaseConfiguration
operator|.
name|create
argument_list|()
decl_stmt|;
name|IntegrationTestingUtility
operator|.
name|setUseDistributedCluster
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|IntegrationTestDDLMasterFailover
name|masterFailover
init|=
operator|new
name|IntegrationTestDDLMasterFailover
argument_list|()
decl_stmt|;
name|Connection
name|connection
init|=
literal|null
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|;
try|try
block|{
comment|// Initialize connection once, then pass to Actions
name|LOG
operator|.
name|debug
argument_list|(
literal|"Setting up connection ..."
argument_list|)
expr_stmt|;
name|connection
operator|=
name|ConnectionFactory
operator|.
name|createConnection
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|masterFailover
operator|.
name|setConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ToolRunner
operator|.
name|run
argument_list|(
name|conf
argument_list|,
name|masterFailover
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|HBaseMarkers
operator|.
name|FATAL
argument_list|,
literal|"Failed to establish connection. Aborting test ..."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|connection
operator|=
name|masterFailover
operator|.
name|getConnection
argument_list|()
expr_stmt|;
if|if
condition|(
name|connection
operator|!=
literal|null
condition|)
block|{
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|System
operator|.
name|exit
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

