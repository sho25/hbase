begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|mttr
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|RandomStringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|math
operator|.
name|stat
operator|.
name|descriptive
operator|.
name|DescriptiveStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ClusterStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HColumnDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|IntegrationTestingUtility
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|IntegrationTests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|InvalidFamilyOperationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NamespaceExistException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NamespaceNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|chaos
operator|.
name|actions
operator|.
name|Action
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|chaos
operator|.
name|actions
operator|.
name|MoveRegionsOfTableAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|chaos
operator|.
name|actions
operator|.
name|RestartActiveMasterAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|chaos
operator|.
name|actions
operator|.
name|RestartRsHoldingMetaAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|chaos
operator|.
name|actions
operator|.
name|RestartRsHoldingTableAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|chaos
operator|.
name|factories
operator|.
name|MonkeyConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|HBaseAdmin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|HTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Put
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ResultScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RetriesExhaustedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Scan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|coprocessor
operator|.
name|CoprocessorException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|KeyOnlyFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|FatalConnectionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|NoSuchColumnFamilyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|AccessDeniedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|LoadTestTool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|htrace
operator|.
name|Span
import|;
end_import

begin_import
import|import
name|org
operator|.
name|htrace
operator|.
name|Trace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|htrace
operator|.
name|TraceScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|htrace
operator|.
name|impl
operator|.
name|AlwaysSampler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|AfterClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|experimental
operator|.
name|categories
operator|.
name|Category
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Objects
import|;
end_import

begin_comment
comment|/**  * Integration test that should benchmark how fast HBase can recover from failures. This test starts  * different threads:  *<ol>  *<li>  * Load Test Tool.<br/>  * This runs so that all RegionServers will have some load and HLogs will be full.  *</li>  *<li>  * Scan thread.<br/>  * This thread runs a very short scan over and over again recording how log it takes to respond.  * The longest response is assumed to be the time it took to recover.  *</li>  *<li>  * Put thread.<br/>  * This thread just like the scan thread except it does a very small put.  *</li>  *<li>  * Admin thread.<br/>  * This thread will continually go to the master to try and get the cluster status.  Just like the  * put and scan threads, the time to respond is recorded.  *</li>  *<li>  * Chaos Monkey thread.<br/>  * This thread runs a ChaosMonkey.Action.  *</li>  *</ol>  *<p/>  * The ChaosMonkey actions currently run are:  *<ul>  *<li>Restart the RegionServer holding meta.</li>  *<li>Restart the RegionServer holding the table the scan and put threads are targeting.</li>  *<li>Move the Regions of the table used by the scan and put threads.</li>  *<li>Restart the master.</li>  *</ul>  *<p/>  * At the end of the test a log line is output on the INFO level containing the timing data that was  * collected.  */
end_comment

begin_class
annotation|@
name|Category
argument_list|(
name|IntegrationTests
operator|.
name|class
argument_list|)
specifier|public
class|class
name|IntegrationTestMTTR
block|{
comment|/**    * Constants.    */
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|FAMILY
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"d"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|IntegrationTestMTTR
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|long
name|sleepTime
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|SLEEP_TIME_KEY
init|=
literal|"hbase.IntegrationTestMTTR.sleeptime"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|SLEEP_TIME_DEFAULT
init|=
literal|60
operator|*
literal|1000l
decl_stmt|;
comment|/**    * Configurable table names.    */
specifier|private
specifier|static
name|TableName
name|tableName
decl_stmt|;
specifier|private
specifier|static
name|TableName
name|loadTableName
decl_stmt|;
comment|/**    * Util to get at the cluster.    */
specifier|private
specifier|static
name|IntegrationTestingUtility
name|util
decl_stmt|;
comment|/**    * Executor for test threads.    */
specifier|private
specifier|static
name|ExecutorService
name|executorService
decl_stmt|;
comment|/**    * All of the chaos monkey actions used.    */
specifier|private
specifier|static
name|Action
name|restartRSAction
decl_stmt|;
specifier|private
specifier|static
name|Action
name|restartMetaAction
decl_stmt|;
specifier|private
specifier|static
name|Action
name|moveRegionAction
decl_stmt|;
specifier|private
specifier|static
name|Action
name|restartMasterAction
decl_stmt|;
comment|/**    * The load test tool used to create load and make sure that HLogs aren't empty.    */
specifier|private
specifier|static
name|LoadTestTool
name|loadTool
decl_stmt|;
annotation|@
name|BeforeClass
specifier|public
specifier|static
name|void
name|setUp
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Set up the integration test util
if|if
condition|(
name|util
operator|==
literal|null
condition|)
block|{
name|util
operator|=
operator|new
name|IntegrationTestingUtility
argument_list|()
expr_stmt|;
block|}
comment|// Make sure there are three servers.
name|util
operator|.
name|initializeCluster
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|// Set up the load test tool.
name|loadTool
operator|=
operator|new
name|LoadTestTool
argument_list|()
expr_stmt|;
name|loadTool
operator|.
name|setConf
argument_list|(
name|util
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
comment|// Create executor with enough threads to restart rs's,
comment|// run scans, puts, admin ops and load test tool.
name|executorService
operator|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
literal|8
argument_list|)
expr_stmt|;
comment|// Set up the tables needed.
name|setupTables
argument_list|()
expr_stmt|;
comment|// Set up the actions.
name|sleepTime
operator|=
name|util
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getLong
argument_list|(
name|SLEEP_TIME_KEY
argument_list|,
name|SLEEP_TIME_DEFAULT
argument_list|)
expr_stmt|;
name|setupActions
argument_list|()
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|setupActions
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Set up the action that will restart a region server holding a region from our table
comment|// because this table should only have one region we should be good.
name|restartRSAction
operator|=
operator|new
name|RestartRsHoldingTableAction
argument_list|(
name|sleepTime
argument_list|,
name|tableName
operator|.
name|getNameAsString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Set up the action that will kill the region holding meta.
name|restartMetaAction
operator|=
operator|new
name|RestartRsHoldingMetaAction
argument_list|(
name|sleepTime
argument_list|)
expr_stmt|;
comment|// Set up the action that will move the regions of our table.
name|moveRegionAction
operator|=
operator|new
name|MoveRegionsOfTableAction
argument_list|(
name|sleepTime
argument_list|,
name|MonkeyConstants
operator|.
name|DEFAULT_MOVE_REGIONS_MAX_TIME
argument_list|,
name|tableName
operator|.
name|getNameAsString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Kill the master
name|restartMasterAction
operator|=
operator|new
name|RestartActiveMasterAction
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|// Give the action the access to the cluster.
name|Action
operator|.
name|ActionContext
name|actionContext
init|=
operator|new
name|Action
operator|.
name|ActionContext
argument_list|(
name|util
argument_list|)
decl_stmt|;
name|restartRSAction
operator|.
name|init
argument_list|(
name|actionContext
argument_list|)
expr_stmt|;
name|restartMetaAction
operator|.
name|init
argument_list|(
name|actionContext
argument_list|)
expr_stmt|;
name|moveRegionAction
operator|.
name|init
argument_list|(
name|actionContext
argument_list|)
expr_stmt|;
name|restartMasterAction
operator|.
name|init
argument_list|(
name|actionContext
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|setupTables
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Get the table name.
name|tableName
operator|=
name|TableName
operator|.
name|valueOf
argument_list|(
name|util
operator|.
name|getConfiguration
argument_list|()
operator|.
name|get
argument_list|(
literal|"hbase.IntegrationTestMTTR.tableName"
argument_list|,
literal|"IntegrationTestMTTR"
argument_list|)
argument_list|)
expr_stmt|;
name|loadTableName
operator|=
name|TableName
operator|.
name|valueOf
argument_list|(
name|util
operator|.
name|getConfiguration
argument_list|()
operator|.
name|get
argument_list|(
literal|"hbase.IntegrationTestMTTR.loadTableName"
argument_list|,
literal|"IntegrationTestMTTRLoadTestTool"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|util
operator|.
name|getHBaseAdmin
argument_list|()
operator|.
name|tableExists
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|util
operator|.
name|deleteTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|util
operator|.
name|getHBaseAdmin
argument_list|()
operator|.
name|tableExists
argument_list|(
name|loadTableName
argument_list|)
condition|)
block|{
name|util
operator|.
name|deleteTable
argument_list|(
name|loadTableName
argument_list|)
expr_stmt|;
block|}
comment|// Create the table.  If this fails then fail everything.
name|HTableDescriptor
name|tableDescriptor
init|=
operator|new
name|HTableDescriptor
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
comment|// Make the max file size huge so that splits don't happen during the test.
name|tableDescriptor
operator|.
name|setMaxFileSize
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
name|HColumnDescriptor
name|descriptor
init|=
operator|new
name|HColumnDescriptor
argument_list|(
name|FAMILY
argument_list|)
decl_stmt|;
name|descriptor
operator|.
name|setMaxVersions
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|tableDescriptor
operator|.
name|addFamily
argument_list|(
name|descriptor
argument_list|)
expr_stmt|;
name|util
operator|.
name|getHBaseAdmin
argument_list|()
operator|.
name|createTable
argument_list|(
name|tableDescriptor
argument_list|)
expr_stmt|;
comment|// Setup the table for LoadTestTool
name|int
name|ret
init|=
name|loadTool
operator|.
name|run
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"-tn"
block|,
name|loadTableName
operator|.
name|getNameAsString
argument_list|()
block|,
literal|"-init_only"
block|}
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Failed to initialize LoadTestTool"
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
annotation|@
name|AfterClass
specifier|public
specifier|static
name|void
name|after
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Clean everything up.
name|util
operator|.
name|restoreCluster
argument_list|()
expr_stmt|;
name|util
operator|=
literal|null
expr_stmt|;
comment|// Stop the threads so that we know everything is complete.
name|executorService
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|executorService
operator|=
literal|null
expr_stmt|;
comment|// Clean up the actions.
name|moveRegionAction
operator|=
literal|null
expr_stmt|;
name|restartMetaAction
operator|=
literal|null
expr_stmt|;
name|restartRSAction
operator|=
literal|null
expr_stmt|;
name|restartMasterAction
operator|=
literal|null
expr_stmt|;
name|loadTool
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRestartRsHoldingTable
parameter_list|()
throws|throws
name|Exception
block|{
name|run
argument_list|(
operator|new
name|ActionCallable
argument_list|(
name|restartRSAction
argument_list|)
argument_list|,
literal|"RestartRsHoldingTableAction"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testKillRsHoldingMeta
parameter_list|()
throws|throws
name|Exception
block|{
name|run
argument_list|(
operator|new
name|ActionCallable
argument_list|(
name|restartMetaAction
argument_list|)
argument_list|,
literal|"KillRsHoldingMeta"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMoveRegion
parameter_list|()
throws|throws
name|Exception
block|{
name|run
argument_list|(
operator|new
name|ActionCallable
argument_list|(
name|moveRegionAction
argument_list|)
argument_list|,
literal|"MoveRegion"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRestartMaster
parameter_list|()
throws|throws
name|Exception
block|{
name|run
argument_list|(
operator|new
name|ActionCallable
argument_list|(
name|restartMasterAction
argument_list|)
argument_list|,
literal|"RestartMaster"
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|run
parameter_list|(
name|Callable
argument_list|<
name|Boolean
argument_list|>
name|monkeyCallable
parameter_list|,
name|String
name|testName
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|maxIters
init|=
name|util
operator|.
name|getHBaseClusterInterface
argument_list|()
operator|.
name|isDistributedCluster
argument_list|()
condition|?
literal|10
else|:
literal|3
decl_stmt|;
comment|// Array to keep track of times.
name|ArrayList
argument_list|<
name|TimingResult
argument_list|>
name|resultPuts
init|=
operator|new
name|ArrayList
argument_list|<
name|TimingResult
argument_list|>
argument_list|(
name|maxIters
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|TimingResult
argument_list|>
name|resultScan
init|=
operator|new
name|ArrayList
argument_list|<
name|TimingResult
argument_list|>
argument_list|(
name|maxIters
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|TimingResult
argument_list|>
name|resultAdmin
init|=
operator|new
name|ArrayList
argument_list|<
name|TimingResult
argument_list|>
argument_list|(
name|maxIters
argument_list|)
decl_stmt|;
name|long
name|start
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
comment|// We're going to try this multiple times
for|for
control|(
name|int
name|fullIterations
init|=
literal|0
init|;
name|fullIterations
operator|<
name|maxIters
condition|;
name|fullIterations
operator|++
control|)
block|{
comment|// Create and start executing a callable that will kill the servers
name|Future
argument_list|<
name|Boolean
argument_list|>
name|monkeyFuture
init|=
name|executorService
operator|.
name|submit
argument_list|(
name|monkeyCallable
argument_list|)
decl_stmt|;
comment|// Pass that future to the timing Callables.
name|Future
argument_list|<
name|TimingResult
argument_list|>
name|putFuture
init|=
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|PutCallable
argument_list|(
name|monkeyFuture
argument_list|)
argument_list|)
decl_stmt|;
name|Future
argument_list|<
name|TimingResult
argument_list|>
name|scanFuture
init|=
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|ScanCallable
argument_list|(
name|monkeyFuture
argument_list|)
argument_list|)
decl_stmt|;
name|Future
argument_list|<
name|TimingResult
argument_list|>
name|adminFuture
init|=
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|AdminCallable
argument_list|(
name|monkeyFuture
argument_list|)
argument_list|)
decl_stmt|;
name|Future
argument_list|<
name|Boolean
argument_list|>
name|loadFuture
init|=
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|LoadCallable
argument_list|(
name|monkeyFuture
argument_list|)
argument_list|)
decl_stmt|;
name|monkeyFuture
operator|.
name|get
argument_list|()
expr_stmt|;
name|loadFuture
operator|.
name|get
argument_list|()
expr_stmt|;
comment|// Get the values from the futures.
name|TimingResult
name|putTime
init|=
name|putFuture
operator|.
name|get
argument_list|()
decl_stmt|;
name|TimingResult
name|scanTime
init|=
name|scanFuture
operator|.
name|get
argument_list|()
decl_stmt|;
name|TimingResult
name|adminTime
init|=
name|adminFuture
operator|.
name|get
argument_list|()
decl_stmt|;
comment|// Store the times to display later.
name|resultPuts
operator|.
name|add
argument_list|(
name|putTime
argument_list|)
expr_stmt|;
name|resultScan
operator|.
name|add
argument_list|(
name|scanTime
argument_list|)
expr_stmt|;
name|resultAdmin
operator|.
name|add
argument_list|(
name|adminTime
argument_list|)
expr_stmt|;
comment|// Wait some time for everything to settle down.
name|Thread
operator|.
name|sleep
argument_list|(
literal|5000l
argument_list|)
expr_stmt|;
block|}
name|long
name|runtimeMs
init|=
name|TimeUnit
operator|.
name|MILLISECONDS
operator|.
name|convert
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|start
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
decl_stmt|;
name|Objects
operator|.
name|ToStringHelper
name|helper
init|=
name|Objects
operator|.
name|toStringHelper
argument_list|(
literal|"MTTRResults"
argument_list|)
operator|.
name|add
argument_list|(
literal|"putResults"
argument_list|,
name|resultPuts
argument_list|)
operator|.
name|add
argument_list|(
literal|"scanResults"
argument_list|,
name|resultScan
argument_list|)
operator|.
name|add
argument_list|(
literal|"adminResults"
argument_list|,
name|resultAdmin
argument_list|)
operator|.
name|add
argument_list|(
literal|"totalRuntimeMs"
argument_list|,
name|runtimeMs
argument_list|)
operator|.
name|add
argument_list|(
literal|"name"
argument_list|,
name|testName
argument_list|)
decl_stmt|;
comment|// Log the info
name|LOG
operator|.
name|info
argument_list|(
name|helper
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Class to store results of TimingCallable.    *    * Stores times and trace id.    */
specifier|private
specifier|static
class|class
name|TimingResult
block|{
name|DescriptiveStatistics
name|stats
init|=
operator|new
name|DescriptiveStatistics
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|Long
argument_list|>
name|traces
init|=
operator|new
name|ArrayList
argument_list|<
name|Long
argument_list|>
argument_list|(
literal|10
argument_list|)
decl_stmt|;
comment|/**      * Add a result to this aggregate result.      * @param time Time in nanoseconds      * @param span Span.  To be kept if the time taken was over 1 second      */
specifier|public
name|void
name|addResult
parameter_list|(
name|long
name|time
parameter_list|,
name|Span
name|span
parameter_list|)
block|{
name|stats
operator|.
name|addValue
argument_list|(
name|TimeUnit
operator|.
name|MILLISECONDS
operator|.
name|convert
argument_list|(
name|time
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TimeUnit
operator|.
name|SECONDS
operator|.
name|convert
argument_list|(
name|time
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
operator|>=
literal|1
condition|)
block|{
name|traces
operator|.
name|add
argument_list|(
name|span
operator|.
name|getTraceId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|Objects
operator|.
name|ToStringHelper
name|helper
init|=
name|Objects
operator|.
name|toStringHelper
argument_list|(
name|this
argument_list|)
operator|.
name|add
argument_list|(
literal|"numResults"
argument_list|,
name|stats
operator|.
name|getN
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
literal|"minTime"
argument_list|,
name|stats
operator|.
name|getMin
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
literal|"meanTime"
argument_list|,
name|stats
operator|.
name|getMean
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
literal|"maxTime"
argument_list|,
name|stats
operator|.
name|getMax
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
literal|"25th"
argument_list|,
name|stats
operator|.
name|getPercentile
argument_list|(
literal|25
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
literal|"50th"
argument_list|,
name|stats
operator|.
name|getPercentile
argument_list|(
literal|50
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
literal|"75th"
argument_list|,
name|stats
operator|.
name|getPercentile
argument_list|(
literal|75
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
literal|"90th"
argument_list|,
name|stats
operator|.
name|getPercentile
argument_list|(
literal|90
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
literal|"95th"
argument_list|,
name|stats
operator|.
name|getPercentile
argument_list|(
literal|95
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
literal|"99th"
argument_list|,
name|stats
operator|.
name|getPercentile
argument_list|(
literal|99
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
literal|"99.9th"
argument_list|,
name|stats
operator|.
name|getPercentile
argument_list|(
literal|99.9
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
literal|"99.99th"
argument_list|,
name|stats
operator|.
name|getPercentile
argument_list|(
literal|99.99
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
literal|"traces"
argument_list|,
name|traces
argument_list|)
decl_stmt|;
return|return
name|helper
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * Base class for actions that need to record the time needed to recover from a failure.    */
specifier|static
specifier|abstract
class|class
name|TimingCallable
implements|implements
name|Callable
argument_list|<
name|TimingResult
argument_list|>
block|{
specifier|protected
specifier|final
name|Future
argument_list|<
name|?
argument_list|>
name|future
decl_stmt|;
specifier|public
name|TimingCallable
parameter_list|(
name|Future
argument_list|<
name|?
argument_list|>
name|f
parameter_list|)
block|{
name|future
operator|=
name|f
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|TimingResult
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|TimingResult
name|result
init|=
operator|new
name|TimingResult
argument_list|()
decl_stmt|;
specifier|final
name|int
name|maxIterations
init|=
literal|10
decl_stmt|;
name|int
name|numAfterDone
init|=
literal|0
decl_stmt|;
name|int
name|resetCount
init|=
literal|0
decl_stmt|;
comment|// Keep trying until the rs is back up and we've gotten a put through
while|while
condition|(
name|numAfterDone
operator|<
name|maxIterations
condition|)
block|{
name|long
name|start
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|TraceScope
name|scope
init|=
literal|null
decl_stmt|;
try|try
block|{
name|scope
operator|=
name|Trace
operator|.
name|startSpan
argument_list|(
name|getSpanName
argument_list|()
argument_list|,
name|AlwaysSampler
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
name|boolean
name|actionResult
init|=
name|doAction
argument_list|()
decl_stmt|;
if|if
condition|(
name|actionResult
operator|&&
name|future
operator|.
name|isDone
argument_list|()
condition|)
block|{
name|numAfterDone
operator|++
expr_stmt|;
block|}
comment|// the following Exceptions derive from DoNotRetryIOException. They are considered
comment|// fatal for the purpose of this test. If we see one of these, it means something is
comment|// broken and needs investigation. This is not the case for all children of DNRIOE.
comment|// Unfortunately, this is an explicit enumeration and will need periodically refreshed.
comment|// See HBASE-9655 for further discussion.
block|}
catch|catch
parameter_list|(
name|AccessDeniedException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|CoprocessorException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|FatalConnectionException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|InvalidFamilyOperationException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|NamespaceExistException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|NamespaceNotFoundException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|NoSuchColumnFamilyException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|TableExistsException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|TableNotFoundException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|RetriesExhaustedException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
comment|// Everything else is potentially recoverable on the application side. For instance, a CM
comment|// action kills the RS that hosted a scanner the client was using. Continued use of that
comment|// scanner should be terminated, but a new scanner can be created and the read attempted
comment|// again.
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|resetCount
operator|++
expr_stmt|;
if|if
condition|(
name|resetCount
operator|<
name|maxIterations
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Non-fatal exception while running "
operator|+
name|this
operator|.
name|toString
argument_list|()
operator|+
literal|". Resetting loop counter"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|numAfterDone
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Too many unexpected Exceptions. Aborting."
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|scope
operator|!=
literal|null
condition|)
block|{
name|scope
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
name|result
operator|.
name|addResult
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|start
argument_list|,
name|scope
operator|.
name|getSpan
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|protected
specifier|abstract
name|boolean
name|doAction
parameter_list|()
throws|throws
name|Exception
function_decl|;
specifier|protected
name|String
name|getSpanName
parameter_list|()
block|{
return|return
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|this
operator|.
name|getSpanName
argument_list|()
return|;
block|}
block|}
comment|/**    * Callable that will keep putting small amounts of data into a table    * until  the future supplied returns.  It keeps track of the max time.    */
specifier|static
class|class
name|PutCallable
extends|extends
name|TimingCallable
block|{
specifier|private
specifier|final
name|HTable
name|table
decl_stmt|;
specifier|public
name|PutCallable
parameter_list|(
name|Future
argument_list|<
name|?
argument_list|>
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|this
operator|.
name|table
operator|=
operator|new
name|HTable
argument_list|(
name|util
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|doAction
parameter_list|()
throws|throws
name|Exception
block|{
name|Put
name|p
init|=
operator|new
name|Put
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|RandomStringUtils
operator|.
name|randomAlphanumeric
argument_list|(
literal|5
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|p
operator|.
name|add
argument_list|(
name|FAMILY
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"\0"
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|RandomStringUtils
operator|.
name|randomAscii
argument_list|(
literal|5
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|table
operator|.
name|put
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|table
operator|.
name|flushCommits
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getSpanName
parameter_list|()
block|{
return|return
literal|"MTTR Put Test"
return|;
block|}
block|}
comment|/**    * Callable that will keep scanning for small amounts of data until the    * supplied future returns.  Returns the max time taken to scan.    */
specifier|static
class|class
name|ScanCallable
extends|extends
name|TimingCallable
block|{
specifier|private
specifier|final
name|HTable
name|table
decl_stmt|;
specifier|public
name|ScanCallable
parameter_list|(
name|Future
argument_list|<
name|?
argument_list|>
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|this
operator|.
name|table
operator|=
operator|new
name|HTable
argument_list|(
name|util
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|doAction
parameter_list|()
throws|throws
name|Exception
block|{
name|ResultScanner
name|rs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|Scan
name|s
init|=
operator|new
name|Scan
argument_list|()
decl_stmt|;
name|s
operator|.
name|setBatch
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|s
operator|.
name|addFamily
argument_list|(
name|FAMILY
argument_list|)
expr_stmt|;
name|s
operator|.
name|setFilter
argument_list|(
operator|new
name|KeyOnlyFilter
argument_list|()
argument_list|)
expr_stmt|;
name|s
operator|.
name|setMaxVersions
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|rs
operator|=
name|table
operator|.
name|getScanner
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|Result
name|result
init|=
name|rs
operator|.
name|next
argument_list|()
decl_stmt|;
return|return
name|result
operator|!=
literal|null
operator|&&
name|result
operator|.
name|size
argument_list|()
operator|>
literal|0
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|rs
operator|!=
literal|null
condition|)
block|{
name|rs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getSpanName
parameter_list|()
block|{
return|return
literal|"MTTR Scan Test"
return|;
block|}
block|}
comment|/**    * Callable that will keep going to the master for cluster status.  Returns the max time taken.    */
specifier|static
class|class
name|AdminCallable
extends|extends
name|TimingCallable
block|{
specifier|public
name|AdminCallable
parameter_list|(
name|Future
argument_list|<
name|?
argument_list|>
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|doAction
parameter_list|()
throws|throws
name|Exception
block|{
name|HBaseAdmin
name|admin
init|=
literal|null
decl_stmt|;
try|try
block|{
name|admin
operator|=
operator|new
name|HBaseAdmin
argument_list|(
name|util
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
name|ClusterStatus
name|status
init|=
name|admin
operator|.
name|getClusterStatus
argument_list|()
decl_stmt|;
return|return
name|status
operator|!=
literal|null
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|admin
operator|!=
literal|null
condition|)
block|{
name|admin
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getSpanName
parameter_list|()
block|{
return|return
literal|"MTTR Admin Test"
return|;
block|}
block|}
specifier|static
class|class
name|ActionCallable
implements|implements
name|Callable
argument_list|<
name|Boolean
argument_list|>
block|{
specifier|private
specifier|final
name|Action
name|action
decl_stmt|;
specifier|public
name|ActionCallable
parameter_list|(
name|Action
name|action
parameter_list|)
block|{
name|this
operator|.
name|action
operator|=
name|action
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|this
operator|.
name|action
operator|.
name|perform
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Callable used to make sure the cluster has some load on it.    * This callable uses LoadTest tool to    */
specifier|public
specifier|static
class|class
name|LoadCallable
implements|implements
name|Callable
argument_list|<
name|Boolean
argument_list|>
block|{
specifier|private
specifier|final
name|Future
argument_list|<
name|?
argument_list|>
name|future
decl_stmt|;
specifier|public
name|LoadCallable
parameter_list|(
name|Future
argument_list|<
name|?
argument_list|>
name|f
parameter_list|)
block|{
name|future
operator|=
name|f
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|colsPerKey
init|=
literal|10
decl_stmt|;
name|int
name|numServers
init|=
name|util
operator|.
name|getHBaseClusterInterface
argument_list|()
operator|.
name|getInitialClusterStatus
argument_list|()
operator|.
name|getServersSize
argument_list|()
decl_stmt|;
name|int
name|numKeys
init|=
name|numServers
operator|*
literal|5000
decl_stmt|;
name|int
name|writeThreads
init|=
literal|10
decl_stmt|;
comment|// Loop until the chaos monkey future is done.
comment|// But always go in just in case some action completes quickly
do|do
block|{
name|int
name|ret
init|=
name|loadTool
operator|.
name|run
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"-tn"
block|,
name|loadTableName
operator|.
name|getNameAsString
argument_list|()
block|,
literal|"-write"
block|,
name|String
operator|.
name|format
argument_list|(
literal|"%d:%d:%d"
argument_list|,
name|colsPerKey
argument_list|,
literal|500
argument_list|,
name|writeThreads
argument_list|)
block|,
literal|"-num_keys"
block|,
name|String
operator|.
name|valueOf
argument_list|(
name|numKeys
argument_list|)
block|,
literal|"-skip_init"
block|}
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Load failed"
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|future
operator|.
name|isDone
argument_list|()
condition|)
do|;
return|return
literal|true
return|;
block|}
block|}
block|}
end_class

end_unit

