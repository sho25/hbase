begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|HBaseSaslRpcClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|HBaseSaslRpcServer
operator|.
name|AuthMethod
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|KerberosInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|TokenInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|User
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|token
operator|.
name|AuthenticationTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|token
operator|.
name|AuthenticationTokenSelector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|PoolMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|SecurityUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenSelector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|net
operator|.
name|SocketFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentSkipListMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_comment
comment|/**  * A client for an IPC service, which support SASL authentication of connections  * using either GSSAPI for Kerberos authentication or DIGEST-MD5 for  * authentication using signed tokens.  *  *<p>  * This is a copy of org.apache.hadoop.ipc.Client from secure Hadoop,  * reworked to remove code duplicated with  * {@link org.apache.hadoop.hbase.HBaseClient}.  This is part of the loadable  * {@link SecureRpcEngine}, and only functions in connection with a  * {@link SecureServer} instance.  *</p>  */
end_comment

begin_class
specifier|public
class|class
name|SecureClient
extends|extends
name|HBaseClient
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
literal|"org.apache.hadoop.ipc.SecureClient"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|TokenSelector
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
argument_list|>
name|tokenHandlers
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|TokenSelector
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|tokenHandlers
operator|.
name|put
argument_list|(
name|AuthenticationTokenIdentifier
operator|.
name|AUTH_TOKEN_TYPE
operator|.
name|toString
argument_list|()
argument_list|,
operator|new
name|AuthenticationTokenSelector
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Thread that reads responses and notifies callers.  Each connection owns a    * socket connected to a remote address.  Calls are multiplexed through this    * socket: responses may be delivered out of order. */
specifier|protected
class|class
name|SecureConnection
extends|extends
name|Connection
block|{
specifier|private
name|InetSocketAddress
name|server
decl_stmt|;
comment|// server ip:port
specifier|private
name|String
name|serverPrincipal
decl_stmt|;
comment|// server's krb5 principal name
specifier|private
name|SecureConnectionHeader
name|header
decl_stmt|;
comment|// connection header
specifier|private
name|AuthMethod
name|authMethod
decl_stmt|;
comment|// authentication method
specifier|private
name|boolean
name|useSasl
decl_stmt|;
specifier|private
name|Token
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|token
decl_stmt|;
specifier|private
name|HBaseSaslRpcClient
name|saslRpcClient
decl_stmt|;
specifier|private
name|int
name|reloginMaxBackoff
decl_stmt|;
comment|// max pause before relogin on sasl failure
specifier|public
name|SecureConnection
parameter_list|(
name|ConnectionId
name|remoteId
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|remoteId
argument_list|)
expr_stmt|;
name|this
operator|.
name|server
operator|=
name|remoteId
operator|.
name|getAddress
argument_list|()
expr_stmt|;
name|User
name|ticket
init|=
name|remoteId
operator|.
name|getTicket
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|protocol
init|=
name|remoteId
operator|.
name|getProtocol
argument_list|()
decl_stmt|;
name|this
operator|.
name|useSasl
operator|=
name|User
operator|.
name|isSecurityEnabled
argument_list|()
expr_stmt|;
if|if
condition|(
name|useSasl
operator|&&
name|protocol
operator|!=
literal|null
condition|)
block|{
name|TokenInfo
name|tokenInfo
init|=
name|protocol
operator|.
name|getAnnotation
argument_list|(
name|TokenInfo
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|tokenInfo
operator|!=
literal|null
condition|)
block|{
name|TokenSelector
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|tokenSelector
init|=
name|tokenHandlers
operator|.
name|get
argument_list|(
name|tokenInfo
operator|.
name|value
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|tokenSelector
operator|!=
literal|null
condition|)
block|{
name|token
operator|=
name|tokenSelector
operator|.
name|selectToken
argument_list|(
operator|new
name|Text
argument_list|(
name|clusterId
argument_list|)
argument_list|,
name|ticket
operator|.
name|getUGI
argument_list|()
operator|.
name|getTokens
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No token selector found for type "
operator|+
name|tokenInfo
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|KerberosInfo
name|krbInfo
init|=
name|protocol
operator|.
name|getAnnotation
argument_list|(
name|KerberosInfo
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|krbInfo
operator|!=
literal|null
condition|)
block|{
name|String
name|serverKey
init|=
name|krbInfo
operator|.
name|serverPrincipal
argument_list|()
decl_stmt|;
if|if
condition|(
name|serverKey
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can't obtain server Kerberos config key from KerberosInfo"
argument_list|)
throw|;
block|}
name|serverPrincipal
operator|=
name|SecurityUtil
operator|.
name|getServerPrincipal
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|serverKey
argument_list|)
argument_list|,
name|server
operator|.
name|getAddress
argument_list|()
operator|.
name|getCanonicalHostName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"RPC Server Kerberos principal name for protocol="
operator|+
name|protocol
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|" is "
operator|+
name|serverPrincipal
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|useSasl
condition|)
block|{
name|authMethod
operator|=
name|AuthMethod
operator|.
name|SIMPLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|!=
literal|null
condition|)
block|{
name|authMethod
operator|=
name|AuthMethod
operator|.
name|DIGEST
expr_stmt|;
block|}
else|else
block|{
name|authMethod
operator|=
name|AuthMethod
operator|.
name|KERBEROS
expr_stmt|;
block|}
name|header
operator|=
operator|new
name|SecureConnectionHeader
argument_list|(
name|protocol
operator|==
literal|null
condition|?
literal|null
else|:
name|protocol
operator|.
name|getName
argument_list|()
argument_list|,
name|ticket
argument_list|,
name|authMethod
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"Use "
operator|+
name|authMethod
operator|+
literal|" authentication for protocol "
operator|+
name|protocol
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
name|reloginMaxBackoff
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.security.relogin.maxbackoff"
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|synchronized
name|void
name|disposeSasl
parameter_list|()
block|{
if|if
condition|(
name|saslRpcClient
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|saslRpcClient
operator|.
name|dispose
argument_list|()
expr_stmt|;
name|saslRpcClient
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Error disposing of SASL client"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|synchronized
name|boolean
name|shouldAuthenticateOverKrb
parameter_list|()
throws|throws
name|IOException
block|{
name|UserGroupInformation
name|loginUser
init|=
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
decl_stmt|;
name|UserGroupInformation
name|currentUser
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
decl_stmt|;
name|UserGroupInformation
name|realUser
init|=
name|currentUser
operator|.
name|getRealUser
argument_list|()
decl_stmt|;
return|return
name|authMethod
operator|==
name|AuthMethod
operator|.
name|KERBEROS
operator|&&
name|loginUser
operator|!=
literal|null
operator|&&
comment|//Make sure user logged in using Kerberos either keytab or TGT
name|loginUser
operator|.
name|hasKerberosCredentials
argument_list|()
operator|&&
comment|// relogin only in case it is the login user (e.g. JT)
comment|// or superuser (like oozie).
operator|(
name|loginUser
operator|.
name|equals
argument_list|(
name|currentUser
argument_list|)
operator|||
name|loginUser
operator|.
name|equals
argument_list|(
name|realUser
argument_list|)
operator|)
return|;
block|}
specifier|private
specifier|synchronized
name|boolean
name|setupSaslConnection
parameter_list|(
specifier|final
name|InputStream
name|in2
parameter_list|,
specifier|final
name|OutputStream
name|out2
parameter_list|)
throws|throws
name|IOException
block|{
name|saslRpcClient
operator|=
operator|new
name|HBaseSaslRpcClient
argument_list|(
name|authMethod
argument_list|,
name|token
argument_list|,
name|serverPrincipal
argument_list|)
expr_stmt|;
return|return
name|saslRpcClient
operator|.
name|saslConnect
argument_list|(
name|in2
argument_list|,
name|out2
argument_list|)
return|;
block|}
comment|/**      * If multiple clients with the same principal try to connect      * to the same server at the same time, the server assumes a      * replay attack is in progress. This is a feature of kerberos.      * In order to work around this, what is done is that the client      * backs off randomly and tries to initiate the connection      * again.      * The other problem is to do with ticket expiry. To handle that,      * a relogin is attempted.      */
specifier|private
specifier|synchronized
name|void
name|handleSaslConnectionFailure
parameter_list|(
specifier|final
name|int
name|currRetries
parameter_list|,
specifier|final
name|int
name|maxRetries
parameter_list|,
specifier|final
name|Exception
name|ex
parameter_list|,
specifier|final
name|Random
name|rand
parameter_list|,
specifier|final
name|User
name|user
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|user
operator|.
name|runAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
specifier|public
name|Object
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|closeConnection
argument_list|()
expr_stmt|;
if|if
condition|(
name|shouldAuthenticateOverKrb
argument_list|()
condition|)
block|{
if|if
condition|(
name|currRetries
operator|<
name|maxRetries
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception encountered while connecting to "
operator|+
literal|"the server : "
operator|+
name|ex
argument_list|)
expr_stmt|;
comment|//try re-login
if|if
condition|(
name|UserGroupInformation
operator|.
name|isLoginKeytabBased
argument_list|()
condition|)
block|{
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
operator|.
name|reloginFromKeytab
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
operator|.
name|reloginFromTicketCache
argument_list|()
expr_stmt|;
block|}
name|disposeSasl
argument_list|()
expr_stmt|;
comment|//have granularity of milliseconds
comment|//we are sleeping with the Connection lock held but since this
comment|//connection instance is being used for connecting to the server
comment|//in question, it is okay
name|Thread
operator|.
name|sleep
argument_list|(
operator|(
name|rand
operator|.
name|nextInt
argument_list|(
name|reloginMaxBackoff
argument_list|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
name|String
name|msg
init|=
literal|"Couldn't setup connection for "
operator|+
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
operator|.
name|getUserName
argument_list|()
operator|+
literal|" to "
operator|+
name|serverPrincipal
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|(
name|IOException
operator|)
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
operator|.
name|initCause
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception encountered while connecting to "
operator|+
literal|"the server : "
operator|+
name|ex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ex
operator|instanceof
name|RemoteException
condition|)
throw|throw
operator|(
name|RemoteException
operator|)
name|ex
throw|;
throw|throw
operator|new
name|IOException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
specifier|synchronized
name|void
name|setupIOstreams
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|socket
operator|!=
literal|null
operator|||
name|shouldCloseConnection
operator|.
name|get
argument_list|()
condition|)
block|{
return|return;
block|}
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Connecting to "
operator|+
name|server
argument_list|)
expr_stmt|;
block|}
name|short
name|numRetries
init|=
literal|0
decl_stmt|;
specifier|final
name|short
name|MAX_RETRIES
init|=
literal|5
decl_stmt|;
name|Random
name|rand
init|=
literal|null
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|setupConnection
argument_list|()
expr_stmt|;
name|InputStream
name|inStream
init|=
name|NetUtils
operator|.
name|getInputStream
argument_list|(
name|socket
argument_list|)
decl_stmt|;
name|OutputStream
name|outStream
init|=
name|NetUtils
operator|.
name|getOutputStream
argument_list|(
name|socket
argument_list|)
decl_stmt|;
name|writeRpcHeader
argument_list|(
name|outStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|useSasl
condition|)
block|{
specifier|final
name|InputStream
name|in2
init|=
name|inStream
decl_stmt|;
specifier|final
name|OutputStream
name|out2
init|=
name|outStream
decl_stmt|;
name|User
name|ticket
init|=
name|remoteId
operator|.
name|getTicket
argument_list|()
decl_stmt|;
if|if
condition|(
name|authMethod
operator|==
name|AuthMethod
operator|.
name|KERBEROS
condition|)
block|{
name|UserGroupInformation
name|ugi
init|=
name|ticket
operator|.
name|getUGI
argument_list|()
decl_stmt|;
if|if
condition|(
name|ugi
operator|!=
literal|null
operator|&&
name|ugi
operator|.
name|getRealUser
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|ticket
operator|=
name|User
operator|.
name|create
argument_list|(
name|ugi
operator|.
name|getRealUser
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|boolean
name|continueSasl
init|=
literal|false
decl_stmt|;
try|try
block|{
name|continueSasl
operator|=
name|ticket
operator|.
name|runAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|run
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|setupSaslConnection
argument_list|(
name|in2
argument_list|,
name|out2
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
if|if
condition|(
name|rand
operator|==
literal|null
condition|)
block|{
name|rand
operator|=
operator|new
name|Random
argument_list|()
expr_stmt|;
block|}
name|handleSaslConnectionFailure
argument_list|(
name|numRetries
operator|++
argument_list|,
name|MAX_RETRIES
argument_list|,
name|ex
argument_list|,
name|rand
argument_list|,
name|ticket
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|continueSasl
condition|)
block|{
comment|// Sasl connect is successful. Let's set up Sasl i/o streams.
name|inStream
operator|=
name|saslRpcClient
operator|.
name|getInputStream
argument_list|(
name|inStream
argument_list|)
expr_stmt|;
name|outStream
operator|=
name|saslRpcClient
operator|.
name|getOutputStream
argument_list|(
name|outStream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// fall back to simple auth because server told us so.
name|authMethod
operator|=
name|AuthMethod
operator|.
name|SIMPLE
expr_stmt|;
name|header
operator|=
operator|new
name|SecureConnectionHeader
argument_list|(
name|header
operator|.
name|getProtocol
argument_list|()
argument_list|,
name|header
operator|.
name|getUser
argument_list|()
argument_list|,
name|authMethod
argument_list|)
expr_stmt|;
name|useSasl
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|this
operator|.
name|in
operator|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
operator|new
name|PingInputStream
argument_list|(
name|inStream
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|out
operator|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|outStream
argument_list|)
argument_list|)
expr_stmt|;
name|writeHeader
argument_list|()
expr_stmt|;
comment|// update last activity time
name|touch
argument_list|()
expr_stmt|;
comment|// start the receiver thread after the socket connection has been set up
name|start
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|markClosed
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/* Write the RPC header */
specifier|private
name|void
name|writeRpcHeader
parameter_list|(
name|OutputStream
name|outStream
parameter_list|)
throws|throws
name|IOException
block|{
name|DataOutputStream
name|out
init|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|outStream
argument_list|)
argument_list|)
decl_stmt|;
comment|// Write out the header, version and authentication method
name|out
operator|.
name|write
argument_list|(
name|SecureServer
operator|.
name|HEADER
operator|.
name|array
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|SecureServer
operator|.
name|CURRENT_VERSION
argument_list|)
expr_stmt|;
name|authMethod
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**      * Write the protocol header for each connection      * Out is not synchronized because only the first thread does this.      */
specifier|private
name|void
name|writeHeader
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Write out the ConnectionHeader
name|DataOutputBuffer
name|buf
init|=
operator|new
name|DataOutputBuffer
argument_list|()
decl_stmt|;
name|header
operator|.
name|write
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|// Write out the payload length
name|int
name|bufLen
init|=
name|buf
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|bufLen
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|buf
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|bufLen
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|receiveResponse
parameter_list|()
block|{
if|if
condition|(
name|shouldCloseConnection
operator|.
name|get
argument_list|()
condition|)
block|{
return|return;
block|}
name|touch
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|id
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
comment|// try to read an id
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|" got value #"
operator|+
name|id
argument_list|)
expr_stmt|;
name|Call
name|call
init|=
name|calls
operator|.
name|remove
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|int
name|state
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
comment|// read call status
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"call #"
operator|+
name|id
operator|+
literal|" state is "
operator|+
name|state
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|==
name|Status
operator|.
name|SUCCESS
operator|.
name|state
condition|)
block|{
name|Writable
name|value
init|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|valueClass
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|value
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
comment|// read value
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"call #"
operator|+
name|id
operator|+
literal|", response is:\n"
operator|+
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|call
operator|.
name|setValue
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|Status
operator|.
name|ERROR
operator|.
name|state
condition|)
block|{
name|call
operator|.
name|setException
argument_list|(
operator|new
name|RemoteException
argument_list|(
name|WritableUtils
operator|.
name|readString
argument_list|(
name|in
argument_list|)
argument_list|,
name|WritableUtils
operator|.
name|readString
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|Status
operator|.
name|FATAL
operator|.
name|state
condition|)
block|{
comment|// Close the connection
name|markClosed
argument_list|(
operator|new
name|RemoteException
argument_list|(
name|WritableUtils
operator|.
name|readString
argument_list|(
name|in
argument_list|)
argument_list|,
name|WritableUtils
operator|.
name|readString
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|SocketTimeoutException
operator|&&
name|remoteId
operator|.
name|rpcTimeout
operator|>
literal|0
condition|)
block|{
comment|// Clean up open calls but don't treat this as a fatal condition,
comment|// since we expect certain responses to not make it by the specified
comment|// {@link ConnectionId#rpcTimeout}.
name|closeException
operator|=
name|e
expr_stmt|;
block|}
else|else
block|{
comment|// Since the server did not respond within the default ping interval
comment|// time, treat this as a fatal condition and close this connection
name|markClosed
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|remoteId
operator|.
name|rpcTimeout
operator|>
literal|0
condition|)
block|{
name|cleanupCalls
argument_list|(
name|remoteId
operator|.
name|rpcTimeout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Close the connection. */
specifier|protected
specifier|synchronized
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
operator|!
name|shouldCloseConnection
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"The connection is not in the closed state"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// release the resources
comment|// first thing to do;take the connection out of the connection list
synchronized|synchronized
init|(
name|connections
init|)
block|{
if|if
condition|(
name|connections
operator|.
name|get
argument_list|(
name|remoteId
argument_list|)
operator|==
name|this
condition|)
block|{
name|connections
operator|.
name|remove
argument_list|(
name|remoteId
argument_list|)
expr_stmt|;
block|}
block|}
comment|// close the streams and therefore the socket
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|disposeSasl
argument_list|()
expr_stmt|;
comment|// clean up all calls
if|if
condition|(
name|closeException
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|calls
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"A connection is closed for no cause and calls are not empty"
argument_list|)
expr_stmt|;
comment|// clean up calls anyway
name|closeException
operator|=
operator|new
name|IOException
argument_list|(
literal|"Unexpected closed connection"
argument_list|)
expr_stmt|;
name|cleanupCalls
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// log the info
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"closing ipc connection to "
operator|+
name|server
operator|+
literal|": "
operator|+
name|closeException
operator|.
name|getMessage
argument_list|()
argument_list|,
name|closeException
argument_list|)
expr_stmt|;
block|}
comment|// cleanup calls
name|cleanupCalls
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|": closed"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Construct an IPC client whose values are of the given {@link org.apache.hadoop.io.Writable}    * class.    * @param valueClass value class    * @param conf configuration    * @param factory socket factory    */
specifier|public
name|SecureClient
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|Writable
argument_list|>
name|valueClass
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|SocketFactory
name|factory
parameter_list|)
block|{
name|super
argument_list|(
name|valueClass
argument_list|,
name|conf
argument_list|,
name|factory
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct an IPC client with the default SocketFactory    * @param valueClass value class    * @param conf configuration    */
specifier|public
name|SecureClient
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|Writable
argument_list|>
name|valueClass
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
argument_list|(
name|valueClass
argument_list|,
name|conf
argument_list|,
name|NetUtils
operator|.
name|getDefaultSocketFactory
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|SecureConnection
name|getConnection
parameter_list|(
name|InetSocketAddress
name|addr
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|VersionedProtocol
argument_list|>
name|protocol
parameter_list|,
name|User
name|ticket
parameter_list|,
name|int
name|rpcTimeout
parameter_list|,
name|Call
name|call
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
operator|!
name|running
operator|.
name|get
argument_list|()
condition|)
block|{
comment|// the client is stopped
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The client is stopped"
argument_list|)
throw|;
block|}
name|SecureConnection
name|connection
decl_stmt|;
comment|/* we could avoid this allocation for each RPC by having a      * connectionsId object and with set() method. We need to manage the      * refs for keys in HashMap properly. For now its ok.      */
name|ConnectionId
name|remoteId
init|=
operator|new
name|ConnectionId
argument_list|(
name|addr
argument_list|,
name|protocol
argument_list|,
name|ticket
argument_list|,
name|rpcTimeout
argument_list|)
decl_stmt|;
do|do
block|{
synchronized|synchronized
init|(
name|connections
init|)
block|{
name|connection
operator|=
operator|(
name|SecureConnection
operator|)
name|connections
operator|.
name|get
argument_list|(
name|remoteId
argument_list|)
expr_stmt|;
if|if
condition|(
name|connection
operator|==
literal|null
condition|)
block|{
name|connection
operator|=
operator|new
name|SecureConnection
argument_list|(
name|remoteId
argument_list|)
expr_stmt|;
name|connections
operator|.
name|put
argument_list|(
name|remoteId
argument_list|,
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|!
name|connection
operator|.
name|addCall
argument_list|(
name|call
argument_list|)
condition|)
do|;
comment|//we don't invoke the method below inside "synchronized (connections)"
comment|//block above. The reason for that is if the server happens to be slow,
comment|//it will take longer to establish a connection and that will slow the
comment|//entire system down.
name|connection
operator|.
name|setupIOstreams
argument_list|()
expr_stmt|;
return|return
name|connection
return|;
block|}
block|}
end_class

end_unit

