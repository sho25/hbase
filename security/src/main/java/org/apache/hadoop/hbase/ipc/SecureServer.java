begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|HbaseObjectWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|WritableWithSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|HBaseSaslRpcServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|HBaseSaslRpcServer
operator|.
name|AuthMethod
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|HBaseSaslRpcServer
operator|.
name|SaslDigestCallbackHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|HBaseSaslRpcServer
operator|.
name|SaslGssCallbackHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|HBaseSaslRpcServer
operator|.
name|SaslStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|User
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ByteBufferOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|BytesWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IntWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
operator|.
name|AuthenticationMethod
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|AuthorizationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|ProxyUsers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|ServiceAuthorizationManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|SecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|SecretManager
operator|.
name|InvalidToken
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|sasl
operator|.
name|Sasl
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|sasl
operator|.
name|SaslException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|sasl
operator|.
name|SaslServer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
operator|.
name|HADOOP_SECURITY_AUTHORIZATION
import|;
end_import

begin_comment
comment|/**  * An abstract IPC service, supporting SASL authentication of connections,  * using GSSAPI for Kerberos authentication or DIGEST-MD5 for authentication  * via signed tokens.  *  *<p>  * This is part of the {@link SecureRpcEngine} implementation.  *</p>  *  * @see org.apache.hadoop.hbase.ipc.SecureClient  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|SecureServer
extends|extends
name|HBaseServer
block|{
specifier|private
specifier|final
name|boolean
name|authorize
decl_stmt|;
specifier|private
name|boolean
name|isSecurityEnabled
decl_stmt|;
comment|/**    * The first four bytes of secure RPC connections    */
specifier|public
specifier|static
specifier|final
name|ByteBuffer
name|HEADER
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
literal|"srpc"
operator|.
name|getBytes
argument_list|()
argument_list|)
decl_stmt|;
comment|// 1 : Introduce ping and server does not throw away RPCs
comment|// 3 : Introduce the protocol into the RPC connection header
comment|// 4 : Introduced SASL security layer
specifier|public
specifier|static
specifier|final
name|byte
name|CURRENT_VERSION
init|=
literal|4
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
literal|"org.apache.hadoop.ipc.SecureServer"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Log
name|AUDITLOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
literal|"SecurityLogger.org.apache.hadoop.ipc.SecureServer"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|AUTH_FAILED_FOR
init|=
literal|"Auth failed for "
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|AUTH_SUCCESSFUL_FOR
init|=
literal|"Auth successful for "
decl_stmt|;
specifier|protected
name|SecretManager
argument_list|<
name|TokenIdentifier
argument_list|>
name|secretManager
decl_stmt|;
specifier|protected
name|ServiceAuthorizationManager
name|authManager
decl_stmt|;
specifier|protected
class|class
name|SecureCall
extends|extends
name|HBaseServer
operator|.
name|Call
block|{
specifier|public
name|SecureCall
parameter_list|(
name|int
name|id
parameter_list|,
name|Writable
name|param
parameter_list|,
name|Connection
name|connection
parameter_list|,
name|Responder
name|responder
parameter_list|,
name|long
name|size
parameter_list|)
block|{
name|super
argument_list|(
name|id
argument_list|,
name|param
argument_list|,
name|connection
argument_list|,
name|responder
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
specifier|synchronized
name|void
name|setResponse
parameter_list|(
name|Object
name|value
parameter_list|,
name|Status
name|status
parameter_list|,
name|String
name|errorClass
parameter_list|,
name|String
name|error
parameter_list|)
block|{
name|Writable
name|result
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Writable
condition|)
block|{
name|result
operator|=
operator|(
name|Writable
operator|)
name|value
expr_stmt|;
block|}
else|else
block|{
comment|/* We might have a null value and errors. Avoid creating a          * HbaseObjectWritable, because the constructor fails on null. */
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
operator|new
name|HbaseObjectWritable
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|size
init|=
name|BUFFER_INITIAL_SIZE
decl_stmt|;
if|if
condition|(
name|result
operator|instanceof
name|WritableWithSize
condition|)
block|{
comment|// get the size hint.
name|WritableWithSize
name|ohint
init|=
operator|(
name|WritableWithSize
operator|)
name|result
decl_stmt|;
name|long
name|hint
init|=
name|ohint
operator|.
name|getWritableSize
argument_list|()
operator|+
name|Bytes
operator|.
name|SIZEOF_INT
operator|+
name|Bytes
operator|.
name|SIZEOF_INT
decl_stmt|;
if|if
condition|(
name|hint
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
comment|// oops, new problem.
name|IOException
name|ioe
init|=
operator|new
name|IOException
argument_list|(
literal|"Result buffer size too large: "
operator|+
name|hint
argument_list|)
decl_stmt|;
name|errorClass
operator|=
name|ioe
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
name|error
operator|=
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
operator|(
name|int
operator|)
name|hint
expr_stmt|;
block|}
block|}
name|ByteBufferOutputStream
name|buf
init|=
operator|new
name|ByteBufferOutputStream
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|DataOutputStream
name|out
init|=
operator|new
name|DataOutputStream
argument_list|(
name|buf
argument_list|)
decl_stmt|;
try|try
block|{
name|out
operator|.
name|writeInt
argument_list|(
name|this
operator|.
name|id
argument_list|)
expr_stmt|;
comment|// write call id
name|out
operator|.
name|writeInt
argument_list|(
name|status
operator|.
name|state
argument_list|)
expr_stmt|;
comment|// write status
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|errorClass
operator|=
name|e
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
name|error
operator|=
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|status
operator|==
name|Status
operator|.
name|SUCCESS
condition|)
block|{
name|result
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WritableUtils
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|errorClass
argument_list|)
expr_stmt|;
name|WritableUtils
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|SecureConnection
operator|)
name|connection
operator|)
operator|.
name|useWrap
condition|)
block|{
name|wrapWithSasl
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error sending response to call: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|response
operator|=
name|buf
operator|.
name|getByteBuffer
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|wrapWithSasl
parameter_list|(
name|ByteBufferOutputStream
name|response
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|(
operator|(
name|SecureConnection
operator|)
name|connection
operator|)
operator|.
name|useSasl
condition|)
block|{
comment|// getByteBuffer calls flip()
name|ByteBuffer
name|buf
init|=
name|response
operator|.
name|getByteBuffer
argument_list|()
decl_stmt|;
name|byte
index|[]
name|token
decl_stmt|;
comment|// synchronization may be needed since there can be multiple Handler
comment|// threads using saslServer to wrap responses.
synchronized|synchronized
init|(
operator|(
operator|(
name|SecureConnection
operator|)
name|connection
operator|)
operator|.
name|saslServer
init|)
block|{
name|token
operator|=
operator|(
operator|(
name|SecureConnection
operator|)
name|connection
operator|)
operator|.
name|saslServer
operator|.
name|wrap
argument_list|(
name|buf
operator|.
name|array
argument_list|()
argument_list|,
name|buf
operator|.
name|arrayOffset
argument_list|()
argument_list|,
name|buf
operator|.
name|remaining
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding saslServer wrapped token of size "
operator|+
name|token
operator|.
name|length
operator|+
literal|" as call response."
argument_list|)
expr_stmt|;
name|buf
operator|.
name|clear
argument_list|()
expr_stmt|;
name|DataOutputStream
name|saslOut
init|=
operator|new
name|DataOutputStream
argument_list|(
name|response
argument_list|)
decl_stmt|;
name|saslOut
operator|.
name|writeInt
argument_list|(
name|token
operator|.
name|length
argument_list|)
expr_stmt|;
name|saslOut
operator|.
name|write
argument_list|(
name|token
argument_list|,
literal|0
argument_list|,
name|token
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Reads calls from a connection and queues them for handling. */
specifier|public
class|class
name|SecureConnection
extends|extends
name|HBaseServer
operator|.
name|Connection
block|{
specifier|private
name|boolean
name|rpcHeaderRead
init|=
literal|false
decl_stmt|;
comment|// if initial rpc header is read
specifier|private
name|boolean
name|headerRead
init|=
literal|false
decl_stmt|;
comment|//if the connection header that
comment|//follows version is read.
specifier|private
name|ByteBuffer
name|data
decl_stmt|;
specifier|private
name|ByteBuffer
name|dataLengthBuffer
decl_stmt|;
specifier|protected
specifier|final
name|LinkedList
argument_list|<
name|SecureCall
argument_list|>
name|responseQueue
decl_stmt|;
specifier|private
name|int
name|dataLength
decl_stmt|;
specifier|private
name|InetAddress
name|addr
decl_stmt|;
name|boolean
name|useSasl
decl_stmt|;
name|SaslServer
name|saslServer
decl_stmt|;
specifier|private
name|AuthMethod
name|authMethod
decl_stmt|;
specifier|private
name|boolean
name|saslContextEstablished
decl_stmt|;
specifier|private
name|boolean
name|skipInitialSaslHandshake
decl_stmt|;
specifier|private
name|ByteBuffer
name|rpcHeaderBuffer
decl_stmt|;
specifier|private
name|ByteBuffer
name|unwrappedData
decl_stmt|;
specifier|private
name|ByteBuffer
name|unwrappedDataLengthBuffer
decl_stmt|;
specifier|private
name|SecureConnectionHeader
name|header
decl_stmt|;
specifier|public
name|UserGroupInformation
name|attemptingUser
init|=
literal|null
decl_stmt|;
comment|// user name before auth
comment|// Fake 'call' for failed authorization response
specifier|private
specifier|final
name|int
name|AUTHORIZATION_FAILED_CALLID
init|=
operator|-
literal|1
decl_stmt|;
comment|// Fake 'call' for SASL context setup
specifier|private
specifier|static
specifier|final
name|int
name|SASL_CALLID
init|=
operator|-
literal|33
decl_stmt|;
specifier|private
specifier|final
name|SecureCall
name|saslCall
init|=
operator|new
name|SecureCall
argument_list|(
name|SASL_CALLID
argument_list|,
literal|null
argument_list|,
name|this
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|private
name|boolean
name|useWrap
init|=
literal|false
decl_stmt|;
specifier|public
name|SecureConnection
parameter_list|(
name|SocketChannel
name|channel
parameter_list|,
name|long
name|lastContact
parameter_list|)
block|{
name|super
argument_list|(
name|channel
argument_list|,
name|lastContact
argument_list|)
expr_stmt|;
name|this
operator|.
name|header
operator|=
operator|new
name|SecureConnectionHeader
argument_list|()
expr_stmt|;
name|this
operator|.
name|channel
operator|=
name|channel
expr_stmt|;
name|this
operator|.
name|data
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|dataLengthBuffer
operator|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|this
operator|.
name|unwrappedData
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|unwrappedDataLengthBuffer
operator|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|this
operator|.
name|socket
operator|=
name|channel
operator|.
name|socket
argument_list|()
expr_stmt|;
name|this
operator|.
name|addr
operator|=
name|socket
operator|.
name|getInetAddress
argument_list|()
expr_stmt|;
name|this
operator|.
name|responseQueue
operator|=
operator|new
name|LinkedList
argument_list|<
name|SecureCall
argument_list|>
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getHostAddress
argument_list|()
operator|+
literal|":"
operator|+
name|remotePort
return|;
block|}
specifier|public
name|String
name|getHostAddress
parameter_list|()
block|{
return|return
name|hostAddress
return|;
block|}
specifier|public
name|InetAddress
name|getHostInetAddress
parameter_list|()
block|{
return|return
name|addr
return|;
block|}
specifier|private
name|User
name|getAuthorizedUgi
parameter_list|(
name|String
name|authorizedId
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|authMethod
operator|==
name|AuthMethod
operator|.
name|DIGEST
condition|)
block|{
name|TokenIdentifier
name|tokenId
init|=
name|HBaseSaslRpcServer
operator|.
name|getIdentifier
argument_list|(
name|authorizedId
argument_list|,
name|secretManager
argument_list|)
decl_stmt|;
name|UserGroupInformation
name|ugi
init|=
name|tokenId
operator|.
name|getUser
argument_list|()
decl_stmt|;
if|if
condition|(
name|ugi
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AccessControlException
argument_list|(
literal|"Can't retrieve username from tokenIdentifier."
argument_list|)
throw|;
block|}
name|ugi
operator|.
name|addTokenIdentifier
argument_list|(
name|tokenId
argument_list|)
expr_stmt|;
return|return
name|User
operator|.
name|create
argument_list|(
name|ugi
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|User
operator|.
name|create
argument_list|(
name|UserGroupInformation
operator|.
name|createRemoteUser
argument_list|(
name|authorizedId
argument_list|)
argument_list|)
return|;
block|}
block|}
specifier|private
name|void
name|saslReadAndProcess
parameter_list|(
name|byte
index|[]
name|saslToken
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
operator|!
name|saslContextEstablished
condition|)
block|{
name|byte
index|[]
name|replyToken
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|saslServer
operator|==
literal|null
condition|)
block|{
switch|switch
condition|(
name|authMethod
condition|)
block|{
case|case
name|DIGEST
case|:
if|if
condition|(
name|secretManager
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AccessControlException
argument_list|(
literal|"Server is not configured to do DIGEST authentication."
argument_list|)
throw|;
block|}
name|saslServer
operator|=
name|Sasl
operator|.
name|createSaslServer
argument_list|(
name|AuthMethod
operator|.
name|DIGEST
operator|.
name|getMechanismName
argument_list|()
argument_list|,
literal|null
argument_list|,
name|HBaseSaslRpcServer
operator|.
name|SASL_DEFAULT_REALM
argument_list|,
name|HBaseSaslRpcServer
operator|.
name|SASL_PROPS
argument_list|,
operator|new
name|SaslDigestCallbackHandler
argument_list|(
name|secretManager
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UserGroupInformation
name|current
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
decl_stmt|;
name|String
name|fullName
init|=
name|current
operator|.
name|getUserName
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"Kerberos principal name is "
operator|+
name|fullName
argument_list|)
expr_stmt|;
specifier|final
name|String
name|names
index|[]
init|=
name|HBaseSaslRpcServer
operator|.
name|splitKerberosName
argument_list|(
name|fullName
argument_list|)
decl_stmt|;
if|if
condition|(
name|names
operator|.
name|length
operator|!=
literal|3
condition|)
block|{
throw|throw
operator|new
name|AccessControlException
argument_list|(
literal|"Kerberos principal name does NOT have the expected "
operator|+
literal|"hostname part: "
operator|+
name|fullName
argument_list|)
throw|;
block|}
name|current
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|run
parameter_list|()
throws|throws
name|SaslException
block|{
name|saslServer
operator|=
name|Sasl
operator|.
name|createSaslServer
argument_list|(
name|AuthMethod
operator|.
name|KERBEROS
operator|.
name|getMechanismName
argument_list|()
argument_list|,
name|names
index|[
literal|0
index|]
argument_list|,
name|names
index|[
literal|1
index|]
argument_list|,
name|HBaseSaslRpcServer
operator|.
name|SASL_PROPS
argument_list|,
operator|new
name|SaslGssCallbackHandler
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|saslServer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|AccessControlException
argument_list|(
literal|"Unable to find SASL server implementation for "
operator|+
name|authMethod
operator|.
name|getMechanismName
argument_list|()
argument_list|)
throw|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created SASL server with mechanism = "
operator|+
name|authMethod
operator|.
name|getMechanismName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"Have read input token of size "
operator|+
name|saslToken
operator|.
name|length
operator|+
literal|" for processing by saslServer.evaluateResponse()"
argument_list|)
expr_stmt|;
name|replyToken
operator|=
name|saslServer
operator|.
name|evaluateResponse
argument_list|(
name|saslToken
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|IOException
name|sendToClient
init|=
name|e
decl_stmt|;
name|Throwable
name|cause
init|=
name|e
decl_stmt|;
while|while
condition|(
name|cause
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|cause
operator|instanceof
name|InvalidToken
condition|)
block|{
name|sendToClient
operator|=
operator|(
name|InvalidToken
operator|)
name|cause
expr_stmt|;
break|break;
block|}
name|cause
operator|=
name|cause
operator|.
name|getCause
argument_list|()
expr_stmt|;
block|}
name|doSaslReply
argument_list|(
name|SaslStatus
operator|.
name|ERROR
argument_list|,
literal|null
argument_list|,
name|sendToClient
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|sendToClient
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
name|rpcMetrics
operator|.
name|authenticationFailures
operator|.
name|inc
argument_list|()
expr_stmt|;
name|String
name|clientIP
init|=
name|this
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|// attempting user could be null
name|AUDITLOG
operator|.
name|warn
argument_list|(
name|AUTH_FAILED_FOR
operator|+
name|clientIP
operator|+
literal|":"
operator|+
name|attemptingUser
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
if|if
condition|(
name|replyToken
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"Will send token of size "
operator|+
name|replyToken
operator|.
name|length
operator|+
literal|" from saslServer."
argument_list|)
expr_stmt|;
name|doSaslReply
argument_list|(
name|SaslStatus
operator|.
name|SUCCESS
argument_list|,
operator|new
name|BytesWritable
argument_list|(
name|replyToken
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|saslServer
operator|.
name|isComplete
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"SASL server context established. Negotiated QoP is "
operator|+
name|saslServer
operator|.
name|getNegotiatedProperty
argument_list|(
name|Sasl
operator|.
name|QOP
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|qop
init|=
operator|(
name|String
operator|)
name|saslServer
operator|.
name|getNegotiatedProperty
argument_list|(
name|Sasl
operator|.
name|QOP
argument_list|)
decl_stmt|;
name|useWrap
operator|=
name|qop
operator|!=
literal|null
operator|&&
operator|!
literal|"auth"
operator|.
name|equalsIgnoreCase
argument_list|(
name|qop
argument_list|)
expr_stmt|;
name|user
operator|=
name|getAuthorizedUgi
argument_list|(
name|saslServer
operator|.
name|getAuthorizationID
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"SASL server successfully authenticated client: "
operator|+
name|user
argument_list|)
expr_stmt|;
name|rpcMetrics
operator|.
name|authenticationSuccesses
operator|.
name|inc
argument_list|()
expr_stmt|;
name|AUDITLOG
operator|.
name|trace
argument_list|(
name|AUTH_SUCCESSFUL_FOR
operator|+
name|user
argument_list|)
expr_stmt|;
name|saslContextEstablished
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"Have read input token of size "
operator|+
name|saslToken
operator|.
name|length
operator|+
literal|" for processing by saslServer.unwrap()"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|useWrap
condition|)
block|{
name|processOneRpc
argument_list|(
name|saslToken
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|byte
index|[]
name|plaintextData
init|=
name|saslServer
operator|.
name|unwrap
argument_list|(
name|saslToken
argument_list|,
literal|0
argument_list|,
name|saslToken
operator|.
name|length
argument_list|)
decl_stmt|;
name|processUnwrappedData
argument_list|(
name|plaintextData
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|doSaslReply
parameter_list|(
name|SaslStatus
name|status
parameter_list|,
name|Writable
name|rv
parameter_list|,
name|String
name|errorClass
parameter_list|,
name|String
name|error
parameter_list|)
throws|throws
name|IOException
block|{
name|saslCall
operator|.
name|setResponse
argument_list|(
name|rv
argument_list|,
name|status
operator|==
name|SaslStatus
operator|.
name|SUCCESS
condition|?
name|Status
operator|.
name|SUCCESS
else|:
name|Status
operator|.
name|ERROR
argument_list|,
name|errorClass
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|saslCall
operator|.
name|responder
operator|=
name|responder
expr_stmt|;
name|saslCall
operator|.
name|sendResponseIfReady
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|disposeSasl
parameter_list|()
block|{
if|if
condition|(
name|saslServer
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|saslServer
operator|.
name|dispose
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SaslException
name|ignored
parameter_list|)
block|{         }
block|}
block|}
specifier|public
name|int
name|readAndProcess
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
while|while
condition|(
literal|true
condition|)
block|{
comment|/* Read at most one RPC. If the header is not read completely yet          * then iterate until we read first RPC or until there is no data left.          */
name|int
name|count
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|dataLengthBuffer
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
block|{
name|count
operator|=
name|channelRead
argument_list|(
name|channel
argument_list|,
name|dataLengthBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
argument_list|<
literal|0
operator|||
name|dataLengthBuffer
operator|.
name|remaining
operator|(
operator|)
argument_list|>
literal|0
condition|)
return|return
name|count
return|;
block|}
if|if
condition|(
operator|!
name|rpcHeaderRead
condition|)
block|{
comment|//Every connection is expected to send the header.
if|if
condition|(
name|rpcHeaderBuffer
operator|==
literal|null
condition|)
block|{
name|rpcHeaderBuffer
operator|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
name|channelRead
argument_list|(
name|channel
argument_list|,
name|rpcHeaderBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
argument_list|<
literal|0
operator|||
name|rpcHeaderBuffer
operator|.
name|remaining
operator|(
operator|)
argument_list|>
literal|0
condition|)
block|{
return|return
name|count
return|;
block|}
name|int
name|version
init|=
name|rpcHeaderBuffer
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|byte
index|[]
name|method
init|=
operator|new
name|byte
index|[]
block|{
name|rpcHeaderBuffer
operator|.
name|get
argument_list|(
literal|1
argument_list|)
block|}
decl_stmt|;
name|authMethod
operator|=
name|AuthMethod
operator|.
name|read
argument_list|(
operator|new
name|DataInputStream
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|method
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dataLengthBuffer
operator|.
name|flip
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|HEADER
operator|.
name|equals
argument_list|(
name|dataLengthBuffer
argument_list|)
operator|||
name|version
operator|!=
name|CURRENT_VERSION
condition|)
block|{
comment|//Warning is ok since this is not supposed to happen.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Incorrect header or version mismatch from "
operator|+
name|hostAddress
operator|+
literal|":"
operator|+
name|remotePort
operator|+
literal|" got version "
operator|+
name|version
operator|+
literal|" expected version "
operator|+
name|CURRENT_VERSION
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|dataLengthBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|authMethod
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to read authentication method"
argument_list|)
throw|;
block|}
if|if
condition|(
name|isSecurityEnabled
operator|&&
name|authMethod
operator|==
name|AuthMethod
operator|.
name|SIMPLE
condition|)
block|{
name|AccessControlException
name|ae
init|=
operator|new
name|AccessControlException
argument_list|(
literal|"Authentication is required"
argument_list|)
decl_stmt|;
name|SecureCall
name|failedCall
init|=
operator|new
name|SecureCall
argument_list|(
name|AUTHORIZATION_FAILED_CALLID
argument_list|,
literal|null
argument_list|,
name|this
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|failedCall
operator|.
name|setResponse
argument_list|(
literal|null
argument_list|,
name|Status
operator|.
name|FATAL
argument_list|,
name|ae
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|ae
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|responder
operator|.
name|doRespond
argument_list|(
name|failedCall
argument_list|)
expr_stmt|;
throw|throw
name|ae
throw|;
block|}
if|if
condition|(
operator|!
name|isSecurityEnabled
operator|&&
name|authMethod
operator|!=
name|AuthMethod
operator|.
name|SIMPLE
condition|)
block|{
name|doSaslReply
argument_list|(
name|SaslStatus
operator|.
name|SUCCESS
argument_list|,
operator|new
name|IntWritable
argument_list|(
name|HBaseSaslRpcServer
operator|.
name|SWITCH_TO_SIMPLE_AUTH
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|authMethod
operator|=
name|AuthMethod
operator|.
name|SIMPLE
expr_stmt|;
comment|// client has already sent the initial Sasl message and we
comment|// should ignore it. Both client and server should fall back
comment|// to simple auth from now on.
name|skipInitialSaslHandshake
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|authMethod
operator|!=
name|AuthMethod
operator|.
name|SIMPLE
condition|)
block|{
name|useSasl
operator|=
literal|true
expr_stmt|;
block|}
name|rpcHeaderBuffer
operator|=
literal|null
expr_stmt|;
name|rpcHeaderRead
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
name|dataLengthBuffer
operator|.
name|flip
argument_list|()
expr_stmt|;
name|dataLength
operator|=
name|dataLengthBuffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|dataLength
operator|==
name|HBaseClient
operator|.
name|PING_CALL_ID
condition|)
block|{
if|if
condition|(
operator|!
name|useWrap
condition|)
block|{
comment|//covers the !useSasl too
name|dataLengthBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
comment|//ping message
block|}
block|}
if|if
condition|(
name|dataLength
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected data length "
operator|+
name|dataLength
operator|+
literal|"!! from "
operator|+
name|getHostAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|data
operator|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|dataLength
argument_list|)
expr_stmt|;
name|incRpcCount
argument_list|()
expr_stmt|;
comment|// Increment the rpc count
block|}
name|count
operator|=
name|channelRead
argument_list|(
name|channel
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|remaining
argument_list|()
operator|==
literal|0
condition|)
block|{
name|dataLengthBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|data
operator|.
name|flip
argument_list|()
expr_stmt|;
if|if
condition|(
name|skipInitialSaslHandshake
condition|)
block|{
name|data
operator|=
literal|null
expr_stmt|;
name|skipInitialSaslHandshake
operator|=
literal|false
expr_stmt|;
continue|continue;
block|}
name|boolean
name|isHeaderRead
init|=
name|headerRead
decl_stmt|;
if|if
condition|(
name|useSasl
condition|)
block|{
name|saslReadAndProcess
argument_list|(
name|data
operator|.
name|array
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|processOneRpc
argument_list|(
name|data
operator|.
name|array
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|data
operator|=
literal|null
expr_stmt|;
if|if
condition|(
operator|!
name|isHeaderRead
condition|)
block|{
continue|continue;
block|}
block|}
return|return
name|count
return|;
block|}
block|}
comment|/// Reads the connection header following version
specifier|private
name|void
name|processHeader
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|DataInputStream
name|in
init|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|buf
argument_list|)
argument_list|)
decl_stmt|;
name|header
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
try|try
block|{
name|String
name|protocolClassName
init|=
name|header
operator|.
name|getProtocol
argument_list|()
decl_stmt|;
if|if
condition|(
name|protocolClassName
operator|!=
literal|null
condition|)
block|{
name|protocol
operator|=
name|getProtocolClass
argument_list|(
name|header
operator|.
name|getProtocol
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|cnfe
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown protocol: "
operator|+
name|header
operator|.
name|getProtocol
argument_list|()
argument_list|)
throw|;
block|}
name|User
name|protocolUser
init|=
name|header
operator|.
name|getUser
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|useSasl
condition|)
block|{
name|user
operator|=
name|protocolUser
expr_stmt|;
if|if
condition|(
name|user
operator|!=
literal|null
condition|)
block|{
name|user
operator|.
name|getUGI
argument_list|()
operator|.
name|setAuthenticationMethod
argument_list|(
name|AuthMethod
operator|.
name|SIMPLE
operator|.
name|authenticationMethod
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// user is authenticated
name|user
operator|.
name|getUGI
argument_list|()
operator|.
name|setAuthenticationMethod
argument_list|(
name|authMethod
operator|.
name|authenticationMethod
argument_list|)
expr_stmt|;
comment|//Now we check if this is a proxy user case. If the protocol user is
comment|//different from the 'user', it is a proxy user scenario. However,
comment|//this is not allowed if user authenticated with DIGEST.
if|if
condition|(
operator|(
name|protocolUser
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|!
name|protocolUser
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|user
operator|.
name|getName
argument_list|()
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|authMethod
operator|==
name|AuthMethod
operator|.
name|DIGEST
condition|)
block|{
comment|// Not allowed to doAs if token authentication is used
throw|throw
operator|new
name|AccessControlException
argument_list|(
literal|"Authenticated user ("
operator|+
name|user
operator|+
literal|") doesn't match what the client claims to be ("
operator|+
name|protocolUser
operator|+
literal|")"
argument_list|)
throw|;
block|}
else|else
block|{
comment|// Effective user can be different from authenticated user
comment|// for simple auth or kerberos auth
comment|// The user is the real user. Now we create a proxy user
name|UserGroupInformation
name|realUser
init|=
name|user
operator|.
name|getUGI
argument_list|()
decl_stmt|;
name|user
operator|=
name|User
operator|.
name|create
argument_list|(
name|UserGroupInformation
operator|.
name|createProxyUser
argument_list|(
name|protocolUser
operator|.
name|getName
argument_list|()
argument_list|,
name|realUser
argument_list|)
argument_list|)
expr_stmt|;
comment|// Now the user is a proxy user, set Authentication method Proxy.
name|user
operator|.
name|getUGI
argument_list|()
operator|.
name|setAuthenticationMethod
argument_list|(
name|AuthenticationMethod
operator|.
name|PROXY
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
name|void
name|processUnwrappedData
parameter_list|(
name|byte
index|[]
name|inBuf
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|ReadableByteChannel
name|ch
init|=
name|Channels
operator|.
name|newChannel
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|inBuf
argument_list|)
argument_list|)
decl_stmt|;
comment|// Read all RPCs contained in the inBuf, even partial ones
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|count
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|unwrappedDataLengthBuffer
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
block|{
name|count
operator|=
name|channelRead
argument_list|(
name|ch
argument_list|,
name|unwrappedDataLengthBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
operator|||
name|unwrappedDataLengthBuffer
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
return|return;
block|}
if|if
condition|(
name|unwrappedData
operator|==
literal|null
condition|)
block|{
name|unwrappedDataLengthBuffer
operator|.
name|flip
argument_list|()
expr_stmt|;
name|int
name|unwrappedDataLength
init|=
name|unwrappedDataLengthBuffer
operator|.
name|getInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|unwrappedDataLength
operator|==
name|HBaseClient
operator|.
name|PING_CALL_ID
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"Received ping message"
argument_list|)
expr_stmt|;
name|unwrappedDataLengthBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
continue|continue;
comment|// ping message
block|}
name|unwrappedData
operator|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|unwrappedDataLength
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
name|channelRead
argument_list|(
name|ch
argument_list|,
name|unwrappedData
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
operator|||
name|unwrappedData
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
return|return;
if|if
condition|(
name|unwrappedData
operator|.
name|remaining
argument_list|()
operator|==
literal|0
condition|)
block|{
name|unwrappedDataLengthBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|unwrappedData
operator|.
name|flip
argument_list|()
expr_stmt|;
name|processOneRpc
argument_list|(
name|unwrappedData
operator|.
name|array
argument_list|()
argument_list|)
expr_stmt|;
name|unwrappedData
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|processOneRpc
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|headerRead
condition|)
block|{
name|processData
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|processHeader
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|headerRead
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|authorizeConnection
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AccessControlException
argument_list|(
literal|"Connection from "
operator|+
name|this
operator|+
literal|" for protocol "
operator|+
name|header
operator|.
name|getProtocol
argument_list|()
operator|+
literal|" is unauthorized for user "
operator|+
name|user
argument_list|)
throw|;
block|}
block|}
block|}
specifier|protected
name|void
name|processData
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|DataInputStream
name|dis
init|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|buf
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|id
init|=
name|dis
operator|.
name|readInt
argument_list|()
decl_stmt|;
comment|// try to read an id
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|" got #"
operator|+
name|id
argument_list|)
expr_stmt|;
block|}
name|Writable
name|param
init|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|paramClass
argument_list|,
name|conf
argument_list|)
decl_stmt|;
comment|// read param
name|param
operator|.
name|readFields
argument_list|(
name|dis
argument_list|)
expr_stmt|;
name|SecureCall
name|call
init|=
operator|new
name|SecureCall
argument_list|(
name|id
argument_list|,
name|param
argument_list|,
name|this
argument_list|,
name|responder
argument_list|,
name|buf
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|priorityCallQueue
operator|!=
literal|null
operator|&&
name|getQosLevel
argument_list|(
name|param
argument_list|)
operator|>
name|highPriorityLevel
condition|)
block|{
name|priorityCallQueue
operator|.
name|put
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|callQueue
operator|.
name|put
argument_list|(
name|call
argument_list|)
expr_stmt|;
comment|// queue the call; maybe blocked here
block|}
block|}
specifier|private
name|boolean
name|authorizeConnection
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
comment|// If auth method is DIGEST, the token was obtained by the
comment|// real user for the effective user, therefore not required to
comment|// authorize real user. doAs is allowed only for simple or kerberos
comment|// authentication
if|if
condition|(
name|user
operator|!=
literal|null
operator|&&
name|user
operator|.
name|getUGI
argument_list|()
operator|.
name|getRealUser
argument_list|()
operator|!=
literal|null
operator|&&
operator|(
name|authMethod
operator|!=
name|AuthMethod
operator|.
name|DIGEST
operator|)
condition|)
block|{
name|ProxyUsers
operator|.
name|authorize
argument_list|(
name|user
operator|.
name|getUGI
argument_list|()
argument_list|,
name|this
operator|.
name|getHostAddress
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
name|authorize
argument_list|(
name|user
argument_list|,
name|header
argument_list|,
name|getHostInetAddress
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Successfully authorized "
operator|+
name|header
argument_list|)
expr_stmt|;
block|}
name|rpcMetrics
operator|.
name|authorizationSuccesses
operator|.
name|inc
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AuthorizationException
name|ae
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Connection authorization failed: "
operator|+
name|ae
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ae
argument_list|)
expr_stmt|;
name|rpcMetrics
operator|.
name|authorizationFailures
operator|.
name|inc
argument_list|()
expr_stmt|;
name|SecureCall
name|failedCall
init|=
operator|new
name|SecureCall
argument_list|(
name|AUTHORIZATION_FAILED_CALLID
argument_list|,
literal|null
argument_list|,
name|this
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|failedCall
operator|.
name|setResponse
argument_list|(
literal|null
argument_list|,
name|Status
operator|.
name|FATAL
argument_list|,
name|ae
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|ae
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|responder
operator|.
name|doRespond
argument_list|(
name|failedCall
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|protected
specifier|synchronized
name|void
name|close
parameter_list|()
block|{
name|disposeSasl
argument_list|()
expr_stmt|;
name|data
operator|=
literal|null
expr_stmt|;
name|dataLengthBuffer
operator|=
literal|null
expr_stmt|;
if|if
condition|(
operator|!
name|channel
operator|.
name|isOpen
argument_list|()
condition|)
return|return;
try|try
block|{
name|socket
operator|.
name|shutdownOutput
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ignored
parameter_list|)
block|{}
comment|// FindBugs DE_MIGHT_IGNORE
if|if
condition|(
name|channel
operator|.
name|isOpen
argument_list|()
condition|)
block|{
try|try
block|{
name|channel
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ignored
parameter_list|)
block|{}
block|}
try|try
block|{
name|socket
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ignored
parameter_list|)
block|{}
block|}
block|}
comment|/** Constructs a server listening on the named port and address.  Parameters passed must    * be of the named class.  The<code>handlerCount</handlerCount> determines    * the number of handler threads that will be used to process calls.    *    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|protected
name|SecureServer
parameter_list|(
name|String
name|bindAddress
parameter_list|,
name|int
name|port
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Writable
argument_list|>
name|paramClass
parameter_list|,
name|int
name|handlerCount
parameter_list|,
name|int
name|priorityHandlerCount
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|String
name|serverName
parameter_list|,
name|int
name|highPriorityLevel
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|bindAddress
argument_list|,
name|port
argument_list|,
name|paramClass
argument_list|,
name|handlerCount
argument_list|,
name|priorityHandlerCount
argument_list|,
name|conf
argument_list|,
name|serverName
argument_list|,
name|highPriorityLevel
argument_list|)
expr_stmt|;
name|this
operator|.
name|authorize
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|HADOOP_SECURITY_AUTHORIZATION
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|isSecurityEnabled
operator|=
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"security enabled="
operator|+
name|isSecurityEnabled
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSecurityEnabled
condition|)
block|{
name|HBaseSaslRpcServer
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|Connection
name|getConnection
parameter_list|(
name|SocketChannel
name|channel
parameter_list|,
name|long
name|time
parameter_list|)
block|{
return|return
operator|new
name|SecureConnection
argument_list|(
name|channel
argument_list|,
name|time
argument_list|)
return|;
block|}
name|Configuration
name|getConf
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
comment|/** for unit testing only, should be called before server is started */
name|void
name|disableSecurity
parameter_list|()
block|{
name|this
operator|.
name|isSecurityEnabled
operator|=
literal|false
expr_stmt|;
block|}
comment|/** for unit testing only, should be called before server is started */
name|void
name|enableSecurity
parameter_list|()
block|{
name|this
operator|.
name|isSecurityEnabled
operator|=
literal|true
expr_stmt|;
block|}
comment|/** Stops the service.  No new calls will be handled after this is called. */
specifier|public
specifier|synchronized
name|void
name|stop
parameter_list|()
block|{
name|super
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
specifier|public
name|SecretManager
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|getSecretManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|secretManager
return|;
block|}
specifier|public
name|void
name|setSecretManager
parameter_list|(
name|SecretManager
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|secretManager
parameter_list|)
block|{
name|this
operator|.
name|secretManager
operator|=
operator|(
name|SecretManager
argument_list|<
name|TokenIdentifier
argument_list|>
operator|)
name|secretManager
expr_stmt|;
block|}
comment|/**    * Authorize the incoming client connection.    *    * @param user client user    * @param connection incoming connection    * @param addr InetAddress of incoming connection    * @throws org.apache.hadoop.security.authorize.AuthorizationException when the client isn't authorized to talk the protocol    */
specifier|public
name|void
name|authorize
parameter_list|(
name|User
name|user
parameter_list|,
name|ConnectionHeader
name|connection
parameter_list|,
name|InetAddress
name|addr
parameter_list|)
throws|throws
name|AuthorizationException
block|{
if|if
condition|(
name|authorize
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|protocol
init|=
literal|null
decl_stmt|;
try|try
block|{
name|protocol
operator|=
name|getProtocolClass
argument_list|(
name|connection
operator|.
name|getProtocol
argument_list|()
argument_list|,
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|cfne
parameter_list|)
block|{
throw|throw
operator|new
name|AuthorizationException
argument_list|(
literal|"Unknown protocol: "
operator|+
name|connection
operator|.
name|getProtocol
argument_list|()
argument_list|)
throw|;
block|}
name|authManager
operator|.
name|authorize
argument_list|(
name|user
operator|!=
literal|null
condition|?
name|user
operator|.
name|getUGI
argument_list|()
else|:
literal|null
argument_list|,
name|protocol
argument_list|,
name|getConf
argument_list|()
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

