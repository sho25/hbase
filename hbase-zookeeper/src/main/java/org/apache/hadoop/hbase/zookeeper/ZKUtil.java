begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Socket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|AppConfigurationEntry
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|AppConfigurationEntry
operator|.
name|LoginModuleControlFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|AuthUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|DeserializationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|Superusers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKUtil
operator|.
name|ZKUtilOp
operator|.
name|CreateAndFailSilent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKUtil
operator|.
name|ZKUtilOp
operator|.
name|DeleteNodeFailSilent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKUtil
operator|.
name|ZKUtilOp
operator|.
name|SetData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|SecurityUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authentication
operator|.
name|util
operator|.
name|KerberosUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|AsyncCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|CreateMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
operator|.
name|NoNodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|Op
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|Watcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|ZooDefs
operator|.
name|Ids
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|ZooDefs
operator|.
name|Perms
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|ZooKeeper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|client
operator|.
name|ZooKeeperSaslClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|ACL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|Id
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|Stat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|proto
operator|.
name|CreateRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|proto
operator|.
name|DeleteRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|proto
operator|.
name|SetDataRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|server
operator|.
name|ZooKeeperSaslServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|InvalidProtocolBufferException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ReplicationProtos
import|;
end_import

begin_comment
comment|/**  * Internal HBase utility class for ZooKeeper.  *  *<p>Contains only static methods and constants.  *  *<p>Methods all throw {@link KeeperException} if there is an unexpected  * zookeeper exception, so callers of these methods must handle appropriately.  * If ZK is required for the operation, the server will need to be aborted.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|final
class|class
name|ZKUtil
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ZKUtil
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|int
name|zkDumpConnectionTimeOut
decl_stmt|;
specifier|private
name|ZKUtil
parameter_list|()
block|{   }
comment|/**    * Creates a new connection to ZooKeeper, pulling settings and ensemble config    * from the specified configuration object using methods from {@link ZKConfig}.    *    * Sets the connection status monitoring watcher to the specified watcher.    *    * @param conf configuration to pull ensemble and other settings from    * @param watcher watcher to monitor connection changes    * @return connection to zookeeper    * @throws IOException if unable to connect to zk or config problem    */
specifier|public
specifier|static
name|RecoverableZooKeeper
name|connect
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Watcher
name|watcher
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|ensemble
init|=
name|ZKConfig
operator|.
name|getZKQuorumServersString
argument_list|(
name|conf
argument_list|)
decl_stmt|;
return|return
name|connect
argument_list|(
name|conf
argument_list|,
name|ensemble
argument_list|,
name|watcher
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|RecoverableZooKeeper
name|connect
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|ensemble
parameter_list|,
name|Watcher
name|watcher
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|connect
argument_list|(
name|conf
argument_list|,
name|ensemble
argument_list|,
name|watcher
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|RecoverableZooKeeper
name|connect
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|ensemble
parameter_list|,
name|Watcher
name|watcher
parameter_list|,
specifier|final
name|String
name|identifier
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|ensemble
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to determine ZooKeeper ensemble"
argument_list|)
throw|;
block|}
name|int
name|timeout
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|ZK_SESSION_TIMEOUT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_ZK_SESSION_TIMEOUT
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|identifier
operator|+
literal|" opening connection to ZooKeeper ensemble="
operator|+
name|ensemble
argument_list|)
expr_stmt|;
block|}
name|int
name|retry
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"zookeeper.recovery.retry"
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|int
name|retryIntervalMillis
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"zookeeper.recovery.retry.intervalmill"
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
name|int
name|maxSleepTime
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"zookeeper.recovery.retry.maxsleeptime"
argument_list|,
literal|60000
argument_list|)
decl_stmt|;
name|zkDumpConnectionTimeOut
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"zookeeper.dump.connection.timeout"
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
return|return
operator|new
name|RecoverableZooKeeper
argument_list|(
name|ensemble
argument_list|,
name|timeout
argument_list|,
name|watcher
argument_list|,
name|retry
argument_list|,
name|retryIntervalMillis
argument_list|,
name|maxSleepTime
argument_list|,
name|identifier
argument_list|)
return|;
block|}
comment|/**    * Log in the current zookeeper server process using the given configuration    * keys for the credential file and login principal.    *    *<p><strong>This is only applicable when running on secure hbase</strong>    * On regular HBase (without security features), this will safely be ignored.    *</p>    *    * @param conf The configuration data to use    * @param keytabFileKey Property key used to configure the path to the credential file    * @param userNameKey Property key used to configure the login principal    * @param hostname Current hostname to use in any credentials    * @throws IOException underlying exception from SecurityUtil.login() call    */
specifier|public
specifier|static
name|void
name|loginServer
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|keytabFileKey
parameter_list|,
name|String
name|userNameKey
parameter_list|,
name|String
name|hostname
parameter_list|)
throws|throws
name|IOException
block|{
name|login
argument_list|(
name|conf
argument_list|,
name|keytabFileKey
argument_list|,
name|userNameKey
argument_list|,
name|hostname
argument_list|,
name|ZooKeeperSaslServer
operator|.
name|LOGIN_CONTEXT_NAME_KEY
argument_list|,
name|JaasConfiguration
operator|.
name|SERVER_KEYTAB_KERBEROS_CONFIG_NAME
argument_list|)
expr_stmt|;
block|}
comment|/**    * Log in the current zookeeper client using the given configuration    * keys for the credential file and login principal.    *    *<p><strong>This is only applicable when running on secure hbase</strong>    * On regular HBase (without security features), this will safely be ignored.    *</p>    *    * @param conf The configuration data to use    * @param keytabFileKey Property key used to configure the path to the credential file    * @param userNameKey Property key used to configure the login principal    * @param hostname Current hostname to use in any credentials    * @throws IOException underlying exception from SecurityUtil.login() call    */
specifier|public
specifier|static
name|void
name|loginClient
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|keytabFileKey
parameter_list|,
name|String
name|userNameKey
parameter_list|,
name|String
name|hostname
parameter_list|)
throws|throws
name|IOException
block|{
name|login
argument_list|(
name|conf
argument_list|,
name|keytabFileKey
argument_list|,
name|userNameKey
argument_list|,
name|hostname
argument_list|,
name|ZooKeeperSaslClient
operator|.
name|LOGIN_CONTEXT_NAME_KEY
argument_list|,
name|JaasConfiguration
operator|.
name|CLIENT_KEYTAB_KERBEROS_CONFIG_NAME
argument_list|)
expr_stmt|;
block|}
comment|/**    * Log in the current process using the given configuration keys for the    * credential file and login principal.    *    *<p><strong>This is only applicable when running on secure hbase</strong>    * On regular HBase (without security features), this will safely be ignored.    *</p>    *    * @param conf The configuration data to use    * @param keytabFileKey Property key used to configure the path to the credential file    * @param userNameKey Property key used to configure the login principal    * @param hostname Current hostname to use in any credentials    * @param loginContextProperty property name to expose the entry name    * @param loginContextName jaas entry name    * @throws IOException underlying exception from SecurityUtil.login() call    */
specifier|private
specifier|static
name|void
name|login
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|keytabFileKey
parameter_list|,
name|String
name|userNameKey
parameter_list|,
name|String
name|hostname
parameter_list|,
name|String
name|loginContextProperty
parameter_list|,
name|String
name|loginContextName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isSecureZooKeeper
argument_list|(
name|conf
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// User has specified a jaas.conf, keep this one as the good one.
comment|// HBASE_OPTS="-Djava.security.auth.login.config=jaas.conf"
if|if
condition|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.security.auth.login.config"
argument_list|)
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
comment|// No keytab specified, no auth
name|String
name|keytabFilename
init|=
name|conf
operator|.
name|get
argument_list|(
name|keytabFileKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|keytabFilename
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"no keytab specified for: "
operator|+
name|keytabFileKey
argument_list|)
expr_stmt|;
return|return;
block|}
name|String
name|principalConfig
init|=
name|conf
operator|.
name|get
argument_list|(
name|userNameKey
argument_list|,
name|System
operator|.
name|getProperty
argument_list|(
literal|"user.name"
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|principalName
init|=
name|SecurityUtil
operator|.
name|getServerPrincipal
argument_list|(
name|principalConfig
argument_list|,
name|hostname
argument_list|)
decl_stmt|;
comment|// Initialize the "jaas.conf" for keyTab/principal,
comment|// If keyTab is not specified use the Ticket Cache.
comment|// and set the zookeeper login context name.
name|JaasConfiguration
name|jaasConf
init|=
operator|new
name|JaasConfiguration
argument_list|(
name|loginContextName
argument_list|,
name|principalName
argument_list|,
name|keytabFilename
argument_list|)
decl_stmt|;
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|Configuration
operator|.
name|setConfiguration
argument_list|(
name|jaasConf
argument_list|)
expr_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
name|loginContextProperty
argument_list|,
name|loginContextName
argument_list|)
expr_stmt|;
block|}
comment|/**    * A JAAS configuration that defines the login modules that we want to use for login.    */
specifier|private
specifier|static
class|class
name|JaasConfiguration
extends|extends
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|Configuration
block|{
specifier|private
specifier|static
specifier|final
name|String
name|SERVER_KEYTAB_KERBEROS_CONFIG_NAME
init|=
literal|"zookeeper-server-keytab-kerberos"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|CLIENT_KEYTAB_KERBEROS_CONFIG_NAME
init|=
literal|"zookeeper-client-keytab-kerberos"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|BASIC_JAAS_OPTIONS
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
static|static
block|{
name|String
name|jaasEnvVar
init|=
name|System
operator|.
name|getenv
argument_list|(
literal|"HBASE_JAAS_DEBUG"
argument_list|)
decl_stmt|;
if|if
condition|(
name|jaasEnvVar
operator|!=
literal|null
operator|&&
literal|"true"
operator|.
name|equalsIgnoreCase
argument_list|(
name|jaasEnvVar
argument_list|)
condition|)
block|{
name|BASIC_JAAS_OPTIONS
operator|.
name|put
argument_list|(
literal|"debug"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|KEYTAB_KERBEROS_OPTIONS
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
static|static
block|{
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"doNotPrompt"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"storeKey"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"refreshKrb5Config"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|putAll
argument_list|(
name|BASIC_JAAS_OPTIONS
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
specifier|final
name|AppConfigurationEntry
name|KEYTAB_KERBEROS_LOGIN
init|=
operator|new
name|AppConfigurationEntry
argument_list|(
name|KerberosUtil
operator|.
name|getKrb5LoginModuleName
argument_list|()
argument_list|,
name|LoginModuleControlFlag
operator|.
name|REQUIRED
argument_list|,
name|KEYTAB_KERBEROS_OPTIONS
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|AppConfigurationEntry
index|[]
name|KEYTAB_KERBEROS_CONF
init|=
operator|new
name|AppConfigurationEntry
index|[]
block|{
name|KEYTAB_KERBEROS_LOGIN
block|}
decl_stmt|;
specifier|private
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|Configuration
name|baseConfig
decl_stmt|;
specifier|private
specifier|final
name|String
name|loginContextName
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|useTicketCache
decl_stmt|;
specifier|private
specifier|final
name|String
name|keytabFile
decl_stmt|;
specifier|private
specifier|final
name|String
name|principal
decl_stmt|;
specifier|public
name|JaasConfiguration
parameter_list|(
name|String
name|loginContextName
parameter_list|,
name|String
name|principal
parameter_list|,
name|String
name|keytabFile
parameter_list|)
block|{
name|this
argument_list|(
name|loginContextName
argument_list|,
name|principal
argument_list|,
name|keytabFile
argument_list|,
name|keytabFile
operator|==
literal|null
operator|||
name|keytabFile
operator|.
name|length
argument_list|()
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|private
name|JaasConfiguration
parameter_list|(
name|String
name|loginContextName
parameter_list|,
name|String
name|principal
parameter_list|,
name|String
name|keytabFile
parameter_list|,
name|boolean
name|useTicketCache
parameter_list|)
block|{
try|try
block|{
name|this
operator|.
name|baseConfig
operator|=
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|Configuration
operator|.
name|getConfiguration
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|e
parameter_list|)
block|{
name|this
operator|.
name|baseConfig
operator|=
literal|null
expr_stmt|;
block|}
name|this
operator|.
name|loginContextName
operator|=
name|loginContextName
expr_stmt|;
name|this
operator|.
name|useTicketCache
operator|=
name|useTicketCache
expr_stmt|;
name|this
operator|.
name|keytabFile
operator|=
name|keytabFile
expr_stmt|;
name|this
operator|.
name|principal
operator|=
name|principal
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"JaasConfiguration loginContextName="
operator|+
name|loginContextName
operator|+
literal|" principal="
operator|+
name|principal
operator|+
literal|" useTicketCache="
operator|+
name|useTicketCache
operator|+
literal|" keytabFile="
operator|+
name|keytabFile
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|AppConfigurationEntry
index|[]
name|getAppConfigurationEntry
parameter_list|(
name|String
name|appName
parameter_list|)
block|{
if|if
condition|(
name|loginContextName
operator|.
name|equals
argument_list|(
name|appName
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|useTicketCache
condition|)
block|{
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"keyTab"
argument_list|,
name|keytabFile
argument_list|)
expr_stmt|;
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"useKeyTab"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"principal"
argument_list|,
name|principal
argument_list|)
expr_stmt|;
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"useTicketCache"
argument_list|,
name|useTicketCache
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
return|return
name|KEYTAB_KERBEROS_CONF
return|;
block|}
if|if
condition|(
name|baseConfig
operator|!=
literal|null
condition|)
block|{
return|return
name|baseConfig
operator|.
name|getAppConfigurationEntry
argument_list|(
name|appName
argument_list|)
return|;
block|}
return|return
operator|(
literal|null
operator|)
return|;
block|}
block|}
comment|//
comment|// Helper methods
comment|//
comment|/**    * Returns the full path of the immediate parent of the specified node.    * @param node path to get parent of    * @return parent of path, null if passed the root node or an invalid node    */
specifier|public
specifier|static
name|String
name|getParent
parameter_list|(
name|String
name|node
parameter_list|)
block|{
name|int
name|idx
init|=
name|node
operator|.
name|lastIndexOf
argument_list|(
name|ZNodePaths
operator|.
name|ZNODE_PATH_SEPARATOR
argument_list|)
decl_stmt|;
return|return
name|idx
operator|<=
literal|0
condition|?
literal|null
else|:
name|node
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|idx
argument_list|)
return|;
block|}
comment|/**    * Get the name of the current node from the specified fully-qualified path.    * @param path fully-qualified path    * @return name of the current node    */
specifier|public
specifier|static
name|String
name|getNodeName
parameter_list|(
name|String
name|path
parameter_list|)
block|{
return|return
name|path
operator|.
name|substring
argument_list|(
name|path
operator|.
name|lastIndexOf
argument_list|(
literal|"/"
argument_list|)
operator|+
literal|1
argument_list|)
return|;
block|}
comment|//
comment|// Existence checks and watches
comment|//
comment|/**    * Watch the specified znode for delete/create/change events.  The watcher is    * set whether or not the node exists.  If the node already exists, the method    * returns true.  If the node does not exist, the method returns false.    *    * @param zkw zk reference    * @param znode path of node to watch    * @return true if znode exists, false if does not exist or error    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|boolean
name|watchAndCheckExists
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|znode
parameter_list|)
throws|throws
name|KeeperException
block|{
try|try
block|{
name|Stat
name|s
init|=
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|exists
argument_list|(
name|znode
argument_list|,
name|zkw
argument_list|)
decl_stmt|;
name|boolean
name|exists
init|=
name|s
operator|!=
literal|null
condition|?
literal|true
else|:
literal|false
decl_stmt|;
if|if
condition|(
name|exists
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Set watcher on existing znode="
operator|+
name|znode
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Set watcher on znode that does not yet exist, "
operator|+
name|znode
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|exists
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Unable to set watcher on znode "
operator|+
name|znode
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|zkw
operator|.
name|keeperException
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Unable to set watcher on znode "
operator|+
name|znode
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|zkw
operator|.
name|interruptedException
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Watch the specified znode, but only if exists. Useful when watching    * for deletions. Uses .getData() (and handles NoNodeException) instead    * of .exists() to accomplish this, as .getData() will only set a watch if    * the znode exists.    * @param zkw zk reference    * @param znode path of node to watch    * @return true if the watch is set, false if node does not exists    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|boolean
name|setWatchIfNodeExists
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|znode
parameter_list|)
throws|throws
name|KeeperException
block|{
try|try
block|{
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|getData
argument_list|(
name|znode
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|NoNodeException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Unable to set watcher on znode "
operator|+
name|znode
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|zkw
operator|.
name|interruptedException
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Check if the specified node exists.  Sets no watches.    *    * @param zkw zk reference    * @param znode path of node to watch    * @return version of the node if it exists, -1 if does not exist    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|int
name|checkExists
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|znode
parameter_list|)
throws|throws
name|KeeperException
block|{
try|try
block|{
name|Stat
name|s
init|=
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|exists
argument_list|(
name|znode
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|s
operator|!=
literal|null
condition|?
name|s
operator|.
name|getVersion
argument_list|()
else|:
operator|-
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Unable to set watcher on znode ("
operator|+
name|znode
operator|+
literal|")"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|zkw
operator|.
name|keeperException
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Unable to set watcher on znode ("
operator|+
name|znode
operator|+
literal|")"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|zkw
operator|.
name|interruptedException
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|//
comment|// Znode listings
comment|//
comment|/**    * Lists the children znodes of the specified znode.  Also sets a watch on    * the specified znode which will capture a NodeDeleted event on the specified    * znode as well as NodeChildrenChanged if any children of the specified znode    * are created or deleted.    *    * Returns null if the specified node does not exist.  Otherwise returns a    * list of children of the specified node.  If the node exists but it has no    * children, an empty list will be returned.    *    * @param zkw zk reference    * @param znode path of node to list and watch children of    * @return list of children of the specified node, an empty list if the node    *          exists but has no children, and null if the node does not exist    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|listChildrenAndWatchForNewChildren
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|znode
parameter_list|)
throws|throws
name|KeeperException
block|{
try|try
block|{
name|List
argument_list|<
name|String
argument_list|>
name|children
init|=
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|getChildren
argument_list|(
name|znode
argument_list|,
name|zkw
argument_list|)
decl_stmt|;
return|return
name|children
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|ke
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Unable to list children of znode "
operator|+
name|znode
operator|+
literal|" "
operator|+
literal|"because node does not exist (not an error)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Unable to list children of znode "
operator|+
name|znode
operator|+
literal|" "
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|zkw
operator|.
name|keeperException
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Unable to list children of znode "
operator|+
name|znode
operator|+
literal|" "
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|zkw
operator|.
name|interruptedException
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * List all the children of the specified znode, setting a watch for children    * changes and also setting a watch on every individual child in order to get    * the NodeCreated and NodeDeleted events.    * @param zkw zookeeper reference    * @param znode node to get children of and watch    * @return list of znode names, null if the node doesn't exist    * @throws KeeperException if a ZooKeeper operation fails    */
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|listChildrenAndWatchThem
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|znode
parameter_list|)
throws|throws
name|KeeperException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|children
init|=
name|listChildrenAndWatchForNewChildren
argument_list|(
name|zkw
argument_list|,
name|znode
argument_list|)
decl_stmt|;
if|if
condition|(
name|children
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
for|for
control|(
name|String
name|child
range|:
name|children
control|)
block|{
name|watchAndCheckExists
argument_list|(
name|zkw
argument_list|,
name|ZNodePaths
operator|.
name|joinZNode
argument_list|(
name|znode
argument_list|,
name|child
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|children
return|;
block|}
comment|/**    * Lists the children of the specified znode without setting any watches.    *    * Sets no watches at all, this method is best effort.    *    * Returns an empty list if the node has no children.  Returns null if the    * parent node itself does not exist.    *    * @param zkw zookeeper reference    * @param znode node to get children    * @return list of data of children of specified znode, empty if no children,    *         null if parent does not exist    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|listChildrenNoWatch
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|znode
parameter_list|)
throws|throws
name|KeeperException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|children
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// List the children without watching
name|children
operator|=
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|getChildren
argument_list|(
name|znode
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|nne
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|zkw
operator|.
name|interruptedException
argument_list|(
name|ie
argument_list|)
expr_stmt|;
block|}
return|return
name|children
return|;
block|}
comment|/**    * Simple class to hold a node path and node data.    * @deprecated Unused    */
annotation|@
name|Deprecated
specifier|public
specifier|static
class|class
name|NodeAndData
block|{
specifier|private
name|String
name|node
decl_stmt|;
specifier|private
name|byte
index|[]
name|data
decl_stmt|;
specifier|public
name|NodeAndData
parameter_list|(
name|String
name|node
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
block|{
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|this
operator|.
name|data
operator|=
name|data
expr_stmt|;
block|}
specifier|public
name|String
name|getNode
parameter_list|()
block|{
return|return
name|node
return|;
block|}
specifier|public
name|byte
index|[]
name|getData
parameter_list|()
block|{
return|return
name|data
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|node
return|;
block|}
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
operator|(
name|data
operator|==
literal|null
operator|||
name|data
operator|.
name|length
operator|==
literal|0
operator|)
return|;
block|}
block|}
comment|/**    * Checks if the specified znode has any children.  Sets no watches.    *    * Returns true if the node exists and has children.  Returns false if the    * node does not exist or if the node does not have any children.    *    * Used during master initialization to determine if the master is a    * failed-over-to master or the first master during initial cluster startup.    * If the directory for regionserver ephemeral nodes is empty then this is    * a cluster startup, if not then it is not cluster startup.    *    * @param zkw zk reference    * @param znode path of node to check for children of    * @return true if node has children, false if not or node does not exist    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|boolean
name|nodeHasChildren
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|znode
parameter_list|)
throws|throws
name|KeeperException
block|{
try|try
block|{
return|return
operator|!
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|getChildren
argument_list|(
name|znode
argument_list|,
literal|null
argument_list|)
operator|.
name|isEmpty
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|ke
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Unable to list children of znode "
operator|+
name|znode
operator|+
literal|" because node does not exist (not an error)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Unable to list children of znode "
operator|+
name|znode
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|zkw
operator|.
name|keeperException
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Unable to list children of znode "
operator|+
name|znode
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|zkw
operator|.
name|interruptedException
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Get the number of children of the specified node.    *    * If the node does not exist or has no children, returns 0.    *    * Sets no watches at all.    *    * @param zkw zk reference    * @param znode path of node to count children of    * @return number of children of specified node, 0 if none or parent does not    *         exist    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|int
name|getNumberOfChildren
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|znode
parameter_list|)
throws|throws
name|KeeperException
block|{
try|try
block|{
name|Stat
name|stat
init|=
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|exists
argument_list|(
name|znode
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|stat
operator|==
literal|null
condition|?
literal|0
else|:
name|stat
operator|.
name|getNumChildren
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Unable to get children of node "
operator|+
name|znode
argument_list|)
argument_list|)
expr_stmt|;
name|zkw
operator|.
name|keeperException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|zkw
operator|.
name|interruptedException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|//
comment|// Data retrieval
comment|//
comment|/**    * Get znode data. Does not set a watcher.    *    * @return ZNode data, null if the node does not exist or if there is an error.    */
specifier|public
specifier|static
name|byte
index|[]
name|getData
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|znode
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
try|try
block|{
name|byte
index|[]
name|data
init|=
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|getData
argument_list|(
name|znode
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|logRetrievedMsg
argument_list|(
name|zkw
argument_list|,
name|znode
argument_list|,
name|data
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Unable to get data of znode "
operator|+
name|znode
operator|+
literal|" "
operator|+
literal|"because node does not exist (not an error)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Unable to get data of znode "
operator|+
name|znode
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|zkw
operator|.
name|keeperException
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Get the data at the specified znode and set a watch.    *    * Returns the data and sets a watch if the node exists.  Returns null and no    * watch is set if the node does not exist or there is an exception.    *    * @param zkw zk reference    * @param znode path of node    * @return data of the specified znode, or null    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|byte
index|[]
name|getDataAndWatch
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|znode
parameter_list|)
throws|throws
name|KeeperException
block|{
return|return
name|getDataInternal
argument_list|(
name|zkw
argument_list|,
name|znode
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Get the data at the specified znode and set a watch.    *    * Returns the data and sets a watch if the node exists.  Returns null and no    * watch is set if the node does not exist or there is an exception.    *    * @param zkw zk reference    * @param znode path of node    * @param stat object to populate the version of the znode    * @return data of the specified znode, or null    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|byte
index|[]
name|getDataAndWatch
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|znode
parameter_list|,
name|Stat
name|stat
parameter_list|)
throws|throws
name|KeeperException
block|{
return|return
name|getDataInternal
argument_list|(
name|zkw
argument_list|,
name|znode
argument_list|,
name|stat
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|byte
index|[]
name|getDataInternal
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|znode
parameter_list|,
name|Stat
name|stat
parameter_list|,
name|boolean
name|watcherSet
parameter_list|)
throws|throws
name|KeeperException
block|{
try|try
block|{
name|byte
index|[]
name|data
init|=
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|getData
argument_list|(
name|znode
argument_list|,
name|zkw
argument_list|,
name|stat
argument_list|)
decl_stmt|;
name|logRetrievedMsg
argument_list|(
name|zkw
argument_list|,
name|znode
argument_list|,
name|data
argument_list|,
name|watcherSet
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|e
parameter_list|)
block|{
comment|// This log can get pretty annoying when we cycle on 100ms waits.
comment|// Enable trace if you really want to see it.
name|LOG
operator|.
name|trace
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Unable to get data of znode "
operator|+
name|znode
operator|+
literal|" "
operator|+
literal|"because node does not exist (not an error)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Unable to get data of znode "
operator|+
name|znode
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|zkw
operator|.
name|keeperException
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Unable to get data of znode "
operator|+
name|znode
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|zkw
operator|.
name|interruptedException
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Get the data at the specified znode without setting a watch.    *    * Returns the data if the node exists.  Returns null if the node does not    * exist.    *    * Sets the stats of the node in the passed Stat object.  Pass a null stat if    * not interested.    *    * @param zkw zk reference    * @param znode path of node    * @param stat node status to get if node exists    * @return data of the specified znode, or null if node does not exist    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|byte
index|[]
name|getDataNoWatch
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|znode
parameter_list|,
name|Stat
name|stat
parameter_list|)
throws|throws
name|KeeperException
block|{
try|try
block|{
name|byte
index|[]
name|data
init|=
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|getData
argument_list|(
name|znode
argument_list|,
literal|null
argument_list|,
name|stat
argument_list|)
decl_stmt|;
name|logRetrievedMsg
argument_list|(
name|zkw
argument_list|,
name|znode
argument_list|,
name|data
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Unable to get data of znode "
operator|+
name|znode
operator|+
literal|" "
operator|+
literal|"because node does not exist (not necessarily an error)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Unable to get data of znode "
operator|+
name|znode
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|zkw
operator|.
name|keeperException
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Unable to get data of znode "
operator|+
name|znode
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|zkw
operator|.
name|interruptedException
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Returns the date of child znodes of the specified znode.  Also sets a watch on    * the specified znode which will capture a NodeDeleted event on the specified    * znode as well as NodeChildrenChanged if any children of the specified znode    * are created or deleted.    *    * Returns null if the specified node does not exist.  Otherwise returns a    * list of children of the specified node.  If the node exists but it has no    * children, an empty list will be returned.    *    * @param zkw zk reference    * @param baseNode path of node to list and watch children of    * @return list of data of children of the specified node, an empty list if the node    *          exists but has no children, and null if the node does not exist    * @throws KeeperException if unexpected zookeeper exception    * @deprecated Unused    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|List
argument_list|<
name|NodeAndData
argument_list|>
name|getChildDataAndWatchForNewChildren
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|baseNode
parameter_list|)
throws|throws
name|KeeperException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|nodes
init|=
name|ZKUtil
operator|.
name|listChildrenAndWatchForNewChildren
argument_list|(
name|zkw
argument_list|,
name|baseNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodes
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|NodeAndData
argument_list|>
name|newNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|node
range|:
name|nodes
control|)
block|{
name|String
name|nodePath
init|=
name|ZNodePaths
operator|.
name|joinZNode
argument_list|(
name|baseNode
argument_list|,
name|node
argument_list|)
decl_stmt|;
name|byte
index|[]
name|data
init|=
name|ZKUtil
operator|.
name|getDataAndWatch
argument_list|(
name|zkw
argument_list|,
name|nodePath
argument_list|)
decl_stmt|;
name|newNodes
operator|.
name|add
argument_list|(
operator|new
name|NodeAndData
argument_list|(
name|nodePath
argument_list|,
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|newNodes
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Update the data of an existing node with the expected version to have the    * specified data.    *    * Throws an exception if there is a version mismatch or some other problem.    *    * Sets no watches under any conditions.    *    * @param zkw zk reference    * @param znode the path to the ZNode    * @param data the data to store in ZooKeeper    * @param expectedVersion the expected version    * @throws KeeperException if unexpected zookeeper exception    * @throws KeeperException.BadVersionException if version mismatch    * @deprecated Unused    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|void
name|updateExistingNodeData
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|znode
parameter_list|,
name|byte
index|[]
name|data
parameter_list|,
name|int
name|expectedVersion
parameter_list|)
throws|throws
name|KeeperException
block|{
try|try
block|{
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|setData
argument_list|(
name|znode
argument_list|,
name|data
argument_list|,
name|expectedVersion
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|zkw
operator|.
name|interruptedException
argument_list|(
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
comment|//
comment|// Data setting
comment|//
comment|/**    * Sets the data of the existing znode to be the specified data.  Ensures that    * the current data has the specified expected version.    *    *<p>If the node does not exist, a {@link NoNodeException} will be thrown.    *    *<p>If their is a version mismatch, method returns null.    *    *<p>No watches are set but setting data will trigger other watchers of this    * node.    *    *<p>If there is another problem, a KeeperException will be thrown.    *    * @param zkw zk reference    * @param znode path of node    * @param data data to set for node    * @param expectedVersion version expected when setting data    * @return true if data set, false if version mismatch    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|boolean
name|setData
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|znode
parameter_list|,
name|byte
index|[]
name|data
parameter_list|,
name|int
name|expectedVersion
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|KeeperException
operator|.
name|NoNodeException
block|{
try|try
block|{
return|return
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|setData
argument_list|(
name|znode
argument_list|,
name|data
argument_list|,
name|expectedVersion
argument_list|)
operator|!=
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|zkw
operator|.
name|interruptedException
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Set data into node creating node if it doesn't yet exist.    * Does not set watch.    *    * @param zkw zk reference    * @param znode path of node    * @param data data to set for node    * @throws KeeperException if a ZooKeeper operation fails    */
specifier|public
specifier|static
name|void
name|createSetData
parameter_list|(
specifier|final
name|ZKWatcher
name|zkw
parameter_list|,
specifier|final
name|String
name|znode
parameter_list|,
specifier|final
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|KeeperException
block|{
if|if
condition|(
name|checkExists
argument_list|(
name|zkw
argument_list|,
name|znode
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ZKUtil
operator|.
name|createWithParents
argument_list|(
name|zkw
argument_list|,
name|znode
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ZKUtil
operator|.
name|setData
argument_list|(
name|zkw
argument_list|,
name|znode
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Sets the data of the existing znode to be the specified data.  The node    * must exist but no checks are done on the existing data or version.    *    *<p>If the node does not exist, a {@link NoNodeException} will be thrown.    *    *<p>No watches are set but setting data will trigger other watchers of this    * node.    *    *<p>If there is another problem, a KeeperException will be thrown.    *    * @param zkw zk reference    * @param znode path of node    * @param data data to set for node    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|void
name|setData
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|znode
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|KeeperException
operator|.
name|NoNodeException
block|{
name|setData
argument_list|(
name|zkw
argument_list|,
operator|(
name|SetData
operator|)
name|ZKUtilOp
operator|.
name|setData
argument_list|(
name|znode
argument_list|,
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|setData
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|SetData
name|setData
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|KeeperException
operator|.
name|NoNodeException
block|{
name|SetDataRequest
name|sd
init|=
operator|(
name|SetDataRequest
operator|)
name|toZooKeeperOp
argument_list|(
name|zkw
argument_list|,
name|setData
argument_list|)
operator|.
name|toRequestRecord
argument_list|()
decl_stmt|;
name|setData
argument_list|(
name|zkw
argument_list|,
name|sd
operator|.
name|getPath
argument_list|()
argument_list|,
name|sd
operator|.
name|getData
argument_list|()
argument_list|,
name|sd
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns whether or not secure authentication is enabled    * (whether<code>hbase.security.authentication</code> is set to    *<code>kerberos</code>.    */
specifier|public
specifier|static
name|boolean
name|isSecureZooKeeper
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
comment|// Detection for embedded HBase client with jaas configuration
comment|// defined for third party programs.
try|try
block|{
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|Configuration
name|testConfig
init|=
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|Configuration
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
if|if
condition|(
name|testConfig
operator|.
name|getAppConfigurationEntry
argument_list|(
literal|"Client"
argument_list|)
operator|==
literal|null
operator|&&
name|testConfig
operator|.
name|getAppConfigurationEntry
argument_list|(
name|JaasConfiguration
operator|.
name|CLIENT_KEYTAB_KERBEROS_CONFIG_NAME
argument_list|)
operator|==
literal|null
operator|&&
name|testConfig
operator|.
name|getAppConfigurationEntry
argument_list|(
name|JaasConfiguration
operator|.
name|SERVER_KEYTAB_KERBEROS_CONFIG_NAME
argument_list|)
operator|==
literal|null
operator|&&
name|conf
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|ZK_CLIENT_KERBEROS_PRINCIPAL
argument_list|)
operator|==
literal|null
operator|&&
name|conf
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|ZK_SERVER_KERBEROS_PRINCIPAL
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// No Jaas configuration defined.
return|return
literal|false
return|;
block|}
comment|// Master& RSs uses hbase.zookeeper.client.*
return|return
literal|"kerberos"
operator|.
name|equalsIgnoreCase
argument_list|(
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.security.authentication"
argument_list|)
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|ArrayList
argument_list|<
name|ACL
argument_list|>
name|createACL
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|node
parameter_list|)
block|{
return|return
name|createACL
argument_list|(
name|zkw
argument_list|,
name|node
argument_list|,
name|isSecureZooKeeper
argument_list|(
name|zkw
operator|.
name|getConfiguration
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|ArrayList
argument_list|<
name|ACL
argument_list|>
name|createACL
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|node
parameter_list|,
name|boolean
name|isSecureZooKeeper
parameter_list|)
block|{
if|if
condition|(
operator|!
name|node
operator|.
name|startsWith
argument_list|(
name|zkw
operator|.
name|getZNodePaths
argument_list|()
operator|.
name|baseZNode
argument_list|)
condition|)
block|{
return|return
name|Ids
operator|.
name|OPEN_ACL_UNSAFE
return|;
block|}
if|if
condition|(
name|isSecureZooKeeper
condition|)
block|{
name|ArrayList
argument_list|<
name|ACL
argument_list|>
name|acls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// add permission to hbase supper user
name|String
index|[]
name|superUsers
init|=
name|zkw
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getStrings
argument_list|(
name|Superusers
operator|.
name|SUPERUSER_CONF_KEY
argument_list|)
decl_stmt|;
name|String
name|hbaseUser
init|=
literal|null
decl_stmt|;
try|try
block|{
name|hbaseUser
operator|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Could not acquire current User."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|superUsers
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|groups
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|user
range|:
name|superUsers
control|)
block|{
if|if
condition|(
name|AuthUtil
operator|.
name|isGroupPrincipal
argument_list|(
name|user
argument_list|)
condition|)
block|{
comment|// TODO: Set node ACL for groups when ZK supports this feature
name|groups
operator|.
name|add
argument_list|(
name|user
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|user
operator|.
name|equals
argument_list|(
name|hbaseUser
argument_list|)
condition|)
block|{
name|acls
operator|.
name|add
argument_list|(
operator|new
name|ACL
argument_list|(
name|Perms
operator|.
name|ALL
argument_list|,
operator|new
name|Id
argument_list|(
literal|"sasl"
argument_list|,
name|user
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|groups
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Znode ACL setting for group "
operator|+
name|groups
operator|+
literal|" is skipped, ZooKeeper doesn't support this feature presently."
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Certain znodes are accessed directly by the client,
comment|// so they must be readable by non-authenticated clients
if|if
condition|(
name|zkw
operator|.
name|getZNodePaths
argument_list|()
operator|.
name|isClientReadable
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|acls
operator|.
name|addAll
argument_list|(
name|Ids
operator|.
name|CREATOR_ALL_ACL
argument_list|)
expr_stmt|;
name|acls
operator|.
name|addAll
argument_list|(
name|Ids
operator|.
name|READ_ACL_UNSAFE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|acls
operator|.
name|addAll
argument_list|(
name|Ids
operator|.
name|CREATOR_ALL_ACL
argument_list|)
expr_stmt|;
block|}
return|return
name|acls
return|;
block|}
else|else
block|{
return|return
name|Ids
operator|.
name|OPEN_ACL_UNSAFE
return|;
block|}
block|}
comment|//
comment|// Node creation
comment|//
comment|/**    *    * Set the specified znode to be an ephemeral node carrying the specified    * data.    *    * If the node is created successfully, a watcher is also set on the node.    *    * If the node is not created successfully because it already exists, this    * method will also set a watcher on the node.    *    * If there is another problem, a KeeperException will be thrown.    *    * @param zkw zk reference    * @param znode path of node    * @param data data of node    * @return true if node created, false if not, watch set in both cases    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|boolean
name|createEphemeralNodeAndWatch
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|znode
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|KeeperException
block|{
name|boolean
name|ret
init|=
literal|true
decl_stmt|;
try|try
block|{
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|create
argument_list|(
name|znode
argument_list|,
name|data
argument_list|,
name|createACL
argument_list|(
name|zkw
argument_list|,
name|znode
argument_list|)
argument_list|,
name|CreateMode
operator|.
name|EPHEMERAL
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NodeExistsException
name|nee
parameter_list|)
block|{
name|ret
operator|=
literal|false
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Interrupted"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|watchAndCheckExists
argument_list|(
name|zkw
argument_list|,
name|znode
argument_list|)
condition|)
block|{
comment|// It did exist but now it doesn't, try again
return|return
name|createEphemeralNodeAndWatch
argument_list|(
name|zkw
argument_list|,
name|znode
argument_list|,
name|data
argument_list|)
return|;
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Creates the specified znode to be a persistent node carrying the specified    * data.    *    * Returns true if the node was successfully created, false if the node    * already existed.    *    * If the node is created successfully, a watcher is also set on the node.    *    * If the node is not created successfully because it already exists, this    * method will also set a watcher on the node but return false.    *    * If there is another problem, a KeeperException will be thrown.    *    * @param zkw zk reference    * @param znode path of node    * @param data data of node    * @return true if node created, false if not, watch set in both cases    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|boolean
name|createNodeIfNotExistsAndWatch
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|znode
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|KeeperException
block|{
name|boolean
name|ret
init|=
literal|true
decl_stmt|;
try|try
block|{
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|create
argument_list|(
name|znode
argument_list|,
name|data
argument_list|,
name|createACL
argument_list|(
name|zkw
argument_list|,
name|znode
argument_list|)
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NodeExistsException
name|nee
parameter_list|)
block|{
name|ret
operator|=
literal|false
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|zkw
operator|.
name|interruptedException
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
try|try
block|{
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|exists
argument_list|(
name|znode
argument_list|,
name|zkw
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|zkw
operator|.
name|interruptedException
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Creates the specified znode with the specified data but does not watch it.    *    * Returns the znode of the newly created node    *    * If there is another problem, a KeeperException will be thrown.    *    * @param zkw zk reference    * @param znode path of node    * @param data data of node    * @param createMode specifying whether the node to be created is ephemeral and/or sequential    * @return true name of the newly created znode or null    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|String
name|createNodeIfNotExistsNoWatch
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|znode
parameter_list|,
name|byte
index|[]
name|data
parameter_list|,
name|CreateMode
name|createMode
parameter_list|)
throws|throws
name|KeeperException
block|{
name|String
name|createdZNode
init|=
literal|null
decl_stmt|;
try|try
block|{
name|createdZNode
operator|=
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|create
argument_list|(
name|znode
argument_list|,
name|data
argument_list|,
name|createACL
argument_list|(
name|zkw
argument_list|,
name|znode
argument_list|)
argument_list|,
name|createMode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NodeExistsException
name|nee
parameter_list|)
block|{
return|return
name|znode
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|zkw
operator|.
name|interruptedException
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|createdZNode
return|;
block|}
comment|/**    * Creates the specified node with the specified data and watches it.    *    *<p>Throws an exception if the node already exists.    *    *<p>The node created is persistent and open access.    *    *<p>Returns the version number of the created node if successful.    *    * @param zkw zk reference    * @param znode path of node to create    * @param data data of node to create    * @return version of node created    * @throws KeeperException if unexpected zookeeper exception    * @throws KeeperException.NodeExistsException if node already exists    */
specifier|public
specifier|static
name|int
name|createAndWatch
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|znode
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|KeeperException
operator|.
name|NodeExistsException
block|{
try|try
block|{
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|create
argument_list|(
name|znode
argument_list|,
name|data
argument_list|,
name|createACL
argument_list|(
name|zkw
argument_list|,
name|znode
argument_list|)
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|)
expr_stmt|;
name|Stat
name|stat
init|=
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|exists
argument_list|(
name|znode
argument_list|,
name|zkw
argument_list|)
decl_stmt|;
if|if
condition|(
name|stat
operator|==
literal|null
condition|)
block|{
comment|// Likely a race condition. Someone deleted the znode.
throw|throw
name|KeeperException
operator|.
name|create
argument_list|(
name|KeeperException
operator|.
name|Code
operator|.
name|SYSTEMERROR
argument_list|,
literal|"ZK.exists returned null (i.e.: znode does not exist) for znode="
operator|+
name|znode
argument_list|)
throw|;
block|}
return|return
name|stat
operator|.
name|getVersion
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|zkw
operator|.
name|interruptedException
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/**    * Async creates the specified node with the specified data.    *    *<p>Throws an exception if the node already exists.    *    *<p>The node created is persistent and open access.    *    * @param zkw zk reference    * @param znode path of node to create    * @param data data of node to create    * @param cb the callback to use for the creation    * @param ctx the context to use for the creation    */
specifier|public
specifier|static
name|void
name|asyncCreate
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|znode
parameter_list|,
name|byte
index|[]
name|data
parameter_list|,
specifier|final
name|AsyncCallback
operator|.
name|StringCallback
name|cb
parameter_list|,
specifier|final
name|Object
name|ctx
parameter_list|)
block|{
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|getZooKeeper
argument_list|()
operator|.
name|create
argument_list|(
name|znode
argument_list|,
name|data
argument_list|,
name|createACL
argument_list|(
name|zkw
argument_list|,
name|znode
argument_list|)
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|,
name|cb
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates the specified node, iff the node does not exist.  Does not set a    * watch and fails silently if the node already exists.    *    * The node created is persistent and open access.    *    * @param zkw zk reference    * @param znode path of node    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|void
name|createAndFailSilent
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|znode
parameter_list|)
throws|throws
name|KeeperException
block|{
name|createAndFailSilent
argument_list|(
name|zkw
argument_list|,
name|znode
argument_list|,
operator|new
name|byte
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates the specified node containing specified data, iff the node does not exist.  Does    * not set a watch and fails silently if the node already exists.    *    * The node created is persistent and open access.    *    * @param zkw zk reference    * @param znode path of node    * @param data a byte array data to store in the znode    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|void
name|createAndFailSilent
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|znode
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|KeeperException
block|{
name|createAndFailSilent
argument_list|(
name|zkw
argument_list|,
operator|(
name|CreateAndFailSilent
operator|)
name|ZKUtilOp
operator|.
name|createAndFailSilent
argument_list|(
name|znode
argument_list|,
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|createAndFailSilent
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|CreateAndFailSilent
name|cafs
parameter_list|)
throws|throws
name|KeeperException
block|{
name|CreateRequest
name|create
init|=
operator|(
name|CreateRequest
operator|)
name|toZooKeeperOp
argument_list|(
name|zkw
argument_list|,
name|cafs
argument_list|)
operator|.
name|toRequestRecord
argument_list|()
decl_stmt|;
name|String
name|znode
init|=
name|create
operator|.
name|getPath
argument_list|()
decl_stmt|;
try|try
block|{
name|RecoverableZooKeeper
name|zk
init|=
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
decl_stmt|;
if|if
condition|(
name|zk
operator|.
name|exists
argument_list|(
name|znode
argument_list|,
literal|false
argument_list|)
operator|==
literal|null
condition|)
block|{
name|zk
operator|.
name|create
argument_list|(
name|znode
argument_list|,
name|create
operator|.
name|getData
argument_list|()
argument_list|,
name|create
operator|.
name|getAcl
argument_list|()
argument_list|,
name|CreateMode
operator|.
name|fromFlag
argument_list|(
name|create
operator|.
name|getFlags
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NodeExistsException
name|nee
parameter_list|)
block|{     }
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoAuthException
name|nee
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
literal|null
operator|==
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|exists
argument_list|(
name|znode
argument_list|,
literal|false
argument_list|)
condition|)
block|{
comment|// If we failed to create the file and it does not already exist.
throw|throw
operator|(
name|nee
operator|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|zkw
operator|.
name|interruptedException
argument_list|(
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|zkw
operator|.
name|interruptedException
argument_list|(
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Creates the specified node and all parent nodes required for it to exist.    *    * No watches are set and no errors are thrown if the node already exists.    *    * The nodes created are persistent and open access.    *    * @param zkw zk reference    * @param znode path of node    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|void
name|createWithParents
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|znode
parameter_list|)
throws|throws
name|KeeperException
block|{
name|createWithParents
argument_list|(
name|zkw
argument_list|,
name|znode
argument_list|,
operator|new
name|byte
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates the specified node and all parent nodes required for it to exist.  The creation of    * parent znodes is not atomic with the leafe znode creation but the data is written atomically    * when the leaf node is created.    *    * No watches are set and no errors are thrown if the node already exists.    *    * The nodes created are persistent and open access.    *    * @param zkw zk reference    * @param znode path of node    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|void
name|createWithParents
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|znode
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|KeeperException
block|{
try|try
block|{
if|if
condition|(
name|znode
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|create
argument_list|(
name|znode
argument_list|,
name|data
argument_list|,
name|createACL
argument_list|(
name|zkw
argument_list|,
name|znode
argument_list|)
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NodeExistsException
name|nee
parameter_list|)
block|{
return|return;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|nne
parameter_list|)
block|{
name|createWithParents
argument_list|(
name|zkw
argument_list|,
name|getParent
argument_list|(
name|znode
argument_list|)
argument_list|)
expr_stmt|;
name|createWithParents
argument_list|(
name|zkw
argument_list|,
name|znode
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|zkw
operator|.
name|interruptedException
argument_list|(
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
comment|//
comment|// Deletes
comment|//
comment|/**    * Delete the specified node.  Sets no watches.  Throws all exceptions.    */
specifier|public
specifier|static
name|void
name|deleteNode
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|node
parameter_list|)
throws|throws
name|KeeperException
block|{
name|deleteNode
argument_list|(
name|zkw
argument_list|,
name|node
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete the specified node with the specified version.  Sets no watches.    * Throws all exceptions.    */
specifier|public
specifier|static
name|boolean
name|deleteNode
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|node
parameter_list|,
name|int
name|version
parameter_list|)
throws|throws
name|KeeperException
block|{
try|try
block|{
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|delete
argument_list|(
name|node
argument_list|,
name|version
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|BadVersionException
name|bve
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|zkw
operator|.
name|interruptedException
argument_list|(
name|ie
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Deletes the specified node.  Fails silent if the node does not exist.    *    * @param zkw reference to the {@link ZKWatcher} which also contains configuration and operation    * @param node the node to delete    * @throws KeeperException if a ZooKeeper operation fails    */
specifier|public
specifier|static
name|void
name|deleteNodeFailSilent
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|node
parameter_list|)
throws|throws
name|KeeperException
block|{
name|deleteNodeFailSilent
argument_list|(
name|zkw
argument_list|,
operator|(
name|DeleteNodeFailSilent
operator|)
name|ZKUtilOp
operator|.
name|deleteNodeFailSilent
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|deleteNodeFailSilent
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|DeleteNodeFailSilent
name|dnfs
parameter_list|)
throws|throws
name|KeeperException
block|{
name|DeleteRequest
name|delete
init|=
operator|(
name|DeleteRequest
operator|)
name|toZooKeeperOp
argument_list|(
name|zkw
argument_list|,
name|dnfs
argument_list|)
operator|.
name|toRequestRecord
argument_list|()
decl_stmt|;
try|try
block|{
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|delete
argument_list|(
name|delete
operator|.
name|getPath
argument_list|()
argument_list|,
name|delete
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|nne
parameter_list|)
block|{     }
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|zkw
operator|.
name|interruptedException
argument_list|(
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Delete the specified node and all of it's children.    *<p>    * If the node does not exist, just returns.    *<p>    * Sets no watches. Throws all exceptions besides dealing with deletion of    * children.    */
specifier|public
specifier|static
name|void
name|deleteNodeRecursively
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|node
parameter_list|)
throws|throws
name|KeeperException
block|{
name|deleteNodeRecursivelyMultiOrSequential
argument_list|(
name|zkw
argument_list|,
literal|true
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete all the children of the specified node but not the node itself.    *    * Sets no watches.  Throws all exceptions besides dealing with deletion of    * children.    *    * @throws KeeperException if a ZooKeeper operation fails    */
specifier|public
specifier|static
name|void
name|deleteChildrenRecursively
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|node
parameter_list|)
throws|throws
name|KeeperException
block|{
name|deleteChildrenRecursivelyMultiOrSequential
argument_list|(
name|zkw
argument_list|,
literal|true
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete all the children of the specified node but not the node itself. This    * will first traverse the znode tree for listing the children and then delete    * these znodes using multi-update api or sequential based on the specified    * configurations.    *<p>    * Sets no watches. Throws all exceptions besides dealing with deletion of    * children.    *<p>    * If the following is true:    *<ul>    *<li>runSequentialOnMultiFailure is true    *</ul>    * on calling multi, we get a ZooKeeper exception that can be handled by a    * sequential call(*), we retry the operations one-by-one (sequentially).    *    * @param zkw    *          - zk reference    * @param runSequentialOnMultiFailure    *          - if true when we get a ZooKeeper exception that could retry the    *          operations one-by-one (sequentially)    * @param pathRoots    *          - path of the parent node(s)    * @throws KeeperException.NotEmptyException    *           if node has children while deleting    * @throws KeeperException    *           if unexpected ZooKeeper exception    * @throws IllegalArgumentException    *           if an invalid path is specified    */
specifier|public
specifier|static
name|void
name|deleteChildrenRecursivelyMultiOrSequential
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|boolean
name|runSequentialOnMultiFailure
parameter_list|,
name|String
modifier|...
name|pathRoots
parameter_list|)
throws|throws
name|KeeperException
block|{
if|if
condition|(
name|pathRoots
operator|==
literal|null
operator|||
name|pathRoots
operator|.
name|length
operator|<=
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Given path is not valid!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|List
argument_list|<
name|ZKUtilOp
argument_list|>
name|ops
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|eachRoot
range|:
name|pathRoots
control|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|children
init|=
name|listChildrenBFSNoWatch
argument_list|(
name|zkw
argument_list|,
name|eachRoot
argument_list|)
decl_stmt|;
comment|// Delete the leaves first and eventually get rid of the root
for|for
control|(
name|int
name|i
init|=
name|children
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|ops
operator|.
name|add
argument_list|(
name|ZKUtilOp
operator|.
name|deleteNodeFailSilent
argument_list|(
name|children
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// atleast one element should exist
if|if
condition|(
name|ops
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|multiOrSequential
argument_list|(
name|zkw
argument_list|,
name|ops
argument_list|,
name|runSequentialOnMultiFailure
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Delete the specified node and its children. This traverse the    * znode tree for listing the children and then delete    * these znodes including the parent using multi-update api or    * sequential based on the specified configurations.    *<p>    * Sets no watches. Throws all exceptions besides dealing with deletion of    * children.    *<p>    * If the following is true:    *<ul>    *<li>runSequentialOnMultiFailure is true    *</ul>    * on calling multi, we get a ZooKeeper exception that can be handled by a    * sequential call(*), we retry the operations one-by-one (sequentially).    *    * @param zkw    *          - zk reference    * @param runSequentialOnMultiFailure    *          - if true when we get a ZooKeeper exception that could retry the    *          operations one-by-one (sequentially)    * @param pathRoots    *          - path of the parent node(s)    * @throws KeeperException.NotEmptyException    *           if node has children while deleting    * @throws KeeperException    *           if unexpected ZooKeeper exception    * @throws IllegalArgumentException    *           if an invalid path is specified    */
specifier|public
specifier|static
name|void
name|deleteNodeRecursivelyMultiOrSequential
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|boolean
name|runSequentialOnMultiFailure
parameter_list|,
name|String
modifier|...
name|pathRoots
parameter_list|)
throws|throws
name|KeeperException
block|{
if|if
condition|(
name|pathRoots
operator|==
literal|null
operator|||
name|pathRoots
operator|.
name|length
operator|<=
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Given path is not valid!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|List
argument_list|<
name|ZKUtilOp
argument_list|>
name|ops
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|eachRoot
range|:
name|pathRoots
control|)
block|{
comment|// ZooKeeper Watches are one time triggers; When children of parent nodes are deleted
comment|// recursively, must set another watch, get notified of delete node
name|List
argument_list|<
name|String
argument_list|>
name|children
init|=
name|listChildrenBFSAndWatchThem
argument_list|(
name|zkw
argument_list|,
name|eachRoot
argument_list|)
decl_stmt|;
comment|// Delete the leaves first and eventually get rid of the root
for|for
control|(
name|int
name|i
init|=
name|children
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|ops
operator|.
name|add
argument_list|(
name|ZKUtilOp
operator|.
name|deleteNodeFailSilent
argument_list|(
name|children
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|exists
argument_list|(
name|eachRoot
argument_list|,
name|zkw
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|ops
operator|.
name|add
argument_list|(
name|ZKUtilOp
operator|.
name|deleteNodeFailSilent
argument_list|(
name|eachRoot
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|zkw
operator|.
name|interruptedException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|// atleast one element should exist
if|if
condition|(
name|ops
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|multiOrSequential
argument_list|(
name|zkw
argument_list|,
name|ops
argument_list|,
name|runSequentialOnMultiFailure
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * BFS Traversal of all the children under path, with the entries in the list,    * in the same order as that of the traversal. Lists all the children without    * setting any watches.    *    * @param zkw    *          - zk reference    * @param znode    *          - path of node    * @return list of children znodes under the path    * @throws KeeperException    *           if unexpected ZooKeeper exception    */
specifier|private
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|listChildrenBFSNoWatch
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
specifier|final
name|String
name|znode
parameter_list|)
throws|throws
name|KeeperException
block|{
name|Deque
argument_list|<
name|String
argument_list|>
name|queue
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|tree
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|queue
operator|.
name|add
argument_list|(
name|znode
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|String
name|node
init|=
name|queue
operator|.
name|pollFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|children
init|=
name|listChildrenNoWatch
argument_list|(
name|zkw
argument_list|,
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|children
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
for|for
control|(
specifier|final
name|String
name|child
range|:
name|children
control|)
block|{
specifier|final
name|String
name|childPath
init|=
name|node
operator|+
literal|"/"
operator|+
name|child
decl_stmt|;
name|queue
operator|.
name|add
argument_list|(
name|childPath
argument_list|)
expr_stmt|;
name|tree
operator|.
name|add
argument_list|(
name|childPath
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|tree
return|;
block|}
comment|/**    * BFS Traversal of all the children under path, with the entries in the list,    * in the same order as that of the traversal.    * Lists all the children and set watches on to them.    *    * @param zkw    *          - zk reference    * @param znode    *          - path of node    * @return list of children znodes under the path    * @throws KeeperException    *           if unexpected ZooKeeper exception    */
specifier|private
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|listChildrenBFSAndWatchThem
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
specifier|final
name|String
name|znode
parameter_list|)
throws|throws
name|KeeperException
block|{
name|Deque
argument_list|<
name|String
argument_list|>
name|queue
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|tree
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|queue
operator|.
name|add
argument_list|(
name|znode
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|String
name|node
init|=
name|queue
operator|.
name|pollFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|children
init|=
name|listChildrenAndWatchThem
argument_list|(
name|zkw
argument_list|,
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|children
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
for|for
control|(
specifier|final
name|String
name|child
range|:
name|children
control|)
block|{
specifier|final
name|String
name|childPath
init|=
name|node
operator|+
literal|"/"
operator|+
name|child
decl_stmt|;
name|queue
operator|.
name|add
argument_list|(
name|childPath
argument_list|)
expr_stmt|;
name|tree
operator|.
name|add
argument_list|(
name|childPath
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|tree
return|;
block|}
comment|/**    * Represents an action taken by ZKUtil, e.g. createAndFailSilent.    * These actions are higher-level than ZKOp actions, which represent    * individual actions in the ZooKeeper API, like create.    */
specifier|public
specifier|abstract
specifier|static
class|class
name|ZKUtilOp
block|{
specifier|private
name|String
name|path
decl_stmt|;
specifier|private
name|ZKUtilOp
parameter_list|(
name|String
name|path
parameter_list|)
block|{
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
block|}
comment|/**      * @return a createAndFailSilent ZKUtilOp      */
specifier|public
specifier|static
name|ZKUtilOp
name|createAndFailSilent
parameter_list|(
name|String
name|path
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
block|{
return|return
operator|new
name|CreateAndFailSilent
argument_list|(
name|path
argument_list|,
name|data
argument_list|)
return|;
block|}
comment|/**      * @return a deleteNodeFailSilent ZKUtilOP      */
specifier|public
specifier|static
name|ZKUtilOp
name|deleteNodeFailSilent
parameter_list|(
name|String
name|path
parameter_list|)
block|{
return|return
operator|new
name|DeleteNodeFailSilent
argument_list|(
name|path
argument_list|)
return|;
block|}
comment|/**      * @return a setData ZKUtilOp      */
specifier|public
specifier|static
name|ZKUtilOp
name|setData
parameter_list|(
name|String
name|path
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
block|{
return|return
operator|new
name|SetData
argument_list|(
name|path
argument_list|,
name|data
argument_list|)
return|;
block|}
comment|/**      * @return a setData ZKUtilOp      */
specifier|public
specifier|static
name|ZKUtilOp
name|setData
parameter_list|(
name|String
name|path
parameter_list|,
name|byte
index|[]
name|data
parameter_list|,
name|int
name|version
parameter_list|)
block|{
return|return
operator|new
name|SetData
argument_list|(
name|path
argument_list|,
name|data
argument_list|,
name|version
argument_list|)
return|;
block|}
comment|/**      * @return path to znode where the ZKOp will occur      */
specifier|public
name|String
name|getPath
parameter_list|()
block|{
return|return
name|path
return|;
block|}
comment|/**      * ZKUtilOp representing createAndFailSilent in ZooKeeper      * (attempt to create node, ignore error if already exists)      */
specifier|public
specifier|static
specifier|final
class|class
name|CreateAndFailSilent
extends|extends
name|ZKUtilOp
block|{
specifier|private
name|byte
index|[]
name|data
decl_stmt|;
specifier|private
name|CreateAndFailSilent
parameter_list|(
name|String
name|path
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
block|{
name|super
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|this
operator|.
name|data
operator|=
name|data
expr_stmt|;
block|}
specifier|public
name|byte
index|[]
name|getData
parameter_list|()
block|{
return|return
name|data
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|CreateAndFailSilent
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|CreateAndFailSilent
name|op
init|=
operator|(
name|CreateAndFailSilent
operator|)
name|o
decl_stmt|;
return|return
name|getPath
argument_list|()
operator|.
name|equals
argument_list|(
name|op
operator|.
name|getPath
argument_list|()
argument_list|)
operator|&&
name|Arrays
operator|.
name|equals
argument_list|(
name|data
argument_list|,
name|op
operator|.
name|data
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|ret
init|=
literal|17
operator|+
name|getPath
argument_list|()
operator|.
name|hashCode
argument_list|()
operator|*
literal|31
decl_stmt|;
return|return
name|ret
operator|*
literal|31
operator|+
name|Bytes
operator|.
name|hashCode
argument_list|(
name|data
argument_list|)
return|;
block|}
block|}
comment|/**      * ZKUtilOp representing deleteNodeFailSilent in ZooKeeper      * (attempt to delete node, ignore error if node doesn't exist)      */
specifier|public
specifier|static
specifier|final
class|class
name|DeleteNodeFailSilent
extends|extends
name|ZKUtilOp
block|{
specifier|private
name|DeleteNodeFailSilent
parameter_list|(
name|String
name|path
parameter_list|)
block|{
name|super
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|DeleteNodeFailSilent
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|super
operator|.
name|equals
argument_list|(
name|o
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|getPath
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
block|}
comment|/**      * ZKUtilOp representing setData in ZooKeeper      */
specifier|public
specifier|static
specifier|final
class|class
name|SetData
extends|extends
name|ZKUtilOp
block|{
specifier|private
name|byte
index|[]
name|data
decl_stmt|;
specifier|private
name|int
name|version
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|SetData
parameter_list|(
name|String
name|path
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
block|{
name|super
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|this
operator|.
name|data
operator|=
name|data
expr_stmt|;
block|}
specifier|private
name|SetData
parameter_list|(
name|String
name|path
parameter_list|,
name|byte
index|[]
name|data
parameter_list|,
name|int
name|version
parameter_list|)
block|{
name|super
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|this
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|this
operator|.
name|version
operator|=
name|version
expr_stmt|;
block|}
specifier|public
name|byte
index|[]
name|getData
parameter_list|()
block|{
return|return
name|data
return|;
block|}
specifier|public
name|int
name|getVersion
parameter_list|()
block|{
return|return
name|version
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|SetData
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|SetData
name|op
init|=
operator|(
name|SetData
operator|)
name|o
decl_stmt|;
return|return
name|getPath
argument_list|()
operator|.
name|equals
argument_list|(
name|op
operator|.
name|getPath
argument_list|()
argument_list|)
operator|&&
name|Arrays
operator|.
name|equals
argument_list|(
name|data
argument_list|,
name|op
operator|.
name|data
argument_list|)
operator|&&
name|getVersion
argument_list|()
operator|==
name|op
operator|.
name|getVersion
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|ret
init|=
name|getPath
argument_list|()
operator|.
name|hashCode
argument_list|()
decl_stmt|;
name|ret
operator|=
name|ret
operator|*
literal|31
operator|+
name|Bytes
operator|.
name|hashCode
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|ret
operator|*
literal|31
operator|+
name|Integer
operator|.
name|hashCode
argument_list|(
name|version
argument_list|)
return|;
block|}
block|}
block|}
comment|/**    * Convert from ZKUtilOp to ZKOp    */
specifier|private
specifier|static
name|Op
name|toZooKeeperOp
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|ZKUtilOp
name|op
parameter_list|)
throws|throws
name|UnsupportedOperationException
block|{
if|if
condition|(
name|op
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|op
operator|instanceof
name|CreateAndFailSilent
condition|)
block|{
name|CreateAndFailSilent
name|cafs
init|=
operator|(
name|CreateAndFailSilent
operator|)
name|op
decl_stmt|;
return|return
name|Op
operator|.
name|create
argument_list|(
name|cafs
operator|.
name|getPath
argument_list|()
argument_list|,
name|cafs
operator|.
name|getData
argument_list|()
argument_list|,
name|createACL
argument_list|(
name|zkw
argument_list|,
name|cafs
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|op
operator|instanceof
name|DeleteNodeFailSilent
condition|)
block|{
name|DeleteNodeFailSilent
name|dnfs
init|=
operator|(
name|DeleteNodeFailSilent
operator|)
name|op
decl_stmt|;
return|return
name|Op
operator|.
name|delete
argument_list|(
name|dnfs
operator|.
name|getPath
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|op
operator|instanceof
name|SetData
condition|)
block|{
name|SetData
name|sd
init|=
operator|(
name|SetData
operator|)
name|op
decl_stmt|;
return|return
name|Op
operator|.
name|setData
argument_list|(
name|sd
operator|.
name|getPath
argument_list|()
argument_list|,
name|sd
operator|.
name|getData
argument_list|()
argument_list|,
name|sd
operator|.
name|getVersion
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Unexpected ZKUtilOp type: "
operator|+
name|op
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * Use ZooKeeper's multi-update functionality.    *    * If all of the following are true:    * - runSequentialOnMultiFailure is true    * - on calling multi, we get a ZooKeeper exception that can be handled by a sequential call(*)    * Then:    * - we retry the operations one-by-one (sequentially)    *    * Note *: an example is receiving a NodeExistsException from a "create" call.  Without multi,    * a user could call "createAndFailSilent" to ensure that a node exists if they don't care who    * actually created the node (i.e. the NodeExistsException from ZooKeeper is caught).    * This will cause all operations in the multi to fail, however, because    * the NodeExistsException that zk.create throws will fail the multi transaction.    * In this case, if the previous conditions hold, the commands are run sequentially, which should    * result in the correct final state, but means that the operations will not run atomically.    *    * @throws KeeperException if a ZooKeeper operation fails    */
specifier|public
specifier|static
name|void
name|multiOrSequential
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|List
argument_list|<
name|ZKUtilOp
argument_list|>
name|ops
parameter_list|,
name|boolean
name|runSequentialOnMultiFailure
parameter_list|)
throws|throws
name|KeeperException
block|{
if|if
condition|(
name|zkw
operator|.
name|getConfiguration
argument_list|()
operator|.
name|get
argument_list|(
literal|"hbase.zookeeper.useMulti"
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"hbase.zookeeper.useMulti is deprecated. Default to true always."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ops
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|List
argument_list|<
name|Op
argument_list|>
name|zkOps
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ZKUtilOp
name|op
range|:
name|ops
control|)
block|{
name|zkOps
operator|.
name|add
argument_list|(
name|toZooKeeperOp
argument_list|(
name|zkw
argument_list|,
name|op
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|multi
argument_list|(
name|zkOps
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|ke
parameter_list|)
block|{
switch|switch
condition|(
name|ke
operator|.
name|code
argument_list|()
condition|)
block|{
case|case
name|NODEEXISTS
case|:
case|case
name|NONODE
case|:
case|case
name|BADVERSION
case|:
case|case
name|NOAUTH
case|:
comment|// if we get an exception that could be solved by running sequentially
comment|// (and the client asked us to), then break out and run sequentially
if|if
condition|(
name|runSequentialOnMultiFailure
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"On call to ZK.multi, received exception: "
operator|+
name|ke
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
literal|"  Attempting to run operations sequentially because"
operator|+
literal|" runSequentialOnMultiFailure is: "
operator|+
name|runSequentialOnMultiFailure
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|processSequentially
argument_list|(
name|zkw
argument_list|,
name|ops
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
throw|throw
name|ke
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|zkw
operator|.
name|interruptedException
argument_list|(
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|void
name|processSequentially
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|List
argument_list|<
name|ZKUtilOp
argument_list|>
name|ops
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|NoNodeException
block|{
for|for
control|(
name|ZKUtilOp
name|op
range|:
name|ops
control|)
block|{
if|if
condition|(
name|op
operator|instanceof
name|CreateAndFailSilent
condition|)
block|{
name|createAndFailSilent
argument_list|(
name|zkw
argument_list|,
operator|(
name|CreateAndFailSilent
operator|)
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|instanceof
name|DeleteNodeFailSilent
condition|)
block|{
name|deleteNodeFailSilent
argument_list|(
name|zkw
argument_list|,
operator|(
name|DeleteNodeFailSilent
operator|)
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|instanceof
name|SetData
condition|)
block|{
name|setData
argument_list|(
name|zkw
argument_list|,
operator|(
name|SetData
operator|)
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Unexpected ZKUtilOp type: "
operator|+
name|op
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
comment|//
comment|// ZooKeeper cluster information
comment|//
comment|/** @return String dump of everything in ZooKeeper. */
specifier|public
specifier|static
name|String
name|dump
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
try|try
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"HBase is rooted at "
argument_list|)
operator|.
name|append
argument_list|(
name|zkw
operator|.
name|getZNodePaths
argument_list|()
operator|.
name|baseZNode
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\nActive master address: "
argument_list|)
expr_stmt|;
try|try
block|{
name|sb
operator|.
name|append
argument_list|(
name|MasterAddressTracker
operator|.
name|getMasterAddress
argument_list|(
name|zkw
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"<<FAILED LOOKUP: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
operator|+
literal|">>"
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"\nBackup master addresses:"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|child
range|:
name|listChildrenNoWatch
argument_list|(
name|zkw
argument_list|,
name|zkw
operator|.
name|getZNodePaths
argument_list|()
operator|.
name|backupMasterAddressesZNode
argument_list|)
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\n "
argument_list|)
operator|.
name|append
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"\nRegion server holding hbase:meta: "
operator|+
operator|new
name|MetaTableLocator
argument_list|()
operator|.
name|getMetaRegionLocation
argument_list|(
name|zkw
argument_list|)
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|HBaseConfiguration
operator|.
name|create
argument_list|()
decl_stmt|;
name|int
name|numMetaReplicas
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|META_REPLICAS_NUM
argument_list|,
name|HConstants
operator|.
name|DEFAULT_META_REPLICA_NUM
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|numMetaReplicas
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\nRegion server holding hbase:meta, replicaId "
operator|+
name|i
operator|+
literal|" "
operator|+
operator|new
name|MetaTableLocator
argument_list|()
operator|.
name|getMetaRegionLocation
argument_list|(
name|zkw
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"\nRegion servers:"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|child
range|:
name|listChildrenNoWatch
argument_list|(
name|zkw
argument_list|,
name|zkw
operator|.
name|getZNodePaths
argument_list|()
operator|.
name|rsZNode
argument_list|)
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\n "
argument_list|)
operator|.
name|append
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|getReplicationZnodesDump
argument_list|(
name|zkw
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|ke
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Couldn't get the replication znode dump"
argument_list|,
name|ke
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"\nQuorum Server Statistics:"
argument_list|)
expr_stmt|;
name|String
index|[]
name|servers
init|=
name|zkw
operator|.
name|getQuorum
argument_list|()
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|server
range|:
name|servers
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\n "
argument_list|)
operator|.
name|append
argument_list|(
name|server
argument_list|)
expr_stmt|;
try|try
block|{
name|String
index|[]
name|stat
init|=
name|getServerStats
argument_list|(
name|server
argument_list|,
name|ZKUtil
operator|.
name|zkDumpConnectionTimeOut
argument_list|)
decl_stmt|;
if|if
condition|(
name|stat
operator|==
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"[Error] invalid quorum server: "
operator|+
name|server
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|String
name|s
range|:
name|stat
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\n  "
argument_list|)
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\n  ERROR: "
argument_list|)
operator|.
name|append
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|ke
parameter_list|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\nFATAL ZooKeeper Exception!\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
operator|+
name|ke
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Appends replication znodes to the passed StringBuilder.    *    * @param zkw reference to the {@link ZKWatcher} which also contains configuration and operation    * @param sb the {@link StringBuilder} to append to    * @throws KeeperException if a ZooKeeper operation fails    */
specifier|private
specifier|static
name|void
name|getReplicationZnodesDump
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|StringBuilder
name|sb
parameter_list|)
throws|throws
name|KeeperException
block|{
name|String
name|replicationZnode
init|=
name|zkw
operator|.
name|getZNodePaths
argument_list|()
operator|.
name|replicationZNode
decl_stmt|;
if|if
condition|(
name|ZKUtil
operator|.
name|checkExists
argument_list|(
name|zkw
argument_list|,
name|replicationZnode
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return;
block|}
comment|// do a ls -r on this znode
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
operator|.
name|append
argument_list|(
name|replicationZnode
argument_list|)
operator|.
name|append
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|children
init|=
name|ZKUtil
operator|.
name|listChildrenNoWatch
argument_list|(
name|zkw
argument_list|,
name|replicationZnode
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|child
range|:
name|children
control|)
block|{
name|String
name|znode
init|=
name|ZNodePaths
operator|.
name|joinZNode
argument_list|(
name|replicationZnode
argument_list|,
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|znode
operator|.
name|equals
argument_list|(
name|zkw
operator|.
name|getZNodePaths
argument_list|()
operator|.
name|peersZNode
argument_list|)
condition|)
block|{
name|appendPeersZnodes
argument_list|(
name|zkw
argument_list|,
name|znode
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|znode
operator|.
name|equals
argument_list|(
name|zkw
operator|.
name|getZNodePaths
argument_list|()
operator|.
name|queuesZNode
argument_list|)
condition|)
block|{
name|appendRSZnodes
argument_list|(
name|zkw
argument_list|,
name|znode
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|znode
operator|.
name|equals
argument_list|(
name|zkw
operator|.
name|getZNodePaths
argument_list|()
operator|.
name|hfileRefsZNode
argument_list|)
condition|)
block|{
name|appendHFileRefsZnodes
argument_list|(
name|zkw
argument_list|,
name|znode
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
name|void
name|appendHFileRefsZnodes
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|hfileRefsZnode
parameter_list|,
name|StringBuilder
name|sb
parameter_list|)
throws|throws
name|KeeperException
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
operator|.
name|append
argument_list|(
name|hfileRefsZnode
argument_list|)
operator|.
name|append
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|peerIdZnode
range|:
name|ZKUtil
operator|.
name|listChildrenNoWatch
argument_list|(
name|zkw
argument_list|,
name|hfileRefsZnode
argument_list|)
control|)
block|{
name|String
name|znodeToProcess
init|=
name|ZNodePaths
operator|.
name|joinZNode
argument_list|(
name|hfileRefsZnode
argument_list|,
name|peerIdZnode
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
operator|.
name|append
argument_list|(
name|znodeToProcess
argument_list|)
operator|.
name|append
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|peerHFileRefsZnodes
init|=
name|ZKUtil
operator|.
name|listChildrenNoWatch
argument_list|(
name|zkw
argument_list|,
name|znodeToProcess
argument_list|)
decl_stmt|;
name|int
name|size
init|=
name|peerHFileRefsZnodes
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|peerHFileRefsZnodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|size
operator|-
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Returns a string with replication znodes and position of the replication log    * @param zkw reference to the {@link ZKWatcher} which also contains configuration and operation    * @return aq string of replication znodes and log positions    */
specifier|public
specifier|static
name|String
name|getReplicationZnodesDump
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|)
throws|throws
name|KeeperException
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|getReplicationZnodesDump
argument_list|(
name|zkw
argument_list|,
name|sb
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|void
name|appendRSZnodes
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|znode
parameter_list|,
name|StringBuilder
name|sb
parameter_list|)
throws|throws
name|KeeperException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|stack
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|stack
operator|.
name|add
argument_list|(
name|znode
argument_list|)
expr_stmt|;
do|do
block|{
name|String
name|znodeToProcess
init|=
name|stack
operator|.
name|remove
argument_list|(
name|stack
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
operator|.
name|append
argument_list|(
name|znodeToProcess
argument_list|)
operator|.
name|append
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
name|byte
index|[]
name|data
decl_stmt|;
try|try
block|{
name|data
operator|=
name|ZKUtil
operator|.
name|getData
argument_list|(
name|zkw
argument_list|,
name|znodeToProcess
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|zkw
operator|.
name|interruptedException
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|data
operator|!=
literal|null
operator|&&
name|data
operator|.
name|length
operator|>
literal|0
condition|)
block|{
comment|// log position
name|long
name|position
init|=
literal|0
decl_stmt|;
try|try
block|{
name|position
operator|=
name|ZKUtil
operator|.
name|parseWALPositionFrom
argument_list|(
name|ZKUtil
operator|.
name|getData
argument_list|(
name|zkw
argument_list|,
name|znodeToProcess
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|position
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|ignored
parameter_list|)
block|{         }
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|zkw
operator|.
name|interruptedException
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
for|for
control|(
name|String
name|zNodeChild
range|:
name|ZKUtil
operator|.
name|listChildrenNoWatch
argument_list|(
name|zkw
argument_list|,
name|znodeToProcess
argument_list|)
control|)
block|{
name|stack
operator|.
name|add
argument_list|(
name|ZNodePaths
operator|.
name|joinZNode
argument_list|(
name|znodeToProcess
argument_list|,
name|zNodeChild
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
do|;
block|}
specifier|private
specifier|static
name|void
name|appendPeersZnodes
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|peersZnode
parameter_list|,
name|StringBuilder
name|sb
parameter_list|)
throws|throws
name|KeeperException
block|{
name|int
name|pblen
init|=
name|ProtobufUtil
operator|.
name|lengthOfPBMagic
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
operator|.
name|append
argument_list|(
name|peersZnode
argument_list|)
operator|.
name|append
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|peerIdZnode
range|:
name|ZKUtil
operator|.
name|listChildrenNoWatch
argument_list|(
name|zkw
argument_list|,
name|peersZnode
argument_list|)
control|)
block|{
name|String
name|znodeToProcess
init|=
name|ZNodePaths
operator|.
name|joinZNode
argument_list|(
name|peersZnode
argument_list|,
name|peerIdZnode
argument_list|)
decl_stmt|;
name|byte
index|[]
name|data
decl_stmt|;
try|try
block|{
name|data
operator|=
name|ZKUtil
operator|.
name|getData
argument_list|(
name|zkw
argument_list|,
name|znodeToProcess
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|zkw
operator|.
name|interruptedException
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// parse the data of the above peer znode.
try|try
block|{
name|ReplicationProtos
operator|.
name|ReplicationPeer
operator|.
name|Builder
name|builder
init|=
name|ReplicationProtos
operator|.
name|ReplicationPeer
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|ProtobufUtil
operator|.
name|mergeFrom
argument_list|(
name|builder
argument_list|,
name|data
argument_list|,
name|pblen
argument_list|,
name|data
operator|.
name|length
operator|-
name|pblen
argument_list|)
expr_stmt|;
name|String
name|clusterKey
init|=
name|builder
operator|.
name|getClusterkey
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
operator|.
name|append
argument_list|(
name|znodeToProcess
argument_list|)
operator|.
name|append
argument_list|(
literal|": "
argument_list|)
operator|.
name|append
argument_list|(
name|clusterKey
argument_list|)
expr_stmt|;
comment|// add the peer-state.
name|appendPeerState
argument_list|(
name|zkw
argument_list|,
name|znodeToProcess
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ipbe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Got Exception while parsing peer: "
operator|+
name|znodeToProcess
argument_list|,
name|ipbe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
name|void
name|appendPeerState
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|znodeToProcess
parameter_list|,
name|StringBuilder
name|sb
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InvalidProtocolBufferException
block|{
name|String
name|peerState
init|=
name|zkw
operator|.
name|getConfiguration
argument_list|()
operator|.
name|get
argument_list|(
literal|"zookeeper.znode.replication.peers.state"
argument_list|,
literal|"peer-state"
argument_list|)
decl_stmt|;
name|int
name|pblen
init|=
name|ProtobufUtil
operator|.
name|lengthOfPBMagic
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|child
range|:
name|ZKUtil
operator|.
name|listChildrenNoWatch
argument_list|(
name|zkw
argument_list|,
name|znodeToProcess
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|child
operator|.
name|equals
argument_list|(
name|peerState
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|String
name|peerStateZnode
init|=
name|ZNodePaths
operator|.
name|joinZNode
argument_list|(
name|znodeToProcess
argument_list|,
name|child
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
operator|.
name|append
argument_list|(
name|peerStateZnode
argument_list|)
operator|.
name|append
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
name|byte
index|[]
name|peerStateData
decl_stmt|;
try|try
block|{
name|peerStateData
operator|=
name|ZKUtil
operator|.
name|getData
argument_list|(
name|zkw
argument_list|,
name|peerStateZnode
argument_list|)
expr_stmt|;
name|ReplicationProtos
operator|.
name|ReplicationState
operator|.
name|Builder
name|builder
init|=
name|ReplicationProtos
operator|.
name|ReplicationState
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|ProtobufUtil
operator|.
name|mergeFrom
argument_list|(
name|builder
argument_list|,
name|peerStateData
argument_list|,
name|pblen
argument_list|,
name|peerStateData
operator|.
name|length
operator|-
name|pblen
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|builder
operator|.
name|getState
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ipbe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Got Exception while parsing peer: "
operator|+
name|znodeToProcess
argument_list|,
name|ipbe
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|zkw
operator|.
name|interruptedException
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/**    * Gets the statistics from the given server.    *    * @param server  The server to get the statistics from.    * @param timeout  The socket timeout to use.    * @return The array of response strings.    * @throws IOException When the socket communication fails.    */
specifier|public
specifier|static
name|String
index|[]
name|getServerStats
parameter_list|(
name|String
name|server
parameter_list|,
name|int
name|timeout
parameter_list|)
throws|throws
name|IOException
block|{
name|String
index|[]
name|sp
init|=
name|server
operator|.
name|split
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
if|if
condition|(
name|sp
operator|==
literal|null
operator|||
name|sp
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|host
init|=
name|sp
index|[
literal|0
index|]
decl_stmt|;
name|int
name|port
init|=
name|sp
operator|.
name|length
operator|>
literal|1
condition|?
name|Integer
operator|.
name|parseInt
argument_list|(
name|sp
index|[
literal|1
index|]
argument_list|)
else|:
name|HConstants
operator|.
name|DEFAULT_ZOOKEEPER_CLIENT_PORT
decl_stmt|;
name|InetSocketAddress
name|sockAddr
init|=
operator|new
name|InetSocketAddress
argument_list|(
name|host
argument_list|,
name|port
argument_list|)
decl_stmt|;
try|try
init|(
name|Socket
name|socket
init|=
operator|new
name|Socket
argument_list|()
init|)
block|{
name|socket
operator|.
name|connect
argument_list|(
name|sockAddr
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|socket
operator|.
name|setSoTimeout
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
try|try
init|(
name|PrintWriter
name|out
init|=
operator|new
name|PrintWriter
argument_list|(
operator|new
name|BufferedWriter
argument_list|(
operator|new
name|OutputStreamWriter
argument_list|(
name|socket
operator|.
name|getOutputStream
argument_list|()
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
argument_list|,
literal|true
argument_list|)
init|;
name|BufferedReader
name|in
operator|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|socket
operator|.
name|getInputStream
argument_list|()
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
init|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"stat"
argument_list|)
expr_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|res
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|String
name|line
init|=
name|in
operator|.
name|readLine
argument_list|()
decl_stmt|;
if|if
condition|(
name|line
operator|!=
literal|null
condition|)
block|{
name|res
operator|.
name|add
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
return|return
name|res
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|res
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
block|}
block|}
specifier|private
specifier|static
name|void
name|logRetrievedMsg
parameter_list|(
specifier|final
name|ZKWatcher
name|zkw
parameter_list|,
specifier|final
name|String
name|znode
parameter_list|,
specifier|final
name|byte
index|[]
name|data
parameter_list|,
specifier|final
name|boolean
name|watcherSet
parameter_list|)
block|{
if|if
condition|(
operator|!
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
return|return;
block|}
name|LOG
operator|.
name|trace
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Retrieved "
operator|+
operator|(
operator|(
name|data
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|data
operator|.
name|length
operator|)
operator|+
literal|" byte(s) of data from znode "
operator|+
name|znode
operator|+
operator|(
name|watcherSet
condition|?
literal|" and set watcher; "
else|:
literal|"; data="
operator|)
operator|+
operator|(
name|data
operator|==
literal|null
condition|?
literal|"null"
else|:
name|data
operator|.
name|length
operator|==
literal|0
condition|?
literal|"empty"
else|:
operator|(
name|znode
operator|.
name|startsWith
argument_list|(
name|zkw
operator|.
name|getZNodePaths
argument_list|()
operator|.
name|metaZNodePrefix
argument_list|)
condition|?
name|getServerNameOrEmptyString
argument_list|(
name|data
argument_list|)
else|:
name|znode
operator|.
name|startsWith
argument_list|(
name|zkw
operator|.
name|getZNodePaths
argument_list|()
operator|.
name|backupMasterAddressesZNode
argument_list|)
condition|?
name|getServerNameOrEmptyString
argument_list|(
name|data
argument_list|)
else|:
name|StringUtils
operator|.
name|abbreviate
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|data
argument_list|)
argument_list|,
literal|32
argument_list|)
operator|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|String
name|getServerNameOrEmptyString
parameter_list|(
specifier|final
name|byte
index|[]
name|data
parameter_list|)
block|{
try|try
block|{
return|return
name|ProtobufUtil
operator|.
name|parseServerNameFrom
argument_list|(
name|data
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|e
parameter_list|)
block|{
return|return
literal|""
return|;
block|}
block|}
comment|/**    * Waits for HBase installation's base (parent) znode to become available.    * @throws IOException on ZK errors    */
specifier|public
specifier|static
name|void
name|waitForBaseZNode
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting until the base znode is available"
argument_list|)
expr_stmt|;
name|String
name|parentZNode
init|=
name|conf
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|ZOOKEEPER_ZNODE_PARENT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_ZOOKEEPER_ZNODE_PARENT
argument_list|)
decl_stmt|;
name|ZooKeeper
name|zk
init|=
operator|new
name|ZooKeeper
argument_list|(
name|ZKConfig
operator|.
name|getZKQuorumServersString
argument_list|(
name|conf
argument_list|)
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|ZK_SESSION_TIMEOUT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_ZK_SESSION_TIMEOUT
argument_list|)
argument_list|,
name|EmptyWatcher
operator|.
name|instance
argument_list|)
decl_stmt|;
specifier|final
name|int
name|maxTimeMs
init|=
literal|10000
decl_stmt|;
specifier|final
name|int
name|maxNumAttempts
init|=
name|maxTimeMs
operator|/
name|HConstants
operator|.
name|SOCKET_RETRY_WAIT_MS
decl_stmt|;
name|KeeperException
name|keeperEx
init|=
literal|null
decl_stmt|;
try|try
block|{
try|try
block|{
for|for
control|(
name|int
name|attempt
init|=
literal|0
init|;
name|attempt
operator|<
name|maxNumAttempts
condition|;
operator|++
name|attempt
control|)
block|{
try|try
block|{
if|if
condition|(
name|zk
operator|.
name|exists
argument_list|(
name|parentZNode
argument_list|,
literal|false
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Parent znode exists: "
operator|+
name|parentZNode
argument_list|)
expr_stmt|;
name|keeperEx
operator|=
literal|null
expr_stmt|;
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|keeperEx
operator|=
name|e
expr_stmt|;
block|}
name|Threads
operator|.
name|sleepWithoutInterrupt
argument_list|(
name|HConstants
operator|.
name|SOCKET_RETRY_WAIT_MS
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|zk
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|keeperEx
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|keeperEx
argument_list|)
throw|;
block|}
block|}
comment|/**    * Convert a {@link DeserializationException} to a more palatable {@link KeeperException}.    * Used when can't let a {@link DeserializationException} out w/o changing public API.    * @param e Exception to convert    * @return Converted exception    */
specifier|public
specifier|static
name|KeeperException
name|convert
parameter_list|(
specifier|final
name|DeserializationException
name|e
parameter_list|)
block|{
name|KeeperException
name|ke
init|=
operator|new
name|KeeperException
operator|.
name|DataInconsistencyException
argument_list|()
decl_stmt|;
name|ke
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|ke
return|;
block|}
comment|/**    * Recursively print the current state of ZK (non-transactional)    * @param root name of the root directory in zk to print    */
specifier|public
specifier|static
name|void
name|logZKTree
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|root
parameter_list|)
block|{
if|if
condition|(
operator|!
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
return|return;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Current zk system:"
argument_list|)
expr_stmt|;
name|String
name|prefix
init|=
literal|"|-"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|prefix
operator|+
name|root
argument_list|)
expr_stmt|;
try|try
block|{
name|logZKTree
argument_list|(
name|zkw
argument_list|,
name|root
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Helper method to print the current state of the ZK tree.    * @see #logZKTree(ZKWatcher, String)    * @throws KeeperException if an unexpected exception occurs    */
specifier|protected
specifier|static
name|void
name|logZKTree
parameter_list|(
name|ZKWatcher
name|zkw
parameter_list|,
name|String
name|root
parameter_list|,
name|String
name|prefix
parameter_list|)
throws|throws
name|KeeperException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|children
init|=
name|ZKUtil
operator|.
name|listChildrenNoWatch
argument_list|(
name|zkw
argument_list|,
name|root
argument_list|)
decl_stmt|;
if|if
condition|(
name|children
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|String
name|child
range|:
name|children
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|prefix
operator|+
name|child
argument_list|)
expr_stmt|;
name|String
name|node
init|=
name|ZNodePaths
operator|.
name|joinZNode
argument_list|(
name|root
operator|.
name|equals
argument_list|(
literal|"/"
argument_list|)
condition|?
literal|""
else|:
name|root
argument_list|,
name|child
argument_list|)
decl_stmt|;
name|logZKTree
argument_list|(
name|zkw
argument_list|,
name|node
argument_list|,
name|prefix
operator|+
literal|"---"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @param position the position to serialize    * @return Serialized protobuf of<code>position</code> with pb magic prefix prepended suitable    *         for use as content of an wal position in a replication queue.    */
specifier|public
specifier|static
name|byte
index|[]
name|positionToByteArray
parameter_list|(
specifier|final
name|long
name|position
parameter_list|)
block|{
name|byte
index|[]
name|bytes
init|=
name|ReplicationProtos
operator|.
name|ReplicationHLogPosition
operator|.
name|newBuilder
argument_list|()
operator|.
name|setPosition
argument_list|(
name|position
argument_list|)
operator|.
name|build
argument_list|()
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
return|return
name|ProtobufUtil
operator|.
name|prependPBMagic
argument_list|(
name|bytes
argument_list|)
return|;
block|}
comment|/**    * @param bytes - Content of a WAL position znode.    * @return long - The current WAL position.    * @throws DeserializationException if the WAL position cannot be parsed    */
specifier|public
specifier|static
name|long
name|parseWALPositionFrom
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|)
throws|throws
name|DeserializationException
block|{
if|if
condition|(
name|bytes
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|DeserializationException
argument_list|(
literal|"Unable to parse null WAL position."
argument_list|)
throw|;
block|}
if|if
condition|(
name|ProtobufUtil
operator|.
name|isPBMagicPrefix
argument_list|(
name|bytes
argument_list|)
condition|)
block|{
name|int
name|pblen
init|=
name|ProtobufUtil
operator|.
name|lengthOfPBMagic
argument_list|()
decl_stmt|;
name|ReplicationProtos
operator|.
name|ReplicationHLogPosition
operator|.
name|Builder
name|builder
init|=
name|ReplicationProtos
operator|.
name|ReplicationHLogPosition
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|ReplicationProtos
operator|.
name|ReplicationHLogPosition
name|position
decl_stmt|;
try|try
block|{
name|ProtobufUtil
operator|.
name|mergeFrom
argument_list|(
name|builder
argument_list|,
name|bytes
argument_list|,
name|pblen
argument_list|,
name|bytes
operator|.
name|length
operator|-
name|pblen
argument_list|)
expr_stmt|;
name|position
operator|=
name|builder
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DeserializationException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|position
operator|.
name|getPosition
argument_list|()
return|;
block|}
else|else
block|{
if|if
condition|(
name|bytes
operator|.
name|length
operator|>
literal|0
condition|)
block|{
return|return
name|Bytes
operator|.
name|toLong
argument_list|(
name|bytes
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
block|}
end_class

end_unit

