begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|ManagementFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|trace
operator|.
name|TraceUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|RetryCounter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|RetryCounterFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|core
operator|.
name|TraceScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|AsyncCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|CreateMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|Op
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|OpResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|Watcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|ZooDefs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|ZooKeeper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|ZooKeeper
operator|.
name|States
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|ACL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|Stat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|proto
operator|.
name|CreateRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|proto
operator|.
name|SetDataRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * A zookeeper that can handle 'recoverable' errors.  * To handle recoverable errors, developers need to realize that there are two  * classes of requests: idempotent and non-idempotent requests. Read requests  * and unconditional sets and deletes are examples of idempotent requests, they  * can be reissued with the same results.  * (Although, the delete may throw a NoNodeException on reissue its effect on  * the ZooKeeper state is the same.) Non-idempotent requests need special  * handling, application and library writers need to keep in mind that they may  * need to encode information in the data or name of znodes to detect  * retries. A simple example is a create that uses a sequence flag.  * If a process issues a create("/x-", ..., SEQUENCE) and gets a connection  * loss exception, that process will reissue another  * create("/x-", ..., SEQUENCE) and get back x-111. When the process does a  * getChildren("/"), it sees x-1,x-30,x-109,x-110,x-111, now it could be  * that x-109 was the result of the previous create, so the process actually  * owns both x-109 and x-111. An easy way around this is to use "x-process id-"  * when doing the create. If the process is using an id of 352, before reissuing  * the create it will do a getChildren("/") and see "x-222-1", "x-542-30",  * "x-352-109", x-333-110". The process will know that the original create  * succeeded an the znode it created is "x-352-109".  * @see "http://wiki.apache.org/hadoop/ZooKeeper/ErrorHandling"  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|RecoverableZooKeeper
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|RecoverableZooKeeper
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// the actual ZooKeeper client instance
specifier|private
name|ZooKeeper
name|zk
decl_stmt|;
specifier|private
specifier|final
name|RetryCounterFactory
name|retryCounterFactory
decl_stmt|;
comment|// An identifier of this process in the cluster
specifier|private
specifier|final
name|String
name|identifier
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|id
decl_stmt|;
specifier|private
specifier|final
name|Watcher
name|watcher
decl_stmt|;
specifier|private
specifier|final
name|int
name|sessionTimeout
decl_stmt|;
specifier|private
specifier|final
name|String
name|quorumServers
decl_stmt|;
specifier|private
specifier|final
name|int
name|maxMultiSize
decl_stmt|;
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"DE_MIGHT_IGNORE"
argument_list|,
name|justification
operator|=
literal|"None. Its always been this way."
argument_list|)
specifier|public
name|RecoverableZooKeeper
parameter_list|(
name|String
name|quorumServers
parameter_list|,
name|int
name|sessionTimeout
parameter_list|,
name|Watcher
name|watcher
parameter_list|,
name|int
name|maxRetries
parameter_list|,
name|int
name|retryIntervalMillis
parameter_list|,
name|int
name|maxSleepTime
parameter_list|,
name|String
name|identifier
parameter_list|,
name|int
name|maxMultiSize
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO: Add support for zk 'chroot'; we don't add it to the quorumServers String as we should.
name|this
operator|.
name|retryCounterFactory
operator|=
operator|new
name|RetryCounterFactory
argument_list|(
name|maxRetries
operator|+
literal|1
argument_list|,
name|retryIntervalMillis
argument_list|,
name|maxSleepTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|identifier
operator|==
literal|null
operator|||
name|identifier
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// the identifier = processID@hostName
name|identifier
operator|=
name|ManagementFactory
operator|.
name|getRuntimeMXBean
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Process identifier="
operator|+
name|identifier
operator|+
literal|" connecting to ZooKeeper ensemble="
operator|+
name|quorumServers
argument_list|)
expr_stmt|;
name|this
operator|.
name|identifier
operator|=
name|identifier
expr_stmt|;
name|this
operator|.
name|id
operator|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|identifier
argument_list|)
expr_stmt|;
name|this
operator|.
name|watcher
operator|=
name|watcher
expr_stmt|;
name|this
operator|.
name|sessionTimeout
operator|=
name|sessionTimeout
expr_stmt|;
name|this
operator|.
name|quorumServers
operator|=
name|quorumServers
expr_stmt|;
name|this
operator|.
name|maxMultiSize
operator|=
name|maxMultiSize
expr_stmt|;
try|try
block|{
name|checkZk
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|x
parameter_list|)
block|{
comment|/* ignore */
block|}
block|}
comment|/**    * Returns the maximum size (in bytes) that should be included in any single multi() call.    *    * NB: This is an approximation, so there may be variance in the msg actually sent over the    * wire. Please be sure to set this approximately, with respect to your ZK server configuration    * for jute.maxbuffer.    */
specifier|public
name|int
name|getMaxMultiSizeLimit
parameter_list|()
block|{
return|return
name|maxMultiSize
return|;
block|}
comment|/**    * Try to create a ZooKeeper connection. Turns any exception encountered into a    * KeeperException.OperationTimeoutException so it can retried.    * @return The created ZooKeeper connection object    * @throws KeeperException if a ZooKeeper operation fails    */
specifier|protected
specifier|synchronized
name|ZooKeeper
name|checkZk
parameter_list|()
throws|throws
name|KeeperException
block|{
if|if
condition|(
name|this
operator|.
name|zk
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|this
operator|.
name|zk
operator|=
operator|new
name|ZooKeeper
argument_list|(
name|quorumServers
argument_list|,
name|sessionTimeout
argument_list|,
name|watcher
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to create ZooKeeper Connection"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|KeeperException
operator|.
name|OperationTimeoutException
argument_list|()
throw|;
block|}
block|}
return|return
name|zk
return|;
block|}
specifier|public
specifier|synchronized
name|void
name|reconnectAfterExpiration
parameter_list|()
throws|throws
name|IOException
throws|,
name|KeeperException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|zk
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Closing dead ZooKeeper connection, session"
operator|+
literal|" was: 0x"
operator|+
name|Long
operator|.
name|toHexString
argument_list|(
name|zk
operator|.
name|getSessionId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|zk
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// reset the ZooKeeper connection
name|zk
operator|=
literal|null
expr_stmt|;
block|}
name|checkZk
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Recreated a ZooKeeper, session"
operator|+
literal|" is: 0x"
operator|+
name|Long
operator|.
name|toHexString
argument_list|(
name|zk
operator|.
name|getSessionId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * delete is an idempotent operation. Retry before throwing exception.    * This function will not throw NoNodeException if the path does not    * exist.    */
specifier|public
name|void
name|delete
parameter_list|(
name|String
name|path
parameter_list|,
name|int
name|version
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|KeeperException
block|{
try|try
init|(
name|TraceScope
name|scope
init|=
name|TraceUtil
operator|.
name|createTrace
argument_list|(
literal|"RecoverableZookeeper.delete"
argument_list|)
init|)
block|{
name|RetryCounter
name|retryCounter
init|=
name|retryCounterFactory
operator|.
name|create
argument_list|()
decl_stmt|;
name|boolean
name|isRetry
init|=
literal|false
decl_stmt|;
comment|// False for first attempt, true for all retries.
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|checkZk
argument_list|()
operator|.
name|delete
argument_list|(
name|path
argument_list|,
name|version
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|e
operator|.
name|code
argument_list|()
condition|)
block|{
case|case
name|NONODE
case|:
if|if
condition|(
name|isRetry
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Node "
operator|+
name|path
operator|+
literal|" already deleted. Assuming a "
operator|+
literal|"previous attempt succeeded."
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Node "
operator|+
name|path
operator|+
literal|" already deleted, retry="
operator|+
name|isRetry
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
case|case
name|CONNECTIONLOSS
case|:
name|retryOrThrow
argument_list|(
name|retryCounter
argument_list|,
name|e
argument_list|,
literal|"delete"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPERATIONTIMEOUT
case|:
name|retryOrThrow
argument_list|(
name|retryCounter
argument_list|,
name|e
argument_list|,
literal|"delete"
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
name|e
throw|;
block|}
block|}
name|retryCounter
operator|.
name|sleepUntilNextRetry
argument_list|()
expr_stmt|;
name|isRetry
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
comment|/**    * exists is an idempotent operation. Retry before throwing exception    * @return A Stat instance    */
specifier|public
name|Stat
name|exists
parameter_list|(
name|String
name|path
parameter_list|,
name|Watcher
name|watcher
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
return|return
name|exists
argument_list|(
name|path
argument_list|,
name|watcher
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|private
name|Stat
name|exists
parameter_list|(
name|String
name|path
parameter_list|,
name|Watcher
name|watcher
parameter_list|,
name|Boolean
name|watch
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|KeeperException
block|{
try|try
init|(
name|TraceScope
name|scope
init|=
name|TraceUtil
operator|.
name|createTrace
argument_list|(
literal|"RecoverableZookeeper.exists"
argument_list|)
init|)
block|{
name|RetryCounter
name|retryCounter
init|=
name|retryCounterFactory
operator|.
name|create
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|Stat
name|nodeStat
decl_stmt|;
if|if
condition|(
name|watch
operator|==
literal|null
condition|)
block|{
name|nodeStat
operator|=
name|checkZk
argument_list|()
operator|.
name|exists
argument_list|(
name|path
argument_list|,
name|watcher
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nodeStat
operator|=
name|checkZk
argument_list|()
operator|.
name|exists
argument_list|(
name|path
argument_list|,
name|watch
argument_list|)
expr_stmt|;
block|}
return|return
name|nodeStat
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|e
operator|.
name|code
argument_list|()
condition|)
block|{
case|case
name|CONNECTIONLOSS
case|:
name|retryOrThrow
argument_list|(
name|retryCounter
argument_list|,
name|e
argument_list|,
literal|"exists"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPERATIONTIMEOUT
case|:
name|retryOrThrow
argument_list|(
name|retryCounter
argument_list|,
name|e
argument_list|,
literal|"exists"
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
name|e
throw|;
block|}
block|}
name|retryCounter
operator|.
name|sleepUntilNextRetry
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * exists is an idempotent operation. Retry before throwing exception    * @return A Stat instance    */
specifier|public
name|Stat
name|exists
parameter_list|(
name|String
name|path
parameter_list|,
name|boolean
name|watch
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
return|return
name|exists
argument_list|(
name|path
argument_list|,
literal|null
argument_list|,
name|watch
argument_list|)
return|;
block|}
specifier|private
name|void
name|retryOrThrow
parameter_list|(
name|RetryCounter
name|retryCounter
parameter_list|,
name|KeeperException
name|e
parameter_list|,
name|String
name|opName
parameter_list|)
throws|throws
name|KeeperException
block|{
if|if
condition|(
operator|!
name|retryCounter
operator|.
name|shouldRetry
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"ZooKeeper "
operator|+
name|opName
operator|+
literal|" failed after "
operator|+
name|retryCounter
operator|.
name|getMaxAttempts
argument_list|()
operator|+
literal|" attempts"
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Retry, connectivity issue (JVM Pause?); quorum="
operator|+
name|quorumServers
operator|+
literal|","
operator|+
literal|"exception="
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
comment|/**    * getChildren is an idempotent operation. Retry before throwing exception    * @return List of children znodes    */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getChildren
parameter_list|(
name|String
name|path
parameter_list|,
name|Watcher
name|watcher
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
return|return
name|getChildren
argument_list|(
name|path
argument_list|,
name|watcher
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getChildren
parameter_list|(
name|String
name|path
parameter_list|,
name|Watcher
name|watcher
parameter_list|,
name|Boolean
name|watch
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|KeeperException
block|{
try|try
init|(
name|TraceScope
name|scope
init|=
name|TraceUtil
operator|.
name|createTrace
argument_list|(
literal|"RecoverableZookeeper.getChildren"
argument_list|)
init|)
block|{
name|RetryCounter
name|retryCounter
init|=
name|retryCounterFactory
operator|.
name|create
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|List
argument_list|<
name|String
argument_list|>
name|children
decl_stmt|;
if|if
condition|(
name|watch
operator|==
literal|null
condition|)
block|{
name|children
operator|=
name|checkZk
argument_list|()
operator|.
name|getChildren
argument_list|(
name|path
argument_list|,
name|watcher
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|children
operator|=
name|checkZk
argument_list|()
operator|.
name|getChildren
argument_list|(
name|path
argument_list|,
name|watch
argument_list|)
expr_stmt|;
block|}
return|return
name|children
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|e
operator|.
name|code
argument_list|()
condition|)
block|{
case|case
name|CONNECTIONLOSS
case|:
name|retryOrThrow
argument_list|(
name|retryCounter
argument_list|,
name|e
argument_list|,
literal|"getChildren"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPERATIONTIMEOUT
case|:
name|retryOrThrow
argument_list|(
name|retryCounter
argument_list|,
name|e
argument_list|,
literal|"getChildren"
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
name|e
throw|;
block|}
block|}
name|retryCounter
operator|.
name|sleepUntilNextRetry
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * getChildren is an idempotent operation. Retry before throwing exception    * @return List of children znodes    */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getChildren
parameter_list|(
name|String
name|path
parameter_list|,
name|boolean
name|watch
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
return|return
name|getChildren
argument_list|(
name|path
argument_list|,
literal|null
argument_list|,
name|watch
argument_list|)
return|;
block|}
comment|/**    * getData is an idempotent operation. Retry before throwing exception    * @return Data    */
specifier|public
name|byte
index|[]
name|getData
parameter_list|(
name|String
name|path
parameter_list|,
name|Watcher
name|watcher
parameter_list|,
name|Stat
name|stat
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
return|return
name|getData
argument_list|(
name|path
argument_list|,
name|watcher
argument_list|,
literal|null
argument_list|,
name|stat
argument_list|)
return|;
block|}
specifier|private
name|byte
index|[]
name|getData
parameter_list|(
name|String
name|path
parameter_list|,
name|Watcher
name|watcher
parameter_list|,
name|Boolean
name|watch
parameter_list|,
name|Stat
name|stat
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|KeeperException
block|{
try|try
init|(
name|TraceScope
name|scope
init|=
name|TraceUtil
operator|.
name|createTrace
argument_list|(
literal|"RecoverableZookeeper.getData"
argument_list|)
init|)
block|{
name|RetryCounter
name|retryCounter
init|=
name|retryCounterFactory
operator|.
name|create
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|byte
index|[]
name|revData
decl_stmt|;
if|if
condition|(
name|watch
operator|==
literal|null
condition|)
block|{
name|revData
operator|=
name|checkZk
argument_list|()
operator|.
name|getData
argument_list|(
name|path
argument_list|,
name|watcher
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|revData
operator|=
name|checkZk
argument_list|()
operator|.
name|getData
argument_list|(
name|path
argument_list|,
name|watch
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
return|return
name|ZKMetadata
operator|.
name|removeMetaData
argument_list|(
name|revData
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|e
operator|.
name|code
argument_list|()
condition|)
block|{
case|case
name|CONNECTIONLOSS
case|:
name|retryOrThrow
argument_list|(
name|retryCounter
argument_list|,
name|e
argument_list|,
literal|"getData"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPERATIONTIMEOUT
case|:
name|retryOrThrow
argument_list|(
name|retryCounter
argument_list|,
name|e
argument_list|,
literal|"getData"
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
name|e
throw|;
block|}
block|}
name|retryCounter
operator|.
name|sleepUntilNextRetry
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * getData is an idempotent operation. Retry before throwing exception    * @return Data    */
specifier|public
name|byte
index|[]
name|getData
parameter_list|(
name|String
name|path
parameter_list|,
name|boolean
name|watch
parameter_list|,
name|Stat
name|stat
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
return|return
name|getData
argument_list|(
name|path
argument_list|,
literal|null
argument_list|,
name|watch
argument_list|,
name|stat
argument_list|)
return|;
block|}
comment|/**    * setData is NOT an idempotent operation. Retry may cause BadVersion Exception    * Adding an identifier field into the data to check whether    * badversion is caused by the result of previous correctly setData    * @return Stat instance    */
specifier|public
name|Stat
name|setData
parameter_list|(
name|String
name|path
parameter_list|,
name|byte
index|[]
name|data
parameter_list|,
name|int
name|version
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
try|try
init|(
name|TraceScope
name|scope
init|=
name|TraceUtil
operator|.
name|createTrace
argument_list|(
literal|"RecoverableZookeeper.setData"
argument_list|)
init|)
block|{
name|RetryCounter
name|retryCounter
init|=
name|retryCounterFactory
operator|.
name|create
argument_list|()
decl_stmt|;
name|byte
index|[]
name|newData
init|=
name|ZKMetadata
operator|.
name|appendMetaData
argument_list|(
name|id
argument_list|,
name|data
argument_list|)
decl_stmt|;
name|boolean
name|isRetry
init|=
literal|false
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
return|return
name|checkZk
argument_list|()
operator|.
name|setData
argument_list|(
name|path
argument_list|,
name|newData
argument_list|,
name|version
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|e
operator|.
name|code
argument_list|()
condition|)
block|{
case|case
name|CONNECTIONLOSS
case|:
name|retryOrThrow
argument_list|(
name|retryCounter
argument_list|,
name|e
argument_list|,
literal|"setData"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPERATIONTIMEOUT
case|:
name|retryOrThrow
argument_list|(
name|retryCounter
argument_list|,
name|e
argument_list|,
literal|"setData"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BADVERSION
case|:
if|if
condition|(
name|isRetry
condition|)
block|{
comment|// try to verify whether the previous setData success or not
try|try
block|{
name|Stat
name|stat
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
name|byte
index|[]
name|revData
init|=
name|checkZk
argument_list|()
operator|.
name|getData
argument_list|(
name|path
argument_list|,
literal|false
argument_list|,
name|stat
argument_list|)
decl_stmt|;
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|revData
argument_list|,
name|newData
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// the bad version is caused by previous successful setData
return|return
name|stat
return|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|keeperException
parameter_list|)
block|{
comment|// the ZK is not reliable at this moment. just throwing exception
throw|throw
name|keeperException
throw|;
block|}
block|}
comment|// throw other exceptions and verified bad version exceptions
default|default:
throw|throw
name|e
throw|;
block|}
block|}
name|retryCounter
operator|.
name|sleepUntilNextRetry
argument_list|()
expr_stmt|;
name|isRetry
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
comment|/**    * getAcl is an idempotent operation. Retry before throwing exception    * @return list of ACLs    */
specifier|public
name|List
argument_list|<
name|ACL
argument_list|>
name|getAcl
parameter_list|(
name|String
name|path
parameter_list|,
name|Stat
name|stat
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
try|try
init|(
name|TraceScope
name|scope
init|=
name|TraceUtil
operator|.
name|createTrace
argument_list|(
literal|"RecoverableZookeeper.getAcl"
argument_list|)
init|)
block|{
name|RetryCounter
name|retryCounter
init|=
name|retryCounterFactory
operator|.
name|create
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
return|return
name|checkZk
argument_list|()
operator|.
name|getACL
argument_list|(
name|path
argument_list|,
name|stat
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|e
operator|.
name|code
argument_list|()
condition|)
block|{
case|case
name|CONNECTIONLOSS
case|:
name|retryOrThrow
argument_list|(
name|retryCounter
argument_list|,
name|e
argument_list|,
literal|"getAcl"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPERATIONTIMEOUT
case|:
name|retryOrThrow
argument_list|(
name|retryCounter
argument_list|,
name|e
argument_list|,
literal|"getAcl"
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
name|e
throw|;
block|}
block|}
name|retryCounter
operator|.
name|sleepUntilNextRetry
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * setAcl is an idempotent operation. Retry before throwing exception    * @return list of ACLs    */
specifier|public
name|Stat
name|setAcl
parameter_list|(
name|String
name|path
parameter_list|,
name|List
argument_list|<
name|ACL
argument_list|>
name|acls
parameter_list|,
name|int
name|version
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
try|try
init|(
name|TraceScope
name|scope
init|=
name|TraceUtil
operator|.
name|createTrace
argument_list|(
literal|"RecoverableZookeeper.setAcl"
argument_list|)
init|)
block|{
name|RetryCounter
name|retryCounter
init|=
name|retryCounterFactory
operator|.
name|create
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
return|return
name|checkZk
argument_list|()
operator|.
name|setACL
argument_list|(
name|path
argument_list|,
name|acls
argument_list|,
name|version
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|e
operator|.
name|code
argument_list|()
condition|)
block|{
case|case
name|CONNECTIONLOSS
case|:
name|retryOrThrow
argument_list|(
name|retryCounter
argument_list|,
name|e
argument_list|,
literal|"setAcl"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPERATIONTIMEOUT
case|:
name|retryOrThrow
argument_list|(
name|retryCounter
argument_list|,
name|e
argument_list|,
literal|"setAcl"
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
name|e
throw|;
block|}
block|}
name|retryCounter
operator|.
name|sleepUntilNextRetry
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    *<p>    * NONSEQUENTIAL create is idempotent operation.    * Retry before throwing exceptions.    * But this function will not throw the NodeExist exception back to the    * application.    *</p>    *<p>    * But SEQUENTIAL is NOT idempotent operation. It is necessary to add    * identifier to the path to verify, whether the previous one is successful    * or not.    *</p>    *    * @return Path    */
specifier|public
name|String
name|create
parameter_list|(
name|String
name|path
parameter_list|,
name|byte
index|[]
name|data
parameter_list|,
name|List
argument_list|<
name|ACL
argument_list|>
name|acl
parameter_list|,
name|CreateMode
name|createMode
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
try|try
init|(
name|TraceScope
name|scope
init|=
name|TraceUtil
operator|.
name|createTrace
argument_list|(
literal|"RecoverableZookeeper.create"
argument_list|)
init|)
block|{
name|byte
index|[]
name|newData
init|=
name|ZKMetadata
operator|.
name|appendMetaData
argument_list|(
name|id
argument_list|,
name|data
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|createMode
condition|)
block|{
case|case
name|EPHEMERAL
case|:
case|case
name|PERSISTENT
case|:
return|return
name|createNonSequential
argument_list|(
name|path
argument_list|,
name|newData
argument_list|,
name|acl
argument_list|,
name|createMode
argument_list|)
return|;
case|case
name|EPHEMERAL_SEQUENTIAL
case|:
case|case
name|PERSISTENT_SEQUENTIAL
case|:
return|return
name|createSequential
argument_list|(
name|path
argument_list|,
name|newData
argument_list|,
name|acl
argument_list|,
name|createMode
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unrecognized CreateMode: "
operator|+
name|createMode
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
name|String
name|createNonSequential
parameter_list|(
name|String
name|path
parameter_list|,
name|byte
index|[]
name|data
parameter_list|,
name|List
argument_list|<
name|ACL
argument_list|>
name|acl
parameter_list|,
name|CreateMode
name|createMode
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
name|RetryCounter
name|retryCounter
init|=
name|retryCounterFactory
operator|.
name|create
argument_list|()
decl_stmt|;
name|boolean
name|isRetry
init|=
literal|false
decl_stmt|;
comment|// False for first attempt, true for all retries.
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
return|return
name|checkZk
argument_list|()
operator|.
name|create
argument_list|(
name|path
argument_list|,
name|data
argument_list|,
name|acl
argument_list|,
name|createMode
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|e
operator|.
name|code
argument_list|()
condition|)
block|{
case|case
name|NODEEXISTS
case|:
if|if
condition|(
name|isRetry
condition|)
block|{
comment|// If the connection was lost, there is still a possibility that
comment|// we have successfully created the node at our previous attempt,
comment|// so we read the node and compare.
name|byte
index|[]
name|currentData
init|=
name|checkZk
argument_list|()
operator|.
name|getData
argument_list|(
name|path
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentData
operator|!=
literal|null
operator|&&
name|Bytes
operator|.
name|compareTo
argument_list|(
name|currentData
argument_list|,
name|data
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// We successfully created a non-sequential node
return|return
name|path
return|;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Node "
operator|+
name|path
operator|+
literal|" already exists with "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|currentData
argument_list|)
operator|+
literal|", could not write "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"Node {} already exists"
argument_list|,
name|path
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
case|case
name|CONNECTIONLOSS
case|:
name|retryOrThrow
argument_list|(
name|retryCounter
argument_list|,
name|e
argument_list|,
literal|"create"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPERATIONTIMEOUT
case|:
name|retryOrThrow
argument_list|(
name|retryCounter
argument_list|,
name|e
argument_list|,
literal|"create"
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
name|e
throw|;
block|}
block|}
name|retryCounter
operator|.
name|sleepUntilNextRetry
argument_list|()
expr_stmt|;
name|isRetry
operator|=
literal|true
expr_stmt|;
block|}
block|}
specifier|private
name|String
name|createSequential
parameter_list|(
name|String
name|path
parameter_list|,
name|byte
index|[]
name|data
parameter_list|,
name|List
argument_list|<
name|ACL
argument_list|>
name|acl
parameter_list|,
name|CreateMode
name|createMode
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
name|RetryCounter
name|retryCounter
init|=
name|retryCounterFactory
operator|.
name|create
argument_list|()
decl_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
name|String
name|newPath
init|=
name|path
operator|+
name|this
operator|.
name|identifier
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
if|if
condition|(
operator|!
name|first
condition|)
block|{
comment|// Check if we succeeded on a previous attempt
name|String
name|previousResult
init|=
name|findPreviousSequentialNode
argument_list|(
name|newPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|previousResult
operator|!=
literal|null
condition|)
block|{
return|return
name|previousResult
return|;
block|}
block|}
name|first
operator|=
literal|false
expr_stmt|;
return|return
name|checkZk
argument_list|()
operator|.
name|create
argument_list|(
name|newPath
argument_list|,
name|data
argument_list|,
name|acl
argument_list|,
name|createMode
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|e
operator|.
name|code
argument_list|()
condition|)
block|{
case|case
name|CONNECTIONLOSS
case|:
name|retryOrThrow
argument_list|(
name|retryCounter
argument_list|,
name|e
argument_list|,
literal|"create"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPERATIONTIMEOUT
case|:
name|retryOrThrow
argument_list|(
name|retryCounter
argument_list|,
name|e
argument_list|,
literal|"create"
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
name|e
throw|;
block|}
block|}
name|retryCounter
operator|.
name|sleepUntilNextRetry
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Convert Iterable of {@link org.apache.zookeeper.Op} we got into the ZooKeeper.Op    * instances to actually pass to multi (need to do this in order to appendMetaData).    */
specifier|private
name|Iterable
argument_list|<
name|Op
argument_list|>
name|prepareZKMulti
parameter_list|(
name|Iterable
argument_list|<
name|Op
argument_list|>
name|ops
parameter_list|)
throws|throws
name|UnsupportedOperationException
block|{
if|if
condition|(
name|ops
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|Op
argument_list|>
name|preparedOps
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Op
name|op
range|:
name|ops
control|)
block|{
if|if
condition|(
name|op
operator|.
name|getType
argument_list|()
operator|==
name|ZooDefs
operator|.
name|OpCode
operator|.
name|create
condition|)
block|{
name|CreateRequest
name|create
init|=
operator|(
name|CreateRequest
operator|)
name|op
operator|.
name|toRequestRecord
argument_list|()
decl_stmt|;
name|preparedOps
operator|.
name|add
argument_list|(
name|Op
operator|.
name|create
argument_list|(
name|create
operator|.
name|getPath
argument_list|()
argument_list|,
name|ZKMetadata
operator|.
name|appendMetaData
argument_list|(
name|id
argument_list|,
name|create
operator|.
name|getData
argument_list|()
argument_list|)
argument_list|,
name|create
operator|.
name|getAcl
argument_list|()
argument_list|,
name|create
operator|.
name|getFlags
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|.
name|getType
argument_list|()
operator|==
name|ZooDefs
operator|.
name|OpCode
operator|.
name|delete
condition|)
block|{
comment|// no need to appendMetaData for delete
name|preparedOps
operator|.
name|add
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|.
name|getType
argument_list|()
operator|==
name|ZooDefs
operator|.
name|OpCode
operator|.
name|setData
condition|)
block|{
name|SetDataRequest
name|setData
init|=
operator|(
name|SetDataRequest
operator|)
name|op
operator|.
name|toRequestRecord
argument_list|()
decl_stmt|;
name|preparedOps
operator|.
name|add
argument_list|(
name|Op
operator|.
name|setData
argument_list|(
name|setData
operator|.
name|getPath
argument_list|()
argument_list|,
name|ZKMetadata
operator|.
name|appendMetaData
argument_list|(
name|id
argument_list|,
name|setData
operator|.
name|getData
argument_list|()
argument_list|)
argument_list|,
name|setData
operator|.
name|getVersion
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Unexpected ZKOp type: "
operator|+
name|op
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
block|}
return|return
name|preparedOps
return|;
block|}
comment|/**    * Run multiple operations in a transactional manner. Retry before throwing exception    */
specifier|public
name|List
argument_list|<
name|OpResult
argument_list|>
name|multi
parameter_list|(
name|Iterable
argument_list|<
name|Op
argument_list|>
name|ops
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
try|try
init|(
name|TraceScope
name|scope
init|=
name|TraceUtil
operator|.
name|createTrace
argument_list|(
literal|"RecoverableZookeeper.multi"
argument_list|)
init|)
block|{
name|RetryCounter
name|retryCounter
init|=
name|retryCounterFactory
operator|.
name|create
argument_list|()
decl_stmt|;
name|Iterable
argument_list|<
name|Op
argument_list|>
name|multiOps
init|=
name|prepareZKMulti
argument_list|(
name|ops
argument_list|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
return|return
name|checkZk
argument_list|()
operator|.
name|multi
argument_list|(
name|multiOps
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|e
operator|.
name|code
argument_list|()
condition|)
block|{
case|case
name|CONNECTIONLOSS
case|:
name|retryOrThrow
argument_list|(
name|retryCounter
argument_list|,
name|e
argument_list|,
literal|"multi"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPERATIONTIMEOUT
case|:
name|retryOrThrow
argument_list|(
name|retryCounter
argument_list|,
name|e
argument_list|,
literal|"multi"
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
name|e
throw|;
block|}
block|}
name|retryCounter
operator|.
name|sleepUntilNextRetry
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|String
name|findPreviousSequentialNode
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
name|int
name|lastSlashIdx
init|=
name|path
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|lastSlashIdx
operator|!=
operator|-
literal|1
operator|)
assert|;
name|String
name|parent
init|=
name|path
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|lastSlashIdx
argument_list|)
decl_stmt|;
name|String
name|nodePrefix
init|=
name|path
operator|.
name|substring
argument_list|(
name|lastSlashIdx
operator|+
literal|1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|nodes
init|=
name|checkZk
argument_list|()
operator|.
name|getChildren
argument_list|(
name|parent
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|matching
init|=
name|filterByPrefix
argument_list|(
name|nodes
argument_list|,
name|nodePrefix
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|node
range|:
name|matching
control|)
block|{
name|String
name|nodePath
init|=
name|parent
operator|+
literal|"/"
operator|+
name|node
decl_stmt|;
name|Stat
name|stat
init|=
name|checkZk
argument_list|()
operator|.
name|exists
argument_list|(
name|nodePath
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|stat
operator|!=
literal|null
condition|)
block|{
return|return
name|nodePath
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|public
specifier|synchronized
name|long
name|getSessionId
parameter_list|()
block|{
return|return
name|zk
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|zk
operator|.
name|getSessionId
argument_list|()
return|;
block|}
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|InterruptedException
block|{
if|if
condition|(
name|zk
operator|!=
literal|null
condition|)
block|{
name|zk
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
specifier|synchronized
name|States
name|getState
parameter_list|()
block|{
return|return
name|zk
operator|==
literal|null
condition|?
literal|null
else|:
name|zk
operator|.
name|getState
argument_list|()
return|;
block|}
specifier|public
specifier|synchronized
name|ZooKeeper
name|getZooKeeper
parameter_list|()
block|{
return|return
name|zk
return|;
block|}
specifier|public
name|void
name|sync
parameter_list|(
name|String
name|path
parameter_list|,
name|AsyncCallback
operator|.
name|VoidCallback
name|cb
parameter_list|,
name|Object
name|ctx
parameter_list|)
throws|throws
name|KeeperException
block|{
name|checkZk
argument_list|()
operator|.
name|sync
argument_list|(
name|path
argument_list|,
name|cb
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Filters the given node list by the given prefixes.    * This method is all-inclusive--if any element in the node list starts    * with any of the given prefixes, then it is included in the result.    *    * @param nodes the nodes to filter    * @param prefixes the prefixes to include in the result    * @return list of every element that starts with one of the prefixes    */
specifier|private
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|filterByPrefix
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|nodes
parameter_list|,
name|String
modifier|...
name|prefixes
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|lockChildren
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|child
range|:
name|nodes
control|)
block|{
for|for
control|(
name|String
name|prefix
range|:
name|prefixes
control|)
block|{
if|if
condition|(
name|child
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
condition|)
block|{
name|lockChildren
operator|.
name|add
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|lockChildren
return|;
block|}
specifier|public
name|String
name|getIdentifier
parameter_list|()
block|{
return|return
name|identifier
return|;
block|}
block|}
end_class

end_unit

