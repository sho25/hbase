begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Abortable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|AuthUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ZooKeeperConnectionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|Superusers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|WatchedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|Watcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|ZooDefs
operator|.
name|Ids
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|ZooDefs
operator|.
name|Perms
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|ACL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|Id
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|Stat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Acts as the single ZooKeeper Watcher.  One instance of this is instantiated  * for each Master, RegionServer, and client process.  *  *<p>This is the only class that implements {@link Watcher}.  Other internal  * classes which need to be notified of ZooKeeper events must register with  * the local instance of this watcher via {@link #registerListener}.  *  *<p>This class also holds and manages the connection to ZooKeeper.  Code to  * deal with connection related events and exceptions are handled here.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|ZKWatcher
implements|implements
name|Watcher
implements|,
name|Abortable
implements|,
name|Closeable
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ZKWatcher
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Identifier for this watcher (for logging only).  It is made of the prefix
comment|// passed on construction and the zookeeper sessionid.
specifier|private
name|String
name|prefix
decl_stmt|;
specifier|private
name|String
name|identifier
decl_stmt|;
comment|// zookeeper quorum
specifier|private
name|String
name|quorum
decl_stmt|;
comment|// zookeeper connection
specifier|private
specifier|final
name|RecoverableZooKeeper
name|recoverableZooKeeper
decl_stmt|;
comment|// abortable in case of zk failure
specifier|protected
name|Abortable
name|abortable
decl_stmt|;
comment|// Used if abortable is null
specifier|private
name|boolean
name|aborted
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
name|ZNodePaths
name|znodePaths
decl_stmt|;
comment|// listeners to be notified
specifier|private
specifier|final
name|List
argument_list|<
name|ZKListener
argument_list|>
name|listeners
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Used by ZKUtil:waitForZKConnectionIfAuthenticating to wait for SASL
comment|// negotiation to complete
specifier|private
name|CountDownLatch
name|saslLatch
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
comment|/* A pattern that matches a Kerberos name, borrowed from Hadoop's KerberosName */
specifier|private
specifier|static
specifier|final
name|Pattern
name|NAME_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"([^/@]*)(/([^/@]*))?@([^/@]*)"
argument_list|)
decl_stmt|;
comment|/**    * Instantiate a ZooKeeper connection and watcher.    * @param identifier string that is passed to RecoverableZookeeper to be used as    *                   identifier for this instance. Use null for default.    * @throws IOException if the connection to ZooKeeper fails    * @throws ZooKeeperConnectionException if the client can't connect to ZooKeeper    */
specifier|public
name|ZKWatcher
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|identifier
parameter_list|,
name|Abortable
name|abortable
parameter_list|)
throws|throws
name|ZooKeeperConnectionException
throws|,
name|IOException
block|{
name|this
argument_list|(
name|conf
argument_list|,
name|identifier
argument_list|,
name|abortable
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Instantiate a ZooKeeper connection and watcher.    * @param conf the configuration to use    * @param identifier string that is passed to RecoverableZookeeper to be used as identifier for    *          this instance. Use null for default.    * @param abortable Can be null if there is on error there is no host to abort: e.g. client    *          context.    * @param canCreateBaseZNode true if a base ZNode can be created    * @throws IOException if the connection to ZooKeeper fails    * @throws ZooKeeperConnectionException if the client can't connect to ZooKeeper    */
specifier|public
name|ZKWatcher
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|identifier
parameter_list|,
name|Abortable
name|abortable
parameter_list|,
name|boolean
name|canCreateBaseZNode
parameter_list|)
throws|throws
name|IOException
throws|,
name|ZooKeeperConnectionException
block|{
name|this
argument_list|(
name|conf
argument_list|,
name|identifier
argument_list|,
name|abortable
argument_list|,
name|canCreateBaseZNode
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Instantiate a ZooKeeper connection and watcher.    * @param conf the configuration to use    * @param identifier string that is passed to RecoverableZookeeper to be used as identifier for    *          this instance. Use null for default.    * @param abortable Can be null if there is on error there is no host to abort: e.g. client    *          context.    * @param canCreateBaseZNode true if a base ZNode can be created    * @param clientZK whether this watcher is set to access client ZK    * @throws IOException if the connection to ZooKeeper fails    * @throws ZooKeeperConnectionException if the connection to Zookeeper fails when create base    *           ZNodes    */
specifier|public
name|ZKWatcher
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|identifier
parameter_list|,
name|Abortable
name|abortable
parameter_list|,
name|boolean
name|canCreateBaseZNode
parameter_list|,
name|boolean
name|clientZK
parameter_list|)
throws|throws
name|IOException
throws|,
name|ZooKeeperConnectionException
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
if|if
condition|(
name|clientZK
condition|)
block|{
name|String
name|clientZkQuorumServers
init|=
name|ZKConfig
operator|.
name|getClientZKQuorumServersString
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|String
name|serverZkQuorumServers
init|=
name|ZKConfig
operator|.
name|getZKQuorumServersString
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|clientZkQuorumServers
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|clientZkQuorumServers
operator|.
name|equals
argument_list|(
name|serverZkQuorumServers
argument_list|)
condition|)
block|{
comment|// Don't allow same settings to avoid dead loop when master trying
comment|// to sync meta information from server ZK to client ZK
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The quorum settings for client ZK should be different from those for server"
argument_list|)
throw|;
block|}
name|this
operator|.
name|quorum
operator|=
name|clientZkQuorumServers
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|quorum
operator|=
name|serverZkQuorumServers
expr_stmt|;
block|}
block|}
else|else
block|{
name|this
operator|.
name|quorum
operator|=
name|ZKConfig
operator|.
name|getZKQuorumServersString
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|prefix
operator|=
name|identifier
expr_stmt|;
comment|// Identifier will get the sessionid appended later below down when we
comment|// handle the syncconnect event.
name|this
operator|.
name|identifier
operator|=
name|identifier
operator|+
literal|"0x0"
expr_stmt|;
name|this
operator|.
name|abortable
operator|=
name|abortable
expr_stmt|;
name|this
operator|.
name|znodePaths
operator|=
operator|new
name|ZNodePaths
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|PendingWatcher
name|pendingWatcher
init|=
operator|new
name|PendingWatcher
argument_list|()
decl_stmt|;
name|this
operator|.
name|recoverableZooKeeper
operator|=
name|ZKUtil
operator|.
name|connect
argument_list|(
name|conf
argument_list|,
name|quorum
argument_list|,
name|pendingWatcher
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
name|pendingWatcher
operator|.
name|prepare
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|canCreateBaseZNode
condition|)
block|{
try|try
block|{
name|createBaseZNodes
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ZooKeeperConnectionException
name|zce
parameter_list|)
block|{
try|try
block|{
name|this
operator|.
name|recoverableZooKeeper
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Encountered InterruptedException when closing "
operator|+
name|this
operator|.
name|recoverableZooKeeper
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
throw|throw
name|zce
throw|;
block|}
block|}
block|}
specifier|private
name|void
name|createBaseZNodes
parameter_list|()
throws|throws
name|ZooKeeperConnectionException
block|{
try|try
block|{
comment|// Create all the necessary "directories" of znodes
name|ZKUtil
operator|.
name|createWithParents
argument_list|(
name|this
argument_list|,
name|znodePaths
operator|.
name|baseZNode
argument_list|)
expr_stmt|;
name|ZKUtil
operator|.
name|createAndFailSilent
argument_list|(
name|this
argument_list|,
name|znodePaths
operator|.
name|rsZNode
argument_list|)
expr_stmt|;
name|ZKUtil
operator|.
name|createAndFailSilent
argument_list|(
name|this
argument_list|,
name|znodePaths
operator|.
name|drainingZNode
argument_list|)
expr_stmt|;
name|ZKUtil
operator|.
name|createAndFailSilent
argument_list|(
name|this
argument_list|,
name|znodePaths
operator|.
name|tableZNode
argument_list|)
expr_stmt|;
name|ZKUtil
operator|.
name|createAndFailSilent
argument_list|(
name|this
argument_list|,
name|znodePaths
operator|.
name|splitLogZNode
argument_list|)
expr_stmt|;
name|ZKUtil
operator|.
name|createAndFailSilent
argument_list|(
name|this
argument_list|,
name|znodePaths
operator|.
name|backupMasterAddressesZNode
argument_list|)
expr_stmt|;
name|ZKUtil
operator|.
name|createAndFailSilent
argument_list|(
name|this
argument_list|,
name|znodePaths
operator|.
name|tableLockZNode
argument_list|)
expr_stmt|;
name|ZKUtil
operator|.
name|createAndFailSilent
argument_list|(
name|this
argument_list|,
name|znodePaths
operator|.
name|masterMaintZNode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ZooKeeperConnectionException
argument_list|(
name|prefix
argument_list|(
literal|"Unexpected KeeperException creating base node"
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * On master start, we check the znode ACLs under the root directory and set the ACLs properly    * if needed. If the cluster goes from an unsecure setup to a secure setup, this step is needed    * so that the existing znodes created with open permissions are now changed with restrictive    * perms.    */
specifier|public
name|void
name|checkAndSetZNodeAcls
parameter_list|()
block|{
if|if
condition|(
operator|!
name|ZKUtil
operator|.
name|isSecureZooKeeper
argument_list|(
name|getConfiguration
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"not a secure deployment, proceeding"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Check the base znodes permission first. Only do the recursion if base znode's perms are not
comment|// correct.
try|try
block|{
name|List
argument_list|<
name|ACL
argument_list|>
name|actualAcls
init|=
name|recoverableZooKeeper
operator|.
name|getAcl
argument_list|(
name|znodePaths
operator|.
name|baseZNode
argument_list|,
operator|new
name|Stat
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isBaseZnodeAclSetup
argument_list|(
name|actualAcls
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"setting znode ACLs"
argument_list|)
expr_stmt|;
name|setZnodeAclsRecursive
argument_list|(
name|znodePaths
operator|.
name|baseZNode
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|nne
parameter_list|)
block|{
return|return;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|interruptedExceptionNoThrow
argument_list|(
name|ie
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received exception while checking and setting zookeeper ACLs"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Set the znode perms recursively. This will do post-order recursion, so that baseZnode ACLs    * will be set last in case the master fails in between.    * @param znode the ZNode to set the permissions for    */
specifier|private
name|void
name|setZnodeAclsRecursive
parameter_list|(
name|String
name|znode
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|children
init|=
name|recoverableZooKeeper
operator|.
name|getChildren
argument_list|(
name|znode
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|child
range|:
name|children
control|)
block|{
name|setZnodeAclsRecursive
argument_list|(
name|ZNodePaths
operator|.
name|joinZNode
argument_list|(
name|znode
argument_list|,
name|child
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|ACL
argument_list|>
name|acls
init|=
name|ZKUtil
operator|.
name|createACL
argument_list|(
name|this
argument_list|,
name|znode
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Setting ACLs for znode:"
operator|+
name|znode
operator|+
literal|" , acl:"
operator|+
name|acls
argument_list|)
expr_stmt|;
name|recoverableZooKeeper
operator|.
name|setAcl
argument_list|(
name|znode
argument_list|,
name|acls
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**    * Checks whether the ACLs returned from the base znode (/hbase) is set for secure setup.    * @param acls acls from zookeeper    * @return whether ACLs are set for the base znode    * @throws IOException if getting the current user fails    */
specifier|private
name|boolean
name|isBaseZnodeAclSetup
parameter_list|(
name|List
argument_list|<
name|ACL
argument_list|>
name|acls
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Checking znode ACLs"
argument_list|)
expr_stmt|;
block|}
name|String
index|[]
name|superUsers
init|=
name|conf
operator|.
name|getStrings
argument_list|(
name|Superusers
operator|.
name|SUPERUSER_CONF_KEY
argument_list|)
decl_stmt|;
comment|// Check whether ACL set for all superusers
if|if
condition|(
name|superUsers
operator|!=
literal|null
operator|&&
operator|!
name|checkACLForSuperUsers
argument_list|(
name|superUsers
argument_list|,
name|acls
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// this assumes that current authenticated user is the same as zookeeper client user
comment|// configured via JAAS
name|String
name|hbaseUser
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
decl_stmt|;
if|if
condition|(
name|acls
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"ACL is empty"
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
for|for
control|(
name|ACL
name|acl
range|:
name|acls
control|)
block|{
name|int
name|perms
init|=
name|acl
operator|.
name|getPerms
argument_list|()
decl_stmt|;
name|Id
name|id
init|=
name|acl
operator|.
name|getId
argument_list|()
decl_stmt|;
comment|// We should only set at most 3 possible ACLs for 3 Ids. One for everyone, one for superuser
comment|// and one for the hbase user
if|if
condition|(
name|Ids
operator|.
name|ANYONE_ID_UNSAFE
operator|.
name|equals
argument_list|(
name|id
argument_list|)
condition|)
block|{
if|if
condition|(
name|perms
operator|!=
name|Perms
operator|.
name|READ
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"permissions for '%s' are not correct: have 0x%x, want 0x%x"
argument_list|,
name|id
argument_list|,
name|perms
argument_list|,
name|Perms
operator|.
name|READ
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|superUsers
operator|!=
literal|null
operator|&&
name|isSuperUserId
argument_list|(
name|superUsers
argument_list|,
name|id
argument_list|)
condition|)
block|{
if|if
condition|(
name|perms
operator|!=
name|Perms
operator|.
name|ALL
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"permissions for '%s' are not correct: have 0x%x, want 0x%x"
argument_list|,
name|id
argument_list|,
name|perms
argument_list|,
name|Perms
operator|.
name|ALL
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"sasl"
operator|.
name|equals
argument_list|(
name|id
operator|.
name|getScheme
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|name
init|=
name|id
operator|.
name|getId
argument_list|()
decl_stmt|;
comment|// If ZooKeeper recorded the Kerberos full name in the ACL, use only the shortname
name|Matcher
name|match
init|=
name|NAME_PATTERN
operator|.
name|matcher
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|match
operator|.
name|matches
argument_list|()
condition|)
block|{
name|name
operator|=
name|match
operator|.
name|group
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
name|hbaseUser
argument_list|)
condition|)
block|{
if|if
condition|(
name|perms
operator|!=
name|Perms
operator|.
name|ALL
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"permissions for '%s' are not correct: have 0x%x, want 0x%x"
argument_list|,
name|id
argument_list|,
name|perms
argument_list|,
name|Perms
operator|.
name|ALL
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unexpected shortname in SASL ACL: "
operator|+
name|id
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"unexpected ACL id '"
operator|+
name|id
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/*    * Validate whether ACL set for all superusers.    */
specifier|private
name|boolean
name|checkACLForSuperUsers
parameter_list|(
name|String
index|[]
name|superUsers
parameter_list|,
name|List
argument_list|<
name|ACL
argument_list|>
name|acls
parameter_list|)
block|{
for|for
control|(
name|String
name|user
range|:
name|superUsers
control|)
block|{
name|boolean
name|hasAccess
init|=
literal|false
decl_stmt|;
comment|// TODO: Validate super group members also when ZK supports setting node ACL for groups.
if|if
condition|(
operator|!
name|AuthUtil
operator|.
name|isGroupPrincipal
argument_list|(
name|user
argument_list|)
condition|)
block|{
for|for
control|(
name|ACL
name|acl
range|:
name|acls
control|)
block|{
if|if
condition|(
name|user
operator|.
name|equals
argument_list|(
name|acl
operator|.
name|getId
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|acl
operator|.
name|getPerms
argument_list|()
operator|==
name|Perms
operator|.
name|ALL
condition|)
block|{
name|hasAccess
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"superuser '%s' does not have correct permissions: have 0x%x, want 0x%x"
argument_list|,
name|acl
operator|.
name|getId
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|acl
operator|.
name|getPerms
argument_list|()
argument_list|,
name|Perms
operator|.
name|ALL
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|hasAccess
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/*    * Validate whether ACL ID is superuser.    */
specifier|public
specifier|static
name|boolean
name|isSuperUserId
parameter_list|(
name|String
index|[]
name|superUsers
parameter_list|,
name|Id
name|id
parameter_list|)
block|{
for|for
control|(
name|String
name|user
range|:
name|superUsers
control|)
block|{
comment|// TODO: Validate super group members also when ZK supports setting node ACL for groups.
if|if
condition|(
operator|!
name|AuthUtil
operator|.
name|isGroupPrincipal
argument_list|(
name|user
argument_list|)
operator|&&
operator|new
name|Id
argument_list|(
literal|"sasl"
argument_list|,
name|user
argument_list|)
operator|.
name|equals
argument_list|(
name|id
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|this
operator|.
name|identifier
operator|+
literal|", quorum="
operator|+
name|quorum
operator|+
literal|", baseZNode="
operator|+
name|znodePaths
operator|.
name|baseZNode
return|;
block|}
comment|/**    * Adds this instance's identifier as a prefix to the passed<code>str</code>    * @param str String to amend.    * @return A new string with this instance's identifier as prefix: e.g.    *         if passed 'hello world', the returned string could be    */
specifier|public
name|String
name|prefix
parameter_list|(
specifier|final
name|String
name|str
parameter_list|)
block|{
return|return
name|this
operator|.
name|toString
argument_list|()
operator|+
literal|" "
operator|+
name|str
return|;
block|}
comment|/**    * Get the znodes corresponding to the meta replicas from ZK    * @return list of znodes    * @throws KeeperException if a ZooKeeper operation fails    */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getMetaReplicaNodes
parameter_list|()
throws|throws
name|KeeperException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|childrenOfBaseNode
init|=
name|ZKUtil
operator|.
name|listChildrenNoWatch
argument_list|(
name|this
argument_list|,
name|znodePaths
operator|.
name|baseZNode
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|metaReplicaNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|childrenOfBaseNode
operator|!=
literal|null
condition|)
block|{
name|String
name|pattern
init|=
name|conf
operator|.
name|get
argument_list|(
literal|"zookeeper.znode.metaserver"
argument_list|,
literal|"meta-region-server"
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|child
range|:
name|childrenOfBaseNode
control|)
block|{
if|if
condition|(
name|child
operator|.
name|startsWith
argument_list|(
name|pattern
argument_list|)
condition|)
block|{
name|metaReplicaNodes
operator|.
name|add
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|metaReplicaNodes
return|;
block|}
comment|/**    * Register the specified listener to receive ZooKeeper events.    * @param listener the listener to register    */
specifier|public
name|void
name|registerListener
parameter_list|(
name|ZKListener
name|listener
parameter_list|)
block|{
name|listeners
operator|.
name|add
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
comment|/**    * Register the specified listener to receive ZooKeeper events and add it as    * the first in the list of current listeners.    * @param listener the listener to register    */
specifier|public
name|void
name|registerListenerFirst
parameter_list|(
name|ZKListener
name|listener
parameter_list|)
block|{
name|listeners
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|listener
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|unregisterListener
parameter_list|(
name|ZKListener
name|listener
parameter_list|)
block|{
name|listeners
operator|.
name|remove
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
comment|/**    * Clean all existing listeners    */
specifier|public
name|void
name|unregisterAllListeners
parameter_list|()
block|{
name|listeners
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * Get a copy of current registered listeners    */
specifier|public
name|List
argument_list|<
name|ZKListener
argument_list|>
name|getListeners
parameter_list|()
block|{
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|listeners
argument_list|)
return|;
block|}
comment|/**    * @return The number of currently registered listeners    */
specifier|public
name|int
name|getNumberOfListeners
parameter_list|()
block|{
return|return
name|listeners
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * Get the connection to ZooKeeper.    * @return connection reference to zookeeper    */
specifier|public
name|RecoverableZooKeeper
name|getRecoverableZooKeeper
parameter_list|()
block|{
return|return
name|recoverableZooKeeper
return|;
block|}
specifier|public
name|void
name|reconnectAfterExpiration
parameter_list|()
throws|throws
name|IOException
throws|,
name|KeeperException
throws|,
name|InterruptedException
block|{
name|recoverableZooKeeper
operator|.
name|reconnectAfterExpiration
argument_list|()
expr_stmt|;
block|}
comment|/**    * Get the quorum address of this instance.    * @return quorum string of this zookeeper connection instance    */
specifier|public
name|String
name|getQuorum
parameter_list|()
block|{
return|return
name|quorum
return|;
block|}
comment|/**    * Get the znodePaths.    *<p>    * Mainly used for mocking as mockito can not mock a field access.    */
specifier|public
name|ZNodePaths
name|getZNodePaths
parameter_list|()
block|{
return|return
name|znodePaths
return|;
block|}
comment|/**    * Method called from ZooKeeper for events and connection status.    *<p>    * Valid events are passed along to listeners.  Connection status changes    * are dealt with locally.    */
annotation|@
name|Override
specifier|public
name|void
name|process
parameter_list|(
name|WatchedEvent
name|event
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|prefix
argument_list|(
literal|"Received ZooKeeper Event, "
operator|+
literal|"type="
operator|+
name|event
operator|.
name|getType
argument_list|()
operator|+
literal|", "
operator|+
literal|"state="
operator|+
name|event
operator|.
name|getState
argument_list|()
operator|+
literal|", "
operator|+
literal|"path="
operator|+
name|event
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|.
name|getType
argument_list|()
condition|)
block|{
comment|// If event type is NONE, this is a connection status change
case|case
name|None
case|:
block|{
name|connectionEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// Otherwise pass along to the listeners
case|case
name|NodeCreated
case|:
block|{
for|for
control|(
name|ZKListener
name|listener
range|:
name|listeners
control|)
block|{
name|listener
operator|.
name|nodeCreated
argument_list|(
name|event
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|NodeDeleted
case|:
block|{
for|for
control|(
name|ZKListener
name|listener
range|:
name|listeners
control|)
block|{
name|listener
operator|.
name|nodeDeleted
argument_list|(
name|event
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|NodeDataChanged
case|:
block|{
for|for
control|(
name|ZKListener
name|listener
range|:
name|listeners
control|)
block|{
name|listener
operator|.
name|nodeDataChanged
argument_list|(
name|event
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|NodeChildrenChanged
case|:
block|{
for|for
control|(
name|ZKListener
name|listener
range|:
name|listeners
control|)
block|{
name|listener
operator|.
name|nodeChildrenChanged
argument_list|(
name|event
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Received event is not valid: "
operator|+
name|event
operator|.
name|getState
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|// Connection management
comment|/**    * Called when there is a connection-related event via the Watcher callback.    *<p>    * If Disconnected or Expired, this should shutdown the cluster. But, since    * we send a KeeperException.SessionExpiredException along with the abort    * call, it's possible for the Abortable to catch it and try to create a new    * session with ZooKeeper. This is what the client does in HCM.    *<p>    * @param event the connection-related event    */
specifier|private
name|void
name|connectionEvent
parameter_list|(
name|WatchedEvent
name|event
parameter_list|)
block|{
switch|switch
condition|(
name|event
operator|.
name|getState
argument_list|()
condition|)
block|{
case|case
name|SyncConnected
case|:
name|this
operator|.
name|identifier
operator|=
name|this
operator|.
name|prefix
operator|+
literal|"-0x"
operator|+
name|Long
operator|.
name|toHexString
argument_list|(
name|this
operator|.
name|recoverableZooKeeper
operator|.
name|getSessionId
argument_list|()
argument_list|)
expr_stmt|;
comment|// Update our identifier.  Otherwise ignore.
name|LOG
operator|.
name|debug
argument_list|(
name|this
operator|.
name|identifier
operator|+
literal|" connected"
argument_list|)
expr_stmt|;
break|break;
comment|// Abort the server if Disconnected or Expired
case|case
name|Disconnected
case|:
name|LOG
operator|.
name|debug
argument_list|(
name|prefix
argument_list|(
literal|"Received Disconnected from ZooKeeper, ignoring"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Expired
case|:
name|String
name|msg
init|=
name|prefix
argument_list|(
name|this
operator|.
name|identifier
operator|+
literal|" received expired from "
operator|+
literal|"ZooKeeper, aborting"
argument_list|)
decl_stmt|;
comment|// TODO: One thought is to add call to ZKListener so say,
comment|// ZKNodeTracker can zero out its data values.
if|if
condition|(
name|this
operator|.
name|abortable
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|abortable
operator|.
name|abort
argument_list|(
name|msg
argument_list|,
operator|new
name|KeeperException
operator|.
name|SessionExpiredException
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ConnectedReadOnly
case|:
case|case
name|SaslAuthenticated
case|:
case|case
name|AuthFailed
case|:
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Received event is not valid: "
operator|+
name|event
operator|.
name|getState
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * Forces a synchronization of this ZooKeeper client connection.    *<p>    * Executing this method before running other methods will ensure that the    * subsequent operations are up-to-date and consistent as of the time that    * the sync is complete.    *<p>    * This is used for compareAndSwap type operations where we need to read the    * data of an existing node and delete or transition that node, utilizing the    * previously read version and data.  We want to ensure that the version read    * is up-to-date from when we begin the operation.    */
specifier|public
name|void
name|sync
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|KeeperException
block|{
name|this
operator|.
name|recoverableZooKeeper
operator|.
name|sync
argument_list|(
name|path
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Handles KeeperExceptions in client calls.    *<p>    * This may be temporary but for now this gives one place to deal with these.    *<p>    * TODO: Currently this method rethrows the exception to let the caller handle    *<p>    * @param ke the exception to rethrow    * @throws KeeperException if a ZooKeeper operation fails    */
specifier|public
name|void
name|keeperException
parameter_list|(
name|KeeperException
name|ke
parameter_list|)
throws|throws
name|KeeperException
block|{
name|LOG
operator|.
name|error
argument_list|(
name|prefix
argument_list|(
literal|"Received unexpected KeeperException, re-throwing exception"
argument_list|)
argument_list|,
name|ke
argument_list|)
expr_stmt|;
throw|throw
name|ke
throw|;
block|}
comment|/**    * Handles InterruptedExceptions in client calls.    * @param ie the InterruptedException instance thrown    * @throws KeeperException the exception to throw, transformed from the InterruptedException    */
specifier|public
name|void
name|interruptedException
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
throws|throws
name|KeeperException
block|{
name|interruptedExceptionNoThrow
argument_list|(
name|ie
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Throw a system error exception to let upper level handle it
name|KeeperException
name|keeperException
init|=
operator|new
name|KeeperException
operator|.
name|SystemErrorException
argument_list|()
decl_stmt|;
name|keeperException
operator|.
name|initCause
argument_list|(
name|ie
argument_list|)
expr_stmt|;
throw|throw
name|keeperException
throw|;
block|}
comment|/**    * Log the InterruptedException and interrupt current thread    * @param ie The IterruptedException to log    * @param throwLater Whether we will throw the exception latter    */
specifier|public
name|void
name|interruptedExceptionNoThrow
parameter_list|(
name|InterruptedException
name|ie
parameter_list|,
name|boolean
name|throwLater
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|prefix
argument_list|(
literal|"Received InterruptedException, will interrupt current thread"
operator|+
operator|(
name|throwLater
condition|?
literal|" and rethrow a SystemErrorException"
else|:
literal|""
operator|)
argument_list|)
argument_list|,
name|ie
argument_list|)
expr_stmt|;
comment|// At least preserve interrupt.
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
comment|/**    * Close the connection to ZooKeeper.    *    */
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{
try|try
block|{
name|recoverableZooKeeper
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|Configuration
name|getConfiguration
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|abort
parameter_list|(
name|String
name|why
parameter_list|,
name|Throwable
name|e
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|abortable
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|abortable
operator|.
name|abort
argument_list|(
name|why
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|aborted
operator|=
literal|true
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isAborted
parameter_list|()
block|{
return|return
name|this
operator|.
name|abortable
operator|==
literal|null
condition|?
name|this
operator|.
name|aborted
else|:
name|this
operator|.
name|abortable
operator|.
name|isAborted
argument_list|()
return|;
block|}
block|}
end_class

end_unit

