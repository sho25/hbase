begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2010 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Chore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HMsg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerAddress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerLoad
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Leases
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Leases
operator|.
name|LeaseStillHeldException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Get
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HRegionInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|RegionManager
operator|.
name|RegionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|WatchedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|Watcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|Watcher
operator|.
name|Event
operator|.
name|EventType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_comment
comment|/**  * The ServerManager class manages info about region servers - HServerInfo,  * load numbers, dying servers, etc.  */
end_comment

begin_class
specifier|public
class|class
name|ServerManager
implements|implements
name|HConstants
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ServerManager
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|AtomicInteger
name|quiescedServers
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// The map of known server names to server info
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|HServerInfo
argument_list|>
name|serversToServerInfo
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|HServerInfo
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|HServerAddress
argument_list|,
name|HServerInfo
argument_list|>
name|serverAddressToServerInfo
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|HServerAddress
argument_list|,
name|HServerInfo
argument_list|>
argument_list|()
decl_stmt|;
comment|/*    * Set of known dead servers.  On znode expiration, servers are added here.    * This is needed in case of a network partitioning where the server's lease    * expires, but the server is still running. After the network is healed,    * and it's server logs are recovered, it will be told to call server startup    * because by then, its regions have probably been reassigned.    */
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|deadServers
init|=
name|Collections
operator|.
name|synchronizedSet
argument_list|(
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|// SortedMap server load -> Set of server names
specifier|private
specifier|final
name|SortedMap
argument_list|<
name|HServerLoad
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|loadToServers
init|=
name|Collections
operator|.
name|synchronizedSortedMap
argument_list|(
operator|new
name|TreeMap
argument_list|<
name|HServerLoad
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|// Map of server names -> server load
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|HServerLoad
argument_list|>
name|serversToLoad
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|HServerLoad
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|HMaster
name|master
decl_stmt|;
comment|/* The regionserver will not be assigned or asked close regions if it    * is currently opening>= this many regions.    */
specifier|private
specifier|final
name|int
name|nobalancingCount
decl_stmt|;
specifier|private
specifier|final
name|ServerMonitor
name|serverMonitorThread
decl_stmt|;
specifier|private
name|int
name|minimumServerCount
decl_stmt|;
specifier|private
specifier|final
name|OldLogsCleaner
name|oldLogCleaner
decl_stmt|;
comment|/*    * Dumps into log current stats on dead servers and number of servers    * TODO: Make this a metric; dump metrics into log.    */
class|class
name|ServerMonitor
extends|extends
name|Chore
block|{
name|ServerMonitor
parameter_list|(
specifier|final
name|int
name|period
parameter_list|,
specifier|final
name|AtomicBoolean
name|stop
parameter_list|)
block|{
name|super
argument_list|(
name|period
argument_list|,
name|stop
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|chore
parameter_list|()
block|{
name|int
name|numServers
init|=
name|serverAddressToServerInfo
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|numDeadServers
init|=
name|deadServers
operator|.
name|size
argument_list|()
decl_stmt|;
name|double
name|averageLoad
init|=
name|getAverageLoad
argument_list|()
decl_stmt|;
name|String
name|deadServersList
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|numDeadServers
operator|>
literal|0
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"Dead Server ["
argument_list|)
decl_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
synchronized|synchronized
init|(
name|deadServers
init|)
block|{
for|for
control|(
name|String
name|server
range|:
name|deadServers
control|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|",  "
argument_list|)
expr_stmt|;
name|first
operator|=
literal|false
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|server
argument_list|)
expr_stmt|;
block|}
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
name|deadServersList
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|numServers
operator|+
literal|" region servers, "
operator|+
name|numDeadServers
operator|+
literal|" dead, average load "
operator|+
name|averageLoad
operator|+
operator|(
name|deadServersList
operator|!=
literal|null
condition|?
name|deadServers
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Constructor.    * @param master    */
specifier|public
name|ServerManager
parameter_list|(
name|HMaster
name|master
parameter_list|)
block|{
name|this
operator|.
name|master
operator|=
name|master
expr_stmt|;
name|Configuration
name|c
init|=
name|master
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|this
operator|.
name|nobalancingCount
operator|=
name|c
operator|.
name|getInt
argument_list|(
literal|"hbase.regions.nobalancing.count"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|int
name|metaRescanInterval
init|=
name|c
operator|.
name|getInt
argument_list|(
literal|"hbase.master.meta.thread.rescanfrequency"
argument_list|,
literal|60
operator|*
literal|1000
argument_list|)
decl_stmt|;
name|this
operator|.
name|minimumServerCount
operator|=
name|c
operator|.
name|getInt
argument_list|(
literal|"hbase.regions.server.count.min"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|serverMonitorThread
operator|=
operator|new
name|ServerMonitor
argument_list|(
name|metaRescanInterval
argument_list|,
name|this
operator|.
name|master
operator|.
name|getShutdownRequested
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|n
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|this
operator|.
name|serverMonitorThread
argument_list|,
name|n
operator|+
literal|".serverMonitor"
argument_list|)
expr_stmt|;
name|this
operator|.
name|oldLogCleaner
operator|=
operator|new
name|OldLogsCleaner
argument_list|(
name|c
operator|.
name|getInt
argument_list|(
literal|"hbase.master.meta.thread.rescanfrequency"
argument_list|,
literal|60
operator|*
literal|1000
argument_list|)
argument_list|,
name|this
operator|.
name|master
operator|.
name|getShutdownRequested
argument_list|()
argument_list|,
name|c
argument_list|,
name|master
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|master
operator|.
name|getOldLogDir
argument_list|()
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|oldLogCleaner
argument_list|,
name|n
operator|+
literal|".oldLogCleaner"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Let the server manager know a new regionserver has come online    * @param serverInfo    * @throws IOException    */
name|void
name|regionServerStartup
parameter_list|(
specifier|final
name|HServerInfo
name|serverInfo
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Test for case where we get a region startup message from a regionserver
comment|// that has been quickly restarted but whose znode expiration handler has
comment|// not yet run, or from a server whose fail we are currently processing.
comment|// Test its host+port combo is present in serverAddresstoServerInfo.  If it
comment|// is, reject the server and trigger its expiration. The next time it comes
comment|// in, it should have been removed from serverAddressToServerInfo and queued
comment|// for processing by ProcessServerShutdown.
name|HServerInfo
name|info
init|=
operator|new
name|HServerInfo
argument_list|(
name|serverInfo
argument_list|)
decl_stmt|;
name|String
name|hostAndPort
init|=
name|info
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|HServerInfo
name|existingServer
init|=
name|this
operator|.
name|serverAddressToServerInfo
operator|.
name|get
argument_list|(
name|info
operator|.
name|getServerAddress
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|existingServer
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Server start rejected; we already have "
operator|+
name|hostAndPort
operator|+
literal|" registered; existingServer="
operator|+
name|existingServer
operator|+
literal|", newServer="
operator|+
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|existingServer
operator|.
name|getStartCode
argument_list|()
operator|<
name|info
operator|.
name|getStartCode
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Triggering server recovery; existingServer looks stale"
argument_list|)
expr_stmt|;
name|expireServer
argument_list|(
name|existingServer
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|Leases
operator|.
name|LeaseStillHeldException
argument_list|(
name|hostAndPort
argument_list|)
throw|;
block|}
name|checkIsDead
argument_list|(
name|info
operator|.
name|getServerName
argument_list|()
argument_list|,
literal|"STARTUP"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Received start message from: "
operator|+
name|info
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
name|recordNewServer
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
comment|/*    * If this server is on the dead list, reject it with a LeaseStillHeldException    * @param serverName Server name formatted as host_port_startcode.    * @param what START or REPORT    * @throws LeaseStillHeldException    */
specifier|private
name|void
name|checkIsDead
parameter_list|(
specifier|final
name|String
name|serverName
parameter_list|,
specifier|final
name|String
name|what
parameter_list|)
throws|throws
name|LeaseStillHeldException
block|{
if|if
condition|(
operator|!
name|isDead
argument_list|(
name|serverName
argument_list|)
condition|)
return|return;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Server "
operator|+
name|what
operator|+
literal|" rejected; currently processing "
operator|+
name|serverName
operator|+
literal|" as dead server"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|Leases
operator|.
name|LeaseStillHeldException
argument_list|(
name|serverName
argument_list|)
throw|;
block|}
comment|/**    * Adds the HSI to the RS list and creates an empty load    * @param info The region server informations    */
specifier|public
name|void
name|recordNewServer
parameter_list|(
name|HServerInfo
name|info
parameter_list|)
block|{
name|recordNewServer
argument_list|(
name|info
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Adds the HSI to the RS list    * @param info The region server informations    * @param useInfoLoad True if the load from the info should be used    *                    like under a master failover    */
name|void
name|recordNewServer
parameter_list|(
name|HServerInfo
name|info
parameter_list|,
name|boolean
name|useInfoLoad
parameter_list|)
block|{
name|HServerLoad
name|load
init|=
name|useInfoLoad
condition|?
name|info
operator|.
name|getLoad
argument_list|()
else|:
operator|new
name|HServerLoad
argument_list|()
decl_stmt|;
name|String
name|serverName
init|=
name|info
operator|.
name|getServerName
argument_list|()
decl_stmt|;
name|info
operator|.
name|setLoad
argument_list|(
name|load
argument_list|)
expr_stmt|;
comment|// We must set this watcher here because it can be set on a fresh start
comment|// or on a failover
name|Watcher
name|watcher
init|=
operator|new
name|ServerExpirer
argument_list|(
operator|new
name|HServerInfo
argument_list|(
name|info
argument_list|)
argument_list|)
decl_stmt|;
name|this
operator|.
name|master
operator|.
name|getZooKeeperWrapper
argument_list|()
operator|.
name|updateRSLocationGetWatch
argument_list|(
name|info
argument_list|,
name|watcher
argument_list|)
expr_stmt|;
name|this
operator|.
name|serversToServerInfo
operator|.
name|put
argument_list|(
name|serverName
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|this
operator|.
name|serverAddressToServerInfo
operator|.
name|put
argument_list|(
name|info
operator|.
name|getServerAddress
argument_list|()
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|this
operator|.
name|serversToLoad
operator|.
name|put
argument_list|(
name|serverName
argument_list|,
name|load
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|loadToServers
init|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|servers
init|=
name|this
operator|.
name|loadToServers
operator|.
name|get
argument_list|(
name|load
argument_list|)
decl_stmt|;
if|if
condition|(
name|servers
operator|==
literal|null
condition|)
block|{
name|servers
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|servers
operator|.
name|add
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
name|this
operator|.
name|loadToServers
operator|.
name|put
argument_list|(
name|load
argument_list|,
name|servers
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Called to process the messages sent from the region server to the master    * along with the heart beat.    *    * @param serverInfo    * @param msgs    * @param mostLoadedRegions Array of regions the region server is submitting    * as candidates to be rebalanced, should it be overloaded    * @return messages from master to region server indicating what region    * server should do.    *    * @throws IOException    */
name|HMsg
index|[]
name|regionServerReport
parameter_list|(
specifier|final
name|HServerInfo
name|serverInfo
parameter_list|,
specifier|final
name|HMsg
name|msgs
index|[]
parameter_list|,
specifier|final
name|HRegionInfo
index|[]
name|mostLoadedRegions
parameter_list|)
throws|throws
name|IOException
block|{
name|HServerInfo
name|info
init|=
operator|new
name|HServerInfo
argument_list|(
name|serverInfo
argument_list|)
decl_stmt|;
name|checkIsDead
argument_list|(
name|info
operator|.
name|getServerName
argument_list|()
argument_list|,
literal|"REPORT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgs
operator|.
name|length
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|msgs
index|[
literal|0
index|]
operator|.
name|isType
argument_list|(
name|HMsg
operator|.
name|Type
operator|.
name|MSG_REPORT_EXITING
argument_list|)
condition|)
block|{
name|processRegionServerExit
argument_list|(
name|info
argument_list|,
name|msgs
argument_list|)
expr_stmt|;
return|return
name|HMsg
operator|.
name|EMPTY_HMSG_ARRAY
return|;
block|}
elseif|else
if|if
condition|(
name|msgs
index|[
literal|0
index|]
operator|.
name|isType
argument_list|(
name|HMsg
operator|.
name|Type
operator|.
name|MSG_REPORT_QUIESCED
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Region server "
operator|+
name|info
operator|.
name|getServerName
argument_list|()
operator|+
literal|" quiesced"
argument_list|)
expr_stmt|;
name|this
operator|.
name|quiescedServers
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|this
operator|.
name|master
operator|.
name|getShutdownRequested
argument_list|()
operator|.
name|get
argument_list|()
condition|)
block|{
if|if
condition|(
name|quiescedServers
operator|.
name|get
argument_list|()
operator|>=
name|serversToServerInfo
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// If the only servers we know about are meta servers, then we can
comment|// proceed with shutdown
name|LOG
operator|.
name|info
argument_list|(
literal|"All user tables quiesced. Proceeding with shutdown"
argument_list|)
expr_stmt|;
name|this
operator|.
name|master
operator|.
name|startShutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|this
operator|.
name|master
operator|.
name|isClosed
argument_list|()
condition|)
block|{
if|if
condition|(
name|msgs
operator|.
name|length
operator|>
literal|0
operator|&&
name|msgs
index|[
literal|0
index|]
operator|.
name|isType
argument_list|(
name|HMsg
operator|.
name|Type
operator|.
name|MSG_REPORT_QUIESCED
argument_list|)
condition|)
block|{
comment|// Server is already quiesced, but we aren't ready to shut down
comment|// return empty response
return|return
name|HMsg
operator|.
name|EMPTY_HMSG_ARRAY
return|;
block|}
comment|// Tell the server to stop serving any user regions
return|return
operator|new
name|HMsg
index|[]
block|{
name|HMsg
operator|.
name|REGIONSERVER_QUIESCE
block|}
return|;
block|}
block|}
if|if
condition|(
name|this
operator|.
name|master
operator|.
name|isClosed
argument_list|()
condition|)
block|{
comment|// Tell server to shut down if we are shutting down.  This should
comment|// happen after check of MSG_REPORT_EXITING above, since region server
comment|// will send us one of these messages after it gets MSG_REGIONSERVER_STOP
return|return
operator|new
name|HMsg
index|[]
block|{
name|HMsg
operator|.
name|REGIONSERVER_STOP
block|}
return|;
block|}
name|HServerInfo
name|storedInfo
init|=
name|this
operator|.
name|serversToServerInfo
operator|.
name|get
argument_list|(
name|info
operator|.
name|getServerName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedInfo
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received report from unknown server -- telling it "
operator|+
literal|"to "
operator|+
name|HMsg
operator|.
name|CALL_SERVER_STARTUP
operator|+
literal|": "
operator|+
name|info
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
comment|// The HBaseMaster may have been restarted.
comment|// Tell the RegionServer to start over and call regionServerStartup()
return|return
operator|new
name|HMsg
index|[]
block|{
name|HMsg
operator|.
name|CALL_SERVER_STARTUP
block|}
return|;
block|}
elseif|else
if|if
condition|(
name|storedInfo
operator|.
name|getStartCode
argument_list|()
operator|!=
name|info
operator|.
name|getStartCode
argument_list|()
condition|)
block|{
comment|// This state is reachable if:
comment|//
comment|// 1) RegionServer A started
comment|// 2) RegionServer B started on the same machine, then
comment|//    clobbered A in regionServerStartup.
comment|// 3) RegionServer A returns, expecting to work as usual.
comment|//
comment|// The answer is to ask A to shut down for good.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"region server race condition detected: "
operator|+
name|info
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|this
operator|.
name|serversToServerInfo
init|)
block|{
name|removeServerInfo
argument_list|(
name|info
operator|.
name|getServerName
argument_list|()
argument_list|,
name|info
operator|.
name|getServerAddress
argument_list|()
argument_list|)
expr_stmt|;
name|notifyServers
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|HMsg
index|[]
block|{
name|HMsg
operator|.
name|REGIONSERVER_STOP
block|}
return|;
block|}
else|else
block|{
return|return
name|processRegionServerAllsWell
argument_list|(
name|info
argument_list|,
name|mostLoadedRegions
argument_list|,
name|msgs
argument_list|)
return|;
block|}
block|}
comment|/*    * Region server is exiting with a clean shutdown.    *    * In this case, the server sends MSG_REPORT_EXITING in msgs[0] followed by    * a MSG_REPORT_CLOSE for each region it was serving.    * @param serverInfo    * @param msgs    */
specifier|private
name|void
name|processRegionServerExit
parameter_list|(
name|HServerInfo
name|serverInfo
parameter_list|,
name|HMsg
index|[]
name|msgs
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|serversToServerInfo
init|)
block|{
comment|// This method removes ROOT/META from the list and marks them to be
comment|// reassigned in addition to other housework.
if|if
condition|(
name|removeServerInfo
argument_list|(
name|serverInfo
operator|.
name|getServerName
argument_list|()
argument_list|,
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
argument_list|)
condition|)
block|{
comment|// Only process the exit message if the server still has registered info.
comment|// Otherwise we could end up processing the server exit twice.
name|LOG
operator|.
name|info
argument_list|(
literal|"Region server "
operator|+
name|serverInfo
operator|.
name|getServerName
argument_list|()
operator|+
literal|": MSG_REPORT_EXITING"
argument_list|)
expr_stmt|;
comment|// Get all the regions the server was serving reassigned
comment|// (if we are not shutting down).
if|if
condition|(
operator|!
name|master
operator|.
name|closed
operator|.
name|get
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|msgs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing "
operator|+
name|msgs
index|[
name|i
index|]
operator|+
literal|" from "
operator|+
name|serverInfo
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
assert|assert
name|msgs
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
operator|==
name|HMsg
operator|.
name|Type
operator|.
name|MSG_REGION_CLOSE
assert|;
name|HRegionInfo
name|info
init|=
name|msgs
index|[
name|i
index|]
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
comment|// Meta/root region offlining is handed in removeServerInfo above.
if|if
condition|(
operator|!
name|info
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
synchronized|synchronized
init|(
name|master
operator|.
name|getRegionManager
argument_list|()
init|)
block|{
if|if
condition|(
operator|!
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|isOfflined
argument_list|(
name|info
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
condition|)
block|{
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|setUnassigned
argument_list|(
name|info
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|removeRegion
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|// There should not be any regions in transition for this server - the
comment|// server should finish transitions itself before closing
name|Map
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
name|inTransition
init|=
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|getRegionsInTransitionOnServer
argument_list|(
name|serverInfo
operator|.
name|getServerName
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
name|entry
range|:
name|inTransition
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Region server "
operator|+
name|serverInfo
operator|.
name|getServerName
argument_list|()
operator|+
literal|" shut down with region "
operator|+
name|entry
operator|.
name|getKey
argument_list|()
operator|+
literal|" in transition "
operator|+
literal|"state "
operator|+
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|setUnassigned
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/*    *  RegionServer is checking in, no exceptional circumstances    * @param serverInfo    * @param mostLoadedRegions    * @param msgs    * @return    * @throws IOException    */
specifier|private
name|HMsg
index|[]
name|processRegionServerAllsWell
parameter_list|(
name|HServerInfo
name|serverInfo
parameter_list|,
specifier|final
name|HRegionInfo
index|[]
name|mostLoadedRegions
parameter_list|,
name|HMsg
index|[]
name|msgs
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Refresh the info object and the load information
name|this
operator|.
name|serverAddressToServerInfo
operator|.
name|put
argument_list|(
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
argument_list|,
name|serverInfo
argument_list|)
expr_stmt|;
name|this
operator|.
name|serversToServerInfo
operator|.
name|put
argument_list|(
name|serverInfo
operator|.
name|getServerName
argument_list|()
argument_list|,
name|serverInfo
argument_list|)
expr_stmt|;
name|HServerLoad
name|load
init|=
name|this
operator|.
name|serversToLoad
operator|.
name|get
argument_list|(
name|serverInfo
operator|.
name|getServerName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|load
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|master
operator|.
name|getMetrics
argument_list|()
operator|.
name|incrementRequests
argument_list|(
name|load
operator|.
name|getNumberOfRequests
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|load
operator|.
name|equals
argument_list|(
name|serverInfo
operator|.
name|getLoad
argument_list|()
argument_list|)
condition|)
block|{
name|updateLoadToServers
argument_list|(
name|serverInfo
operator|.
name|getServerName
argument_list|()
argument_list|,
name|load
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Set the current load information
name|load
operator|=
name|serverInfo
operator|.
name|getLoad
argument_list|()
expr_stmt|;
name|this
operator|.
name|serversToLoad
operator|.
name|put
argument_list|(
name|serverInfo
operator|.
name|getServerName
argument_list|()
argument_list|,
name|load
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|loadToServers
init|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|servers
init|=
name|this
operator|.
name|loadToServers
operator|.
name|get
argument_list|(
name|load
argument_list|)
decl_stmt|;
if|if
condition|(
name|servers
operator|==
literal|null
condition|)
block|{
name|servers
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|servers
operator|.
name|add
argument_list|(
name|serverInfo
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|loadToServers
operator|.
name|put
argument_list|(
name|load
argument_list|,
name|servers
argument_list|)
expr_stmt|;
block|}
comment|// Next, process messages for this server
return|return
name|processMsgs
argument_list|(
name|serverInfo
argument_list|,
name|mostLoadedRegions
argument_list|,
name|msgs
argument_list|)
return|;
block|}
comment|/*    * Process all the incoming messages from a server that's contacted us.    * Note that we never need to update the server's load information because    * that has already been done in regionServerReport.    * @param serverInfo    * @param mostLoadedRegions    * @param incomingMsgs    * @return    */
specifier|private
name|HMsg
index|[]
name|processMsgs
parameter_list|(
name|HServerInfo
name|serverInfo
parameter_list|,
name|HRegionInfo
index|[]
name|mostLoadedRegions
parameter_list|,
name|HMsg
name|incomingMsgs
index|[]
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|HMsg
argument_list|>
name|returnMsgs
init|=
operator|new
name|ArrayList
argument_list|<
name|HMsg
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Server address cannot be null; "
operator|+
literal|"hbase-958 debugging"
argument_list|)
throw|;
block|}
comment|// Get reports on what the RegionServer did.
comment|// Be careful that in message processors we don't throw exceptions that
comment|// break the switch below because then we might drop messages on the floor.
name|int
name|openingCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|incomingMsgs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|HRegionInfo
name|region
init|=
name|incomingMsgs
index|[
name|i
index|]
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing "
operator|+
name|incomingMsgs
index|[
name|i
index|]
operator|+
literal|" from "
operator|+
name|serverInfo
operator|.
name|getServerName
argument_list|()
operator|+
literal|"; "
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|+
literal|" of "
operator|+
name|incomingMsgs
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|this
operator|.
name|master
operator|.
name|getRegionServerOperationQueue
argument_list|()
operator|.
name|process
argument_list|(
name|serverInfo
argument_list|,
name|incomingMsgs
index|[
name|i
index|]
argument_list|)
condition|)
block|{
continue|continue;
block|}
switch|switch
condition|(
name|incomingMsgs
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|MSG_REPORT_PROCESS_OPEN
case|:
name|openingCount
operator|++
expr_stmt|;
break|break;
case|case
name|MSG_REPORT_OPEN
case|:
name|processRegionOpen
argument_list|(
name|serverInfo
argument_list|,
name|region
argument_list|,
name|returnMsgs
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_REPORT_CLOSE
case|:
name|processRegionClose
argument_list|(
name|region
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_REPORT_SPLIT
case|:
name|processSplitRegion
argument_list|(
name|region
argument_list|,
name|incomingMsgs
index|[
operator|++
name|i
index|]
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|incomingMsgs
index|[
operator|++
name|i
index|]
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_REPORT_SPLIT_INCLUDES_DAUGHTERS
case|:
name|processSplitRegion
argument_list|(
name|region
argument_list|,
name|incomingMsgs
index|[
name|i
index|]
operator|.
name|getDaughterA
argument_list|()
argument_list|,
name|incomingMsgs
index|[
name|i
index|]
operator|.
name|getDaughterB
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LOG
operator|.
name|warn
argument_list|(
literal|"Impossible state during message processing. Instruction: "
operator|+
name|incomingMsgs
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
synchronized|synchronized
init|(
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
init|)
block|{
comment|// Tell the region server to close regions that we have marked for closing.
for|for
control|(
name|HRegionInfo
name|i
range|:
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|getMarkedToClose
argument_list|(
name|serverInfo
operator|.
name|getServerName
argument_list|()
argument_list|)
control|)
block|{
name|returnMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|Type
operator|.
name|MSG_REGION_CLOSE
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|// Transition the region from toClose to closing state
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|setPendingClose
argument_list|(
name|i
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Figure out what the RegionServer ought to do, and write back.
comment|// Should we tell it close regions because its overloaded?  If its
comment|// currently opening regions, leave it alone till all are open.
if|if
condition|(
name|openingCount
operator|<
name|this
operator|.
name|nobalancingCount
condition|)
block|{
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|assignRegions
argument_list|(
name|serverInfo
argument_list|,
name|mostLoadedRegions
argument_list|,
name|returnMsgs
argument_list|)
expr_stmt|;
block|}
comment|// Send any pending table actions.
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|applyActions
argument_list|(
name|serverInfo
argument_list|,
name|returnMsgs
argument_list|)
expr_stmt|;
block|}
return|return
name|returnMsgs
operator|.
name|toArray
argument_list|(
operator|new
name|HMsg
index|[
name|returnMsgs
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/*    * A region has split.    *    * @param region    * @param splitA    * @param splitB    * @param returnMsgs    */
specifier|private
name|void
name|processSplitRegion
parameter_list|(
name|HRegionInfo
name|region
parameter_list|,
name|HRegionInfo
name|a
parameter_list|,
name|HRegionInfo
name|b
parameter_list|)
block|{
synchronized|synchronized
init|(
name|master
operator|.
name|getRegionManager
argument_list|()
init|)
block|{
comment|// Cancel any actions pending for the affected region.
comment|// This prevents the master from sending a SPLIT message if the table
comment|// has already split by the region server.
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|endActions
argument_list|(
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
name|assignSplitDaughter
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|assignSplitDaughter
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|.
name|isMetaTable
argument_list|()
condition|)
block|{
comment|// A meta region has split.
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|offlineMetaRegionWithStartKey
argument_list|(
name|region
operator|.
name|getStartKey
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|incrementNumMetaRegions
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/*    * Assign new daughter-of-a-split UNLESS its already been assigned.    * It could have been assigned already in rare case where there was a large    * gap between insertion of the daughter region into .META. by the    * splitting regionserver and receipt of the split message in master (See    * HBASE-1784).    * @param hri Region to assign.    */
specifier|private
name|void
name|assignSplitDaughter
parameter_list|(
specifier|final
name|HRegionInfo
name|hri
parameter_list|)
block|{
name|MetaRegion
name|mr
init|=
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|getFirstMetaRegionForRegion
argument_list|(
name|hri
argument_list|)
decl_stmt|;
name|Get
name|g
init|=
operator|new
name|Get
argument_list|(
name|hri
operator|.
name|getRegionName
argument_list|()
argument_list|)
decl_stmt|;
name|g
operator|.
name|addFamily
argument_list|(
name|HConstants
operator|.
name|CATALOG_FAMILY
argument_list|)
expr_stmt|;
try|try
block|{
name|HRegionInterface
name|server
init|=
name|this
operator|.
name|master
operator|.
name|getServerConnection
argument_list|()
operator|.
name|getHRegionConnection
argument_list|(
name|mr
operator|.
name|getServer
argument_list|()
argument_list|)
decl_stmt|;
name|Result
name|r
init|=
name|server
operator|.
name|get
argument_list|(
name|mr
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|g
argument_list|)
decl_stmt|;
comment|// If size> 3 -- presume regioninfo, startcode and server -- then presume
comment|// that this daughter already assigned and return.
if|if
condition|(
name|r
operator|.
name|size
argument_list|()
operator|>=
literal|3
condition|)
return|return;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed get on "
operator|+
name|HConstants
operator|.
name|CATALOG_FAMILY_STR
operator|+
literal|"; possible double-assignment?"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|setUnassigned
argument_list|(
name|hri
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/*    * Region server is reporting that a region is now opened    * @param serverInfo    * @param region    * @param returnMsgs    */
specifier|private
name|void
name|processRegionOpen
parameter_list|(
name|HServerInfo
name|serverInfo
parameter_list|,
name|HRegionInfo
name|region
parameter_list|,
name|ArrayList
argument_list|<
name|HMsg
argument_list|>
name|returnMsgs
parameter_list|)
block|{
name|boolean
name|duplicateAssignment
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|master
operator|.
name|getRegionManager
argument_list|()
init|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|isUnassigned
argument_list|(
name|region
argument_list|)
operator|&&
operator|!
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|isPendingOpen
argument_list|(
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|region
operator|.
name|isRootRegion
argument_list|()
condition|)
block|{
comment|// Root region
name|HServerAddress
name|rootServer
init|=
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|getRootRegionLocation
argument_list|()
decl_stmt|;
if|if
condition|(
name|rootServer
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|rootServer
operator|.
name|compareTo
argument_list|(
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// A duplicate open report from the correct server
return|return;
block|}
comment|// We received an open report on the root region, but it is
comment|// assigned to a different server
name|duplicateAssignment
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Not root region. If it is not a pending region, then we are
comment|// going to treat it as a duplicate assignment, although we can't
comment|// tell for certain that's the case.
if|if
condition|(
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|isPendingOpen
argument_list|(
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
condition|)
block|{
comment|// A duplicate report from the correct server
return|return;
block|}
name|duplicateAssignment
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|duplicateAssignment
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"region server "
operator|+
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|" should not have opened region "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// This Region should not have been opened.
comment|// Ask the server to shut it down, but don't report it as closed.
comment|// Otherwise the HMaster will think the Region was closed on purpose,
comment|// and then try to reopen it elsewhere; that's not what we want.
name|returnMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|Type
operator|.
name|MSG_REGION_CLOSE_WITHOUT_REPORT
argument_list|,
name|region
argument_list|,
literal|"Duplicate assignment"
operator|.
name|getBytes
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|region
operator|.
name|isRootRegion
argument_list|()
condition|)
block|{
comment|// it was assigned, and it's not a duplicate assignment, so take it out
comment|// of the unassigned list.
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|removeRegion
argument_list|(
name|region
argument_list|)
expr_stmt|;
comment|// Store the Root Region location (in memory)
name|HServerAddress
name|rootServer
init|=
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
decl_stmt|;
name|this
operator|.
name|master
operator|.
name|getServerConnection
argument_list|()
operator|.
name|setRootRegionLocation
argument_list|(
operator|new
name|HRegionLocation
argument_list|(
name|region
argument_list|,
name|rootServer
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|setRootRegionLocation
argument_list|(
name|rootServer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Note that the table has been assigned and is waiting for the
comment|// meta table to be updated.
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|setOpen
argument_list|(
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
name|RegionServerOperation
name|op
init|=
operator|new
name|ProcessRegionOpen
argument_list|(
name|master
argument_list|,
name|serverInfo
argument_list|,
name|region
argument_list|)
decl_stmt|;
name|this
operator|.
name|master
operator|.
name|getRegionServerOperationQueue
argument_list|()
operator|.
name|put
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/*    * @param region    * @throws Exception    */
specifier|private
name|void
name|processRegionClose
parameter_list|(
name|HRegionInfo
name|region
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
init|)
block|{
if|if
condition|(
name|region
operator|.
name|isRootRegion
argument_list|()
condition|)
block|{
comment|// Root region
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|unsetRootRegion
argument_list|()
expr_stmt|;
if|if
condition|(
name|region
operator|.
name|isOffline
argument_list|()
condition|)
block|{
comment|// Can't proceed without root region. Shutdown.
name|LOG
operator|.
name|fatal
argument_list|(
literal|"root region is marked offline"
argument_list|)
expr_stmt|;
name|this
operator|.
name|master
operator|.
name|shutdown
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|region
operator|.
name|isMetaTable
argument_list|()
condition|)
block|{
comment|// Region is part of the meta table. Remove it from onlineMetaRegions
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|offlineMetaRegionWithStartKey
argument_list|(
name|region
operator|.
name|getStartKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|boolean
name|offlineRegion
init|=
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|isOfflined
argument_list|(
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|reassignRegion
init|=
operator|!
name|region
operator|.
name|isOffline
argument_list|()
operator|&&
operator|!
name|offlineRegion
decl_stmt|;
comment|// NOTE: If the region was just being closed and not offlined, we cannot
comment|//       mark the region unassignedRegions as that changes the ordering of
comment|//       the messages we've received. In this case, a close could be
comment|//       processed before an open resulting in the master not agreeing on
comment|//       the region's state.
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|setClosed
argument_list|(
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
name|RegionServerOperation
name|op
init|=
operator|new
name|ProcessRegionClose
argument_list|(
name|master
argument_list|,
name|region
argument_list|,
name|offlineRegion
argument_list|,
name|reassignRegion
argument_list|)
decl_stmt|;
name|this
operator|.
name|master
operator|.
name|getRegionServerOperationQueue
argument_list|()
operator|.
name|put
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Update a server load information because it's shutting down*/
specifier|private
name|boolean
name|removeServerInfo
parameter_list|(
specifier|final
name|String
name|serverName
parameter_list|,
specifier|final
name|HServerAddress
name|serverAddress
parameter_list|)
block|{
name|boolean
name|infoUpdated
init|=
literal|false
decl_stmt|;
name|this
operator|.
name|serverAddressToServerInfo
operator|.
name|remove
argument_list|(
name|serverAddress
argument_list|)
expr_stmt|;
name|HServerInfo
name|info
init|=
name|this
operator|.
name|serversToServerInfo
operator|.
name|remove
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
comment|// Only update load information once.
comment|// This method can be called a couple of times during shutdown.
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing server's info "
operator|+
name|serverName
argument_list|)
expr_stmt|;
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|offlineMetaServer
argument_list|(
name|info
operator|.
name|getServerAddress
argument_list|()
argument_list|)
expr_stmt|;
comment|//HBASE-1928: Check whether this server has been transitioning the ROOT table
if|if
condition|(
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|isRootInTransitionOnThisServer
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|unsetRootRegion
argument_list|()
expr_stmt|;
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|reassignRootRegion
argument_list|()
expr_stmt|;
block|}
comment|//HBASE-1928: Check whether this server has been transitioning the META table
name|HRegionInfo
name|metaServerRegionInfo
init|=
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|getMetaServerRegionInfo
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
if|if
condition|(
name|metaServerRegionInfo
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|master
operator|.
name|getRegionManager
argument_list|()
operator|.
name|setUnassigned
argument_list|(
name|metaServerRegionInfo
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|infoUpdated
operator|=
literal|true
expr_stmt|;
comment|// update load information
name|updateLoadToServers
argument_list|(
name|serverName
argument_list|,
name|this
operator|.
name|serversToLoad
operator|.
name|remove
argument_list|(
name|serverName
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|infoUpdated
return|;
block|}
specifier|private
name|void
name|updateLoadToServers
parameter_list|(
specifier|final
name|String
name|serverName
parameter_list|,
specifier|final
name|HServerLoad
name|load
parameter_list|)
block|{
if|if
condition|(
name|load
operator|==
literal|null
condition|)
return|return;
synchronized|synchronized
init|(
name|this
operator|.
name|loadToServers
init|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|servers
init|=
name|this
operator|.
name|loadToServers
operator|.
name|get
argument_list|(
name|load
argument_list|)
decl_stmt|;
if|if
condition|(
name|servers
operator|!=
literal|null
condition|)
block|{
name|servers
operator|.
name|remove
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
if|if
condition|(
name|servers
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
name|this
operator|.
name|loadToServers
operator|.
name|put
argument_list|(
name|load
argument_list|,
name|servers
argument_list|)
expr_stmt|;
else|else
name|this
operator|.
name|loadToServers
operator|.
name|remove
argument_list|(
name|load
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Compute the average load across all region servers.    * Currently, this uses a very naive computation - just uses the number of    * regions being served, ignoring stats about number of requests.    * @return the average load    */
specifier|public
name|double
name|getAverageLoad
parameter_list|()
block|{
name|int
name|totalLoad
init|=
literal|0
decl_stmt|;
name|int
name|numServers
init|=
literal|0
decl_stmt|;
name|double
name|averageLoad
init|=
literal|0.0
decl_stmt|;
synchronized|synchronized
init|(
name|serversToLoad
init|)
block|{
name|numServers
operator|=
name|serversToLoad
operator|.
name|size
argument_list|()
expr_stmt|;
for|for
control|(
name|HServerLoad
name|load
range|:
name|serversToLoad
operator|.
name|values
argument_list|()
control|)
block|{
name|totalLoad
operator|+=
name|load
operator|.
name|getNumberOfRegions
argument_list|()
expr_stmt|;
block|}
name|averageLoad
operator|=
operator|(
name|double
operator|)
name|totalLoad
operator|/
operator|(
name|double
operator|)
name|numServers
expr_stmt|;
block|}
return|return
name|averageLoad
return|;
block|}
comment|/** @return the number of active servers */
specifier|public
name|int
name|numServers
parameter_list|()
block|{
return|return
name|this
operator|.
name|serversToServerInfo
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * @param name server name    * @return HServerInfo for the given server address    */
specifier|public
name|HServerInfo
name|getServerInfo
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|this
operator|.
name|serversToServerInfo
operator|.
name|get
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**    * @return Read-only map of servers to serverinfo.    */
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|HServerInfo
argument_list|>
name|getServersToServerInfo
parameter_list|()
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|serversToServerInfo
init|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|this
operator|.
name|serversToServerInfo
argument_list|)
return|;
block|}
block|}
specifier|public
name|Map
argument_list|<
name|HServerAddress
argument_list|,
name|HServerInfo
argument_list|>
name|getServerAddressToServerInfo
parameter_list|()
block|{
comment|// we use this one because all the puts to this map are parallel/synced with the other map.
synchronized|synchronized
init|(
name|this
operator|.
name|serversToServerInfo
init|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|this
operator|.
name|serverAddressToServerInfo
argument_list|)
return|;
block|}
block|}
comment|/**    * @return Read-only map of servers to load.    */
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|HServerLoad
argument_list|>
name|getServersToLoad
parameter_list|()
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|serversToLoad
init|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|serversToLoad
argument_list|)
return|;
block|}
block|}
comment|/**    * @return Read-only map of load to servers.    */
specifier|public
name|SortedMap
argument_list|<
name|HServerLoad
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|getLoadToServers
parameter_list|()
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|loadToServers
init|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableSortedMap
argument_list|(
name|this
operator|.
name|loadToServers
argument_list|)
return|;
block|}
block|}
comment|/**    * Wakes up threads waiting on serversToServerInfo    */
specifier|public
name|void
name|notifyServers
parameter_list|()
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|serversToServerInfo
init|)
block|{
name|this
operator|.
name|serversToServerInfo
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*    * Wait on regionservers to report in    * with {@link #regionServerReport(HServerInfo, HMsg[])} so they get notice    * the master is going down.  Waits until all region servers come back with    * a MSG_REGIONSERVER_STOP.    */
name|void
name|letRegionServersShutdown
parameter_list|()
block|{
if|if
condition|(
operator|!
name|master
operator|.
name|checkFileSystem
argument_list|()
condition|)
block|{
comment|// Forget waiting for the region servers if the file system has gone
comment|// away. Just exit as quickly as possible.
return|return;
block|}
synchronized|synchronized
init|(
name|serversToServerInfo
init|)
block|{
while|while
condition|(
name|serversToServerInfo
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting on following regionserver(s) to go down "
operator|+
name|this
operator|.
name|serversToServerInfo
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|serversToServerInfo
operator|.
name|wait
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// continue
block|}
block|}
block|}
block|}
comment|/** Watcher triggered when a RS znode is deleted */
specifier|private
class|class
name|ServerExpirer
implements|implements
name|Watcher
block|{
specifier|private
name|HServerInfo
name|server
decl_stmt|;
name|ServerExpirer
parameter_list|(
specifier|final
name|HServerInfo
name|hsi
parameter_list|)
block|{
name|this
operator|.
name|server
operator|=
name|hsi
expr_stmt|;
block|}
specifier|public
name|void
name|process
parameter_list|(
name|WatchedEvent
name|event
parameter_list|)
block|{
if|if
condition|(
operator|!
name|event
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|EventType
operator|.
name|NodeDeleted
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected event="
operator|+
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|this
operator|.
name|server
operator|.
name|getServerName
argument_list|()
operator|+
literal|" znode expired"
argument_list|)
expr_stmt|;
name|expireServer
argument_list|(
name|this
operator|.
name|server
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Expire the passed server.  Add it to list of deadservers and queue a    * shutdown processing.    */
specifier|private
specifier|synchronized
name|void
name|expireServer
parameter_list|(
specifier|final
name|HServerInfo
name|hsi
parameter_list|)
block|{
comment|// First check a server to expire.  ServerName is of the form:
comment|//<hostname> ,<port> ,<startcode>
name|String
name|serverName
init|=
name|hsi
operator|.
name|getServerName
argument_list|()
decl_stmt|;
name|HServerInfo
name|info
init|=
name|this
operator|.
name|serversToServerInfo
operator|.
name|get
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No HServerInfo for "
operator|+
name|serverName
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|this
operator|.
name|deadServers
operator|.
name|contains
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Already processing shutdown of "
operator|+
name|serverName
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Remove the server from the known servers lists and update load info
name|this
operator|.
name|serverAddressToServerInfo
operator|.
name|remove
argument_list|(
name|info
operator|.
name|getServerAddress
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|serversToServerInfo
operator|.
name|remove
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
name|HServerLoad
name|load
init|=
name|this
operator|.
name|serversToLoad
operator|.
name|remove
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
if|if
condition|(
name|load
operator|!=
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|loadToServers
init|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|servers
init|=
name|this
operator|.
name|loadToServers
operator|.
name|get
argument_list|(
name|load
argument_list|)
decl_stmt|;
if|if
condition|(
name|servers
operator|!=
literal|null
condition|)
block|{
name|servers
operator|.
name|remove
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
if|if
condition|(
name|servers
operator|.
name|isEmpty
argument_list|()
condition|)
name|this
operator|.
name|loadToServers
operator|.
name|remove
argument_list|(
name|load
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Add to dead servers and queue a shutdown processing.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Added="
operator|+
name|serverName
operator|+
literal|" to dead servers, added shutdown processing operation"
argument_list|)
expr_stmt|;
name|this
operator|.
name|deadServers
operator|.
name|add
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
name|this
operator|.
name|master
operator|.
name|getRegionServerOperationQueue
argument_list|()
operator|.
name|put
argument_list|(
operator|new
name|ProcessServerShutdown
argument_list|(
name|master
argument_list|,
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param serverName    */
name|void
name|removeDeadServer
parameter_list|(
name|String
name|serverName
parameter_list|)
block|{
name|this
operator|.
name|deadServers
operator|.
name|remove
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param serverName    * @return true if server is dead    */
specifier|public
name|boolean
name|isDead
parameter_list|(
specifier|final
name|String
name|serverName
parameter_list|)
block|{
return|return
name|isDead
argument_list|(
name|serverName
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * @param serverName Servername as either<code>host:port</code> or    *<code>host,port,startcode</code>.    * @param hostAndPortOnly True if<code>serverName</code> is host and    * port only (<code>host:port</code>) and if so, then we do a prefix compare    * (ignoring start codes) looking for dead server.    * @return true if server is dead    */
name|boolean
name|isDead
parameter_list|(
specifier|final
name|String
name|serverName
parameter_list|,
specifier|final
name|boolean
name|hostAndPortOnly
parameter_list|)
block|{
return|return
name|isDead
argument_list|(
name|this
operator|.
name|deadServers
argument_list|,
name|serverName
argument_list|,
name|hostAndPortOnly
argument_list|)
return|;
block|}
specifier|static
name|boolean
name|isDead
parameter_list|(
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|deadServers
parameter_list|,
specifier|final
name|String
name|serverName
parameter_list|,
specifier|final
name|boolean
name|hostAndPortOnly
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hostAndPortOnly
condition|)
return|return
name|deadServers
operator|.
name|contains
argument_list|(
name|serverName
argument_list|)
return|;
name|String
name|serverNameColonReplaced
init|=
name|serverName
operator|.
name|replaceFirst
argument_list|(
literal|":"
argument_list|,
name|HServerInfo
operator|.
name|SERVERNAME_SEPARATOR
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|hostPortStartCode
range|:
name|deadServers
control|)
block|{
name|int
name|index
init|=
name|hostPortStartCode
operator|.
name|lastIndexOf
argument_list|(
name|HServerInfo
operator|.
name|SERVERNAME_SEPARATOR
argument_list|)
decl_stmt|;
name|String
name|hostPortStrippedOfStartCode
init|=
name|hostPortStartCode
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|hostPortStrippedOfStartCode
operator|.
name|equals
argument_list|(
name|serverNameColonReplaced
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|getDeadServers
parameter_list|()
block|{
return|return
name|this
operator|.
name|deadServers
return|;
block|}
comment|/**    * Add to the passed<code>m</code> servers that are loaded less than    *<code>l</code>.    * @param l    * @param m    */
name|void
name|getLightServers
parameter_list|(
specifier|final
name|HServerLoad
name|l
parameter_list|,
name|SortedMap
argument_list|<
name|HServerLoad
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|m
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|loadToServers
init|)
block|{
name|m
operator|.
name|putAll
argument_list|(
name|this
operator|.
name|loadToServers
operator|.
name|headMap
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|canAssignUserRegions
parameter_list|()
block|{
if|if
condition|(
name|minimumServerCount
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
operator|(
name|numServers
argument_list|()
operator|>=
name|minimumServerCount
operator|)
return|;
block|}
specifier|public
name|void
name|setMinimumServerCount
parameter_list|(
name|int
name|minimumServerCount
parameter_list|)
block|{
name|this
operator|.
name|minimumServerCount
operator|=
name|minimumServerCount
expr_stmt|;
block|}
block|}
end_class

end_unit

