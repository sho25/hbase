begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertArrayEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|fail
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|testclassification
operator|.
name|MiscTests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|testclassification
operator|.
name|SmallTests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|experimental
operator|.
name|categories
operator|.
name|Category
import|;
end_import

begin_class
annotation|@
name|Category
argument_list|(
block|{
name|MiscTests
operator|.
name|class
block|,
name|SmallTests
operator|.
name|class
block|}
argument_list|)
specifier|public
class|class
name|TestOrderedBytes
block|{
comment|// integer constants for testing Numeric code paths
specifier|static
specifier|final
name|Long
index|[]
name|I_VALS
init|=
block|{
literal|0L
block|,
literal|1L
block|,
literal|10L
block|,
literal|99L
block|,
literal|100L
block|,
literal|1234L
block|,
literal|9999L
block|,
literal|10000L
block|,
literal|10001L
block|,
literal|12345L
block|,
literal|123450L
block|,
name|Long
operator|.
name|MAX_VALUE
block|,
operator|-
literal|1L
block|,
operator|-
literal|10L
block|,
operator|-
literal|99L
block|,
operator|-
literal|100L
block|,
operator|-
literal|123L
block|,
operator|-
literal|999L
block|,
operator|-
literal|10000L
block|,
operator|-
literal|10001L
block|,
operator|-
literal|12345L
block|,
operator|-
literal|123450L
block|,
name|Long
operator|.
name|MIN_VALUE
block|}
decl_stmt|;
specifier|static
specifier|final
name|int
index|[]
name|I_LENGTHS
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|2
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|11
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|2
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|11
block|}
decl_stmt|;
comment|// real constants for testing Numeric code paths
specifier|static
specifier|final
name|Double
index|[]
name|D_VALS
init|=
block|{
literal|0.0
block|,
literal|0.00123
block|,
literal|0.0123
block|,
literal|0.123
block|,
literal|1.0
block|,
literal|10.0
block|,
literal|12.345
block|,
literal|99.0
block|,
literal|99.01
block|,
literal|99.0001
block|,
literal|100.0
block|,
literal|100.01
block|,
literal|100.1
block|,
literal|1234.0
block|,
literal|1234.5
block|,
literal|9999.0
block|,
literal|9999.000001
block|,
literal|9999.000009
block|,
literal|9999.00001
block|,
literal|9999.00009
block|,
literal|9999.000099
block|,
literal|9999.0001
block|,
literal|9999.001
block|,
literal|9999.01
block|,
literal|9999.1
block|,
literal|10000.0
block|,
literal|10001.0
block|,
literal|12345.0
block|,
literal|123450.0
block|,
name|Double
operator|.
name|NEGATIVE_INFINITY
block|,
name|Double
operator|.
name|POSITIVE_INFINITY
block|,
name|Double
operator|.
name|NaN
block|,
name|Double
operator|.
name|MAX_VALUE
block|,
operator|-
literal|0.00123
block|,
operator|-
literal|0.0123
block|,
operator|-
literal|0.123
block|,
operator|-
literal|1.0
block|,
operator|-
literal|10.0
block|,
operator|-
literal|12.345
block|,
operator|-
literal|99.0
block|,
operator|-
literal|99.01
block|,
operator|-
literal|99.0001
block|,
operator|-
literal|100.0
block|,
operator|-
literal|100.01
block|,
operator|-
literal|100.1
block|,
operator|-
literal|1234.0
block|,
operator|-
literal|1234.5
block|,
operator|-
literal|9999.0
block|,
operator|-
literal|9999.000001
block|,
operator|-
literal|9999.000009
block|,
operator|-
literal|9999.00001
block|,
operator|-
literal|9999.00009
block|,
operator|-
literal|9999.000099
block|,
operator|-
literal|9999.0001
block|,
operator|-
literal|9999.001
block|,
operator|-
literal|9999.01
block|,
operator|-
literal|9999.1
block|,
operator|-
literal|10000.0
block|,
operator|-
literal|10001.0
block|,
operator|-
literal|12345.0
block|,
operator|-
literal|123450.0
block|}
decl_stmt|;
specifier|static
specifier|final
name|int
index|[]
name|D_LENGTHS
init|=
block|{
literal|1
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|,
literal|4
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|2
block|,
literal|4
block|,
literal|4
block|,
literal|3
block|,
literal|4
block|,
literal|3
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|5
block|,
literal|5
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|11
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|,
literal|4
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|2
block|,
literal|4
block|,
literal|4
block|,
literal|3
block|,
literal|4
block|,
literal|3
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|5
block|,
literal|5
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|}
decl_stmt|;
comment|// fill in other gaps in Numeric code paths
specifier|static
specifier|final
name|BigDecimal
index|[]
name|BD_VALS
init|=
block|{
literal|null
block|,
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
block|,
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|Long
operator|.
name|MIN_VALUE
argument_list|)
block|,
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|Double
operator|.
name|MAX_VALUE
argument_list|)
block|,
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|Double
operator|.
name|MIN_VALUE
argument_list|)
block|,
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
operator|.
name|multiply
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|100
argument_list|)
argument_list|)
block|}
decl_stmt|;
specifier|static
specifier|final
name|int
index|[]
name|BD_LENGTHS
init|=
block|{
literal|1
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|4
block|,
literal|12
block|}
decl_stmt|;
comment|/*    * This is the smallest difference between two doubles in D_VALS    */
specifier|static
specifier|final
name|double
name|MIN_EPSILON
init|=
literal|0.000001
decl_stmt|;
comment|/**    * Expected lengths of equivalent values should match    */
annotation|@
name|Test
specifier|public
name|void
name|testVerifyTestIntegrity
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|I_VALS
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|d
init|=
literal|0
init|;
name|d
operator|<
name|D_VALS
operator|.
name|length
condition|;
name|d
operator|++
control|)
block|{
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|I_VALS
index|[
name|i
index|]
operator|-
name|D_VALS
index|[
name|d
index|]
argument_list|)
operator|<
name|MIN_EPSILON
condition|)
block|{
name|assertEquals
argument_list|(
literal|"Test inconsistency detected: expected lengths for "
operator|+
name|I_VALS
index|[
name|i
index|]
operator|+
literal|" do not match."
argument_list|,
name|I_LENGTHS
index|[
name|i
index|]
argument_list|,
name|D_LENGTHS
index|[
name|d
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Tests the variable uint64 encoding.    *<p>    * Building sqlite4 with -DVARINT_TOOL provides this reference:<br />    *<code>$ ./varint_tool 240 2287 67823 16777215 4294967295 1099511627775    *   281474976710655 72057594037927935 18446744073709551615<br />    * 240 = f0<br />    * 2287 = f8ff<br />    * 67823 = f9ffff<br />    * 16777215 = faffffff<br />    * 4294967295 = fbffffffff<br />    * 1099511627775 = fcffffffffff<br />    * 281474976710655 = fdffffffffffff<br />    * 72057594037927935 = feffffffffffffff<br />    * 9223372036854775807 = ff7fffffffffffffff (Long.MAX_VAL)<br />    * 9223372036854775808 = ff8000000000000000 (Long.MIN_VAL)<br />    * 18446744073709551615 = ffffffffffffffffff<br /></code>    *</p>    */
annotation|@
name|Test
specifier|public
name|void
name|testVaruint64Boundaries
parameter_list|()
block|{
name|long
name|vals
index|[]
init|=
block|{
literal|239L
block|,
literal|240L
block|,
literal|2286L
block|,
literal|2287L
block|,
literal|67822L
block|,
literal|67823L
block|,
literal|16777214L
block|,
literal|16777215L
block|,
literal|4294967294L
block|,
literal|4294967295L
block|,
literal|1099511627774L
block|,
literal|1099511627775L
block|,
literal|281474976710654L
block|,
literal|281474976710655L
block|,
literal|72057594037927934L
block|,
literal|72057594037927935L
block|,
name|Long
operator|.
name|MAX_VALUE
operator|-
literal|1
block|,
name|Long
operator|.
name|MAX_VALUE
block|,
name|Long
operator|.
name|MIN_VALUE
operator|+
literal|1
block|,
name|Long
operator|.
name|MIN_VALUE
block|,
operator|-
literal|2L
block|,
operator|-
literal|1L
block|}
decl_stmt|;
name|int
name|lens
index|[]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|8
block|,
literal|8
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|}
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Broken test!"
argument_list|,
name|vals
operator|.
name|length
argument_list|,
name|lens
operator|.
name|length
argument_list|)
expr_stmt|;
comment|/*      * assert encoded values match decoded values. encode into target buffer      * starting at an offset to detect over/underflow conditions.      */
for|for
control|(
name|boolean
name|comp
range|:
operator|new
name|boolean
index|[]
block|{
literal|true
block|,
literal|false
block|}
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// allocate a buffer 2-bytes larger than necessary and place our range over the center.
name|byte
index|[]
name|a
init|=
operator|new
name|byte
index|[
name|lens
index|[
name|i
index|]
operator|+
literal|2
index|]
decl_stmt|;
name|PositionedByteRange
name|buf
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
name|lens
index|[
name|i
index|]
argument_list|)
decl_stmt|;
comment|// verify encode
name|assertEquals
argument_list|(
literal|"Surprising return value."
argument_list|,
name|lens
index|[
name|i
index|]
argument_list|,
name|OrderedBytes
operator|.
name|putVaruint64
argument_list|(
name|buf
argument_list|,
name|vals
index|[
name|i
index|]
argument_list|,
name|comp
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Surprising serialized length."
argument_list|,
name|lens
index|[
name|i
index|]
argument_list|,
name|buf
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer underflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer overflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
name|a
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|// verify skip
name|buf
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Surprising return value."
argument_list|,
name|lens
index|[
name|i
index|]
argument_list|,
name|OrderedBytes
operator|.
name|skipVaruint64
argument_list|(
name|buf
argument_list|,
name|comp
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Did not skip enough bytes."
argument_list|,
name|lens
index|[
name|i
index|]
argument_list|,
name|buf
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
comment|// verify decode
name|buf
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Deserialization failed."
argument_list|,
name|vals
index|[
name|i
index|]
argument_list|,
name|OrderedBytes
operator|.
name|getVaruint64
argument_list|(
name|buf
argument_list|,
name|comp
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Did not consume enough bytes."
argument_list|,
name|lens
index|[
name|i
index|]
argument_list|,
name|buf
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Test integer encoding. Example input values come from reference wiki    * page.    */
annotation|@
name|Test
specifier|public
name|void
name|testNumericInt
parameter_list|()
block|{
comment|/*      * assert encoded values match decoded values. encode into target buffer      * starting at an offset to detect over/underflow conditions.      */
for|for
control|(
name|Order
name|ord
range|:
operator|new
name|Order
index|[]
block|{
name|Order
operator|.
name|ASCENDING
block|,
name|Order
operator|.
name|DESCENDING
block|}
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|I_VALS
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// allocate a buffer 3-bytes larger than necessary to detect over/underflow
name|byte
index|[]
name|a
init|=
operator|new
name|byte
index|[
name|I_LENGTHS
index|[
name|i
index|]
operator|+
literal|3
index|]
decl_stmt|;
name|PositionedByteRange
name|buf1
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
name|I_LENGTHS
index|[
name|i
index|]
operator|+
literal|1
argument_list|)
decl_stmt|;
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// verify encode
name|assertEquals
argument_list|(
literal|"Surprising return value."
argument_list|,
name|I_LENGTHS
index|[
name|i
index|]
argument_list|,
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|buf1
argument_list|,
name|I_VALS
index|[
name|i
index|]
argument_list|,
name|ord
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Broken test: serialization did not consume entire buffer."
argument_list|,
name|buf1
operator|.
name|getLength
argument_list|()
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Surprising serialized length."
argument_list|,
name|I_LENGTHS
index|[
name|i
index|]
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer underflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer underflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer overflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
name|a
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|// verify skip
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Surprising return value."
argument_list|,
name|I_LENGTHS
index|[
name|i
index|]
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Did not skip enough bytes."
argument_list|,
name|I_LENGTHS
index|[
name|i
index|]
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// verify decode
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Deserialization failed."
argument_list|,
name|I_VALS
index|[
name|i
index|]
operator|.
name|longValue
argument_list|()
argument_list|,
name|OrderedBytes
operator|.
name|decodeNumericAsLong
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Did not consume enough bytes."
argument_list|,
name|I_LENGTHS
index|[
name|i
index|]
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * assert natural sort order is preserved by the codec.      */
for|for
control|(
name|Order
name|ord
range|:
operator|new
name|Order
index|[]
block|{
name|Order
operator|.
name|ASCENDING
block|,
name|Order
operator|.
name|DESCENDING
block|}
control|)
block|{
name|byte
index|[]
index|[]
name|encoded
init|=
operator|new
name|byte
index|[
name|I_VALS
operator|.
name|length
index|]
index|[]
decl_stmt|;
name|PositionedByteRange
name|pbr
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|I_VALS
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|encoded
index|[
name|i
index|]
operator|=
operator|new
name|byte
index|[
name|I_LENGTHS
index|[
name|i
index|]
index|]
expr_stmt|;
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|pbr
operator|.
name|set
argument_list|(
name|encoded
index|[
name|i
index|]
argument_list|)
argument_list|,
name|I_VALS
index|[
name|i
index|]
argument_list|,
name|ord
argument_list|)
expr_stmt|;
block|}
name|Arrays
operator|.
name|sort
argument_list|(
name|encoded
argument_list|,
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
expr_stmt|;
name|Long
index|[]
name|sortedVals
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|I_VALS
argument_list|,
name|I_VALS
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|ord
operator|==
name|Order
operator|.
name|ASCENDING
condition|)
name|Arrays
operator|.
name|sort
argument_list|(
name|sortedVals
argument_list|)
expr_stmt|;
else|else
name|Arrays
operator|.
name|sort
argument_list|(
name|sortedVals
argument_list|,
name|Collections
operator|.
name|reverseOrder
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sortedVals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|pbr
operator|.
name|set
argument_list|(
name|encoded
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|long
name|decoded
init|=
name|OrderedBytes
operator|.
name|decodeNumericAsLong
argument_list|(
name|pbr
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Encoded representations do not preserve natural order:<%s>,<%s>, %s"
argument_list|,
name|sortedVals
index|[
name|i
index|]
argument_list|,
name|decoded
argument_list|,
name|ord
argument_list|)
argument_list|,
name|sortedVals
index|[
name|i
index|]
operator|.
name|longValue
argument_list|()
argument_list|,
name|decoded
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Test real encoding. Example input values come from reference wiki page.    */
annotation|@
name|Test
specifier|public
name|void
name|testNumericReal
parameter_list|()
block|{
comment|/*      * assert encoded values match decoded values. encode into target buffer      * starting at an offset to detect over/underflow conditions.      */
for|for
control|(
name|Order
name|ord
range|:
operator|new
name|Order
index|[]
block|{
name|Order
operator|.
name|ASCENDING
block|,
name|Order
operator|.
name|DESCENDING
block|}
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|D_VALS
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// allocate a buffer 3-bytes larger than necessary to detect over/underflow
name|byte
index|[]
name|a
init|=
operator|new
name|byte
index|[
name|D_LENGTHS
index|[
name|i
index|]
operator|+
literal|3
index|]
decl_stmt|;
name|PositionedByteRange
name|buf1
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
name|D_LENGTHS
index|[
name|i
index|]
operator|+
literal|1
argument_list|)
decl_stmt|;
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// verify encode
name|assertEquals
argument_list|(
literal|"Surprising return value."
argument_list|,
name|D_LENGTHS
index|[
name|i
index|]
argument_list|,
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|buf1
argument_list|,
name|D_VALS
index|[
name|i
index|]
argument_list|,
name|ord
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Broken test: serialization did not consume entire buffer."
argument_list|,
name|buf1
operator|.
name|getLength
argument_list|()
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Surprising serialized length."
argument_list|,
name|D_LENGTHS
index|[
name|i
index|]
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer underflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer underflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer overflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
name|a
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|// verify skip
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Surprising return value."
argument_list|,
name|D_LENGTHS
index|[
name|i
index|]
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Did not skip enough bytes."
argument_list|,
name|D_LENGTHS
index|[
name|i
index|]
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// verify decode
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Deserialization failed."
argument_list|,
name|D_VALS
index|[
name|i
index|]
operator|.
name|doubleValue
argument_list|()
argument_list|,
name|OrderedBytes
operator|.
name|decodeNumericAsDouble
argument_list|(
name|buf1
argument_list|)
argument_list|,
name|MIN_EPSILON
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Did not consume enough bytes."
argument_list|,
name|D_LENGTHS
index|[
name|i
index|]
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * assert natural sort order is preserved by the codec.      */
for|for
control|(
name|Order
name|ord
range|:
operator|new
name|Order
index|[]
block|{
name|Order
operator|.
name|ASCENDING
block|,
name|Order
operator|.
name|DESCENDING
block|}
control|)
block|{
name|byte
index|[]
index|[]
name|encoded
init|=
operator|new
name|byte
index|[
name|D_VALS
operator|.
name|length
index|]
index|[]
decl_stmt|;
name|PositionedByteRange
name|pbr
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|D_VALS
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|encoded
index|[
name|i
index|]
operator|=
operator|new
name|byte
index|[
name|D_LENGTHS
index|[
name|i
index|]
index|]
expr_stmt|;
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|pbr
operator|.
name|set
argument_list|(
name|encoded
index|[
name|i
index|]
argument_list|)
argument_list|,
name|D_VALS
index|[
name|i
index|]
argument_list|,
name|ord
argument_list|)
expr_stmt|;
block|}
name|Arrays
operator|.
name|sort
argument_list|(
name|encoded
argument_list|,
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
expr_stmt|;
name|Double
index|[]
name|sortedVals
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|D_VALS
argument_list|,
name|D_VALS
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|ord
operator|==
name|Order
operator|.
name|ASCENDING
condition|)
name|Arrays
operator|.
name|sort
argument_list|(
name|sortedVals
argument_list|)
expr_stmt|;
else|else
name|Arrays
operator|.
name|sort
argument_list|(
name|sortedVals
argument_list|,
name|Collections
operator|.
name|reverseOrder
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sortedVals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|pbr
operator|.
name|set
argument_list|(
name|encoded
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|double
name|decoded
init|=
name|OrderedBytes
operator|.
name|decodeNumericAsDouble
argument_list|(
name|pbr
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Encoded representations do not preserve natural order:<%s>,<%s>, %s"
argument_list|,
name|sortedVals
index|[
name|i
index|]
argument_list|,
name|decoded
argument_list|,
name|ord
argument_list|)
argument_list|,
name|sortedVals
index|[
name|i
index|]
operator|.
name|doubleValue
argument_list|()
argument_list|,
name|decoded
argument_list|,
name|MIN_EPSILON
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Fill gaps in Numeric encoding testing.    */
annotation|@
name|Test
specifier|public
name|void
name|testNumericOther
parameter_list|()
block|{
comment|/*      * assert encoded values match decoded values. encode into target buffer      * starting at an offset to detect over/underflow conditions.      */
for|for
control|(
name|Order
name|ord
range|:
operator|new
name|Order
index|[]
block|{
name|Order
operator|.
name|ASCENDING
block|,
name|Order
operator|.
name|DESCENDING
block|}
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BD_VALS
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// allocate a buffer 3-bytes larger than necessary to detect over/underflow
name|byte
index|[]
name|a
init|=
operator|new
name|byte
index|[
name|BD_LENGTHS
index|[
name|i
index|]
operator|+
literal|3
index|]
decl_stmt|;
name|PositionedByteRange
name|buf1
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
name|BD_LENGTHS
index|[
name|i
index|]
operator|+
literal|1
argument_list|)
decl_stmt|;
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// verify encode
name|assertEquals
argument_list|(
literal|"Surprising return value."
argument_list|,
name|BD_LENGTHS
index|[
name|i
index|]
argument_list|,
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|buf1
argument_list|,
name|BD_VALS
index|[
name|i
index|]
argument_list|,
name|ord
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Broken test: serialization did not consume entire buffer."
argument_list|,
name|buf1
operator|.
name|getLength
argument_list|()
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Surprising serialized length."
argument_list|,
name|BD_LENGTHS
index|[
name|i
index|]
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer underflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer underflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer overflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
name|a
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|// verify skip
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Surprising return value."
argument_list|,
name|BD_LENGTHS
index|[
name|i
index|]
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Did not skip enough bytes."
argument_list|,
name|BD_LENGTHS
index|[
name|i
index|]
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// verify decode
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|BigDecimal
name|decoded
init|=
name|OrderedBytes
operator|.
name|decodeNumericAsBigDecimal
argument_list|(
name|buf1
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|BD_VALS
index|[
name|i
index|]
condition|)
block|{
name|assertEquals
argument_list|(
name|BD_VALS
index|[
name|i
index|]
argument_list|,
name|decoded
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertEquals
argument_list|(
literal|"Deserialization failed."
argument_list|,
literal|0
argument_list|,
name|BD_VALS
index|[
name|i
index|]
operator|.
name|compareTo
argument_list|(
name|decoded
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|"Did not consume enough bytes."
argument_list|,
name|BD_LENGTHS
index|[
name|i
index|]
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Verify Real and Int encodings are compatible.    */
annotation|@
name|Test
specifier|public
name|void
name|testNumericIntRealCompatibility
parameter_list|()
block|{
for|for
control|(
name|Order
name|ord
range|:
operator|new
name|Order
index|[]
block|{
name|Order
operator|.
name|ASCENDING
block|,
name|Order
operator|.
name|DESCENDING
block|}
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|I_VALS
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// verify primitives
name|PositionedByteRange
name|pbri
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|(
name|I_LENGTHS
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|PositionedByteRange
name|pbrr
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|(
name|I_LENGTHS
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|pbri
argument_list|,
name|I_VALS
index|[
name|i
index|]
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|pbrr
argument_list|,
name|I_VALS
index|[
name|i
index|]
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|assertArrayEquals
argument_list|(
literal|"Integer and real encodings differ."
argument_list|,
name|pbri
operator|.
name|getBytes
argument_list|()
argument_list|,
name|pbrr
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
name|pbri
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pbrr
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|long
operator|)
name|I_VALS
index|[
name|i
index|]
argument_list|,
name|OrderedBytes
operator|.
name|decodeNumericAsLong
argument_list|(
name|pbri
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|long
operator|)
name|I_VALS
index|[
name|i
index|]
argument_list|,
operator|(
name|long
operator|)
name|OrderedBytes
operator|.
name|decodeNumericAsDouble
argument_list|(
name|pbrr
argument_list|)
argument_list|)
expr_stmt|;
comment|// verify BigDecimal for Real encoding
name|BigDecimal
name|bd
init|=
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|I_VALS
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|PositionedByteRange
name|pbrbd
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|(
name|I_LENGTHS
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|pbrbd
argument_list|,
name|bd
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|assertArrayEquals
argument_list|(
literal|"Integer and BigDecimal encodings differ."
argument_list|,
name|pbri
operator|.
name|getBytes
argument_list|()
argument_list|,
name|pbrbd
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
name|pbri
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Value not preserved when decoding as Long"
argument_list|,
literal|0
argument_list|,
name|bd
operator|.
name|compareTo
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|OrderedBytes
operator|.
name|decodeNumericAsLong
argument_list|(
name|pbri
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Test int8 encoding.    */
annotation|@
name|Test
specifier|public
name|void
name|testInt8
parameter_list|()
block|{
name|Byte
index|[]
name|vals
init|=
block|{
name|Byte
operator|.
name|MIN_VALUE
block|,
name|Byte
operator|.
name|MIN_VALUE
operator|/
literal|2
block|,
literal|0
block|,
name|Byte
operator|.
name|MAX_VALUE
operator|/
literal|2
block|,
name|Byte
operator|.
name|MAX_VALUE
block|}
decl_stmt|;
comment|/*      * assert encoded values match decoded values. encode into target buffer      * starting at an offset to detect over/underflow conditions.      */
for|for
control|(
name|Order
name|ord
range|:
operator|new
name|Order
index|[]
block|{
name|Order
operator|.
name|ASCENDING
block|,
name|Order
operator|.
name|DESCENDING
block|}
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// allocate a buffer 3-bytes larger than necessary to detect over/underflow
name|byte
index|[]
name|a
init|=
operator|new
name|byte
index|[
literal|2
operator|+
literal|3
index|]
decl_stmt|;
name|PositionedByteRange
name|buf1
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
literal|2
operator|+
literal|1
argument_list|)
decl_stmt|;
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// verify encode
name|assertEquals
argument_list|(
literal|"Surprising return value."
argument_list|,
literal|2
argument_list|,
name|OrderedBytes
operator|.
name|encodeInt8
argument_list|(
name|buf1
argument_list|,
name|vals
index|[
name|i
index|]
argument_list|,
name|ord
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Broken test: serialization did not consume entire buffer."
argument_list|,
name|buf1
operator|.
name|getLength
argument_list|()
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Surprising serialized length."
argument_list|,
literal|2
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer underflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer underflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer overflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
name|a
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|// verify skip
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Surprising return value."
argument_list|,
literal|2
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Did not skip enough bytes."
argument_list|,
literal|2
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// verify decode
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Deserialization failed."
argument_list|,
name|vals
index|[
name|i
index|]
operator|.
name|byteValue
argument_list|()
argument_list|,
name|OrderedBytes
operator|.
name|decodeInt8
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Did not consume enough bytes."
argument_list|,
literal|2
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * assert natural sort order is preserved by the codec.      */
for|for
control|(
name|Order
name|ord
range|:
operator|new
name|Order
index|[]
block|{
name|Order
operator|.
name|ASCENDING
block|,
name|Order
operator|.
name|DESCENDING
block|}
control|)
block|{
name|byte
index|[]
index|[]
name|encoded
init|=
operator|new
name|byte
index|[
name|vals
operator|.
name|length
index|]
index|[
literal|2
index|]
decl_stmt|;
name|PositionedByteRange
name|pbr
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|OrderedBytes
operator|.
name|encodeInt8
argument_list|(
name|pbr
operator|.
name|set
argument_list|(
name|encoded
index|[
name|i
index|]
argument_list|)
argument_list|,
name|vals
index|[
name|i
index|]
argument_list|,
name|ord
argument_list|)
expr_stmt|;
block|}
name|Arrays
operator|.
name|sort
argument_list|(
name|encoded
argument_list|,
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
expr_stmt|;
name|Byte
index|[]
name|sortedVals
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|vals
argument_list|,
name|vals
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|ord
operator|==
name|Order
operator|.
name|ASCENDING
condition|)
name|Arrays
operator|.
name|sort
argument_list|(
name|sortedVals
argument_list|)
expr_stmt|;
else|else
name|Arrays
operator|.
name|sort
argument_list|(
name|sortedVals
argument_list|,
name|Collections
operator|.
name|reverseOrder
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sortedVals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|decoded
init|=
name|OrderedBytes
operator|.
name|decodeInt8
argument_list|(
name|pbr
operator|.
name|set
argument_list|(
name|encoded
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Encoded representations do not preserve natural order:<%s>,<%s>, %s"
argument_list|,
name|sortedVals
index|[
name|i
index|]
argument_list|,
name|decoded
argument_list|,
name|ord
argument_list|)
argument_list|,
name|sortedVals
index|[
name|i
index|]
operator|.
name|byteValue
argument_list|()
argument_list|,
name|decoded
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Test int16 encoding.    */
annotation|@
name|Test
specifier|public
name|void
name|testInt16
parameter_list|()
block|{
name|Short
index|[]
name|vals
init|=
block|{
name|Short
operator|.
name|MIN_VALUE
block|,
name|Short
operator|.
name|MIN_VALUE
operator|/
literal|2
block|,
literal|0
block|,
name|Short
operator|.
name|MAX_VALUE
operator|/
literal|2
block|,
name|Short
operator|.
name|MAX_VALUE
block|}
decl_stmt|;
comment|/*      * assert encoded values match decoded values. encode into target buffer      * starting at an offset to detect over/underflow conditions.      */
for|for
control|(
name|Order
name|ord
range|:
operator|new
name|Order
index|[]
block|{
name|Order
operator|.
name|ASCENDING
block|,
name|Order
operator|.
name|DESCENDING
block|}
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// allocate a buffer 3-bytes larger than necessary to detect over/underflow
name|byte
index|[]
name|a
init|=
operator|new
name|byte
index|[
literal|3
operator|+
literal|3
index|]
decl_stmt|;
name|PositionedByteRange
name|buf1
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
literal|3
operator|+
literal|1
argument_list|)
decl_stmt|;
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// verify encode
name|assertEquals
argument_list|(
literal|"Surprising return value."
argument_list|,
literal|3
argument_list|,
name|OrderedBytes
operator|.
name|encodeInt16
argument_list|(
name|buf1
argument_list|,
name|vals
index|[
name|i
index|]
argument_list|,
name|ord
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Broken test: serialization did not consume entire buffer."
argument_list|,
name|buf1
operator|.
name|getLength
argument_list|()
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Surprising serialized length."
argument_list|,
literal|3
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer underflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer underflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer overflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
name|a
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|// verify skip
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Surprising return value."
argument_list|,
literal|3
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Did not skip enough bytes."
argument_list|,
literal|3
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// verify decode
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Deserialization failed."
argument_list|,
name|vals
index|[
name|i
index|]
operator|.
name|shortValue
argument_list|()
argument_list|,
name|OrderedBytes
operator|.
name|decodeInt16
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Did not consume enough bytes."
argument_list|,
literal|3
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * assert natural sort order is preserved by the codec.      */
for|for
control|(
name|Order
name|ord
range|:
operator|new
name|Order
index|[]
block|{
name|Order
operator|.
name|ASCENDING
block|,
name|Order
operator|.
name|DESCENDING
block|}
control|)
block|{
name|byte
index|[]
index|[]
name|encoded
init|=
operator|new
name|byte
index|[
name|vals
operator|.
name|length
index|]
index|[
literal|3
index|]
decl_stmt|;
name|PositionedByteRange
name|pbr
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|OrderedBytes
operator|.
name|encodeInt16
argument_list|(
name|pbr
operator|.
name|set
argument_list|(
name|encoded
index|[
name|i
index|]
argument_list|)
argument_list|,
name|vals
index|[
name|i
index|]
argument_list|,
name|ord
argument_list|)
expr_stmt|;
block|}
name|Arrays
operator|.
name|sort
argument_list|(
name|encoded
argument_list|,
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
expr_stmt|;
name|Short
index|[]
name|sortedVals
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|vals
argument_list|,
name|vals
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|ord
operator|==
name|Order
operator|.
name|ASCENDING
condition|)
name|Arrays
operator|.
name|sort
argument_list|(
name|sortedVals
argument_list|)
expr_stmt|;
else|else
name|Arrays
operator|.
name|sort
argument_list|(
name|sortedVals
argument_list|,
name|Collections
operator|.
name|reverseOrder
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sortedVals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|decoded
init|=
name|OrderedBytes
operator|.
name|decodeInt16
argument_list|(
name|pbr
operator|.
name|set
argument_list|(
name|encoded
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Encoded representations do not preserve natural order:<%s>,<%s>, %s"
argument_list|,
name|sortedVals
index|[
name|i
index|]
argument_list|,
name|decoded
argument_list|,
name|ord
argument_list|)
argument_list|,
name|sortedVals
index|[
name|i
index|]
operator|.
name|shortValue
argument_list|()
argument_list|,
name|decoded
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Test int32 encoding.    */
annotation|@
name|Test
specifier|public
name|void
name|testInt32
parameter_list|()
block|{
name|Integer
index|[]
name|vals
init|=
block|{
name|Integer
operator|.
name|MIN_VALUE
block|,
name|Integer
operator|.
name|MIN_VALUE
operator|/
literal|2
block|,
literal|0
block|,
name|Integer
operator|.
name|MAX_VALUE
operator|/
literal|2
block|,
name|Integer
operator|.
name|MAX_VALUE
block|}
decl_stmt|;
comment|/*      * assert encoded values match decoded values. encode into target buffer      * starting at an offset to detect over/underflow conditions.      */
for|for
control|(
name|Order
name|ord
range|:
operator|new
name|Order
index|[]
block|{
name|Order
operator|.
name|ASCENDING
block|,
name|Order
operator|.
name|DESCENDING
block|}
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// allocate a buffer 3-bytes larger than necessary to detect over/underflow
name|byte
index|[]
name|a
init|=
operator|new
name|byte
index|[
literal|5
operator|+
literal|3
index|]
decl_stmt|;
name|PositionedByteRange
name|buf1
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
literal|5
operator|+
literal|1
argument_list|)
decl_stmt|;
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// verify encode
name|assertEquals
argument_list|(
literal|"Surprising return value."
argument_list|,
literal|5
argument_list|,
name|OrderedBytes
operator|.
name|encodeInt32
argument_list|(
name|buf1
argument_list|,
name|vals
index|[
name|i
index|]
argument_list|,
name|ord
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Broken test: serialization did not consume entire buffer."
argument_list|,
name|buf1
operator|.
name|getLength
argument_list|()
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Surprising serialized length."
argument_list|,
literal|5
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer underflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer underflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer overflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
name|a
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|// verify skip
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Surprising return value."
argument_list|,
literal|5
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Did not skip enough bytes."
argument_list|,
literal|5
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// verify decode
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Deserialization failed."
argument_list|,
name|vals
index|[
name|i
index|]
operator|.
name|intValue
argument_list|()
argument_list|,
name|OrderedBytes
operator|.
name|decodeInt32
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Did not consume enough bytes."
argument_list|,
literal|5
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * assert natural sort order is preserved by the codec.      */
for|for
control|(
name|Order
name|ord
range|:
operator|new
name|Order
index|[]
block|{
name|Order
operator|.
name|ASCENDING
block|,
name|Order
operator|.
name|DESCENDING
block|}
control|)
block|{
name|byte
index|[]
index|[]
name|encoded
init|=
operator|new
name|byte
index|[
name|vals
operator|.
name|length
index|]
index|[
literal|5
index|]
decl_stmt|;
name|PositionedByteRange
name|pbr
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|OrderedBytes
operator|.
name|encodeInt32
argument_list|(
name|pbr
operator|.
name|set
argument_list|(
name|encoded
index|[
name|i
index|]
argument_list|)
argument_list|,
name|vals
index|[
name|i
index|]
argument_list|,
name|ord
argument_list|)
expr_stmt|;
block|}
name|Arrays
operator|.
name|sort
argument_list|(
name|encoded
argument_list|,
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
expr_stmt|;
name|Integer
index|[]
name|sortedVals
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|vals
argument_list|,
name|vals
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|ord
operator|==
name|Order
operator|.
name|ASCENDING
condition|)
name|Arrays
operator|.
name|sort
argument_list|(
name|sortedVals
argument_list|)
expr_stmt|;
else|else
name|Arrays
operator|.
name|sort
argument_list|(
name|sortedVals
argument_list|,
name|Collections
operator|.
name|reverseOrder
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sortedVals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|decoded
init|=
name|OrderedBytes
operator|.
name|decodeInt32
argument_list|(
name|pbr
operator|.
name|set
argument_list|(
name|encoded
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Encoded representations do not preserve natural order:<%s>,<%s>, %s"
argument_list|,
name|sortedVals
index|[
name|i
index|]
argument_list|,
name|decoded
argument_list|,
name|ord
argument_list|)
argument_list|,
name|sortedVals
index|[
name|i
index|]
operator|.
name|intValue
argument_list|()
argument_list|,
name|decoded
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Test int64 encoding.    */
annotation|@
name|Test
specifier|public
name|void
name|testInt64
parameter_list|()
block|{
name|Long
index|[]
name|vals
init|=
block|{
name|Long
operator|.
name|MIN_VALUE
block|,
name|Long
operator|.
name|MIN_VALUE
operator|/
literal|2
block|,
literal|0L
block|,
name|Long
operator|.
name|MAX_VALUE
operator|/
literal|2
block|,
name|Long
operator|.
name|MAX_VALUE
block|}
decl_stmt|;
comment|/*      * assert encoded values match decoded values. encode into target buffer      * starting at an offset to detect over/underflow conditions.      */
for|for
control|(
name|Order
name|ord
range|:
operator|new
name|Order
index|[]
block|{
name|Order
operator|.
name|ASCENDING
block|,
name|Order
operator|.
name|DESCENDING
block|}
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// allocate a buffer 3-bytes larger than necessary to detect over/underflow
name|byte
index|[]
name|a
init|=
operator|new
name|byte
index|[
literal|9
operator|+
literal|3
index|]
decl_stmt|;
name|PositionedByteRange
name|buf1
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
literal|9
operator|+
literal|1
argument_list|)
decl_stmt|;
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// verify encode
name|assertEquals
argument_list|(
literal|"Surprising return value."
argument_list|,
literal|9
argument_list|,
name|OrderedBytes
operator|.
name|encodeInt64
argument_list|(
name|buf1
argument_list|,
name|vals
index|[
name|i
index|]
argument_list|,
name|ord
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Broken test: serialization did not consume entire buffer."
argument_list|,
name|buf1
operator|.
name|getLength
argument_list|()
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Surprising serialized length."
argument_list|,
literal|9
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer underflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer underflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer overflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
name|a
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|// verify skip
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Surprising return value."
argument_list|,
literal|9
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Did not skip enough bytes."
argument_list|,
literal|9
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// verify decode
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Deserialization failed."
argument_list|,
name|vals
index|[
name|i
index|]
operator|.
name|longValue
argument_list|()
argument_list|,
name|OrderedBytes
operator|.
name|decodeInt64
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Did not consume enough bytes."
argument_list|,
literal|9
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * assert natural sort order is preserved by the codec.      */
for|for
control|(
name|Order
name|ord
range|:
operator|new
name|Order
index|[]
block|{
name|Order
operator|.
name|ASCENDING
block|,
name|Order
operator|.
name|DESCENDING
block|}
control|)
block|{
name|byte
index|[]
index|[]
name|encoded
init|=
operator|new
name|byte
index|[
name|vals
operator|.
name|length
index|]
index|[
literal|9
index|]
decl_stmt|;
name|PositionedByteRange
name|pbr
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|OrderedBytes
operator|.
name|encodeInt64
argument_list|(
name|pbr
operator|.
name|set
argument_list|(
name|encoded
index|[
name|i
index|]
argument_list|)
argument_list|,
name|vals
index|[
name|i
index|]
argument_list|,
name|ord
argument_list|)
expr_stmt|;
block|}
name|Arrays
operator|.
name|sort
argument_list|(
name|encoded
argument_list|,
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
expr_stmt|;
name|Long
index|[]
name|sortedVals
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|vals
argument_list|,
name|vals
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|ord
operator|==
name|Order
operator|.
name|ASCENDING
condition|)
name|Arrays
operator|.
name|sort
argument_list|(
name|sortedVals
argument_list|)
expr_stmt|;
else|else
name|Arrays
operator|.
name|sort
argument_list|(
name|sortedVals
argument_list|,
name|Collections
operator|.
name|reverseOrder
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sortedVals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|long
name|decoded
init|=
name|OrderedBytes
operator|.
name|decodeInt64
argument_list|(
name|pbr
operator|.
name|set
argument_list|(
name|encoded
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Encoded representations do not preserve natural order:<%s>,<%s>, %s"
argument_list|,
name|sortedVals
index|[
name|i
index|]
argument_list|,
name|decoded
argument_list|,
name|ord
argument_list|)
argument_list|,
name|sortedVals
index|[
name|i
index|]
operator|.
name|longValue
argument_list|()
argument_list|,
name|decoded
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Test float32 encoding.    */
annotation|@
name|Test
specifier|public
name|void
name|testFloat32
parameter_list|()
block|{
name|Float
index|[]
name|vals
init|=
block|{
name|Float
operator|.
name|MIN_VALUE
block|,
name|Float
operator|.
name|MIN_VALUE
operator|+
literal|1.0f
block|,
literal|0.0f
block|,
name|Float
operator|.
name|MAX_VALUE
operator|/
literal|2.0f
block|,
name|Float
operator|.
name|MAX_VALUE
block|}
decl_stmt|;
comment|/*      * assert encoded values match decoded values. encode into target buffer      * starting at an offset to detect over/underflow conditions.      */
for|for
control|(
name|Order
name|ord
range|:
operator|new
name|Order
index|[]
block|{
name|Order
operator|.
name|ASCENDING
block|,
name|Order
operator|.
name|DESCENDING
block|}
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// allocate a buffer 3-bytes larger than necessary to detect over/underflow
name|byte
index|[]
name|a
init|=
operator|new
name|byte
index|[
literal|5
operator|+
literal|3
index|]
decl_stmt|;
name|PositionedByteRange
name|buf1
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
literal|5
operator|+
literal|1
argument_list|)
decl_stmt|;
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// verify encode
name|assertEquals
argument_list|(
literal|"Surprising return value."
argument_list|,
literal|5
argument_list|,
name|OrderedBytes
operator|.
name|encodeFloat32
argument_list|(
name|buf1
argument_list|,
name|vals
index|[
name|i
index|]
argument_list|,
name|ord
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Broken test: serialization did not consume entire buffer."
argument_list|,
name|buf1
operator|.
name|getLength
argument_list|()
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Surprising serialized length."
argument_list|,
literal|5
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer underflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer underflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer overflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
name|a
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|// verify skip
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Surprising return value."
argument_list|,
literal|5
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Did not skip enough bytes."
argument_list|,
literal|5
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// verify decode
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Deserialization failed."
argument_list|,
name|Float
operator|.
name|floatToIntBits
argument_list|(
name|vals
index|[
name|i
index|]
operator|.
name|floatValue
argument_list|()
argument_list|)
argument_list|,
name|Float
operator|.
name|floatToIntBits
argument_list|(
name|OrderedBytes
operator|.
name|decodeFloat32
argument_list|(
name|buf1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Did not consume enough bytes."
argument_list|,
literal|5
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * assert natural sort order is preserved by the codec.      */
for|for
control|(
name|Order
name|ord
range|:
operator|new
name|Order
index|[]
block|{
name|Order
operator|.
name|ASCENDING
block|,
name|Order
operator|.
name|DESCENDING
block|}
control|)
block|{
name|byte
index|[]
index|[]
name|encoded
init|=
operator|new
name|byte
index|[
name|vals
operator|.
name|length
index|]
index|[
literal|5
index|]
decl_stmt|;
name|PositionedByteRange
name|pbr
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|OrderedBytes
operator|.
name|encodeFloat32
argument_list|(
name|pbr
operator|.
name|set
argument_list|(
name|encoded
index|[
name|i
index|]
argument_list|)
argument_list|,
name|vals
index|[
name|i
index|]
argument_list|,
name|ord
argument_list|)
expr_stmt|;
block|}
name|Arrays
operator|.
name|sort
argument_list|(
name|encoded
argument_list|,
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
expr_stmt|;
name|Float
index|[]
name|sortedVals
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|vals
argument_list|,
name|vals
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|ord
operator|==
name|Order
operator|.
name|ASCENDING
condition|)
name|Arrays
operator|.
name|sort
argument_list|(
name|sortedVals
argument_list|)
expr_stmt|;
else|else
name|Arrays
operator|.
name|sort
argument_list|(
name|sortedVals
argument_list|,
name|Collections
operator|.
name|reverseOrder
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sortedVals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|float
name|decoded
init|=
name|OrderedBytes
operator|.
name|decodeFloat32
argument_list|(
name|pbr
operator|.
name|set
argument_list|(
name|encoded
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Encoded representations do not preserve natural order:<%s>,<%s>, %s"
argument_list|,
name|sortedVals
index|[
name|i
index|]
argument_list|,
name|decoded
argument_list|,
name|ord
argument_list|)
argument_list|,
name|Float
operator|.
name|floatToIntBits
argument_list|(
name|sortedVals
index|[
name|i
index|]
operator|.
name|floatValue
argument_list|()
argument_list|)
argument_list|,
name|Float
operator|.
name|floatToIntBits
argument_list|(
name|decoded
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Test float64 encoding.    */
annotation|@
name|Test
specifier|public
name|void
name|testFloat64
parameter_list|()
block|{
name|Double
index|[]
name|vals
init|=
block|{
name|Double
operator|.
name|MIN_VALUE
block|,
name|Double
operator|.
name|MIN_VALUE
operator|+
literal|1.0
block|,
literal|0.0
block|,
name|Double
operator|.
name|MAX_VALUE
operator|/
literal|2.0
block|,
name|Double
operator|.
name|MAX_VALUE
block|}
decl_stmt|;
comment|/*      * assert encoded values match decoded values. encode into target buffer      * starting at an offset to detect over/underflow conditions.      */
for|for
control|(
name|Order
name|ord
range|:
operator|new
name|Order
index|[]
block|{
name|Order
operator|.
name|ASCENDING
block|,
name|Order
operator|.
name|DESCENDING
block|}
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// allocate a buffer 3-bytes larger than necessary to detect over/underflow
name|byte
index|[]
name|a
init|=
operator|new
name|byte
index|[
literal|9
operator|+
literal|3
index|]
decl_stmt|;
name|PositionedByteRange
name|buf1
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
literal|9
operator|+
literal|1
argument_list|)
decl_stmt|;
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// verify encode
name|assertEquals
argument_list|(
literal|"Surprising return value."
argument_list|,
literal|9
argument_list|,
name|OrderedBytes
operator|.
name|encodeFloat64
argument_list|(
name|buf1
argument_list|,
name|vals
index|[
name|i
index|]
argument_list|,
name|ord
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Broken test: serialization did not consume entire buffer."
argument_list|,
name|buf1
operator|.
name|getLength
argument_list|()
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Surprising serialized length."
argument_list|,
literal|9
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer underflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer underflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer overflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
name|a
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|// verify skip
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Surprising return value."
argument_list|,
literal|9
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Did not skip enough bytes."
argument_list|,
literal|9
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// verify decode
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Deserialization failed."
argument_list|,
name|Double
operator|.
name|doubleToLongBits
argument_list|(
name|vals
index|[
name|i
index|]
operator|.
name|doubleValue
argument_list|()
argument_list|)
argument_list|,
name|Double
operator|.
name|doubleToLongBits
argument_list|(
name|OrderedBytes
operator|.
name|decodeFloat64
argument_list|(
name|buf1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Did not consume enough bytes."
argument_list|,
literal|9
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * assert natural sort order is preserved by the codec.      */
for|for
control|(
name|Order
name|ord
range|:
operator|new
name|Order
index|[]
block|{
name|Order
operator|.
name|ASCENDING
block|,
name|Order
operator|.
name|DESCENDING
block|}
control|)
block|{
name|byte
index|[]
index|[]
name|encoded
init|=
operator|new
name|byte
index|[
name|vals
operator|.
name|length
index|]
index|[
literal|9
index|]
decl_stmt|;
name|PositionedByteRange
name|pbr
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|OrderedBytes
operator|.
name|encodeFloat64
argument_list|(
name|pbr
operator|.
name|set
argument_list|(
name|encoded
index|[
name|i
index|]
argument_list|)
argument_list|,
name|vals
index|[
name|i
index|]
argument_list|,
name|ord
argument_list|)
expr_stmt|;
block|}
name|Arrays
operator|.
name|sort
argument_list|(
name|encoded
argument_list|,
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
expr_stmt|;
name|Double
index|[]
name|sortedVals
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|vals
argument_list|,
name|vals
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|ord
operator|==
name|Order
operator|.
name|ASCENDING
condition|)
name|Arrays
operator|.
name|sort
argument_list|(
name|sortedVals
argument_list|)
expr_stmt|;
else|else
name|Arrays
operator|.
name|sort
argument_list|(
name|sortedVals
argument_list|,
name|Collections
operator|.
name|reverseOrder
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sortedVals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|double
name|decoded
init|=
name|OrderedBytes
operator|.
name|decodeFloat64
argument_list|(
name|pbr
operator|.
name|set
argument_list|(
name|encoded
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Encoded representations do not preserve natural order:<%s>,<%s>, %s"
argument_list|,
name|sortedVals
index|[
name|i
index|]
argument_list|,
name|decoded
argument_list|,
name|ord
argument_list|)
argument_list|,
name|Double
operator|.
name|doubleToLongBits
argument_list|(
name|sortedVals
index|[
name|i
index|]
operator|.
name|doubleValue
argument_list|()
argument_list|)
argument_list|,
name|Double
operator|.
name|doubleToLongBits
argument_list|(
name|decoded
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Test string encoding.    */
annotation|@
name|Test
specifier|public
name|void
name|testString
parameter_list|()
block|{
name|String
index|[]
name|vals
init|=
block|{
literal|"foo"
block|,
literal|"baaaar"
block|,
literal|"bazz"
block|}
decl_stmt|;
name|int
name|expectedLengths
index|[]
init|=
block|{
literal|5
block|,
literal|8
block|,
literal|6
block|}
decl_stmt|;
comment|/*      * assert encoded values match decoded values. encode into target buffer      * starting at an offset to detect over/underflow conditions.      */
for|for
control|(
name|Order
name|ord
range|:
operator|new
name|Order
index|[]
block|{
name|Order
operator|.
name|ASCENDING
block|,
name|Order
operator|.
name|DESCENDING
block|}
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// allocate a buffer 3-bytes larger than necessary to detect over/underflow
name|byte
index|[]
name|a
init|=
operator|new
name|byte
index|[
name|expectedLengths
index|[
name|i
index|]
operator|+
literal|3
index|]
decl_stmt|;
name|PositionedByteRange
name|buf1
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
name|expectedLengths
index|[
name|i
index|]
operator|+
literal|1
argument_list|)
decl_stmt|;
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// verify encode
name|assertEquals
argument_list|(
literal|"Surprising return value."
argument_list|,
name|expectedLengths
index|[
name|i
index|]
argument_list|,
name|OrderedBytes
operator|.
name|encodeString
argument_list|(
name|buf1
argument_list|,
name|vals
index|[
name|i
index|]
argument_list|,
name|ord
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Broken test: serialization did not consume entire buffer."
argument_list|,
name|buf1
operator|.
name|getLength
argument_list|()
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Surprising serialized length."
argument_list|,
name|expectedLengths
index|[
name|i
index|]
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer underflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer underflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer overflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
name|a
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|// verify skip
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Surprising return value."
argument_list|,
name|expectedLengths
index|[
name|i
index|]
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Did not skip enough bytes."
argument_list|,
name|expectedLengths
index|[
name|i
index|]
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// verify decode
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Deserialization failed."
argument_list|,
name|vals
index|[
name|i
index|]
argument_list|,
name|OrderedBytes
operator|.
name|decodeString
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Did not consume enough bytes."
argument_list|,
name|expectedLengths
index|[
name|i
index|]
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * assert natural sort order is preserved by the codec.      */
for|for
control|(
name|Order
name|ord
range|:
operator|new
name|Order
index|[]
block|{
name|Order
operator|.
name|ASCENDING
block|,
name|Order
operator|.
name|DESCENDING
block|}
control|)
block|{
name|byte
index|[]
index|[]
name|encoded
init|=
operator|new
name|byte
index|[
name|vals
operator|.
name|length
index|]
index|[]
decl_stmt|;
name|PositionedByteRange
name|pbr
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|encoded
index|[
name|i
index|]
operator|=
operator|new
name|byte
index|[
name|expectedLengths
index|[
name|i
index|]
index|]
expr_stmt|;
name|OrderedBytes
operator|.
name|encodeString
argument_list|(
name|pbr
operator|.
name|set
argument_list|(
name|encoded
index|[
name|i
index|]
argument_list|)
argument_list|,
name|vals
index|[
name|i
index|]
argument_list|,
name|ord
argument_list|)
expr_stmt|;
block|}
name|Arrays
operator|.
name|sort
argument_list|(
name|encoded
argument_list|,
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
expr_stmt|;
name|String
index|[]
name|sortedVals
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|vals
argument_list|,
name|vals
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|ord
operator|==
name|Order
operator|.
name|ASCENDING
condition|)
name|Arrays
operator|.
name|sort
argument_list|(
name|sortedVals
argument_list|)
expr_stmt|;
else|else
name|Arrays
operator|.
name|sort
argument_list|(
name|sortedVals
argument_list|,
name|Collections
operator|.
name|reverseOrder
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sortedVals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|pbr
operator|.
name|set
argument_list|(
name|encoded
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|String
name|decoded
init|=
name|OrderedBytes
operator|.
name|decodeString
argument_list|(
name|pbr
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Encoded representations do not preserve natural order:<%s>,<%s>, %s"
argument_list|,
name|sortedVals
index|[
name|i
index|]
argument_list|,
name|decoded
argument_list|,
name|ord
argument_list|)
argument_list|,
name|sortedVals
index|[
name|i
index|]
argument_list|,
name|decoded
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Test
argument_list|(
name|expected
operator|=
name|IllegalArgumentException
operator|.
name|class
argument_list|)
specifier|public
name|void
name|testStringNoNullChars
parameter_list|()
block|{
name|PositionedByteRange
name|buff
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|OrderedBytes
operator|.
name|encodeString
argument_list|(
name|buff
argument_list|,
literal|"\u0000"
argument_list|,
name|Order
operator|.
name|ASCENDING
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test length estimation algorithms for BlobVar encoding. Does not cover    * 0-length input case properly.    */
annotation|@
name|Test
specifier|public
name|void
name|testBlobVarLencodedLength
parameter_list|()
block|{
name|int
index|[]
index|[]
name|values
init|=
block|{
comment|/* decoded length, encoded length          * ceil((n bytes * 8 bits/input byte) / 7 bits/encoded byte) + 1 header          */
block|{
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|2
block|,
literal|4
block|}
block|,
block|{
literal|3
block|,
literal|5
block|}
block|,
block|{
literal|4
block|,
literal|6
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|6
block|,
literal|8
block|}
block|,
block|{
literal|7
block|,
literal|9
block|}
block|,
block|{
literal|8
block|,
literal|11
block|}
block|}
decl_stmt|;
for|for
control|(
name|int
index|[]
name|pair
range|:
name|values
control|)
block|{
name|assertEquals
argument_list|(
name|pair
index|[
literal|1
index|]
argument_list|,
name|OrderedBytes
operator|.
name|blobVarEncodedLength
argument_list|(
name|pair
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|pair
index|[
literal|0
index|]
argument_list|,
name|OrderedBytes
operator|.
name|blobVarDecodedLength
argument_list|(
name|pair
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Test BlobVar encoding.    */
annotation|@
name|Test
specifier|public
name|void
name|testBlobVar
parameter_list|()
block|{
name|byte
index|[]
index|[]
name|vals
init|=
block|{
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|""
argument_list|)
block|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"foo"
argument_list|)
block|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"foobarbazbub"
argument_list|)
block|,
block|{
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
comment|/* 7 bytes of alternating bits; testing around HBASE-9893 */
block|}
block|,
block|{
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|}
block|,
block|{
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
comment|/* 14 bytes of alternating bits; testing around HBASE-9893 */
block|}
block|,
block|{
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
comment|/* 7 bytes of alternating bits; testing around HBASE-9893 */
block|}
block|,
block|{
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|}
block|,
block|{
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
comment|/* 14 bytes of alternating bits; testing around HBASE-9893 */
block|}
block|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"1"
argument_list|)
block|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"22"
argument_list|)
block|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"333"
argument_list|)
block|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"4444"
argument_list|)
block|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"55555"
argument_list|)
block|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"666666"
argument_list|)
block|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"7777777"
argument_list|)
block|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"88888888"
argument_list|)
block|}
decl_stmt|;
comment|/*      * assert encoded values match decoded values. encode into target buffer      * starting at an offset to detect over/underflow conditions.      */
for|for
control|(
name|Order
name|ord
range|:
operator|new
name|Order
index|[]
block|{
name|Order
operator|.
name|ASCENDING
block|,
name|Order
operator|.
name|DESCENDING
block|}
control|)
block|{
for|for
control|(
name|byte
index|[]
name|val
range|:
name|vals
control|)
block|{
comment|// allocate a buffer 3-bytes larger than necessary to detect over/underflow
name|int
name|expectedLen
init|=
name|OrderedBytes
operator|.
name|blobVarEncodedLength
argument_list|(
name|val
operator|.
name|length
argument_list|)
decl_stmt|;
name|byte
index|[]
name|a
init|=
operator|new
name|byte
index|[
name|expectedLen
operator|+
literal|3
index|]
decl_stmt|;
name|PositionedByteRange
name|buf1
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
name|expectedLen
operator|+
literal|1
argument_list|)
decl_stmt|;
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// verify encode
name|assertEquals
argument_list|(
literal|"Surprising return value."
argument_list|,
name|expectedLen
argument_list|,
name|OrderedBytes
operator|.
name|encodeBlobVar
argument_list|(
name|buf1
argument_list|,
name|val
argument_list|,
name|ord
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Broken test: serialization did not consume entire buffer."
argument_list|,
name|buf1
operator|.
name|getLength
argument_list|()
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Surprising serialized length."
argument_list|,
name|expectedLen
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer underflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer underflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer overflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
name|a
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|// verify skip
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Surprising return value."
argument_list|,
name|expectedLen
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Did not skip enough bytes."
argument_list|,
name|expectedLen
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// verify decode
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertArrayEquals
argument_list|(
literal|"Deserialization failed."
argument_list|,
name|val
argument_list|,
name|OrderedBytes
operator|.
name|decodeBlobVar
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Did not consume enough bytes."
argument_list|,
name|expectedLen
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * assert natural sort order is preserved by the codec.      */
for|for
control|(
name|Order
name|ord
range|:
operator|new
name|Order
index|[]
block|{
name|Order
operator|.
name|ASCENDING
block|,
name|Order
operator|.
name|DESCENDING
block|}
control|)
block|{
name|byte
index|[]
index|[]
name|encoded
init|=
operator|new
name|byte
index|[
name|vals
operator|.
name|length
index|]
index|[]
decl_stmt|;
name|PositionedByteRange
name|pbr
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|encoded
index|[
name|i
index|]
operator|=
operator|new
name|byte
index|[
name|OrderedBytes
operator|.
name|blobVarEncodedLength
argument_list|(
name|vals
index|[
name|i
index|]
operator|.
name|length
argument_list|)
index|]
expr_stmt|;
name|OrderedBytes
operator|.
name|encodeBlobVar
argument_list|(
name|pbr
operator|.
name|set
argument_list|(
name|encoded
index|[
name|i
index|]
argument_list|)
argument_list|,
name|vals
index|[
name|i
index|]
argument_list|,
name|ord
argument_list|)
expr_stmt|;
block|}
name|Arrays
operator|.
name|sort
argument_list|(
name|encoded
argument_list|,
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
expr_stmt|;
name|byte
index|[]
index|[]
name|sortedVals
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|vals
argument_list|,
name|vals
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|ord
operator|==
name|Order
operator|.
name|ASCENDING
condition|)
name|Arrays
operator|.
name|sort
argument_list|(
name|sortedVals
argument_list|,
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
expr_stmt|;
else|else
name|Arrays
operator|.
name|sort
argument_list|(
name|sortedVals
argument_list|,
name|Collections
operator|.
name|reverseOrder
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sortedVals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|pbr
operator|.
name|set
argument_list|(
name|encoded
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|byte
index|[]
name|decoded
init|=
name|OrderedBytes
operator|.
name|decodeBlobVar
argument_list|(
name|pbr
argument_list|)
decl_stmt|;
name|assertArrayEquals
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Encoded representations do not preserve natural order:<%s>,<%s>, %s"
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|sortedVals
index|[
name|i
index|]
argument_list|)
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|decoded
argument_list|)
argument_list|,
name|ord
argument_list|)
argument_list|,
name|sortedVals
index|[
name|i
index|]
argument_list|,
name|decoded
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Test BlobCopy encoding.    */
annotation|@
name|Test
specifier|public
name|void
name|testBlobCopy
parameter_list|()
block|{
name|byte
index|[]
index|[]
name|vals
init|=
block|{
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|""
argument_list|)
block|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"foo"
argument_list|)
block|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"foobarbazbub"
argument_list|)
block|,
block|{
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|,
operator|(
name|byte
operator|)
literal|0xaa
block|}
block|,
block|{
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|,
operator|(
name|byte
operator|)
literal|0x55
block|}
block|,       }
decl_stmt|;
comment|/*      * assert encoded values match decoded values. encode into target buffer      * starting at an offset to detect over/underflow conditions.      */
for|for
control|(
name|Order
name|ord
range|:
operator|new
name|Order
index|[]
block|{
name|Order
operator|.
name|ASCENDING
block|,
name|Order
operator|.
name|DESCENDING
block|}
control|)
block|{
for|for
control|(
name|byte
index|[]
name|val
range|:
name|vals
control|)
block|{
comment|// allocate a buffer 3-bytes larger than necessary to detect over/underflow
name|int
name|expectedLen
init|=
name|val
operator|.
name|length
operator|+
operator|(
name|Order
operator|.
name|ASCENDING
operator|==
name|ord
condition|?
literal|1
else|:
literal|2
operator|)
decl_stmt|;
name|byte
index|[]
name|a
init|=
operator|new
name|byte
index|[
name|expectedLen
operator|+
literal|3
index|]
decl_stmt|;
name|PositionedByteRange
name|buf1
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
name|expectedLen
operator|+
literal|1
argument_list|)
decl_stmt|;
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// verify encode
name|assertEquals
argument_list|(
literal|"Surprising return value."
argument_list|,
name|expectedLen
argument_list|,
name|OrderedBytes
operator|.
name|encodeBlobCopy
argument_list|(
name|buf1
argument_list|,
name|val
argument_list|,
name|ord
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Broken test: serialization did not consume entire buffer."
argument_list|,
name|buf1
operator|.
name|getLength
argument_list|()
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Surprising serialized length."
argument_list|,
name|expectedLen
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer underflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer underflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Buffer overflow."
argument_list|,
literal|0
argument_list|,
name|a
index|[
name|a
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|// verify skip
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Surprising return value."
argument_list|,
name|expectedLen
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Did not skip enough bytes."
argument_list|,
name|expectedLen
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// verify decode
name|buf1
operator|.
name|setPosition
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assertArrayEquals
argument_list|(
literal|"Deserialization failed."
argument_list|,
name|val
argument_list|,
name|OrderedBytes
operator|.
name|decodeBlobCopy
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Did not consume enough bytes."
argument_list|,
name|expectedLen
argument_list|,
name|buf1
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * assert natural sort order is preserved by the codec.      */
for|for
control|(
name|Order
name|ord
range|:
operator|new
name|Order
index|[]
block|{
name|Order
operator|.
name|ASCENDING
block|,
name|Order
operator|.
name|DESCENDING
block|}
control|)
block|{
name|byte
index|[]
index|[]
name|encoded
init|=
operator|new
name|byte
index|[
name|vals
operator|.
name|length
index|]
index|[]
decl_stmt|;
name|PositionedByteRange
name|pbr
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|encoded
index|[
name|i
index|]
operator|=
operator|new
name|byte
index|[
name|vals
index|[
name|i
index|]
operator|.
name|length
operator|+
operator|(
name|Order
operator|.
name|ASCENDING
operator|==
name|ord
condition|?
literal|1
else|:
literal|2
operator|)
index|]
expr_stmt|;
name|OrderedBytes
operator|.
name|encodeBlobCopy
argument_list|(
name|pbr
operator|.
name|set
argument_list|(
name|encoded
index|[
name|i
index|]
argument_list|)
argument_list|,
name|vals
index|[
name|i
index|]
argument_list|,
name|ord
argument_list|)
expr_stmt|;
block|}
name|Arrays
operator|.
name|sort
argument_list|(
name|encoded
argument_list|,
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
expr_stmt|;
name|byte
index|[]
index|[]
name|sortedVals
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|vals
argument_list|,
name|vals
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|ord
operator|==
name|Order
operator|.
name|ASCENDING
condition|)
name|Arrays
operator|.
name|sort
argument_list|(
name|sortedVals
argument_list|,
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
expr_stmt|;
else|else
name|Arrays
operator|.
name|sort
argument_list|(
name|sortedVals
argument_list|,
name|Collections
operator|.
name|reverseOrder
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sortedVals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|pbr
operator|.
name|set
argument_list|(
name|encoded
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|byte
index|[]
name|decoded
init|=
name|OrderedBytes
operator|.
name|decodeBlobCopy
argument_list|(
name|pbr
argument_list|)
decl_stmt|;
name|assertArrayEquals
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Encoded representations do not preserve natural order:<%s>,<%s>, %s"
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|sortedVals
index|[
name|i
index|]
argument_list|)
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|decoded
argument_list|)
argument_list|,
name|ord
argument_list|)
argument_list|,
name|sortedVals
index|[
name|i
index|]
argument_list|,
name|decoded
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * assert byte[] segments are serialized correctly.      */
for|for
control|(
name|Order
name|ord
range|:
operator|new
name|Order
index|[]
block|{
name|Order
operator|.
name|ASCENDING
block|,
name|Order
operator|.
name|DESCENDING
block|}
control|)
block|{
name|byte
index|[]
name|a
init|=
operator|new
name|byte
index|[
literal|3
operator|+
operator|(
name|Order
operator|.
name|ASCENDING
operator|==
name|ord
condition|?
literal|1
else|:
literal|2
operator|)
operator|+
literal|2
index|]
decl_stmt|;
name|PositionedByteRange
name|buf
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
literal|3
operator|+
operator|(
name|Order
operator|.
name|ASCENDING
operator|==
name|ord
condition|?
literal|1
else|:
literal|2
operator|)
argument_list|)
decl_stmt|;
name|OrderedBytes
operator|.
name|encodeBlobCopy
argument_list|(
name|buf
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"foobarbaz"
argument_list|)
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|buf
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertArrayEquals
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"bar"
argument_list|)
argument_list|,
name|OrderedBytes
operator|.
name|decodeBlobCopy
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Assert invalid input byte[] are rejected by BlobCopy    */
annotation|@
name|Test
argument_list|(
name|expected
operator|=
name|IllegalArgumentException
operator|.
name|class
argument_list|)
specifier|public
name|void
name|testBlobCopyNoZeroBytes
parameter_list|()
block|{
name|byte
index|[]
name|val
init|=
block|{
literal|0x01
block|,
literal|0x02
block|,
literal|0x00
block|,
literal|0x03
block|}
decl_stmt|;
comment|// TODO: implementation detail leaked here.
name|byte
index|[]
name|ascExpected
init|=
block|{
literal|0x38
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0x00
block|,
literal|0x03
block|}
decl_stmt|;
name|PositionedByteRange
name|buf
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|(
name|val
operator|.
name|length
operator|+
literal|1
argument_list|)
decl_stmt|;
name|OrderedBytes
operator|.
name|encodeBlobCopy
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|Order
operator|.
name|ASCENDING
argument_list|)
expr_stmt|;
name|assertArrayEquals
argument_list|(
name|ascExpected
argument_list|,
name|buf
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|set
argument_list|(
name|val
operator|.
name|length
operator|+
literal|2
argument_list|)
expr_stmt|;
name|OrderedBytes
operator|.
name|encodeBlobCopy
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|Order
operator|.
name|DESCENDING
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"test should never get here."
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test generic skip logic    */
annotation|@
name|Test
specifier|public
name|void
name|testSkip
parameter_list|()
block|{
name|BigDecimal
name|longMax
init|=
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
name|double
name|negInf
init|=
name|Double
operator|.
name|NEGATIVE_INFINITY
decl_stmt|;
name|BigDecimal
name|negLarge
init|=
name|longMax
operator|.
name|multiply
argument_list|(
name|longMax
argument_list|)
operator|.
name|negate
argument_list|()
decl_stmt|;
name|BigDecimal
name|negMed
init|=
operator|new
name|BigDecimal
argument_list|(
literal|"-10.0"
argument_list|)
decl_stmt|;
name|BigDecimal
name|negSmall
init|=
operator|new
name|BigDecimal
argument_list|(
literal|"-0.0010"
argument_list|)
decl_stmt|;
name|long
name|zero
init|=
literal|0l
decl_stmt|;
name|BigDecimal
name|posSmall
init|=
name|negSmall
operator|.
name|negate
argument_list|()
decl_stmt|;
name|BigDecimal
name|posMed
init|=
name|negMed
operator|.
name|negate
argument_list|()
decl_stmt|;
name|BigDecimal
name|posLarge
init|=
name|negLarge
operator|.
name|negate
argument_list|()
decl_stmt|;
name|double
name|posInf
init|=
name|Double
operator|.
name|POSITIVE_INFINITY
decl_stmt|;
name|double
name|nan
init|=
name|Double
operator|.
name|NaN
decl_stmt|;
name|byte
name|int8
init|=
literal|100
decl_stmt|;
name|short
name|int16
init|=
literal|100
decl_stmt|;
name|int
name|int32
init|=
literal|100
decl_stmt|;
name|long
name|int64
init|=
literal|100l
decl_stmt|;
name|float
name|float32
init|=
literal|100.0f
decl_stmt|;
name|double
name|float64
init|=
literal|100.0d
decl_stmt|;
name|String
name|text
init|=
literal|"hello world."
decl_stmt|;
name|byte
index|[]
name|blobVar
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"foo"
argument_list|)
decl_stmt|;
name|byte
index|[]
name|blobCopy
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"bar"
argument_list|)
decl_stmt|;
for|for
control|(
name|Order
name|ord
range|:
operator|new
name|Order
index|[]
block|{
name|Order
operator|.
name|ASCENDING
block|,
name|Order
operator|.
name|DESCENDING
block|}
control|)
block|{
name|PositionedByteRange
name|buff
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|(
literal|30
argument_list|)
decl_stmt|;
name|int
name|o
decl_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeNull
argument_list|(
name|buff
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|o
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|buff
argument_list|,
name|negInf
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|o
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|buff
argument_list|,
name|negLarge
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|o
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|buff
argument_list|,
name|negMed
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|o
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|buff
argument_list|,
name|negSmall
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|o
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|buff
argument_list|,
name|zero
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|o
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|buff
argument_list|,
name|posSmall
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|o
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|buff
argument_list|,
name|posMed
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|o
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|buff
argument_list|,
name|posLarge
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|o
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|buff
argument_list|,
name|posInf
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|o
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|buff
argument_list|,
name|nan
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|o
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeInt8
argument_list|(
name|buff
argument_list|,
name|int8
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|o
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeInt16
argument_list|(
name|buff
argument_list|,
name|int16
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|o
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeInt32
argument_list|(
name|buff
argument_list|,
name|int32
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|o
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeInt64
argument_list|(
name|buff
argument_list|,
name|int64
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|o
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeFloat32
argument_list|(
name|buff
argument_list|,
name|float32
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|o
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeFloat64
argument_list|(
name|buff
argument_list|,
name|float64
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|o
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeString
argument_list|(
name|buff
argument_list|,
name|text
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|o
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeBlobVar
argument_list|(
name|buff
argument_list|,
name|blobVar
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|o
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
comment|// blobCopy is special in that it runs to the end of the target buffer.
name|buff
operator|.
name|set
argument_list|(
name|blobCopy
operator|.
name|length
operator|+
operator|(
name|Order
operator|.
name|ASCENDING
operator|==
name|ord
condition|?
literal|1
else|:
literal|2
operator|)
argument_list|)
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeBlobCopy
argument_list|(
name|buff
argument_list|,
name|blobCopy
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|o
argument_list|,
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Test encoded value check    */
annotation|@
name|Test
specifier|public
name|void
name|testEncodedValueCheck
parameter_list|()
block|{
name|BigDecimal
name|longMax
init|=
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
name|double
name|negInf
init|=
name|Double
operator|.
name|NEGATIVE_INFINITY
decl_stmt|;
name|BigDecimal
name|negLarge
init|=
name|longMax
operator|.
name|multiply
argument_list|(
name|longMax
argument_list|)
operator|.
name|negate
argument_list|()
decl_stmt|;
name|BigDecimal
name|negMed
init|=
operator|new
name|BigDecimal
argument_list|(
literal|"-10.0"
argument_list|)
decl_stmt|;
name|BigDecimal
name|negSmall
init|=
operator|new
name|BigDecimal
argument_list|(
literal|"-0.0010"
argument_list|)
decl_stmt|;
name|long
name|zero
init|=
literal|0l
decl_stmt|;
name|BigDecimal
name|posSmall
init|=
name|negSmall
operator|.
name|negate
argument_list|()
decl_stmt|;
name|BigDecimal
name|posMed
init|=
name|negMed
operator|.
name|negate
argument_list|()
decl_stmt|;
name|BigDecimal
name|posLarge
init|=
name|negLarge
operator|.
name|negate
argument_list|()
decl_stmt|;
name|double
name|posInf
init|=
name|Double
operator|.
name|POSITIVE_INFINITY
decl_stmt|;
name|double
name|nan
init|=
name|Double
operator|.
name|NaN
decl_stmt|;
name|byte
name|int8
init|=
literal|100
decl_stmt|;
name|short
name|int16
init|=
literal|100
decl_stmt|;
name|int
name|int32
init|=
literal|100
decl_stmt|;
name|long
name|int64
init|=
literal|100l
decl_stmt|;
name|float
name|float32
init|=
literal|100.0f
decl_stmt|;
name|double
name|float64
init|=
literal|100.0d
decl_stmt|;
name|String
name|text
init|=
literal|"hello world."
decl_stmt|;
name|byte
index|[]
name|blobVar
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"foo"
argument_list|)
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|PositionedByteRange
name|buff
init|=
operator|new
name|SimplePositionedMutableByteRange
argument_list|(
literal|1024
argument_list|)
decl_stmt|;
for|for
control|(
name|Order
name|ord
range|:
operator|new
name|Order
index|[]
block|{
name|Order
operator|.
name|ASCENDING
block|,
name|Order
operator|.
name|DESCENDING
block|}
control|)
block|{
name|int
name|o
decl_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeNull
argument_list|(
name|buff
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|buff
argument_list|,
name|negInf
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|buff
argument_list|,
name|negLarge
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|buff
argument_list|,
name|negMed
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|buff
argument_list|,
name|negSmall
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|buff
argument_list|,
name|zero
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|buff
argument_list|,
name|posSmall
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|buff
argument_list|,
name|posMed
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|buff
argument_list|,
name|posLarge
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|buff
argument_list|,
name|posInf
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeNumeric
argument_list|(
name|buff
argument_list|,
name|nan
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeInt8
argument_list|(
name|buff
argument_list|,
name|int8
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeInt16
argument_list|(
name|buff
argument_list|,
name|int16
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeInt32
argument_list|(
name|buff
argument_list|,
name|int32
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeInt64
argument_list|(
name|buff
argument_list|,
name|int64
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeFloat32
argument_list|(
name|buff
argument_list|,
name|float32
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeFloat64
argument_list|(
name|buff
argument_list|,
name|float64
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeString
argument_list|(
name|buff
argument_list|,
name|text
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|o
operator|=
name|OrderedBytes
operator|.
name|encodeBlobVar
argument_list|(
name|buff
argument_list|,
name|blobVar
argument_list|,
name|ord
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
name|buff
operator|.
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|OrderedBytes
operator|.
name|length
argument_list|(
name|buff
argument_list|)
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|assertTrue
argument_list|(
name|OrderedBytes
operator|.
name|isEncodedValue
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|OrderedBytes
operator|.
name|skip
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

