begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ByteBufferUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Longs
import|;
end_import

begin_comment
comment|/**  * Compare two HBase cells.  Do not use this method comparing<code>-ROOT-</code> or  *<code>hbase:meta</code> cells.  Cells from these tables need a specialized comparator, one that  * takes account of the special formatting of the row where we have commas to delimit table from  * regionname, from row.  See KeyValue for how it has a special comparator to do hbase:meta cells  * and yet another for -ROOT-.  * While using this comparator for {{@link #compareRows(Cell, Cell)} et al, the hbase:meta cells  * format should be taken into consideration, for which the instance of this comparator  * should be used.  In all other cases the static APIs in this comparator would be enough  */
end_comment

begin_class
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"UNKNOWN"
argument_list|,
name|justification
operator|=
literal|"Findbugs doesn't like the way we are negating the result of a compare in below"
argument_list|)
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
class|class
name|CellComparator
implements|implements
name|Comparator
argument_list|<
name|Cell
argument_list|>
implements|,
name|Serializable
block|{
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|CellComparator
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
operator|-
literal|8760041766259623329L
decl_stmt|;
comment|/**    * Comparator for plain key/values; i.e. non-catalog table key/values. Works on Key portion    * of KeyValue only.    */
specifier|public
specifier|static
specifier|final
name|CellComparator
name|COMPARATOR
init|=
operator|new
name|CellComparator
argument_list|()
decl_stmt|;
comment|/**    * A {@link CellComparator} for<code>hbase:meta</code> catalog table    * {@link KeyValue}s.    */
specifier|public
specifier|static
specifier|final
name|CellComparator
name|META_COMPARATOR
init|=
operator|new
name|MetaCellComparator
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Cell
name|a
parameter_list|,
name|Cell
name|b
parameter_list|)
block|{
return|return
name|compare
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Compares only the key portion of a cell. It does not include the sequence id/mvcc of the    * cell     * @param left    * @param right    * @return an int greater than 0 if left&gt; than right    *                lesser than 0 if left&lt; than right    *                equal to 0 if left is equal to right    */
specifier|public
specifier|final
name|int
name|compareKeyIgnoresMvcc
parameter_list|(
name|Cell
name|left
parameter_list|,
name|Cell
name|right
parameter_list|)
block|{
return|return
name|compare
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Used when a cell needs to be compared with a key byte[] such as cases of    * finding the index from the index block, bloom keys from the bloom blocks    * This byte[] is expected to be serialized in the KeyValue serialization format    * If the KeyValue (Cell's) serialization format changes this method cannot be used.    * @param left the cell to be compared    * @param key the serialized key part of a KeyValue    * @param offset the offset in the key byte[]    * @param length the length of the key byte[]    * @return an int greater than 0 if left is greater than right    *                lesser than 0 if left is lesser than right    *                equal to 0 if left is equal to right    */
specifier|public
specifier|final
name|int
name|compare
parameter_list|(
name|Cell
name|left
parameter_list|,
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
comment|// row
name|short
name|rrowlength
init|=
name|Bytes
operator|.
name|toShort
argument_list|(
name|key
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|int
name|c
init|=
name|compareRows
argument_list|(
name|left
argument_list|,
name|key
argument_list|,
name|offset
operator|+
name|Bytes
operator|.
name|SIZEOF_SHORT
argument_list|,
name|rrowlength
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
return|return
name|c
return|;
comment|// Compare the rest of the two KVs without making any assumptions about
comment|// the common prefix. This function will not compare rows anyway, so we
comment|// don't need to tell it that the common prefix includes the row.
return|return
name|compareWithoutRow
argument_list|(
name|left
argument_list|,
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|rrowlength
argument_list|)
return|;
block|}
comment|/**    * Compare cells.    * @param a    * @param b    * @param ignoreSequenceid True if we are to compare the key portion only and ignore    * the sequenceid. Set to false to compare key and consider sequenceid.    * @return 0 if equal, -1 if a&lt; b, and +1 if a&gt; b.    */
specifier|private
specifier|final
name|int
name|compare
parameter_list|(
specifier|final
name|Cell
name|a
parameter_list|,
specifier|final
name|Cell
name|b
parameter_list|,
name|boolean
name|ignoreSequenceid
parameter_list|)
block|{
comment|// row
name|int
name|c
init|=
name|compareRows
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
return|return
name|c
return|;
name|c
operator|=
name|compareWithoutRow
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
return|return
name|c
return|;
if|if
condition|(
operator|!
name|ignoreSequenceid
condition|)
block|{
comment|// Negate following comparisons so later edits show up first
comment|// mvccVersion: later sorts first
return|return
name|Longs
operator|.
name|compare
argument_list|(
name|b
operator|.
name|getSequenceId
argument_list|()
argument_list|,
name|a
operator|.
name|getSequenceId
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|c
return|;
block|}
block|}
comment|/**    * Compares the family and qualifier part of the cell    * @param left the left cell    * @param right the right cell    * @return 0 if both cells are equal, 1 if left cell is bigger than right, -1 otherwise    */
specifier|public
specifier|final
specifier|static
name|int
name|compareColumns
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|)
block|{
name|int
name|diff
init|=
name|compareFamilies
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
decl_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|0
condition|)
block|{
return|return
name|diff
return|;
block|}
return|return
name|compareQualifiers
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
specifier|private
specifier|final
specifier|static
name|int
name|compareColumns
parameter_list|(
name|Cell
name|left
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|rfoffset
parameter_list|,
name|int
name|rflength
parameter_list|,
name|int
name|rqoffset
parameter_list|,
name|int
name|rqlength
parameter_list|)
block|{
name|int
name|diff
init|=
name|compareFamilies
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|rfoffset
argument_list|,
name|rflength
argument_list|)
decl_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|0
condition|)
return|return
name|diff
return|;
return|return
name|compareQualifiers
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|rqoffset
argument_list|,
name|rqlength
argument_list|)
return|;
block|}
comment|/**    * Compare the families of left and right cell    * @param left    * @param right    * @return 0 if both cells are equal, 1 if left cell is bigger than right, -1 otherwise    */
specifier|public
specifier|final
specifier|static
name|int
name|compareFamilies
parameter_list|(
name|Cell
name|left
parameter_list|,
name|Cell
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferedCell
operator|&&
name|right
operator|instanceof
name|ByteBufferedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|compareTo
argument_list|(
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|left
operator|)
operator|.
name|getFamilyByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|left
operator|)
operator|.
name|getFamilyPositionInByteBuffer
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|right
operator|)
operator|.
name|getFamilyByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|right
operator|)
operator|.
name|getFamilyPositionInByteBuffer
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyLength
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|compareTo
argument_list|(
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|left
operator|)
operator|.
name|getFamilyByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|left
operator|)
operator|.
name|getFamilyPositionInByteBuffer
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyLength
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|right
operator|instanceof
name|ByteBufferedCell
condition|)
block|{
return|return
operator|-
operator|(
name|ByteBufferUtils
operator|.
name|compareTo
argument_list|(
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|right
operator|)
operator|.
name|getFamilyByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|right
operator|)
operator|.
name|getFamilyPositionInByteBuffer
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyLength
argument_list|()
argument_list|)
operator|)
return|;
block|}
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyLength
argument_list|()
argument_list|)
return|;
block|}
specifier|private
specifier|final
specifier|static
name|int
name|compareFamilies
parameter_list|(
name|Cell
name|left
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|roffset
parameter_list|,
name|int
name|rlength
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|compareTo
argument_list|(
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|left
operator|)
operator|.
name|getFamilyByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|left
operator|)
operator|.
name|getFamilyPositionInByteBuffer
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|right
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|)
return|;
block|}
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|right
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|)
return|;
block|}
comment|/**    * Compare the qualifiers part of the left and right cells.    * @param left    * @param right    * @return 0 if both cells are equal, 1 if left cell is bigger than right, -1 otherwise    */
specifier|public
specifier|final
specifier|static
name|int
name|compareQualifiers
parameter_list|(
name|Cell
name|left
parameter_list|,
name|Cell
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferedCell
operator|&&
name|right
operator|instanceof
name|ByteBufferedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|compareTo
argument_list|(
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|left
operator|)
operator|.
name|getQualifierByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|left
operator|)
operator|.
name|getQualifierPositionInByteBuffer
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierLength
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|right
operator|)
operator|.
name|getQualifierByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|right
operator|)
operator|.
name|getQualifierPositionInByteBuffer
argument_list|()
argument_list|,
name|right
operator|.
name|getQualifierLength
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|compareTo
argument_list|(
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|left
operator|)
operator|.
name|getQualifierByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|left
operator|)
operator|.
name|getQualifierPositionInByteBuffer
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierLength
argument_list|()
argument_list|,
name|right
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|right
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|right
operator|.
name|getQualifierLength
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|right
operator|instanceof
name|ByteBufferedCell
condition|)
block|{
return|return
operator|-
operator|(
name|ByteBufferUtils
operator|.
name|compareTo
argument_list|(
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|right
operator|)
operator|.
name|getQualifierByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|right
operator|)
operator|.
name|getQualifierPositionInByteBuffer
argument_list|()
argument_list|,
name|right
operator|.
name|getQualifierLength
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierLength
argument_list|()
argument_list|)
operator|)
return|;
block|}
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierLength
argument_list|()
argument_list|,
name|right
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|right
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|right
operator|.
name|getQualifierLength
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|final
specifier|static
name|int
name|compareQualifiers
parameter_list|(
name|Cell
name|left
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|rOffset
parameter_list|,
name|int
name|rLength
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|compareTo
argument_list|(
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|left
operator|)
operator|.
name|getQualifierByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|left
operator|)
operator|.
name|getQualifierPositionInByteBuffer
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierLength
argument_list|()
argument_list|,
name|right
argument_list|,
name|rOffset
argument_list|,
name|rLength
argument_list|)
return|;
block|}
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierLength
argument_list|()
argument_list|,
name|right
argument_list|,
name|rOffset
argument_list|,
name|rLength
argument_list|)
return|;
block|}
comment|/**    * Compare columnFamily, qualifier, timestamp, and key type (everything    * except the row). This method is used both in the normal comparator and    * the "same-prefix" comparator. Note that we are assuming that row portions    * of both KVs have already been parsed and found identical, and we don't    * validate that assumption here.    * @param commonPrefix    *          the length of the common prefix of the two key-values being    *          compared, including row length and row    */
specifier|private
specifier|final
name|int
name|compareWithoutRow
parameter_list|(
name|Cell
name|left
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|roffset
parameter_list|,
name|int
name|rlength
parameter_list|,
name|short
name|rowlength
parameter_list|)
block|{
comment|/***      * KeyValue Format and commonLength:      * |_keyLen_|_valLen_|_rowLen_|_rowKey_|_famiLen_|_fami_|_Quali_|....      * ------------------|-------commonLength--------|--------------      */
name|int
name|commonLength
init|=
name|KeyValue
operator|.
name|ROW_LENGTH_SIZE
operator|+
name|KeyValue
operator|.
name|FAMILY_LENGTH_SIZE
operator|+
name|rowlength
decl_stmt|;
comment|// commonLength + TIMESTAMP_TYPE_SIZE
name|int
name|commonLengthWithTSAndType
init|=
name|KeyValue
operator|.
name|TIMESTAMP_TYPE_SIZE
operator|+
name|commonLength
decl_stmt|;
comment|// ColumnFamily + Qualifier length.
name|int
name|lcolumnlength
init|=
name|left
operator|.
name|getFamilyLength
argument_list|()
operator|+
name|left
operator|.
name|getQualifierLength
argument_list|()
decl_stmt|;
name|int
name|rcolumnlength
init|=
name|rlength
operator|-
name|commonLengthWithTSAndType
decl_stmt|;
name|byte
name|ltype
init|=
name|left
operator|.
name|getTypeByte
argument_list|()
decl_stmt|;
name|byte
name|rtype
init|=
name|right
index|[
name|roffset
operator|+
operator|(
name|rlength
operator|-
literal|1
operator|)
index|]
decl_stmt|;
comment|// If the column is not specified, the "minimum" key type appears the
comment|// latest in the sorted order, regardless of the timestamp. This is used
comment|// for specifying the last key/value in a given row, because there is no
comment|// "lexicographically last column" (it would be infinitely long). The
comment|// "maximum" key type does not need this behavior.
if|if
condition|(
name|lcolumnlength
operator|==
literal|0
operator|&&
name|ltype
operator|==
name|Type
operator|.
name|Minimum
operator|.
name|getCode
argument_list|()
condition|)
block|{
comment|// left is "bigger", i.e. it appears later in the sorted order
return|return
literal|1
return|;
block|}
if|if
condition|(
name|rcolumnlength
operator|==
literal|0
operator|&&
name|rtype
operator|==
name|Type
operator|.
name|Minimum
operator|.
name|getCode
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|int
name|rfamilyoffset
init|=
name|commonLength
operator|+
name|roffset
decl_stmt|;
comment|// Column family length.
name|int
name|lfamilylength
init|=
name|left
operator|.
name|getFamilyLength
argument_list|()
decl_stmt|;
name|int
name|rfamilylength
init|=
name|right
index|[
name|rfamilyoffset
operator|-
literal|1
index|]
decl_stmt|;
comment|// If left family size is not equal to right family size, we need not
comment|// compare the qualifiers.
name|boolean
name|sameFamilySize
init|=
operator|(
name|lfamilylength
operator|==
name|rfamilylength
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|sameFamilySize
condition|)
block|{
comment|// comparing column family is enough.
return|return
name|compareFamilies
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|rfamilyoffset
argument_list|,
name|rfamilylength
argument_list|)
return|;
block|}
comment|// Compare family& qualifier together.
comment|// Families are same. Compare on qualifiers.
name|int
name|comparison
init|=
name|compareColumns
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|rfamilyoffset
argument_list|,
name|rfamilylength
argument_list|,
name|rfamilyoffset
operator|+
name|rfamilylength
argument_list|,
operator|(
name|rcolumnlength
operator|-
name|rfamilylength
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|comparison
operator|!=
literal|0
condition|)
block|{
return|return
name|comparison
return|;
block|}
comment|// //
comment|// Next compare timestamps.
name|long
name|rtimestamp
init|=
name|Bytes
operator|.
name|toLong
argument_list|(
name|right
argument_list|,
name|roffset
operator|+
operator|(
name|rlength
operator|-
name|KeyValue
operator|.
name|TIMESTAMP_TYPE_SIZE
operator|)
argument_list|)
decl_stmt|;
name|int
name|compare
init|=
name|compareTimestamps
argument_list|(
name|left
operator|.
name|getTimestamp
argument_list|()
argument_list|,
name|rtimestamp
argument_list|)
decl_stmt|;
if|if
condition|(
name|compare
operator|!=
literal|0
condition|)
block|{
return|return
name|compare
return|;
block|}
comment|// Compare types. Let the delete types sort ahead of puts; i.e. types
comment|// of higher numbers sort before those of lesser numbers. Maximum (255)
comment|// appears ahead of everything, and minimum (0) appears after
comment|// everything.
return|return
operator|(
literal|0xff
operator|&
name|rtype
operator|)
operator|-
operator|(
literal|0xff
operator|&
name|ltype
operator|)
return|;
block|}
comment|/**    * Compares the rows of the left and right cell.    * For the hbase:meta case this method is overridden such that it can handle hbase:meta cells.    * The caller should ensure using the appropriate comparator for hbase:meta.    * @param left    * @param right    * @return 0 if both cells are equal, 1 if left cell is bigger than right, -1 otherwise    */
specifier|public
name|int
name|compareRows
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferedCell
operator|&&
name|right
operator|instanceof
name|ByteBufferedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|compareTo
argument_list|(
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|left
operator|)
operator|.
name|getRowByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|left
operator|)
operator|.
name|getRowPositionInByteBuffer
argument_list|()
argument_list|,
name|left
operator|.
name|getRowLength
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|right
operator|)
operator|.
name|getRowByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|right
operator|)
operator|.
name|getRowPositionInByteBuffer
argument_list|()
argument_list|,
name|right
operator|.
name|getRowLength
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|compareTo
argument_list|(
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|left
operator|)
operator|.
name|getRowByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|left
operator|)
operator|.
name|getRowPositionInByteBuffer
argument_list|()
argument_list|,
name|left
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|right
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|right
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|right
operator|.
name|getRowLength
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|right
operator|instanceof
name|ByteBufferedCell
condition|)
block|{
return|return
operator|-
operator|(
name|ByteBufferUtils
operator|.
name|compareTo
argument_list|(
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|right
operator|)
operator|.
name|getRowByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|right
operator|)
operator|.
name|getRowPositionInByteBuffer
argument_list|()
argument_list|,
name|right
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|left
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|left
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getRowLength
argument_list|()
argument_list|)
operator|)
return|;
block|}
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|left
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|right
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|right
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|right
operator|.
name|getRowLength
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Compares the row part of the cell with a simple plain byte[] like the    * stopRow in Scan. This should be used with context where for hbase:meta    * cells the {{@link #META_COMPARATOR} should be used    *    * @param left    *          the cell to be compared    * @param right    *          the kv serialized byte[] to be compared with    * @param roffset    *          the offset in the byte[]    * @param rlength    *          the length in the byte[]    * @return 0 if both cell and the byte[] are equal, 1 if the cell is bigger    *         than byte[], -1 otherwise    */
specifier|public
name|int
name|compareRows
parameter_list|(
name|Cell
name|left
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|roffset
parameter_list|,
name|int
name|rlength
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|compareTo
argument_list|(
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|left
operator|)
operator|.
name|getRowByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferedCell
operator|)
name|left
operator|)
operator|.
name|getRowPositionInByteBuffer
argument_list|()
argument_list|,
name|left
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|right
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|)
return|;
block|}
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|left
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|right
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|int
name|compareWithoutRow
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|)
block|{
comment|// If the column is not specified, the "minimum" key type appears the
comment|// latest in the sorted order, regardless of the timestamp. This is used
comment|// for specifying the last key/value in a given row, because there is no
comment|// "lexicographically last column" (it would be infinitely long). The
comment|// "maximum" key type does not need this behavior.
comment|// Copied from KeyValue. This is bad in that we can't do memcmp w/ special rules like this.
name|int
name|lFamLength
init|=
name|left
operator|.
name|getFamilyLength
argument_list|()
decl_stmt|;
name|int
name|rFamLength
init|=
name|right
operator|.
name|getFamilyLength
argument_list|()
decl_stmt|;
name|int
name|lQualLength
init|=
name|left
operator|.
name|getQualifierLength
argument_list|()
decl_stmt|;
name|int
name|rQualLength
init|=
name|right
operator|.
name|getQualifierLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|lFamLength
operator|+
name|lQualLength
operator|==
literal|0
operator|&&
name|left
operator|.
name|getTypeByte
argument_list|()
operator|==
name|Type
operator|.
name|Minimum
operator|.
name|getCode
argument_list|()
condition|)
block|{
comment|// left is "bigger", i.e. it appears later in the sorted order
return|return
literal|1
return|;
block|}
if|if
condition|(
name|rFamLength
operator|+
name|rQualLength
operator|==
literal|0
operator|&&
name|right
operator|.
name|getTypeByte
argument_list|()
operator|==
name|Type
operator|.
name|Minimum
operator|.
name|getCode
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|lFamLength
operator|!=
name|rFamLength
condition|)
block|{
comment|// comparing column family is enough.
return|return
name|compareFamilies
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|// Compare cf:qualifier
name|int
name|diff
init|=
name|compareColumns
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
decl_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|0
condition|)
return|return
name|diff
return|;
name|diff
operator|=
name|compareTimestamps
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|0
condition|)
return|return
name|diff
return|;
comment|// Compare types. Let the delete types sort ahead of puts; i.e. types
comment|// of higher numbers sort before those of lesser numbers. Maximum (255)
comment|// appears ahead of everything, and minimum (0) appears after
comment|// everything.
return|return
operator|(
literal|0xff
operator|&
name|right
operator|.
name|getTypeByte
argument_list|()
operator|)
operator|-
operator|(
literal|0xff
operator|&
name|left
operator|.
name|getTypeByte
argument_list|()
operator|)
return|;
block|}
comment|/**    * Compares cell's timestamps in DESCENDING order.    * The below older timestamps sorting ahead of newer timestamps looks    * wrong but it is intentional. This way, newer timestamps are first    * found when we iterate over a memstore and newer versions are the    * first we trip over when reading from a store file.    * @return 1 if left's timestamp&lt; right's timestamp    *         -1 if left's timestamp&gt; right's timestamp    *         0 if both timestamps are equal    */
specifier|public
specifier|static
name|int
name|compareTimestamps
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|)
block|{
return|return
name|compareTimestamps
argument_list|(
name|left
operator|.
name|getTimestamp
argument_list|()
argument_list|,
name|right
operator|.
name|getTimestamp
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Used to compare two cells based on the column hint provided. This is specifically    * used when we need to optimize the seeks based on the next indexed key. This is an    * advance usage API specifically needed for some optimizations.    * @param nextIndexedCell the next indexed cell     * @param currentCell the cell to be compared    * @param foff the family offset of the currentCell    * @param flen the family length of the currentCell    * @param colHint the column hint provided - could be null    * @param coff the offset of the column hint if provided, if not offset of the currentCell's    * qualifier    * @param clen the length of the column hint if provided, if not length of the currentCell's    * qualifier    * @param ts the timestamp to be seeked    * @param type the type to be seeked    * @return an int based on the given column hint    * TODO : To be moved out of here because this is a special API used in scan    * optimization.    */
comment|// compare a key against row/fam/qual/ts/type
specifier|public
specifier|final
name|int
name|compareKeyBasedOnColHint
parameter_list|(
name|Cell
name|nextIndexedCell
parameter_list|,
name|Cell
name|currentCell
parameter_list|,
name|int
name|foff
parameter_list|,
name|int
name|flen
parameter_list|,
name|byte
index|[]
name|colHint
parameter_list|,
name|int
name|coff
parameter_list|,
name|int
name|clen
parameter_list|,
name|long
name|ts
parameter_list|,
name|byte
name|type
parameter_list|)
block|{
name|int
name|compare
init|=
name|compareRows
argument_list|(
name|nextIndexedCell
argument_list|,
name|currentCell
argument_list|)
decl_stmt|;
if|if
condition|(
name|compare
operator|!=
literal|0
condition|)
block|{
return|return
name|compare
return|;
block|}
comment|// If the column is not specified, the "minimum" key type appears the
comment|// latest in the sorted order, regardless of the timestamp. This is used
comment|// for specifying the last key/value in a given row, because there is no
comment|// "lexicographically last column" (it would be infinitely long). The
comment|// "maximum" key type does not need this behavior.
if|if
condition|(
name|nextIndexedCell
operator|.
name|getFamilyLength
argument_list|()
operator|+
name|nextIndexedCell
operator|.
name|getQualifierLength
argument_list|()
operator|==
literal|0
operator|&&
name|nextIndexedCell
operator|.
name|getTypeByte
argument_list|()
operator|==
name|Type
operator|.
name|Minimum
operator|.
name|getCode
argument_list|()
condition|)
block|{
comment|// left is "bigger", i.e. it appears later in the sorted order
return|return
literal|1
return|;
block|}
if|if
condition|(
name|flen
operator|+
name|clen
operator|==
literal|0
operator|&&
name|type
operator|==
name|Type
operator|.
name|Minimum
operator|.
name|getCode
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|compare
operator|=
name|compareFamilies
argument_list|(
name|nextIndexedCell
argument_list|,
name|currentCell
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
operator|!=
literal|0
condition|)
block|{
return|return
name|compare
return|;
block|}
if|if
condition|(
name|colHint
operator|==
literal|null
condition|)
block|{
name|compare
operator|=
name|compareQualifiers
argument_list|(
name|nextIndexedCell
argument_list|,
name|currentCell
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|compare
operator|=
name|compareQualifiers
argument_list|(
name|nextIndexedCell
argument_list|,
name|colHint
argument_list|,
name|coff
argument_list|,
name|clen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|compare
operator|!=
literal|0
condition|)
block|{
return|return
name|compare
return|;
block|}
comment|// Next compare timestamps.
name|compare
operator|=
name|compareTimestamps
argument_list|(
name|nextIndexedCell
operator|.
name|getTimestamp
argument_list|()
argument_list|,
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
operator|!=
literal|0
condition|)
block|{
return|return
name|compare
return|;
block|}
comment|// Compare types. Let the delete types sort ahead of puts; i.e. types
comment|// of higher numbers sort before those of lesser numbers. Maximum (255)
comment|// appears ahead of everything, and minimum (0) appears after
comment|// everything.
return|return
operator|(
literal|0xff
operator|&
name|type
operator|)
operator|-
operator|(
literal|0xff
operator|&
name|nextIndexedCell
operator|.
name|getTypeByte
argument_list|()
operator|)
return|;
block|}
comment|/**    * Compares timestamps in DESCENDING order.    * The below older timestamps sorting ahead of newer timestamps looks    * wrong but it is intentional. This way, newer timestamps are first    * found when we iterate over a memstore and newer versions are the    * first we trip over when reading from a store file.    * @return 1 if left timestamp&lt; right timestamp    *         -1 if left timestamp&gt; right timestamp    *         0 if both timestamps are equal    */
specifier|public
specifier|static
name|int
name|compareTimestamps
parameter_list|(
specifier|final
name|long
name|ltimestamp
parameter_list|,
specifier|final
name|long
name|rtimestamp
parameter_list|)
block|{
if|if
condition|(
name|ltimestamp
operator|<
name|rtimestamp
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|ltimestamp
operator|>
name|rtimestamp
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/**    * Comparator that compares row component only of a Cell    */
specifier|public
specifier|static
class|class
name|RowComparator
extends|extends
name|CellComparator
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Cell
name|a
parameter_list|,
name|Cell
name|b
parameter_list|)
block|{
return|return
name|compareRows
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
block|}
comment|/**    * A {@link CellComparator} for<code>hbase:meta</code> catalog table    * {@link KeyValue}s.    */
specifier|public
specifier|static
class|class
name|MetaCellComparator
extends|extends
name|CellComparator
block|{
annotation|@
name|Override
specifier|public
name|int
name|compareRows
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|)
block|{
return|return
name|compareRows
argument_list|(
name|left
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|left
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|right
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|right
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|right
operator|.
name|getRowLength
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|compareRows
parameter_list|(
name|Cell
name|left
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|roffset
parameter_list|,
name|int
name|rlength
parameter_list|)
block|{
return|return
name|compareRows
argument_list|(
name|left
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|left
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|right
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|)
return|;
block|}
specifier|private
name|int
name|compareRows
parameter_list|(
name|byte
index|[]
name|left
parameter_list|,
name|int
name|loffset
parameter_list|,
name|int
name|llength
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|roffset
parameter_list|,
name|int
name|rlength
parameter_list|)
block|{
name|int
name|leftDelimiter
init|=
name|Bytes
operator|.
name|searchDelimiterIndex
argument_list|(
name|left
argument_list|,
name|loffset
argument_list|,
name|llength
argument_list|,
name|HConstants
operator|.
name|DELIMITER
argument_list|)
decl_stmt|;
name|int
name|rightDelimiter
init|=
name|Bytes
operator|.
name|searchDelimiterIndex
argument_list|(
name|right
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|,
name|HConstants
operator|.
name|DELIMITER
argument_list|)
decl_stmt|;
comment|// Compare up to the delimiter
name|int
name|lpart
init|=
operator|(
name|leftDelimiter
operator|<
literal|0
condition|?
name|llength
else|:
name|leftDelimiter
operator|-
name|loffset
operator|)
decl_stmt|;
name|int
name|rpart
init|=
operator|(
name|rightDelimiter
operator|<
literal|0
condition|?
name|rlength
else|:
name|rightDelimiter
operator|-
name|roffset
operator|)
decl_stmt|;
name|int
name|result
init|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
argument_list|,
name|loffset
argument_list|,
name|lpart
argument_list|,
name|right
argument_list|,
name|roffset
argument_list|,
name|rpart
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
else|else
block|{
if|if
condition|(
name|leftDelimiter
operator|<
literal|0
operator|&&
name|rightDelimiter
operator|>=
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|rightDelimiter
operator|<
literal|0
operator|&&
name|leftDelimiter
operator|>=
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|leftDelimiter
operator|<
literal|0
operator|&&
name|rightDelimiter
operator|<
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
comment|// Compare middle bit of the row.
comment|// Move past delimiter
name|leftDelimiter
operator|++
expr_stmt|;
name|rightDelimiter
operator|++
expr_stmt|;
name|int
name|leftFarDelimiter
init|=
name|Bytes
operator|.
name|searchDelimiterIndexInReverse
argument_list|(
name|left
argument_list|,
name|leftDelimiter
argument_list|,
name|llength
operator|-
operator|(
name|leftDelimiter
operator|-
name|loffset
operator|)
argument_list|,
name|HConstants
operator|.
name|DELIMITER
argument_list|)
decl_stmt|;
name|int
name|rightFarDelimiter
init|=
name|Bytes
operator|.
name|searchDelimiterIndexInReverse
argument_list|(
name|right
argument_list|,
name|rightDelimiter
argument_list|,
name|rlength
operator|-
operator|(
name|rightDelimiter
operator|-
name|roffset
operator|)
argument_list|,
name|HConstants
operator|.
name|DELIMITER
argument_list|)
decl_stmt|;
comment|// Now compare middlesection of row.
name|lpart
operator|=
operator|(
name|leftFarDelimiter
operator|<
literal|0
condition|?
name|llength
operator|+
name|loffset
else|:
name|leftFarDelimiter
operator|)
operator|-
name|leftDelimiter
expr_stmt|;
name|rpart
operator|=
operator|(
name|rightFarDelimiter
operator|<
literal|0
condition|?
name|rlength
operator|+
name|roffset
else|:
name|rightFarDelimiter
operator|)
operator|-
name|rightDelimiter
expr_stmt|;
name|result
operator|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
argument_list|,
name|leftDelimiter
argument_list|,
name|lpart
argument_list|,
name|right
argument_list|,
name|rightDelimiter
argument_list|,
name|rpart
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
else|else
block|{
if|if
condition|(
name|leftDelimiter
operator|<
literal|0
operator|&&
name|rightDelimiter
operator|>=
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|rightDelimiter
operator|<
literal|0
operator|&&
name|leftDelimiter
operator|>=
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|leftDelimiter
operator|<
literal|0
operator|&&
name|rightDelimiter
operator|<
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
comment|// Compare last part of row, the rowid.
name|leftFarDelimiter
operator|++
expr_stmt|;
name|rightFarDelimiter
operator|++
expr_stmt|;
name|result
operator|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
argument_list|,
name|leftFarDelimiter
argument_list|,
name|llength
operator|-
operator|(
name|leftFarDelimiter
operator|-
name|loffset
operator|)
argument_list|,
name|right
argument_list|,
name|rightFarDelimiter
argument_list|,
name|rlength
operator|-
operator|(
name|rightFarDelimiter
operator|-
name|roffset
operator|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
block|}
end_class

end_unit

