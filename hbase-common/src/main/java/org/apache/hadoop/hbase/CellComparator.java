begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Longs
import|;
end_import

begin_comment
comment|/**  * Compare two HBase cells.  Do not use this method comparing<code>-ROOT-</code> or  *<code>hbase:meta</code> cells.  Cells from these tables need a specialized comparator, one that  * takes account of the special formatting of the row where we have commas to delimit table from  * regionname, from row.  See KeyValue for how it has a special comparator to do hbase:meta cells  * and yet another for -ROOT-.  */
end_comment

begin_class
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"UNKNOWN"
argument_list|,
name|justification
operator|=
literal|"Findbugs doesn't like the way we are negating the result of a compare in below"
argument_list|)
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
class|class
name|CellComparator
implements|implements
name|Comparator
argument_list|<
name|Cell
argument_list|>
implements|,
name|Serializable
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
operator|-
literal|8760041766259623329L
decl_stmt|;
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Cell
name|a
parameter_list|,
name|Cell
name|b
parameter_list|)
block|{
return|return
name|compare
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Compare cells.    * TODO: Replace with dynamic rather than static comparator so can change comparator    * implementation.    * @param a    * @param b    * @param ignoreSequenceid True if we are to compare the key portion only and ignore    * the sequenceid. Set to false to compare key and consider sequenceid.    * @return 0 if equal, -1 if a< b, and +1 if a> b.    */
specifier|public
specifier|static
name|int
name|compare
parameter_list|(
specifier|final
name|Cell
name|a
parameter_list|,
specifier|final
name|Cell
name|b
parameter_list|,
name|boolean
name|ignoreSequenceid
parameter_list|)
block|{
comment|// row
name|int
name|c
init|=
name|compareRows
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
return|return
name|c
return|;
name|c
operator|=
name|compareWithoutRow
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
return|return
name|c
return|;
if|if
condition|(
operator|!
name|ignoreSequenceid
condition|)
block|{
comment|// Negate following comparisons so later edits show up first
comment|// compare log replay tag value if there is any
comment|// when either keyvalue tagged with log replay sequence number, we need to compare them:
comment|// 1) when both keyvalues have the tag, then use the tag values for comparison
comment|// 2) when one has and the other doesn't have, the one without the log
comment|// replay tag wins because
comment|// it means the edit isn't from recovery but new one coming from clients during recovery
comment|// 3) when both doesn't have, then skip to the next mvcc comparison
name|long
name|leftChangeSeqNum
init|=
name|getReplaySeqNum
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|long
name|RightChangeSeqNum
init|=
name|getReplaySeqNum
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftChangeSeqNum
operator|!=
name|Long
operator|.
name|MAX_VALUE
operator|||
name|RightChangeSeqNum
operator|!=
name|Long
operator|.
name|MAX_VALUE
condition|)
block|{
return|return
name|Longs
operator|.
name|compare
argument_list|(
name|RightChangeSeqNum
argument_list|,
name|leftChangeSeqNum
argument_list|)
return|;
block|}
comment|// mvccVersion: later sorts first
return|return
name|Longs
operator|.
name|compare
argument_list|(
name|b
operator|.
name|getMvccVersion
argument_list|()
argument_list|,
name|a
operator|.
name|getMvccVersion
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|c
return|;
block|}
block|}
comment|/**    * Return replay log sequence number for the cell    *    * @param c    * @return Long.MAX_VALUE if there is no LOG_REPLAY_TAG    */
specifier|private
specifier|static
name|long
name|getReplaySeqNum
parameter_list|(
specifier|final
name|Cell
name|c
parameter_list|)
block|{
name|Tag
name|tag
init|=
name|Tag
operator|.
name|getTag
argument_list|(
name|c
operator|.
name|getTagsArray
argument_list|()
argument_list|,
name|c
operator|.
name|getTagsOffset
argument_list|()
argument_list|,
name|c
operator|.
name|getTagsLength
argument_list|()
argument_list|,
name|TagType
operator|.
name|LOG_REPLAY_TAG_TYPE
argument_list|)
decl_stmt|;
if|if
condition|(
name|tag
operator|!=
literal|null
condition|)
block|{
return|return
name|Bytes
operator|.
name|toLong
argument_list|(
name|tag
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|tag
operator|.
name|getTagOffset
argument_list|()
argument_list|,
name|tag
operator|.
name|getTagLength
argument_list|()
argument_list|)
return|;
block|}
return|return
name|Long
operator|.
name|MAX_VALUE
return|;
block|}
specifier|public
specifier|static
name|int
name|findCommonPrefixInRowPart
parameter_list|(
name|Cell
name|left
parameter_list|,
name|Cell
name|right
parameter_list|,
name|int
name|rowCommonPrefix
parameter_list|)
block|{
return|return
name|findCommonPrefix
argument_list|(
name|left
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|right
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|left
operator|.
name|getRowLength
argument_list|()
operator|-
name|rowCommonPrefix
argument_list|,
name|right
operator|.
name|getRowLength
argument_list|()
operator|-
name|rowCommonPrefix
argument_list|,
name|left
operator|.
name|getRowOffset
argument_list|()
operator|+
name|rowCommonPrefix
argument_list|,
name|right
operator|.
name|getRowOffset
argument_list|()
operator|+
name|rowCommonPrefix
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|int
name|findCommonPrefix
parameter_list|(
name|byte
index|[]
name|left
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|leftLength
parameter_list|,
name|int
name|rightLength
parameter_list|,
name|int
name|leftOffset
parameter_list|,
name|int
name|rightOffset
parameter_list|)
block|{
name|int
name|length
init|=
name|Math
operator|.
name|min
argument_list|(
name|leftLength
argument_list|,
name|rightLength
argument_list|)
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|result
operator|<
name|length
operator|&&
name|left
index|[
name|leftOffset
operator|+
name|result
index|]
operator|==
name|right
index|[
name|rightOffset
operator|+
name|result
index|]
condition|)
block|{
name|result
operator|++
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|public
specifier|static
name|int
name|findCommonPrefixInFamilyPart
parameter_list|(
name|Cell
name|left
parameter_list|,
name|Cell
name|right
parameter_list|,
name|int
name|familyCommonPrefix
parameter_list|)
block|{
return|return
name|findCommonPrefix
argument_list|(
name|left
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyLength
argument_list|()
operator|-
name|familyCommonPrefix
argument_list|,
name|right
operator|.
name|getFamilyLength
argument_list|()
operator|-
name|familyCommonPrefix
argument_list|,
name|left
operator|.
name|getFamilyOffset
argument_list|()
operator|+
name|familyCommonPrefix
argument_list|,
name|right
operator|.
name|getFamilyOffset
argument_list|()
operator|+
name|familyCommonPrefix
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|int
name|findCommonPrefixInQualifierPart
parameter_list|(
name|Cell
name|left
parameter_list|,
name|Cell
name|right
parameter_list|,
name|int
name|qualifierCommonPrefix
parameter_list|)
block|{
return|return
name|findCommonPrefix
argument_list|(
name|left
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|right
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierLength
argument_list|()
operator|-
name|qualifierCommonPrefix
argument_list|,
name|right
operator|.
name|getQualifierLength
argument_list|()
operator|-
name|qualifierCommonPrefix
argument_list|,
name|left
operator|.
name|getQualifierOffset
argument_list|()
operator|+
name|qualifierCommonPrefix
argument_list|,
name|right
operator|.
name|getQualifierOffset
argument_list|()
operator|+
name|qualifierCommonPrefix
argument_list|)
return|;
block|}
comment|/**************** equals ****************************/
specifier|public
specifier|static
name|boolean
name|equals
parameter_list|(
name|Cell
name|a
parameter_list|,
name|Cell
name|b
parameter_list|)
block|{
return|return
name|equalsRow
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|&&
name|equalsFamily
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|&&
name|equalsQualifier
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|&&
name|equalsTimestamp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|&&
name|equalsType
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|equalsRow
parameter_list|(
name|Cell
name|a
parameter_list|,
name|Cell
name|b
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|a
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|a
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|a
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|b
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|b
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|b
operator|.
name|getRowLength
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|equalsFamily
parameter_list|(
name|Cell
name|a
parameter_list|,
name|Cell
name|b
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|a
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|a
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|a
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|b
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|b
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|b
operator|.
name|getFamilyLength
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|equalsQualifier
parameter_list|(
name|Cell
name|a
parameter_list|,
name|Cell
name|b
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|a
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|a
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|a
operator|.
name|getQualifierLength
argument_list|()
argument_list|,
name|b
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|b
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|b
operator|.
name|getQualifierLength
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|equalsTimestamp
parameter_list|(
name|Cell
name|a
parameter_list|,
name|Cell
name|b
parameter_list|)
block|{
return|return
name|a
operator|.
name|getTimestamp
argument_list|()
operator|==
name|b
operator|.
name|getTimestamp
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|boolean
name|equalsType
parameter_list|(
name|Cell
name|a
parameter_list|,
name|Cell
name|b
parameter_list|)
block|{
return|return
name|a
operator|.
name|getTypeByte
argument_list|()
operator|==
name|b
operator|.
name|getTypeByte
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|int
name|compareColumns
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|)
block|{
name|int
name|lfoffset
init|=
name|left
operator|.
name|getFamilyOffset
argument_list|()
decl_stmt|;
name|int
name|rfoffset
init|=
name|right
operator|.
name|getFamilyOffset
argument_list|()
decl_stmt|;
name|int
name|lclength
init|=
name|left
operator|.
name|getQualifierLength
argument_list|()
decl_stmt|;
name|int
name|rclength
init|=
name|right
operator|.
name|getQualifierLength
argument_list|()
decl_stmt|;
name|int
name|lfamilylength
init|=
name|left
operator|.
name|getFamilyLength
argument_list|()
decl_stmt|;
name|int
name|rfamilylength
init|=
name|right
operator|.
name|getFamilyLength
argument_list|()
decl_stmt|;
name|int
name|diff
init|=
name|compare
argument_list|(
name|left
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|lfoffset
argument_list|,
name|lfamilylength
argument_list|,
name|right
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|rfoffset
argument_list|,
name|rfamilylength
argument_list|)
decl_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|0
condition|)
block|{
return|return
name|diff
return|;
block|}
else|else
block|{
return|return
name|compare
argument_list|(
name|left
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|lclength
argument_list|,
name|right
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|right
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|rclength
argument_list|)
return|;
block|}
block|}
specifier|public
specifier|static
name|int
name|compareFamilies
parameter_list|(
name|Cell
name|left
parameter_list|,
name|Cell
name|right
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyLength
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|int
name|compareQualifiers
parameter_list|(
name|Cell
name|left
parameter_list|,
name|Cell
name|right
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierLength
argument_list|()
argument_list|,
name|right
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|right
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|right
operator|.
name|getQualifierLength
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|int
name|compareFlatKey
parameter_list|(
name|Cell
name|left
parameter_list|,
name|Cell
name|right
parameter_list|)
block|{
name|int
name|compare
init|=
name|compareRows
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
decl_stmt|;
if|if
condition|(
name|compare
operator|!=
literal|0
condition|)
block|{
return|return
name|compare
return|;
block|}
return|return
name|compareWithoutRow
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|int
name|compareRows
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|left
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|right
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|right
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|right
operator|.
name|getRowLength
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|int
name|compareRows
parameter_list|(
name|byte
index|[]
name|left
parameter_list|,
name|int
name|loffset
parameter_list|,
name|int
name|llength
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|roffset
parameter_list|,
name|int
name|rlength
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
argument_list|,
name|loffset
argument_list|,
name|llength
argument_list|,
name|right
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|int
name|compareWithoutRow
parameter_list|(
specifier|final
name|Cell
name|leftCell
parameter_list|,
specifier|final
name|Cell
name|rightCell
parameter_list|)
block|{
comment|// If the column is not specified, the "minimum" key type appears the
comment|// latest in the sorted order, regardless of the timestamp. This is used
comment|// for specifying the last key/value in a given row, because there is no
comment|// "lexicographically last column" (it would be infinitely long). The
comment|// "maximum" key type does not need this behavior.
comment|// Copied from KeyValue. This is bad in that we can't do memcmp w/ special rules like this.
comment|// TODO
if|if
condition|(
name|leftCell
operator|.
name|getFamilyLength
argument_list|()
operator|+
name|leftCell
operator|.
name|getQualifierLength
argument_list|()
operator|==
literal|0
operator|&&
name|leftCell
operator|.
name|getTypeByte
argument_list|()
operator|==
name|Type
operator|.
name|Minimum
operator|.
name|getCode
argument_list|()
condition|)
block|{
comment|// left is "bigger", i.e. it appears later in the sorted order
return|return
literal|1
return|;
block|}
if|if
condition|(
name|rightCell
operator|.
name|getFamilyLength
argument_list|()
operator|+
name|rightCell
operator|.
name|getQualifierLength
argument_list|()
operator|==
literal|0
operator|&&
name|rightCell
operator|.
name|getTypeByte
argument_list|()
operator|==
name|Type
operator|.
name|Minimum
operator|.
name|getCode
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|boolean
name|sameFamilySize
init|=
operator|(
name|leftCell
operator|.
name|getFamilyLength
argument_list|()
operator|==
name|rightCell
operator|.
name|getFamilyLength
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|sameFamilySize
condition|)
block|{
comment|// comparing column family is enough.
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|leftCell
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|leftCell
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|leftCell
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|rightCell
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|rightCell
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|rightCell
operator|.
name|getFamilyLength
argument_list|()
argument_list|)
return|;
block|}
name|int
name|diff
init|=
name|compareColumns
argument_list|(
name|leftCell
argument_list|,
name|rightCell
argument_list|)
decl_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|0
condition|)
return|return
name|diff
return|;
name|diff
operator|=
name|compareTimestamps
argument_list|(
name|leftCell
argument_list|,
name|rightCell
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|0
condition|)
return|return
name|diff
return|;
comment|// Compare types. Let the delete types sort ahead of puts; i.e. types
comment|// of higher numbers sort before those of lesser numbers. Maximum (255)
comment|// appears ahead of everything, and minimum (0) appears after
comment|// everything.
return|return
operator|(
literal|0xff
operator|&
name|rightCell
operator|.
name|getTypeByte
argument_list|()
operator|)
operator|-
operator|(
literal|0xff
operator|&
name|leftCell
operator|.
name|getTypeByte
argument_list|()
operator|)
return|;
block|}
specifier|public
specifier|static
name|int
name|compareTimestamps
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|)
block|{
name|long
name|ltimestamp
init|=
name|left
operator|.
name|getTimestamp
argument_list|()
decl_stmt|;
name|long
name|rtimestamp
init|=
name|right
operator|.
name|getTimestamp
argument_list|()
decl_stmt|;
return|return
name|compareTimestamps
argument_list|(
name|ltimestamp
argument_list|,
name|rtimestamp
argument_list|)
return|;
block|}
comment|/********************* hashCode ************************/
comment|/**    * Returns a hash code that is always the same for two Cells having a matching equals(..) result.    * Currently does not guard against nulls, but it could if necessary.    */
specifier|public
specifier|static
name|int
name|hashCode
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
if|if
condition|(
name|cell
operator|==
literal|null
condition|)
block|{
comment|// return 0 for empty Cell
return|return
literal|0
return|;
block|}
name|int
name|hash
init|=
name|calculateHashForKeyValue
argument_list|(
name|cell
argument_list|)
decl_stmt|;
name|hash
operator|=
literal|31
operator|*
name|hash
operator|+
operator|(
name|int
operator|)
name|cell
operator|.
name|getMvccVersion
argument_list|()
expr_stmt|;
return|return
name|hash
return|;
block|}
comment|/**    * Returns a hash code that is always the same for two Cells having a matching    * equals(..) result. Currently does not guard against nulls, but it could if    * necessary. Note : Ignore mvcc while calculating the hashcode    *     * @param cell    * @return hashCode    */
specifier|public
specifier|static
name|int
name|hashCodeIgnoreMvcc
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
if|if
condition|(
name|cell
operator|==
literal|null
condition|)
block|{
comment|// return 0 for empty Cell
return|return
literal|0
return|;
block|}
name|int
name|hash
init|=
name|calculateHashForKeyValue
argument_list|(
name|cell
argument_list|)
decl_stmt|;
return|return
name|hash
return|;
block|}
specifier|private
specifier|static
name|int
name|calculateHashForKeyValue
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
comment|//pre-calculate the 3 hashes made of byte ranges
name|int
name|rowHash
init|=
name|Bytes
operator|.
name|hashCode
argument_list|(
name|cell
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getRowLength
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|familyHash
init|=
name|Bytes
operator|.
name|hashCode
argument_list|(
name|cell
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getFamilyLength
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|qualifierHash
init|=
name|Bytes
operator|.
name|hashCode
argument_list|(
name|cell
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getQualifierLength
argument_list|()
argument_list|)
decl_stmt|;
comment|//combine the 6 sub-hashes
name|int
name|hash
init|=
literal|31
operator|*
name|rowHash
operator|+
name|familyHash
decl_stmt|;
name|hash
operator|=
literal|31
operator|*
name|hash
operator|+
name|qualifierHash
expr_stmt|;
name|hash
operator|=
literal|31
operator|*
name|hash
operator|+
operator|(
name|int
operator|)
name|cell
operator|.
name|getTimestamp
argument_list|()
expr_stmt|;
name|hash
operator|=
literal|31
operator|*
name|hash
operator|+
name|cell
operator|.
name|getTypeByte
argument_list|()
expr_stmt|;
return|return
name|hash
return|;
block|}
comment|/******************** lengths *************************/
specifier|public
specifier|static
name|boolean
name|areKeyLengthsEqual
parameter_list|(
name|Cell
name|a
parameter_list|,
name|Cell
name|b
parameter_list|)
block|{
return|return
name|a
operator|.
name|getRowLength
argument_list|()
operator|==
name|b
operator|.
name|getRowLength
argument_list|()
operator|&&
name|a
operator|.
name|getFamilyLength
argument_list|()
operator|==
name|b
operator|.
name|getFamilyLength
argument_list|()
operator|&&
name|a
operator|.
name|getQualifierLength
argument_list|()
operator|==
name|b
operator|.
name|getQualifierLength
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|boolean
name|areRowLengthsEqual
parameter_list|(
name|Cell
name|a
parameter_list|,
name|Cell
name|b
parameter_list|)
block|{
return|return
name|a
operator|.
name|getRowLength
argument_list|()
operator|==
name|b
operator|.
name|getRowLength
argument_list|()
return|;
block|}
comment|/*********************common prefixes*************************/
specifier|private
specifier|static
name|int
name|compare
parameter_list|(
name|byte
index|[]
name|left
parameter_list|,
name|int
name|leftOffset
parameter_list|,
name|int
name|leftLength
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|rightOffset
parameter_list|,
name|int
name|rightLength
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
argument_list|,
name|leftOffset
argument_list|,
name|leftLength
argument_list|,
name|right
argument_list|,
name|rightOffset
argument_list|,
name|rightLength
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|int
name|compareCommonRowPrefix
parameter_list|(
name|Cell
name|left
parameter_list|,
name|Cell
name|right
parameter_list|,
name|int
name|rowCommonPrefix
parameter_list|)
block|{
return|return
name|compare
argument_list|(
name|left
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|left
operator|.
name|getRowOffset
argument_list|()
operator|+
name|rowCommonPrefix
argument_list|,
name|left
operator|.
name|getRowLength
argument_list|()
operator|-
name|rowCommonPrefix
argument_list|,
name|right
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|right
operator|.
name|getRowOffset
argument_list|()
operator|+
name|rowCommonPrefix
argument_list|,
name|right
operator|.
name|getRowLength
argument_list|()
operator|-
name|rowCommonPrefix
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|int
name|compareCommonFamilyPrefix
parameter_list|(
name|Cell
name|left
parameter_list|,
name|Cell
name|right
parameter_list|,
name|int
name|familyCommonPrefix
parameter_list|)
block|{
return|return
name|compare
argument_list|(
name|left
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyOffset
argument_list|()
operator|+
name|familyCommonPrefix
argument_list|,
name|left
operator|.
name|getFamilyLength
argument_list|()
operator|-
name|familyCommonPrefix
argument_list|,
name|right
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyOffset
argument_list|()
operator|+
name|familyCommonPrefix
argument_list|,
name|right
operator|.
name|getFamilyLength
argument_list|()
operator|-
name|familyCommonPrefix
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|int
name|compareCommonQualifierPrefix
parameter_list|(
name|Cell
name|left
parameter_list|,
name|Cell
name|right
parameter_list|,
name|int
name|qualCommonPrefix
parameter_list|)
block|{
return|return
name|compare
argument_list|(
name|left
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierOffset
argument_list|()
operator|+
name|qualCommonPrefix
argument_list|,
name|left
operator|.
name|getQualifierLength
argument_list|()
operator|-
name|qualCommonPrefix
argument_list|,
name|right
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|right
operator|.
name|getQualifierOffset
argument_list|()
operator|+
name|qualCommonPrefix
argument_list|,
name|right
operator|.
name|getQualifierLength
argument_list|()
operator|-
name|qualCommonPrefix
argument_list|)
return|;
block|}
comment|/***************** special cases ****************************/
comment|/**    * special case for KeyValue.equals    */
specifier|public
specifier|static
name|boolean
name|equalsIgnoreMvccVersion
parameter_list|(
name|Cell
name|a
parameter_list|,
name|Cell
name|b
parameter_list|)
block|{
return|return
literal|0
operator|==
name|compareStaticIgnoreMvccVersion
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|int
name|compareStaticIgnoreMvccVersion
parameter_list|(
name|Cell
name|a
parameter_list|,
name|Cell
name|b
parameter_list|)
block|{
comment|// row
name|int
name|c
init|=
name|compareRows
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
return|return
name|c
return|;
comment|// family
name|c
operator|=
name|compareColumns
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
return|return
name|c
return|;
comment|// timestamp: later sorts first
name|c
operator|=
name|compareTimestamps
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
return|return
name|c
return|;
comment|//type
name|c
operator|=
operator|(
literal|0xff
operator|&
name|b
operator|.
name|getTypeByte
argument_list|()
operator|)
operator|-
operator|(
literal|0xff
operator|&
name|a
operator|.
name|getTypeByte
argument_list|()
operator|)
expr_stmt|;
return|return
name|c
return|;
block|}
specifier|private
specifier|static
name|int
name|compareTimestamps
parameter_list|(
specifier|final
name|long
name|ltimestamp
parameter_list|,
specifier|final
name|long
name|rtimestamp
parameter_list|)
block|{
comment|// The below older timestamps sorting ahead of newer timestamps looks
comment|// wrong but it is intentional. This way, newer timestamps are first
comment|// found when we iterate over a memstore and newer versions are the
comment|// first we trip over when reading from a store file.
if|if
condition|(
name|ltimestamp
operator|<
name|rtimestamp
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|ltimestamp
operator|>
name|rtimestamp
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/**    * Counter part for the KeyValue.RowOnlyComparator    */
specifier|public
specifier|static
class|class
name|RowComparator
extends|extends
name|CellComparator
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Cell
name|a
parameter_list|,
name|Cell
name|b
parameter_list|)
block|{
return|return
name|compareRows
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
block|}
comment|/**    * Try to return a Cell that falls between<code>left</code> and<code>right</code> but that is    * shorter; i.e. takes up less space. This is trick is used building HFile block index.    * Its an optimization. It does not always work.  In this case we'll just return the    *<code>right</code> cell.    * @param left    * @param right    * @return A cell that sorts between<code>left</code> and<code>right</code>.    */
specifier|public
specifier|static
name|Cell
name|getMidpoint
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|)
block|{
comment|// TODO: Redo so only a single pass over the arrays rather than one to compare and then a
comment|// second composing midpoint.
if|if
condition|(
name|right
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"right cell can not be null"
argument_list|)
throw|;
block|}
if|if
condition|(
name|left
operator|==
literal|null
condition|)
block|{
return|return
name|right
return|;
block|}
name|int
name|diff
init|=
name|compareRows
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
decl_stmt|;
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Left row sorts after right row; left="
operator|+
name|CellUtil
operator|.
name|getCellKeyAsString
argument_list|(
name|left
argument_list|)
operator|+
literal|", right="
operator|+
name|CellUtil
operator|.
name|getCellKeyAsString
argument_list|(
name|right
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
block|{
comment|// Left row is< right row.
name|byte
index|[]
name|midRow
init|=
name|getMinimumMidpointArray
argument_list|(
name|left
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|left
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|right
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|right
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|right
operator|.
name|getRowLength
argument_list|()
argument_list|)
decl_stmt|;
comment|// If midRow is null, just return 'right'.  Can't do optimization.
if|if
condition|(
name|midRow
operator|==
literal|null
condition|)
return|return
name|right
return|;
return|return
name|CellUtil
operator|.
name|createCell
argument_list|(
name|midRow
argument_list|)
return|;
block|}
comment|// Rows are same. Compare on families.
name|diff
operator|=
name|compareFamilies
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Left family sorts after right family; left="
operator|+
name|CellUtil
operator|.
name|getCellKeyAsString
argument_list|(
name|left
argument_list|)
operator|+
literal|", right="
operator|+
name|CellUtil
operator|.
name|getCellKeyAsString
argument_list|(
name|right
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
block|{
name|byte
index|[]
name|midRow
init|=
name|getMinimumMidpointArray
argument_list|(
name|left
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyLength
argument_list|()
argument_list|)
decl_stmt|;
comment|// If midRow is null, just return 'right'.  Can't do optimization.
if|if
condition|(
name|midRow
operator|==
literal|null
condition|)
return|return
name|right
return|;
comment|// Return new Cell where we use right row and then a mid sort family.
return|return
name|CellUtil
operator|.
name|createCell
argument_list|(
name|right
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|right
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|right
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|midRow
argument_list|,
literal|0
argument_list|,
name|midRow
operator|.
name|length
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|,
literal|0
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
operator|.
name|length
argument_list|)
return|;
block|}
comment|// Families are same. Compare on qualifiers.
name|diff
operator|=
name|compareQualifiers
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Left qualifier sorts after right qualifier; left="
operator|+
name|CellUtil
operator|.
name|getCellKeyAsString
argument_list|(
name|left
argument_list|)
operator|+
literal|", right="
operator|+
name|CellUtil
operator|.
name|getCellKeyAsString
argument_list|(
name|right
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
block|{
name|byte
index|[]
name|midRow
init|=
name|getMinimumMidpointArray
argument_list|(
name|left
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierLength
argument_list|()
argument_list|,
name|right
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|right
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|right
operator|.
name|getQualifierLength
argument_list|()
argument_list|)
decl_stmt|;
comment|// If midRow is null, just return 'right'.  Can't do optimization.
if|if
condition|(
name|midRow
operator|==
literal|null
condition|)
return|return
name|right
return|;
comment|// Return new Cell where we use right row and family and then a mid sort qualifier.
return|return
name|CellUtil
operator|.
name|createCell
argument_list|(
name|right
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|right
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|right
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|midRow
argument_list|,
literal|0
argument_list|,
name|midRow
operator|.
name|length
argument_list|)
return|;
block|}
comment|// No opportunity for optimization. Just return right key.
return|return
name|right
return|;
block|}
comment|/**    * @param leftArray    * @param leftOffset    * @param leftLength    * @param rightArray    * @param rightOffset    * @param rightLength    * @return Return a new array that is between left and right and minimally sized else just return    * null as indicator that we could not create a mid point.    */
specifier|private
specifier|static
name|byte
index|[]
name|getMinimumMidpointArray
parameter_list|(
specifier|final
name|byte
index|[]
name|leftArray
parameter_list|,
specifier|final
name|int
name|leftOffset
parameter_list|,
specifier|final
name|int
name|leftLength
parameter_list|,
specifier|final
name|byte
index|[]
name|rightArray
parameter_list|,
specifier|final
name|int
name|rightOffset
parameter_list|,
specifier|final
name|int
name|rightLength
parameter_list|)
block|{
comment|// rows are different
name|int
name|minLength
init|=
name|leftLength
operator|<
name|rightLength
condition|?
name|leftLength
else|:
name|rightLength
decl_stmt|;
name|short
name|diffIdx
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|diffIdx
operator|<
name|minLength
operator|&&
name|leftArray
index|[
name|leftOffset
operator|+
name|diffIdx
index|]
operator|==
name|rightArray
index|[
name|rightOffset
operator|+
name|diffIdx
index|]
condition|)
block|{
name|diffIdx
operator|++
expr_stmt|;
block|}
name|byte
index|[]
name|minimumMidpointArray
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|diffIdx
operator|>=
name|minLength
condition|)
block|{
comment|// leftKey's row is prefix of rightKey's.
name|minimumMidpointArray
operator|=
operator|new
name|byte
index|[
name|diffIdx
operator|+
literal|1
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|rightArray
argument_list|,
name|rightOffset
argument_list|,
name|minimumMidpointArray
argument_list|,
literal|0
argument_list|,
name|diffIdx
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|diffByte
init|=
name|leftArray
index|[
name|leftOffset
operator|+
name|diffIdx
index|]
decl_stmt|;
if|if
condition|(
operator|(
literal|0xff
operator|&
name|diffByte
operator|)
operator|<
literal|0xff
operator|&&
operator|(
name|diffByte
operator|+
literal|1
operator|)
operator|<
operator|(
name|rightArray
index|[
name|rightOffset
operator|+
name|diffIdx
index|]
operator|&
literal|0xff
operator|)
condition|)
block|{
name|minimumMidpointArray
operator|=
operator|new
name|byte
index|[
name|diffIdx
operator|+
literal|1
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|leftArray
argument_list|,
name|leftOffset
argument_list|,
name|minimumMidpointArray
argument_list|,
literal|0
argument_list|,
name|diffIdx
argument_list|)
expr_stmt|;
name|minimumMidpointArray
index|[
name|diffIdx
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|diffByte
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|minimumMidpointArray
operator|=
operator|new
name|byte
index|[
name|diffIdx
operator|+
literal|1
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|rightArray
argument_list|,
name|rightOffset
argument_list|,
name|minimumMidpointArray
argument_list|,
literal|0
argument_list|,
name|diffIdx
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|minimumMidpointArray
return|;
block|}
block|}
end_class

end_unit

