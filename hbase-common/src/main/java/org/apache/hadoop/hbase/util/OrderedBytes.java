begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Order
operator|.
name|ASCENDING
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Order
operator|.
name|DESCENDING
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|MathContext
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|RoundingMode
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * Utility class that handles ordered byte arrays. That is, unlike  * {@link Bytes}, these methods produce byte arrays which maintain the sort  * order of the original values.  *<h3>Encoding Format summary</h3>  *<p>  * Each value is encoded as one or more bytes. The first byte of the encoding,  * its meaning, and a terse description of the bytes that follow is given by  * the following table:  *<table>  *<tr><th>Content Type</th><th>Encoding</th></tr>  *<tr><td>NULL</td><td>0x05</td></tr>  *<tr><td>negative infinity</td><td>0x07</td></tr>  *<tr><td>negative large</td><td>0x08, ~E, ~M</td></tr>  *<tr><td>negative medium</td><td>0x13-E, ~M</td></tr>  *<tr><td>negative small</td><td>0x14, -E, ~M</td></tr>  *<tr><td>zero</td><td>0x15</td></tr>  *<tr><td>positive small</td><td>0x16, ~-E, M</td></tr>  *<tr><td>positive medium</td><td>0x17+E, M</td></tr>  *<tr><td>positive large</td><td>0x22, E, M</td></tr>  *<tr><td>positive infinity</td><td>0x23</td></tr>  *<tr><td>NaN</td><td>0x25</td></tr>  *<tr><td>fixed-length 32-bit integer</td><td>0x27, I</td></tr>  *<tr><td>fixed-length 64-bit integer</td><td>0x28, I</td></tr>  *<tr><td>fixed-length 32-bit float</td><td>0x30, F</td></tr>  *<tr><td>fixed-length 64-bit float</td><td>0x31, F</td></tr>  *<tr><td>TEXT</td><td>0x33, T</td></tr>  *<tr><td>variable length BLOB</td><td>0x35, B</td></tr>  *<tr><td>byte-for-byte BLOB</td><td>0x36, X</td></tr>  *</table>  *</p>  *  *<h3>Null Encoding</h3>  *<p>  * Each value that is a NULL encodes as a single byte of 0x05. Since every  * other value encoding begins with a byte greater than 0x05, this forces NULL  * values to sort first.  *</p>  *<h3>Text Encoding</h3>  *<p>  * Each text value begins with a single byte of 0x33 and ends with a single  * byte of 0x00. There are zero or more intervening bytes that encode the text  * value. The intervening bytes are chosen so that the encoding will sort in  * the desired collating order. The intervening bytes may not contain a 0x00  * character; the only 0x00 byte allowed in a text encoding is the final byte.  *</p>  *<p>  * The text encoding ends in 0x00 in order to ensure that when there are two  * strings where one is a prefix of the other that the shorter string will  * sort first.  *</p>  *<h3>Binary Encoding</h3>  *<p>  * There are two encoding strategies for binary fields, referred to as  * "BlobVar" and "BlobCopy". BlobVar is less efficient in both space and  * encoding time. It has no limitations on the range of encoded values.  * BlobCopy is a byte-for-byte copy of the input data followed by a  * termination byte. It is extremely fast to encode and decode. It carries the  * restriction of not allowing a 0x00 value in the input byte[] as this value  * is used as the termination byte.  *</p>  *<h4>BlobVar</h4>  *<p>  * "BlobVar" encodes the input byte[] in a manner similar to a variable length  * integer encoding. As with the other {@code OrderedBytes} encodings,  * the first encoded byte is used to indicate what kind of value follows. This  * header byte is 0x37 for BlobVar encoded values. As with the traditional  * varint encoding, the most significant bit of each subsequent encoded  * {@code byte} is used as a continuation marker. The 7 remaining bits  * contain the 7 most significant bits of the first unencoded byte. The next  * encoded byte starts with a continuation marker in the MSB. The least  * significant bit from the first unencoded byte follows, and the remaining 6  * bits contain the 6 MSBs of the second unencoded byte. The encoding  * continues, encoding 7 bytes on to 8 encoded bytes. The MSB of the final  * encoded byte contains a termination marker rather than a continuation  * marker, and any remaining bits from the final input byte. Any trailing bits  * in the final encoded byte are zeros.  *</p>  *<h4>BlobCopy</h4>  *<p>  * "BlobCopy" is a simple byte-for-byte copy of the input data. It uses 0x38  * as the header byte, and is terminated by 0x00 in the DESCENDING case. This  * alternative encoding is faster and more space-efficient, but it cannot  * accept values containing a 0x00 byte in DESCENDING order.  *</p>  *<h3>Variable-length Numeric Encoding</h3>  *<p>  * Numeric values must be coded so as to sort in numeric order. We assume that  * numeric values can be both integer and floating point values. Clients must  * be careful to use inspection methods for encoded values (such as  * {@link #isNumericInfinite(PositionedByteRange)} and  * {@link #isNumericNaN(PositionedByteRange)} to protect against decoding  * values into object which do not support these numeric concepts (such as  * {@link Long} and {@link BigDecimal}).  *</p>  *<p>  * Simplest cases first: If the numeric value is a NaN, then the encoding is a  * single byte of 0x25. This causes NaN values to sort after every other  * numeric value.  *</p>  *<p>  * If the numeric value is a negative infinity then the encoding is a single  * byte of 0x07. Since every other numeric value except NaN has a larger  * initial byte, this encoding ensures that negative infinity will sort prior  * to every other numeric value other than NaN.  *</p>  *<p>  * If the numeric value is a positive infinity then the encoding is a single  * byte of 0x23. Every other numeric value encoding begins with a smaller  * byte, ensuring that positive infinity always sorts last among numeric  * values. 0x23 is also smaller than 0x33, the initial byte of a text value,  * ensuring that every numeric value sorts before every text value.  *</p>  *<p>  * If the numeric value is exactly zero then it is encoded as a single byte of  * 0x15. Finite negative values will have initial bytes of 0x08 through 0x14  * and finite positive values will have initial bytes of 0x16 through 0x22.  *</p>  *<p>  * For all numeric values, we compute a mantissa M and an exponent E. The  * mantissa is a base-100 representation of the value. The exponent E  * determines where to put the decimal point.  *</p>  *<p>  * Each centimal digit of the mantissa is stored in a byte. If the value of  * the centimal digit is X (hence X&ge;0 and X&le;99) then the byte value will  * be 2*X+1 for every byte of the mantissa, except for the last byte which  * will be 2*X+0. The mantissa must be the minimum number of bytes necessary  * to represent the value; trailing X==0 digits are omitted. This means that  * the mantissa will never contain a byte with the value 0x00.  *</p>  *<p>  * If we assume all digits of the mantissa occur to the right of the decimal  * point, then the exponent E is the power of one hundred by which one must  * multiply the mantissa to recover the original value.  *</p>  *<p>  * Values are classified as large, medium, or small according to the value of  * E. If E is 11 or more, the value is large. For E between 0 and 10, the  * value is medium. For E less than zero, the value is small.  *</p>  *<p>  * Large positive values are encoded as a single byte 0x22 followed by E as a  * varint and then M. Medium positive values are a single byte of 0x17+E  * followed by M. Small positive values are encoded as a single byte 0x16  * followed by the ones-complement of the varint for -E followed by M.  *</p>  *<p>  * Small negative values are encoded as a single byte 0x14 followed by -E as a  * varint and then the ones-complement of M. Medium negative values are  * encoded as a byte 0x13-E followed by the ones-complement of M. Large  * negative values consist of the single byte 0x08 followed by the  * ones-complement of the varint encoding of E followed by the ones-complement  * of M.  *</p>  *<h3>Fixed-length Integer Encoding</h3>  *<p>  * All 4-byte integers are serialized to a 5-byte, fixed-width, sortable byte  * format. All 8-byte integers are serialized to the equivelant 9-byte format.  * Serialization is performed by writing a header byte, inverting the integer  * sign bit and writing the resulting bytes to the byte array in big endian  * order.  *</p>  *<h3>Fixed-length Floating Point Encoding</h3>  *<p>  * 32-bit and 64-bit floating point numbers are encoded to a 5-byte and 9-byte  * encoding format, respectively. The format is identical, save for the  * precision respected in each step of the operation.  *<p>  * This format ensures the following total ordering of floating point values:  * Float.NEGATIVE_INFINITY&lt; -Float.MAX_VALUE&lt; ...&lt;  * -Float.MIN_VALUE&lt; -0.0&lt; +0.0;&lt; Float.MIN_VALUE&lt; ...&lt;  * Float.MAX_VALUE&lt; Float.POSITIVE_INFINITY&lt; Float.NaN  *</p>  *<p>  * Floating point numbers are encoded as specified in IEEE 754. A 32-bit  * single precision float consists of a sign bit, 8-bit unsigned exponent  * encoded in offset-127 notation, and a 23-bit significand. The format is  * described further in the<a  * href="http://en.wikipedia.org/wiki/Single_precision"> Single Precision  * Floating Point Wikipedia page</a>  *</p>  *<p>  * The value of a normal float is -1<sup>sign bit</sup>&times;  * 2<sup>exponent - 127</sup>&times; 1.significand  *</p>  *<p>  * The IEE754 floating point format already preserves sort ordering for  * positive floating point numbers when the raw bytes are compared in most  * significant byte order. This is discussed further at<a href=  * "http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm">  * http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm</a>  *</p>  *<p>  * Thus, we need only ensure that negative numbers sort in the the exact  * opposite order as positive numbers (so that say, negative infinity is less  * than negative 1), and that all negative numbers compare less than any  * positive number. To accomplish this, we invert the sign bit of all floating  * point numbers, and we also invert the exponent and significand bits if the  * floating point number was negative.  *</p>  *<p>  * More specifically, we first store the floating point bits into a 32-bit int  * {@code j} using {@link Float#floatToIntBits}. This method collapses  * all NaNs into a single, canonical NaN value but otherwise leaves the bits  * unchanged. We then compute  *</p>  *  *<pre>  * j&circ;= (j&gt;&gt; (Integer.SIZE - 1)) | Integer.MIN_SIZE  *</pre>  *<p>  * which inverts the sign bit and XOR's all other bits with the sign bit  * itself. Comparing the raw bytes of {@code j} in most significant byte  * order is equivalent to performing a single precision floating point  * comparison on the underlying bits (ignoring NaN comparisons, as NaNs don't  * compare equal to anything when performing floating point comparisons).  *</p>  *<p>  * The resulting integer is then converted into a byte array by serializing  * the integer one byte at a time in most significant byte order. The  * serialized integer is prefixed by a single header byte. All serialized  * values are 5 bytes in length.  *</p>  *<p>  * {@code OrderedBytes} encodings are heavily influenced by the<a href="  * http://sqlite.org/src4/doc/trunk/www/key_encoding.wiki">SQLite4 Key  * Encoding</a>. Slight deviations are make in the interest of order  * correctness and user extensibility. Fixed-width {@code Long} and  * {@link Double} encodings are based on implementations from the now defunct  * Orderly library.  *</p>  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
class|class
name|OrderedBytes
block|{
comment|/*    * These constants define header bytes used to identify encoded values. Note    * that the values here are not exhaustive as the Numeric format encodes    * portions of its value within the header byte. The values listed here are    * directly applied to persisted data -- DO NOT modify the values specified    * here. Instead, gaps are placed intentionally between values so that new    * implementations can be inserted into the total ordering enforced here.    */
specifier|private
specifier|static
specifier|final
name|byte
name|NULL
init|=
literal|0x05
decl_stmt|;
comment|// room for 1 expansion type
specifier|private
specifier|static
specifier|final
name|byte
name|NEG_INF
init|=
literal|0x07
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
name|NEG_LARGE
init|=
literal|0x08
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
name|NEG_MED_MIN
init|=
literal|0x09
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
name|NEG_MED_MAX
init|=
literal|0x13
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
name|NEG_SMALL
init|=
literal|0x14
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
name|ZERO
init|=
literal|0x15
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
name|POS_SMALL
init|=
literal|0x16
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
name|POS_MED_MIN
init|=
literal|0x17
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
name|POS_MED_MAX
init|=
literal|0x21
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
name|POS_LARGE
init|=
literal|0x22
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
name|POS_INF
init|=
literal|0x23
decl_stmt|;
comment|// room for 2 expansion type
specifier|private
specifier|static
specifier|final
name|byte
name|NAN
init|=
literal|0x26
decl_stmt|;
comment|// room for 2 expansion types
specifier|private
specifier|static
specifier|final
name|byte
name|FIXED_INT8
init|=
literal|0x29
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
name|FIXED_INT16
init|=
literal|0x2a
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
name|FIXED_INT32
init|=
literal|0x2b
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
name|FIXED_INT64
init|=
literal|0x2c
decl_stmt|;
comment|// room for 3 expansion types
specifier|private
specifier|static
specifier|final
name|byte
name|FIXED_FLOAT32
init|=
literal|0x30
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
name|FIXED_FLOAT64
init|=
literal|0x31
decl_stmt|;
comment|// room for 2 expansion type
specifier|private
specifier|static
specifier|final
name|byte
name|TEXT
init|=
literal|0x34
decl_stmt|;
comment|// room for 2 expansion type
specifier|private
specifier|static
specifier|final
name|byte
name|BLOB_VAR
init|=
literal|0x37
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
name|BLOB_COPY
init|=
literal|0x38
decl_stmt|;
comment|/*    * The following constant values are used by encoding implementations    */
specifier|public
specifier|static
specifier|final
name|Charset
name|UTF8
init|=
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-8"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
name|TERM
init|=
literal|0x00
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|BigDecimal
name|E8
init|=
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|1e8
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|BigDecimal
name|E32
init|=
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|1e32
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|BigDecimal
name|EN2
init|=
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|1e-2
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|BigDecimal
name|EN10
init|=
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|1e-10
argument_list|)
decl_stmt|;
comment|/**    * Max precision guaranteed to fit into a {@code long}.    */
specifier|public
specifier|static
specifier|final
name|int
name|MAX_PRECISION
init|=
literal|31
decl_stmt|;
comment|/**    * The context used to normalize {@link BigDecimal} values.    */
specifier|public
specifier|static
specifier|final
name|MathContext
name|DEFAULT_MATH_CONTEXT
init|=
operator|new
name|MathContext
argument_list|(
name|MAX_PRECISION
argument_list|,
name|RoundingMode
operator|.
name|HALF_UP
argument_list|)
decl_stmt|;
comment|/**    * Creates the standard exception when the encoded header byte is unexpected for the decoding    * context.    * @param header value used in error message.    */
specifier|private
specifier|static
name|IllegalArgumentException
name|unexpectedHeader
parameter_list|(
name|byte
name|header
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"unexpected value in first byte: 0x"
operator|+
name|Long
operator|.
name|toHexString
argument_list|(
name|header
argument_list|)
argument_list|)
throw|;
block|}
comment|/**    * Perform unsigned comparison between two long values. Conforms to the same interface as    * {@link Comparator#compare(Object, Object)}.    */
specifier|private
specifier|static
name|int
name|unsignedCmp
parameter_list|(
name|long
name|x1
parameter_list|,
name|long
name|x2
parameter_list|)
block|{
name|int
name|cmp
decl_stmt|;
if|if
condition|(
operator|(
name|cmp
operator|=
operator|(
name|x1
operator|<
name|x2
condition|?
operator|-
literal|1
else|:
operator|(
name|x1
operator|==
name|x2
condition|?
literal|0
else|:
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|// invert the result when either value is negative
if|if
condition|(
operator|(
name|x1
operator|<
literal|0
operator|)
operator|!=
operator|(
name|x2
operator|<
literal|0
operator|)
condition|)
return|return
operator|-
name|cmp
return|;
return|return
name|cmp
return|;
block|}
comment|/**    * Write a 32-bit unsigned integer to {@code dst} as 4 big-endian bytes.    * @return number of bytes written.    */
specifier|private
specifier|static
name|int
name|putUint32
parameter_list|(
name|PositionedByteRange
name|dst
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|dst
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|val
operator|>>>
literal|24
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|val
operator|>>>
literal|16
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|val
operator|>>>
literal|8
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
operator|(
name|byte
operator|)
name|val
argument_list|)
expr_stmt|;
return|return
literal|4
return|;
block|}
comment|/**    * Encode an unsigned 64-bit unsigned integer {@code val} into {@code dst}.    * @param dst The destination to which encoded bytes are written.    * @param val The value to write.    * @param comp Compliment the encoded value when {@code comp} is true.    * @return number of bytes written.    */
annotation|@
name|VisibleForTesting
specifier|static
name|int
name|putVaruint64
parameter_list|(
name|PositionedByteRange
name|dst
parameter_list|,
name|long
name|val
parameter_list|,
name|boolean
name|comp
parameter_list|)
block|{
name|int
name|w
decl_stmt|,
name|y
decl_stmt|,
name|len
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|offset
init|=
name|dst
operator|.
name|getOffset
argument_list|()
decl_stmt|,
name|start
init|=
name|dst
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|byte
index|[]
name|a
init|=
name|dst
operator|.
name|getBytes
argument_list|()
decl_stmt|;
name|Order
name|ord
init|=
name|comp
condition|?
name|DESCENDING
else|:
name|ASCENDING
decl_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|unsignedCmp
argument_list|(
name|val
argument_list|,
literal|241L
argument_list|)
condition|)
block|{
name|dst
operator|.
name|put
argument_list|(
operator|(
name|byte
operator|)
name|val
argument_list|)
expr_stmt|;
name|len
operator|=
name|dst
operator|.
name|getPosition
argument_list|()
operator|-
name|start
expr_stmt|;
name|ord
operator|.
name|apply
argument_list|(
name|a
argument_list|,
name|offset
operator|+
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
if|if
condition|(
operator|-
literal|1
operator|==
name|unsignedCmp
argument_list|(
name|val
argument_list|,
literal|2288L
argument_list|)
condition|)
block|{
name|y
operator|=
call|(
name|int
call|)
argument_list|(
name|val
operator|-
literal|240
argument_list|)
expr_stmt|;
name|dst
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|y
operator|/
literal|256
operator|+
literal|241
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|y
operator|%
literal|256
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|dst
operator|.
name|getPosition
argument_list|()
operator|-
name|start
expr_stmt|;
name|ord
operator|.
name|apply
argument_list|(
name|a
argument_list|,
name|offset
operator|+
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
if|if
condition|(
operator|-
literal|1
operator|==
name|unsignedCmp
argument_list|(
name|val
argument_list|,
literal|67824L
argument_list|)
condition|)
block|{
name|y
operator|=
call|(
name|int
call|)
argument_list|(
name|val
operator|-
literal|2288
argument_list|)
expr_stmt|;
name|dst
operator|.
name|put
argument_list|(
operator|(
name|byte
operator|)
literal|249
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|y
operator|/
literal|256
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|y
operator|%
literal|256
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|dst
operator|.
name|getPosition
argument_list|()
operator|-
name|start
expr_stmt|;
name|ord
operator|.
name|apply
argument_list|(
name|a
argument_list|,
name|offset
operator|+
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
name|y
operator|=
operator|(
name|int
operator|)
name|val
expr_stmt|;
name|w
operator|=
call|(
name|int
call|)
argument_list|(
name|val
operator|>>>
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|-
literal|1
operator|==
name|unsignedCmp
argument_list|(
name|y
argument_list|,
literal|16777216L
argument_list|)
condition|)
block|{
name|dst
operator|.
name|put
argument_list|(
operator|(
name|byte
operator|)
literal|250
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|y
operator|>>>
literal|16
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|y
operator|>>>
literal|8
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
operator|(
name|byte
operator|)
name|y
argument_list|)
expr_stmt|;
name|len
operator|=
name|dst
operator|.
name|getPosition
argument_list|()
operator|-
name|start
expr_stmt|;
name|ord
operator|.
name|apply
argument_list|(
name|a
argument_list|,
name|offset
operator|+
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
name|dst
operator|.
name|put
argument_list|(
operator|(
name|byte
operator|)
literal|251
argument_list|)
expr_stmt|;
name|putUint32
argument_list|(
name|dst
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|len
operator|=
name|dst
operator|.
name|getPosition
argument_list|()
operator|-
name|start
expr_stmt|;
name|ord
operator|.
name|apply
argument_list|(
name|a
argument_list|,
name|offset
operator|+
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
if|if
condition|(
operator|-
literal|1
operator|==
name|unsignedCmp
argument_list|(
name|w
argument_list|,
literal|256L
argument_list|)
condition|)
block|{
name|dst
operator|.
name|put
argument_list|(
operator|(
name|byte
operator|)
literal|252
argument_list|)
operator|.
name|put
argument_list|(
operator|(
name|byte
operator|)
name|w
argument_list|)
expr_stmt|;
name|putUint32
argument_list|(
name|dst
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|len
operator|=
name|dst
operator|.
name|getPosition
argument_list|()
operator|-
name|start
expr_stmt|;
name|ord
operator|.
name|apply
argument_list|(
name|a
argument_list|,
name|offset
operator|+
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
if|if
condition|(
operator|-
literal|1
operator|==
name|unsignedCmp
argument_list|(
name|w
argument_list|,
literal|65536L
argument_list|)
condition|)
block|{
name|dst
operator|.
name|put
argument_list|(
operator|(
name|byte
operator|)
literal|253
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|w
operator|>>>
literal|8
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
operator|(
name|byte
operator|)
name|w
argument_list|)
expr_stmt|;
name|putUint32
argument_list|(
name|dst
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|len
operator|=
name|dst
operator|.
name|getPosition
argument_list|()
operator|-
name|start
expr_stmt|;
name|ord
operator|.
name|apply
argument_list|(
name|a
argument_list|,
name|offset
operator|+
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
if|if
condition|(
operator|-
literal|1
operator|==
name|unsignedCmp
argument_list|(
name|w
argument_list|,
literal|16777216L
argument_list|)
condition|)
block|{
name|dst
operator|.
name|put
argument_list|(
operator|(
name|byte
operator|)
literal|254
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|w
operator|>>>
literal|16
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|w
operator|>>>
literal|8
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
operator|(
name|byte
operator|)
name|w
argument_list|)
expr_stmt|;
name|putUint32
argument_list|(
name|dst
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|len
operator|=
name|dst
operator|.
name|getPosition
argument_list|()
operator|-
name|start
expr_stmt|;
name|ord
operator|.
name|apply
argument_list|(
name|a
argument_list|,
name|offset
operator|+
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
name|dst
operator|.
name|put
argument_list|(
operator|(
name|byte
operator|)
literal|255
argument_list|)
expr_stmt|;
name|putUint32
argument_list|(
name|dst
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|putUint32
argument_list|(
name|dst
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|len
operator|=
name|dst
operator|.
name|getPosition
argument_list|()
operator|-
name|start
expr_stmt|;
name|ord
operator|.
name|apply
argument_list|(
name|a
argument_list|,
name|offset
operator|+
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
comment|/**    * Inspect {@code src} for an encoded varuint64 for its length in bytes.    * Preserves the state of {@code src}.    * @param src source buffer    * @param comp if true, parse the compliment of the value.    * @return the number of bytes consumed by this value.    */
annotation|@
name|VisibleForTesting
specifier|static
name|int
name|lengthVaruint64
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|,
name|boolean
name|comp
parameter_list|)
block|{
name|int
name|a0
init|=
operator|(
name|comp
condition|?
name|DESCENDING
else|:
name|ASCENDING
operator|)
operator|.
name|apply
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
name|a0
operator|<=
literal|240
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|a0
operator|>=
literal|241
operator|&&
name|a0
operator|<=
literal|248
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|a0
operator|==
literal|249
condition|)
return|return
literal|3
return|;
if|if
condition|(
name|a0
operator|==
literal|250
condition|)
return|return
literal|4
return|;
if|if
condition|(
name|a0
operator|==
literal|251
condition|)
return|return
literal|5
return|;
if|if
condition|(
name|a0
operator|==
literal|252
condition|)
return|return
literal|6
return|;
if|if
condition|(
name|a0
operator|==
literal|253
condition|)
return|return
literal|7
return|;
if|if
condition|(
name|a0
operator|==
literal|254
condition|)
return|return
literal|8
return|;
if|if
condition|(
name|a0
operator|==
literal|255
condition|)
return|return
literal|9
return|;
throw|throw
name|unexpectedHeader
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
throw|;
block|}
comment|/**    * Skip {@code src} over the encoded varuint64.    * @param src source buffer    * @param cmp if true, parse the compliment of the value.    * @return the number of bytes skipped.    */
annotation|@
name|VisibleForTesting
specifier|static
name|int
name|skipVaruint64
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|,
name|boolean
name|cmp
parameter_list|)
block|{
specifier|final
name|int
name|len
init|=
name|lengthVaruint64
argument_list|(
name|src
argument_list|,
name|cmp
argument_list|)
decl_stmt|;
name|src
operator|.
name|setPosition
argument_list|(
name|src
operator|.
name|getPosition
argument_list|()
operator|+
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
comment|/**    * Decode a sequence of bytes in {@code src} as a varuint64. Compliment the    * encoded value when {@code comp} is true.    * @return the decoded value.    */
annotation|@
name|VisibleForTesting
specifier|static
name|long
name|getVaruint64
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|,
name|boolean
name|comp
parameter_list|)
block|{
assert|assert
name|src
operator|.
name|getRemaining
argument_list|()
operator|>=
name|lengthVaruint64
argument_list|(
name|src
argument_list|,
name|comp
argument_list|)
assert|;
specifier|final
name|long
name|ret
decl_stmt|;
name|Order
name|ord
init|=
name|comp
condition|?
name|DESCENDING
else|:
name|ASCENDING
decl_stmt|;
name|byte
name|x
init|=
name|src
operator|.
name|get
argument_list|()
decl_stmt|;
specifier|final
name|int
name|a0
init|=
name|ord
operator|.
name|apply
argument_list|(
name|x
argument_list|)
operator|&
literal|0xff
decl_stmt|,
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|,
name|a4
decl_stmt|,
name|a5
decl_stmt|,
name|a6
decl_stmt|,
name|a7
decl_stmt|,
name|a8
decl_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|unsignedCmp
argument_list|(
name|a0
argument_list|,
literal|241
argument_list|)
condition|)
block|{
return|return
name|a0
return|;
block|}
name|x
operator|=
name|src
operator|.
name|get
argument_list|()
expr_stmt|;
name|a1
operator|=
name|ord
operator|.
name|apply
argument_list|(
name|x
argument_list|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|unsignedCmp
argument_list|(
name|a0
argument_list|,
literal|249
argument_list|)
condition|)
block|{
return|return
operator|(
name|a0
operator|-
literal|241
operator|)
operator|*
literal|256
operator|+
name|a1
operator|+
literal|240
return|;
block|}
name|x
operator|=
name|src
operator|.
name|get
argument_list|()
expr_stmt|;
name|a2
operator|=
name|ord
operator|.
name|apply
argument_list|(
name|x
argument_list|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|a0
operator|==
literal|249
condition|)
block|{
return|return
literal|2288
operator|+
literal|256
operator|*
name|a1
operator|+
name|a2
return|;
block|}
name|x
operator|=
name|src
operator|.
name|get
argument_list|()
expr_stmt|;
name|a3
operator|=
name|ord
operator|.
name|apply
argument_list|(
name|x
argument_list|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|a0
operator|==
literal|250
condition|)
block|{
return|return
operator|(
name|a1
operator|<<
literal|16
operator|)
operator||
operator|(
name|a2
operator|<<
literal|8
operator|)
operator||
name|a3
return|;
block|}
name|x
operator|=
name|src
operator|.
name|get
argument_list|()
expr_stmt|;
name|a4
operator|=
name|ord
operator|.
name|apply
argument_list|(
name|x
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|ret
operator|=
operator|(
operator|(
operator|(
name|long
operator|)
name|a1
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
name|a2
operator|<<
literal|16
operator|)
operator||
operator|(
name|a3
operator|<<
literal|8
operator|)
operator||
name|a4
expr_stmt|;
if|if
condition|(
name|a0
operator|==
literal|251
condition|)
block|{
return|return
name|ret
return|;
block|}
name|x
operator|=
name|src
operator|.
name|get
argument_list|()
expr_stmt|;
name|a5
operator|=
name|ord
operator|.
name|apply
argument_list|(
name|x
argument_list|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|a0
operator|==
literal|252
condition|)
block|{
return|return
operator|(
name|ret
operator|<<
literal|8
operator|)
operator||
name|a5
return|;
block|}
name|x
operator|=
name|src
operator|.
name|get
argument_list|()
expr_stmt|;
name|a6
operator|=
name|ord
operator|.
name|apply
argument_list|(
name|x
argument_list|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|a0
operator|==
literal|253
condition|)
block|{
return|return
operator|(
name|ret
operator|<<
literal|16
operator|)
operator||
operator|(
name|a5
operator|<<
literal|8
operator|)
operator||
name|a6
return|;
block|}
name|x
operator|=
name|src
operator|.
name|get
argument_list|()
expr_stmt|;
name|a7
operator|=
name|ord
operator|.
name|apply
argument_list|(
name|x
argument_list|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|a0
operator|==
literal|254
condition|)
block|{
return|return
operator|(
name|ret
operator|<<
literal|24
operator|)
operator||
operator|(
name|a5
operator|<<
literal|16
operator|)
operator||
operator|(
name|a6
operator|<<
literal|8
operator|)
operator||
name|a7
return|;
block|}
name|x
operator|=
name|src
operator|.
name|get
argument_list|()
expr_stmt|;
name|a8
operator|=
name|ord
operator|.
name|apply
argument_list|(
name|x
argument_list|)
operator|&
literal|0xff
expr_stmt|;
return|return
operator|(
name|ret
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
operator|(
name|long
operator|)
name|a5
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
name|a6
operator|<<
literal|16
operator|)
operator||
operator|(
name|a7
operator|<<
literal|8
operator|)
operator||
name|a8
return|;
block|}
comment|/**    * Strip all trailing zeros to ensure that no digit will be zero and round    * using our default context to ensure precision doesn't exceed max allowed.    * From Phoenix's {@code NumberUtil}.    * @return new {@link BigDecimal} instance    */
annotation|@
name|VisibleForTesting
specifier|static
name|BigDecimal
name|normalize
parameter_list|(
name|BigDecimal
name|val
parameter_list|)
block|{
return|return
literal|null
operator|==
name|val
condition|?
literal|null
else|:
name|val
operator|.
name|stripTrailingZeros
argument_list|()
operator|.
name|round
argument_list|(
name|DEFAULT_MATH_CONTEXT
argument_list|)
return|;
block|}
comment|/**    * Read significand digits from {@code src} according to the magnitude    * of {@code e}.    * @param src The source from which to read encoded digits.    * @param e The magnitude of the first digit read.    * @param comp Treat encoded bytes as compliments when {@code comp} is true.    * @return The decoded value.    * @throws IllegalArgumentException when read exceeds the remaining length    *     of {@code src}.    */
specifier|private
specifier|static
name|BigDecimal
name|decodeSignificand
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|,
name|int
name|e
parameter_list|,
name|boolean
name|comp
parameter_list|)
block|{
comment|// TODO: can this be made faster?
name|byte
index|[]
name|a
init|=
name|src
operator|.
name|getBytes
argument_list|()
decl_stmt|;
specifier|final
name|int
name|start
init|=
name|src
operator|.
name|getPosition
argument_list|()
decl_stmt|,
name|offset
init|=
name|src
operator|.
name|getOffset
argument_list|()
decl_stmt|,
name|remaining
init|=
name|src
operator|.
name|getRemaining
argument_list|()
decl_stmt|;
name|Order
name|ord
init|=
name|comp
condition|?
name|DESCENDING
else|:
name|ASCENDING
decl_stmt|;
name|BigDecimal
name|m
init|=
name|BigDecimal
operator|.
name|ZERO
decl_stmt|;
name|e
operator|--
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
name|remaining
condition|)
block|{
comment|// we've exceeded this range's window
name|src
operator|.
name|setPosition
argument_list|(
name|start
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Read exceeds range before termination byte found. offset: "
operator|+
name|offset
operator|+
literal|" position: "
operator|+
operator|(
name|start
operator|+
name|i
operator|)
argument_list|)
throw|;
block|}
comment|// base-100 digits are encoded as val * 2 + 1 except for the termination digit.
name|m
operator|=
name|m
operator|.
name|add
argument_list|(
comment|// m +=
operator|new
name|BigDecimal
argument_list|(
name|BigInteger
operator|.
name|ONE
argument_list|,
name|e
operator|*
operator|-
literal|2
argument_list|)
operator|.
name|multiply
argument_list|(
comment|// 100 ^ p * [decoded digit]
name|BigDecimal
operator|.
name|valueOf
argument_list|(
operator|(
name|ord
operator|.
name|apply
argument_list|(
name|a
index|[
name|offset
operator|+
name|start
operator|+
name|i
index|]
argument_list|)
operator|&
literal|0xff
operator|)
operator|/
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|--
expr_stmt|;
comment|// detect termination digit
if|if
condition|(
operator|(
name|ord
operator|.
name|apply
argument_list|(
name|a
index|[
name|offset
operator|+
name|start
operator|+
name|i
index|]
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|src
operator|.
name|setPosition
argument_list|(
name|start
operator|+
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|normalize
argument_list|(
name|m
argument_list|)
return|;
block|}
comment|/**    * Skip {@code src} over the significand bytes.    * @param src The source from which to read encoded digits.    * @param comp Treat encoded bytes as compliments when {@code comp} is true.    * @return the number of bytes skipped.    */
specifier|private
specifier|static
name|int
name|skipSignificand
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|,
name|boolean
name|comp
parameter_list|)
block|{
name|byte
index|[]
name|a
init|=
name|src
operator|.
name|getBytes
argument_list|()
decl_stmt|;
specifier|final
name|int
name|offset
init|=
name|src
operator|.
name|getOffset
argument_list|()
decl_stmt|,
name|start
init|=
name|src
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|int
name|i
init|=
name|src
operator|.
name|getPosition
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
operator|(
name|comp
condition|?
name|DESCENDING
else|:
name|ASCENDING
operator|)
operator|.
name|apply
argument_list|(
name|a
index|[
name|offset
operator|+
name|i
operator|++
index|]
argument_list|)
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
empty_stmt|;
name|src
operator|.
name|setPosition
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
name|i
operator|-
name|start
return|;
block|}
comment|/**    *<p>    * Encode the small magnitude floating point number {@code val} using the    * key encoding. The caller guarantees that 1.0> abs(val)> 0.0.    *</p>    *<p>    * A floating point value is encoded as an integer exponent {@code E} and a    * mantissa {@code M}. The original value is equal to {@code (M * 100^E)}.    * {@code E} is set to the smallest value possible without making {@code M}    * greater than or equal to 1.0.    *</p>    *<p>    * For this routine, {@code E} will always be zero or negative, since the    * original value is less than one. The encoding written by this routine is    * the ones-complement of the varint of the negative of {@code E} followed    * by the mantissa:    *<pre>    *   Encoding:   ~-E  M    *</pre>    *</p>    * @param dst The destination to which encoded digits are written.    * @param val The value to encode.    * @return the number of bytes written.    */
specifier|private
specifier|static
name|int
name|encodeNumericSmall
parameter_list|(
name|PositionedByteRange
name|dst
parameter_list|,
name|BigDecimal
name|val
parameter_list|)
block|{
comment|// TODO: this can be done faster?
comment|// assert 1.0> abs(val)> 0.0
name|BigDecimal
name|abs
init|=
name|val
operator|.
name|abs
argument_list|()
decl_stmt|;
assert|assert
name|BigDecimal
operator|.
name|ZERO
operator|.
name|compareTo
argument_list|(
name|abs
argument_list|)
operator|<
literal|0
operator|&&
name|BigDecimal
operator|.
name|ONE
operator|.
name|compareTo
argument_list|(
name|abs
argument_list|)
operator|>
literal|0
assert|;
name|byte
index|[]
name|a
init|=
name|dst
operator|.
name|getBytes
argument_list|()
decl_stmt|;
name|boolean
name|isNeg
init|=
name|val
operator|.
name|signum
argument_list|()
operator|==
operator|-
literal|1
decl_stmt|;
specifier|final
name|int
name|offset
init|=
name|dst
operator|.
name|getOffset
argument_list|()
decl_stmt|,
name|start
init|=
name|dst
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|int
name|e
init|=
literal|0
decl_stmt|,
name|d
decl_stmt|,
name|startM
decl_stmt|;
if|if
condition|(
name|isNeg
condition|)
block|{
comment|/* Small negative number: 0x14, -E, ~M */
name|dst
operator|.
name|put
argument_list|(
name|NEG_SMALL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Small positive number: 0x16, ~-E, M */
name|dst
operator|.
name|put
argument_list|(
name|POS_SMALL
argument_list|)
expr_stmt|;
block|}
comment|// normalize abs(val) to determine E
while|while
condition|(
name|abs
operator|.
name|compareTo
argument_list|(
name|EN10
argument_list|)
operator|<
literal|0
condition|)
block|{
name|abs
operator|=
name|abs
operator|.
name|movePointRight
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|e
operator|+=
literal|4
expr_stmt|;
block|}
while|while
condition|(
name|abs
operator|.
name|compareTo
argument_list|(
name|EN2
argument_list|)
operator|<
literal|0
condition|)
block|{
name|abs
operator|=
name|abs
operator|.
name|movePointRight
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|e
operator|++
expr_stmt|;
block|}
name|putVaruint64
argument_list|(
name|dst
argument_list|,
name|e
argument_list|,
operator|!
name|isNeg
argument_list|)
expr_stmt|;
comment|// encode appropriate E value.
comment|// encode M by peeling off centimal digits, encoding x as 2x+1
name|startM
operator|=
name|dst
operator|.
name|getPosition
argument_list|()
expr_stmt|;
comment|// TODO: 18 is an arbitrary encoding limit. Reevaluate once we have a better handling of
comment|// numeric scale.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|18
operator|&&
name|abs
operator|.
name|compareTo
argument_list|(
name|BigDecimal
operator|.
name|ZERO
argument_list|)
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|abs
operator|=
name|abs
operator|.
name|movePointRight
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|d
operator|=
name|abs
operator|.
name|intValue
argument_list|()
expr_stmt|;
name|dst
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
operator|(
literal|2
operator|*
name|d
operator|+
literal|1
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|abs
operator|=
name|abs
operator|.
name|subtract
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|a
index|[
name|offset
operator|+
name|dst
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
index|]
operator|&=
literal|0xfe
expr_stmt|;
comment|// terminal digit should be 2x
if|if
condition|(
name|isNeg
condition|)
block|{
comment|// negative values encoded as ~M
name|DESCENDING
operator|.
name|apply
argument_list|(
name|a
argument_list|,
name|offset
operator|+
name|startM
argument_list|,
name|dst
operator|.
name|getPosition
argument_list|()
operator|-
name|startM
argument_list|)
expr_stmt|;
block|}
return|return
name|dst
operator|.
name|getPosition
argument_list|()
operator|-
name|start
return|;
block|}
comment|/**    * Encode the large magnitude floating point number {@code val} using    * the key encoding. The caller guarantees that {@code val} will be    * finite and abs(val)>= 1.0.    *<p>    * A floating point value is encoded as an integer exponent {@code E}    * and a mantissa {@code M}. The original value is equal to    * {@code (M * 100^E)}. {@code E} is set to the smallest value    * possible without making {@code M} greater than or equal to 1.0.    *</p>    *<p>    * Each centimal digit of the mantissa is stored in a byte. If the value of    * the centimal digit is {@code X} (hence {@code X>=0} and    * {@code X<=99}) then the byte value will be {@code 2*X+1} for    * every byte of the mantissa, except for the last byte which will be    * {@code 2*X+0}. The mantissa must be the minimum number of bytes    * necessary to represent the value; trailing {@code X==0} digits are    * omitted. This means that the mantissa will never contain a byte with the    * value {@code 0x00}.    *</p>    *<p>    * If {@code E> 10}, then this routine writes of {@code E} as a    * varint followed by the mantissa as described above. Otherwise, if    * {@code E<= 10}, this routine only writes the mantissa and leaves    * the {@code E} value to be encoded as part of the opening byte of the    * field by the calling function.    *    *<pre>    *   Encoding:  M       (if E<=10)    *              E M     (if E>10)    *</pre>    *</p>    * @param dst The destination to which encoded digits are written.    * @param val The value to encode.    * @return the number of bytes written.    */
specifier|private
specifier|static
name|int
name|encodeNumericLarge
parameter_list|(
name|PositionedByteRange
name|dst
parameter_list|,
name|BigDecimal
name|val
parameter_list|)
block|{
comment|// TODO: this can be done faster
name|BigDecimal
name|abs
init|=
name|val
operator|.
name|abs
argument_list|()
decl_stmt|;
name|byte
index|[]
name|a
init|=
name|dst
operator|.
name|getBytes
argument_list|()
decl_stmt|;
name|boolean
name|isNeg
init|=
name|val
operator|.
name|signum
argument_list|()
operator|==
operator|-
literal|1
decl_stmt|;
specifier|final
name|int
name|start
init|=
name|dst
operator|.
name|getPosition
argument_list|()
decl_stmt|,
name|offset
init|=
name|dst
operator|.
name|getOffset
argument_list|()
decl_stmt|;
name|int
name|e
init|=
literal|0
decl_stmt|,
name|d
decl_stmt|,
name|startM
decl_stmt|;
if|if
condition|(
name|isNeg
condition|)
block|{
comment|/* Large negative number: 0x08, ~E, ~M */
name|dst
operator|.
name|put
argument_list|(
name|NEG_LARGE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Large positive number: 0x22, E, M */
name|dst
operator|.
name|put
argument_list|(
name|POS_LARGE
argument_list|)
expr_stmt|;
block|}
comment|// normalize abs(val) to determine E
while|while
condition|(
name|abs
operator|.
name|compareTo
argument_list|(
name|E32
argument_list|)
operator|>=
literal|0
operator|&&
name|e
operator|<=
literal|350
condition|)
block|{
name|abs
operator|=
name|abs
operator|.
name|movePointLeft
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|e
operator|+=
literal|16
expr_stmt|;
block|}
while|while
condition|(
name|abs
operator|.
name|compareTo
argument_list|(
name|E8
argument_list|)
operator|>=
literal|0
operator|&&
name|e
operator|<=
literal|350
condition|)
block|{
name|abs
operator|=
name|abs
operator|.
name|movePointLeft
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|e
operator|+=
literal|4
expr_stmt|;
block|}
while|while
condition|(
name|abs
operator|.
name|compareTo
argument_list|(
name|BigDecimal
operator|.
name|ONE
argument_list|)
operator|>=
literal|0
operator|&&
name|e
operator|<=
literal|350
condition|)
block|{
name|abs
operator|=
name|abs
operator|.
name|movePointLeft
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|e
operator|++
expr_stmt|;
block|}
comment|// encode appropriate header byte and/or E value.
if|if
condition|(
name|e
operator|>
literal|10
condition|)
block|{
comment|/* large number, write out {~,}E */
name|putVaruint64
argument_list|(
name|dst
argument_list|,
name|e
argument_list|,
name|isNeg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isNeg
condition|)
block|{
comment|/* Medium negative number: 0x13-E, ~M */
name|dst
operator|.
name|put
argument_list|(
name|start
argument_list|,
call|(
name|byte
call|)
argument_list|(
name|NEG_MED_MAX
operator|-
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Medium positive number: 0x17+E, M */
name|dst
operator|.
name|put
argument_list|(
name|start
argument_list|,
call|(
name|byte
call|)
argument_list|(
name|POS_MED_MIN
operator|+
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// encode M by peeling off centimal digits, encoding x as 2x+1
name|startM
operator|=
name|dst
operator|.
name|getPosition
argument_list|()
expr_stmt|;
comment|// TODO: 18 is an arbitrary encoding limit. Reevaluate once we have a better handling of
comment|// numeric scale.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|18
operator|&&
name|abs
operator|.
name|compareTo
argument_list|(
name|BigDecimal
operator|.
name|ZERO
argument_list|)
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|abs
operator|=
name|abs
operator|.
name|movePointRight
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|d
operator|=
name|abs
operator|.
name|intValue
argument_list|()
expr_stmt|;
name|dst
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
literal|2
operator|*
name|d
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|abs
operator|=
name|abs
operator|.
name|subtract
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|a
index|[
name|offset
operator|+
name|dst
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
index|]
operator|&=
literal|0xfe
expr_stmt|;
comment|// terminal digit should be 2x
if|if
condition|(
name|isNeg
condition|)
block|{
comment|// negative values encoded as ~M
name|DESCENDING
operator|.
name|apply
argument_list|(
name|a
argument_list|,
name|offset
operator|+
name|startM
argument_list|,
name|dst
operator|.
name|getPosition
argument_list|()
operator|-
name|startM
argument_list|)
expr_stmt|;
block|}
return|return
name|dst
operator|.
name|getPosition
argument_list|()
operator|-
name|start
return|;
block|}
comment|/**    * Encode a numerical value using the variable-length encoding.    * @param dst The destination to which encoded digits are written.    * @param val The value to encode.    * @param ord The {@link Order} to respect while encoding {@code val}.    * @return the number of bytes written.    */
specifier|public
specifier|static
name|int
name|encodeNumeric
parameter_list|(
name|PositionedByteRange
name|dst
parameter_list|,
name|long
name|val
parameter_list|,
name|Order
name|ord
parameter_list|)
block|{
return|return
name|encodeNumeric
argument_list|(
name|dst
argument_list|,
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|val
argument_list|)
argument_list|,
name|ord
argument_list|)
return|;
block|}
comment|/**    * Encode a numerical value using the variable-length encoding.    * @param dst The destination to which encoded digits are written.    * @param val The value to encode.    * @param ord The {@link Order} to respect while encoding {@code val}.    * @return the number of bytes written.    */
specifier|public
specifier|static
name|int
name|encodeNumeric
parameter_list|(
name|PositionedByteRange
name|dst
parameter_list|,
name|double
name|val
parameter_list|,
name|Order
name|ord
parameter_list|)
block|{
if|if
condition|(
name|val
operator|==
literal|0.0
condition|)
block|{
name|dst
operator|.
name|put
argument_list|(
name|ord
operator|.
name|apply
argument_list|(
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|Double
operator|.
name|isNaN
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|dst
operator|.
name|put
argument_list|(
name|ord
operator|.
name|apply
argument_list|(
name|NAN
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|val
operator|==
name|Double
operator|.
name|NEGATIVE_INFINITY
condition|)
block|{
name|dst
operator|.
name|put
argument_list|(
name|ord
operator|.
name|apply
argument_list|(
name|NEG_INF
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|val
operator|==
name|Double
operator|.
name|POSITIVE_INFINITY
condition|)
block|{
name|dst
operator|.
name|put
argument_list|(
name|ord
operator|.
name|apply
argument_list|(
name|POS_INF
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
name|encodeNumeric
argument_list|(
name|dst
argument_list|,
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|val
argument_list|)
argument_list|,
name|ord
argument_list|)
return|;
block|}
comment|/**    * Encode a numerical value using the variable-length encoding.    * @param dst The destination to which encoded digits are written.    * @param val The value to encode.    * @param ord The {@link Order} to respect while encoding {@code val}.    * @return the number of bytes written.    */
specifier|public
specifier|static
name|int
name|encodeNumeric
parameter_list|(
name|PositionedByteRange
name|dst
parameter_list|,
name|BigDecimal
name|val
parameter_list|,
name|Order
name|ord
parameter_list|)
block|{
specifier|final
name|int
name|len
decl_stmt|,
name|offset
init|=
name|dst
operator|.
name|getOffset
argument_list|()
decl_stmt|,
name|start
init|=
name|dst
operator|.
name|getPosition
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|val
condition|)
block|{
return|return
name|encodeNull
argument_list|(
name|dst
argument_list|,
name|ord
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|BigDecimal
operator|.
name|ZERO
operator|.
name|compareTo
argument_list|(
name|val
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dst
operator|.
name|put
argument_list|(
name|ord
operator|.
name|apply
argument_list|(
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|BigDecimal
name|abs
init|=
name|val
operator|.
name|abs
argument_list|()
decl_stmt|;
if|if
condition|(
name|BigDecimal
operator|.
name|ONE
operator|.
name|compareTo
argument_list|(
name|abs
argument_list|)
operator|<=
literal|0
condition|)
block|{
comment|// abs(v)>= 1.0
name|len
operator|=
name|encodeNumericLarge
argument_list|(
name|dst
argument_list|,
name|normalize
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// 1.0> abs(v)>= 0.0
name|len
operator|=
name|encodeNumericSmall
argument_list|(
name|dst
argument_list|,
name|normalize
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ord
operator|.
name|apply
argument_list|(
name|dst
operator|.
name|getBytes
argument_list|()
argument_list|,
name|offset
operator|+
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
comment|/**    * Decode a {@link BigDecimal} from {@code src}. Assumes {@code src} encodes    * a value in Numeric encoding and is within the valid range of    * {@link BigDecimal} values. {@link BigDecimal} does not support {@code NaN}    * or {@code Infinte} values.    * @see #decodeNumericAsDouble(PositionedByteRange)    */
specifier|private
specifier|static
name|BigDecimal
name|decodeNumericValue
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|)
block|{
specifier|final
name|int
name|e
decl_stmt|;
name|byte
name|header
init|=
name|src
operator|.
name|get
argument_list|()
decl_stmt|;
name|boolean
name|dsc
init|=
operator|-
literal|1
operator|==
name|Integer
operator|.
name|signum
argument_list|(
name|header
argument_list|)
decl_stmt|;
name|header
operator|=
name|dsc
condition|?
name|DESCENDING
operator|.
name|apply
argument_list|(
name|header
argument_list|)
else|:
name|header
expr_stmt|;
if|if
condition|(
name|header
operator|==
name|NULL
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|header
operator|==
name|NEG_LARGE
condition|)
block|{
comment|/* Large negative number: 0x08, ~E, ~M */
name|e
operator|=
operator|(
name|int
operator|)
name|getVaruint64
argument_list|(
name|src
argument_list|,
operator|!
name|dsc
argument_list|)
expr_stmt|;
return|return
name|decodeSignificand
argument_list|(
name|src
argument_list|,
name|e
argument_list|,
operator|!
name|dsc
argument_list|)
operator|.
name|negate
argument_list|()
return|;
block|}
if|if
condition|(
name|header
operator|>=
name|NEG_MED_MIN
operator|&&
name|header
operator|<=
name|NEG_MED_MAX
condition|)
block|{
comment|/* Medium negative number: 0x13-E, ~M */
name|e
operator|=
name|NEG_MED_MAX
operator|-
name|header
expr_stmt|;
return|return
name|decodeSignificand
argument_list|(
name|src
argument_list|,
name|e
argument_list|,
operator|!
name|dsc
argument_list|)
operator|.
name|negate
argument_list|()
return|;
block|}
if|if
condition|(
name|header
operator|==
name|NEG_SMALL
condition|)
block|{
comment|/* Small negative number: 0x14, -E, ~M */
name|e
operator|=
operator|(
name|int
operator|)
operator|-
name|getVaruint64
argument_list|(
name|src
argument_list|,
name|dsc
argument_list|)
expr_stmt|;
return|return
name|decodeSignificand
argument_list|(
name|src
argument_list|,
name|e
argument_list|,
operator|!
name|dsc
argument_list|)
operator|.
name|negate
argument_list|()
return|;
block|}
if|if
condition|(
name|header
operator|==
name|ZERO
condition|)
block|{
return|return
name|BigDecimal
operator|.
name|ZERO
return|;
block|}
if|if
condition|(
name|header
operator|==
name|POS_SMALL
condition|)
block|{
comment|/* Small positive number: 0x16, ~-E, M */
name|e
operator|=
operator|(
name|int
operator|)
operator|-
name|getVaruint64
argument_list|(
name|src
argument_list|,
operator|!
name|dsc
argument_list|)
expr_stmt|;
return|return
name|decodeSignificand
argument_list|(
name|src
argument_list|,
name|e
argument_list|,
name|dsc
argument_list|)
return|;
block|}
if|if
condition|(
name|header
operator|>=
name|POS_MED_MIN
operator|&&
name|header
operator|<=
name|POS_MED_MAX
condition|)
block|{
comment|/* Medium positive number: 0x17+E, M */
name|e
operator|=
name|header
operator|-
name|POS_MED_MIN
expr_stmt|;
return|return
name|decodeSignificand
argument_list|(
name|src
argument_list|,
name|e
argument_list|,
name|dsc
argument_list|)
return|;
block|}
if|if
condition|(
name|header
operator|==
name|POS_LARGE
condition|)
block|{
comment|/* Large positive number: 0x22, E, M */
name|e
operator|=
operator|(
name|int
operator|)
name|getVaruint64
argument_list|(
name|src
argument_list|,
name|dsc
argument_list|)
expr_stmt|;
return|return
name|decodeSignificand
argument_list|(
name|src
argument_list|,
name|e
argument_list|,
name|dsc
argument_list|)
return|;
block|}
throw|throw
name|unexpectedHeader
argument_list|(
name|header
argument_list|)
throw|;
block|}
comment|/**    * Decode a primitive {@code double} value from the Numeric encoding. Numeric    * encoding is based on {@link BigDecimal}; in the event the encoded value is    * larger than can be represented in a {@code double}, this method performs    * an implicit narrowing conversion as described in    * {@link BigDecimal#doubleValue()}.    * @throws NullPointerException when the encoded value is {@code NULL}.    * @throws IllegalArgumentException when the encoded value is not a Numeric.    * @see #encodeNumeric(PositionedByteRange, double, Order)    * @see BigDecimal#doubleValue()    */
specifier|public
specifier|static
name|double
name|decodeNumericAsDouble
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|)
block|{
comment|// TODO: should an encoded NULL value throw unexpectedHeader() instead?
if|if
condition|(
name|isNull
argument_list|(
name|src
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"A null value cannot be decoded to a double."
argument_list|)
throw|;
block|}
if|if
condition|(
name|isNumericNaN
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|src
operator|.
name|get
argument_list|()
expr_stmt|;
return|return
name|Double
operator|.
name|NaN
return|;
block|}
if|if
condition|(
name|isNumericZero
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|src
operator|.
name|get
argument_list|()
expr_stmt|;
return|return
name|Double
operator|.
name|valueOf
argument_list|(
literal|0.0
argument_list|)
return|;
block|}
name|byte
name|header
init|=
operator|-
literal|1
operator|==
name|Integer
operator|.
name|signum
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
condition|?
name|DESCENDING
operator|.
name|apply
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
else|:
name|src
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|header
operator|==
name|NEG_INF
condition|)
block|{
name|src
operator|.
name|get
argument_list|()
expr_stmt|;
return|return
name|Double
operator|.
name|NEGATIVE_INFINITY
return|;
block|}
elseif|else
if|if
condition|(
name|header
operator|==
name|POS_INF
condition|)
block|{
name|src
operator|.
name|get
argument_list|()
expr_stmt|;
return|return
name|Double
operator|.
name|POSITIVE_INFINITY
return|;
block|}
else|else
block|{
return|return
name|decodeNumericValue
argument_list|(
name|src
argument_list|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
block|}
comment|/**    * Decode a primitive {@code long} value from the Numeric encoding. Numeric    * encoding is based on {@link BigDecimal}; in the event the encoded value is    * larger than can be represented in a {@code long}, this method performs an    * implicit narrowing conversion as described in    * {@link BigDecimal#doubleValue()}.    * @throws NullPointerException when the encoded value is {@code NULL}.    * @throws IllegalArgumentException when the encoded value is not a Numeric.    * @see #encodeNumeric(PositionedByteRange, long, Order)    * @see BigDecimal#longValue()    */
specifier|public
specifier|static
name|long
name|decodeNumericAsLong
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|)
block|{
comment|// TODO: should an encoded NULL value throw unexpectedHeader() instead?
if|if
condition|(
name|isNull
argument_list|(
name|src
argument_list|)
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
if|if
condition|(
operator|!
name|isNumeric
argument_list|(
name|src
argument_list|)
condition|)
throw|throw
name|unexpectedHeader
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
throw|;
if|if
condition|(
name|isNumericNaN
argument_list|(
name|src
argument_list|)
condition|)
throw|throw
name|unexpectedHeader
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
throw|;
if|if
condition|(
name|isNumericInfinite
argument_list|(
name|src
argument_list|)
condition|)
throw|throw
name|unexpectedHeader
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
throw|;
if|if
condition|(
name|isNumericZero
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|src
operator|.
name|get
argument_list|()
expr_stmt|;
return|return
name|Long
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
return|;
block|}
return|return
name|decodeNumericValue
argument_list|(
name|src
argument_list|)
operator|.
name|longValue
argument_list|()
return|;
block|}
comment|/**    * Decode a {@link BigDecimal} value from the variable-length encoding.    * @throws IllegalArgumentException when the encoded value is not a Numeric.    * @see #encodeNumeric(PositionedByteRange, BigDecimal, Order)    */
specifier|public
specifier|static
name|BigDecimal
name|decodeNumericAsBigDecimal
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|)
block|{
if|if
condition|(
name|isNull
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|src
operator|.
name|get
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|isNumeric
argument_list|(
name|src
argument_list|)
condition|)
throw|throw
name|unexpectedHeader
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
throw|;
if|if
condition|(
name|isNumericNaN
argument_list|(
name|src
argument_list|)
condition|)
throw|throw
name|unexpectedHeader
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
throw|;
if|if
condition|(
name|isNumericInfinite
argument_list|(
name|src
argument_list|)
condition|)
throw|throw
name|unexpectedHeader
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
throw|;
return|return
name|decodeNumericValue
argument_list|(
name|src
argument_list|)
return|;
block|}
comment|/**    * Encode a String value. String encoding is 0x00-terminated and so it does    * not support {@code \u0000} codepoints in the value.    * @param dst The destination to which the encoded value is written.    * @param val The value to encode.    * @param ord The {@link Order} to respect while encoding {@code val}.    * @return the number of bytes written.    * @throws IllegalArgumentException when {@code val} contains a {@code \u0000}.    */
specifier|public
specifier|static
name|int
name|encodeString
parameter_list|(
name|PositionedByteRange
name|dst
parameter_list|,
name|String
name|val
parameter_list|,
name|Order
name|ord
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|val
condition|)
block|{
return|return
name|encodeNull
argument_list|(
name|dst
argument_list|,
name|ord
argument_list|)
return|;
block|}
if|if
condition|(
name|val
operator|.
name|contains
argument_list|(
literal|"\u0000"
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot encode String values containing '\\u0000'"
argument_list|)
throw|;
specifier|final
name|int
name|offset
init|=
name|dst
operator|.
name|getOffset
argument_list|()
decl_stmt|,
name|start
init|=
name|dst
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|dst
operator|.
name|put
argument_list|(
name|TEXT
argument_list|)
expr_stmt|;
comment|// TODO: is there no way to decode into dst directly?
name|dst
operator|.
name|put
argument_list|(
name|val
operator|.
name|getBytes
argument_list|(
name|UTF8
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|.
name|put
argument_list|(
name|TERM
argument_list|)
expr_stmt|;
name|ord
operator|.
name|apply
argument_list|(
name|dst
operator|.
name|getBytes
argument_list|()
argument_list|,
name|offset
operator|+
name|start
argument_list|,
name|dst
operator|.
name|getPosition
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
return|return
name|dst
operator|.
name|getPosition
argument_list|()
operator|-
name|start
return|;
block|}
comment|/**    * Decode a String value.    */
specifier|public
specifier|static
name|String
name|decodeString
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|)
block|{
specifier|final
name|byte
name|header
init|=
name|src
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|header
operator|==
name|NULL
operator|||
name|header
operator|==
name|DESCENDING
operator|.
name|apply
argument_list|(
name|NULL
argument_list|)
condition|)
return|return
literal|null
return|;
assert|assert
name|header
operator|==
name|TEXT
operator|||
name|header
operator|==
name|DESCENDING
operator|.
name|apply
argument_list|(
name|TEXT
argument_list|)
assert|;
name|Order
name|ord
init|=
name|header
operator|==
name|TEXT
condition|?
name|ASCENDING
else|:
name|DESCENDING
decl_stmt|;
name|byte
index|[]
name|a
init|=
name|src
operator|.
name|getBytes
argument_list|()
decl_stmt|;
specifier|final
name|int
name|offset
init|=
name|src
operator|.
name|getOffset
argument_list|()
decl_stmt|,
name|start
init|=
name|src
operator|.
name|getPosition
argument_list|()
decl_stmt|;
specifier|final
name|byte
name|terminator
init|=
name|ord
operator|.
name|apply
argument_list|(
name|TERM
argument_list|)
decl_stmt|;
name|int
name|rawStartPos
init|=
name|offset
operator|+
name|start
decl_stmt|,
name|rawTermPos
init|=
name|rawStartPos
decl_stmt|;
for|for
control|(
init|;
name|a
index|[
name|rawTermPos
index|]
operator|!=
name|terminator
condition|;
name|rawTermPos
operator|++
control|)
empty_stmt|;
name|src
operator|.
name|setPosition
argument_list|(
name|rawTermPos
operator|-
name|offset
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// advance position to TERM + 1
if|if
condition|(
name|DESCENDING
operator|==
name|ord
condition|)
block|{
comment|// make a copy so that we don't disturb encoded value with ord.
name|byte
index|[]
name|copy
init|=
operator|new
name|byte
index|[
name|rawTermPos
operator|-
name|rawStartPos
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|a
argument_list|,
name|rawStartPos
argument_list|,
name|copy
argument_list|,
literal|0
argument_list|,
name|copy
operator|.
name|length
argument_list|)
expr_stmt|;
name|ord
operator|.
name|apply
argument_list|(
name|copy
argument_list|)
expr_stmt|;
return|return
operator|new
name|String
argument_list|(
name|copy
argument_list|,
name|UTF8
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|String
argument_list|(
name|a
argument_list|,
name|rawStartPos
argument_list|,
name|rawTermPos
operator|-
name|rawStartPos
argument_list|,
name|UTF8
argument_list|)
return|;
block|}
block|}
comment|/**    * Calculate the expected BlobVar encoded length based on unencoded length.    */
specifier|public
specifier|static
name|int
name|blobVarEncodedLength
parameter_list|(
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
literal|0
operator|==
name|len
condition|)
return|return
literal|2
return|;
comment|// 1-byte header + 1-byte terminator
else|else
return|return
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
operator|(
name|len
operator|*
literal|8
operator|)
comment|// 8-bits per input byte
operator|/
literal|7.0
argument_list|)
comment|// 7-bits of input data per encoded byte, rounded up
operator|+
literal|1
return|;
comment|// + 1-byte header
block|}
comment|/**    * Calculate the expected BlobVar decoded length based on encoded length.    */
annotation|@
name|VisibleForTesting
specifier|static
name|int
name|blobVarDecodedLength
parameter_list|(
name|int
name|len
parameter_list|)
block|{
return|return
operator|(
operator|(
name|len
operator|-
literal|1
operator|)
comment|// 1-byte header
operator|*
literal|7
operator|)
comment|// 7-bits of payload per encoded byte
operator|/
literal|8
return|;
comment|// 8-bits per byte
block|}
comment|/**    * Encode a Blob value using a modified varint encoding scheme.    *<p>    * This format encodes a byte[] value such that no limitations on the input    * value are imposed. The first byte encodes the encoding scheme that    * follows, {@link #BLOB_VAR}. Each encoded byte thereafter consists of a    * header bit followed by 7 bits of payload. A header bit of '1' indicates    * continuation of the encoding. A header bit of '0' indicates this byte    * contains the last of the payload. An empty input value is encoded as the    * header byte immediately followed by a termination byte {@code 0x00}. This    * is not ambiguous with the encoded value of {@code []}, which results in    * {@code [0x80, 0x00]}.    *</p>    * @return the number of bytes written.    */
specifier|public
specifier|static
name|int
name|encodeBlobVar
parameter_list|(
name|PositionedByteRange
name|dst
parameter_list|,
name|byte
index|[]
name|val
parameter_list|,
name|int
name|voff
parameter_list|,
name|int
name|vlen
parameter_list|,
name|Order
name|ord
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|val
condition|)
block|{
return|return
name|encodeNull
argument_list|(
name|dst
argument_list|,
name|ord
argument_list|)
return|;
block|}
comment|// Empty value is null-terminated. All other values are encoded as 7-bits per byte.
assert|assert
name|dst
operator|.
name|getRemaining
argument_list|()
operator|>=
name|blobVarEncodedLength
argument_list|(
name|vlen
argument_list|)
operator|:
literal|"buffer overflow expected."
assert|;
specifier|final
name|int
name|offset
init|=
name|dst
operator|.
name|getOffset
argument_list|()
decl_stmt|,
name|start
init|=
name|dst
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|dst
operator|.
name|put
argument_list|(
name|BLOB_VAR
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|vlen
condition|)
block|{
name|dst
operator|.
name|put
argument_list|(
name|TERM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|byte
name|s
init|=
literal|1
decl_stmt|,
name|t
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|voff
init|;
name|i
operator|<
name|vlen
condition|;
name|i
operator|++
control|)
block|{
name|dst
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
name|t
operator||
operator|(
operator|(
name|val
index|[
name|i
index|]
operator|&
literal|0xff
operator|)
operator|>>>
name|s
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|7
condition|)
block|{
name|t
operator|=
call|(
name|byte
call|)
argument_list|(
name|val
index|[
name|i
index|]
operator|<<
operator|(
literal|7
operator|-
name|s
operator|)
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
else|else
block|{
name|dst
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
literal|0x80
operator||
name|val
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
literal|1
expr_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s
operator|>
literal|1
condition|)
block|{
name|dst
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
literal|0x7f
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dst
operator|.
name|getBytes
argument_list|()
index|[
name|offset
operator|+
name|dst
operator|.
name|getPosition
argument_list|()
operator|-
literal|1
index|]
operator|&=
literal|0x7f
expr_stmt|;
block|}
block|}
name|ord
operator|.
name|apply
argument_list|(
name|dst
operator|.
name|getBytes
argument_list|()
argument_list|,
name|offset
operator|+
name|start
argument_list|,
name|dst
operator|.
name|getPosition
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
return|return
name|dst
operator|.
name|getPosition
argument_list|()
operator|-
name|start
return|;
block|}
comment|/**    * Encode a blob value using a modified varint encoding scheme.    * @return the number of bytes written.    * @see #encodeBlobVar(PositionedByteRange, byte[], int, int, Order)    */
specifier|public
specifier|static
name|int
name|encodeBlobVar
parameter_list|(
name|PositionedByteRange
name|dst
parameter_list|,
name|byte
index|[]
name|val
parameter_list|,
name|Order
name|ord
parameter_list|)
block|{
return|return
name|encodeBlobVar
argument_list|(
name|dst
argument_list|,
name|val
argument_list|,
literal|0
argument_list|,
literal|null
operator|!=
name|val
condition|?
name|val
operator|.
name|length
else|:
literal|0
argument_list|,
name|ord
argument_list|)
return|;
block|}
comment|/**    * Decode a blob value that was encoded using BlobVar encoding.    */
specifier|public
specifier|static
name|byte
index|[]
name|decodeBlobVar
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|)
block|{
specifier|final
name|byte
name|header
init|=
name|src
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|header
operator|==
name|NULL
operator|||
name|header
operator|==
name|DESCENDING
operator|.
name|apply
argument_list|(
name|NULL
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
assert|assert
name|header
operator|==
name|BLOB_VAR
operator|||
name|header
operator|==
name|DESCENDING
operator|.
name|apply
argument_list|(
name|BLOB_VAR
argument_list|)
assert|;
name|Order
name|ord
init|=
name|BLOB_VAR
operator|==
name|header
condition|?
name|ASCENDING
else|:
name|DESCENDING
decl_stmt|;
if|if
condition|(
name|src
operator|.
name|peek
argument_list|()
operator|==
name|ord
operator|.
name|apply
argument_list|(
name|TERM
argument_list|)
condition|)
block|{
comment|// skip empty input buffer.
name|src
operator|.
name|get
argument_list|()
expr_stmt|;
return|return
operator|new
name|byte
index|[
literal|0
index|]
return|;
block|}
specifier|final
name|int
name|offset
init|=
name|src
operator|.
name|getOffset
argument_list|()
decl_stmt|,
name|start
init|=
name|src
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|int
name|end
decl_stmt|;
name|byte
index|[]
name|a
init|=
name|src
operator|.
name|getBytes
argument_list|()
decl_stmt|;
for|for
control|(
name|end
operator|=
name|start
init|;
call|(
name|byte
call|)
argument_list|(
name|ord
operator|.
name|apply
argument_list|(
name|a
index|[
name|offset
operator|+
name|end
index|]
argument_list|)
operator|&
literal|0x80
argument_list|)
operator|!=
name|TERM
condition|;
name|end
operator|++
control|)
empty_stmt|;
name|end
operator|++
expr_stmt|;
comment|// increment end to 1-past last byte
comment|// create ret buffer using length of encoded data + 1 (header byte)
name|PositionedByteRange
name|ret
init|=
operator|new
name|SimplePositionedByteRange
argument_list|(
name|blobVarDecodedLength
argument_list|(
name|end
operator|-
name|start
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|s
init|=
literal|6
decl_stmt|;
name|byte
name|t
init|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|ord
operator|.
name|apply
argument_list|(
name|a
index|[
name|offset
operator|+
name|start
index|]
argument_list|)
operator|<<
literal|1
operator|)
operator|&
literal|0xff
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
operator|+
literal|1
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|==
literal|7
condition|)
block|{
name|ret
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|t
operator||
operator|(
name|ord
operator|.
name|apply
argument_list|(
name|a
index|[
name|offset
operator|+
name|i
index|]
argument_list|)
operator|&
literal|0x7f
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|// explicitly reset t -- clean up overflow buffer after decoding
comment|// a full cycle and retain assertion condition below. This happens
name|t
operator|=
literal|0
expr_stmt|;
comment|// when the LSB in the last encoded byte is 1. (HBASE-9893)
block|}
else|else
block|{
name|ret
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|t
operator||
operator|(
operator|(
name|ord
operator|.
name|apply
argument_list|(
name|a
index|[
name|offset
operator|+
name|i
index|]
argument_list|)
operator|&
literal|0x7f
operator|)
operator|>>>
name|s
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|end
condition|)
break|break;
name|t
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|ord
operator|.
name|apply
argument_list|(
name|a
index|[
name|offset
operator|+
name|i
index|]
argument_list|)
operator|<<
literal|8
operator|-
name|s
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|s
operator|=
name|s
operator|==
literal|1
condition|?
literal|7
else|:
name|s
operator|-
literal|1
expr_stmt|;
block|}
name|src
operator|.
name|setPosition
argument_list|(
name|end
argument_list|)
expr_stmt|;
assert|assert
name|t
operator|==
literal|0
operator|:
literal|"Unexpected bits remaining after decoding blob."
assert|;
assert|assert
name|ret
operator|.
name|getPosition
argument_list|()
operator|==
name|ret
operator|.
name|getLength
argument_list|()
operator|:
literal|"Allocated unnecessarily large return buffer."
assert|;
return|return
name|ret
operator|.
name|getBytes
argument_list|()
return|;
block|}
comment|/**    * Encode a Blob value as a byte-for-byte copy. BlobCopy encoding in    * DESCENDING order is NULL terminated so as to preserve proper sorting of    * {@code []} and so it does not support {@code 0x00} in the value.    * @return the number of bytes written.    * @throws IllegalArgumentException when {@code ord} is DESCENDING and    *    {@code val} contains a {@code 0x00} byte.    */
specifier|public
specifier|static
name|int
name|encodeBlobCopy
parameter_list|(
name|PositionedByteRange
name|dst
parameter_list|,
name|byte
index|[]
name|val
parameter_list|,
name|int
name|voff
parameter_list|,
name|int
name|vlen
parameter_list|,
name|Order
name|ord
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|val
condition|)
block|{
name|encodeNull
argument_list|(
name|dst
argument_list|,
name|ord
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASCENDING
operator|==
name|ord
condition|)
return|return
literal|1
return|;
else|else
block|{
comment|// DESCENDING ordered BlobCopy requires a termination bit to preserve
comment|// sort-order semantics of null values.
name|dst
operator|.
name|put
argument_list|(
name|ord
operator|.
name|apply
argument_list|(
name|TERM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
block|}
comment|// Blobs as final entry in a compound key are written unencoded.
assert|assert
name|dst
operator|.
name|getRemaining
argument_list|()
operator|>=
name|vlen
operator|+
operator|(
name|ASCENDING
operator|==
name|ord
condition|?
literal|1
else|:
literal|2
operator|)
assert|;
if|if
condition|(
name|DESCENDING
operator|==
name|ord
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vlen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TERM
operator|==
name|val
index|[
name|voff
operator|+
name|i
index|]
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"0x00 bytes not permitted in value."
argument_list|)
throw|;
block|}
block|}
block|}
specifier|final
name|int
name|offset
init|=
name|dst
operator|.
name|getOffset
argument_list|()
decl_stmt|,
name|start
init|=
name|dst
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|dst
operator|.
name|put
argument_list|(
name|BLOB_COPY
argument_list|)
expr_stmt|;
name|dst
operator|.
name|put
argument_list|(
name|val
argument_list|,
name|voff
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
comment|// DESCENDING ordered BlobCopy requires a termination bit to preserve
comment|// sort-order semantics of null values.
if|if
condition|(
name|DESCENDING
operator|==
name|ord
condition|)
name|dst
operator|.
name|put
argument_list|(
name|TERM
argument_list|)
expr_stmt|;
name|ord
operator|.
name|apply
argument_list|(
name|dst
operator|.
name|getBytes
argument_list|()
argument_list|,
name|offset
operator|+
name|start
argument_list|,
name|dst
operator|.
name|getPosition
argument_list|()
operator|-
name|start
argument_list|)
expr_stmt|;
return|return
name|dst
operator|.
name|getPosition
argument_list|()
operator|-
name|start
return|;
block|}
comment|/**    * Encode a Blob value as a byte-for-byte copy. BlobCopy encoding in    * DESCENDING order is NULL terminated so as to preserve proper sorting of    * {@code []} and so it does not support {@code 0x00} in the value.    * @return the number of bytes written.    * @throws IllegalArgumentException when {@code ord} is DESCENDING and    *    {@code val} contains a {@code 0x00} byte.    * @see #encodeBlobCopy(PositionedByteRange, byte[], int, int, Order)    */
specifier|public
specifier|static
name|int
name|encodeBlobCopy
parameter_list|(
name|PositionedByteRange
name|dst
parameter_list|,
name|byte
index|[]
name|val
parameter_list|,
name|Order
name|ord
parameter_list|)
block|{
return|return
name|encodeBlobCopy
argument_list|(
name|dst
argument_list|,
name|val
argument_list|,
literal|0
argument_list|,
literal|null
operator|!=
name|val
condition|?
name|val
operator|.
name|length
else|:
literal|0
argument_list|,
name|ord
argument_list|)
return|;
block|}
comment|/**    * Decode a Blob value, byte-for-byte copy.    * @see #encodeBlobCopy(PositionedByteRange, byte[], int, int, Order)    */
specifier|public
specifier|static
name|byte
index|[]
name|decodeBlobCopy
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|)
block|{
name|byte
name|header
init|=
name|src
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|header
operator|==
name|NULL
operator|||
name|header
operator|==
name|DESCENDING
operator|.
name|apply
argument_list|(
name|NULL
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
assert|assert
name|header
operator|==
name|BLOB_COPY
operator|||
name|header
operator|==
name|DESCENDING
operator|.
name|apply
argument_list|(
name|BLOB_COPY
argument_list|)
assert|;
name|Order
name|ord
init|=
name|header
operator|==
name|BLOB_COPY
condition|?
name|ASCENDING
else|:
name|DESCENDING
decl_stmt|;
specifier|final
name|int
name|length
init|=
name|src
operator|.
name|getRemaining
argument_list|()
operator|-
operator|(
name|ASCENDING
operator|==
name|ord
condition|?
literal|0
else|:
literal|1
operator|)
decl_stmt|;
name|byte
index|[]
name|ret
init|=
operator|new
name|byte
index|[
name|length
index|]
decl_stmt|;
name|src
operator|.
name|get
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|ord
operator|.
name|apply
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|ret
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// DESCENDING ordered BlobCopy requires a termination bit to preserve
comment|// sort-order semantics of null values.
if|if
condition|(
name|DESCENDING
operator|==
name|ord
condition|)
name|src
operator|.
name|get
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**    * Encode a null value.    * @param dst The destination to which encoded digits are written.    * @param ord The {@link Order} to respect while encoding {@code val}.    * @return the number of bytes written.    */
specifier|public
specifier|static
name|int
name|encodeNull
parameter_list|(
name|PositionedByteRange
name|dst
parameter_list|,
name|Order
name|ord
parameter_list|)
block|{
name|dst
operator|.
name|put
argument_list|(
name|ord
operator|.
name|apply
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/**    * Encode an {@code int8} value using the fixed-length encoding.    * @return the number of bytes written.    * @see #encodeInt64(PositionedByteRange, long, Order)    * @see #decodeInt8(PositionedByteRange)    */
specifier|public
specifier|static
name|int
name|encodeInt8
parameter_list|(
name|PositionedByteRange
name|dst
parameter_list|,
name|byte
name|val
parameter_list|,
name|Order
name|ord
parameter_list|)
block|{
specifier|final
name|int
name|offset
init|=
name|dst
operator|.
name|getOffset
argument_list|()
decl_stmt|,
name|start
init|=
name|dst
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|dst
operator|.
name|put
argument_list|(
name|FIXED_INT8
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|val
operator|^
literal|0x80
argument_list|)
argument_list|)
expr_stmt|;
name|ord
operator|.
name|apply
argument_list|(
name|dst
operator|.
name|getBytes
argument_list|()
argument_list|,
name|offset
operator|+
name|start
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
comment|/**    * Decode an {@code int8} value.    * @see #encodeInt8(PositionedByteRange, byte, Order)    */
specifier|public
specifier|static
name|byte
name|decodeInt8
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|)
block|{
specifier|final
name|byte
name|header
init|=
name|src
operator|.
name|get
argument_list|()
decl_stmt|;
assert|assert
name|header
operator|==
name|FIXED_INT8
operator|||
name|header
operator|==
name|DESCENDING
operator|.
name|apply
argument_list|(
name|FIXED_INT8
argument_list|)
assert|;
name|Order
name|ord
init|=
name|header
operator|==
name|FIXED_INT8
condition|?
name|ASCENDING
else|:
name|DESCENDING
decl_stmt|;
return|return
call|(
name|byte
call|)
argument_list|(
operator|(
name|ord
operator|.
name|apply
argument_list|(
name|src
operator|.
name|get
argument_list|()
argument_list|)
operator|^
literal|0x80
operator|)
operator|&
literal|0xff
argument_list|)
return|;
block|}
comment|/**    * Encode an {@code int16} value using the fixed-length encoding.    * @return the number of bytes written.    * @see #encodeInt64(PositionedByteRange, long, Order)    * @see #decodeInt16(PositionedByteRange)    */
specifier|public
specifier|static
name|int
name|encodeInt16
parameter_list|(
name|PositionedByteRange
name|dst
parameter_list|,
name|short
name|val
parameter_list|,
name|Order
name|ord
parameter_list|)
block|{
specifier|final
name|int
name|offset
init|=
name|dst
operator|.
name|getOffset
argument_list|()
decl_stmt|,
name|start
init|=
name|dst
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|dst
operator|.
name|put
argument_list|(
name|FIXED_INT16
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
operator|(
name|val
operator|>>
literal|8
operator|)
operator|^
literal|0x80
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
operator|(
name|byte
operator|)
name|val
argument_list|)
expr_stmt|;
name|ord
operator|.
name|apply
argument_list|(
name|dst
operator|.
name|getBytes
argument_list|()
argument_list|,
name|offset
operator|+
name|start
argument_list|,
literal|3
argument_list|)
expr_stmt|;
return|return
literal|3
return|;
block|}
comment|/**    * Decode an {@code int16} value.    * @see #encodeInt16(PositionedByteRange, short, Order)    */
specifier|public
specifier|static
name|short
name|decodeInt16
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|)
block|{
specifier|final
name|byte
name|header
init|=
name|src
operator|.
name|get
argument_list|()
decl_stmt|;
assert|assert
name|header
operator|==
name|FIXED_INT16
operator|||
name|header
operator|==
name|DESCENDING
operator|.
name|apply
argument_list|(
name|FIXED_INT16
argument_list|)
assert|;
name|Order
name|ord
init|=
name|header
operator|==
name|FIXED_INT16
condition|?
name|ASCENDING
else|:
name|DESCENDING
decl_stmt|;
name|short
name|val
init|=
call|(
name|short
call|)
argument_list|(
operator|(
name|ord
operator|.
name|apply
argument_list|(
name|src
operator|.
name|get
argument_list|()
argument_list|)
operator|^
literal|0x80
operator|)
operator|&
literal|0xff
argument_list|)
decl_stmt|;
name|val
operator|=
call|(
name|short
call|)
argument_list|(
operator|(
name|val
operator|<<
literal|8
operator|)
operator|+
operator|(
name|ord
operator|.
name|apply
argument_list|(
name|src
operator|.
name|get
argument_list|()
argument_list|)
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
comment|/**    * Encode an {@code int32} value using the fixed-length encoding.    * @return the number of bytes written.    * @see #encodeInt64(PositionedByteRange, long, Order)    * @see #decodeInt32(PositionedByteRange)    */
specifier|public
specifier|static
name|int
name|encodeInt32
parameter_list|(
name|PositionedByteRange
name|dst
parameter_list|,
name|int
name|val
parameter_list|,
name|Order
name|ord
parameter_list|)
block|{
specifier|final
name|int
name|offset
init|=
name|dst
operator|.
name|getOffset
argument_list|()
decl_stmt|,
name|start
init|=
name|dst
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|dst
operator|.
name|put
argument_list|(
name|FIXED_INT32
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
operator|(
name|val
operator|>>
literal|24
operator|)
operator|^
literal|0x80
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|val
operator|>>
literal|16
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|val
operator|>>
literal|8
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
operator|(
name|byte
operator|)
name|val
argument_list|)
expr_stmt|;
name|ord
operator|.
name|apply
argument_list|(
name|dst
operator|.
name|getBytes
argument_list|()
argument_list|,
name|offset
operator|+
name|start
argument_list|,
literal|5
argument_list|)
expr_stmt|;
return|return
literal|5
return|;
block|}
comment|/**    * Decode an {@code int32} value.    * @see #encodeInt32(PositionedByteRange, int, Order)    */
specifier|public
specifier|static
name|int
name|decodeInt32
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|)
block|{
specifier|final
name|byte
name|header
init|=
name|src
operator|.
name|get
argument_list|()
decl_stmt|;
assert|assert
name|header
operator|==
name|FIXED_INT32
operator|||
name|header
operator|==
name|DESCENDING
operator|.
name|apply
argument_list|(
name|FIXED_INT32
argument_list|)
assert|;
name|Order
name|ord
init|=
name|header
operator|==
name|FIXED_INT32
condition|?
name|ASCENDING
else|:
name|DESCENDING
decl_stmt|;
name|int
name|val
init|=
operator|(
name|ord
operator|.
name|apply
argument_list|(
name|src
operator|.
name|get
argument_list|()
argument_list|)
operator|^
literal|0x80
operator|)
operator|&
literal|0xff
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
operator|(
name|val
operator|<<
literal|8
operator|)
operator|+
operator|(
name|ord
operator|.
name|apply
argument_list|(
name|src
operator|.
name|get
argument_list|()
argument_list|)
operator|&
literal|0xff
operator|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
comment|/**    * Encode an {@code int64} value using the fixed-length encoding.    *<p>    * This format ensures that all longs sort in their natural order, as they    * would sort when using signed long comparison.    *</p>    *<p>    * All Longs are serialized to an 8-byte, fixed-width sortable byte format.    * Serialization is performed by inverting the integer sign bit and writing    * the resulting bytes to the byte array in big endian order. The encoded    * value is prefixed by the {@link #FIXED_INT64} header byte. This encoding    * is designed to handle java language primitives and so Null values are NOT    * supported by this implementation.    *</p>    *<p>    * For example:    *</p>    *<pre>    * Input:   0x0000000000000005 (5)    * Result:  0x288000000000000005    *    * Input:   0xfffffffffffffffb (-4)    * Result:  0x280000000000000004    *    * Input:   0x7fffffffffffffff (Long.MAX_VALUE)    * Result:  0x28ffffffffffffffff    *    * Input:   0x8000000000000000 (Long.MIN_VALUE)    * Result:  0x287fffffffffffffff    *</pre>    *<p>    * This encoding format, and much of this documentation string, is based on    * Orderly's {@code FixedIntWritableRowKey}.    *</p>    * @return the number of bytes written.    * @see #decodeInt64(PositionedByteRange)    */
specifier|public
specifier|static
name|int
name|encodeInt64
parameter_list|(
name|PositionedByteRange
name|dst
parameter_list|,
name|long
name|val
parameter_list|,
name|Order
name|ord
parameter_list|)
block|{
specifier|final
name|int
name|offset
init|=
name|dst
operator|.
name|getOffset
argument_list|()
decl_stmt|,
name|start
init|=
name|dst
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|dst
operator|.
name|put
argument_list|(
name|FIXED_INT64
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
operator|(
name|val
operator|>>
literal|56
operator|)
operator|^
literal|0x80
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|val
operator|>>
literal|48
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|val
operator|>>
literal|40
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|val
operator|>>
literal|32
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|val
operator|>>
literal|24
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|val
operator|>>
literal|16
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|val
operator|>>
literal|8
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
operator|(
name|byte
operator|)
name|val
argument_list|)
expr_stmt|;
name|ord
operator|.
name|apply
argument_list|(
name|dst
operator|.
name|getBytes
argument_list|()
argument_list|,
name|offset
operator|+
name|start
argument_list|,
literal|9
argument_list|)
expr_stmt|;
return|return
literal|9
return|;
block|}
comment|/**    * Decode an {@code int64} value.    * @see #encodeInt64(PositionedByteRange, long, Order)    */
specifier|public
specifier|static
name|long
name|decodeInt64
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|)
block|{
specifier|final
name|byte
name|header
init|=
name|src
operator|.
name|get
argument_list|()
decl_stmt|;
assert|assert
name|header
operator|==
name|FIXED_INT64
operator|||
name|header
operator|==
name|DESCENDING
operator|.
name|apply
argument_list|(
name|FIXED_INT64
argument_list|)
assert|;
name|Order
name|ord
init|=
name|header
operator|==
name|FIXED_INT64
condition|?
name|ASCENDING
else|:
name|DESCENDING
decl_stmt|;
name|long
name|val
init|=
operator|(
name|ord
operator|.
name|apply
argument_list|(
name|src
operator|.
name|get
argument_list|()
argument_list|)
operator|^
literal|0x80
operator|)
operator|&
literal|0xff
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
operator|(
name|val
operator|<<
literal|8
operator|)
operator|+
operator|(
name|ord
operator|.
name|apply
argument_list|(
name|src
operator|.
name|get
argument_list|()
argument_list|)
operator|&
literal|0xff
operator|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
comment|/**    * Encode a 32-bit floating point value using the fixed-length encoding.    * Encoding format is described at length in    * {@link #encodeFloat64(PositionedByteRange, double, Order)}.    * @return the number of bytes written.    * @see #decodeFloat32(PositionedByteRange)    * @see #encodeFloat64(PositionedByteRange, double, Order)    */
specifier|public
specifier|static
name|int
name|encodeFloat32
parameter_list|(
name|PositionedByteRange
name|dst
parameter_list|,
name|float
name|val
parameter_list|,
name|Order
name|ord
parameter_list|)
block|{
specifier|final
name|int
name|offset
init|=
name|dst
operator|.
name|getOffset
argument_list|()
decl_stmt|,
name|start
init|=
name|dst
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|int
name|i
init|=
name|Float
operator|.
name|floatToIntBits
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|i
operator|^=
operator|(
operator|(
name|i
operator|>>
name|Integer
operator|.
name|SIZE
operator|-
literal|1
operator|)
operator||
name|Integer
operator|.
name|MIN_VALUE
operator|)
expr_stmt|;
name|dst
operator|.
name|put
argument_list|(
name|FIXED_FLOAT32
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|i
operator|>>
literal|24
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|i
operator|>>
literal|16
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|i
operator|>>
literal|8
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
operator|(
name|byte
operator|)
name|i
argument_list|)
expr_stmt|;
name|ord
operator|.
name|apply
argument_list|(
name|dst
operator|.
name|getBytes
argument_list|()
argument_list|,
name|offset
operator|+
name|start
argument_list|,
literal|5
argument_list|)
expr_stmt|;
return|return
literal|5
return|;
block|}
comment|/**    * Decode a 32-bit floating point value using the fixed-length encoding.    * @see #encodeFloat32(PositionedByteRange, float, Order)    */
specifier|public
specifier|static
name|float
name|decodeFloat32
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|)
block|{
specifier|final
name|byte
name|header
init|=
name|src
operator|.
name|get
argument_list|()
decl_stmt|;
assert|assert
name|header
operator|==
name|FIXED_FLOAT32
operator|||
name|header
operator|==
name|DESCENDING
operator|.
name|apply
argument_list|(
name|FIXED_FLOAT32
argument_list|)
assert|;
name|Order
name|ord
init|=
name|header
operator|==
name|FIXED_FLOAT32
condition|?
name|ASCENDING
else|:
name|DESCENDING
decl_stmt|;
name|int
name|val
init|=
name|ord
operator|.
name|apply
argument_list|(
name|src
operator|.
name|get
argument_list|()
argument_list|)
operator|&
literal|0xff
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
operator|(
name|val
operator|<<
literal|8
operator|)
operator|+
operator|(
name|ord
operator|.
name|apply
argument_list|(
name|src
operator|.
name|get
argument_list|()
argument_list|)
operator|&
literal|0xff
operator|)
expr_stmt|;
block|}
name|val
operator|^=
operator|(
operator|~
name|val
operator|>>
name|Integer
operator|.
name|SIZE
operator|-
literal|1
operator|)
operator||
name|Integer
operator|.
name|MIN_VALUE
expr_stmt|;
return|return
name|Float
operator|.
name|intBitsToFloat
argument_list|(
name|val
argument_list|)
return|;
block|}
comment|/**    * Encode a 64-bit floating point value using the fixed-length encoding.    *<p>    * This format ensures the following total ordering of floating point    * values: Double.NEGATIVE_INFINITY&lt; -Double.MAX_VALUE&lt; ...&lt;    * -Double.MIN_VALUE&lt; -0.0&lt; +0.0;&lt; Double.MIN_VALUE&lt; ...    *&lt; Double.MAX_VALUE&lt; Double.POSITIVE_INFINITY&lt; Double.NaN    *</p>    * Floating point numbers are encoded as specified in IEEE 754. A 64-bit    * double precision float consists of a sign bit, 11-bit unsigned exponent    * encoded in offset-1023 notation, and a 52-bit significand. The format is    * described further in the<a    * href="http://en.wikipedia.org/wiki/Double_precision"> Double Precision    * Floating Point Wikipedia page</a></p>    *<p>    * The value of a normal float is -1<sup>sign bit</sup>&times;    * 2<sup>exponent - 1023</sup>&times; 1.significand    *</p>    *<p>    * The IEE754 floating point format already preserves sort ordering for    * positive floating point numbers when the raw bytes are compared in most    * significant byte order. This is discussed further at<a href=    * "http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm"    *> http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.    * htm</a>    *</p>    *<p>    * Thus, we need only ensure that negative numbers sort in the the exact    * opposite order as positive numbers (so that say, negative infinity is    * less than negative 1), and that all negative numbers compare less than    * any positive number. To accomplish this, we invert the sign bit of all    * floating point numbers, and we also invert the exponent and significand    * bits if the floating point number was negative.    *</p>    *<p>    * More specifically, we first store the floating point bits into a 64-bit    * long {@code l} using {@link Double#doubleToLongBits}. This method    * collapses all NaNs into a single, canonical NaN value but otherwise    * leaves the bits unchanged. We then compute    *</p>    *<pre>    * l&circ;= (l&gt;&gt; (Long.SIZE - 1)) | Long.MIN_SIZE    *</pre>    *<p>    * which inverts the sign bit and XOR's all other bits with the sign bit    * itself. Comparing the raw bytes of {@code l} in most significant    * byte order is equivalent to performing a double precision floating point    * comparison on the underlying bits (ignoring NaN comparisons, as NaNs    * don't compare equal to anything when performing floating point    * comparisons).    *</p>    *<p>    * The resulting long integer is then converted into a byte array by    * serializing the long one byte at a time in most significant byte order.    * The serialized integer is prefixed by a single header byte. All    * serialized values are 9 bytes in length.    *</p>    *<p>    * This encoding format, and much of this highly detailed documentation    * string, is based on Orderly's {@code DoubleWritableRowKey}.    *</p>    * @return the number of bytes written.    * @see #decodeFloat64(PositionedByteRange)    */
specifier|public
specifier|static
name|int
name|encodeFloat64
parameter_list|(
name|PositionedByteRange
name|dst
parameter_list|,
name|double
name|val
parameter_list|,
name|Order
name|ord
parameter_list|)
block|{
specifier|final
name|int
name|offset
init|=
name|dst
operator|.
name|getOffset
argument_list|()
decl_stmt|,
name|start
init|=
name|dst
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|long
name|lng
init|=
name|Double
operator|.
name|doubleToLongBits
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|lng
operator|^=
operator|(
operator|(
name|lng
operator|>>
name|Long
operator|.
name|SIZE
operator|-
literal|1
operator|)
operator||
name|Long
operator|.
name|MIN_VALUE
operator|)
expr_stmt|;
name|dst
operator|.
name|put
argument_list|(
name|FIXED_FLOAT64
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|lng
operator|>>
literal|56
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|lng
operator|>>
literal|48
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|lng
operator|>>
literal|40
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|lng
operator|>>
literal|32
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|lng
operator|>>
literal|24
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|lng
operator|>>
literal|16
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|lng
operator|>>
literal|8
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
operator|(
name|byte
operator|)
name|lng
argument_list|)
expr_stmt|;
name|ord
operator|.
name|apply
argument_list|(
name|dst
operator|.
name|getBytes
argument_list|()
argument_list|,
name|offset
operator|+
name|start
argument_list|,
literal|9
argument_list|)
expr_stmt|;
return|return
literal|9
return|;
block|}
comment|/**    * Decode a 64-bit floating point value using the fixed-length encoding.    * @see #encodeFloat64(PositionedByteRange, double, Order)    */
specifier|public
specifier|static
name|double
name|decodeFloat64
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|)
block|{
specifier|final
name|byte
name|header
init|=
name|src
operator|.
name|get
argument_list|()
decl_stmt|;
assert|assert
name|header
operator|==
name|FIXED_FLOAT64
operator|||
name|header
operator|==
name|DESCENDING
operator|.
name|apply
argument_list|(
name|FIXED_FLOAT64
argument_list|)
assert|;
name|Order
name|ord
init|=
name|header
operator|==
name|FIXED_FLOAT64
condition|?
name|ASCENDING
else|:
name|DESCENDING
decl_stmt|;
name|long
name|val
init|=
name|ord
operator|.
name|apply
argument_list|(
name|src
operator|.
name|get
argument_list|()
argument_list|)
operator|&
literal|0xff
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
operator|(
name|val
operator|<<
literal|8
operator|)
operator|+
operator|(
name|ord
operator|.
name|apply
argument_list|(
name|src
operator|.
name|get
argument_list|()
argument_list|)
operator|&
literal|0xff
operator|)
expr_stmt|;
block|}
name|val
operator|^=
operator|(
operator|~
name|val
operator|>>
name|Long
operator|.
name|SIZE
operator|-
literal|1
operator|)
operator||
name|Long
operator|.
name|MIN_VALUE
expr_stmt|;
return|return
name|Double
operator|.
name|longBitsToDouble
argument_list|(
name|val
argument_list|)
return|;
block|}
comment|/**    * Returns true when {@code src} appears to be positioned an encoded value,    * false otherwise.    */
specifier|public
specifier|static
name|boolean
name|isEncodedValue
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|)
block|{
return|return
name|isNull
argument_list|(
name|src
argument_list|)
operator|||
name|isNumeric
argument_list|(
name|src
argument_list|)
operator|||
name|isFixedInt32
argument_list|(
name|src
argument_list|)
operator|||
name|isFixedInt64
argument_list|(
name|src
argument_list|)
operator|||
name|isFixedFloat32
argument_list|(
name|src
argument_list|)
operator|||
name|isFixedFloat64
argument_list|(
name|src
argument_list|)
operator|||
name|isText
argument_list|(
name|src
argument_list|)
operator|||
name|isBlobCopy
argument_list|(
name|src
argument_list|)
operator|||
name|isBlobVar
argument_list|(
name|src
argument_list|)
return|;
block|}
comment|/**    * Return true when the next encoded value in {@code src} is null, false    * otherwise.    */
specifier|public
specifier|static
name|boolean
name|isNull
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|)
block|{
return|return
name|NULL
operator|==
operator|(
operator|-
literal|1
operator|==
name|Integer
operator|.
name|signum
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
condition|?
name|DESCENDING
else|:
name|ASCENDING
operator|)
operator|.
name|apply
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Return true when the next encoded value in {@code src} uses Numeric    * encoding, false otherwise. {@code NaN}, {@code +/-Inf} are valid Numeric    * values.    */
specifier|public
specifier|static
name|boolean
name|isNumeric
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|)
block|{
name|byte
name|x
init|=
operator|(
operator|-
literal|1
operator|==
name|Integer
operator|.
name|signum
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
condition|?
name|DESCENDING
else|:
name|ASCENDING
operator|)
operator|.
name|apply
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|x
operator|>=
name|NEG_INF
operator|&&
name|x
operator|<=
name|NAN
return|;
block|}
comment|/**    * Return true when the next encoded value in {@code src} uses Numeric    * encoding and is {@code Infinite}, false otherwise.    */
specifier|public
specifier|static
name|boolean
name|isNumericInfinite
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|)
block|{
name|byte
name|x
init|=
operator|(
operator|-
literal|1
operator|==
name|Integer
operator|.
name|signum
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
condition|?
name|DESCENDING
else|:
name|ASCENDING
operator|)
operator|.
name|apply
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|NEG_INF
operator|==
name|x
operator|||
name|POS_INF
operator|==
name|x
return|;
block|}
comment|/**    * Return true when the next encoded value in {@code src} uses Numeric    * encoding and is {@code NaN}, false otherwise.    */
specifier|public
specifier|static
name|boolean
name|isNumericNaN
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|)
block|{
return|return
name|NAN
operator|==
operator|(
operator|-
literal|1
operator|==
name|Integer
operator|.
name|signum
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
condition|?
name|DESCENDING
else|:
name|ASCENDING
operator|)
operator|.
name|apply
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Return true when the next encoded value in {@code src} uses Numeric    * encoding and is {@code 0}, false otherwise.    */
specifier|public
specifier|static
name|boolean
name|isNumericZero
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|)
block|{
return|return
name|ZERO
operator|==
operator|(
operator|-
literal|1
operator|==
name|Integer
operator|.
name|signum
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
condition|?
name|DESCENDING
else|:
name|ASCENDING
operator|)
operator|.
name|apply
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Return true when the next encoded value in {@code src} uses fixed-width    * Int32 encoding, false otherwise.    */
specifier|public
specifier|static
name|boolean
name|isFixedInt32
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|)
block|{
return|return
name|FIXED_INT32
operator|==
operator|(
operator|-
literal|1
operator|==
name|Integer
operator|.
name|signum
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
condition|?
name|DESCENDING
else|:
name|ASCENDING
operator|)
operator|.
name|apply
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Return true when the next encoded value in {@code src} uses fixed-width    * Int64 encoding, false otherwise.    */
specifier|public
specifier|static
name|boolean
name|isFixedInt64
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|)
block|{
return|return
name|FIXED_INT64
operator|==
operator|(
operator|-
literal|1
operator|==
name|Integer
operator|.
name|signum
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
condition|?
name|DESCENDING
else|:
name|ASCENDING
operator|)
operator|.
name|apply
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Return true when the next encoded value in {@code src} uses fixed-width    * Float32 encoding, false otherwise.    */
specifier|public
specifier|static
name|boolean
name|isFixedFloat32
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|)
block|{
return|return
name|FIXED_FLOAT32
operator|==
operator|(
operator|-
literal|1
operator|==
name|Integer
operator|.
name|signum
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
condition|?
name|DESCENDING
else|:
name|ASCENDING
operator|)
operator|.
name|apply
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Return true when the next encoded value in {@code src} uses fixed-width    * Float64 encoding, false otherwise.    */
specifier|public
specifier|static
name|boolean
name|isFixedFloat64
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|)
block|{
return|return
name|FIXED_FLOAT64
operator|==
operator|(
operator|-
literal|1
operator|==
name|Integer
operator|.
name|signum
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
condition|?
name|DESCENDING
else|:
name|ASCENDING
operator|)
operator|.
name|apply
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Return true when the next encoded value in {@code src} uses Text encoding,    * false otherwise.    */
specifier|public
specifier|static
name|boolean
name|isText
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|)
block|{
return|return
name|TEXT
operator|==
operator|(
operator|-
literal|1
operator|==
name|Integer
operator|.
name|signum
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
condition|?
name|DESCENDING
else|:
name|ASCENDING
operator|)
operator|.
name|apply
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Return true when the next encoded value in {@code src} uses BlobVar    * encoding, false otherwise.    */
specifier|public
specifier|static
name|boolean
name|isBlobVar
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|)
block|{
return|return
name|BLOB_VAR
operator|==
operator|(
operator|-
literal|1
operator|==
name|Integer
operator|.
name|signum
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
condition|?
name|DESCENDING
else|:
name|ASCENDING
operator|)
operator|.
name|apply
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Return true when the next encoded value in {@code src} uses BlobCopy    * encoding, false otherwise.    */
specifier|public
specifier|static
name|boolean
name|isBlobCopy
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|)
block|{
return|return
name|BLOB_COPY
operator|==
operator|(
operator|-
literal|1
operator|==
name|Integer
operator|.
name|signum
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
condition|?
name|DESCENDING
else|:
name|ASCENDING
operator|)
operator|.
name|apply
argument_list|(
name|src
operator|.
name|peek
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Skip {@code buff}'s position forward over one encoded value.    * @return number of bytes skipped.    */
specifier|public
specifier|static
name|int
name|skip
parameter_list|(
name|PositionedByteRange
name|src
parameter_list|)
block|{
specifier|final
name|int
name|start
init|=
name|src
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|byte
name|header
init|=
name|src
operator|.
name|get
argument_list|()
decl_stmt|;
name|Order
name|ord
init|=
operator|(
operator|-
literal|1
operator|==
name|Integer
operator|.
name|signum
argument_list|(
name|header
argument_list|)
operator|)
condition|?
name|DESCENDING
else|:
name|ASCENDING
decl_stmt|;
name|header
operator|=
name|ord
operator|.
name|apply
argument_list|(
name|header
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|header
condition|)
block|{
case|case
name|NULL
case|:
case|case
name|NEG_INF
case|:
return|return
literal|1
return|;
case|case
name|NEG_LARGE
case|:
comment|/* Large negative number: 0x08, ~E, ~M */
name|skipVaruint64
argument_list|(
name|src
argument_list|,
name|DESCENDING
operator|!=
name|ord
argument_list|)
expr_stmt|;
name|skipSignificand
argument_list|(
name|src
argument_list|,
name|DESCENDING
operator|!=
name|ord
argument_list|)
expr_stmt|;
return|return
name|src
operator|.
name|getPosition
argument_list|()
operator|-
name|start
return|;
case|case
name|NEG_MED_MIN
case|:
comment|/* Medium negative number: 0x13-E, ~M */
case|case
name|NEG_MED_MIN
operator|+
literal|0x01
case|:
case|case
name|NEG_MED_MIN
operator|+
literal|0x02
case|:
case|case
name|NEG_MED_MIN
operator|+
literal|0x03
case|:
case|case
name|NEG_MED_MIN
operator|+
literal|0x04
case|:
case|case
name|NEG_MED_MIN
operator|+
literal|0x05
case|:
case|case
name|NEG_MED_MIN
operator|+
literal|0x06
case|:
case|case
name|NEG_MED_MIN
operator|+
literal|0x07
case|:
case|case
name|NEG_MED_MIN
operator|+
literal|0x08
case|:
case|case
name|NEG_MED_MIN
operator|+
literal|0x09
case|:
case|case
name|NEG_MED_MAX
case|:
name|skipSignificand
argument_list|(
name|src
argument_list|,
name|DESCENDING
operator|!=
name|ord
argument_list|)
expr_stmt|;
return|return
name|src
operator|.
name|getPosition
argument_list|()
operator|-
name|start
return|;
case|case
name|NEG_SMALL
case|:
comment|/* Small negative number: 0x14, -E, ~M */
name|skipVaruint64
argument_list|(
name|src
argument_list|,
name|DESCENDING
operator|==
name|ord
argument_list|)
expr_stmt|;
name|skipSignificand
argument_list|(
name|src
argument_list|,
name|DESCENDING
operator|!=
name|ord
argument_list|)
expr_stmt|;
return|return
name|src
operator|.
name|getPosition
argument_list|()
operator|-
name|start
return|;
case|case
name|ZERO
case|:
return|return
literal|1
return|;
case|case
name|POS_SMALL
case|:
comment|/* Small positive number: 0x16, ~-E, M */
name|skipVaruint64
argument_list|(
name|src
argument_list|,
name|DESCENDING
operator|!=
name|ord
argument_list|)
expr_stmt|;
name|skipSignificand
argument_list|(
name|src
argument_list|,
name|DESCENDING
operator|==
name|ord
argument_list|)
expr_stmt|;
return|return
name|src
operator|.
name|getPosition
argument_list|()
operator|-
name|start
return|;
case|case
name|POS_MED_MIN
case|:
comment|/* Medium positive number: 0x17+E, M */
case|case
name|POS_MED_MIN
operator|+
literal|0x01
case|:
case|case
name|POS_MED_MIN
operator|+
literal|0x02
case|:
case|case
name|POS_MED_MIN
operator|+
literal|0x03
case|:
case|case
name|POS_MED_MIN
operator|+
literal|0x04
case|:
case|case
name|POS_MED_MIN
operator|+
literal|0x05
case|:
case|case
name|POS_MED_MIN
operator|+
literal|0x06
case|:
case|case
name|POS_MED_MIN
operator|+
literal|0x07
case|:
case|case
name|POS_MED_MIN
operator|+
literal|0x08
case|:
case|case
name|POS_MED_MIN
operator|+
literal|0x09
case|:
case|case
name|POS_MED_MAX
case|:
name|skipSignificand
argument_list|(
name|src
argument_list|,
name|DESCENDING
operator|==
name|ord
argument_list|)
expr_stmt|;
return|return
name|src
operator|.
name|getPosition
argument_list|()
operator|-
name|start
return|;
case|case
name|POS_LARGE
case|:
comment|/* Large positive number: 0x22, E, M */
name|skipVaruint64
argument_list|(
name|src
argument_list|,
name|DESCENDING
operator|==
name|ord
argument_list|)
expr_stmt|;
name|skipSignificand
argument_list|(
name|src
argument_list|,
name|DESCENDING
operator|==
name|ord
argument_list|)
expr_stmt|;
return|return
name|src
operator|.
name|getPosition
argument_list|()
operator|-
name|start
return|;
case|case
name|POS_INF
case|:
return|return
literal|1
return|;
case|case
name|NAN
case|:
return|return
literal|1
return|;
case|case
name|FIXED_INT8
case|:
name|src
operator|.
name|setPosition
argument_list|(
name|src
operator|.
name|getPosition
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|src
operator|.
name|getPosition
argument_list|()
operator|-
name|start
return|;
case|case
name|FIXED_INT16
case|:
name|src
operator|.
name|setPosition
argument_list|(
name|src
operator|.
name|getPosition
argument_list|()
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
name|src
operator|.
name|getPosition
argument_list|()
operator|-
name|start
return|;
case|case
name|FIXED_INT32
case|:
name|src
operator|.
name|setPosition
argument_list|(
name|src
operator|.
name|getPosition
argument_list|()
operator|+
literal|4
argument_list|)
expr_stmt|;
return|return
name|src
operator|.
name|getPosition
argument_list|()
operator|-
name|start
return|;
case|case
name|FIXED_INT64
case|:
name|src
operator|.
name|setPosition
argument_list|(
name|src
operator|.
name|getPosition
argument_list|()
operator|+
literal|8
argument_list|)
expr_stmt|;
return|return
name|src
operator|.
name|getPosition
argument_list|()
operator|-
name|start
return|;
case|case
name|FIXED_FLOAT32
case|:
name|src
operator|.
name|setPosition
argument_list|(
name|src
operator|.
name|getPosition
argument_list|()
operator|+
literal|4
argument_list|)
expr_stmt|;
return|return
name|src
operator|.
name|getPosition
argument_list|()
operator|-
name|start
return|;
case|case
name|FIXED_FLOAT64
case|:
name|src
operator|.
name|setPosition
argument_list|(
name|src
operator|.
name|getPosition
argument_list|()
operator|+
literal|8
argument_list|)
expr_stmt|;
return|return
name|src
operator|.
name|getPosition
argument_list|()
operator|-
name|start
return|;
case|case
name|TEXT
case|:
comment|// for null-terminated values, skip to the end.
do|do
block|{
name|header
operator|=
name|ord
operator|.
name|apply
argument_list|(
name|src
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|header
operator|!=
name|TERM
condition|)
do|;
return|return
name|src
operator|.
name|getPosition
argument_list|()
operator|-
name|start
return|;
case|case
name|BLOB_VAR
case|:
comment|// read until we find a 0 in the MSB
do|do
block|{
name|header
operator|=
name|ord
operator|.
name|apply
argument_list|(
name|src
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
call|(
name|byte
call|)
argument_list|(
name|header
operator|&
literal|0x80
argument_list|)
operator|!=
name|TERM
condition|)
do|;
return|return
name|src
operator|.
name|getPosition
argument_list|()
operator|-
name|start
return|;
case|case
name|BLOB_COPY
case|:
if|if
condition|(
name|Order
operator|.
name|DESCENDING
operator|==
name|ord
condition|)
block|{
comment|// if descending, read to termination byte.
do|do
block|{
name|header
operator|=
name|ord
operator|.
name|apply
argument_list|(
name|src
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|header
operator|!=
name|TERM
condition|)
do|;
return|return
name|src
operator|.
name|getPosition
argument_list|()
operator|-
name|start
return|;
block|}
else|else
block|{
comment|// otherwise, just skip to the end.
name|src
operator|.
name|setPosition
argument_list|(
name|src
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|src
operator|.
name|getPosition
argument_list|()
operator|-
name|start
return|;
block|}
default|default:
throw|throw
name|unexpectedHeader
argument_list|(
name|header
argument_list|)
throw|;
block|}
block|}
comment|/**    * Return the number of encoded entries remaining in {@code buff}. The    * state of {@code buff} is not modified through use of this method.    */
specifier|public
specifier|static
name|int
name|length
parameter_list|(
name|PositionedByteRange
name|buff
parameter_list|)
block|{
name|PositionedByteRange
name|b
init|=
operator|new
name|SimplePositionedByteRange
argument_list|(
name|buff
operator|.
name|getBytes
argument_list|()
argument_list|,
name|buff
operator|.
name|getOffset
argument_list|()
argument_list|,
name|buff
operator|.
name|getLength
argument_list|()
argument_list|)
decl_stmt|;
name|b
operator|.
name|setPosition
argument_list|(
name|buff
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|isEncodedValue
argument_list|(
name|b
argument_list|)
condition|;
name|skip
argument_list|(
name|buff
argument_list|)
operator|,
name|cnt
operator|++
control|)
empty_stmt|;
return|return
name|cnt
return|;
block|}
block|}
end_class

end_unit

