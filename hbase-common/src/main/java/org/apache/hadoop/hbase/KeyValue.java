begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
operator|.
name|len
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|HeapSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ClassSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|RawComparator
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Longs
import|;
end_import

begin_comment
comment|/**  * An HBase Key/Value. This is the fundamental HBase Type.    *<p>  * HBase applications and users should use the Cell interface and avoid directly using KeyValue  * and member functions not defined in Cell.  *<p>  * If being used client-side, the primary methods to access individual fields are {@link #getRow()},  * {@link #getFamily()}, {@link #getQualifier()}, {@link #getTimestamp()}, and {@link #getValue()}.  * These methods allocate new byte arrays and return copies. Avoid their use server-side.  *<p>  * Instances of this class are immutable. They do not implement Comparable but Comparators are  * provided. Comparators change with context, whether user table or a catalog table comparison. Its  * critical you use the appropriate comparator. There are Comparators for normal HFiles, Meta's  * Hfiles, and bloom filter keys.  *<p>  * KeyValue wraps a byte array and takes offsets and lengths into passed array at where to start  * interpreting the content as KeyValue. The KeyValue format inside a byte array is:  *<code>&lt;keylength>&lt;valuelength>&lt;key>&lt;value></code> Key is further decomposed as:  *<code>&lt;rowlength>&lt;row>&lt;columnfamilylength>&lt;columnfamily>&lt;columnqualifier>  *&lt;timestamp>&lt;keytype></code>  * The<code>rowlength</code> maximum is<code>Short.MAX_SIZE</code>, column family length maximum  * is<code>Byte.MAX_SIZE</code>, and column qualifier + key length must be<  *<code>Integer.MAX_SIZE</code>. The column does not contain the family/qualifier delimiter,  * {@link #COLUMN_FAMILY_DELIMITER}<br>  * KeyValue can optionally contain Tags. When it contains tags, it is added in the byte array after  * the value part. The format for this part is:<code>&lt;tagslength>&lt;tagsbytes></code>.  *<code>tagslength</code> maximum is<code>Short.MAX_SIZE</code>. The<code>tagsbytes</code>  * contain one or more tags where as each tag is of the form  *<code>&lt;taglength>&lt;tagtype>&lt;tagbytes></code>.<code>tagtype</code> is one byte and  *<code>taglength</code> maximum is<code>Short.MAX_SIZE</code> and it includes 1 byte type length  * and actual tag bytes length.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|KeyValue
implements|implements
name|Cell
implements|,
name|HeapSize
implements|,
name|Cloneable
block|{
specifier|private
specifier|static
specifier|final
name|ArrayList
argument_list|<
name|Tag
argument_list|>
name|EMPTY_ARRAY_LIST
init|=
operator|new
name|ArrayList
argument_list|<
name|Tag
argument_list|>
argument_list|()
decl_stmt|;
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|KeyValue
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Colon character in UTF-8    */
specifier|public
specifier|static
specifier|final
name|char
name|COLUMN_FAMILY_DELIMITER
init|=
literal|':'
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|COLUMN_FAMILY_DELIM_ARRAY
init|=
operator|new
name|byte
index|[]
block|{
name|COLUMN_FAMILY_DELIMITER
block|}
decl_stmt|;
comment|/**    * Comparator for plain key/values; i.e. non-catalog table key/values. Works on Key portion    * of KeyValue only.    */
specifier|public
specifier|static
specifier|final
name|KVComparator
name|COMPARATOR
init|=
operator|new
name|KVComparator
argument_list|()
decl_stmt|;
comment|/**    * A {@link KVComparator} for<code>hbase:meta</code> catalog table    * {@link KeyValue}s.    */
specifier|public
specifier|static
specifier|final
name|KVComparator
name|META_COMPARATOR
init|=
operator|new
name|MetaComparator
argument_list|()
decl_stmt|;
comment|/**    * Needed for Bloom Filters.    */
specifier|public
specifier|static
specifier|final
name|KVComparator
name|RAW_COMPARATOR
init|=
operator|new
name|RawBytesComparator
argument_list|()
decl_stmt|;
comment|/** Size of the key length field in bytes*/
specifier|public
specifier|static
specifier|final
name|int
name|KEY_LENGTH_SIZE
init|=
name|Bytes
operator|.
name|SIZEOF_INT
decl_stmt|;
comment|/** Size of the key type field in bytes */
specifier|public
specifier|static
specifier|final
name|int
name|TYPE_SIZE
init|=
name|Bytes
operator|.
name|SIZEOF_BYTE
decl_stmt|;
comment|/** Size of the row length field in bytes */
specifier|public
specifier|static
specifier|final
name|int
name|ROW_LENGTH_SIZE
init|=
name|Bytes
operator|.
name|SIZEOF_SHORT
decl_stmt|;
comment|/** Size of the family length field in bytes */
specifier|public
specifier|static
specifier|final
name|int
name|FAMILY_LENGTH_SIZE
init|=
name|Bytes
operator|.
name|SIZEOF_BYTE
decl_stmt|;
comment|/** Size of the timestamp field in bytes */
specifier|public
specifier|static
specifier|final
name|int
name|TIMESTAMP_SIZE
init|=
name|Bytes
operator|.
name|SIZEOF_LONG
decl_stmt|;
comment|// Size of the timestamp and type byte on end of a key -- a long + a byte.
specifier|public
specifier|static
specifier|final
name|int
name|TIMESTAMP_TYPE_SIZE
init|=
name|TIMESTAMP_SIZE
operator|+
name|TYPE_SIZE
decl_stmt|;
comment|// Size of the length shorts and bytes in key.
specifier|public
specifier|static
specifier|final
name|int
name|KEY_INFRASTRUCTURE_SIZE
init|=
name|ROW_LENGTH_SIZE
operator|+
name|FAMILY_LENGTH_SIZE
operator|+
name|TIMESTAMP_TYPE_SIZE
decl_stmt|;
comment|// How far into the key the row starts at. First thing to read is the short
comment|// that says how long the row is.
specifier|public
specifier|static
specifier|final
name|int
name|ROW_OFFSET
init|=
name|Bytes
operator|.
name|SIZEOF_INT
comment|/*keylength*/
operator|+
name|Bytes
operator|.
name|SIZEOF_INT
comment|/*valuelength*/
decl_stmt|;
comment|// Size of the length ints in a KeyValue datastructure.
specifier|public
specifier|static
specifier|final
name|int
name|KEYVALUE_INFRASTRUCTURE_SIZE
init|=
name|ROW_OFFSET
decl_stmt|;
comment|/** Size of the tags length field in bytes */
specifier|public
specifier|static
specifier|final
name|int
name|TAGS_LENGTH_SIZE
init|=
name|Bytes
operator|.
name|SIZEOF_SHORT
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|KEYVALUE_WITH_TAGS_INFRASTRUCTURE_SIZE
init|=
name|ROW_OFFSET
operator|+
name|TAGS_LENGTH_SIZE
decl_stmt|;
comment|/**    * Computes the number of bytes that a<code>KeyValue</code> instance with the provided    * characteristics would take up for its underlying data structure.    *    * @param rlength row length    * @param flength family length    * @param qlength qualifier length    * @param vlength value length    *    * @return the<code>KeyValue</code> data structure length    */
specifier|public
specifier|static
name|long
name|getKeyValueDataStructureSize
parameter_list|(
name|int
name|rlength
parameter_list|,
name|int
name|flength
parameter_list|,
name|int
name|qlength
parameter_list|,
name|int
name|vlength
parameter_list|)
block|{
return|return
name|KeyValue
operator|.
name|KEYVALUE_INFRASTRUCTURE_SIZE
operator|+
name|getKeyDataStructureSize
argument_list|(
name|rlength
argument_list|,
name|flength
argument_list|,
name|qlength
argument_list|)
operator|+
name|vlength
return|;
block|}
comment|/**    * Computes the number of bytes that a<code>KeyValue</code> instance with the provided    * characteristics would take up for its underlying data structure.    *    * @param rlength row length    * @param flength family length    * @param qlength qualifier length    * @param vlength value length    * @param tagsLength total length of the tags    *    * @return the<code>KeyValue</code> data structure length    */
specifier|public
specifier|static
name|long
name|getKeyValueDataStructureSize
parameter_list|(
name|int
name|rlength
parameter_list|,
name|int
name|flength
parameter_list|,
name|int
name|qlength
parameter_list|,
name|int
name|vlength
parameter_list|,
name|int
name|tagsLength
parameter_list|)
block|{
if|if
condition|(
name|tagsLength
operator|==
literal|0
condition|)
block|{
return|return
name|getKeyValueDataStructureSize
argument_list|(
name|rlength
argument_list|,
name|flength
argument_list|,
name|qlength
argument_list|,
name|vlength
argument_list|)
return|;
block|}
return|return
name|KeyValue
operator|.
name|KEYVALUE_WITH_TAGS_INFRASTRUCTURE_SIZE
operator|+
name|getKeyDataStructureSize
argument_list|(
name|rlength
argument_list|,
name|flength
argument_list|,
name|qlength
argument_list|)
operator|+
name|vlength
operator|+
name|tagsLength
return|;
block|}
comment|/**    * Computes the number of bytes that a<code>KeyValue</code> instance with the provided    * characteristics would take up for its underlying data structure.    *    * @param klength key length    * @param vlength value length    * @param tagsLength total length of the tags    *    * @return the<code>KeyValue</code> data structure length    */
specifier|public
specifier|static
name|long
name|getKeyValueDataStructureSize
parameter_list|(
name|int
name|klength
parameter_list|,
name|int
name|vlength
parameter_list|,
name|int
name|tagsLength
parameter_list|)
block|{
if|if
condition|(
name|tagsLength
operator|==
literal|0
condition|)
block|{
return|return
name|KeyValue
operator|.
name|KEYVALUE_INFRASTRUCTURE_SIZE
operator|+
name|klength
operator|+
name|vlength
return|;
block|}
return|return
name|KeyValue
operator|.
name|KEYVALUE_WITH_TAGS_INFRASTRUCTURE_SIZE
operator|+
name|klength
operator|+
name|vlength
operator|+
name|tagsLength
return|;
block|}
comment|/**    * Computes the number of bytes that a<code>KeyValue</code> instance with the provided    * characteristics would take up in its underlying data structure for the key.    *    * @param rlength row length    * @param flength family length    * @param qlength qualifier length    *    * @return the key data structure length    */
specifier|public
specifier|static
name|long
name|getKeyDataStructureSize
parameter_list|(
name|int
name|rlength
parameter_list|,
name|int
name|flength
parameter_list|,
name|int
name|qlength
parameter_list|)
block|{
return|return
name|KeyValue
operator|.
name|KEY_INFRASTRUCTURE_SIZE
operator|+
name|rlength
operator|+
name|flength
operator|+
name|qlength
return|;
block|}
comment|/**    * Key type.    * Has space for other key types to be added later.  Cannot rely on    * enum ordinals . They change if item is removed or moved.  Do our own codes.    */
specifier|public
specifier|static
enum|enum
name|Type
block|{
name|Minimum
argument_list|(
operator|(
name|byte
operator|)
literal|0
argument_list|)
block|,
name|Put
argument_list|(
operator|(
name|byte
operator|)
literal|4
argument_list|)
block|,
name|Delete
argument_list|(
operator|(
name|byte
operator|)
literal|8
argument_list|)
block|,
name|DeleteFamilyVersion
argument_list|(
operator|(
name|byte
operator|)
literal|10
argument_list|)
block|,
name|DeleteColumn
argument_list|(
operator|(
name|byte
operator|)
literal|12
argument_list|)
block|,
name|DeleteFamily
argument_list|(
operator|(
name|byte
operator|)
literal|14
argument_list|)
block|,
comment|// Maximum is used when searching; you look from maximum on down.
name|Maximum
argument_list|(
operator|(
name|byte
operator|)
literal|255
argument_list|)
block|;
specifier|private
specifier|final
name|byte
name|code
decl_stmt|;
name|Type
parameter_list|(
specifier|final
name|byte
name|c
parameter_list|)
block|{
name|this
operator|.
name|code
operator|=
name|c
expr_stmt|;
block|}
specifier|public
name|byte
name|getCode
parameter_list|()
block|{
return|return
name|this
operator|.
name|code
return|;
block|}
comment|/**      * Cannot rely on enum ordinals . They change if item is removed or moved.      * Do our own codes.      * @param b      * @return Type associated with passed code.      */
specifier|public
specifier|static
name|Type
name|codeToType
parameter_list|(
specifier|final
name|byte
name|b
parameter_list|)
block|{
for|for
control|(
name|Type
name|t
range|:
name|Type
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|t
operator|.
name|getCode
argument_list|()
operator|==
name|b
condition|)
block|{
return|return
name|t
return|;
block|}
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unknown code "
operator|+
name|b
argument_list|)
throw|;
block|}
block|}
comment|/**    * Lowest possible key.    * Makes a Key with highest possible Timestamp, empty row and column.  No    * key can be equal or lower than this one in memstore or in store file.    */
specifier|public
specifier|static
specifier|final
name|KeyValue
name|LOWESTKEY
init|=
operator|new
name|KeyValue
argument_list|(
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|)
decl_stmt|;
comment|////
comment|// KeyValue core instance fields.
specifier|private
name|byte
index|[]
name|bytes
init|=
literal|null
decl_stmt|;
comment|// an immutable byte array that contains the KV
specifier|private
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|// offset into bytes buffer KV starts at
specifier|private
name|int
name|length
init|=
literal|0
decl_stmt|;
comment|// length of the KV starting from offset.
comment|/**    * @return True if a delete type, a {@link KeyValue.Type#Delete} or    * a {KeyValue.Type#DeleteFamily} or a {@link KeyValue.Type#DeleteColumn}    * KeyValue type.    */
specifier|public
specifier|static
name|boolean
name|isDelete
parameter_list|(
name|byte
name|t
parameter_list|)
block|{
return|return
name|Type
operator|.
name|Delete
operator|.
name|getCode
argument_list|()
operator|<=
name|t
operator|&&
name|t
operator|<=
name|Type
operator|.
name|DeleteFamily
operator|.
name|getCode
argument_list|()
return|;
block|}
comment|/** Here be dragons **/
comment|// used to achieve atomic operations in the memstore.
annotation|@
name|Override
specifier|public
name|long
name|getMvccVersion
parameter_list|()
block|{
return|return
name|mvcc
return|;
block|}
specifier|public
name|void
name|setMvccVersion
parameter_list|(
name|long
name|mvccVersion
parameter_list|)
block|{
name|this
operator|.
name|mvcc
operator|=
name|mvccVersion
expr_stmt|;
block|}
comment|// multi-version concurrency control version.  default value is 0, aka do not care.
specifier|private
name|long
name|mvcc
init|=
literal|0
decl_stmt|;
comment|// this value is not part of a serialized KeyValue (not in HFiles)
comment|/** Dragon time over, return to normal business */
comment|/** Writable Constructor -- DO NOT USE */
specifier|public
name|KeyValue
parameter_list|()
block|{}
comment|/**    * Creates a KeyValue from the start of the specified byte array.    * Presumes<code>bytes</code> content is formatted as a KeyValue blob.    * @param bytes byte array    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|)
block|{
name|this
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a KeyValue from the specified byte array and offset.    * Presumes<code>bytes</code> content starting at<code>offset</code> is    * formatted as a KeyValue blob.    * @param bytes byte array    * @param offset offset to start of KeyValue    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|)
block|{
name|this
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|getLength
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a KeyValue from the specified byte array, starting at offset, and    * for length<code>length</code>.    * @param bytes byte array    * @param offset offset to start of the KeyValue    * @param length length of the KeyValue    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|)
block|{
name|this
operator|.
name|bytes
operator|=
name|bytes
expr_stmt|;
name|this
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|this
operator|.
name|length
operator|=
name|length
expr_stmt|;
block|}
comment|/**    * Creates a KeyValue from the specified byte array, starting at offset, and    * for length<code>length</code>.    *    * @param bytes  byte array    * @param offset offset to start of the KeyValue    * @param length length of the KeyValue    * @param ts    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|,
name|long
name|ts
parameter_list|)
block|{
name|this
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ts
argument_list|,
name|Type
operator|.
name|Maximum
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/** Constructors that build a new backing byte array from fields */
comment|/**    * Constructs KeyValue structure filled with null value.    * Sets type to {@link KeyValue.Type#Maximum}    * @param row - row key (arbitrary byte array)    * @param timestamp    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|)
block|{
name|this
argument_list|(
name|row
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|timestamp
argument_list|,
name|Type
operator|.
name|Maximum
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs KeyValue structure filled with null value.    * @param row - row key (arbitrary byte array)    * @param timestamp    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
name|this
argument_list|(
name|row
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|timestamp
argument_list|,
name|type
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs KeyValue structure filled with null value.    * Sets type to {@link KeyValue.Type#Maximum}    * @param row - row key (arbitrary byte array)    * @param family family name    * @param qualifier column qualifier    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
name|this
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|,
name|Type
operator|.
name|Maximum
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs KeyValue structure filled with null value.    * @param row - row key (arbitrary byte array)    * @param family family name    * @param qualifier column qualifier    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|)
block|{
name|this
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|,
name|Type
operator|.
name|Put
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs KeyValue structure filled with specified values.    * @param row row key    * @param family family name    * @param qualifier column qualifier    * @param timestamp version timestamp    * @param type key type    * @throws IllegalArgumentException    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
name|this
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|timestamp
argument_list|,
name|type
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs KeyValue structure filled with specified values.    * @param row row key    * @param family family name    * @param qualifier column qualifier    * @param timestamp version timestamp    * @param value column value    * @throws IllegalArgumentException    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|)
block|{
name|this
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|timestamp
argument_list|,
name|Type
operator|.
name|Put
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs KeyValue structure filled with specified values.    * @param row row key    * @param family family name    * @param qualifier column qualifier    * @param timestamp version timestamp    * @param value column value    * @param tags tags    * @throws IllegalArgumentException    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|Tag
index|[]
name|tags
parameter_list|)
block|{
name|this
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|timestamp
argument_list|,
name|value
argument_list|,
name|tags
operator|!=
literal|null
condition|?
name|Arrays
operator|.
name|asList
argument_list|(
name|tags
argument_list|)
else|:
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs KeyValue structure filled with specified values.    * @param row row key    * @param family family name    * @param qualifier column qualifier    * @param timestamp version timestamp    * @param value column value    * @param tags tags non-empty list of tags or null    * @throws IllegalArgumentException    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|List
argument_list|<
name|Tag
argument_list|>
name|tags
parameter_list|)
block|{
name|this
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
name|row
operator|==
literal|null
condition|?
literal|0
else|:
name|row
operator|.
name|length
argument_list|,
name|family
argument_list|,
literal|0
argument_list|,
name|family
operator|==
literal|null
condition|?
literal|0
else|:
name|family
operator|.
name|length
argument_list|,
name|qualifier
argument_list|,
literal|0
argument_list|,
name|qualifier
operator|==
literal|null
condition|?
literal|0
else|:
name|qualifier
operator|.
name|length
argument_list|,
name|timestamp
argument_list|,
name|Type
operator|.
name|Put
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|value
operator|==
literal|null
condition|?
literal|0
else|:
name|value
operator|.
name|length
argument_list|,
name|tags
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs KeyValue structure filled with specified values.    * @param row row key    * @param family family name    * @param qualifier column qualifier    * @param timestamp version timestamp    * @param type key type    * @param value column value    * @throws IllegalArgumentException    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
name|Type
name|type
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|)
block|{
name|this
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
name|len
argument_list|(
name|row
argument_list|)
argument_list|,
name|family
argument_list|,
literal|0
argument_list|,
name|len
argument_list|(
name|family
argument_list|)
argument_list|,
name|qualifier
argument_list|,
literal|0
argument_list|,
name|len
argument_list|(
name|qualifier
argument_list|)
argument_list|,
name|timestamp
argument_list|,
name|type
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|len
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs KeyValue structure filled with specified values.    *<p>    * Column is split into two fields, family and qualifier.    * @param row row key    * @param family family name    * @param qualifier column qualifier    * @param timestamp version timestamp    * @param type key type    * @param value column value    * @throws IllegalArgumentException    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
name|Type
name|type
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|List
argument_list|<
name|Tag
argument_list|>
name|tags
parameter_list|)
block|{
name|this
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
literal|0
argument_list|,
name|qualifier
operator|==
literal|null
condition|?
literal|0
else|:
name|qualifier
operator|.
name|length
argument_list|,
name|timestamp
argument_list|,
name|type
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|value
operator|==
literal|null
condition|?
literal|0
else|:
name|value
operator|.
name|length
argument_list|,
name|tags
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs KeyValue structure filled with specified values.    * @param row row key    * @param family family name    * @param qualifier column qualifier    * @param timestamp version timestamp    * @param type key type    * @param value column value    * @throws IllegalArgumentException    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
name|Type
name|type
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|byte
index|[]
name|tags
parameter_list|)
block|{
name|this
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
literal|0
argument_list|,
name|qualifier
operator|==
literal|null
condition|?
literal|0
else|:
name|qualifier
operator|.
name|length
argument_list|,
name|timestamp
argument_list|,
name|type
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|value
operator|==
literal|null
condition|?
literal|0
else|:
name|value
operator|.
name|length
argument_list|,
name|tags
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs KeyValue structure filled with specified values.    * @param row row key    * @param family family name    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    * @param timestamp version timestamp    * @param type key type    * @param value column value    * @param voffset value offset    * @param vlength value length    * @throws IllegalArgumentException    */
specifier|public
name|KeyValue
parameter_list|(
name|byte
index|[]
name|row
parameter_list|,
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|int
name|qoffset
parameter_list|,
name|int
name|qlength
parameter_list|,
name|long
name|timestamp
parameter_list|,
name|Type
name|type
parameter_list|,
name|byte
index|[]
name|value
parameter_list|,
name|int
name|voffset
parameter_list|,
name|int
name|vlength
parameter_list|,
name|List
argument_list|<
name|Tag
argument_list|>
name|tags
parameter_list|)
block|{
name|this
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
name|row
operator|==
literal|null
condition|?
literal|0
else|:
name|row
operator|.
name|length
argument_list|,
name|family
argument_list|,
literal|0
argument_list|,
name|family
operator|==
literal|null
condition|?
literal|0
else|:
name|family
operator|.
name|length
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|,
name|timestamp
argument_list|,
name|type
argument_list|,
name|value
argument_list|,
name|voffset
argument_list|,
name|vlength
argument_list|,
name|tags
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param row    * @param family    * @param qualifier    * @param qoffset    * @param qlength    * @param timestamp    * @param type    * @param value    * @param voffset    * @param vlength    * @param tags    */
specifier|public
name|KeyValue
parameter_list|(
name|byte
index|[]
name|row
parameter_list|,
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|int
name|qoffset
parameter_list|,
name|int
name|qlength
parameter_list|,
name|long
name|timestamp
parameter_list|,
name|Type
name|type
parameter_list|,
name|byte
index|[]
name|value
parameter_list|,
name|int
name|voffset
parameter_list|,
name|int
name|vlength
parameter_list|,
name|byte
index|[]
name|tags
parameter_list|)
block|{
name|this
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
name|row
operator|==
literal|null
condition|?
literal|0
else|:
name|row
operator|.
name|length
argument_list|,
name|family
argument_list|,
literal|0
argument_list|,
name|family
operator|==
literal|null
condition|?
literal|0
else|:
name|family
operator|.
name|length
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|,
name|timestamp
argument_list|,
name|type
argument_list|,
name|value
argument_list|,
name|voffset
argument_list|,
name|vlength
argument_list|,
name|tags
argument_list|,
literal|0
argument_list|,
name|tags
operator|==
literal|null
condition|?
literal|0
else|:
name|tags
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs KeyValue structure filled with specified values.    *<p>    * Column is split into two fields, family and qualifier.    * @param row row key    * @throws IllegalArgumentException    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|int
name|roffset
parameter_list|,
specifier|final
name|int
name|rlength
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|int
name|foffset
parameter_list|,
specifier|final
name|int
name|flength
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|int
name|qoffset
parameter_list|,
specifier|final
name|int
name|qlength
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|int
name|voffset
parameter_list|,
specifier|final
name|int
name|vlength
parameter_list|)
block|{
name|this
argument_list|(
name|row
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|,
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|,
name|timestamp
argument_list|,
name|type
argument_list|,
name|value
argument_list|,
name|voffset
argument_list|,
name|vlength
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs KeyValue structure filled with specified values. Uses the provided buffer as the    * data buffer.    *<p>    * Column is split into two fields, family and qualifier.    *    * @param buffer the bytes buffer to use    * @param boffset buffer offset    * @param row row key    * @param roffset row offset    * @param rlength row length    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    * @param timestamp version timestamp    * @param type key type    * @param value column value    * @param voffset value offset    * @param vlength value length    * @param tags non-empty list of tags or null    * @throws IllegalArgumentException an illegal value was passed or there is insufficient space    * remaining in the buffer    */
specifier|public
name|KeyValue
parameter_list|(
name|byte
index|[]
name|buffer
parameter_list|,
specifier|final
name|int
name|boffset
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|int
name|roffset
parameter_list|,
specifier|final
name|int
name|rlength
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|int
name|foffset
parameter_list|,
specifier|final
name|int
name|flength
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|int
name|qoffset
parameter_list|,
specifier|final
name|int
name|qlength
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|int
name|voffset
parameter_list|,
specifier|final
name|int
name|vlength
parameter_list|,
specifier|final
name|Tag
index|[]
name|tags
parameter_list|)
block|{
name|this
operator|.
name|bytes
operator|=
name|buffer
expr_stmt|;
name|this
operator|.
name|length
operator|=
name|writeByteArray
argument_list|(
name|buffer
argument_list|,
name|boffset
argument_list|,
name|row
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|,
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|,
name|timestamp
argument_list|,
name|type
argument_list|,
name|value
argument_list|,
name|voffset
argument_list|,
name|vlength
argument_list|,
name|tags
argument_list|)
expr_stmt|;
name|this
operator|.
name|offset
operator|=
name|boffset
expr_stmt|;
block|}
comment|/**    * Constructs KeyValue structure filled with specified values.    *<p>    * Column is split into two fields, family and qualifier.    * @param row row key    * @param roffset row offset    * @param rlength row length    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    * @param timestamp version timestamp    * @param type key type    * @param value column value    * @param voffset value offset    * @param vlength value length    * @param tags tags    * @throws IllegalArgumentException    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|int
name|roffset
parameter_list|,
specifier|final
name|int
name|rlength
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|int
name|foffset
parameter_list|,
specifier|final
name|int
name|flength
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|int
name|qoffset
parameter_list|,
specifier|final
name|int
name|qlength
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|int
name|voffset
parameter_list|,
specifier|final
name|int
name|vlength
parameter_list|,
specifier|final
name|List
argument_list|<
name|Tag
argument_list|>
name|tags
parameter_list|)
block|{
name|this
operator|.
name|bytes
operator|=
name|createByteArray
argument_list|(
name|row
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|,
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|,
name|timestamp
argument_list|,
name|type
argument_list|,
name|value
argument_list|,
name|voffset
argument_list|,
name|vlength
argument_list|,
name|tags
argument_list|)
expr_stmt|;
name|this
operator|.
name|length
operator|=
name|bytes
operator|.
name|length
expr_stmt|;
name|this
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/**    * @param row    * @param roffset    * @param rlength    * @param family    * @param foffset    * @param flength    * @param qualifier    * @param qoffset    * @param qlength    * @param timestamp    * @param type    * @param value    * @param voffset    * @param vlength    * @param tags    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|int
name|roffset
parameter_list|,
specifier|final
name|int
name|rlength
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|int
name|foffset
parameter_list|,
specifier|final
name|int
name|flength
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|int
name|qoffset
parameter_list|,
specifier|final
name|int
name|qlength
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|int
name|voffset
parameter_list|,
specifier|final
name|int
name|vlength
parameter_list|,
specifier|final
name|byte
index|[]
name|tags
parameter_list|,
specifier|final
name|int
name|tagsOffset
parameter_list|,
specifier|final
name|int
name|tagsLength
parameter_list|)
block|{
name|this
operator|.
name|bytes
operator|=
name|createByteArray
argument_list|(
name|row
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|,
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|,
name|timestamp
argument_list|,
name|type
argument_list|,
name|value
argument_list|,
name|voffset
argument_list|,
name|vlength
argument_list|,
name|tags
argument_list|,
name|tagsOffset
argument_list|,
name|tagsLength
argument_list|)
expr_stmt|;
name|this
operator|.
name|length
operator|=
name|bytes
operator|.
name|length
expr_stmt|;
name|this
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/**    * Constructs an empty KeyValue structure, with specified sizes.    * This can be used to partially fill up KeyValues.    *<p>    * Column is split into two fields, family and qualifier.    * @param rlength row length    * @param flength family length    * @param qlength qualifier length    * @param timestamp version timestamp    * @param type key type    * @param vlength value length    * @throws IllegalArgumentException    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|int
name|rlength
parameter_list|,
specifier|final
name|int
name|flength
parameter_list|,
specifier|final
name|int
name|qlength
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|,
specifier|final
name|int
name|vlength
parameter_list|)
block|{
name|this
argument_list|(
name|rlength
argument_list|,
name|flength
argument_list|,
name|qlength
argument_list|,
name|timestamp
argument_list|,
name|type
argument_list|,
name|vlength
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs an empty KeyValue structure, with specified sizes.    * This can be used to partially fill up KeyValues.    *<p>    * Column is split into two fields, family and qualifier.    * @param rlength row length    * @param flength family length    * @param qlength qualifier length    * @param timestamp version timestamp    * @param type key type    * @param vlength value length    * @param tagsLength    * @throws IllegalArgumentException    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|int
name|rlength
parameter_list|,
specifier|final
name|int
name|flength
parameter_list|,
specifier|final
name|int
name|qlength
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|,
specifier|final
name|int
name|vlength
parameter_list|,
specifier|final
name|int
name|tagsLength
parameter_list|)
block|{
name|this
operator|.
name|bytes
operator|=
name|createEmptyByteArray
argument_list|(
name|rlength
argument_list|,
name|flength
argument_list|,
name|qlength
argument_list|,
name|timestamp
argument_list|,
name|type
argument_list|,
name|vlength
argument_list|,
name|tagsLength
argument_list|)
expr_stmt|;
name|this
operator|.
name|length
operator|=
name|bytes
operator|.
name|length
expr_stmt|;
name|this
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
name|KeyValue
parameter_list|(
name|byte
index|[]
name|row
parameter_list|,
name|int
name|roffset
parameter_list|,
name|int
name|rlength
parameter_list|,
name|byte
index|[]
name|family
parameter_list|,
name|int
name|foffset
parameter_list|,
name|int
name|flength
parameter_list|,
name|ByteBuffer
name|qualifier
parameter_list|,
name|long
name|ts
parameter_list|,
name|Type
name|type
parameter_list|,
name|ByteBuffer
name|value
parameter_list|,
name|List
argument_list|<
name|Tag
argument_list|>
name|tags
parameter_list|)
block|{
name|this
operator|.
name|bytes
operator|=
name|createByteArray
argument_list|(
name|row
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|,
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
literal|0
argument_list|,
name|qualifier
operator|==
literal|null
condition|?
literal|0
else|:
name|qualifier
operator|.
name|remaining
argument_list|()
argument_list|,
name|ts
argument_list|,
name|type
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|value
operator|==
literal|null
condition|?
literal|0
else|:
name|value
operator|.
name|remaining
argument_list|()
argument_list|,
name|tags
argument_list|)
expr_stmt|;
name|this
operator|.
name|length
operator|=
name|bytes
operator|.
name|length
expr_stmt|;
name|this
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
name|KeyValue
parameter_list|(
name|Cell
name|c
parameter_list|)
block|{
name|this
argument_list|(
name|c
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|c
operator|.
name|getRowOffset
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|c
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|c
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|c
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|c
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|c
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|c
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|c
operator|.
name|getQualifierLength
argument_list|()
argument_list|,
name|c
operator|.
name|getTimestamp
argument_list|()
argument_list|,
name|Type
operator|.
name|codeToType
argument_list|(
name|c
operator|.
name|getTypeByte
argument_list|()
argument_list|)
argument_list|,
name|c
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|c
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|c
operator|.
name|getValueLength
argument_list|()
argument_list|,
name|c
operator|.
name|getTagsArray
argument_list|()
argument_list|,
name|c
operator|.
name|getTagsOffset
argument_list|()
argument_list|,
name|c
operator|.
name|getTagsLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create an empty byte[] representing a KeyValue    * All lengths are preset and can be filled in later.    * @param rlength    * @param flength    * @param qlength    * @param timestamp    * @param type    * @param vlength    * @return The newly created byte array.    */
specifier|private
specifier|static
name|byte
index|[]
name|createEmptyByteArray
parameter_list|(
specifier|final
name|int
name|rlength
parameter_list|,
name|int
name|flength
parameter_list|,
name|int
name|qlength
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|,
name|int
name|vlength
parameter_list|,
name|int
name|tagsLength
parameter_list|)
block|{
if|if
condition|(
name|rlength
operator|>
name|Short
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Row> "
operator|+
name|Short
operator|.
name|MAX_VALUE
argument_list|)
throw|;
block|}
if|if
condition|(
name|flength
operator|>
name|Byte
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Family> "
operator|+
name|Byte
operator|.
name|MAX_VALUE
argument_list|)
throw|;
block|}
comment|// Qualifier length
if|if
condition|(
name|qlength
operator|>
name|Integer
operator|.
name|MAX_VALUE
operator|-
name|rlength
operator|-
name|flength
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Qualifier> "
operator|+
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
throw|;
block|}
name|checkForTagsLength
argument_list|(
name|tagsLength
argument_list|)
expr_stmt|;
comment|// Key length
name|long
name|longkeylength
init|=
name|getKeyDataStructureSize
argument_list|(
name|rlength
argument_list|,
name|flength
argument_list|,
name|qlength
argument_list|)
decl_stmt|;
if|if
condition|(
name|longkeylength
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"keylength "
operator|+
name|longkeylength
operator|+
literal|"> "
operator|+
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
throw|;
block|}
name|int
name|keylength
init|=
operator|(
name|int
operator|)
name|longkeylength
decl_stmt|;
comment|// Value length
if|if
condition|(
name|vlength
operator|>
name|HConstants
operator|.
name|MAXIMUM_VALUE_LENGTH
condition|)
block|{
comment|// FindBugs INT_VACUOUS_COMPARISON
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Valuer> "
operator|+
name|HConstants
operator|.
name|MAXIMUM_VALUE_LENGTH
argument_list|)
throw|;
block|}
comment|// Allocate right-sized byte array.
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
operator|(
name|int
operator|)
name|getKeyValueDataStructureSize
argument_list|(
name|rlength
argument_list|,
name|flength
argument_list|,
name|qlength
argument_list|,
name|vlength
argument_list|,
name|tagsLength
argument_list|)
index|]
decl_stmt|;
comment|// Write the correct size markers
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putInt
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|keylength
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putInt
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|vlength
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putShort
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
call|(
name|short
call|)
argument_list|(
name|rlength
operator|&
literal|0x0000ffff
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|rlength
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putByte
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
call|(
name|byte
call|)
argument_list|(
name|flength
operator|&
literal|0x0000ff
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|flength
operator|+
name|qlength
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putLong
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putByte
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|type
operator|.
name|getCode
argument_list|()
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|vlength
expr_stmt|;
if|if
condition|(
name|tagsLength
operator|>
literal|0
condition|)
block|{
name|pos
operator|=
name|Bytes
operator|.
name|putShort
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
call|(
name|short
call|)
argument_list|(
name|tagsLength
operator|&
literal|0x0000ffff
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|bytes
return|;
block|}
comment|/**    * Checks the parameters passed to a constructor.    *    * @param row row key    * @param rlength row length    * @param family family name    * @param flength family length    * @param qlength qualifier length    * @param vlength value length    *    * @throws IllegalArgumentException an illegal value was passed    */
specifier|private
specifier|static
name|void
name|checkParameters
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|int
name|rlength
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
name|int
name|flength
parameter_list|,
name|int
name|qlength
parameter_list|,
name|int
name|vlength
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|rlength
operator|>
name|Short
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Row> "
operator|+
name|Short
operator|.
name|MAX_VALUE
argument_list|)
throw|;
block|}
if|if
condition|(
name|row
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Row is null"
argument_list|)
throw|;
block|}
comment|// Family length
name|flength
operator|=
name|family
operator|==
literal|null
condition|?
literal|0
else|:
name|flength
expr_stmt|;
if|if
condition|(
name|flength
operator|>
name|Byte
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Family> "
operator|+
name|Byte
operator|.
name|MAX_VALUE
argument_list|)
throw|;
block|}
comment|// Qualifier length
if|if
condition|(
name|qlength
operator|>
name|Integer
operator|.
name|MAX_VALUE
operator|-
name|rlength
operator|-
name|flength
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Qualifier> "
operator|+
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
throw|;
block|}
comment|// Key length
name|long
name|longKeyLength
init|=
name|getKeyDataStructureSize
argument_list|(
name|rlength
argument_list|,
name|flength
argument_list|,
name|qlength
argument_list|)
decl_stmt|;
if|if
condition|(
name|longKeyLength
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"keylength "
operator|+
name|longKeyLength
operator|+
literal|"> "
operator|+
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
throw|;
block|}
comment|// Value length
if|if
condition|(
name|vlength
operator|>
name|HConstants
operator|.
name|MAXIMUM_VALUE_LENGTH
condition|)
block|{
comment|// FindBugs INT_VACUOUS_COMPARISON
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Value length "
operator|+
name|vlength
operator|+
literal|"> "
operator|+
name|HConstants
operator|.
name|MAXIMUM_VALUE_LENGTH
argument_list|)
throw|;
block|}
block|}
comment|/**    * Write KeyValue format into the provided byte array.    *    * @param buffer the bytes buffer to use    * @param boffset buffer offset    * @param row row key    * @param roffset row offset    * @param rlength row length    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    * @param timestamp version timestamp    * @param type key type    * @param value column value    * @param voffset value offset    * @param vlength value length    *    * @return The number of useful bytes in the buffer.    *    * @throws IllegalArgumentException an illegal value was passed or there is insufficient space    * remaining in the buffer    */
specifier|private
specifier|static
name|int
name|writeByteArray
parameter_list|(
name|byte
index|[]
name|buffer
parameter_list|,
specifier|final
name|int
name|boffset
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|int
name|roffset
parameter_list|,
specifier|final
name|int
name|rlength
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|int
name|foffset
parameter_list|,
name|int
name|flength
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|int
name|qoffset
parameter_list|,
name|int
name|qlength
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|int
name|voffset
parameter_list|,
name|int
name|vlength
parameter_list|,
name|Tag
index|[]
name|tags
parameter_list|)
block|{
name|checkParameters
argument_list|(
name|row
argument_list|,
name|rlength
argument_list|,
name|family
argument_list|,
name|flength
argument_list|,
name|qlength
argument_list|,
name|vlength
argument_list|)
expr_stmt|;
comment|// Calculate length of tags area
name|int
name|tagsLength
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tags
operator|!=
literal|null
operator|&&
name|tags
operator|.
name|length
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|Tag
name|t
range|:
name|tags
control|)
block|{
name|tagsLength
operator|+=
name|t
operator|.
name|getLength
argument_list|()
expr_stmt|;
block|}
block|}
name|checkForTagsLength
argument_list|(
name|tagsLength
argument_list|)
expr_stmt|;
name|int
name|keyLength
init|=
operator|(
name|int
operator|)
name|getKeyDataStructureSize
argument_list|(
name|rlength
argument_list|,
name|flength
argument_list|,
name|qlength
argument_list|)
decl_stmt|;
name|int
name|keyValueLength
init|=
operator|(
name|int
operator|)
name|getKeyValueDataStructureSize
argument_list|(
name|rlength
argument_list|,
name|flength
argument_list|,
name|qlength
argument_list|,
name|vlength
argument_list|,
name|tagsLength
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyValueLength
operator|>
name|buffer
operator|.
name|length
operator|-
name|boffset
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Buffer size "
operator|+
operator|(
name|buffer
operator|.
name|length
operator|-
name|boffset
operator|)
operator|+
literal|"< "
operator|+
name|keyValueLength
argument_list|)
throw|;
block|}
comment|// Write key, value and key row length.
name|int
name|pos
init|=
name|boffset
decl_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putInt
argument_list|(
name|buffer
argument_list|,
name|pos
argument_list|,
name|keyLength
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putInt
argument_list|(
name|buffer
argument_list|,
name|pos
argument_list|,
name|vlength
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putShort
argument_list|(
name|buffer
argument_list|,
name|pos
argument_list|,
call|(
name|short
call|)
argument_list|(
name|rlength
operator|&
literal|0x0000ffff
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putBytes
argument_list|(
name|buffer
argument_list|,
name|pos
argument_list|,
name|row
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putByte
argument_list|(
name|buffer
argument_list|,
name|pos
argument_list|,
call|(
name|byte
call|)
argument_list|(
name|flength
operator|&
literal|0x0000ff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flength
operator|!=
literal|0
condition|)
block|{
name|pos
operator|=
name|Bytes
operator|.
name|putBytes
argument_list|(
name|buffer
argument_list|,
name|pos
argument_list|,
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qlength
operator|!=
literal|0
condition|)
block|{
name|pos
operator|=
name|Bytes
operator|.
name|putBytes
argument_list|(
name|buffer
argument_list|,
name|pos
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
expr_stmt|;
block|}
name|pos
operator|=
name|Bytes
operator|.
name|putLong
argument_list|(
name|buffer
argument_list|,
name|pos
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putByte
argument_list|(
name|buffer
argument_list|,
name|pos
argument_list|,
name|type
operator|.
name|getCode
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
name|value
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|pos
operator|=
name|Bytes
operator|.
name|putBytes
argument_list|(
name|buffer
argument_list|,
name|pos
argument_list|,
name|value
argument_list|,
name|voffset
argument_list|,
name|vlength
argument_list|)
expr_stmt|;
block|}
comment|// Write the number of tags. If it is 0 then it means there are no tags.
if|if
condition|(
name|tagsLength
operator|>
literal|0
condition|)
block|{
name|pos
operator|=
name|Bytes
operator|.
name|putShort
argument_list|(
name|buffer
argument_list|,
name|pos
argument_list|,
operator|(
name|short
operator|)
name|tagsLength
argument_list|)
expr_stmt|;
for|for
control|(
name|Tag
name|t
range|:
name|tags
control|)
block|{
name|pos
operator|=
name|Bytes
operator|.
name|putBytes
argument_list|(
name|buffer
argument_list|,
name|pos
argument_list|,
name|t
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|t
operator|.
name|getOffset
argument_list|()
argument_list|,
name|t
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|keyValueLength
return|;
block|}
specifier|private
specifier|static
name|void
name|checkForTagsLength
parameter_list|(
name|int
name|tagsLength
parameter_list|)
block|{
if|if
condition|(
name|tagsLength
operator|>
name|Short
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"tagslength "
operator|+
name|tagsLength
operator|+
literal|"> "
operator|+
name|Short
operator|.
name|MAX_VALUE
argument_list|)
throw|;
block|}
block|}
comment|/**    * Write KeyValue format into a byte array.    * @param row row key    * @param roffset row offset    * @param rlength row length    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    * @param timestamp version timestamp    * @param type key type    * @param value column value    * @param voffset value offset    * @param vlength value length    * @return The newly created byte array.    */
specifier|private
specifier|static
name|byte
index|[]
name|createByteArray
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|int
name|roffset
parameter_list|,
specifier|final
name|int
name|rlength
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|int
name|foffset
parameter_list|,
name|int
name|flength
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|int
name|qoffset
parameter_list|,
name|int
name|qlength
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|int
name|voffset
parameter_list|,
name|int
name|vlength
parameter_list|,
name|byte
index|[]
name|tags
parameter_list|,
name|int
name|tagsOffset
parameter_list|,
name|int
name|tagsLength
parameter_list|)
block|{
name|checkParameters
argument_list|(
name|row
argument_list|,
name|rlength
argument_list|,
name|family
argument_list|,
name|flength
argument_list|,
name|qlength
argument_list|,
name|vlength
argument_list|)
expr_stmt|;
name|checkForTagsLength
argument_list|(
name|tagsLength
argument_list|)
expr_stmt|;
comment|// Allocate right-sized byte array.
name|int
name|keyLength
init|=
operator|(
name|int
operator|)
name|getKeyDataStructureSize
argument_list|(
name|rlength
argument_list|,
name|flength
argument_list|,
name|qlength
argument_list|)
decl_stmt|;
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
operator|(
name|int
operator|)
name|getKeyValueDataStructureSize
argument_list|(
name|rlength
argument_list|,
name|flength
argument_list|,
name|qlength
argument_list|,
name|vlength
argument_list|,
name|tagsLength
argument_list|)
index|]
decl_stmt|;
comment|// Write key, value and key row length.
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putInt
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|keyLength
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putInt
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|vlength
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putShort
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
call|(
name|short
call|)
argument_list|(
name|rlength
operator|&
literal|0x0000ffff
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putBytes
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|row
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putByte
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
call|(
name|byte
call|)
argument_list|(
name|flength
operator|&
literal|0x0000ff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flength
operator|!=
literal|0
condition|)
block|{
name|pos
operator|=
name|Bytes
operator|.
name|putBytes
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qlength
operator|!=
literal|0
condition|)
block|{
name|pos
operator|=
name|Bytes
operator|.
name|putBytes
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
expr_stmt|;
block|}
name|pos
operator|=
name|Bytes
operator|.
name|putLong
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putByte
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|type
operator|.
name|getCode
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
name|value
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|pos
operator|=
name|Bytes
operator|.
name|putBytes
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|value
argument_list|,
name|voffset
argument_list|,
name|vlength
argument_list|)
expr_stmt|;
block|}
comment|// Add the tags after the value part
if|if
condition|(
name|tagsLength
operator|>
literal|0
condition|)
block|{
name|pos
operator|=
name|Bytes
operator|.
name|putShort
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
call|(
name|short
call|)
argument_list|(
name|tagsLength
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putBytes
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|tags
argument_list|,
name|tagsOffset
argument_list|,
name|tagsLength
argument_list|)
expr_stmt|;
block|}
return|return
name|bytes
return|;
block|}
comment|/**    * @param qualifier can be a ByteBuffer or a byte[], or null.    * @param value can be a ByteBuffer or a byte[], or null.    */
specifier|private
specifier|static
name|byte
index|[]
name|createByteArray
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|int
name|roffset
parameter_list|,
specifier|final
name|int
name|rlength
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|int
name|foffset
parameter_list|,
name|int
name|flength
parameter_list|,
specifier|final
name|Object
name|qualifier
parameter_list|,
specifier|final
name|int
name|qoffset
parameter_list|,
name|int
name|qlength
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|,
specifier|final
name|Object
name|value
parameter_list|,
specifier|final
name|int
name|voffset
parameter_list|,
name|int
name|vlength
parameter_list|,
name|List
argument_list|<
name|Tag
argument_list|>
name|tags
parameter_list|)
block|{
name|checkParameters
argument_list|(
name|row
argument_list|,
name|rlength
argument_list|,
name|family
argument_list|,
name|flength
argument_list|,
name|qlength
argument_list|,
name|vlength
argument_list|)
expr_stmt|;
comment|// Calculate length of tags area
name|int
name|tagsLength
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tags
operator|!=
literal|null
operator|&&
operator|!
name|tags
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Tag
name|t
range|:
name|tags
control|)
block|{
name|tagsLength
operator|+=
name|t
operator|.
name|getLength
argument_list|()
expr_stmt|;
block|}
block|}
name|checkForTagsLength
argument_list|(
name|tagsLength
argument_list|)
expr_stmt|;
comment|// Allocate right-sized byte array.
name|int
name|keyLength
init|=
operator|(
name|int
operator|)
name|getKeyDataStructureSize
argument_list|(
name|rlength
argument_list|,
name|flength
argument_list|,
name|qlength
argument_list|)
decl_stmt|;
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
operator|(
name|int
operator|)
name|getKeyValueDataStructureSize
argument_list|(
name|rlength
argument_list|,
name|flength
argument_list|,
name|qlength
argument_list|,
name|vlength
argument_list|,
name|tagsLength
argument_list|)
index|]
decl_stmt|;
comment|// Write key, value and key row length.
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putInt
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|keyLength
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putInt
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|vlength
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putShort
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
call|(
name|short
call|)
argument_list|(
name|rlength
operator|&
literal|0x0000ffff
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putBytes
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|row
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putByte
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
call|(
name|byte
call|)
argument_list|(
name|flength
operator|&
literal|0x0000ff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flength
operator|!=
literal|0
condition|)
block|{
name|pos
operator|=
name|Bytes
operator|.
name|putBytes
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qlength
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|qualifier
operator|instanceof
name|ByteBuffer
condition|)
block|{
name|pos
operator|=
name|Bytes
operator|.
name|putByteBuffer
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
operator|(
name|ByteBuffer
operator|)
name|qualifier
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|=
name|Bytes
operator|.
name|putBytes
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
operator|(
name|byte
index|[]
operator|)
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
expr_stmt|;
block|}
block|}
name|pos
operator|=
name|Bytes
operator|.
name|putLong
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putByte
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|type
operator|.
name|getCode
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlength
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|ByteBuffer
condition|)
block|{
name|pos
operator|=
name|Bytes
operator|.
name|putByteBuffer
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
operator|(
name|ByteBuffer
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|=
name|Bytes
operator|.
name|putBytes
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
operator|(
name|byte
index|[]
operator|)
name|value
argument_list|,
name|voffset
argument_list|,
name|vlength
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Add the tags after the value part
if|if
condition|(
name|tagsLength
operator|>
literal|0
condition|)
block|{
name|pos
operator|=
name|Bytes
operator|.
name|putShort
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
call|(
name|short
call|)
argument_list|(
name|tagsLength
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Tag
name|t
range|:
name|tags
control|)
block|{
name|pos
operator|=
name|Bytes
operator|.
name|putBytes
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|t
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|t
operator|.
name|getOffset
argument_list|()
argument_list|,
name|t
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|bytes
return|;
block|}
comment|/**    * Needed doing 'contains' on List.  Only compares the key portion, not the value.    */
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|other
operator|instanceof
name|Cell
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|CellComparator
operator|.
name|equals
argument_list|(
name|this
argument_list|,
operator|(
name|Cell
operator|)
name|other
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|byte
index|[]
name|b
init|=
name|getBuffer
argument_list|()
decl_stmt|;
name|int
name|start
init|=
name|getOffset
argument_list|()
decl_stmt|,
name|end
init|=
name|getOffset
argument_list|()
operator|+
name|getLength
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|b
index|[
name|start
operator|++
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|h
operator|=
operator|(
name|h
operator|*
literal|13
operator|)
operator|^
name|b
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
comment|//---------------------------------------------------------------------------
comment|//
comment|//  KeyValue cloning
comment|//
comment|//---------------------------------------------------------------------------
comment|/**    * Clones a KeyValue.  This creates a copy, re-allocating the buffer.    * @return Fully copied clone of this KeyValue    * @throws CloneNotSupportedException    */
annotation|@
name|Override
specifier|public
name|KeyValue
name|clone
parameter_list|()
throws|throws
name|CloneNotSupportedException
block|{
name|super
operator|.
name|clone
argument_list|()
expr_stmt|;
name|byte
index|[]
name|b
init|=
operator|new
name|byte
index|[
name|this
operator|.
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|this
operator|.
name|bytes
argument_list|,
name|this
operator|.
name|offset
argument_list|,
name|b
argument_list|,
literal|0
argument_list|,
name|this
operator|.
name|length
argument_list|)
expr_stmt|;
name|KeyValue
name|ret
init|=
operator|new
name|KeyValue
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|length
argument_list|)
decl_stmt|;
comment|// Important to clone the memstoreTS as well - otherwise memstore's
comment|// update-in-place methods (eg increment) will end up creating
comment|// new entries
name|ret
operator|.
name|setMvccVersion
argument_list|(
name|mvcc
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**    * Creates a shallow copy of this KeyValue, reusing the data byte buffer.    * http://en.wikipedia.org/wiki/Object_copy    * @return Shallow copy of this KeyValue    */
specifier|public
name|KeyValue
name|shallowCopy
parameter_list|()
block|{
name|KeyValue
name|shallowCopy
init|=
operator|new
name|KeyValue
argument_list|(
name|this
operator|.
name|bytes
argument_list|,
name|this
operator|.
name|offset
argument_list|,
name|this
operator|.
name|length
argument_list|)
decl_stmt|;
name|shallowCopy
operator|.
name|setMvccVersion
argument_list|(
name|this
operator|.
name|mvcc
argument_list|)
expr_stmt|;
return|return
name|shallowCopy
return|;
block|}
comment|//---------------------------------------------------------------------------
comment|//
comment|//  String representation
comment|//
comment|//---------------------------------------------------------------------------
specifier|public
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|bytes
operator|==
literal|null
operator|||
name|this
operator|.
name|bytes
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|"empty"
return|;
block|}
return|return
name|keyToString
argument_list|(
name|this
operator|.
name|bytes
argument_list|,
name|this
operator|.
name|offset
operator|+
name|ROW_OFFSET
argument_list|,
name|getKeyLength
argument_list|()
argument_list|)
operator|+
literal|"/vlen="
operator|+
name|getValueLength
argument_list|()
operator|+
literal|"/mvcc="
operator|+
name|mvcc
return|;
block|}
comment|/**    * @param k Key portion of a KeyValue.    * @return Key as a String, empty string if k is null.     */
specifier|public
specifier|static
name|String
name|keyToString
parameter_list|(
specifier|final
name|byte
index|[]
name|k
parameter_list|)
block|{
if|if
condition|(
name|k
operator|==
literal|null
condition|)
block|{
return|return
literal|""
return|;
block|}
return|return
name|keyToString
argument_list|(
name|k
argument_list|,
literal|0
argument_list|,
name|k
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * Produces a string map for this key/value pair. Useful for programmatic use    * and manipulation of the data stored in an HLogKey, for example, printing    * as JSON. Values are left out due to their tendency to be large. If needed,    * they can be added manually.    *    * @return the Map<String,?> containing data from this key    */
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|toStringMap
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|stringMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|stringMap
operator|.
name|put
argument_list|(
literal|"row"
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|getRow
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|stringMap
operator|.
name|put
argument_list|(
literal|"family"
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|getFamily
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|stringMap
operator|.
name|put
argument_list|(
literal|"qualifier"
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|getQualifier
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|stringMap
operator|.
name|put
argument_list|(
literal|"timestamp"
argument_list|,
name|getTimestamp
argument_list|()
argument_list|)
expr_stmt|;
name|stringMap
operator|.
name|put
argument_list|(
literal|"vlen"
argument_list|,
name|getValueLength
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Tag
argument_list|>
name|tags
init|=
name|getTags
argument_list|()
decl_stmt|;
if|if
condition|(
name|tags
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|tagsString
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Tag
name|t
range|:
name|tags
control|)
block|{
name|tagsString
operator|.
name|add
argument_list|(
operator|(
name|t
operator|.
name|getType
argument_list|()
operator|)
operator|+
literal|":"
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|t
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|stringMap
operator|.
name|put
argument_list|(
literal|"tag"
argument_list|,
name|tagsString
argument_list|)
expr_stmt|;
block|}
return|return
name|stringMap
return|;
block|}
comment|/**    * Use for logging.    * @param b Key portion of a KeyValue.    * @param o Offset to start of key    * @param l Length of key.    * @return Key as a String.    */
specifier|public
specifier|static
name|String
name|keyToString
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|,
specifier|final
name|int
name|o
parameter_list|,
specifier|final
name|int
name|l
parameter_list|)
block|{
if|if
condition|(
name|b
operator|==
literal|null
condition|)
return|return
literal|""
return|;
name|int
name|rowlength
init|=
name|Bytes
operator|.
name|toShort
argument_list|(
name|b
argument_list|,
name|o
argument_list|)
decl_stmt|;
name|String
name|row
init|=
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|b
argument_list|,
name|o
operator|+
name|Bytes
operator|.
name|SIZEOF_SHORT
argument_list|,
name|rowlength
argument_list|)
decl_stmt|;
name|int
name|columnoffset
init|=
name|o
operator|+
name|Bytes
operator|.
name|SIZEOF_SHORT
operator|+
literal|1
operator|+
name|rowlength
decl_stmt|;
name|int
name|familylength
init|=
name|b
index|[
name|columnoffset
operator|-
literal|1
index|]
decl_stmt|;
name|int
name|columnlength
init|=
name|l
operator|-
operator|(
operator|(
name|columnoffset
operator|-
name|o
operator|)
operator|+
name|TIMESTAMP_TYPE_SIZE
operator|)
decl_stmt|;
name|String
name|family
init|=
name|familylength
operator|==
literal|0
condition|?
literal|""
else|:
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|b
argument_list|,
name|columnoffset
argument_list|,
name|familylength
argument_list|)
decl_stmt|;
name|String
name|qualifier
init|=
name|columnlength
operator|==
literal|0
condition|?
literal|""
else|:
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|b
argument_list|,
name|columnoffset
operator|+
name|familylength
argument_list|,
name|columnlength
operator|-
name|familylength
argument_list|)
decl_stmt|;
name|long
name|timestamp
init|=
name|Bytes
operator|.
name|toLong
argument_list|(
name|b
argument_list|,
name|o
operator|+
operator|(
name|l
operator|-
name|TIMESTAMP_TYPE_SIZE
operator|)
argument_list|)
decl_stmt|;
name|String
name|timestampStr
init|=
name|humanReadableTimestamp
argument_list|(
name|timestamp
argument_list|)
decl_stmt|;
name|byte
name|type
init|=
name|b
index|[
name|o
operator|+
name|l
operator|-
literal|1
index|]
decl_stmt|;
return|return
name|row
operator|+
literal|"/"
operator|+
name|family
operator|+
operator|(
name|family
operator|!=
literal|null
operator|&&
name|family
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|?
literal|":"
else|:
literal|""
operator|)
operator|+
name|qualifier
operator|+
literal|"/"
operator|+
name|timestampStr
operator|+
literal|"/"
operator|+
name|Type
operator|.
name|codeToType
argument_list|(
name|type
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|String
name|humanReadableTimestamp
parameter_list|(
specifier|final
name|long
name|timestamp
parameter_list|)
block|{
if|if
condition|(
name|timestamp
operator|==
name|HConstants
operator|.
name|LATEST_TIMESTAMP
condition|)
block|{
return|return
literal|"LATEST_TIMESTAMP"
return|;
block|}
if|if
condition|(
name|timestamp
operator|==
name|HConstants
operator|.
name|OLDEST_TIMESTAMP
condition|)
block|{
return|return
literal|"OLDEST_TIMESTAMP"
return|;
block|}
return|return
name|String
operator|.
name|valueOf
argument_list|(
name|timestamp
argument_list|)
return|;
block|}
comment|//---------------------------------------------------------------------------
comment|//
comment|//  Public Member Accessors
comment|//
comment|//---------------------------------------------------------------------------
comment|/**    * @return The byte array backing this KeyValue.    * @deprecated Since 0.98.0.  Use Cell Interface instead.  Do not presume single backing buffer.    */
annotation|@
name|Deprecated
specifier|public
name|byte
index|[]
name|getBuffer
parameter_list|()
block|{
return|return
name|this
operator|.
name|bytes
return|;
block|}
comment|/**    * @return Offset into {@link #getBuffer()} at which this KeyValue starts.    */
specifier|public
name|int
name|getOffset
parameter_list|()
block|{
return|return
name|this
operator|.
name|offset
return|;
block|}
comment|/**    * @return Length of bytes this KeyValue occupies in {@link #getBuffer()}.    */
specifier|public
name|int
name|getLength
parameter_list|()
block|{
return|return
name|length
return|;
block|}
comment|//---------------------------------------------------------------------------
comment|//
comment|//  Length and Offset Calculators
comment|//
comment|//---------------------------------------------------------------------------
comment|/**    * Determines the total length of the KeyValue stored in the specified    * byte array and offset.  Includes all headers.    * @param bytes byte array    * @param offset offset to start of the KeyValue    * @return length of entire KeyValue, in bytes    */
specifier|private
specifier|static
name|int
name|getLength
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|int
name|klength
init|=
name|ROW_OFFSET
operator|+
name|Bytes
operator|.
name|toInt
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|int
name|vlength
init|=
name|Bytes
operator|.
name|toInt
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
name|Bytes
operator|.
name|SIZEOF_INT
argument_list|)
decl_stmt|;
return|return
name|klength
operator|+
name|vlength
return|;
block|}
comment|/**    * @return Key offset in backing buffer..    */
specifier|public
name|int
name|getKeyOffset
parameter_list|()
block|{
return|return
name|this
operator|.
name|offset
operator|+
name|ROW_OFFSET
return|;
block|}
specifier|public
name|String
name|getKeyString
parameter_list|()
block|{
return|return
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|getBuffer
argument_list|()
argument_list|,
name|getKeyOffset
argument_list|()
argument_list|,
name|getKeyLength
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @return Length of key portion.    */
specifier|public
name|int
name|getKeyLength
parameter_list|()
block|{
return|return
name|Bytes
operator|.
name|toInt
argument_list|(
name|this
operator|.
name|bytes
argument_list|,
name|this
operator|.
name|offset
argument_list|)
return|;
block|}
comment|/**    * @return the backing array of the entire KeyValue (all KeyValue fields are in a single array)    */
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|getValueArray
parameter_list|()
block|{
return|return
name|bytes
return|;
block|}
comment|/**    * @return the value offset    */
annotation|@
name|Override
specifier|public
name|int
name|getValueOffset
parameter_list|()
block|{
name|int
name|voffset
init|=
name|getKeyOffset
argument_list|()
operator|+
name|getKeyLength
argument_list|()
decl_stmt|;
return|return
name|voffset
return|;
block|}
comment|/**    * @return Value length    */
annotation|@
name|Override
specifier|public
name|int
name|getValueLength
parameter_list|()
block|{
name|int
name|vlength
init|=
name|Bytes
operator|.
name|toInt
argument_list|(
name|this
operator|.
name|bytes
argument_list|,
name|this
operator|.
name|offset
operator|+
name|Bytes
operator|.
name|SIZEOF_INT
argument_list|)
decl_stmt|;
return|return
name|vlength
return|;
block|}
comment|/**    * @return the backing array of the entire KeyValue (all KeyValue fields are in a single array)    */
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|getRowArray
parameter_list|()
block|{
return|return
name|bytes
return|;
block|}
comment|/**    * @return Row offset    */
annotation|@
name|Override
specifier|public
name|int
name|getRowOffset
parameter_list|()
block|{
return|return
name|getKeyOffset
argument_list|()
operator|+
name|Bytes
operator|.
name|SIZEOF_SHORT
return|;
block|}
comment|/**    * @return Row length    */
annotation|@
name|Override
specifier|public
name|short
name|getRowLength
parameter_list|()
block|{
return|return
name|Bytes
operator|.
name|toShort
argument_list|(
name|this
operator|.
name|bytes
argument_list|,
name|getKeyOffset
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @return the backing array of the entire KeyValue (all KeyValue fields are in a single array)    */
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|getFamilyArray
parameter_list|()
block|{
return|return
name|bytes
return|;
block|}
comment|/**    * @return Family offset    */
annotation|@
name|Override
specifier|public
name|int
name|getFamilyOffset
parameter_list|()
block|{
return|return
name|getFamilyOffset
argument_list|(
name|getRowLength
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @return Family offset    */
specifier|private
name|int
name|getFamilyOffset
parameter_list|(
name|int
name|rlength
parameter_list|)
block|{
return|return
name|this
operator|.
name|offset
operator|+
name|ROW_OFFSET
operator|+
name|Bytes
operator|.
name|SIZEOF_SHORT
operator|+
name|rlength
operator|+
name|Bytes
operator|.
name|SIZEOF_BYTE
return|;
block|}
comment|/**    * @return Family length    */
annotation|@
name|Override
specifier|public
name|byte
name|getFamilyLength
parameter_list|()
block|{
return|return
name|getFamilyLength
argument_list|(
name|getFamilyOffset
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @return Family length    */
specifier|public
name|byte
name|getFamilyLength
parameter_list|(
name|int
name|foffset
parameter_list|)
block|{
return|return
name|this
operator|.
name|bytes
index|[
name|foffset
operator|-
literal|1
index|]
return|;
block|}
comment|/**    * @return the backing array of the entire KeyValue (all KeyValue fields are in a single array)    */
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|getQualifierArray
parameter_list|()
block|{
return|return
name|bytes
return|;
block|}
comment|/**    * @return Qualifier offset    */
annotation|@
name|Override
specifier|public
name|int
name|getQualifierOffset
parameter_list|()
block|{
return|return
name|getQualifierOffset
argument_list|(
name|getFamilyOffset
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @return Qualifier offset    */
specifier|private
name|int
name|getQualifierOffset
parameter_list|(
name|int
name|foffset
parameter_list|)
block|{
return|return
name|foffset
operator|+
name|getFamilyLength
argument_list|(
name|foffset
argument_list|)
return|;
block|}
comment|/**    * @return Qualifier length    */
annotation|@
name|Override
specifier|public
name|int
name|getQualifierLength
parameter_list|()
block|{
return|return
name|getQualifierLength
argument_list|(
name|getRowLength
argument_list|()
argument_list|,
name|getFamilyLength
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @return Qualifier length    */
specifier|private
name|int
name|getQualifierLength
parameter_list|(
name|int
name|rlength
parameter_list|,
name|int
name|flength
parameter_list|)
block|{
return|return
name|getKeyLength
argument_list|()
operator|-
operator|(
name|int
operator|)
name|getKeyDataStructureSize
argument_list|(
name|rlength
argument_list|,
name|flength
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * @return Column (family + qualifier) length    */
specifier|private
name|int
name|getTotalColumnLength
parameter_list|(
name|int
name|rlength
parameter_list|,
name|int
name|foffset
parameter_list|)
block|{
name|int
name|flength
init|=
name|getFamilyLength
argument_list|(
name|foffset
argument_list|)
decl_stmt|;
name|int
name|qlength
init|=
name|getQualifierLength
argument_list|(
name|rlength
argument_list|,
name|flength
argument_list|)
decl_stmt|;
return|return
name|flength
operator|+
name|qlength
return|;
block|}
comment|/**    * @return Timestamp offset    */
specifier|public
name|int
name|getTimestampOffset
parameter_list|()
block|{
return|return
name|getTimestampOffset
argument_list|(
name|getKeyLength
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @param keylength Pass if you have it to save on a int creation.    * @return Timestamp offset    */
specifier|private
name|int
name|getTimestampOffset
parameter_list|(
specifier|final
name|int
name|keylength
parameter_list|)
block|{
return|return
name|getKeyOffset
argument_list|()
operator|+
name|keylength
operator|-
name|TIMESTAMP_TYPE_SIZE
return|;
block|}
comment|/**    * @return True if this KeyValue has a LATEST_TIMESTAMP timestamp.    */
specifier|public
name|boolean
name|isLatestTimestamp
parameter_list|()
block|{
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|getBuffer
argument_list|()
argument_list|,
name|getTimestampOffset
argument_list|()
argument_list|,
name|Bytes
operator|.
name|SIZEOF_LONG
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP_BYTES
argument_list|,
literal|0
argument_list|,
name|Bytes
operator|.
name|SIZEOF_LONG
argument_list|)
return|;
block|}
comment|/**    * @param now Time to set into<code>this</code> IFF timestamp ==    * {@link HConstants#LATEST_TIMESTAMP} (else, its a noop).    * @return True is we modified this.    */
specifier|public
name|boolean
name|updateLatestStamp
parameter_list|(
specifier|final
name|byte
index|[]
name|now
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|isLatestTimestamp
argument_list|()
condition|)
block|{
name|int
name|tsOffset
init|=
name|getTimestampOffset
argument_list|()
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|now
argument_list|,
literal|0
argument_list|,
name|this
operator|.
name|bytes
argument_list|,
name|tsOffset
argument_list|,
name|Bytes
operator|.
name|SIZEOF_LONG
argument_list|)
expr_stmt|;
comment|// clear cache or else getTimestamp() possibly returns an old value
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|//---------------------------------------------------------------------------
comment|//
comment|//  Methods that return copies of fields
comment|//
comment|//---------------------------------------------------------------------------
comment|/**    * Do not use unless you have to.  Used internally for compacting and testing.    *    * Use {@link #getRow()}, {@link #getFamily()}, {@link #getQualifier()}, and    * {@link #getValue()} if accessing a KeyValue client-side.    * @return Copy of the key portion only.    */
specifier|public
name|byte
index|[]
name|getKey
parameter_list|()
block|{
name|int
name|keylength
init|=
name|getKeyLength
argument_list|()
decl_stmt|;
name|byte
index|[]
name|key
init|=
operator|new
name|byte
index|[
name|keylength
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|getBuffer
argument_list|()
argument_list|,
name|getKeyOffset
argument_list|()
argument_list|,
name|key
argument_list|,
literal|0
argument_list|,
name|keylength
argument_list|)
expr_stmt|;
return|return
name|key
return|;
block|}
comment|/**    * Returns value in a new byte array.    * Primarily for use client-side. If server-side, use    * {@link #getBuffer()} with appropriate offsets and lengths instead to    * save on allocations.    * @return Value in a new byte array.    */
annotation|@
name|Deprecated
comment|// use CellUtil.getValueArray()
specifier|public
name|byte
index|[]
name|getValue
parameter_list|()
block|{
return|return
name|CellUtil
operator|.
name|cloneValue
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * Primarily for use client-side.  Returns the row of this KeyValue in a new    * byte array.<p>    *    * If server-side, use {@link #getBuffer()} with appropriate offsets and    * lengths instead.    * @return Row in a new byte array.    */
annotation|@
name|Deprecated
comment|// use CellUtil.getRowArray()
specifier|public
name|byte
index|[]
name|getRow
parameter_list|()
block|{
return|return
name|CellUtil
operator|.
name|cloneRow
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    *    * @return Timestamp    */
annotation|@
name|Override
specifier|public
name|long
name|getTimestamp
parameter_list|()
block|{
return|return
name|getTimestamp
argument_list|(
name|getKeyLength
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @param keylength Pass if you have it to save on a int creation.    * @return Timestamp    */
name|long
name|getTimestamp
parameter_list|(
specifier|final
name|int
name|keylength
parameter_list|)
block|{
name|int
name|tsOffset
init|=
name|getTimestampOffset
argument_list|(
name|keylength
argument_list|)
decl_stmt|;
return|return
name|Bytes
operator|.
name|toLong
argument_list|(
name|this
operator|.
name|bytes
argument_list|,
name|tsOffset
argument_list|)
return|;
block|}
comment|/**    * @return Type of this KeyValue.    */
annotation|@
name|Deprecated
specifier|public
name|byte
name|getType
parameter_list|()
block|{
return|return
name|getTypeByte
argument_list|()
return|;
block|}
comment|/**    * @return KeyValue.TYPE byte representation    */
annotation|@
name|Override
specifier|public
name|byte
name|getTypeByte
parameter_list|()
block|{
return|return
name|this
operator|.
name|bytes
index|[
name|this
operator|.
name|offset
operator|+
name|getKeyLength
argument_list|()
operator|-
literal|1
operator|+
name|ROW_OFFSET
index|]
return|;
block|}
comment|/**    * @return True if a delete type, a {@link KeyValue.Type#Delete} or    * a {KeyValue.Type#DeleteFamily} or a {@link KeyValue.Type#DeleteColumn}    * KeyValue type.    */
annotation|@
name|Deprecated
comment|// use CellUtil#isDelete
specifier|public
name|boolean
name|isDelete
parameter_list|()
block|{
return|return
name|KeyValue
operator|.
name|isDelete
argument_list|(
name|getType
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @return True if this KV is a {@link KeyValue.Type#Delete} type.    */
specifier|public
name|boolean
name|isDeleteType
parameter_list|()
block|{
comment|// TODO: Fix this method name vis-a-vis isDelete!
return|return
name|getTypeByte
argument_list|()
operator|==
name|Type
operator|.
name|Delete
operator|.
name|getCode
argument_list|()
return|;
block|}
comment|/**    * @return True if this KV is a delete family type.    */
specifier|public
name|boolean
name|isDeleteFamily
parameter_list|()
block|{
return|return
name|getTypeByte
argument_list|()
operator|==
name|Type
operator|.
name|DeleteFamily
operator|.
name|getCode
argument_list|()
return|;
block|}
comment|/**    * @return True if this KV is a delete family-version type.    */
specifier|public
name|boolean
name|isDeleteFamilyVersion
parameter_list|()
block|{
return|return
name|getTypeByte
argument_list|()
operator|==
name|Type
operator|.
name|DeleteFamilyVersion
operator|.
name|getCode
argument_list|()
return|;
block|}
comment|/**    *    * @return True if this KV is a delete family or column type.    */
specifier|public
name|boolean
name|isDeleteColumnOrFamily
parameter_list|()
block|{
name|int
name|t
init|=
name|getTypeByte
argument_list|()
decl_stmt|;
return|return
name|t
operator|==
name|Type
operator|.
name|DeleteColumn
operator|.
name|getCode
argument_list|()
operator|||
name|t
operator|==
name|Type
operator|.
name|DeleteFamily
operator|.
name|getCode
argument_list|()
return|;
block|}
comment|/**    * Primarily for use client-side.  Returns the family of this KeyValue in a    * new byte array.<p>    *    * If server-side, use {@link #getBuffer()} with appropriate offsets and    * lengths instead.    * @return Returns family. Makes a copy.    */
annotation|@
name|Deprecated
comment|// use CellUtil.getFamilyArray
specifier|public
name|byte
index|[]
name|getFamily
parameter_list|()
block|{
return|return
name|CellUtil
operator|.
name|cloneFamily
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * Primarily for use client-side.  Returns the column qualifier of this    * KeyValue in a new byte array.<p>    *    * If server-side, use {@link #getBuffer()} with appropriate offsets and    * lengths instead.    * Use {@link #getBuffer()} with appropriate offsets and lengths instead.    * @return Returns qualifier. Makes a copy.    */
annotation|@
name|Deprecated
comment|// use CellUtil.getQualifierArray
specifier|public
name|byte
index|[]
name|getQualifier
parameter_list|()
block|{
return|return
name|CellUtil
operator|.
name|cloneQualifier
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * This returns the offset where the tag actually starts.    */
annotation|@
name|Override
specifier|public
name|int
name|getTagsOffset
parameter_list|()
block|{
name|short
name|tagsLen
init|=
name|getTagsLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|tagsLen
operator|==
literal|0
condition|)
block|{
return|return
name|this
operator|.
name|offset
operator|+
name|this
operator|.
name|length
return|;
block|}
return|return
name|this
operator|.
name|offset
operator|+
name|this
operator|.
name|length
operator|-
name|tagsLen
return|;
block|}
comment|/**    * This returns the total length of the tag bytes    */
annotation|@
name|Override
specifier|public
name|short
name|getTagsLength
parameter_list|()
block|{
name|int
name|tagsLen
init|=
name|this
operator|.
name|length
operator|-
operator|(
name|getKeyLength
argument_list|()
operator|+
name|getValueLength
argument_list|()
operator|+
name|KEYVALUE_INFRASTRUCTURE_SIZE
operator|)
decl_stmt|;
if|if
condition|(
name|tagsLen
operator|>
literal|0
condition|)
block|{
comment|// There are some Tag bytes in the byte[]. So reduce 2 bytes which is added to denote the tags
comment|// length
name|tagsLen
operator|-=
name|TAGS_LENGTH_SIZE
expr_stmt|;
block|}
return|return
operator|(
name|short
operator|)
name|tagsLen
return|;
block|}
comment|/**    * Returns any tags embedded in the KeyValue.  Used in testcases.    * @return The tags    */
specifier|public
name|List
argument_list|<
name|Tag
argument_list|>
name|getTags
parameter_list|()
block|{
name|short
name|tagsLength
init|=
name|getTagsLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|tagsLength
operator|==
literal|0
condition|)
block|{
return|return
name|EMPTY_ARRAY_LIST
return|;
block|}
return|return
name|Tag
operator|.
name|asList
argument_list|(
name|getTagsArray
argument_list|()
argument_list|,
name|getTagsOffset
argument_list|()
argument_list|,
name|tagsLength
argument_list|)
return|;
block|}
comment|/**    * @return the backing array of the entire KeyValue (all KeyValue fields are in a single array)    */
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|getTagsArray
parameter_list|()
block|{
return|return
name|bytes
return|;
block|}
comment|//---------------------------------------------------------------------------
comment|//
comment|//  Compare specified fields against those contained in this KeyValue
comment|//
comment|//---------------------------------------------------------------------------
comment|/**    * @param family    * @return True if matching families.    */
specifier|public
name|boolean
name|matchingFamily
parameter_list|(
specifier|final
name|byte
index|[]
name|family
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|length
operator|==
literal|0
operator|||
name|this
operator|.
name|bytes
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|family
argument_list|,
literal|0
argument_list|,
name|family
operator|.
name|length
argument_list|,
name|this
operator|.
name|bytes
argument_list|,
name|getFamilyOffset
argument_list|()
argument_list|,
name|getFamilyLength
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @param qualifier    * @return True if matching qualifiers.    */
specifier|public
name|boolean
name|matchingQualifier
parameter_list|(
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
return|return
name|matchingQualifier
argument_list|(
name|qualifier
argument_list|,
literal|0
argument_list|,
name|qualifier
operator|.
name|length
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|matchingQualifier
parameter_list|(
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|qualifier
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|this
operator|.
name|bytes
argument_list|,
name|getQualifierOffset
argument_list|()
argument_list|,
name|getQualifierLength
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|matchingQualifier
parameter_list|(
specifier|final
name|KeyValue
name|other
parameter_list|)
block|{
return|return
name|matchingQualifier
argument_list|(
name|other
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|other
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|other
operator|.
name|getQualifierLength
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|matchingRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|)
block|{
return|return
name|matchingRow
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
name|row
operator|.
name|length
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|matchingRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|row
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|this
operator|.
name|bytes
argument_list|,
name|getRowOffset
argument_list|()
argument_list|,
name|getRowLength
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|matchingRow
parameter_list|(
name|KeyValue
name|other
parameter_list|)
block|{
return|return
name|matchingRow
argument_list|(
name|other
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|other
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|other
operator|.
name|getRowLength
argument_list|()
argument_list|)
return|;
block|}
comment|/**    *    * @param family column family    * @param qualifier column qualifier    * @return True if column matches    */
specifier|public
name|boolean
name|matchingColumn
parameter_list|(
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
return|return
name|matchingColumn
argument_list|(
name|family
argument_list|,
literal|0
argument_list|,
name|len
argument_list|(
name|family
argument_list|)
argument_list|,
name|qualifier
argument_list|,
literal|0
argument_list|,
name|len
argument_list|(
name|qualifier
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Checks if column matches.    *    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    *    * @return True if column matches    */
specifier|public
name|boolean
name|matchingColumn
parameter_list|(
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|int
name|foffset
parameter_list|,
specifier|final
name|int
name|flength
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|int
name|qoffset
parameter_list|,
specifier|final
name|int
name|qlength
parameter_list|)
block|{
name|int
name|rl
init|=
name|getRowLength
argument_list|()
decl_stmt|;
name|int
name|o
init|=
name|getFamilyOffset
argument_list|(
name|rl
argument_list|)
decl_stmt|;
name|int
name|fl
init|=
name|getFamilyLength
argument_list|(
name|o
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|this
operator|.
name|bytes
argument_list|,
name|o
argument_list|,
name|fl
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|ql
init|=
name|getQualifierLength
argument_list|(
name|rl
argument_list|,
name|fl
argument_list|)
decl_stmt|;
if|if
condition|(
name|qualifier
operator|==
literal|null
operator|||
name|qlength
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|ql
operator|==
literal|0
operator|)
return|;
block|}
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|,
name|this
operator|.
name|bytes
argument_list|,
name|o
operator|+
name|fl
argument_list|,
name|ql
argument_list|)
return|;
block|}
comment|/**    * Creates a new KeyValue that only contains the key portion (the value is    * set to be null).    *    * TODO only used by KeyOnlyFilter -- move there.    * @param lenAsVal replace value with the actual value length (false=empty)    */
specifier|public
name|KeyValue
name|createKeyOnly
parameter_list|(
name|boolean
name|lenAsVal
parameter_list|)
block|{
comment|// KV format:<keylen:4><valuelen:4><key:keylen><value:valuelen>
comment|// Rebuild as:<keylen:4><0:4><key:keylen>
name|int
name|dataLen
init|=
name|lenAsVal
condition|?
name|Bytes
operator|.
name|SIZEOF_INT
else|:
literal|0
decl_stmt|;
name|byte
index|[]
name|newBuffer
init|=
operator|new
name|byte
index|[
name|getKeyLength
argument_list|()
operator|+
name|ROW_OFFSET
operator|+
name|dataLen
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|this
operator|.
name|bytes
argument_list|,
name|this
operator|.
name|offset
argument_list|,
name|newBuffer
argument_list|,
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|newBuffer
operator|.
name|length
argument_list|,
name|this
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|Bytes
operator|.
name|putInt
argument_list|(
name|newBuffer
argument_list|,
name|Bytes
operator|.
name|SIZEOF_INT
argument_list|,
name|dataLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|lenAsVal
condition|)
block|{
name|Bytes
operator|.
name|putInt
argument_list|(
name|newBuffer
argument_list|,
name|newBuffer
operator|.
name|length
operator|-
name|dataLen
argument_list|,
name|this
operator|.
name|getValueLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|KeyValue
argument_list|(
name|newBuffer
argument_list|)
return|;
block|}
comment|/**    * Splits a column in {@code family:qualifier} form into separate byte arrays. An empty qualifier    * (ie, {@code fam:}) is parsed as<code>{ fam, EMPTY_BYTE_ARRAY }</code> while no delimiter (ie,    * {@code fam}) is parsed as an array of one element,<code>{ fam }</code>.    *<p>    * Don't forget, HBase DOES support empty qualifiers. (see HBASE-9549)    *</p>    *<p>    * Not recommend to be used as this is old-style API.    *</p>    * @param c The column.    * @return The parsed column.    */
specifier|public
specifier|static
name|byte
index|[]
index|[]
name|parseColumn
parameter_list|(
name|byte
index|[]
name|c
parameter_list|)
block|{
specifier|final
name|int
name|index
init|=
name|getDelimiter
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
name|c
operator|.
name|length
argument_list|,
name|COLUMN_FAMILY_DELIMITER
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
comment|// If no delimiter, return array of size 1
return|return
operator|new
name|byte
index|[]
index|[]
block|{
name|c
block|}
return|;
block|}
elseif|else
if|if
condition|(
name|index
operator|==
name|c
operator|.
name|length
operator|-
literal|1
condition|)
block|{
comment|// family with empty qualifier, return array size 2
name|byte
index|[]
name|family
init|=
operator|new
name|byte
index|[
name|c
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
name|family
argument_list|,
literal|0
argument_list|,
name|family
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
operator|new
name|byte
index|[]
index|[]
block|{
name|family
block|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
block|}
return|;
block|}
comment|// Family and column, return array size 2
specifier|final
name|byte
index|[]
index|[]
name|result
init|=
operator|new
name|byte
index|[
literal|2
index|]
index|[]
decl_stmt|;
name|result
index|[
literal|0
index|]
operator|=
operator|new
name|byte
index|[
name|index
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
name|result
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|index
argument_list|)
expr_stmt|;
specifier|final
name|int
name|len
init|=
name|c
operator|.
name|length
operator|-
operator|(
name|index
operator|+
literal|1
operator|)
decl_stmt|;
name|result
index|[
literal|1
index|]
operator|=
operator|new
name|byte
index|[
name|len
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|c
argument_list|,
name|index
operator|+
literal|1
comment|/* Skip delimiter */
argument_list|,
name|result
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Makes a column in family:qualifier form from separate byte arrays.    *<p>    * Not recommended for usage as this is old-style API.    * @param family    * @param qualifier    * @return family:qualifier    */
specifier|public
specifier|static
name|byte
index|[]
name|makeColumn
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|add
argument_list|(
name|family
argument_list|,
name|COLUMN_FAMILY_DELIM_ARRAY
argument_list|,
name|qualifier
argument_list|)
return|;
block|}
comment|/**    * This function is only used in Meta key comparisons so its error message    * is specific for meta key errors.    */
specifier|static
name|int
name|getRequiredDelimiterInReverse
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|,
specifier|final
name|int
name|delimiter
parameter_list|)
block|{
name|int
name|index
init|=
name|getDelimiterInReverse
argument_list|(
name|b
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|delimiter
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"hbase:meta key must have two '"
operator|+
operator|(
name|char
operator|)
name|delimiter
operator|+
literal|"' "
operator|+
literal|"delimiters and have the following format: '<table>,<key>,<etc>'"
argument_list|)
throw|;
block|}
return|return
name|index
return|;
block|}
comment|/**    * @param b    * @param delimiter    * @return Index of delimiter having started from start of<code>b</code>    * moving rightward.    */
specifier|public
specifier|static
name|int
name|getDelimiter
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|,
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|,
specifier|final
name|int
name|delimiter
parameter_list|)
block|{
if|if
condition|(
name|b
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Passed buffer is null"
argument_list|)
throw|;
block|}
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|offset
init|;
name|i
operator|<
name|length
operator|+
name|offset
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|b
index|[
name|i
index|]
operator|==
name|delimiter
condition|)
block|{
name|result
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**    * Find index of passed delimiter walking from end of buffer backwards.    * @param b    * @param delimiter    * @return Index of delimiter    */
specifier|public
specifier|static
name|int
name|getDelimiterInReverse
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|,
specifier|final
name|int
name|delimiter
parameter_list|)
block|{
if|if
condition|(
name|b
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Passed buffer is null"
argument_list|)
throw|;
block|}
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
operator|(
name|offset
operator|+
name|length
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
name|offset
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|b
index|[
name|i
index|]
operator|==
name|delimiter
condition|)
block|{
name|result
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**    * A {@link KVComparator} for<code>hbase:meta</code> catalog table    * {@link KeyValue}s.    */
specifier|public
specifier|static
class|class
name|MetaComparator
extends|extends
name|KVComparator
block|{
comment|/**      * Compare key portion of a {@link KeyValue} for keys in<code>hbase:meta</code>      * table.      */
annotation|@
name|Override
specifier|public
name|int
name|compareRows
parameter_list|(
name|byte
index|[]
name|left
parameter_list|,
name|int
name|loffset
parameter_list|,
name|int
name|llength
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|roffset
parameter_list|,
name|int
name|rlength
parameter_list|)
block|{
name|int
name|leftDelimiter
init|=
name|getDelimiter
argument_list|(
name|left
argument_list|,
name|loffset
argument_list|,
name|llength
argument_list|,
name|HConstants
operator|.
name|DELIMITER
argument_list|)
decl_stmt|;
name|int
name|rightDelimiter
init|=
name|getDelimiter
argument_list|(
name|right
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|,
name|HConstants
operator|.
name|DELIMITER
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftDelimiter
operator|<
literal|0
operator|&&
name|rightDelimiter
operator|>=
literal|0
condition|)
block|{
comment|// Nothing between hbase:meta and regionid.  Its first key.
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|rightDelimiter
operator|<
literal|0
operator|&&
name|leftDelimiter
operator|>=
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|leftDelimiter
operator|<
literal|0
operator|&&
name|rightDelimiter
operator|<
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|// Compare up to the delimiter
name|int
name|result
init|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
argument_list|,
name|loffset
argument_list|,
name|leftDelimiter
operator|-
name|loffset
argument_list|,
name|right
argument_list|,
name|roffset
argument_list|,
name|rightDelimiter
operator|-
name|roffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
comment|// Compare middle bit of the row.
comment|// Move past delimiter
name|leftDelimiter
operator|++
expr_stmt|;
name|rightDelimiter
operator|++
expr_stmt|;
name|int
name|leftFarDelimiter
init|=
name|getRequiredDelimiterInReverse
argument_list|(
name|left
argument_list|,
name|leftDelimiter
argument_list|,
name|llength
operator|-
operator|(
name|leftDelimiter
operator|-
name|loffset
operator|)
argument_list|,
name|HConstants
operator|.
name|DELIMITER
argument_list|)
decl_stmt|;
name|int
name|rightFarDelimiter
init|=
name|getRequiredDelimiterInReverse
argument_list|(
name|right
argument_list|,
name|rightDelimiter
argument_list|,
name|rlength
operator|-
operator|(
name|rightDelimiter
operator|-
name|roffset
operator|)
argument_list|,
name|HConstants
operator|.
name|DELIMITER
argument_list|)
decl_stmt|;
comment|// Now compare middlesection of row.
name|result
operator|=
name|super
operator|.
name|compareRows
argument_list|(
name|left
argument_list|,
name|leftDelimiter
argument_list|,
name|leftFarDelimiter
operator|-
name|leftDelimiter
argument_list|,
name|right
argument_list|,
name|rightDelimiter
argument_list|,
name|rightFarDelimiter
operator|-
name|rightDelimiter
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
comment|// Compare last part of row, the rowid.
name|leftFarDelimiter
operator|++
expr_stmt|;
name|rightFarDelimiter
operator|++
expr_stmt|;
name|result
operator|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
argument_list|,
name|leftFarDelimiter
argument_list|,
name|llength
operator|-
operator|(
name|leftFarDelimiter
operator|-
name|loffset
operator|)
argument_list|,
name|right
argument_list|,
name|rightFarDelimiter
argument_list|,
name|rlength
operator|-
operator|(
name|rightFarDelimiter
operator|-
name|roffset
operator|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**      * Don't do any fancy Block Index splitting tricks.      */
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|getShortMidpointKey
parameter_list|(
specifier|final
name|byte
index|[]
name|leftKey
parameter_list|,
specifier|final
name|byte
index|[]
name|rightKey
parameter_list|)
block|{
return|return
name|Arrays
operator|.
name|copyOf
argument_list|(
name|rightKey
argument_list|,
name|rightKey
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**      * The HFileV2 file format's trailer contains this class name.  We reinterpret this and      * instantiate the appropriate comparator.      * TODO: With V3 consider removing this.      * @return legacy class name for FileFileTrailer#comparatorClassName      */
annotation|@
name|Override
specifier|public
name|String
name|getLegacyKeyComparatorName
parameter_list|()
block|{
return|return
literal|"org.apache.hadoop.hbase.KeyValue$MetaKeyComparator"
return|;
block|}
annotation|@
name|Override
specifier|protected
name|Object
name|clone
parameter_list|()
throws|throws
name|CloneNotSupportedException
block|{
return|return
operator|new
name|MetaComparator
argument_list|()
return|;
block|}
comment|/**      * Override the row key comparison to parse and compare the meta row key parts.      */
annotation|@
name|Override
specifier|protected
name|int
name|compareRowKey
parameter_list|(
specifier|final
name|Cell
name|l
parameter_list|,
specifier|final
name|Cell
name|r
parameter_list|)
block|{
name|byte
index|[]
name|left
init|=
name|l
operator|.
name|getRowArray
argument_list|()
decl_stmt|;
name|int
name|loffset
init|=
name|l
operator|.
name|getRowOffset
argument_list|()
decl_stmt|;
name|int
name|llength
init|=
name|l
operator|.
name|getRowLength
argument_list|()
decl_stmt|;
name|byte
index|[]
name|right
init|=
name|r
operator|.
name|getRowArray
argument_list|()
decl_stmt|;
name|int
name|roffset
init|=
name|r
operator|.
name|getRowOffset
argument_list|()
decl_stmt|;
name|int
name|rlength
init|=
name|r
operator|.
name|getRowLength
argument_list|()
decl_stmt|;
return|return
name|compareRows
argument_list|(
name|left
argument_list|,
name|loffset
argument_list|,
name|llength
argument_list|,
name|right
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|)
return|;
block|}
block|}
comment|/**    * Compare KeyValues.  When we compare KeyValues, we only compare the Key    * portion.  This means two KeyValues with same Key but different Values are    * considered the same as far as this Comparator is concerned.    */
specifier|public
specifier|static
class|class
name|KVComparator
implements|implements
name|RawComparator
argument_list|<
name|Cell
argument_list|>
implements|,
name|SamePrefixComparator
argument_list|<
name|byte
index|[]
argument_list|>
block|{
comment|/**      * The HFileV2 file format's trailer contains this class name.  We reinterpret this and      * instantiate the appropriate comparator.      * TODO: With V3 consider removing this.      * @return legacy class name for FileFileTrailer#comparatorClassName      */
specifier|public
name|String
name|getLegacyKeyComparatorName
parameter_list|()
block|{
return|return
literal|"org.apache.hadoop.hbase.KeyValue$KeyComparator"
return|;
block|}
annotation|@
name|Override
comment|// RawComparator
specifier|public
name|int
name|compare
parameter_list|(
name|byte
index|[]
name|l
parameter_list|,
name|int
name|loff
parameter_list|,
name|int
name|llen
parameter_list|,
name|byte
index|[]
name|r
parameter_list|,
name|int
name|roff
parameter_list|,
name|int
name|rlen
parameter_list|)
block|{
return|return
name|compareFlatKey
argument_list|(
name|l
argument_list|,
name|loff
argument_list|,
name|llen
argument_list|,
name|r
argument_list|,
name|roff
argument_list|,
name|rlen
argument_list|)
return|;
block|}
comment|/**      * Compares the only the user specified portion of a Key.  This is overridden by MetaComparator.      * @param left      * @param right      * @return 0 if equal,<0 if left smaller,>0 if right smaller      */
specifier|protected
name|int
name|compareRowKey
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|left
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|right
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|right
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|right
operator|.
name|getRowLength
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Compares left to right assuming that left,loffset,llength and right,roffset,rlength are      * full KVs laid out in a flat byte[]s.      * @param left      * @param loffset      * @param llength      * @param right      * @param roffset      * @param rlength      * @return  0 if equal,<0 if left smaller,>0 if right smaller      */
specifier|public
name|int
name|compareFlatKey
parameter_list|(
name|byte
index|[]
name|left
parameter_list|,
name|int
name|loffset
parameter_list|,
name|int
name|llength
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|roffset
parameter_list|,
name|int
name|rlength
parameter_list|)
block|{
comment|// Compare row
name|short
name|lrowlength
init|=
name|Bytes
operator|.
name|toShort
argument_list|(
name|left
argument_list|,
name|loffset
argument_list|)
decl_stmt|;
name|short
name|rrowlength
init|=
name|Bytes
operator|.
name|toShort
argument_list|(
name|right
argument_list|,
name|roffset
argument_list|)
decl_stmt|;
name|int
name|compare
init|=
name|compareRows
argument_list|(
name|left
argument_list|,
name|loffset
operator|+
name|Bytes
operator|.
name|SIZEOF_SHORT
argument_list|,
name|lrowlength
argument_list|,
name|right
argument_list|,
name|roffset
operator|+
name|Bytes
operator|.
name|SIZEOF_SHORT
argument_list|,
name|rrowlength
argument_list|)
decl_stmt|;
if|if
condition|(
name|compare
operator|!=
literal|0
condition|)
block|{
return|return
name|compare
return|;
block|}
comment|// Compare the rest of the two KVs without making any assumptions about
comment|// the common prefix. This function will not compare rows anyway, so we
comment|// don't need to tell it that the common prefix includes the row.
return|return
name|compareWithoutRow
argument_list|(
literal|0
argument_list|,
name|left
argument_list|,
name|loffset
argument_list|,
name|llength
argument_list|,
name|right
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|,
name|rrowlength
argument_list|)
return|;
block|}
specifier|public
name|int
name|compareFlatKey
parameter_list|(
name|byte
index|[]
name|left
parameter_list|,
name|byte
index|[]
name|right
parameter_list|)
block|{
return|return
name|compareFlatKey
argument_list|(
name|left
argument_list|,
literal|0
argument_list|,
name|left
operator|.
name|length
argument_list|,
name|right
argument_list|,
literal|0
argument_list|,
name|right
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**      * Compares the Key of a cell -- with fields being more significant in this order:      * rowkey, colfam/qual, timestamp, type, mvcc      */
specifier|public
name|int
name|compare
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|)
block|{
comment|// compare row
name|int
name|compare
init|=
name|compareRowKey
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
decl_stmt|;
if|if
condition|(
name|compare
operator|!=
literal|0
condition|)
block|{
return|return
name|compare
return|;
block|}
comment|// compare vs minimum
name|byte
name|ltype
init|=
name|left
operator|.
name|getTypeByte
argument_list|()
decl_stmt|;
name|byte
name|rtype
init|=
name|right
operator|.
name|getTypeByte
argument_list|()
decl_stmt|;
comment|// If the column is not specified, the "minimum" key type appears the
comment|// latest in the sorted order, regardless of the timestamp. This is used
comment|// for specifying the last key/value in a given row, because there is no
comment|// "lexicographically last column" (it would be infinitely long). The
comment|// "maximum" key type does not need this behavior.
name|int
name|lcfqLen
init|=
name|left
operator|.
name|getFamilyLength
argument_list|()
operator|+
name|left
operator|.
name|getQualifierLength
argument_list|()
decl_stmt|;
name|int
name|rcfqLen
init|=
name|right
operator|.
name|getFamilyLength
argument_list|()
operator|+
name|right
operator|.
name|getQualifierLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|lcfqLen
operator|==
literal|0
operator|&&
name|ltype
operator|==
name|Type
operator|.
name|Minimum
operator|.
name|getCode
argument_list|()
condition|)
block|{
comment|// left is "bigger", i.e. it appears later in the sorted order
return|return
literal|1
return|;
block|}
if|if
condition|(
name|rcfqLen
operator|==
literal|0
operator|&&
name|rtype
operator|==
name|Type
operator|.
name|Minimum
operator|.
name|getCode
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|// compare col family / col fam + qual
comment|// If left family size is not equal to right family size, we need not
comment|// compare the qualifiers.
name|compare
operator|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyLength
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
operator|!=
literal|0
condition|)
block|{
return|return
name|compare
return|;
block|}
comment|// Compare qualifier
name|compare
operator|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierLength
argument_list|()
argument_list|,
name|right
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|right
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|right
operator|.
name|getQualifierLength
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
operator|!=
literal|0
condition|)
block|{
return|return
name|compare
return|;
block|}
comment|// compare timestamp
name|long
name|ltimestamp
init|=
name|left
operator|.
name|getTimestamp
argument_list|()
decl_stmt|;
name|long
name|rtimestamp
init|=
name|right
operator|.
name|getTimestamp
argument_list|()
decl_stmt|;
name|compare
operator|=
name|compareTimestamps
argument_list|(
name|ltimestamp
argument_list|,
name|rtimestamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
operator|!=
literal|0
condition|)
block|{
return|return
name|compare
return|;
block|}
comment|// Compare types. Let the delete types sort ahead of puts; i.e. types
comment|// of higher numbers sort before those of lesser numbers. Maximum (255)
comment|// appears ahead of everything, and minimum (0) appears after
comment|// everything.
name|compare
operator|=
operator|(
literal|0xff
operator|&
name|rtype
operator|)
operator|-
operator|(
literal|0xff
operator|&
name|ltype
operator|)
expr_stmt|;
if|if
condition|(
name|compare
operator|!=
literal|0
condition|)
block|{
return|return
name|compare
return|;
block|}
comment|// Negate following comparisons so later edits show up first
comment|// compare log replay tag value if there is any
comment|// when either keyvalue tagged with log replay sequence number, we need to compare them:
comment|// 1) when both keyvalues have the tag, then use the tag values for comparison
comment|// 2) when one has and the other doesn't have, the one without the log replay tag wins because
comment|// it means the edit isn't from recovery but new one coming from clients during recovery
comment|// 3) when both doesn't have, then skip to the next mvcc comparison
name|long
name|leftChangeSeqNum
init|=
name|getReplaySeqNum
argument_list|(
name|left
argument_list|)
decl_stmt|;
name|long
name|RightChangeSeqNum
init|=
name|getReplaySeqNum
argument_list|(
name|right
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftChangeSeqNum
operator|!=
name|Long
operator|.
name|MAX_VALUE
operator|||
name|RightChangeSeqNum
operator|!=
name|Long
operator|.
name|MAX_VALUE
condition|)
block|{
return|return
name|Longs
operator|.
name|compare
argument_list|(
name|RightChangeSeqNum
argument_list|,
name|leftChangeSeqNum
argument_list|)
return|;
block|}
comment|// compare Mvcc Version
return|return
name|Longs
operator|.
name|compare
argument_list|(
name|right
operator|.
name|getMvccVersion
argument_list|()
argument_list|,
name|left
operator|.
name|getMvccVersion
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Return replay log sequence number for the cell      * @param c      * @return Long.MAX_VALUE if there is no LOG_REPLAY_TAG      */
specifier|private
name|long
name|getReplaySeqNum
parameter_list|(
specifier|final
name|Cell
name|c
parameter_list|)
block|{
name|Tag
name|tag
init|=
name|Tag
operator|.
name|getTag
argument_list|(
name|c
operator|.
name|getTagsArray
argument_list|()
argument_list|,
name|c
operator|.
name|getTagsOffset
argument_list|()
argument_list|,
name|c
operator|.
name|getTagsLength
argument_list|()
argument_list|,
name|TagType
operator|.
name|LOG_REPLAY_TAG_TYPE
argument_list|)
decl_stmt|;
if|if
condition|(
name|tag
operator|!=
literal|null
condition|)
block|{
return|return
name|Bytes
operator|.
name|toLong
argument_list|(
name|tag
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|tag
operator|.
name|getTagOffset
argument_list|()
argument_list|,
name|tag
operator|.
name|getTagLength
argument_list|()
argument_list|)
return|;
block|}
return|return
name|Long
operator|.
name|MAX_VALUE
return|;
block|}
specifier|public
name|int
name|compareTimestamps
parameter_list|(
specifier|final
name|KeyValue
name|left
parameter_list|,
specifier|final
name|KeyValue
name|right
parameter_list|)
block|{
comment|// Compare timestamps
name|long
name|ltimestamp
init|=
name|left
operator|.
name|getTimestamp
argument_list|(
name|left
operator|.
name|getKeyLength
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|rtimestamp
init|=
name|right
operator|.
name|getTimestamp
argument_list|(
name|right
operator|.
name|getKeyLength
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|compareTimestamps
argument_list|(
name|ltimestamp
argument_list|,
name|rtimestamp
argument_list|)
return|;
block|}
comment|/**      * @param left      * @param right      * @return Result comparing rows.      */
specifier|public
name|int
name|compareRows
parameter_list|(
specifier|final
name|KeyValue
name|left
parameter_list|,
specifier|final
name|KeyValue
name|right
parameter_list|)
block|{
return|return
name|compareRows
argument_list|(
name|left
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|left
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|right
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|right
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|right
operator|.
name|getRowLength
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Get the b[],o,l for left and right rowkey portions and compare.      * @param left      * @param loffset      * @param llength      * @param right      * @param roffset      * @param rlength      * @return 0 if equal,<0 if left smaller,>0 if right smaller      */
specifier|public
name|int
name|compareRows
parameter_list|(
name|byte
index|[]
name|left
parameter_list|,
name|int
name|loffset
parameter_list|,
name|int
name|llength
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|roffset
parameter_list|,
name|int
name|rlength
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
argument_list|,
name|loffset
argument_list|,
name|llength
argument_list|,
name|right
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|)
return|;
block|}
name|int
name|compareColumns
parameter_list|(
specifier|final
name|KeyValue
name|left
parameter_list|,
specifier|final
name|short
name|lrowlength
parameter_list|,
specifier|final
name|KeyValue
name|right
parameter_list|,
specifier|final
name|short
name|rrowlength
parameter_list|)
block|{
name|int
name|lfoffset
init|=
name|left
operator|.
name|getFamilyOffset
argument_list|(
name|lrowlength
argument_list|)
decl_stmt|;
name|int
name|rfoffset
init|=
name|right
operator|.
name|getFamilyOffset
argument_list|(
name|rrowlength
argument_list|)
decl_stmt|;
name|int
name|lclength
init|=
name|left
operator|.
name|getTotalColumnLength
argument_list|(
name|lrowlength
argument_list|,
name|lfoffset
argument_list|)
decl_stmt|;
name|int
name|rclength
init|=
name|right
operator|.
name|getTotalColumnLength
argument_list|(
name|rrowlength
argument_list|,
name|rfoffset
argument_list|)
decl_stmt|;
name|int
name|lfamilylength
init|=
name|left
operator|.
name|getFamilyLength
argument_list|(
name|lfoffset
argument_list|)
decl_stmt|;
name|int
name|rfamilylength
init|=
name|right
operator|.
name|getFamilyLength
argument_list|(
name|rfoffset
argument_list|)
decl_stmt|;
return|return
name|compareColumns
argument_list|(
name|left
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|lfoffset
argument_list|,
name|lclength
argument_list|,
name|lfamilylength
argument_list|,
name|right
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|rfoffset
argument_list|,
name|rclength
argument_list|,
name|rfamilylength
argument_list|)
return|;
block|}
specifier|protected
name|int
name|compareColumns
parameter_list|(
name|byte
index|[]
name|left
parameter_list|,
name|int
name|loffset
parameter_list|,
name|int
name|llength
parameter_list|,
specifier|final
name|int
name|lfamilylength
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|roffset
parameter_list|,
name|int
name|rlength
parameter_list|,
specifier|final
name|int
name|rfamilylength
parameter_list|)
block|{
comment|// Compare family portion first.
name|int
name|diff
init|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
argument_list|,
name|loffset
argument_list|,
name|lfamilylength
argument_list|,
name|right
argument_list|,
name|roffset
argument_list|,
name|rfamilylength
argument_list|)
decl_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|0
condition|)
block|{
return|return
name|diff
return|;
block|}
comment|// Compare qualifier portion
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
argument_list|,
name|loffset
operator|+
name|lfamilylength
argument_list|,
name|llength
operator|-
name|lfamilylength
argument_list|,
name|right
argument_list|,
name|roffset
operator|+
name|rfamilylength
argument_list|,
name|rlength
operator|-
name|rfamilylength
argument_list|)
return|;
block|}
specifier|static
name|int
name|compareTimestamps
parameter_list|(
specifier|final
name|long
name|ltimestamp
parameter_list|,
specifier|final
name|long
name|rtimestamp
parameter_list|)
block|{
comment|// The below older timestamps sorting ahead of newer timestamps looks
comment|// wrong but it is intentional. This way, newer timestamps are first
comment|// found when we iterate over a memstore and newer versions are the
comment|// first we trip over when reading from a store file.
if|if
condition|(
name|ltimestamp
operator|<
name|rtimestamp
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|ltimestamp
operator|>
name|rtimestamp
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/**      * Overridden      * @param commonPrefix      * @param left      * @param loffset      * @param llength      * @param right      * @param roffset      * @param rlength      * @return 0 if equal,<0 if left smaller,>0 if right smaller      */
annotation|@
name|Override
comment|// SamePrefixComparator
specifier|public
name|int
name|compareIgnoringPrefix
parameter_list|(
name|int
name|commonPrefix
parameter_list|,
name|byte
index|[]
name|left
parameter_list|,
name|int
name|loffset
parameter_list|,
name|int
name|llength
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|roffset
parameter_list|,
name|int
name|rlength
parameter_list|)
block|{
comment|// Compare row
name|short
name|lrowlength
init|=
name|Bytes
operator|.
name|toShort
argument_list|(
name|left
argument_list|,
name|loffset
argument_list|)
decl_stmt|;
name|short
name|rrowlength
decl_stmt|;
name|int
name|comparisonResult
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|commonPrefix
operator|<
name|ROW_LENGTH_SIZE
condition|)
block|{
comment|// almost nothing in common
name|rrowlength
operator|=
name|Bytes
operator|.
name|toShort
argument_list|(
name|right
argument_list|,
name|roffset
argument_list|)
expr_stmt|;
name|comparisonResult
operator|=
name|compareRows
argument_list|(
name|left
argument_list|,
name|loffset
operator|+
name|ROW_LENGTH_SIZE
argument_list|,
name|lrowlength
argument_list|,
name|right
argument_list|,
name|roffset
operator|+
name|ROW_LENGTH_SIZE
argument_list|,
name|rrowlength
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// the row length is the same
name|rrowlength
operator|=
name|lrowlength
expr_stmt|;
if|if
condition|(
name|commonPrefix
operator|<
name|ROW_LENGTH_SIZE
operator|+
name|rrowlength
condition|)
block|{
comment|// The rows are not the same. Exclude the common prefix and compare
comment|// the rest of the two rows.
name|int
name|common
init|=
name|commonPrefix
operator|-
name|ROW_LENGTH_SIZE
decl_stmt|;
name|comparisonResult
operator|=
name|compareRows
argument_list|(
name|left
argument_list|,
name|loffset
operator|+
name|common
operator|+
name|ROW_LENGTH_SIZE
argument_list|,
name|lrowlength
operator|-
name|common
argument_list|,
name|right
argument_list|,
name|roffset
operator|+
name|common
operator|+
name|ROW_LENGTH_SIZE
argument_list|,
name|rrowlength
operator|-
name|common
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|comparisonResult
operator|!=
literal|0
condition|)
block|{
return|return
name|comparisonResult
return|;
block|}
assert|assert
name|lrowlength
operator|==
name|rrowlength
assert|;
return|return
name|compareWithoutRow
argument_list|(
name|commonPrefix
argument_list|,
name|left
argument_list|,
name|loffset
argument_list|,
name|llength
argument_list|,
name|right
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|,
name|lrowlength
argument_list|)
return|;
block|}
comment|/**      * Compare columnFamily, qualifier, timestamp, and key type (everything      * except the row). This method is used both in the normal comparator and      * the "same-prefix" comparator. Note that we are assuming that row portions      * of both KVs have already been parsed and found identical, and we don't      * validate that assumption here.      * @param commonPrefix      *          the length of the common prefix of the two key-values being      *          compared, including row length and row      */
specifier|private
name|int
name|compareWithoutRow
parameter_list|(
name|int
name|commonPrefix
parameter_list|,
name|byte
index|[]
name|left
parameter_list|,
name|int
name|loffset
parameter_list|,
name|int
name|llength
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|roffset
parameter_list|,
name|int
name|rlength
parameter_list|,
name|short
name|rowlength
parameter_list|)
block|{
comment|/***        * KeyValue Format and commonLength:        * |_keyLen_|_valLen_|_rowLen_|_rowKey_|_famiLen_|_fami_|_Quali_|....        * ------------------|-------commonLength--------|--------------        */
name|int
name|commonLength
init|=
name|ROW_LENGTH_SIZE
operator|+
name|FAMILY_LENGTH_SIZE
operator|+
name|rowlength
decl_stmt|;
comment|// commonLength + TIMESTAMP_TYPE_SIZE
name|int
name|commonLengthWithTSAndType
init|=
name|TIMESTAMP_TYPE_SIZE
operator|+
name|commonLength
decl_stmt|;
comment|// ColumnFamily + Qualifier length.
name|int
name|lcolumnlength
init|=
name|llength
operator|-
name|commonLengthWithTSAndType
decl_stmt|;
name|int
name|rcolumnlength
init|=
name|rlength
operator|-
name|commonLengthWithTSAndType
decl_stmt|;
name|byte
name|ltype
init|=
name|left
index|[
name|loffset
operator|+
operator|(
name|llength
operator|-
literal|1
operator|)
index|]
decl_stmt|;
name|byte
name|rtype
init|=
name|right
index|[
name|roffset
operator|+
operator|(
name|rlength
operator|-
literal|1
operator|)
index|]
decl_stmt|;
comment|// If the column is not specified, the "minimum" key type appears the
comment|// latest in the sorted order, regardless of the timestamp. This is used
comment|// for specifying the last key/value in a given row, because there is no
comment|// "lexicographically last column" (it would be infinitely long). The
comment|// "maximum" key type does not need this behavior.
if|if
condition|(
name|lcolumnlength
operator|==
literal|0
operator|&&
name|ltype
operator|==
name|Type
operator|.
name|Minimum
operator|.
name|getCode
argument_list|()
condition|)
block|{
comment|// left is "bigger", i.e. it appears later in the sorted order
return|return
literal|1
return|;
block|}
if|if
condition|(
name|rcolumnlength
operator|==
literal|0
operator|&&
name|rtype
operator|==
name|Type
operator|.
name|Minimum
operator|.
name|getCode
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|int
name|lfamilyoffset
init|=
name|commonLength
operator|+
name|loffset
decl_stmt|;
name|int
name|rfamilyoffset
init|=
name|commonLength
operator|+
name|roffset
decl_stmt|;
comment|// Column family length.
name|int
name|lfamilylength
init|=
name|left
index|[
name|lfamilyoffset
operator|-
literal|1
index|]
decl_stmt|;
name|int
name|rfamilylength
init|=
name|right
index|[
name|rfamilyoffset
operator|-
literal|1
index|]
decl_stmt|;
comment|// If left family size is not equal to right family size, we need not
comment|// compare the qualifiers.
name|boolean
name|sameFamilySize
init|=
operator|(
name|lfamilylength
operator|==
name|rfamilylength
operator|)
decl_stmt|;
name|int
name|common
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|commonPrefix
operator|>
literal|0
condition|)
block|{
name|common
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|commonPrefix
operator|-
name|commonLength
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sameFamilySize
condition|)
block|{
comment|// Common should not be larger than Math.min(lfamilylength,
comment|// rfamilylength).
name|common
operator|=
name|Math
operator|.
name|min
argument_list|(
name|common
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|lfamilylength
argument_list|,
name|rfamilylength
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|common
operator|=
name|Math
operator|.
name|min
argument_list|(
name|common
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|lcolumnlength
argument_list|,
name|rcolumnlength
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|sameFamilySize
condition|)
block|{
comment|// comparing column family is enough.
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
argument_list|,
name|lfamilyoffset
operator|+
name|common
argument_list|,
name|lfamilylength
operator|-
name|common
argument_list|,
name|right
argument_list|,
name|rfamilyoffset
operator|+
name|common
argument_list|,
name|rfamilylength
operator|-
name|common
argument_list|)
return|;
block|}
comment|// Compare family& qualifier together.
specifier|final
name|int
name|comparison
init|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
argument_list|,
name|lfamilyoffset
operator|+
name|common
argument_list|,
name|lcolumnlength
operator|-
name|common
argument_list|,
name|right
argument_list|,
name|rfamilyoffset
operator|+
name|common
argument_list|,
name|rcolumnlength
operator|-
name|common
argument_list|)
decl_stmt|;
if|if
condition|(
name|comparison
operator|!=
literal|0
condition|)
block|{
return|return
name|comparison
return|;
block|}
comment|////
comment|// Next compare timestamps.
name|long
name|ltimestamp
init|=
name|Bytes
operator|.
name|toLong
argument_list|(
name|left
argument_list|,
name|loffset
operator|+
operator|(
name|llength
operator|-
name|TIMESTAMP_TYPE_SIZE
operator|)
argument_list|)
decl_stmt|;
name|long
name|rtimestamp
init|=
name|Bytes
operator|.
name|toLong
argument_list|(
name|right
argument_list|,
name|roffset
operator|+
operator|(
name|rlength
operator|-
name|TIMESTAMP_TYPE_SIZE
operator|)
argument_list|)
decl_stmt|;
name|int
name|compare
init|=
name|compareTimestamps
argument_list|(
name|ltimestamp
argument_list|,
name|rtimestamp
argument_list|)
decl_stmt|;
if|if
condition|(
name|compare
operator|!=
literal|0
condition|)
block|{
return|return
name|compare
return|;
block|}
comment|// Compare types. Let the delete types sort ahead of puts; i.e. types
comment|// of higher numbers sort before those of lesser numbers. Maximum (255)
comment|// appears ahead of everything, and minimum (0) appears after
comment|// everything.
return|return
operator|(
literal|0xff
operator|&
name|rtype
operator|)
operator|-
operator|(
literal|0xff
operator|&
name|ltype
operator|)
return|;
block|}
comment|/**      * Compares the row and column of two keyvalues for equality      * @param left      * @param right      * @return True if same row and column.      */
specifier|public
name|boolean
name|matchingRowColumn
parameter_list|(
specifier|final
name|KeyValue
name|left
parameter_list|,
specifier|final
name|KeyValue
name|right
parameter_list|)
block|{
name|short
name|lrowlength
init|=
name|left
operator|.
name|getRowLength
argument_list|()
decl_stmt|;
name|short
name|rrowlength
init|=
name|right
operator|.
name|getRowLength
argument_list|()
decl_stmt|;
comment|// TsOffset = end of column data. just comparing Row+CF length of each
if|if
condition|(
operator|(
name|left
operator|.
name|getTimestampOffset
argument_list|()
operator|-
name|left
operator|.
name|getOffset
argument_list|()
operator|)
operator|!=
operator|(
name|right
operator|.
name|getTimestampOffset
argument_list|()
operator|-
name|right
operator|.
name|getOffset
argument_list|()
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|matchingRows
argument_list|(
name|left
argument_list|,
name|lrowlength
argument_list|,
name|right
argument_list|,
name|rrowlength
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|lfoffset
init|=
name|left
operator|.
name|getFamilyOffset
argument_list|(
name|lrowlength
argument_list|)
decl_stmt|;
name|int
name|rfoffset
init|=
name|right
operator|.
name|getFamilyOffset
argument_list|(
name|rrowlength
argument_list|)
decl_stmt|;
name|int
name|lclength
init|=
name|left
operator|.
name|getTotalColumnLength
argument_list|(
name|lrowlength
argument_list|,
name|lfoffset
argument_list|)
decl_stmt|;
name|int
name|rclength
init|=
name|right
operator|.
name|getTotalColumnLength
argument_list|(
name|rrowlength
argument_list|,
name|rfoffset
argument_list|)
decl_stmt|;
name|int
name|lfamilylength
init|=
name|left
operator|.
name|getFamilyLength
argument_list|(
name|lfoffset
argument_list|)
decl_stmt|;
name|int
name|rfamilylength
init|=
name|right
operator|.
name|getFamilyLength
argument_list|(
name|rfoffset
argument_list|)
decl_stmt|;
name|int
name|ccRes
init|=
name|compareColumns
argument_list|(
name|left
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|lfoffset
argument_list|,
name|lclength
argument_list|,
name|lfamilylength
argument_list|,
name|right
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|rfoffset
argument_list|,
name|rclength
argument_list|,
name|rfamilylength
argument_list|)
decl_stmt|;
return|return
name|ccRes
operator|==
literal|0
return|;
block|}
comment|/**      * Compares the row of two keyvalues for equality      * @param left      * @param right      * @return True if rows match.      */
specifier|public
name|boolean
name|matchingRows
parameter_list|(
specifier|final
name|KeyValue
name|left
parameter_list|,
specifier|final
name|KeyValue
name|right
parameter_list|)
block|{
name|short
name|lrowlength
init|=
name|left
operator|.
name|getRowLength
argument_list|()
decl_stmt|;
name|short
name|rrowlength
init|=
name|right
operator|.
name|getRowLength
argument_list|()
decl_stmt|;
return|return
name|matchingRows
argument_list|(
name|left
argument_list|,
name|lrowlength
argument_list|,
name|right
argument_list|,
name|rrowlength
argument_list|)
return|;
block|}
comment|/**      * @param left      * @param lrowlength      * @param right      * @param rrowlength      * @return True if rows match.      */
specifier|private
name|boolean
name|matchingRows
parameter_list|(
specifier|final
name|KeyValue
name|left
parameter_list|,
specifier|final
name|short
name|lrowlength
parameter_list|,
specifier|final
name|KeyValue
name|right
parameter_list|,
specifier|final
name|short
name|rrowlength
parameter_list|)
block|{
return|return
name|lrowlength
operator|==
name|rrowlength
operator|&&
name|matchingRows
argument_list|(
name|left
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|left
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|lrowlength
argument_list|,
name|right
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|right
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|rrowlength
argument_list|)
return|;
block|}
comment|/**      * Compare rows. Just calls Bytes.equals, but it's good to have this encapsulated.      * @param left Left row array.      * @param loffset Left row offset.      * @param llength Left row length.      * @param right Right row array.      * @param roffset Right row offset.      * @param rlength Right row length.      * @return Whether rows are the same row.      */
specifier|public
name|boolean
name|matchingRows
parameter_list|(
specifier|final
name|byte
index|[]
name|left
parameter_list|,
specifier|final
name|int
name|loffset
parameter_list|,
specifier|final
name|int
name|llength
parameter_list|,
specifier|final
name|byte
index|[]
name|right
parameter_list|,
specifier|final
name|int
name|roffset
parameter_list|,
specifier|final
name|int
name|rlength
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|left
argument_list|,
name|loffset
argument_list|,
name|llength
argument_list|,
name|right
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|)
return|;
block|}
specifier|public
name|byte
index|[]
name|calcIndexKey
parameter_list|(
name|byte
index|[]
name|lastKeyOfPreviousBlock
parameter_list|,
name|byte
index|[]
name|firstKeyInBlock
parameter_list|)
block|{
name|byte
index|[]
name|fakeKey
init|=
name|getShortMidpointKey
argument_list|(
name|lastKeyOfPreviousBlock
argument_list|,
name|firstKeyInBlock
argument_list|)
decl_stmt|;
if|if
condition|(
name|compareFlatKey
argument_list|(
name|fakeKey
argument_list|,
name|firstKeyInBlock
argument_list|)
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unexpected getShortMidpointKey result, fakeKey:"
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|fakeKey
argument_list|)
operator|+
literal|", firstKeyInBlock:"
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|firstKeyInBlock
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|firstKeyInBlock
return|;
block|}
if|if
condition|(
name|lastKeyOfPreviousBlock
operator|!=
literal|null
operator|&&
name|compareFlatKey
argument_list|(
name|lastKeyOfPreviousBlock
argument_list|,
name|fakeKey
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unexpected getShortMidpointKey result, lastKeyOfPreviousBlock:"
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|lastKeyOfPreviousBlock
argument_list|)
operator|+
literal|", fakeKey:"
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|fakeKey
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|firstKeyInBlock
return|;
block|}
return|return
name|fakeKey
return|;
block|}
comment|/**      * This is a HFile block index key optimization.      * @param leftKey      * @param rightKey      * @return 0 if equal,<0 if left smaller,>0 if right smaller      */
specifier|public
name|byte
index|[]
name|getShortMidpointKey
parameter_list|(
specifier|final
name|byte
index|[]
name|leftKey
parameter_list|,
specifier|final
name|byte
index|[]
name|rightKey
parameter_list|)
block|{
if|if
condition|(
name|rightKey
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"rightKey can not be null"
argument_list|)
throw|;
block|}
if|if
condition|(
name|leftKey
operator|==
literal|null
condition|)
block|{
return|return
name|Arrays
operator|.
name|copyOf
argument_list|(
name|rightKey
argument_list|,
name|rightKey
operator|.
name|length
argument_list|)
return|;
block|}
if|if
condition|(
name|compareFlatKey
argument_list|(
name|leftKey
argument_list|,
name|rightKey
argument_list|)
operator|>=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unexpected input, leftKey:"
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|leftKey
argument_list|)
operator|+
literal|", rightKey:"
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|rightKey
argument_list|)
argument_list|)
throw|;
block|}
name|short
name|leftRowLength
init|=
name|Bytes
operator|.
name|toShort
argument_list|(
name|leftKey
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|short
name|rightRowLength
init|=
name|Bytes
operator|.
name|toShort
argument_list|(
name|rightKey
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|leftCommonLength
init|=
name|ROW_LENGTH_SIZE
operator|+
name|FAMILY_LENGTH_SIZE
operator|+
name|leftRowLength
decl_stmt|;
name|int
name|rightCommonLength
init|=
name|ROW_LENGTH_SIZE
operator|+
name|FAMILY_LENGTH_SIZE
operator|+
name|rightRowLength
decl_stmt|;
name|int
name|leftCommonLengthWithTSAndType
init|=
name|TIMESTAMP_TYPE_SIZE
operator|+
name|leftCommonLength
decl_stmt|;
name|int
name|rightCommonLengthWithTSAndType
init|=
name|TIMESTAMP_TYPE_SIZE
operator|+
name|rightCommonLength
decl_stmt|;
name|int
name|leftColumnLength
init|=
name|leftKey
operator|.
name|length
operator|-
name|leftCommonLengthWithTSAndType
decl_stmt|;
name|int
name|rightColumnLength
init|=
name|rightKey
operator|.
name|length
operator|-
name|rightCommonLengthWithTSAndType
decl_stmt|;
comment|// rows are equal
if|if
condition|(
name|leftRowLength
operator|==
name|rightRowLength
operator|&&
name|compareRows
argument_list|(
name|leftKey
argument_list|,
name|ROW_LENGTH_SIZE
argument_list|,
name|leftRowLength
argument_list|,
name|rightKey
argument_list|,
name|ROW_LENGTH_SIZE
argument_list|,
name|rightRowLength
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// Compare family& qualifier together.
name|int
name|comparison
init|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|leftKey
argument_list|,
name|leftCommonLength
argument_list|,
name|leftColumnLength
argument_list|,
name|rightKey
argument_list|,
name|rightCommonLength
argument_list|,
name|rightColumnLength
argument_list|)
decl_stmt|;
comment|// same with "row + family + qualifier", return rightKey directly
if|if
condition|(
name|comparison
operator|==
literal|0
condition|)
block|{
return|return
name|Arrays
operator|.
name|copyOf
argument_list|(
name|rightKey
argument_list|,
name|rightKey
operator|.
name|length
argument_list|)
return|;
block|}
comment|// "family + qualifier" are different, generate a faked key per rightKey
name|byte
index|[]
name|newKey
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|rightKey
argument_list|,
name|rightKey
operator|.
name|length
argument_list|)
decl_stmt|;
name|Bytes
operator|.
name|putLong
argument_list|(
name|newKey
argument_list|,
name|rightKey
operator|.
name|length
operator|-
name|TIMESTAMP_TYPE_SIZE
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|)
expr_stmt|;
name|Bytes
operator|.
name|putByte
argument_list|(
name|newKey
argument_list|,
name|rightKey
operator|.
name|length
operator|-
name|TYPE_SIZE
argument_list|,
name|Type
operator|.
name|Maximum
operator|.
name|getCode
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|newKey
return|;
block|}
comment|// rows are different
name|short
name|minLength
init|=
name|leftRowLength
operator|<
name|rightRowLength
condition|?
name|leftRowLength
else|:
name|rightRowLength
decl_stmt|;
name|short
name|diffIdx
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|diffIdx
operator|<
name|minLength
operator|&&
name|leftKey
index|[
name|ROW_LENGTH_SIZE
operator|+
name|diffIdx
index|]
operator|==
name|rightKey
index|[
name|ROW_LENGTH_SIZE
operator|+
name|diffIdx
index|]
condition|)
block|{
name|diffIdx
operator|++
expr_stmt|;
block|}
name|byte
index|[]
name|newRowKey
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|diffIdx
operator|>=
name|minLength
condition|)
block|{
comment|// leftKey's row is prefix of rightKey's.
name|newRowKey
operator|=
operator|new
name|byte
index|[
name|diffIdx
operator|+
literal|1
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|rightKey
argument_list|,
name|ROW_LENGTH_SIZE
argument_list|,
name|newRowKey
argument_list|,
literal|0
argument_list|,
name|diffIdx
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|diffByte
init|=
name|leftKey
index|[
name|ROW_LENGTH_SIZE
operator|+
name|diffIdx
index|]
decl_stmt|;
if|if
condition|(
operator|(
literal|0xff
operator|&
name|diffByte
operator|)
operator|<
literal|0xff
operator|&&
operator|(
name|diffByte
operator|+
literal|1
operator|)
operator|<
operator|(
name|rightKey
index|[
name|ROW_LENGTH_SIZE
operator|+
name|diffIdx
index|]
operator|&
literal|0xff
operator|)
condition|)
block|{
name|newRowKey
operator|=
operator|new
name|byte
index|[
name|diffIdx
operator|+
literal|1
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|leftKey
argument_list|,
name|ROW_LENGTH_SIZE
argument_list|,
name|newRowKey
argument_list|,
literal|0
argument_list|,
name|diffIdx
argument_list|)
expr_stmt|;
name|newRowKey
index|[
name|diffIdx
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|diffByte
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newRowKey
operator|=
operator|new
name|byte
index|[
name|diffIdx
operator|+
literal|1
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|rightKey
argument_list|,
name|ROW_LENGTH_SIZE
argument_list|,
name|newRowKey
argument_list|,
literal|0
argument_list|,
name|diffIdx
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|KeyValue
argument_list|(
name|newRowKey
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|,
name|Type
operator|.
name|Maximum
argument_list|)
operator|.
name|getKey
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|protected
name|Object
name|clone
parameter_list|()
throws|throws
name|CloneNotSupportedException
block|{
return|return
operator|new
name|KVComparator
argument_list|()
return|;
block|}
block|}
comment|/**    * Creates a KeyValue that is last on the specified row id. That is,    * every other possible KeyValue for the given row would compareTo()    * less than the result of this call.    * @param row row key    * @return Last possible KeyValue on passed<code>row</code>    */
specifier|public
specifier|static
name|KeyValue
name|createLastOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|,
name|Type
operator|.
name|Minimum
argument_list|)
return|;
block|}
comment|/**    * Create a KeyValue that is smaller than all other possible KeyValues    * for the given row. That is any (valid) KeyValue on 'row' would sort    * _after_ the result.    *    * @param row - row key (arbitrary byte array)    * @return First possible KeyValue on passed<code>row</code>    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|)
block|{
return|return
name|createFirstOnRow
argument_list|(
name|row
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|)
return|;
block|}
comment|/**    * Create a KeyValue that is smaller than all other possible KeyValues    * for the given row. That is any (valid) KeyValue on 'row' would sort    * _after_ the result.    *    * @param row - row key (arbitrary byte array)    * @return First possible KeyValue on passed<code>row</code>    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
name|int
name|roffset
parameter_list|,
name|short
name|rlength
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|,
name|Type
operator|.
name|Maximum
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Creates a KeyValue that is smaller than all other KeyValues that    * are older than the passed timestamp.    * @param row - row key (arbitrary byte array)    * @param ts - timestamp    * @return First possible key on passed<code>row</code> and timestamp.    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|long
name|ts
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|ts
argument_list|,
name|Type
operator|.
name|Maximum
argument_list|)
return|;
block|}
comment|/**    * Create a KeyValue for the specified row, family and qualifier that would be    * smaller than all other possible KeyValues that have the same row,family,qualifier.    * Used for seeking.    * @param row - row key (arbitrary byte array)    * @param family - family name    * @param qualifier - column qualifier    * @return First possible key on passed<code>row</code>, and column.    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|,
name|Type
operator|.
name|Maximum
argument_list|)
return|;
block|}
comment|/**    * Create a Delete Family KeyValue for the specified row and family that would    * be smaller than all other possible Delete Family KeyValues that have the    * same row and family.    * Used for seeking.    * @param row - row key (arbitrary byte array)    * @param family - family name    * @return First Delete Family possible key on passed<code>row</code>.    */
specifier|public
specifier|static
name|KeyValue
name|createFirstDeleteFamilyOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
literal|null
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|,
name|Type
operator|.
name|DeleteFamily
argument_list|)
return|;
block|}
comment|/**    * @param row - row key (arbitrary byte array)    * @param f - family name    * @param q - column qualifier    * @param ts - timestamp    * @return First possible key on passed<code>row</code>, column and timestamp    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|f
parameter_list|,
specifier|final
name|byte
index|[]
name|q
parameter_list|,
specifier|final
name|long
name|ts
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
name|f
argument_list|,
name|q
argument_list|,
name|ts
argument_list|,
name|Type
operator|.
name|Maximum
argument_list|)
return|;
block|}
comment|/**    * Create a KeyValue for the specified row, family and qualifier that would be    * smaller than all other possible KeyValues that have the same row,    * family, qualifier.    * Used for seeking.    * @param row row key    * @param roffset row offset    * @param rlength row length    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    * @return First possible key on passed Row, Family, Qualifier.    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|int
name|roffset
parameter_list|,
specifier|final
name|int
name|rlength
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|int
name|foffset
parameter_list|,
specifier|final
name|int
name|flength
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|int
name|qoffset
parameter_list|,
specifier|final
name|int
name|qlength
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|,
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|,
name|Type
operator|.
name|Maximum
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Create a KeyValue for the specified row, family and qualifier that would be    * smaller than all other possible KeyValues that have the same row,    * family, qualifier.    * Used for seeking.    *    * @param buffer the buffer to use for the new<code>KeyValue</code> object    * @param row the value key    * @param family family name    * @param qualifier column qualifier    *    * @return First possible key on passed Row, Family, Qualifier.    *    * @throws IllegalArgumentException The resulting<code>KeyValue</code> object would be larger    * than the provided buffer or than<code>Integer.MAX_VALUE</code>    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRow
parameter_list|(
name|byte
index|[]
name|buffer
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
return|return
name|createFirstOnRow
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|row
argument_list|,
literal|0
argument_list|,
name|row
operator|.
name|length
argument_list|,
name|family
argument_list|,
literal|0
argument_list|,
name|family
operator|.
name|length
argument_list|,
name|qualifier
argument_list|,
literal|0
argument_list|,
name|qualifier
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * Create a KeyValue for the specified row, family and qualifier that would be    * smaller than all other possible KeyValues that have the same row,    * family, qualifier.    * Used for seeking.    *    * @param buffer the buffer to use for the new<code>KeyValue</code> object    * @param boffset buffer offset    * @param row the value key    * @param roffset row offset    * @param rlength row length    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    *    * @return First possible key on passed Row, Family, Qualifier.    *    * @throws IllegalArgumentException The resulting<code>KeyValue</code> object would be larger    * than the provided buffer or than<code>Integer.MAX_VALUE</code>    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRow
parameter_list|(
name|byte
index|[]
name|buffer
parameter_list|,
specifier|final
name|int
name|boffset
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|int
name|roffset
parameter_list|,
specifier|final
name|int
name|rlength
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|int
name|foffset
parameter_list|,
specifier|final
name|int
name|flength
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|int
name|qoffset
parameter_list|,
specifier|final
name|int
name|qlength
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|long
name|lLength
init|=
name|getKeyValueDataStructureSize
argument_list|(
name|rlength
argument_list|,
name|flength
argument_list|,
name|qlength
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|lLength
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"KeyValue length "
operator|+
name|lLength
operator|+
literal|"> "
operator|+
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
throw|;
block|}
name|int
name|iLength
init|=
operator|(
name|int
operator|)
name|lLength
decl_stmt|;
if|if
condition|(
name|buffer
operator|.
name|length
operator|-
name|boffset
operator|<
name|iLength
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Buffer size "
operator|+
operator|(
name|buffer
operator|.
name|length
operator|-
name|boffset
operator|)
operator|+
literal|"< "
operator|+
name|iLength
argument_list|)
throw|;
block|}
name|int
name|len
init|=
name|writeByteArray
argument_list|(
name|buffer
argument_list|,
name|boffset
argument_list|,
name|row
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|,
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|,
name|KeyValue
operator|.
name|Type
operator|.
name|Maximum
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
operator|new
name|KeyValue
argument_list|(
name|buffer
argument_list|,
name|boffset
argument_list|,
name|len
argument_list|)
return|;
block|}
comment|/**    * Create a KeyValue for the specified row, family and qualifier that would be    * larger than or equal to all other possible KeyValues that have the same    * row, family, qualifier.    * Used for reseeking.    * @param row row key    * @param roffset row offset    * @param rlength row length    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    * @return Last possible key on passed row, family, qualifier.    */
specifier|public
specifier|static
name|KeyValue
name|createLastOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|int
name|roffset
parameter_list|,
specifier|final
name|int
name|rlength
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|int
name|foffset
parameter_list|,
specifier|final
name|int
name|flength
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|int
name|qoffset
parameter_list|,
specifier|final
name|int
name|qlength
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|,
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|,
name|HConstants
operator|.
name|OLDEST_TIMESTAMP
argument_list|,
name|Type
operator|.
name|Minimum
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Similar to {@link #createLastOnRow(byte[], int, int, byte[], int, int,    * byte[], int, int)} but creates the last key on the row/column of this KV    * (the value part of the returned KV is always empty). Used in creating    * "fake keys" for the multi-column Bloom filter optimization to skip the    * row/column we already know is not in the file.    * @return the last key on the row/column of the given key-value pair    */
specifier|public
name|KeyValue
name|createLastOnRowCol
parameter_list|()
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|bytes
argument_list|,
name|getRowOffset
argument_list|()
argument_list|,
name|getRowLength
argument_list|()
argument_list|,
name|bytes
argument_list|,
name|getFamilyOffset
argument_list|()
argument_list|,
name|getFamilyLength
argument_list|()
argument_list|,
name|bytes
argument_list|,
name|getQualifierOffset
argument_list|()
argument_list|,
name|getQualifierLength
argument_list|()
argument_list|,
name|HConstants
operator|.
name|OLDEST_TIMESTAMP
argument_list|,
name|Type
operator|.
name|Minimum
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Creates the first KV with the row/family/qualifier of this KV and the    * given timestamp. Uses the "maximum" KV type that guarantees that the new    * KV is the lowest possible for this combination of row, family, qualifier,    * and timestamp. This KV's own timestamp is ignored. While this function    * copies the value from this KV, it is normally used on key-only KVs.    */
specifier|public
name|KeyValue
name|createFirstOnRowColTS
parameter_list|(
name|long
name|ts
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|bytes
argument_list|,
name|getRowOffset
argument_list|()
argument_list|,
name|getRowLength
argument_list|()
argument_list|,
name|bytes
argument_list|,
name|getFamilyOffset
argument_list|()
argument_list|,
name|getFamilyLength
argument_list|()
argument_list|,
name|bytes
argument_list|,
name|getQualifierOffset
argument_list|()
argument_list|,
name|getQualifierLength
argument_list|()
argument_list|,
name|ts
argument_list|,
name|Type
operator|.
name|Maximum
argument_list|,
name|bytes
argument_list|,
name|getValueOffset
argument_list|()
argument_list|,
name|getValueLength
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @param b    * @return A KeyValue made of a byte array that holds the key-only part.    * Needed to convert hfile index members to KeyValues.    */
specifier|public
specifier|static
name|KeyValue
name|createKeyValueFromKey
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|)
block|{
return|return
name|createKeyValueFromKey
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * @param bb    * @return A KeyValue made of a byte buffer that holds the key-only part.    * Needed to convert hfile index members to KeyValues.    */
specifier|public
specifier|static
name|KeyValue
name|createKeyValueFromKey
parameter_list|(
specifier|final
name|ByteBuffer
name|bb
parameter_list|)
block|{
return|return
name|createKeyValueFromKey
argument_list|(
name|bb
operator|.
name|array
argument_list|()
argument_list|,
name|bb
operator|.
name|arrayOffset
argument_list|()
argument_list|,
name|bb
operator|.
name|limit
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @param b    * @param o    * @param l    * @return A KeyValue made of a byte array that holds the key-only part.    * Needed to convert hfile index members to KeyValues.    */
specifier|public
specifier|static
name|KeyValue
name|createKeyValueFromKey
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|,
specifier|final
name|int
name|o
parameter_list|,
specifier|final
name|int
name|l
parameter_list|)
block|{
name|byte
index|[]
name|newb
init|=
operator|new
name|byte
index|[
name|l
operator|+
name|ROW_OFFSET
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|b
argument_list|,
name|o
argument_list|,
name|newb
argument_list|,
name|ROW_OFFSET
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|Bytes
operator|.
name|putInt
argument_list|(
name|newb
argument_list|,
literal|0
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|Bytes
operator|.
name|putInt
argument_list|(
name|newb
argument_list|,
name|Bytes
operator|.
name|SIZEOF_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|new
name|KeyValue
argument_list|(
name|newb
argument_list|)
return|;
block|}
comment|/**    * @param in Where to read bytes from.  Creates a byte array to hold the KeyValue    * backing bytes copied from the steam.    * @return KeyValue created by deserializing from<code>in</code> OR if we find a length    * of zero, we will return null which can be useful marking a stream as done.    * @throws IOException    */
specifier|public
specifier|static
name|KeyValue
name|create
parameter_list|(
specifier|final
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|create
argument_list|(
name|in
operator|.
name|readInt
argument_list|()
argument_list|,
name|in
argument_list|)
return|;
block|}
comment|/**    * Create a KeyValue reading<code>length</code> from<code>in</code>    * @param length    * @param in    * @return Created KeyValue OR if we find a length of zero, we will return null which    * can be useful marking a stream as done.    * @throws IOException    */
specifier|public
specifier|static
name|KeyValue
name|create
parameter_list|(
name|int
name|length
parameter_list|,
specifier|final
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|length
operator|==
literal|0
condition|)
return|return
literal|null
return|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed read "
operator|+
name|length
operator|+
literal|" bytes, stream corrupt?"
argument_list|)
throw|;
block|}
comment|// This is how the old Writables.readFrom used to deserialize.  Didn't even vint.
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|length
index|]
decl_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
return|return
operator|new
name|KeyValue
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
return|;
block|}
comment|/**    * Create a new KeyValue by copying existing cell and adding new tags    * @param c    * @param newTags    * @return a new KeyValue instance with new tags    */
specifier|public
specifier|static
name|KeyValue
name|cloneAndAddTags
parameter_list|(
name|Cell
name|c
parameter_list|,
name|List
argument_list|<
name|Tag
argument_list|>
name|newTags
parameter_list|)
block|{
name|List
argument_list|<
name|Tag
argument_list|>
name|existingTags
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|getTagsLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|existingTags
operator|=
name|Tag
operator|.
name|asList
argument_list|(
name|c
operator|.
name|getTagsArray
argument_list|()
argument_list|,
name|c
operator|.
name|getTagsOffset
argument_list|()
argument_list|,
name|c
operator|.
name|getTagsLength
argument_list|()
argument_list|)
expr_stmt|;
name|existingTags
operator|.
name|addAll
argument_list|(
name|newTags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|existingTags
operator|=
name|newTags
expr_stmt|;
block|}
return|return
operator|new
name|KeyValue
argument_list|(
name|c
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|c
operator|.
name|getRowOffset
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|c
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|c
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|c
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|c
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|c
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|c
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|c
operator|.
name|getQualifierLength
argument_list|()
argument_list|,
name|c
operator|.
name|getTimestamp
argument_list|()
argument_list|,
name|Type
operator|.
name|codeToType
argument_list|(
name|c
operator|.
name|getTypeByte
argument_list|()
argument_list|)
argument_list|,
name|c
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|c
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|c
operator|.
name|getValueLength
argument_list|()
argument_list|,
name|existingTags
argument_list|)
return|;
block|}
comment|/**    * Create a KeyValue reading from the raw InputStream.    * Named<code>iscreate</code> so doesn't clash with {@link #create(DataInput)}    * @param in    * @return Created KeyValue OR if we find a length of zero, we will return null which    * can be useful marking a stream as done.    * @throws IOException    */
specifier|public
specifier|static
name|KeyValue
name|iscreate
parameter_list|(
specifier|final
name|InputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|intBytes
init|=
operator|new
name|byte
index|[
name|Bytes
operator|.
name|SIZEOF_INT
index|]
decl_stmt|;
name|int
name|bytesRead
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|bytesRead
operator|<
name|intBytes
operator|.
name|length
condition|)
block|{
name|int
name|n
init|=
name|in
operator|.
name|read
argument_list|(
name|intBytes
argument_list|,
name|bytesRead
argument_list|,
name|intBytes
operator|.
name|length
operator|-
name|bytesRead
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|bytesRead
operator|==
literal|0
condition|)
return|return
literal|null
return|;
comment|// EOF at start is ok
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed read of int, read "
operator|+
name|bytesRead
operator|+
literal|" bytes"
argument_list|)
throw|;
block|}
name|bytesRead
operator|+=
name|n
expr_stmt|;
block|}
comment|// TODO: perhaps some sanity check is needed here.
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|Bytes
operator|.
name|toInt
argument_list|(
name|intBytes
argument_list|)
index|]
decl_stmt|;
name|IOUtils
operator|.
name|readFully
argument_list|(
name|in
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
operator|new
name|KeyValue
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * Write out a KeyValue in the manner in which we used to when KeyValue was a Writable.    * @param kv    * @param out    * @return Length written on stream    * @throws IOException    * @see #create(DataInput) for the inverse function    */
specifier|public
specifier|static
name|long
name|write
parameter_list|(
specifier|final
name|KeyValue
name|kv
parameter_list|,
specifier|final
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
comment|// This is how the old Writables write used to serialize KVs.  Need to figure way to make it
comment|// work for all implementations.
name|int
name|length
init|=
name|kv
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|kv
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|kv
operator|.
name|getOffset
argument_list|()
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|length
operator|+
name|Bytes
operator|.
name|SIZEOF_INT
return|;
block|}
comment|/**    * Write out a KeyValue in the manner in which we used to when KeyValue was a Writable but do    * not require a {@link DataOutput}, just take plain {@link OutputStream}    * Named<code>oswrite</code> so does not clash with {@link #write(KeyValue, DataOutput)}    * @param kv    * @param out    * @return Length written on stream    * @throws IOException    * @see #create(DataInput) for the inverse function    * @see #write(KeyValue, DataOutput)    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|long
name|oswrite
parameter_list|(
specifier|final
name|KeyValue
name|kv
parameter_list|,
specifier|final
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|length
init|=
name|kv
operator|.
name|getLength
argument_list|()
decl_stmt|;
comment|// This does same as DataOuput#writeInt (big-endian, etc.)
name|out
operator|.
name|write
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|kv
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|kv
operator|.
name|getOffset
argument_list|()
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|length
operator|+
name|Bytes
operator|.
name|SIZEOF_INT
return|;
block|}
comment|/**    * Write out a KeyValue in the manner in which we used to when KeyValue was a Writable but do    * not require a {@link DataOutput}, just take plain {@link OutputStream}    * Named<code>oswrite</code> so does not clash with {@link #write(KeyValue, DataOutput)}    * @param kv    * @param out    * @param withTags    * @return Length written on stream    * @throws IOException    * @see #create(DataInput) for the inverse function    * @see #write(KeyValue, DataOutput)    */
specifier|public
specifier|static
name|long
name|oswrite
parameter_list|(
specifier|final
name|KeyValue
name|kv
parameter_list|,
specifier|final
name|OutputStream
name|out
parameter_list|,
specifier|final
name|boolean
name|withTags
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|length
init|=
name|kv
operator|.
name|getLength
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|withTags
condition|)
block|{
name|length
operator|=
name|kv
operator|.
name|getKeyLength
argument_list|()
operator|+
name|kv
operator|.
name|getValueLength
argument_list|()
operator|+
name|KEYVALUE_INFRASTRUCTURE_SIZE
expr_stmt|;
block|}
comment|// This does same as DataOuput#writeInt (big-endian, etc.)
name|out
operator|.
name|write
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|kv
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|kv
operator|.
name|getOffset
argument_list|()
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|length
operator|+
name|Bytes
operator|.
name|SIZEOF_INT
return|;
block|}
comment|/**    * Comparator that compares row component only of a KeyValue.    */
specifier|public
specifier|static
class|class
name|RowOnlyComparator
implements|implements
name|Comparator
argument_list|<
name|KeyValue
argument_list|>
block|{
specifier|final
name|KVComparator
name|comparator
decl_stmt|;
specifier|public
name|RowOnlyComparator
parameter_list|(
specifier|final
name|KVComparator
name|c
parameter_list|)
block|{
name|this
operator|.
name|comparator
operator|=
name|c
expr_stmt|;
block|}
specifier|public
name|int
name|compare
parameter_list|(
name|KeyValue
name|left
parameter_list|,
name|KeyValue
name|right
parameter_list|)
block|{
return|return
name|comparator
operator|.
name|compareRows
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
block|}
comment|/**    * Avoids redundant comparisons for better performance.    *     * TODO get rid of this wart    */
specifier|public
interface|interface
name|SamePrefixComparator
parameter_list|<
name|T
parameter_list|>
block|{
comment|/**      * Compare two keys assuming that the first n bytes are the same.      * @param commonPrefix How many bytes are the same.      */
name|int
name|compareIgnoringPrefix
parameter_list|(
name|int
name|commonPrefix
parameter_list|,
name|byte
index|[]
name|left
parameter_list|,
name|int
name|loffset
parameter_list|,
name|int
name|llength
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|roffset
parameter_list|,
name|int
name|rlength
parameter_list|)
function_decl|;
block|}
comment|/**    * This is a TEST only Comparator used in TestSeekTo and TestReseekTo.    */
specifier|public
specifier|static
class|class
name|RawBytesComparator
extends|extends
name|KVComparator
block|{
comment|/**      * The HFileV2 file format's trailer contains this class name.  We reinterpret this and      * instantiate the appropriate comparator.      * TODO: With V3 consider removing this.      * @return legacy class name for FileFileTrailer#comparatorClassName      */
specifier|public
name|String
name|getLegacyKeyComparatorName
parameter_list|()
block|{
return|return
literal|"org.apache.hadoop.hbase.util.Bytes$ByteArrayComparator"
return|;
block|}
specifier|public
name|int
name|compareFlatKey
parameter_list|(
name|byte
index|[]
name|left
parameter_list|,
name|int
name|loffset
parameter_list|,
name|int
name|llength
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|roffset
parameter_list|,
name|int
name|rlength
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|BYTES_RAWCOMPARATOR
operator|.
name|compare
argument_list|(
name|left
argument_list|,
name|loffset
argument_list|,
name|llength
argument_list|,
name|right
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|)
return|;
block|}
specifier|public
name|byte
index|[]
name|calcIndexKey
parameter_list|(
name|byte
index|[]
name|lastKeyOfPreviousBlock
parameter_list|,
name|byte
index|[]
name|firstKeyInBlock
parameter_list|)
block|{
return|return
name|firstKeyInBlock
return|;
block|}
block|}
comment|/**    * HeapSize implementation    *    * We do not count the bytes in the rowCache because it should be empty for a KeyValue in the    * MemStore.    */
annotation|@
name|Override
specifier|public
name|long
name|heapSize
parameter_list|()
block|{
name|int
name|sum
init|=
literal|0
decl_stmt|;
name|sum
operator|+=
name|ClassSize
operator|.
name|OBJECT
expr_stmt|;
comment|// the KeyValue object itself
name|sum
operator|+=
name|ClassSize
operator|.
name|REFERENCE
expr_stmt|;
comment|// pointer to "bytes"
name|sum
operator|+=
name|ClassSize
operator|.
name|align
argument_list|(
name|ClassSize
operator|.
name|ARRAY
argument_list|)
expr_stmt|;
comment|// "bytes"
name|sum
operator|+=
name|ClassSize
operator|.
name|align
argument_list|(
name|length
argument_list|)
expr_stmt|;
comment|// number of bytes of data in the "bytes" array
name|sum
operator|+=
literal|2
operator|*
name|Bytes
operator|.
name|SIZEOF_INT
expr_stmt|;
comment|// offset, length
name|sum
operator|+=
name|Bytes
operator|.
name|SIZEOF_LONG
expr_stmt|;
comment|// memstoreTS
return|return
name|ClassSize
operator|.
name|align
argument_list|(
name|sum
argument_list|)
return|;
block|}
block|}
end_class

end_unit

