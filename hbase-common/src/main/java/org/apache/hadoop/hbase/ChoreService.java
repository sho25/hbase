begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ScheduledChore
operator|.
name|ChoreServicer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * ChoreService is a service that can be used to schedule instances of {@link ScheduledChore} to run  * periodically while sharing threads. The ChoreService is backed by a  * {@link ScheduledThreadPoolExecutor} whose core pool size changes dynamically depending on the  * number of {@link ScheduledChore} scheduled. All of the threads in the core thread pool of the  * underlying {@link ScheduledThreadPoolExecutor} are set to be daemon threads.  *<p>  * The ChoreService provides the ability to schedule, cancel, and trigger instances of  * {@link ScheduledChore}. The ChoreService also provides the ability to check on the status of  * scheduled chores. The number of threads used by the ChoreService changes based on the scheduling  * load and whether or not the scheduled chores are executing on time. As more chores are scheduled,  * there may be a need to increase the number of threads if it is noticed that chores are no longer  * meeting their scheduled start times. On the other hand, as chores are cancelled, an attempt is  * made to reduce the number of running threads to see if chores can still meet their start times  * with a smaller thread pool.  *<p>  * When finished with a ChoreService it is good practice to call {@link ChoreService#shutdown()}.  * Calling this method ensures that all scheduled chores are cancelled and cleaned up properly.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
specifier|public
class|class
name|ChoreService
implements|implements
name|ChoreServicer
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ChoreService
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * The minimum number of threads in the core pool of the underlying ScheduledThreadPoolExecutor    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|final
specifier|static
name|int
name|MIN_CORE_POOL_SIZE
init|=
literal|1
decl_stmt|;
comment|/**    * This thread pool is used to schedule all of the Chores    */
specifier|private
specifier|final
name|ScheduledThreadPoolExecutor
name|scheduler
decl_stmt|;
comment|/**    * Maps chores to their futures. Futures are used to control a chore's schedule    */
specifier|private
specifier|final
name|HashMap
argument_list|<
name|ScheduledChore
argument_list|,
name|ScheduledFuture
argument_list|<
name|?
argument_list|>
argument_list|>
name|scheduledChores
decl_stmt|;
comment|/**    * Maps chores to Booleans which indicate whether or not a chore has caused an increase in the    * core pool size of the ScheduledThreadPoolExecutor. Each chore should only be allowed to    * increase the core pool size by 1 (otherwise a single long running chore whose execution is    * longer than its period would be able to spawn too many threads).    */
specifier|private
specifier|final
name|HashMap
argument_list|<
name|ScheduledChore
argument_list|,
name|Boolean
argument_list|>
name|choresMissingStartTime
decl_stmt|;
comment|/**    * The coreThreadPoolPrefix is the prefix that will be applied to all threads within the    * ScheduledThreadPoolExecutor. The prefix is typically related to the Server that the service is    * running on. The prefix is useful because it allows us to monitor how the thread pool of a    * particular service changes over time VIA thread dumps.    */
specifier|private
specifier|final
name|String
name|coreThreadPoolPrefix
decl_stmt|;
comment|/**    *    * @param coreThreadPoolPrefix Prefix that will be applied to the Thread name of all threads    *          spawned by this service    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|VisibleForTesting
specifier|public
name|ChoreService
parameter_list|(
specifier|final
name|String
name|coreThreadPoolPrefix
parameter_list|)
block|{
name|this
argument_list|(
name|coreThreadPoolPrefix
argument_list|,
name|MIN_CORE_POOL_SIZE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param coreThreadPoolPrefix Prefix that will be applied to the Thread name of all threads    *          spawned by this service    * @param jitter Should chore service add some jitter for all of the scheduled chores. When set    *               to true this will add -10% to 10% jitter.    */
specifier|public
name|ChoreService
parameter_list|(
specifier|final
name|String
name|coreThreadPoolPrefix
parameter_list|,
specifier|final
name|boolean
name|jitter
parameter_list|)
block|{
name|this
argument_list|(
name|coreThreadPoolPrefix
argument_list|,
name|MIN_CORE_POOL_SIZE
argument_list|,
name|jitter
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param coreThreadPoolPrefix Prefix that will be applied to the Thread name of all threads    *          spawned by this service    * @param corePoolSize The initial size to set the core pool of the ScheduledThreadPoolExecutor    *          to during initialization. The default size is 1, but specifying a larger size may be    *          beneficial if you know that 1 thread will not be enough.    * @param jitter Should chore service add some jitter for all of the scheduled chores. When set    *               to true this will add -10% to 10% jitter.    */
specifier|public
name|ChoreService
parameter_list|(
specifier|final
name|String
name|coreThreadPoolPrefix
parameter_list|,
name|int
name|corePoolSize
parameter_list|,
name|boolean
name|jitter
parameter_list|)
block|{
name|this
operator|.
name|coreThreadPoolPrefix
operator|=
name|coreThreadPoolPrefix
expr_stmt|;
if|if
condition|(
name|corePoolSize
operator|<
name|MIN_CORE_POOL_SIZE
condition|)
block|{
name|corePoolSize
operator|=
name|MIN_CORE_POOL_SIZE
expr_stmt|;
block|}
specifier|final
name|ThreadFactory
name|threadFactory
init|=
operator|new
name|ChoreServiceThreadFactory
argument_list|(
name|coreThreadPoolPrefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|jitter
condition|)
block|{
name|scheduler
operator|=
operator|new
name|JitterScheduledThreadPoolExecutorImpl
argument_list|(
name|corePoolSize
argument_list|,
name|threadFactory
argument_list|,
literal|0.1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scheduler
operator|=
operator|new
name|ScheduledThreadPoolExecutor
argument_list|(
name|corePoolSize
argument_list|,
name|threadFactory
argument_list|)
expr_stmt|;
block|}
name|scheduler
operator|.
name|setRemoveOnCancelPolicy
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|scheduledChores
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|choresMissingStartTime
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
comment|/**    * @param chore Chore to be scheduled. If the chore is already scheduled with another ChoreService    *          instance, that schedule will be cancelled (i.e. a Chore can only ever be scheduled    *          with a single ChoreService instance).    * @return true when the chore was successfully scheduled. false when the scheduling failed    *         (typically occurs when a chore is scheduled during shutdown of service)    */
specifier|public
specifier|synchronized
name|boolean
name|scheduleChore
parameter_list|(
name|ScheduledChore
name|chore
parameter_list|)
block|{
if|if
condition|(
name|chore
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
try|try
block|{
if|if
condition|(
name|chore
operator|.
name|getPeriod
argument_list|()
operator|<=
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Chore {} is disabled because its period is not positive."
argument_list|,
name|chore
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Chore {} is enabled."
argument_list|,
name|chore
argument_list|)
expr_stmt|;
name|chore
operator|.
name|setChoreServicer
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|ScheduledFuture
argument_list|<
name|?
argument_list|>
name|future
init|=
name|scheduler
operator|.
name|scheduleAtFixedRate
argument_list|(
name|chore
argument_list|,
name|chore
operator|.
name|getInitialDelay
argument_list|()
argument_list|,
name|chore
operator|.
name|getPeriod
argument_list|()
argument_list|,
name|chore
operator|.
name|getTimeUnit
argument_list|()
argument_list|)
decl_stmt|;
name|scheduledChores
operator|.
name|put
argument_list|(
name|chore
argument_list|,
name|future
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|exception
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Could not successfully schedule chore: "
operator|+
name|chore
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
comment|/**    * @param chore The Chore to be rescheduled. If the chore is not scheduled with this ChoreService    *          yet then this call is equivalent to a call to scheduleChore.    */
specifier|private
specifier|synchronized
name|void
name|rescheduleChore
parameter_list|(
name|ScheduledChore
name|chore
parameter_list|)
block|{
if|if
condition|(
name|chore
operator|==
literal|null
condition|)
return|return;
if|if
condition|(
name|scheduledChores
operator|.
name|containsKey
argument_list|(
name|chore
argument_list|)
condition|)
block|{
name|ScheduledFuture
argument_list|<
name|?
argument_list|>
name|future
init|=
name|scheduledChores
operator|.
name|get
argument_list|(
name|chore
argument_list|)
decl_stmt|;
name|future
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|scheduleChore
argument_list|(
name|chore
argument_list|)
expr_stmt|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|cancelChore
parameter_list|(
name|ScheduledChore
name|chore
parameter_list|)
block|{
name|cancelChore
argument_list|(
name|chore
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|cancelChore
parameter_list|(
name|ScheduledChore
name|chore
parameter_list|,
name|boolean
name|mayInterruptIfRunning
parameter_list|)
block|{
if|if
condition|(
name|chore
operator|!=
literal|null
operator|&&
name|scheduledChores
operator|.
name|containsKey
argument_list|(
name|chore
argument_list|)
condition|)
block|{
name|ScheduledFuture
argument_list|<
name|?
argument_list|>
name|future
init|=
name|scheduledChores
operator|.
name|get
argument_list|(
name|chore
argument_list|)
decl_stmt|;
name|future
operator|.
name|cancel
argument_list|(
name|mayInterruptIfRunning
argument_list|)
expr_stmt|;
name|scheduledChores
operator|.
name|remove
argument_list|(
name|chore
argument_list|)
expr_stmt|;
comment|// Removing a chore that was missing its start time means it may be possible
comment|// to reduce the number of threads
if|if
condition|(
name|choresMissingStartTime
operator|.
name|containsKey
argument_list|(
name|chore
argument_list|)
condition|)
block|{
name|choresMissingStartTime
operator|.
name|remove
argument_list|(
name|chore
argument_list|)
expr_stmt|;
name|requestCorePoolDecrease
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|Override
specifier|public
specifier|synchronized
name|boolean
name|isChoreScheduled
parameter_list|(
name|ScheduledChore
name|chore
parameter_list|)
block|{
return|return
name|chore
operator|!=
literal|null
operator|&&
name|scheduledChores
operator|.
name|containsKey
argument_list|(
name|chore
argument_list|)
operator|&&
operator|!
name|scheduledChores
operator|.
name|get
argument_list|(
name|chore
argument_list|)
operator|.
name|isDone
argument_list|()
return|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|Override
specifier|public
specifier|synchronized
name|boolean
name|triggerNow
parameter_list|(
name|ScheduledChore
name|chore
parameter_list|)
block|{
if|if
condition|(
name|chore
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
name|rescheduleChore
argument_list|(
name|chore
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|/**    * @return number of chores that this service currently has scheduled    */
name|int
name|getNumberOfScheduledChores
parameter_list|()
block|{
return|return
name|scheduledChores
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * @return number of chores that this service currently has scheduled that are missing their    *         scheduled start time    */
name|int
name|getNumberOfChoresMissingStartTime
parameter_list|()
block|{
return|return
name|choresMissingStartTime
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * @return number of threads in the core pool of the underlying ScheduledThreadPoolExecutor    */
name|int
name|getCorePoolSize
parameter_list|()
block|{
return|return
name|scheduler
operator|.
name|getCorePoolSize
argument_list|()
return|;
block|}
comment|/**    * Custom ThreadFactory used with the ScheduledThreadPoolExecutor so that all the threads are    * daemon threads, and thus, don't prevent the JVM from shutting down    */
specifier|static
class|class
name|ChoreServiceThreadFactory
implements|implements
name|ThreadFactory
block|{
specifier|private
specifier|final
name|String
name|threadPrefix
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|String
name|THREAD_NAME_SUFFIX
init|=
literal|".Chore."
decl_stmt|;
specifier|private
name|AtomicInteger
name|threadNumber
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|/**      * @param threadPrefix The prefix given to all threads created by this factory      */
specifier|public
name|ChoreServiceThreadFactory
parameter_list|(
specifier|final
name|String
name|threadPrefix
parameter_list|)
block|{
name|this
operator|.
name|threadPrefix
operator|=
name|threadPrefix
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Thread
name|newThread
parameter_list|(
name|Runnable
name|r
parameter_list|)
block|{
name|Thread
name|thread
init|=
operator|new
name|Thread
argument_list|(
name|r
argument_list|,
name|threadPrefix
operator|+
name|THREAD_NAME_SUFFIX
operator|+
name|threadNumber
operator|.
name|getAndIncrement
argument_list|()
argument_list|)
decl_stmt|;
name|thread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|thread
return|;
block|}
block|}
comment|/**    * Represents a request to increase the number of core pool threads. Typically a request    * originates from the fact that the current core pool size is not sufficient to service all of    * the currently running Chores    * @return true when the request to increase the core pool size succeeds    */
specifier|private
specifier|synchronized
name|boolean
name|requestCorePoolIncrease
parameter_list|()
block|{
comment|// There is no point in creating more threads than scheduledChores.size since scheduled runs
comment|// of the same chore cannot run concurrently (i.e. happen-before behavior is enforced
comment|// amongst occurrences of the same chore).
if|if
condition|(
name|scheduler
operator|.
name|getCorePoolSize
argument_list|()
operator|<
name|scheduledChores
operator|.
name|size
argument_list|()
condition|)
block|{
name|scheduler
operator|.
name|setCorePoolSize
argument_list|(
name|scheduler
operator|.
name|getCorePoolSize
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|printChoreServiceDetails
argument_list|(
literal|"requestCorePoolIncrease"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Represents a request to decrease the number of core pool threads. Typically a request    * originates from the fact that the current core pool size is more than sufficient to service the    * running Chores.    */
specifier|private
specifier|synchronized
name|void
name|requestCorePoolDecrease
parameter_list|()
block|{
if|if
condition|(
name|scheduler
operator|.
name|getCorePoolSize
argument_list|()
operator|>
name|MIN_CORE_POOL_SIZE
condition|)
block|{
name|scheduler
operator|.
name|setCorePoolSize
argument_list|(
name|scheduler
operator|.
name|getCorePoolSize
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printChoreServiceDetails
argument_list|(
literal|"requestCorePoolDecrease"
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|onChoreMissedStartTime
parameter_list|(
name|ScheduledChore
name|chore
parameter_list|)
block|{
if|if
condition|(
name|chore
operator|==
literal|null
operator|||
operator|!
name|scheduledChores
operator|.
name|containsKey
argument_list|(
name|chore
argument_list|)
condition|)
return|return;
comment|// If the chore has not caused an increase in the size of the core thread pool then request an
comment|// increase. This allows each chore missing its start time to increase the core pool size by
comment|// at most 1.
if|if
condition|(
operator|!
name|choresMissingStartTime
operator|.
name|containsKey
argument_list|(
name|chore
argument_list|)
operator|||
operator|!
name|choresMissingStartTime
operator|.
name|get
argument_list|(
name|chore
argument_list|)
condition|)
block|{
name|choresMissingStartTime
operator|.
name|put
argument_list|(
name|chore
argument_list|,
name|requestCorePoolIncrease
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Must reschedule the chore to prevent unnecessary delays of chores in the scheduler. If
comment|// the chore is NOT rescheduled, future executions of this chore will be delayed more and
comment|// more on each iteration. This hurts us because the ScheduledThreadPoolExecutor allocates
comment|// idle threads to chores based on how delayed they are.
name|rescheduleChore
argument_list|(
name|chore
argument_list|)
expr_stmt|;
name|printChoreDetails
argument_list|(
literal|"onChoreMissedStartTime"
argument_list|,
name|chore
argument_list|)
expr_stmt|;
block|}
comment|/**    * shutdown the service. Any chores that are scheduled for execution will be cancelled. Any chores    * in the middle of execution will be interrupted and shutdown. This service will be unusable    * after this method has been called (i.e. future scheduling attempts will fail).    */
specifier|public
specifier|synchronized
name|void
name|shutdown
parameter_list|()
block|{
name|scheduler
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Chore service for: "
operator|+
name|coreThreadPoolPrefix
operator|+
literal|" had "
operator|+
name|scheduledChores
operator|.
name|keySet
argument_list|()
operator|+
literal|" on shutdown"
argument_list|)
expr_stmt|;
block|}
name|cancelAllChores
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|scheduledChores
operator|.
name|clear
argument_list|()
expr_stmt|;
name|choresMissingStartTime
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * @return true when the service is shutdown and thus cannot be used anymore    */
specifier|public
name|boolean
name|isShutdown
parameter_list|()
block|{
return|return
name|scheduler
operator|.
name|isShutdown
argument_list|()
return|;
block|}
comment|/**    * @return true when the service is shutdown and all threads have terminated    */
specifier|public
name|boolean
name|isTerminated
parameter_list|()
block|{
return|return
name|scheduler
operator|.
name|isTerminated
argument_list|()
return|;
block|}
specifier|private
name|void
name|cancelAllChores
parameter_list|(
specifier|final
name|boolean
name|mayInterruptIfRunning
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|ScheduledChore
argument_list|>
name|choresToCancel
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|scheduledChores
operator|.
name|keySet
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// Build list of chores to cancel so we can iterate through a set that won't change
comment|// as chores are cancelled. If we tried to cancel each chore while iterating through
comment|// keySet the results would be undefined because the keySet would be changing
for|for
control|(
name|ScheduledChore
name|chore
range|:
name|scheduledChores
operator|.
name|keySet
argument_list|()
control|)
block|{
name|choresToCancel
operator|.
name|add
argument_list|(
name|chore
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ScheduledChore
name|chore
range|:
name|choresToCancel
control|)
block|{
name|cancelChore
argument_list|(
name|chore
argument_list|,
name|mayInterruptIfRunning
argument_list|)
expr_stmt|;
block|}
name|choresToCancel
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * Prints a summary of important details about the chore. Used for debugging purposes    */
specifier|private
name|void
name|printChoreDetails
parameter_list|(
specifier|final
name|String
name|header
parameter_list|,
name|ScheduledChore
name|chore
parameter_list|)
block|{
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|output
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|output
operator|.
name|put
argument_list|(
name|header
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|output
operator|.
name|put
argument_list|(
literal|"Chore name: "
argument_list|,
name|chore
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|output
operator|.
name|put
argument_list|(
literal|"Chore period: "
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|chore
operator|.
name|getPeriod
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|.
name|put
argument_list|(
literal|"Chore timeBetweenRuns: "
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|chore
operator|.
name|getTimeBetweenRuns
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|output
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|trace
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|+
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Prints a summary of important details about the service. Used for debugging purposes    */
specifier|private
name|void
name|printChoreServiceDetails
parameter_list|(
specifier|final
name|String
name|header
parameter_list|)
block|{
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|output
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|output
operator|.
name|put
argument_list|(
name|header
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|output
operator|.
name|put
argument_list|(
literal|"ChoreService corePoolSize: "
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|getCorePoolSize
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|.
name|put
argument_list|(
literal|"ChoreService scheduledChores: "
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|getNumberOfScheduledChores
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|.
name|put
argument_list|(
literal|"ChoreService missingStartTimeCount: "
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|getNumberOfChoresMissingStartTime
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|output
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|trace
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|+
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

