begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|util
operator|.
name|StreamUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ByteBufferUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|IterableUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|SimpleMutableByteRange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableUtils
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  * static convenience methods for dealing with KeyValues and collections of KeyValues  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|KeyValueUtil
block|{
comment|/**************** length *********************/
comment|/**    * Returns number of bytes this cell would have been used if serialized as in {@link KeyValue}    * @param cell    * @return the length    */
specifier|public
specifier|static
name|int
name|length
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
return|return
name|length
argument_list|(
name|cell
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|cell
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|cell
operator|.
name|getQualifierLength
argument_list|()
argument_list|,
name|cell
operator|.
name|getValueLength
argument_list|()
argument_list|,
name|cell
operator|.
name|getTagsLength
argument_list|()
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|int
name|length
parameter_list|(
name|short
name|rlen
parameter_list|,
name|byte
name|flen
parameter_list|,
name|int
name|qlen
parameter_list|,
name|int
name|vlen
parameter_list|,
name|int
name|tlen
parameter_list|,
name|boolean
name|withTags
parameter_list|)
block|{
if|if
condition|(
name|withTags
condition|)
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|KeyValue
operator|.
name|getKeyValueDataStructureSize
argument_list|(
name|rlen
argument_list|,
name|flen
argument_list|,
name|qlen
argument_list|,
name|vlen
argument_list|,
name|tlen
argument_list|)
argument_list|)
return|;
block|}
return|return
call|(
name|int
call|)
argument_list|(
name|KeyValue
operator|.
name|getKeyValueDataStructureSize
argument_list|(
name|rlen
argument_list|,
name|flen
argument_list|,
name|qlen
argument_list|,
name|vlen
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns number of bytes this cell's key part would have been used if serialized as in    * {@link KeyValue}. Key includes rowkey, family, qualifier, timestamp and type.    * @param cell    * @return the key length    */
specifier|public
specifier|static
name|int
name|keyLength
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
return|return
name|keyLength
argument_list|(
name|cell
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|cell
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|cell
operator|.
name|getQualifierLength
argument_list|()
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|int
name|keyLength
parameter_list|(
name|short
name|rlen
parameter_list|,
name|byte
name|flen
parameter_list|,
name|int
name|qlen
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|KeyValue
operator|.
name|getKeyDataStructureSize
argument_list|(
name|rlen
argument_list|,
name|flen
argument_list|,
name|qlen
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|int
name|lengthWithMvccVersion
parameter_list|(
specifier|final
name|KeyValue
name|kv
parameter_list|,
specifier|final
name|boolean
name|includeMvccVersion
parameter_list|)
block|{
name|int
name|length
init|=
name|kv
operator|.
name|getLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|includeMvccVersion
condition|)
block|{
name|length
operator|+=
name|WritableUtils
operator|.
name|getVIntSize
argument_list|(
name|kv
operator|.
name|getMvccVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|length
return|;
block|}
specifier|public
specifier|static
name|int
name|totalLengthWithMvccVersion
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|?
extends|extends
name|KeyValue
argument_list|>
name|kvs
parameter_list|,
specifier|final
name|boolean
name|includeMvccVersion
parameter_list|)
block|{
name|int
name|length
init|=
literal|0
decl_stmt|;
for|for
control|(
name|KeyValue
name|kv
range|:
name|IterableUtils
operator|.
name|nullSafe
argument_list|(
name|kvs
argument_list|)
control|)
block|{
name|length
operator|+=
name|lengthWithMvccVersion
argument_list|(
name|kv
argument_list|,
name|includeMvccVersion
argument_list|)
expr_stmt|;
block|}
return|return
name|length
return|;
block|}
comment|/**************** copy key only *********************/
specifier|public
specifier|static
name|KeyValue
name|copyToNewKeyValue
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
name|byte
index|[]
name|bytes
init|=
name|copyToNewByteArray
argument_list|(
name|cell
argument_list|)
decl_stmt|;
name|KeyValue
name|kvCell
init|=
operator|new
name|KeyValue
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
decl_stmt|;
name|kvCell
operator|.
name|setSequenceId
argument_list|(
name|cell
operator|.
name|getMvccVersion
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|kvCell
return|;
block|}
specifier|public
specifier|static
name|ByteBuffer
name|copyKeyToNewByteBuffer
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|keyLength
argument_list|(
name|cell
argument_list|)
index|]
decl_stmt|;
name|appendKeyTo
argument_list|(
name|cell
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ByteBuffer
name|buffer
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
name|buffer
operator|.
name|position
argument_list|(
name|buffer
operator|.
name|limit
argument_list|()
argument_list|)
expr_stmt|;
comment|//make it look as if each field were appended
return|return
name|buffer
return|;
block|}
specifier|public
specifier|static
name|byte
index|[]
name|copyToNewByteArray
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
name|int
name|v1Length
init|=
name|length
argument_list|(
name|cell
argument_list|)
decl_stmt|;
name|byte
index|[]
name|backingBytes
init|=
operator|new
name|byte
index|[
name|v1Length
index|]
decl_stmt|;
name|appendToByteArray
argument_list|(
name|cell
argument_list|,
name|backingBytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|backingBytes
return|;
block|}
specifier|public
specifier|static
name|int
name|appendKeyTo
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|,
specifier|final
name|byte
index|[]
name|output
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|)
block|{
name|int
name|nextOffset
init|=
name|offset
decl_stmt|;
name|nextOffset
operator|=
name|Bytes
operator|.
name|putShort
argument_list|(
name|output
argument_list|,
name|nextOffset
argument_list|,
name|cell
operator|.
name|getRowLength
argument_list|()
argument_list|)
expr_stmt|;
name|nextOffset
operator|=
name|CellUtil
operator|.
name|copyRowTo
argument_list|(
name|cell
argument_list|,
name|output
argument_list|,
name|nextOffset
argument_list|)
expr_stmt|;
name|nextOffset
operator|=
name|Bytes
operator|.
name|putByte
argument_list|(
name|output
argument_list|,
name|nextOffset
argument_list|,
name|cell
operator|.
name|getFamilyLength
argument_list|()
argument_list|)
expr_stmt|;
name|nextOffset
operator|=
name|CellUtil
operator|.
name|copyFamilyTo
argument_list|(
name|cell
argument_list|,
name|output
argument_list|,
name|nextOffset
argument_list|)
expr_stmt|;
name|nextOffset
operator|=
name|CellUtil
operator|.
name|copyQualifierTo
argument_list|(
name|cell
argument_list|,
name|output
argument_list|,
name|nextOffset
argument_list|)
expr_stmt|;
name|nextOffset
operator|=
name|Bytes
operator|.
name|putLong
argument_list|(
name|output
argument_list|,
name|nextOffset
argument_list|,
name|cell
operator|.
name|getTimestamp
argument_list|()
argument_list|)
expr_stmt|;
name|nextOffset
operator|=
name|Bytes
operator|.
name|putByte
argument_list|(
name|output
argument_list|,
name|nextOffset
argument_list|,
name|cell
operator|.
name|getTypeByte
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|nextOffset
return|;
block|}
comment|/**************** copy key and value *********************/
specifier|public
specifier|static
name|int
name|appendToByteArray
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|,
specifier|final
name|byte
index|[]
name|output
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|)
block|{
comment|// TODO when cell instance of KV we can bypass all steps and just do backing single array
comment|// copy(?)
name|int
name|pos
init|=
name|offset
decl_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putInt
argument_list|(
name|output
argument_list|,
name|pos
argument_list|,
name|keyLength
argument_list|(
name|cell
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putInt
argument_list|(
name|output
argument_list|,
name|pos
argument_list|,
name|cell
operator|.
name|getValueLength
argument_list|()
argument_list|)
expr_stmt|;
name|pos
operator|=
name|appendKeyTo
argument_list|(
name|cell
argument_list|,
name|output
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|=
name|CellUtil
operator|.
name|copyValueTo
argument_list|(
name|cell
argument_list|,
name|output
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cell
operator|.
name|getTagsLength
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
name|pos
operator|=
name|Bytes
operator|.
name|putAsShort
argument_list|(
name|output
argument_list|,
name|pos
argument_list|,
name|cell
operator|.
name|getTagsLength
argument_list|()
argument_list|)
expr_stmt|;
name|pos
operator|=
name|CellUtil
operator|.
name|copyTagTo
argument_list|(
name|cell
argument_list|,
name|output
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
return|return
name|pos
return|;
block|}
specifier|public
specifier|static
name|ByteBuffer
name|copyToNewByteBuffer
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|length
argument_list|(
name|cell
argument_list|)
index|]
decl_stmt|;
name|appendToByteArray
argument_list|(
name|cell
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ByteBuffer
name|buffer
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
name|buffer
operator|.
name|position
argument_list|(
name|buffer
operator|.
name|limit
argument_list|()
argument_list|)
expr_stmt|;
comment|//make it look as if each field were appended
return|return
name|buffer
return|;
block|}
specifier|public
specifier|static
name|void
name|appendToByteBuffer
parameter_list|(
specifier|final
name|ByteBuffer
name|bb
parameter_list|,
specifier|final
name|KeyValue
name|kv
parameter_list|,
specifier|final
name|boolean
name|includeMvccVersion
parameter_list|)
block|{
comment|// keep pushing the limit out. assume enough capacity
name|bb
operator|.
name|limit
argument_list|(
name|bb
operator|.
name|position
argument_list|()
operator|+
name|kv
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|bb
operator|.
name|put
argument_list|(
name|kv
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|kv
operator|.
name|getOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|includeMvccVersion
condition|)
block|{
name|int
name|numMvccVersionBytes
init|=
name|WritableUtils
operator|.
name|getVIntSize
argument_list|(
name|kv
operator|.
name|getMvccVersion
argument_list|()
argument_list|)
decl_stmt|;
name|ByteBufferUtils
operator|.
name|extendLimit
argument_list|(
name|bb
argument_list|,
name|numMvccVersionBytes
argument_list|)
expr_stmt|;
name|ByteBufferUtils
operator|.
name|writeVLong
argument_list|(
name|bb
argument_list|,
name|kv
operator|.
name|getMvccVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**************** iterating *******************************/
comment|/**    * Creates a new KeyValue object positioned in the supplied ByteBuffer and sets the ByteBuffer's    * position to the start of the next KeyValue. Does not allocate a new array or copy data.    * @param bb    * @param includesMvccVersion    * @param includesTags     */
specifier|public
specifier|static
name|KeyValue
name|nextShallowCopy
parameter_list|(
specifier|final
name|ByteBuffer
name|bb
parameter_list|,
specifier|final
name|boolean
name|includesMvccVersion
parameter_list|,
name|boolean
name|includesTags
parameter_list|)
block|{
if|if
condition|(
name|bb
operator|.
name|isDirect
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"only supports heap buffers"
argument_list|)
throw|;
block|}
if|if
condition|(
name|bb
operator|.
name|remaining
argument_list|()
operator|<
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
name|KeyValue
name|keyValue
init|=
literal|null
decl_stmt|;
name|int
name|underlyingArrayOffset
init|=
name|bb
operator|.
name|arrayOffset
argument_list|()
operator|+
name|bb
operator|.
name|position
argument_list|()
decl_stmt|;
name|int
name|keyLength
init|=
name|bb
operator|.
name|getInt
argument_list|()
decl_stmt|;
name|int
name|valueLength
init|=
name|bb
operator|.
name|getInt
argument_list|()
decl_stmt|;
name|ByteBufferUtils
operator|.
name|skip
argument_list|(
name|bb
argument_list|,
name|keyLength
operator|+
name|valueLength
argument_list|)
expr_stmt|;
name|int
name|tagsLength
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|includesTags
condition|)
block|{
comment|// Read short as unsigned, high byte first
name|tagsLength
operator|=
operator|(
operator|(
name|bb
operator|.
name|get
argument_list|()
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator|^
operator|(
name|bb
operator|.
name|get
argument_list|()
operator|&
literal|0xff
operator|)
expr_stmt|;
name|ByteBufferUtils
operator|.
name|skip
argument_list|(
name|bb
argument_list|,
name|tagsLength
argument_list|)
expr_stmt|;
block|}
name|int
name|kvLength
init|=
operator|(
name|int
operator|)
name|KeyValue
operator|.
name|getKeyValueDataStructureSize
argument_list|(
name|keyLength
argument_list|,
name|valueLength
argument_list|,
name|tagsLength
argument_list|)
decl_stmt|;
name|keyValue
operator|=
operator|new
name|KeyValue
argument_list|(
name|bb
operator|.
name|array
argument_list|()
argument_list|,
name|underlyingArrayOffset
argument_list|,
name|kvLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|includesMvccVersion
condition|)
block|{
name|long
name|mvccVersion
init|=
name|ByteBufferUtils
operator|.
name|readVLong
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|keyValue
operator|.
name|setSequenceId
argument_list|(
name|mvccVersion
argument_list|)
expr_stmt|;
block|}
return|return
name|keyValue
return|;
block|}
comment|/*************** next/previous **********************************/
comment|/**    * Append single byte 0x00 to the end of the input row key    */
specifier|public
specifier|static
name|KeyValue
name|createFirstKeyInNextRow
parameter_list|(
specifier|final
name|Cell
name|in
parameter_list|)
block|{
name|byte
index|[]
name|nextRow
init|=
operator|new
name|byte
index|[
name|in
operator|.
name|getRowLength
argument_list|()
operator|+
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|in
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|in
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|nextRow
argument_list|,
literal|0
argument_list|,
name|in
operator|.
name|getRowLength
argument_list|()
argument_list|)
expr_stmt|;
name|nextRow
index|[
name|nextRow
operator|.
name|length
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|//maybe not necessary
return|return
name|createFirstOnRow
argument_list|(
name|nextRow
argument_list|)
return|;
block|}
comment|/**    * Increment the row bytes and clear the other fields    */
specifier|public
specifier|static
name|KeyValue
name|createFirstKeyInIncrementedRow
parameter_list|(
specifier|final
name|Cell
name|in
parameter_list|)
block|{
name|byte
index|[]
name|thisRow
init|=
operator|new
name|SimpleMutableByteRange
argument_list|(
name|in
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|in
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|in
operator|.
name|getRowLength
argument_list|()
argument_list|)
operator|.
name|deepCopyToNewArray
argument_list|()
decl_stmt|;
name|byte
index|[]
name|nextRow
init|=
name|Bytes
operator|.
name|unsignedCopyAndIncrement
argument_list|(
name|thisRow
argument_list|)
decl_stmt|;
return|return
name|createFirstOnRow
argument_list|(
name|nextRow
argument_list|)
return|;
block|}
comment|/**    * Decrement the timestamp.  For tests (currently wasteful)    *    * Remember timestamps are sorted reverse chronologically.    * @param in    * @return previous key    */
specifier|public
specifier|static
name|KeyValue
name|previousKey
parameter_list|(
specifier|final
name|KeyValue
name|in
parameter_list|)
block|{
return|return
name|createFirstOnRow
argument_list|(
name|CellUtil
operator|.
name|cloneRow
argument_list|(
name|in
argument_list|)
argument_list|,
name|CellUtil
operator|.
name|cloneFamily
argument_list|(
name|in
argument_list|)
argument_list|,
name|CellUtil
operator|.
name|cloneQualifier
argument_list|(
name|in
argument_list|)
argument_list|,
name|in
operator|.
name|getTimestamp
argument_list|()
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/**    * Create a KeyValue for the specified row, family and qualifier that would be    * larger than or equal to all other possible KeyValues that have the same    * row, family, qualifier. Used for reseeking.    *    * @param row    *          row key    * @param roffset    *         row offset    * @param rlength    *         row length    * @param family    *         family name    * @param foffset    *         family offset    * @param flength    *         family length    * @param qualifier    *        column qualifier    * @param qoffset    *        qualifier offset    * @param qlength    *        qualifier length    * @return Last possible key on passed row, family, qualifier.    */
specifier|public
specifier|static
name|KeyValue
name|createLastOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|int
name|roffset
parameter_list|,
specifier|final
name|int
name|rlength
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|int
name|foffset
parameter_list|,
specifier|final
name|int
name|flength
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|int
name|qoffset
parameter_list|,
specifier|final
name|int
name|qlength
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|,
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|,
name|HConstants
operator|.
name|OLDEST_TIMESTAMP
argument_list|,
name|Type
operator|.
name|Minimum
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Creates a keyValue for the specified keyvalue larger than or equal to all other possible    * KeyValues that have the same row, family, qualifer.  Used for reseeking    * @param kv    * @return KeyValue    */
specifier|public
specifier|static
name|KeyValue
name|createLastOnRow
parameter_list|(
name|Cell
name|kv
parameter_list|)
block|{
return|return
name|createLastOnRow
argument_list|(
name|kv
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|kv
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getRowLength
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Similar to    * {@link #createLastOnRow(byte[], int, int, byte[], int, int, byte[], int, int)}    * but creates the last key on the row/column of this KV (the value part of    * the returned KV is always empty). Used in creating "fake keys" for the    * multi-column Bloom filter optimization to skip the row/column we already    * know is not in the file.    *     * @param kv - cell    * @return the last key on the row/column of the given key-value pair    */
specifier|public
specifier|static
name|KeyValue
name|createLastOnRowCol
parameter_list|(
name|Cell
name|kv
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|kv
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|kv
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|kv
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|kv
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|kv
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|kv
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getQualifierLength
argument_list|()
argument_list|,
name|HConstants
operator|.
name|OLDEST_TIMESTAMP
argument_list|,
name|Type
operator|.
name|Minimum
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Creates the first KV with the row/family/qualifier of this KV and the given    * timestamp. Uses the "maximum" KV type that guarantees that the new KV is    * the lowest possible for this combination of row, family, qualifier, and    * timestamp. This KV's own timestamp is ignored. While this function copies    * the value from this KV, it is normally used on key-only KVs.    *     * @param kv - cell    * @param ts    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRowColTS
parameter_list|(
name|Cell
name|kv
parameter_list|,
name|long
name|ts
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|kv
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|kv
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|kv
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|kv
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|kv
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|kv
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getQualifierLength
argument_list|()
argument_list|,
name|ts
argument_list|,
name|Type
operator|.
name|Maximum
argument_list|,
name|kv
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|kv
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getValueLength
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Create a KeyValue that is smaller than all other possible KeyValues    * for the given row. That is any (valid) KeyValue on 'row' would sort    * _after_ the result.    *    * @param row - row key (arbitrary byte array)    * @return First possible KeyValue on passed<code>row</code>    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
name|int
name|roffset
parameter_list|,
name|short
name|rlength
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|,
name|Type
operator|.
name|Maximum
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Creates a KeyValue that is last on the specified row id. That is,    * every other possible KeyValue for the given row would compareTo()    * less than the result of this call.    * @param row row key    * @return Last possible KeyValue on passed<code>row</code>    */
specifier|public
specifier|static
name|KeyValue
name|createLastOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|,
name|Type
operator|.
name|Minimum
argument_list|)
return|;
block|}
comment|/**    * Create a KeyValue that is smaller than all other possible KeyValues    * for the given row. That is any (valid) KeyValue on 'row' would sort    * _after_ the result.    *    * @param row - row key (arbitrary byte array)    * @return First possible KeyValue on passed<code>row</code>    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|)
block|{
return|return
name|createFirstOnRow
argument_list|(
name|row
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|)
return|;
block|}
comment|/**    * Creates a KeyValue that is smaller than all other KeyValues that    * are older than the passed timestamp.    * @param row - row key (arbitrary byte array)    * @param ts - timestamp    * @return First possible key on passed<code>row</code> and timestamp.    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|long
name|ts
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|ts
argument_list|,
name|Type
operator|.
name|Maximum
argument_list|)
return|;
block|}
comment|/**    * Create a KeyValue for the specified row, family and qualifier that would be    * smaller than all other possible KeyValues that have the same row,family,qualifier.    * Used for seeking.    * @param row - row key (arbitrary byte array)    * @param family - family name    * @param qualifier - column qualifier    * @return First possible key on passed<code>row</code>, and column.    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|,
name|Type
operator|.
name|Maximum
argument_list|)
return|;
block|}
comment|/**    * Create a Delete Family KeyValue for the specified row and family that would    * be smaller than all other possible Delete Family KeyValues that have the    * same row and family.    * Used for seeking.    * @param row - row key (arbitrary byte array)    * @param family - family name    * @return First Delete Family possible key on passed<code>row</code>.    */
specifier|public
specifier|static
name|KeyValue
name|createFirstDeleteFamilyOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
literal|null
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|,
name|Type
operator|.
name|DeleteFamily
argument_list|)
return|;
block|}
comment|/**    * @param row - row key (arbitrary byte array)    * @param f - family name    * @param q - column qualifier    * @param ts - timestamp    * @return First possible key on passed<code>row</code>, column and timestamp    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|f
parameter_list|,
specifier|final
name|byte
index|[]
name|q
parameter_list|,
specifier|final
name|long
name|ts
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
name|f
argument_list|,
name|q
argument_list|,
name|ts
argument_list|,
name|Type
operator|.
name|Maximum
argument_list|)
return|;
block|}
comment|/**    * Create a KeyValue for the specified row, family and qualifier that would be    * smaller than all other possible KeyValues that have the same row,    * family, qualifier.    * Used for seeking.    * @param row row key    * @param roffset row offset    * @param rlength row length    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    * @return First possible key on passed Row, Family, Qualifier.    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|int
name|roffset
parameter_list|,
specifier|final
name|int
name|rlength
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|int
name|foffset
parameter_list|,
specifier|final
name|int
name|flength
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|int
name|qoffset
parameter_list|,
specifier|final
name|int
name|qlength
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|,
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|,
name|Type
operator|.
name|Maximum
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Create a KeyValue for the specified row, family and qualifier that would be    * smaller than all other possible KeyValues that have the same row,    * family, qualifier.    * Used for seeking.    *    * @param buffer the buffer to use for the new<code>KeyValue</code> object    * @param row the value key    * @param family family name    * @param qualifier column qualifier    *    * @return First possible key on passed Row, Family, Qualifier.    *    * @throws IllegalArgumentException The resulting<code>KeyValue</code> object would be larger    * than the provided buffer or than<code>Integer.MAX_VALUE</code>    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRow
parameter_list|(
name|byte
index|[]
name|buffer
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
return|return
name|createFirstOnRow
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|row
argument_list|,
literal|0
argument_list|,
name|row
operator|.
name|length
argument_list|,
name|family
argument_list|,
literal|0
argument_list|,
name|family
operator|.
name|length
argument_list|,
name|qualifier
argument_list|,
literal|0
argument_list|,
name|qualifier
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * Create a KeyValue for the specified row, family and qualifier that would be    * smaller than all other possible KeyValues that have the same row,    * family, qualifier.    * Used for seeking.    *    * @param buffer the buffer to use for the new<code>KeyValue</code> object    * @param boffset buffer offset    * @param row the value key    * @param roffset row offset    * @param rlength row length    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    *    * @return First possible key on passed Row, Family, Qualifier.    *    * @throws IllegalArgumentException The resulting<code>KeyValue</code> object would be larger    * than the provided buffer or than<code>Integer.MAX_VALUE</code>    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRow
parameter_list|(
name|byte
index|[]
name|buffer
parameter_list|,
specifier|final
name|int
name|boffset
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|int
name|roffset
parameter_list|,
specifier|final
name|int
name|rlength
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|int
name|foffset
parameter_list|,
specifier|final
name|int
name|flength
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|int
name|qoffset
parameter_list|,
specifier|final
name|int
name|qlength
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|long
name|lLength
init|=
name|KeyValue
operator|.
name|getKeyValueDataStructureSize
argument_list|(
name|rlength
argument_list|,
name|flength
argument_list|,
name|qlength
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|lLength
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"KeyValue length "
operator|+
name|lLength
operator|+
literal|"> "
operator|+
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
throw|;
block|}
name|int
name|iLength
init|=
operator|(
name|int
operator|)
name|lLength
decl_stmt|;
if|if
condition|(
name|buffer
operator|.
name|length
operator|-
name|boffset
operator|<
name|iLength
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Buffer size "
operator|+
operator|(
name|buffer
operator|.
name|length
operator|-
name|boffset
operator|)
operator|+
literal|"< "
operator|+
name|iLength
argument_list|)
throw|;
block|}
name|int
name|len
init|=
name|KeyValue
operator|.
name|writeByteArray
argument_list|(
name|buffer
argument_list|,
name|boffset
argument_list|,
name|row
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|,
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|,
name|KeyValue
operator|.
name|Type
operator|.
name|Maximum
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
operator|new
name|KeyValue
argument_list|(
name|buffer
argument_list|,
name|boffset
argument_list|,
name|len
argument_list|)
return|;
block|}
comment|/**    * Creates the first KV with the row/family/qualifier of this KV and the    * given timestamp. Uses the "maximum" KV type that guarantees that the new    * KV is the lowest possible for this combination of row, family, qualifier,    * and timestamp. This KV's own timestamp is ignored. While this function    * copies the value from this KV, it is normally used on key-only KVs.    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRowColTS
parameter_list|(
name|KeyValue
name|kv
parameter_list|,
name|long
name|ts
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|kv
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|kv
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|kv
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|kv
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|kv
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|kv
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getQualifierLength
argument_list|()
argument_list|,
name|ts
argument_list|,
name|Type
operator|.
name|Maximum
argument_list|,
name|kv
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|kv
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getValueLength
argument_list|()
argument_list|)
return|;
block|}
comment|/*************** misc **********************************/
comment|/**    * @param cell    * @return<code>cell<code> if it is an instance of {@link KeyValue} else we will return a    * new {@link KeyValue} instance made from<code>cell</code>    * @deprecated without any replacement.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|KeyValue
name|ensureKeyValue
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
if|if
condition|(
name|cell
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|cell
operator|instanceof
name|KeyValue
condition|?
operator|(
name|KeyValue
operator|)
name|cell
else|:
name|copyToNewKeyValue
argument_list|(
name|cell
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
specifier|public
specifier|static
name|List
argument_list|<
name|KeyValue
argument_list|>
name|ensureKeyValues
parameter_list|(
name|List
argument_list|<
name|Cell
argument_list|>
name|cells
parameter_list|)
block|{
name|List
argument_list|<
name|KeyValue
argument_list|>
name|lazyList
init|=
name|Lists
operator|.
name|transform
argument_list|(
name|cells
argument_list|,
operator|new
name|Function
argument_list|<
name|Cell
argument_list|,
name|KeyValue
argument_list|>
argument_list|()
block|{
specifier|public
name|KeyValue
name|apply
parameter_list|(
name|Cell
name|arg0
parameter_list|)
block|{
return|return
name|KeyValueUtil
operator|.
name|ensureKeyValue
argument_list|(
name|arg0
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
return|return
operator|new
name|ArrayList
argument_list|<
name|KeyValue
argument_list|>
argument_list|(
name|lazyList
argument_list|)
return|;
block|}
comment|/**    * Write out a KeyValue in the manner in which we used to when KeyValue was a    * Writable.    *    * @param kv    * @param out    * @return Length written on stream    * @throws IOException    * @see #create(DataInput) for the inverse function    */
specifier|public
specifier|static
name|long
name|write
parameter_list|(
specifier|final
name|KeyValue
name|kv
parameter_list|,
specifier|final
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
comment|// This is how the old Writables write used to serialize KVs. Need to figure
comment|// way to make it
comment|// work for all implementations.
name|int
name|length
init|=
name|kv
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|kv
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|kv
operator|.
name|getOffset
argument_list|()
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|length
operator|+
name|Bytes
operator|.
name|SIZEOF_INT
return|;
block|}
comment|/**    * Create a KeyValue reading from the raw InputStream. Named    *<code>iscreate</code> so doesn't clash with {@link #create(DataInput)}    *    * @param in    * @return Created KeyValue OR if we find a length of zero, we will return    *         null which can be useful marking a stream as done.    * @throws IOException    */
specifier|public
specifier|static
name|KeyValue
name|iscreate
parameter_list|(
specifier|final
name|InputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|intBytes
init|=
operator|new
name|byte
index|[
name|Bytes
operator|.
name|SIZEOF_INT
index|]
decl_stmt|;
name|int
name|bytesRead
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|bytesRead
operator|<
name|intBytes
operator|.
name|length
condition|)
block|{
name|int
name|n
init|=
name|in
operator|.
name|read
argument_list|(
name|intBytes
argument_list|,
name|bytesRead
argument_list|,
name|intBytes
operator|.
name|length
operator|-
name|bytesRead
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|bytesRead
operator|==
literal|0
condition|)
return|return
literal|null
return|;
comment|// EOF at start is ok
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed read of int, read "
operator|+
name|bytesRead
operator|+
literal|" bytes"
argument_list|)
throw|;
block|}
name|bytesRead
operator|+=
name|n
expr_stmt|;
block|}
comment|// TODO: perhaps some sanity check is needed here.
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|Bytes
operator|.
name|toInt
argument_list|(
name|intBytes
argument_list|)
index|]
decl_stmt|;
name|IOUtils
operator|.
name|readFully
argument_list|(
name|in
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
operator|new
name|KeyValue
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * @param b    * @return A KeyValue made of a byte array that holds the key-only part.    *         Needed to convert hfile index members to KeyValues.    */
specifier|public
specifier|static
name|KeyValue
name|createKeyValueFromKey
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|)
block|{
return|return
name|createKeyValueFromKey
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * @param bb    * @return A KeyValue made of a byte buffer that holds the key-only part.    *         Needed to convert hfile index members to KeyValues.    */
specifier|public
specifier|static
name|KeyValue
name|createKeyValueFromKey
parameter_list|(
specifier|final
name|ByteBuffer
name|bb
parameter_list|)
block|{
return|return
name|createKeyValueFromKey
argument_list|(
name|bb
operator|.
name|array
argument_list|()
argument_list|,
name|bb
operator|.
name|arrayOffset
argument_list|()
argument_list|,
name|bb
operator|.
name|limit
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @param b    * @param o    * @param l    * @return A KeyValue made of a byte array that holds the key-only part.    *         Needed to convert hfile index members to KeyValues.    */
specifier|public
specifier|static
name|KeyValue
name|createKeyValueFromKey
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|,
specifier|final
name|int
name|o
parameter_list|,
specifier|final
name|int
name|l
parameter_list|)
block|{
name|byte
index|[]
name|newb
init|=
operator|new
name|byte
index|[
name|l
operator|+
name|KeyValue
operator|.
name|ROW_OFFSET
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|b
argument_list|,
name|o
argument_list|,
name|newb
argument_list|,
name|KeyValue
operator|.
name|ROW_OFFSET
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|Bytes
operator|.
name|putInt
argument_list|(
name|newb
argument_list|,
literal|0
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|Bytes
operator|.
name|putInt
argument_list|(
name|newb
argument_list|,
name|Bytes
operator|.
name|SIZEOF_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|new
name|KeyValue
argument_list|(
name|newb
argument_list|)
return|;
block|}
comment|/**    * @param in    *          Where to read bytes from. Creates a byte array to hold the    *          KeyValue backing bytes copied from the steam.    * @return KeyValue created by deserializing from<code>in</code> OR if we    *         find a length of zero, we will return null which can be useful    *         marking a stream as done.    * @throws IOException    */
specifier|public
specifier|static
name|KeyValue
name|create
parameter_list|(
specifier|final
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|create
argument_list|(
name|in
operator|.
name|readInt
argument_list|()
argument_list|,
name|in
argument_list|)
return|;
block|}
comment|/**    * Create a KeyValue reading<code>length</code> from<code>in</code>    *     * @param length    * @param in    * @return Created KeyValue OR if we find a length of zero, we will return    *         null which can be useful marking a stream as done.    * @throws IOException    */
specifier|public
specifier|static
name|KeyValue
name|create
parameter_list|(
name|int
name|length
parameter_list|,
specifier|final
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|length
operator|==
literal|0
condition|)
return|return
literal|null
return|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed read "
operator|+
name|length
operator|+
literal|" bytes, stream corrupt?"
argument_list|)
throw|;
block|}
comment|// This is how the old Writables.readFrom used to deserialize. Didn't even
comment|// vint.
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|length
index|]
decl_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
return|return
operator|new
name|KeyValue
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|void
name|oswrite
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|,
specifier|final
name|OutputStream
name|out
parameter_list|,
specifier|final
name|boolean
name|withTags
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|cell
operator|instanceof
name|KeyValue
condition|)
block|{
name|KeyValue
operator|.
name|oswrite
argument_list|(
operator|(
name|KeyValue
operator|)
name|cell
argument_list|,
name|out
argument_list|,
name|withTags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|short
name|rlen
init|=
name|cell
operator|.
name|getRowLength
argument_list|()
decl_stmt|;
name|byte
name|flen
init|=
name|cell
operator|.
name|getFamilyLength
argument_list|()
decl_stmt|;
name|int
name|qlen
init|=
name|cell
operator|.
name|getQualifierLength
argument_list|()
decl_stmt|;
name|int
name|vlen
init|=
name|cell
operator|.
name|getValueLength
argument_list|()
decl_stmt|;
name|int
name|tlen
init|=
name|cell
operator|.
name|getTagsLength
argument_list|()
decl_stmt|;
comment|// write total length
name|StreamUtils
operator|.
name|writeInt
argument_list|(
name|out
argument_list|,
name|length
argument_list|(
name|rlen
argument_list|,
name|flen
argument_list|,
name|qlen
argument_list|,
name|vlen
argument_list|,
name|tlen
argument_list|,
name|withTags
argument_list|)
argument_list|)
expr_stmt|;
comment|// write key length
name|StreamUtils
operator|.
name|writeInt
argument_list|(
name|out
argument_list|,
name|keyLength
argument_list|(
name|rlen
argument_list|,
name|flen
argument_list|,
name|qlen
argument_list|)
argument_list|)
expr_stmt|;
comment|// write value length
name|StreamUtils
operator|.
name|writeInt
argument_list|(
name|out
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
comment|// Write rowkey - 2 bytes rk length followed by rowkey bytes
name|StreamUtils
operator|.
name|writeShort
argument_list|(
name|out
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|cell
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
comment|// Write cf - 1 byte of cf length followed by the family bytes
name|out
operator|.
name|write
argument_list|(
name|flen
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|cell
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|flen
argument_list|)
expr_stmt|;
comment|// write qualifier
name|out
operator|.
name|write
argument_list|(
name|cell
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|qlen
argument_list|)
expr_stmt|;
comment|// write timestamp
name|StreamUtils
operator|.
name|writeLong
argument_list|(
name|out
argument_list|,
name|cell
operator|.
name|getTimestamp
argument_list|()
argument_list|)
expr_stmt|;
comment|// write the type
name|out
operator|.
name|write
argument_list|(
name|cell
operator|.
name|getTypeByte
argument_list|()
argument_list|)
expr_stmt|;
comment|// write value
name|out
operator|.
name|write
argument_list|(
name|cell
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
comment|// write tags if we have to
if|if
condition|(
name|withTags
operator|&&
name|tlen
operator|>
literal|0
condition|)
block|{
comment|// 2 bytes tags length followed by tags bytes
comment|// tags length is serialized with 2 bytes only(short way) even if the
comment|// type is int. As this
comment|// is non -ve numbers, we save the sign bit. See HBASE-11437
name|out
operator|.
name|write
argument_list|(
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
name|tlen
operator|>>
literal|8
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
name|tlen
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|cell
operator|.
name|getTagsArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getTagsOffset
argument_list|()
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

