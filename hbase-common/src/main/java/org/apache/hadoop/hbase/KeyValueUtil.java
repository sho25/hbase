begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
package|;
end_package

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ByteBufferUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ByteRange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|IterableUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableUtils
import|;
end_import

begin_comment
comment|/**  * static convenience methods for dealing with KeyValues and collections of KeyValues  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|KeyValueUtil
block|{
comment|/**************** length *********************/
specifier|public
specifier|static
name|int
name|length
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|KeyValue
operator|.
name|getKeyValueDataStructureSize
argument_list|(
name|cell
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|cell
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|cell
operator|.
name|getQualifierLength
argument_list|()
argument_list|,
name|cell
operator|.
name|getValueLength
argument_list|()
argument_list|)
return|;
block|}
specifier|protected
specifier|static
name|int
name|keyLength
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|KeyValue
operator|.
name|getKeyDataStructureSize
argument_list|(
name|cell
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|cell
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|cell
operator|.
name|getQualifierLength
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|int
name|lengthWithMvccVersion
parameter_list|(
specifier|final
name|KeyValue
name|kv
parameter_list|,
specifier|final
name|boolean
name|includeMvccVersion
parameter_list|)
block|{
name|int
name|length
init|=
name|kv
operator|.
name|getLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|includeMvccVersion
condition|)
block|{
name|length
operator|+=
name|WritableUtils
operator|.
name|getVIntSize
argument_list|(
name|kv
operator|.
name|getMvccVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|length
return|;
block|}
specifier|public
specifier|static
name|int
name|totalLengthWithMvccVersion
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|?
extends|extends
name|KeyValue
argument_list|>
name|kvs
parameter_list|,
specifier|final
name|boolean
name|includeMvccVersion
parameter_list|)
block|{
name|int
name|length
init|=
literal|0
decl_stmt|;
for|for
control|(
name|KeyValue
name|kv
range|:
name|IterableUtils
operator|.
name|nullSafe
argument_list|(
name|kvs
argument_list|)
control|)
block|{
name|length
operator|+=
name|lengthWithMvccVersion
argument_list|(
name|kv
argument_list|,
name|includeMvccVersion
argument_list|)
expr_stmt|;
block|}
return|return
name|length
return|;
block|}
comment|/**************** copy key only *********************/
specifier|public
specifier|static
name|KeyValue
name|copyToNewKeyValue
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
name|KeyValue
name|kvCell
init|=
operator|new
name|KeyValue
argument_list|(
name|copyToNewByteArray
argument_list|(
name|cell
argument_list|)
argument_list|)
decl_stmt|;
name|kvCell
operator|.
name|setMvccVersion
argument_list|(
name|cell
operator|.
name|getMvccVersion
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|kvCell
return|;
block|}
specifier|public
specifier|static
name|ByteBuffer
name|copyKeyToNewByteBuffer
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|keyLength
argument_list|(
name|cell
argument_list|)
index|]
decl_stmt|;
name|appendKeyToByteArrayWithoutValue
argument_list|(
name|cell
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ByteBuffer
name|buffer
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
name|buffer
operator|.
name|position
argument_list|(
name|buffer
operator|.
name|limit
argument_list|()
argument_list|)
expr_stmt|;
comment|//make it look as if each field were appended
return|return
name|buffer
return|;
block|}
specifier|public
specifier|static
name|byte
index|[]
name|copyToNewByteArray
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
name|int
name|v1Length
init|=
name|length
argument_list|(
name|cell
argument_list|)
decl_stmt|;
name|byte
index|[]
name|backingBytes
init|=
operator|new
name|byte
index|[
name|v1Length
index|]
decl_stmt|;
name|appendToByteArray
argument_list|(
name|cell
argument_list|,
name|backingBytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|backingBytes
return|;
block|}
specifier|protected
specifier|static
name|int
name|appendKeyToByteArrayWithoutValue
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|,
specifier|final
name|byte
index|[]
name|output
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|)
block|{
name|int
name|nextOffset
init|=
name|offset
decl_stmt|;
name|nextOffset
operator|=
name|Bytes
operator|.
name|putShort
argument_list|(
name|output
argument_list|,
name|nextOffset
argument_list|,
name|cell
operator|.
name|getRowLength
argument_list|()
argument_list|)
expr_stmt|;
name|nextOffset
operator|=
name|CellUtil
operator|.
name|copyRowTo
argument_list|(
name|cell
argument_list|,
name|output
argument_list|,
name|nextOffset
argument_list|)
expr_stmt|;
name|nextOffset
operator|=
name|Bytes
operator|.
name|putByte
argument_list|(
name|output
argument_list|,
name|nextOffset
argument_list|,
name|cell
operator|.
name|getFamilyLength
argument_list|()
argument_list|)
expr_stmt|;
name|nextOffset
operator|=
name|CellUtil
operator|.
name|copyFamilyTo
argument_list|(
name|cell
argument_list|,
name|output
argument_list|,
name|nextOffset
argument_list|)
expr_stmt|;
name|nextOffset
operator|=
name|CellUtil
operator|.
name|copyQualifierTo
argument_list|(
name|cell
argument_list|,
name|output
argument_list|,
name|nextOffset
argument_list|)
expr_stmt|;
name|nextOffset
operator|=
name|Bytes
operator|.
name|putLong
argument_list|(
name|output
argument_list|,
name|nextOffset
argument_list|,
name|cell
operator|.
name|getTimestamp
argument_list|()
argument_list|)
expr_stmt|;
name|nextOffset
operator|=
name|Bytes
operator|.
name|putByte
argument_list|(
name|output
argument_list|,
name|nextOffset
argument_list|,
name|cell
operator|.
name|getTypeByte
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|nextOffset
return|;
block|}
comment|/**************** copy key and value *********************/
specifier|public
specifier|static
name|int
name|appendToByteArray
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|,
specifier|final
name|byte
index|[]
name|output
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|)
block|{
name|int
name|pos
init|=
name|offset
decl_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putInt
argument_list|(
name|output
argument_list|,
name|pos
argument_list|,
name|keyLength
argument_list|(
name|cell
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putInt
argument_list|(
name|output
argument_list|,
name|pos
argument_list|,
name|cell
operator|.
name|getValueLength
argument_list|()
argument_list|)
expr_stmt|;
name|pos
operator|=
name|appendKeyToByteArrayWithoutValue
argument_list|(
name|cell
argument_list|,
name|output
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|CellUtil
operator|.
name|copyValueTo
argument_list|(
name|cell
argument_list|,
name|output
argument_list|,
name|pos
argument_list|)
expr_stmt|;
return|return
name|pos
operator|+
name|cell
operator|.
name|getValueLength
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|ByteBuffer
name|copyToNewByteBuffer
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|length
argument_list|(
name|cell
argument_list|)
index|]
decl_stmt|;
name|appendToByteArray
argument_list|(
name|cell
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ByteBuffer
name|buffer
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
name|buffer
operator|.
name|position
argument_list|(
name|buffer
operator|.
name|limit
argument_list|()
argument_list|)
expr_stmt|;
comment|//make it look as if each field were appended
return|return
name|buffer
return|;
block|}
specifier|public
specifier|static
name|void
name|appendToByteBuffer
parameter_list|(
specifier|final
name|ByteBuffer
name|bb
parameter_list|,
specifier|final
name|KeyValue
name|kv
parameter_list|,
specifier|final
name|boolean
name|includeMvccVersion
parameter_list|)
block|{
comment|// keep pushing the limit out. assume enough capacity
name|bb
operator|.
name|limit
argument_list|(
name|bb
operator|.
name|position
argument_list|()
operator|+
name|kv
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|bb
operator|.
name|put
argument_list|(
name|kv
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|kv
operator|.
name|getOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|includeMvccVersion
condition|)
block|{
name|int
name|numMvccVersionBytes
init|=
name|WritableUtils
operator|.
name|getVIntSize
argument_list|(
name|kv
operator|.
name|getMvccVersion
argument_list|()
argument_list|)
decl_stmt|;
name|ByteBufferUtils
operator|.
name|extendLimit
argument_list|(
name|bb
argument_list|,
name|numMvccVersionBytes
argument_list|)
expr_stmt|;
name|ByteBufferUtils
operator|.
name|writeVLong
argument_list|(
name|bb
argument_list|,
name|kv
operator|.
name|getMvccVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**************** iterating *******************************/
comment|/**    * Creates a new KeyValue object positioned in the supplied ByteBuffer and sets the ByteBuffer's    * position to the start of the next KeyValue. Does not allocate a new array or copy data.    */
specifier|public
specifier|static
name|KeyValue
name|nextShallowCopy
parameter_list|(
specifier|final
name|ByteBuffer
name|bb
parameter_list|,
specifier|final
name|boolean
name|includesMvccVersion
parameter_list|)
block|{
if|if
condition|(
name|bb
operator|.
name|isDirect
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"only supports heap buffers"
argument_list|)
throw|;
block|}
if|if
condition|(
name|bb
operator|.
name|remaining
argument_list|()
operator|<
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|underlyingArrayOffset
init|=
name|bb
operator|.
name|arrayOffset
argument_list|()
operator|+
name|bb
operator|.
name|position
argument_list|()
decl_stmt|;
name|int
name|keyLength
init|=
name|bb
operator|.
name|getInt
argument_list|()
decl_stmt|;
name|int
name|valueLength
init|=
name|bb
operator|.
name|getInt
argument_list|()
decl_stmt|;
name|int
name|kvLength
init|=
name|KeyValue
operator|.
name|KEYVALUE_INFRASTRUCTURE_SIZE
operator|+
name|keyLength
operator|+
name|valueLength
decl_stmt|;
name|KeyValue
name|keyValue
init|=
operator|new
name|KeyValue
argument_list|(
name|bb
operator|.
name|array
argument_list|()
argument_list|,
name|underlyingArrayOffset
argument_list|,
name|kvLength
argument_list|)
decl_stmt|;
name|ByteBufferUtils
operator|.
name|skip
argument_list|(
name|bb
argument_list|,
name|keyLength
operator|+
name|valueLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|includesMvccVersion
condition|)
block|{
name|long
name|mvccVersion
init|=
name|ByteBufferUtils
operator|.
name|readVLong
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|keyValue
operator|.
name|setMvccVersion
argument_list|(
name|mvccVersion
argument_list|)
expr_stmt|;
block|}
return|return
name|keyValue
return|;
block|}
comment|/*************** next/previous **********************************/
comment|/**    * Append single byte 0x00 to the end of the input row key    */
specifier|public
specifier|static
name|KeyValue
name|createFirstKeyInNextRow
parameter_list|(
specifier|final
name|Cell
name|in
parameter_list|)
block|{
name|byte
index|[]
name|nextRow
init|=
operator|new
name|byte
index|[
name|in
operator|.
name|getRowLength
argument_list|()
operator|+
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|in
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|in
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|nextRow
argument_list|,
literal|0
argument_list|,
name|in
operator|.
name|getRowLength
argument_list|()
argument_list|)
expr_stmt|;
name|nextRow
index|[
name|nextRow
operator|.
name|length
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|//maybe not necessary
return|return
name|KeyValue
operator|.
name|createFirstOnRow
argument_list|(
name|nextRow
argument_list|)
return|;
block|}
comment|/**    * Increment the row bytes and clear the other fields    */
specifier|public
specifier|static
name|KeyValue
name|createFirstKeyInIncrementedRow
parameter_list|(
specifier|final
name|Cell
name|in
parameter_list|)
block|{
name|byte
index|[]
name|thisRow
init|=
operator|new
name|ByteRange
argument_list|(
name|in
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|in
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|in
operator|.
name|getRowLength
argument_list|()
argument_list|)
operator|.
name|deepCopyToNewArray
argument_list|()
decl_stmt|;
name|byte
index|[]
name|nextRow
init|=
name|Bytes
operator|.
name|unsignedCopyAndIncrement
argument_list|(
name|thisRow
argument_list|)
decl_stmt|;
return|return
name|KeyValue
operator|.
name|createFirstOnRow
argument_list|(
name|nextRow
argument_list|)
return|;
block|}
comment|/**    * Decrement the timestamp.  For tests (currently wasteful)    *    * Remember timestamps are sorted reverse chronologically.    * @param in    * @return previous key    */
specifier|public
specifier|static
name|KeyValue
name|previousKey
parameter_list|(
specifier|final
name|KeyValue
name|in
parameter_list|)
block|{
return|return
name|KeyValue
operator|.
name|createFirstOnRow
argument_list|(
name|CellUtil
operator|.
name|getRowArray
argument_list|(
name|in
argument_list|)
argument_list|,
name|CellUtil
operator|.
name|getFamilyArray
argument_list|(
name|in
argument_list|)
argument_list|,
name|CellUtil
operator|.
name|getQualifierArray
argument_list|(
name|in
argument_list|)
argument_list|,
name|in
operator|.
name|getTimestamp
argument_list|()
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/*************** misc **********************************/
comment|/**    * @param cell    * @return<code>cell<code> if it is an instance of {@link KeyValue} else we will return a    * new {@link KeyValue} instance made from<code>cell</code>    */
specifier|public
specifier|static
name|KeyValue
name|ensureKeyValue
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
if|if
condition|(
name|cell
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|cell
operator|instanceof
name|KeyValue
condition|?
operator|(
name|KeyValue
operator|)
name|cell
else|:
name|copyToNewKeyValue
argument_list|(
name|cell
argument_list|)
return|;
block|}
block|}
end_class

end_unit

