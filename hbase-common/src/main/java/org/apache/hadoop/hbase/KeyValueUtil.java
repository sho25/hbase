begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|util
operator|.
name|StreamUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ByteBufferUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|collections4
operator|.
name|IterableUtils
import|;
end_import

begin_comment
comment|/**  * static convenience methods for dealing with KeyValues and collections of KeyValues  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|KeyValueUtil
block|{
comment|/**************** length *********************/
specifier|public
specifier|static
name|int
name|length
parameter_list|(
name|short
name|rlen
parameter_list|,
name|byte
name|flen
parameter_list|,
name|int
name|qlen
parameter_list|,
name|int
name|vlen
parameter_list|,
name|int
name|tlen
parameter_list|,
name|boolean
name|withTags
parameter_list|)
block|{
if|if
condition|(
name|withTags
condition|)
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|KeyValue
operator|.
name|getKeyValueDataStructureSize
argument_list|(
name|rlen
argument_list|,
name|flen
argument_list|,
name|qlen
argument_list|,
name|vlen
argument_list|,
name|tlen
argument_list|)
argument_list|)
return|;
block|}
return|return
call|(
name|int
call|)
argument_list|(
name|KeyValue
operator|.
name|getKeyValueDataStructureSize
argument_list|(
name|rlen
argument_list|,
name|flen
argument_list|,
name|qlen
argument_list|,
name|vlen
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns number of bytes this cell's key part would have been used if serialized as in    * {@link KeyValue}. Key includes rowkey, family, qualifier, timestamp and type.    * @param cell    * @return the key length    */
specifier|public
specifier|static
name|int
name|keyLength
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
return|return
name|keyLength
argument_list|(
name|cell
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|cell
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|cell
operator|.
name|getQualifierLength
argument_list|()
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|int
name|keyLength
parameter_list|(
name|short
name|rlen
parameter_list|,
name|byte
name|flen
parameter_list|,
name|int
name|qlen
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|KeyValue
operator|.
name|getKeyDataStructureSize
argument_list|(
name|rlen
argument_list|,
name|flen
argument_list|,
name|qlen
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|int
name|lengthWithMvccVersion
parameter_list|(
specifier|final
name|KeyValue
name|kv
parameter_list|,
specifier|final
name|boolean
name|includeMvccVersion
parameter_list|)
block|{
name|int
name|length
init|=
name|kv
operator|.
name|getLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|includeMvccVersion
condition|)
block|{
name|length
operator|+=
name|WritableUtils
operator|.
name|getVIntSize
argument_list|(
name|kv
operator|.
name|getSequenceId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|length
return|;
block|}
specifier|public
specifier|static
name|int
name|totalLengthWithMvccVersion
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|?
extends|extends
name|KeyValue
argument_list|>
name|kvs
parameter_list|,
specifier|final
name|boolean
name|includeMvccVersion
parameter_list|)
block|{
name|int
name|length
init|=
literal|0
decl_stmt|;
for|for
control|(
name|KeyValue
name|kv
range|:
name|IterableUtils
operator|.
name|emptyIfNull
argument_list|(
name|kvs
argument_list|)
control|)
block|{
name|length
operator|+=
name|lengthWithMvccVersion
argument_list|(
name|kv
argument_list|,
name|includeMvccVersion
argument_list|)
expr_stmt|;
block|}
return|return
name|length
return|;
block|}
comment|/**************** copy the cell to create a new keyvalue *********************/
specifier|public
specifier|static
name|KeyValue
name|copyToNewKeyValue
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
name|byte
index|[]
name|bytes
init|=
name|copyToNewByteArray
argument_list|(
name|cell
argument_list|)
decl_stmt|;
name|KeyValue
name|kvCell
init|=
operator|new
name|KeyValue
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
decl_stmt|;
name|kvCell
operator|.
name|setSequenceId
argument_list|(
name|cell
operator|.
name|getSequenceId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|kvCell
return|;
block|}
comment|/**    * The position will be set to the beginning of the new ByteBuffer    * @param cell    * @return the Bytebuffer containing the key part of the cell    */
specifier|public
specifier|static
name|ByteBuffer
name|copyKeyToNewByteBuffer
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|keyLength
argument_list|(
name|cell
argument_list|)
index|]
decl_stmt|;
name|appendKeyTo
argument_list|(
name|cell
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ByteBuffer
name|buffer
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
return|return
name|buffer
return|;
block|}
comment|/**    * Copies the key to a new KeyValue    * @param cell    * @return the KeyValue that consists only the key part of the incoming cell    */
specifier|public
specifier|static
name|KeyValue
name|toNewKeyCell
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|keyLength
argument_list|(
name|cell
argument_list|)
index|]
decl_stmt|;
name|appendKeyTo
argument_list|(
name|cell
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KeyValue
name|kv
init|=
operator|new
name|KeyValue
operator|.
name|KeyOnlyKeyValue
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
decl_stmt|;
comment|// Set the seq id. The new key cell could be used in comparisons so it
comment|// is important that it uses the seqid also. If not the comparsion would fail
name|kv
operator|.
name|setSequenceId
argument_list|(
name|cell
operator|.
name|getSequenceId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|kv
return|;
block|}
specifier|public
specifier|static
name|byte
index|[]
name|copyToNewByteArray
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
name|int
name|v1Length
init|=
name|cell
operator|.
name|getSerializedSize
argument_list|()
decl_stmt|;
name|byte
index|[]
name|backingBytes
init|=
operator|new
name|byte
index|[
name|v1Length
index|]
decl_stmt|;
name|appendToByteArray
argument_list|(
name|cell
argument_list|,
name|backingBytes
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|backingBytes
return|;
block|}
specifier|public
specifier|static
name|int
name|appendKeyTo
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|,
specifier|final
name|byte
index|[]
name|output
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|)
block|{
name|int
name|nextOffset
init|=
name|offset
decl_stmt|;
name|nextOffset
operator|=
name|Bytes
operator|.
name|putShort
argument_list|(
name|output
argument_list|,
name|nextOffset
argument_list|,
name|cell
operator|.
name|getRowLength
argument_list|()
argument_list|)
expr_stmt|;
name|nextOffset
operator|=
name|CellUtil
operator|.
name|copyRowTo
argument_list|(
name|cell
argument_list|,
name|output
argument_list|,
name|nextOffset
argument_list|)
expr_stmt|;
name|nextOffset
operator|=
name|Bytes
operator|.
name|putByte
argument_list|(
name|output
argument_list|,
name|nextOffset
argument_list|,
name|cell
operator|.
name|getFamilyLength
argument_list|()
argument_list|)
expr_stmt|;
name|nextOffset
operator|=
name|CellUtil
operator|.
name|copyFamilyTo
argument_list|(
name|cell
argument_list|,
name|output
argument_list|,
name|nextOffset
argument_list|)
expr_stmt|;
name|nextOffset
operator|=
name|CellUtil
operator|.
name|copyQualifierTo
argument_list|(
name|cell
argument_list|,
name|output
argument_list|,
name|nextOffset
argument_list|)
expr_stmt|;
name|nextOffset
operator|=
name|Bytes
operator|.
name|putLong
argument_list|(
name|output
argument_list|,
name|nextOffset
argument_list|,
name|cell
operator|.
name|getTimestamp
argument_list|()
argument_list|)
expr_stmt|;
name|nextOffset
operator|=
name|Bytes
operator|.
name|putByte
argument_list|(
name|output
argument_list|,
name|nextOffset
argument_list|,
name|cell
operator|.
name|getTypeByte
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|nextOffset
return|;
block|}
comment|/**************** copy key and value *********************/
specifier|public
specifier|static
name|int
name|appendToByteArray
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|byte
index|[]
name|output
parameter_list|,
name|int
name|offset
parameter_list|,
name|boolean
name|withTags
parameter_list|)
block|{
name|int
name|pos
init|=
name|offset
decl_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putInt
argument_list|(
name|output
argument_list|,
name|pos
argument_list|,
name|keyLength
argument_list|(
name|cell
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putInt
argument_list|(
name|output
argument_list|,
name|pos
argument_list|,
name|cell
operator|.
name|getValueLength
argument_list|()
argument_list|)
expr_stmt|;
name|pos
operator|=
name|appendKeyTo
argument_list|(
name|cell
argument_list|,
name|output
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|=
name|CellUtil
operator|.
name|copyValueTo
argument_list|(
name|cell
argument_list|,
name|output
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|withTags
operator|&&
operator|(
name|cell
operator|.
name|getTagsLength
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
name|pos
operator|=
name|Bytes
operator|.
name|putAsShort
argument_list|(
name|output
argument_list|,
name|pos
argument_list|,
name|cell
operator|.
name|getTagsLength
argument_list|()
argument_list|)
expr_stmt|;
name|pos
operator|=
name|PrivateCellUtil
operator|.
name|copyTagsTo
argument_list|(
name|cell
argument_list|,
name|output
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
return|return
name|pos
return|;
block|}
comment|/**    * Copy the Cell content into the passed buf in KeyValue serialization format.    */
specifier|public
specifier|static
name|int
name|appendTo
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|ByteBuffer
name|buf
parameter_list|,
name|int
name|offset
parameter_list|,
name|boolean
name|withTags
parameter_list|)
block|{
name|offset
operator|=
name|ByteBufferUtils
operator|.
name|putInt
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|keyLength
argument_list|(
name|cell
argument_list|)
argument_list|)
expr_stmt|;
comment|// Key length
name|offset
operator|=
name|ByteBufferUtils
operator|.
name|putInt
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|cell
operator|.
name|getValueLength
argument_list|()
argument_list|)
expr_stmt|;
comment|// Value length
name|offset
operator|=
name|appendKeyTo
argument_list|(
name|cell
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|CellUtil
operator|.
name|copyValueTo
argument_list|(
name|cell
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|// Value bytes
name|int
name|tagsLength
init|=
name|cell
operator|.
name|getTagsLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|withTags
operator|&&
operator|(
name|tagsLength
operator|>
literal|0
operator|)
condition|)
block|{
name|offset
operator|=
name|ByteBufferUtils
operator|.
name|putAsShort
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|tagsLength
argument_list|)
expr_stmt|;
comment|// Tags length
name|offset
operator|=
name|PrivateCellUtil
operator|.
name|copyTagsTo
argument_list|(
name|cell
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|// Tags bytes
block|}
return|return
name|offset
return|;
block|}
specifier|public
specifier|static
name|int
name|appendKeyTo
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|ByteBuffer
name|buf
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|offset
operator|=
name|ByteBufferUtils
operator|.
name|putShort
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|cell
operator|.
name|getRowLength
argument_list|()
argument_list|)
expr_stmt|;
comment|// RK length
name|offset
operator|=
name|CellUtil
operator|.
name|copyRowTo
argument_list|(
name|cell
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|// Row bytes
name|offset
operator|=
name|ByteBufferUtils
operator|.
name|putByte
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|cell
operator|.
name|getFamilyLength
argument_list|()
argument_list|)
expr_stmt|;
comment|// CF length
name|offset
operator|=
name|CellUtil
operator|.
name|copyFamilyTo
argument_list|(
name|cell
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|// CF bytes
name|offset
operator|=
name|CellUtil
operator|.
name|copyQualifierTo
argument_list|(
name|cell
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|// Qualifier bytes
name|offset
operator|=
name|ByteBufferUtils
operator|.
name|putLong
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|cell
operator|.
name|getTimestamp
argument_list|()
argument_list|)
expr_stmt|;
comment|// TS
name|offset
operator|=
name|ByteBufferUtils
operator|.
name|putByte
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|cell
operator|.
name|getTypeByte
argument_list|()
argument_list|)
expr_stmt|;
comment|// Type
return|return
name|offset
return|;
block|}
specifier|public
specifier|static
name|void
name|appendToByteBuffer
parameter_list|(
specifier|final
name|ByteBuffer
name|bb
parameter_list|,
specifier|final
name|KeyValue
name|kv
parameter_list|,
specifier|final
name|boolean
name|includeMvccVersion
parameter_list|)
block|{
comment|// keep pushing the limit out. assume enough capacity
name|bb
operator|.
name|limit
argument_list|(
name|bb
operator|.
name|position
argument_list|()
operator|+
name|kv
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|bb
operator|.
name|put
argument_list|(
name|kv
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|kv
operator|.
name|getOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|includeMvccVersion
condition|)
block|{
name|int
name|numMvccVersionBytes
init|=
name|WritableUtils
operator|.
name|getVIntSize
argument_list|(
name|kv
operator|.
name|getSequenceId
argument_list|()
argument_list|)
decl_stmt|;
name|ByteBufferUtils
operator|.
name|extendLimit
argument_list|(
name|bb
argument_list|,
name|numMvccVersionBytes
argument_list|)
expr_stmt|;
name|ByteBufferUtils
operator|.
name|writeVLong
argument_list|(
name|bb
argument_list|,
name|kv
operator|.
name|getSequenceId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**************** iterating *******************************/
comment|/**    * Creates a new KeyValue object positioned in the supplied ByteBuffer and sets the ByteBuffer's    * position to the start of the next KeyValue. Does not allocate a new array or copy data.    * @param bb    * @param includesMvccVersion    * @param includesTags    */
specifier|public
specifier|static
name|KeyValue
name|nextShallowCopy
parameter_list|(
specifier|final
name|ByteBuffer
name|bb
parameter_list|,
specifier|final
name|boolean
name|includesMvccVersion
parameter_list|,
name|boolean
name|includesTags
parameter_list|)
block|{
if|if
condition|(
name|bb
operator|.
name|isDirect
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"only supports heap buffers"
argument_list|)
throw|;
block|}
if|if
condition|(
name|bb
operator|.
name|remaining
argument_list|()
operator|<
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
name|KeyValue
name|keyValue
init|=
literal|null
decl_stmt|;
name|int
name|underlyingArrayOffset
init|=
name|bb
operator|.
name|arrayOffset
argument_list|()
operator|+
name|bb
operator|.
name|position
argument_list|()
decl_stmt|;
name|int
name|keyLength
init|=
name|bb
operator|.
name|getInt
argument_list|()
decl_stmt|;
name|int
name|valueLength
init|=
name|bb
operator|.
name|getInt
argument_list|()
decl_stmt|;
name|ByteBufferUtils
operator|.
name|skip
argument_list|(
name|bb
argument_list|,
name|keyLength
operator|+
name|valueLength
argument_list|)
expr_stmt|;
name|int
name|tagsLength
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|includesTags
condition|)
block|{
comment|// Read short as unsigned, high byte first
name|tagsLength
operator|=
operator|(
operator|(
name|bb
operator|.
name|get
argument_list|()
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator|^
operator|(
name|bb
operator|.
name|get
argument_list|()
operator|&
literal|0xff
operator|)
expr_stmt|;
name|ByteBufferUtils
operator|.
name|skip
argument_list|(
name|bb
argument_list|,
name|tagsLength
argument_list|)
expr_stmt|;
block|}
name|int
name|kvLength
init|=
operator|(
name|int
operator|)
name|KeyValue
operator|.
name|getKeyValueDataStructureSize
argument_list|(
name|keyLength
argument_list|,
name|valueLength
argument_list|,
name|tagsLength
argument_list|)
decl_stmt|;
name|keyValue
operator|=
operator|new
name|KeyValue
argument_list|(
name|bb
operator|.
name|array
argument_list|()
argument_list|,
name|underlyingArrayOffset
argument_list|,
name|kvLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|includesMvccVersion
condition|)
block|{
name|long
name|mvccVersion
init|=
name|ByteBufferUtils
operator|.
name|readVLong
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|keyValue
operator|.
name|setSequenceId
argument_list|(
name|mvccVersion
argument_list|)
expr_stmt|;
block|}
return|return
name|keyValue
return|;
block|}
comment|/*************** next/previous **********************************/
comment|/**    * Decrement the timestamp.  For tests (currently wasteful)    *    * Remember timestamps are sorted reverse chronologically.    * @param in    * @return previous key    */
specifier|public
specifier|static
name|KeyValue
name|previousKey
parameter_list|(
specifier|final
name|KeyValue
name|in
parameter_list|)
block|{
return|return
name|createFirstOnRow
argument_list|(
name|CellUtil
operator|.
name|cloneRow
argument_list|(
name|in
argument_list|)
argument_list|,
name|CellUtil
operator|.
name|cloneFamily
argument_list|(
name|in
argument_list|)
argument_list|,
name|CellUtil
operator|.
name|cloneQualifier
argument_list|(
name|in
argument_list|)
argument_list|,
name|in
operator|.
name|getTimestamp
argument_list|()
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/**    * Create a KeyValue for the specified row, family and qualifier that would be    * larger than or equal to all other possible KeyValues that have the same    * row, family, qualifier. Used for reseeking. Should NEVER be returned to a client.    *    * @param row    *          row key    * @param roffset    *         row offset    * @param rlength    *         row length    * @param family    *         family name    * @param foffset    *         family offset    * @param flength    *         family length    * @param qualifier    *        column qualifier    * @param qoffset    *        qualifier offset    * @param qlength    *        qualifier length    * @return Last possible key on passed row, family, qualifier.    */
specifier|public
specifier|static
name|KeyValue
name|createLastOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|int
name|roffset
parameter_list|,
specifier|final
name|int
name|rlength
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|int
name|foffset
parameter_list|,
specifier|final
name|int
name|flength
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|int
name|qoffset
parameter_list|,
specifier|final
name|int
name|qlength
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|,
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|,
name|HConstants
operator|.
name|OLDEST_TIMESTAMP
argument_list|,
name|Type
operator|.
name|Minimum
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Create a KeyValue that is smaller than all other possible KeyValues    * for the given row. That is any (valid) KeyValue on 'row' would sort    * _after_ the result.    *    * @param row - row key (arbitrary byte array)    * @return First possible KeyValue on passed<code>row</code>    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
name|int
name|roffset
parameter_list|,
name|short
name|rlength
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|,
name|Type
operator|.
name|Maximum
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Creates a KeyValue that is last on the specified row id. That is,    * every other possible KeyValue for the given row would compareTo()    * less than the result of this call.    * @param row row key    * @return Last possible KeyValue on passed<code>row</code>    */
specifier|public
specifier|static
name|KeyValue
name|createLastOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|,
name|Type
operator|.
name|Minimum
argument_list|)
return|;
block|}
comment|/**    * Create a KeyValue that is smaller than all other possible KeyValues    * for the given row. That is any (valid) KeyValue on 'row' would sort    * _after_ the result.    *    * @param row - row key (arbitrary byte array)    * @return First possible KeyValue on passed<code>row</code>    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|)
block|{
return|return
name|createFirstOnRow
argument_list|(
name|row
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|)
return|;
block|}
comment|/**    * Creates a KeyValue that is smaller than all other KeyValues that    * are older than the passed timestamp.    * @param row - row key (arbitrary byte array)    * @param ts - timestamp    * @return First possible key on passed<code>row</code> and timestamp.    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|long
name|ts
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|ts
argument_list|,
name|Type
operator|.
name|Maximum
argument_list|)
return|;
block|}
comment|/**    * Create a KeyValue for the specified row, family and qualifier that would be    * smaller than all other possible KeyValues that have the same row,family,qualifier.    * Used for seeking.    * @param row - row key (arbitrary byte array)    * @param family - family name    * @param qualifier - column qualifier    * @return First possible key on passed<code>row</code>, and column.    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|,
name|Type
operator|.
name|Maximum
argument_list|)
return|;
block|}
comment|/**    * @param row - row key (arbitrary byte array)    * @param f - family name    * @param q - column qualifier    * @param ts - timestamp    * @return First possible key on passed<code>row</code>, column and timestamp    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|f
parameter_list|,
specifier|final
name|byte
index|[]
name|q
parameter_list|,
specifier|final
name|long
name|ts
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
name|f
argument_list|,
name|q
argument_list|,
name|ts
argument_list|,
name|Type
operator|.
name|Maximum
argument_list|)
return|;
block|}
comment|/**    * Create a KeyValue for the specified row, family and qualifier that would be    * smaller than all other possible KeyValues that have the same row,    * family, qualifier.    * Used for seeking.    * @param row row key    * @param roffset row offset    * @param rlength row length    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    * @return First possible key on passed Row, Family, Qualifier.    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|int
name|roffset
parameter_list|,
specifier|final
name|int
name|rlength
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|int
name|foffset
parameter_list|,
specifier|final
name|int
name|flength
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|int
name|qoffset
parameter_list|,
specifier|final
name|int
name|qlength
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|,
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|,
name|Type
operator|.
name|Maximum
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Create a KeyValue for the specified row, family and qualifier that would be    * smaller than all other possible KeyValues that have the same row,    * family, qualifier.    * Used for seeking.    *    * @param buffer the buffer to use for the new<code>KeyValue</code> object    * @param row the value key    * @param family family name    * @param qualifier column qualifier    *    * @return First possible key on passed Row, Family, Qualifier.    *    * @throws IllegalArgumentException The resulting<code>KeyValue</code> object would be larger    * than the provided buffer or than<code>Integer.MAX_VALUE</code>    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRow
parameter_list|(
name|byte
index|[]
name|buffer
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
return|return
name|createFirstOnRow
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|row
argument_list|,
literal|0
argument_list|,
name|row
operator|.
name|length
argument_list|,
name|family
argument_list|,
literal|0
argument_list|,
name|family
operator|.
name|length
argument_list|,
name|qualifier
argument_list|,
literal|0
argument_list|,
name|qualifier
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * Create a KeyValue for the specified row, family and qualifier that would be    * smaller than all other possible KeyValues that have the same row,    * family, qualifier.    * Used for seeking.    *    * @param buffer the buffer to use for the new<code>KeyValue</code> object    * @param boffset buffer offset    * @param row the value key    * @param roffset row offset    * @param rlength row length    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    *    * @return First possible key on passed Row, Family, Qualifier.    *    * @throws IllegalArgumentException The resulting<code>KeyValue</code> object would be larger    * than the provided buffer or than<code>Integer.MAX_VALUE</code>    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRow
parameter_list|(
name|byte
index|[]
name|buffer
parameter_list|,
specifier|final
name|int
name|boffset
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|int
name|roffset
parameter_list|,
specifier|final
name|int
name|rlength
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|int
name|foffset
parameter_list|,
specifier|final
name|int
name|flength
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|int
name|qoffset
parameter_list|,
specifier|final
name|int
name|qlength
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|long
name|lLength
init|=
name|KeyValue
operator|.
name|getKeyValueDataStructureSize
argument_list|(
name|rlength
argument_list|,
name|flength
argument_list|,
name|qlength
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|lLength
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"KeyValue length "
operator|+
name|lLength
operator|+
literal|"> "
operator|+
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
throw|;
block|}
name|int
name|iLength
init|=
operator|(
name|int
operator|)
name|lLength
decl_stmt|;
if|if
condition|(
name|buffer
operator|.
name|length
operator|-
name|boffset
operator|<
name|iLength
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Buffer size "
operator|+
operator|(
name|buffer
operator|.
name|length
operator|-
name|boffset
operator|)
operator|+
literal|"< "
operator|+
name|iLength
argument_list|)
throw|;
block|}
name|int
name|len
init|=
name|KeyValue
operator|.
name|writeByteArray
argument_list|(
name|buffer
argument_list|,
name|boffset
argument_list|,
name|row
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|,
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|,
name|KeyValue
operator|.
name|Type
operator|.
name|Maximum
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
operator|new
name|KeyValue
argument_list|(
name|buffer
argument_list|,
name|boffset
argument_list|,
name|len
argument_list|)
return|;
block|}
comment|/*************** misc **********************************/
comment|/**    * @param cell    * @return<code>cell</code> if it is an object of class {@link KeyValue} else we will return a    *         new {@link KeyValue} instance made from<code>cell</code> Note: Even if the cell is an    *         object of any of the subclass of {@link KeyValue}, we will create a new    *         {@link KeyValue} object wrapping same buffer. This API is used only with MR based tools    *         which expect the type to be exactly KeyValue. That is the reason for doing this way.    * @deprecated without any replacement.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|KeyValue
name|ensureKeyValue
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
if|if
condition|(
name|cell
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|cell
operator|instanceof
name|KeyValue
condition|)
block|{
if|if
condition|(
name|cell
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|KeyValue
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
operator|(
name|KeyValue
operator|)
name|cell
return|;
block|}
comment|// Cell is an Object of any of the sub classes of KeyValue. Make a new KeyValue wrapping the
comment|// same byte[]
name|KeyValue
name|kv
init|=
operator|(
name|KeyValue
operator|)
name|cell
decl_stmt|;
name|KeyValue
name|newKv
init|=
operator|new
name|KeyValue
argument_list|(
name|kv
operator|.
name|bytes
argument_list|,
name|kv
operator|.
name|offset
argument_list|,
name|kv
operator|.
name|length
argument_list|)
decl_stmt|;
name|newKv
operator|.
name|setSequenceId
argument_list|(
name|kv
operator|.
name|getSequenceId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|newKv
return|;
block|}
return|return
name|copyToNewKeyValue
argument_list|(
name|cell
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
specifier|public
specifier|static
name|List
argument_list|<
name|KeyValue
argument_list|>
name|ensureKeyValues
parameter_list|(
name|List
argument_list|<
name|Cell
argument_list|>
name|cells
parameter_list|)
block|{
name|List
argument_list|<
name|KeyValue
argument_list|>
name|lazyList
init|=
name|Lists
operator|.
name|transform
argument_list|(
name|cells
argument_list|,
operator|new
name|Function
argument_list|<
name|Cell
argument_list|,
name|KeyValue
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|KeyValue
name|apply
parameter_list|(
name|Cell
name|arg0
parameter_list|)
block|{
return|return
name|KeyValueUtil
operator|.
name|ensureKeyValue
argument_list|(
name|arg0
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|lazyList
argument_list|)
return|;
block|}
comment|/**    * Write out a KeyValue in the manner in which we used to when KeyValue was a    * Writable.    *    * @param kv    * @param out    * @return Length written on stream    * @throws IOException    * @see #create(DataInput) for the inverse function    */
specifier|public
specifier|static
name|long
name|write
parameter_list|(
specifier|final
name|KeyValue
name|kv
parameter_list|,
specifier|final
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
comment|// This is how the old Writables write used to serialize KVs. Need to figure
comment|// way to make it
comment|// work for all implementations.
name|int
name|length
init|=
name|kv
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|kv
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|kv
operator|.
name|getOffset
argument_list|()
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
name|long
operator|)
name|length
operator|+
name|Bytes
operator|.
name|SIZEOF_INT
return|;
block|}
specifier|static
name|String
name|bytesToHex
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|String
name|bufferContents
init|=
name|buf
operator|!=
literal|null
condition|?
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
else|:
literal|"<null>"
decl_stmt|;
return|return
literal|", KeyValueBytesHex="
operator|+
name|bufferContents
operator|+
literal|", offset="
operator|+
name|offset
operator|+
literal|", length="
operator|+
name|length
return|;
block|}
specifier|static
name|void
name|checkKeyValueBytes
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|withTags
parameter_list|)
block|{
if|if
condition|(
name|buf
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid to have null "
operator|+
literal|"byte array in KeyValue."
argument_list|)
throw|;
block|}
name|int
name|pos
init|=
name|offset
decl_stmt|,
name|endOffset
init|=
name|offset
operator|+
name|length
decl_stmt|;
comment|// check the key
if|if
condition|(
name|pos
operator|+
name|Bytes
operator|.
name|SIZEOF_INT
operator|>
name|endOffset
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Overflow when reading key length at position="
operator|+
name|pos
operator|+
name|bytesToHex
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|)
throw|;
block|}
name|int
name|keyLen
init|=
name|Bytes
operator|.
name|toInt
argument_list|(
name|buf
argument_list|,
name|pos
argument_list|,
name|Bytes
operator|.
name|SIZEOF_INT
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|Bytes
operator|.
name|SIZEOF_INT
expr_stmt|;
if|if
condition|(
name|keyLen
operator|<=
literal|0
operator|||
name|pos
operator|+
name|keyLen
operator|>
name|endOffset
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid key length in KeyValue. keyLength="
operator|+
name|keyLen
operator|+
name|bytesToHex
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|)
throw|;
block|}
comment|// check the value
if|if
condition|(
name|pos
operator|+
name|Bytes
operator|.
name|SIZEOF_INT
operator|>
name|endOffset
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Overflow when reading value length at position="
operator|+
name|pos
operator|+
name|bytesToHex
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|)
throw|;
block|}
name|int
name|valLen
init|=
name|Bytes
operator|.
name|toInt
argument_list|(
name|buf
argument_list|,
name|pos
argument_list|,
name|Bytes
operator|.
name|SIZEOF_INT
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|Bytes
operator|.
name|SIZEOF_INT
expr_stmt|;
if|if
condition|(
name|valLen
argument_list|<
literal|0
operator|||
name|pos
operator|+
name|valLen
argument_list|>
name|endOffset
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid value length in KeyValue, valueLength="
operator|+
name|valLen
operator|+
name|bytesToHex
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|)
throw|;
block|}
comment|// check the row
if|if
condition|(
name|pos
operator|+
name|Bytes
operator|.
name|SIZEOF_SHORT
operator|>
name|endOffset
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Overflow when reading row length at position="
operator|+
name|pos
operator|+
name|bytesToHex
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|)
throw|;
block|}
name|short
name|rowLen
init|=
name|Bytes
operator|.
name|toShort
argument_list|(
name|buf
argument_list|,
name|pos
argument_list|,
name|Bytes
operator|.
name|SIZEOF_SHORT
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|Bytes
operator|.
name|SIZEOF_SHORT
expr_stmt|;
if|if
condition|(
name|rowLen
argument_list|<
literal|0
operator|||
name|pos
operator|+
name|rowLen
argument_list|>
name|endOffset
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid row length in KeyValue, rowLength="
operator|+
name|rowLen
operator|+
name|bytesToHex
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|)
throw|;
block|}
name|pos
operator|+=
name|rowLen
expr_stmt|;
comment|// check the family
if|if
condition|(
name|pos
operator|+
name|Bytes
operator|.
name|SIZEOF_BYTE
operator|>
name|endOffset
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Overflow when reading family length at position="
operator|+
name|pos
operator|+
name|bytesToHex
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|)
throw|;
block|}
name|int
name|familyLen
init|=
name|buf
index|[
name|pos
index|]
decl_stmt|;
name|pos
operator|+=
name|Bytes
operator|.
name|SIZEOF_BYTE
expr_stmt|;
if|if
condition|(
name|familyLen
argument_list|<
literal|0
operator|||
name|pos
operator|+
name|familyLen
argument_list|>
name|endOffset
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid family length in KeyValue, familyLength="
operator|+
name|familyLen
operator|+
name|bytesToHex
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|)
throw|;
block|}
name|pos
operator|+=
name|familyLen
expr_stmt|;
comment|// check the qualifier
name|int
name|qualifierLen
init|=
name|keyLen
operator|-
name|Bytes
operator|.
name|SIZEOF_SHORT
operator|-
name|rowLen
operator|-
name|Bytes
operator|.
name|SIZEOF_BYTE
operator|-
name|familyLen
operator|-
name|Bytes
operator|.
name|SIZEOF_LONG
operator|-
name|Bytes
operator|.
name|SIZEOF_BYTE
decl_stmt|;
if|if
condition|(
name|qualifierLen
argument_list|<
literal|0
operator|||
name|pos
operator|+
name|qualifierLen
argument_list|>
name|endOffset
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid qualifier length in KeyValue, qualifierLen="
operator|+
name|qualifierLen
operator|+
name|bytesToHex
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|)
throw|;
block|}
name|pos
operator|+=
name|qualifierLen
expr_stmt|;
comment|// check the timestamp
if|if
condition|(
name|pos
operator|+
name|Bytes
operator|.
name|SIZEOF_LONG
operator|>
name|endOffset
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Overflow when reading timestamp at position="
operator|+
name|pos
operator|+
name|bytesToHex
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|)
throw|;
block|}
name|long
name|timestamp
init|=
name|Bytes
operator|.
name|toLong
argument_list|(
name|buf
argument_list|,
name|pos
argument_list|,
name|Bytes
operator|.
name|SIZEOF_LONG
argument_list|)
decl_stmt|;
if|if
condition|(
name|timestamp
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Timestamp cannot be negative, ts="
operator|+
name|timestamp
operator|+
name|bytesToHex
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|)
throw|;
block|}
name|pos
operator|+=
name|Bytes
operator|.
name|SIZEOF_LONG
expr_stmt|;
comment|// check the type
if|if
condition|(
name|pos
operator|+
name|Bytes
operator|.
name|SIZEOF_BYTE
operator|>
name|endOffset
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Overflow when reading type at position="
operator|+
name|pos
operator|+
name|bytesToHex
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|)
throw|;
block|}
name|byte
name|type
init|=
name|buf
index|[
name|pos
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|Type
operator|.
name|isValidType
argument_list|(
name|type
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid type in KeyValue, type="
operator|+
name|type
operator|+
name|bytesToHex
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|)
throw|;
block|}
name|pos
operator|+=
name|Bytes
operator|.
name|SIZEOF_BYTE
expr_stmt|;
comment|// check the value
if|if
condition|(
name|pos
operator|+
name|valLen
operator|>
name|endOffset
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Overflow when reading value part at position="
operator|+
name|pos
operator|+
name|bytesToHex
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|)
throw|;
block|}
name|pos
operator|+=
name|valLen
expr_stmt|;
comment|// check the tags
if|if
condition|(
name|withTags
condition|)
block|{
if|if
condition|(
name|pos
operator|==
name|endOffset
condition|)
block|{
comment|// withTags is true but no tag in the cell.
return|return;
block|}
if|if
condition|(
name|pos
operator|+
name|Bytes
operator|.
name|SIZEOF_SHORT
operator|>
name|endOffset
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Overflow when reading tags length at position="
operator|+
name|pos
operator|+
name|bytesToHex
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|)
throw|;
block|}
name|short
name|tagsLen
init|=
name|Bytes
operator|.
name|toShort
argument_list|(
name|buf
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|Bytes
operator|.
name|SIZEOF_SHORT
expr_stmt|;
if|if
condition|(
name|tagsLen
argument_list|<
literal|0
operator|||
name|pos
operator|+
name|tagsLen
argument_list|>
name|endOffset
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid tags length in KeyValue at position="
operator|+
operator|(
name|pos
operator|-
name|Bytes
operator|.
name|SIZEOF_SHORT
operator|)
operator|+
name|bytesToHex
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|)
throw|;
block|}
name|int
name|tagsEndOffset
init|=
name|pos
operator|+
name|tagsLen
decl_stmt|;
for|for
control|(
init|;
name|pos
operator|<
name|tagsEndOffset
condition|;
control|)
block|{
if|if
condition|(
name|pos
operator|+
name|Tag
operator|.
name|TAG_LENGTH_SIZE
operator|>
name|endOffset
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Overflow when reading tag length at position="
operator|+
name|pos
operator|+
name|bytesToHex
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|)
throw|;
block|}
name|short
name|tagLen
init|=
name|Bytes
operator|.
name|toShort
argument_list|(
name|buf
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|Tag
operator|.
name|TAG_LENGTH_SIZE
expr_stmt|;
comment|// tagLen contains one byte tag type, so must be not less than 1.
if|if
condition|(
name|tagLen
argument_list|<
literal|1
operator|||
name|pos
operator|+
name|tagLen
argument_list|>
name|endOffset
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid tag length at position="
operator|+
operator|(
name|pos
operator|-
name|Tag
operator|.
name|TAG_LENGTH_SIZE
operator|)
operator|+
literal|", tagLength="
operator|+
name|tagLen
operator|+
name|bytesToHex
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|)
throw|;
block|}
name|pos
operator|+=
name|tagLen
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pos
operator|!=
name|endOffset
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Some redundant bytes in KeyValue's buffer, startOffset="
operator|+
name|pos
operator|+
literal|", endOffset="
operator|+
name|endOffset
operator|+
name|bytesToHex
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|/**    * Create a KeyValue reading from the raw InputStream. Named    *<code>createKeyValueFromInputStream</code> so doesn't clash with {@link #create(DataInput)}    * @param in inputStream to read.    * @param withTags whether the keyvalue should include tags are not    * @return Created KeyValue OR if we find a length of zero, we will return null which can be    *         useful marking a stream as done.    * @throws IOException    */
specifier|public
specifier|static
name|KeyValue
name|createKeyValueFromInputStream
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|boolean
name|withTags
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|intBytes
init|=
operator|new
name|byte
index|[
name|Bytes
operator|.
name|SIZEOF_INT
index|]
decl_stmt|;
name|int
name|bytesRead
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|bytesRead
operator|<
name|intBytes
operator|.
name|length
condition|)
block|{
name|int
name|n
init|=
name|in
operator|.
name|read
argument_list|(
name|intBytes
argument_list|,
name|bytesRead
argument_list|,
name|intBytes
operator|.
name|length
operator|-
name|bytesRead
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|bytesRead
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|()
throw|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed read of int, read "
operator|+
name|bytesRead
operator|+
literal|" bytes"
argument_list|)
throw|;
block|}
name|bytesRead
operator|+=
name|n
expr_stmt|;
block|}
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|Bytes
operator|.
name|toInt
argument_list|(
name|intBytes
argument_list|)
index|]
decl_stmt|;
name|IOUtils
operator|.
name|readFully
argument_list|(
name|in
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|withTags
condition|?
operator|new
name|KeyValue
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
else|:
operator|new
name|NoTagsKeyValue
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * @param b    * @return A KeyValue made of a byte array that holds the key-only part.    *         Needed to convert hfile index members to KeyValues.    */
specifier|public
specifier|static
name|KeyValue
name|createKeyValueFromKey
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|)
block|{
return|return
name|createKeyValueFromKey
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * @param bb    * @return A KeyValue made of a byte buffer that holds the key-only part.    *         Needed to convert hfile index members to KeyValues.    */
specifier|public
specifier|static
name|KeyValue
name|createKeyValueFromKey
parameter_list|(
specifier|final
name|ByteBuffer
name|bb
parameter_list|)
block|{
return|return
name|createKeyValueFromKey
argument_list|(
name|bb
operator|.
name|array
argument_list|()
argument_list|,
name|bb
operator|.
name|arrayOffset
argument_list|()
argument_list|,
name|bb
operator|.
name|limit
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @param b    * @param o    * @param l    * @return A KeyValue made of a byte array that holds the key-only part.    *         Needed to convert hfile index members to KeyValues.    */
specifier|public
specifier|static
name|KeyValue
name|createKeyValueFromKey
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|,
specifier|final
name|int
name|o
parameter_list|,
specifier|final
name|int
name|l
parameter_list|)
block|{
name|byte
index|[]
name|newb
init|=
operator|new
name|byte
index|[
name|l
operator|+
name|KeyValue
operator|.
name|ROW_OFFSET
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|b
argument_list|,
name|o
argument_list|,
name|newb
argument_list|,
name|KeyValue
operator|.
name|ROW_OFFSET
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|Bytes
operator|.
name|putInt
argument_list|(
name|newb
argument_list|,
literal|0
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|Bytes
operator|.
name|putInt
argument_list|(
name|newb
argument_list|,
name|Bytes
operator|.
name|SIZEOF_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|new
name|KeyValue
argument_list|(
name|newb
argument_list|)
return|;
block|}
comment|/**    * @param in    *          Where to read bytes from. Creates a byte array to hold the    *          KeyValue backing bytes copied from the steam.    * @return KeyValue created by deserializing from<code>in</code> OR if we    *         find a length of zero, we will return null which can be useful    *         marking a stream as done.    * @throws IOException    */
specifier|public
specifier|static
name|KeyValue
name|create
parameter_list|(
specifier|final
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|create
argument_list|(
name|in
operator|.
name|readInt
argument_list|()
argument_list|,
name|in
argument_list|)
return|;
block|}
comment|/**    * Create a KeyValue reading<code>length</code> from<code>in</code>    *    * @param length    * @param in    * @return Created KeyValue OR if we find a length of zero, we will return    *         null which can be useful marking a stream as done.    * @throws IOException    */
specifier|public
specifier|static
name|KeyValue
name|create
parameter_list|(
name|int
name|length
parameter_list|,
specifier|final
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|length
operator|==
literal|0
condition|)
return|return
literal|null
return|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed read "
operator|+
name|length
operator|+
literal|" bytes, stream corrupt?"
argument_list|)
throw|;
block|}
comment|// This is how the old Writables.readFrom used to deserialize. Didn't even
comment|// vint.
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|length
index|]
decl_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
return|return
operator|new
name|KeyValue
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|int
name|getSerializedSize
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|boolean
name|withTags
parameter_list|)
block|{
if|if
condition|(
name|withTags
condition|)
block|{
return|return
name|cell
operator|.
name|getSerializedSize
argument_list|()
return|;
block|}
if|if
condition|(
name|cell
operator|instanceof
name|ExtendedCell
condition|)
block|{
return|return
operator|(
operator|(
name|ExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getSerializedSize
argument_list|(
name|withTags
argument_list|)
return|;
block|}
return|return
name|length
argument_list|(
name|cell
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|cell
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|cell
operator|.
name|getQualifierLength
argument_list|()
argument_list|,
name|cell
operator|.
name|getValueLength
argument_list|()
argument_list|,
name|cell
operator|.
name|getTagsLength
argument_list|()
argument_list|,
name|withTags
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|int
name|oswrite
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|,
specifier|final
name|OutputStream
name|out
parameter_list|,
specifier|final
name|boolean
name|withTags
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|cell
operator|instanceof
name|ExtendedCell
condition|)
block|{
return|return
operator|(
operator|(
name|ExtendedCell
operator|)
name|cell
operator|)
operator|.
name|write
argument_list|(
name|out
argument_list|,
name|withTags
argument_list|)
return|;
block|}
else|else
block|{
name|short
name|rlen
init|=
name|cell
operator|.
name|getRowLength
argument_list|()
decl_stmt|;
name|byte
name|flen
init|=
name|cell
operator|.
name|getFamilyLength
argument_list|()
decl_stmt|;
name|int
name|qlen
init|=
name|cell
operator|.
name|getQualifierLength
argument_list|()
decl_stmt|;
name|int
name|vlen
init|=
name|cell
operator|.
name|getValueLength
argument_list|()
decl_stmt|;
name|int
name|tlen
init|=
name|cell
operator|.
name|getTagsLength
argument_list|()
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
comment|// write key length
name|int
name|klen
init|=
name|keyLength
argument_list|(
name|rlen
argument_list|,
name|flen
argument_list|,
name|qlen
argument_list|)
decl_stmt|;
name|ByteBufferUtils
operator|.
name|putInt
argument_list|(
name|out
argument_list|,
name|klen
argument_list|)
expr_stmt|;
comment|// write value length
name|ByteBufferUtils
operator|.
name|putInt
argument_list|(
name|out
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
comment|// Write rowkey - 2 bytes rk length followed by rowkey bytes
name|StreamUtils
operator|.
name|writeShort
argument_list|(
name|out
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|cell
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
comment|// Write cf - 1 byte of cf length followed by the family bytes
name|out
operator|.
name|write
argument_list|(
name|flen
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|cell
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|flen
argument_list|)
expr_stmt|;
comment|// write qualifier
name|out
operator|.
name|write
argument_list|(
name|cell
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|qlen
argument_list|)
expr_stmt|;
comment|// write timestamp
name|StreamUtils
operator|.
name|writeLong
argument_list|(
name|out
argument_list|,
name|cell
operator|.
name|getTimestamp
argument_list|()
argument_list|)
expr_stmt|;
comment|// write the type
name|out
operator|.
name|write
argument_list|(
name|cell
operator|.
name|getTypeByte
argument_list|()
argument_list|)
expr_stmt|;
comment|// write value
name|out
operator|.
name|write
argument_list|(
name|cell
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
name|size
operator|=
name|klen
operator|+
name|vlen
operator|+
name|KeyValue
operator|.
name|KEYVALUE_INFRASTRUCTURE_SIZE
expr_stmt|;
comment|// write tags if we have to
if|if
condition|(
name|withTags
operator|&&
name|tlen
operator|>
literal|0
condition|)
block|{
comment|// 2 bytes tags length followed by tags bytes
comment|// tags length is serialized with 2 bytes only(short way) even if the
comment|// type is int. As this
comment|// is non -ve numbers, we save the sign bit. See HBASE-11437
name|out
operator|.
name|write
argument_list|(
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
operator|(
name|tlen
operator|>>
literal|8
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
call|(
name|byte
call|)
argument_list|(
literal|0xff
operator|&
name|tlen
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|cell
operator|.
name|getTagsArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getTagsOffset
argument_list|()
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|size
operator|+=
name|tlen
operator|+
name|KeyValue
operator|.
name|TAGS_LENGTH_SIZE
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
block|}
block|}
end_class

end_unit

