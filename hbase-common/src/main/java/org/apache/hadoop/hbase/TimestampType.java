begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  * http://www.apache.org/licenses/LICENSE-2.0  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|time
operator|.
name|FastDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimeZone
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_comment
comment|/**  * {@link TimestampType} is an enum to represent different ways of encoding time in HBase using  * 64 bits. Time is usually encoded as a 64-bit long in {@link org.apache.hadoop.hbase.Cell}  * timestamps and is used for sorting {@link org.apache.hadoop.hbase.Cell}s, ordering writes etc.  * It has methods which help in constructing or interpreting the 64 bit timestamp and getter  * methods to read the hard coded constants of the particular {@link TimestampType}.  *  *<p>  * Enum {@link TimestampType} is dumb in a way. It doesn't have any logic other than interpreting  * the 64 bits. Any monotonically increasing or monotonically non-decreasing semantics of the  * timestamps are the responsibility of the clock implementation generating the particular  * timestamps. There can be several clock implementations, and each such implementation can map  * its representation of the timestamp to one of the available Timestamp types i.e.  * {@link #HYBRID} or {@link #PHYSICAL}. In essence, the {@link TimestampType} is only used  * internally by the Clock implementations and thus never exposed to the user. The user has to  * know only the different available clock types. So, for the user timestamp types do not exist.  *</p>  */
end_comment

begin_enum
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
enum|enum
name|TimestampType
block|{
comment|/**    * Hybrid is a Timestamp type used to encode both physical time and logical time components    * into a single. 64 bits long integer. It has methods to decipher the 64 bits hybrid timestamp    * and also to construct the hybrid timestamp.    */
name|HYBRID
block|{
comment|/**      * Hard coded 44-bits for physical time, with most significant bit carrying the sign i.e 0      * as we are dealing with positive integers and the remaining 43 bits are to be interpreted as      * system time in milli seconds. See      *<a href="https://issues.apache.org/jira/browse/HBASE-14070">HBASE-14070</a> for      * understanding the choice of going with the millisecond resolution for physical time.      * Thus allowing us to represent all the dates between unix epoch (1970) and year 2248 with      * signed timestamp comparison with 44 bits for physical time assuming a millisecond      * resolution with signed long integers. Picking 42 bits to represent the physical time has      * the problem of representing time until 2039 only, with signed integers, might cause Y2k39      * bug hoping HBase to be around till then. The trade-off here is with the year until we can      * represent the physical time vs if we are able capture all the events in the worst case      * (read: leap seconds etc) without the logical component of the timestamp overflowing. With      * 20 bits for logical time, one can represent upto one million events at the same      * millisecond. In case of leap seconds, the no of events happening in the same second is very      * unlikely to exceed one million.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|private
specifier|static
specifier|final
name|int
name|BITS_FOR_PHYSICAL_TIME
init|=
literal|44
decl_stmt|;
comment|/**      * Remaining 20-bits for logical time, allowing values up to 1,048,576. Logical Time is the      * least significant part of the 64 bit timestamp, so unsigned comparison can be used for LT.      */
specifier|private
specifier|static
specifier|final
name|int
name|BITS_FOR_LOGICAL_TIME
init|=
literal|20
decl_stmt|;
comment|/**      * Max value for physical time in the {@link #HYBRID} timestamp representation, inclusive.      * This assumes signed comparison.      */
specifier|private
specifier|static
specifier|final
name|long
name|PHYSICAL_TIME_MAX_VALUE
init|=
literal|0x7ffffffffffL
decl_stmt|;
comment|/**      * Max value for logical time in the {@link #HYBRID} timestamp representation      */
specifier|static
specifier|final
name|long
name|LOGICAL_TIME_MAX_VALUE
init|=
literal|0xfffffL
decl_stmt|;
specifier|public
name|long
name|toEpochTimeMillisFromTimestamp
parameter_list|(
name|long
name|timestamp
parameter_list|)
block|{
return|return
name|getPhysicalTime
argument_list|(
name|timestamp
argument_list|)
return|;
block|}
specifier|public
name|long
name|fromEpochTimeMillisToTimestamp
parameter_list|(
name|long
name|timestamp
parameter_list|)
block|{
return|return
name|toTimestamp
argument_list|(
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|,
name|timestamp
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|public
name|long
name|toTimestamp
parameter_list|(
name|TimeUnit
name|timeUnit
parameter_list|,
name|long
name|physicalTime
parameter_list|,
name|long
name|logicalTime
parameter_list|)
block|{
name|physicalTime
operator|=
name|TimeUnit
operator|.
name|MILLISECONDS
operator|.
name|convert
argument_list|(
name|physicalTime
argument_list|,
name|timeUnit
argument_list|)
expr_stmt|;
return|return
operator|(
name|physicalTime
operator|<<
name|BITS_FOR_LOGICAL_TIME
operator|)
operator|+
name|logicalTime
return|;
block|}
specifier|public
name|long
name|getPhysicalTime
parameter_list|(
name|long
name|timestamp
parameter_list|)
block|{
return|return
name|timestamp
operator|>>>
name|BITS_FOR_LOGICAL_TIME
return|;
comment|// assume unsigned timestamp
block|}
name|long
name|getLogicalTime
parameter_list|(
name|long
name|timestamp
parameter_list|)
block|{
return|return
name|timestamp
operator|&
name|LOGICAL_TIME_MAX_VALUE
return|;
block|}
specifier|public
name|long
name|getMaxPhysicalTime
parameter_list|()
block|{
return|return
name|PHYSICAL_TIME_MAX_VALUE
return|;
block|}
specifier|public
name|long
name|getMaxLogicalTime
parameter_list|()
block|{
return|return
name|LOGICAL_TIME_MAX_VALUE
return|;
block|}
name|int
name|getBitsForLogicalTime
parameter_list|()
block|{
return|return
name|BITS_FOR_LOGICAL_TIME
return|;
block|}
comment|/**      * Returns whether the given timestamp is "likely" of {@link #HYBRID} {@link TimestampType}.      * Timestamp implementations can use the full range of 64bits long to represent physical and      * logical components of time. However, this method returns whether the given timestamp is a      * likely representation depending on heuristics for the clock implementation.      *      * Hybrid timestamps are checked whether they belong to Hybrid range assuming      * that Hybrid timestamps will only have> 0 logical time component for timestamps      * corresponding to years after 2016. This method will return false if lt> 0 and year is      * before 2016. Due to left shifting for Hybrid time, all millisecond-since-epoch timestamps      * from years 1970-10K fall into      * year 1970 when interpreted as Hybrid timestamps. Thus, {@link #isLikelyOfType(long, boolean)} will      * return false for timestamps which are in the year 1970 and logical time = 0 when      * interpreted as of type Hybrid Time.      *      *<p>      *<b>Note that</b> this method uses heuristics which may not hold      * if system timestamps are intermixed from client side and server side or timestamp      * sources other than system clock are used.      *</p>      * @param timestamp {@link #HYBRID} Timestamp      * @param isClockMonotonic if the clock that generated this timestamp is monotonic      * @return true if the timestamp is likely to be of the corresponding {@link TimestampType}      * else false      */
specifier|public
name|boolean
name|isLikelyOfType
parameter_list|(
name|long
name|timestamp
parameter_list|,
name|boolean
name|isClockMonotonic
parameter_list|)
block|{
name|long
name|physicalTime
init|=
name|getPhysicalTime
argument_list|(
name|timestamp
argument_list|)
decl_stmt|;
name|long
name|logicalTime
init|=
name|getLogicalTime
argument_list|(
name|timestamp
argument_list|)
decl_stmt|;
comment|// heuristic 1: Up until year 2016 (1451635200000), lt component cannot be non-zero.
if|if
condition|(
name|physicalTime
operator|<
literal|1451635200000L
operator|&&
name|logicalTime
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|physicalTime
operator|<
literal|31536000000L
condition|)
block|{
comment|// heuristic 2: Even if logical time = 0, physical time after left shifting by 20 bits,
comment|// will be before year 1971(31536000000L), as after left shifting by 20, all epoch ms
comment|// timestamps from wall time end up in year less than 1971, even for epoch time for the
comment|// year 10000. This assumes Hybrid time is not used to represent timestamps for year 1970
comment|// UTC.
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Returns a string representation for Physical Time and Logical Time components. The format is:      *<code>yyyy-MM-dd HH:mm:ss:SSS(Physical Time),Logical Time</code>      * Physical Time is converted to UTC time and not to local time for uniformity.      * Example: 2015-07-17 16:56:35:891(1437177395891), 0      * @param timestamp A {@link #HYBRID} Timestamp      * @return A date time string formatted as mentioned in the method description      */
specifier|public
name|String
name|toString
parameter_list|(
name|long
name|timestamp
parameter_list|)
block|{
name|long
name|physicalTime
init|=
name|getPhysicalTime
argument_list|(
name|timestamp
argument_list|)
decl_stmt|;
name|long
name|logicalTime
init|=
name|getLogicalTime
argument_list|(
name|timestamp
argument_list|)
decl_stmt|;
return|return
operator|new
name|StringBuilder
argument_list|()
operator|.
name|append
argument_list|(
name|dateFormat
operator|.
name|format
argument_list|(
name|physicalTime
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
operator|.
name|append
argument_list|(
name|physicalTime
argument_list|)
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
operator|.
name|append
argument_list|(
name|logicalTime
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
block|,
comment|/**    * Physical is a Timestamp type used to encode the physical time in 64 bits.    * It has helper methods to decipher the 64 bit encoding of physical time.    */
name|PHYSICAL
block|{
specifier|public
name|long
name|toEpochTimeMillisFromTimestamp
parameter_list|(
name|long
name|timestamp
parameter_list|)
block|{
return|return
name|timestamp
return|;
block|}
specifier|public
name|long
name|fromEpochTimeMillisToTimestamp
parameter_list|(
name|long
name|timestamp
parameter_list|)
block|{
return|return
name|timestamp
return|;
block|}
specifier|public
name|long
name|toTimestamp
parameter_list|(
name|TimeUnit
name|timeUnit
parameter_list|,
name|long
name|physicalTime
parameter_list|,
name|long
name|logicalTime
parameter_list|)
block|{
return|return
name|TimeUnit
operator|.
name|MILLISECONDS
operator|.
name|convert
argument_list|(
name|physicalTime
argument_list|,
name|timeUnit
argument_list|)
return|;
block|}
specifier|public
name|long
name|getPhysicalTime
parameter_list|(
name|long
name|timestamp
parameter_list|)
block|{
return|return
name|timestamp
return|;
block|}
name|long
name|getLogicalTime
parameter_list|(
name|long
name|timestamp
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
specifier|public
name|long
name|getMaxPhysicalTime
parameter_list|()
block|{
return|return
name|Long
operator|.
name|MAX_VALUE
return|;
block|}
specifier|public
name|long
name|getMaxLogicalTime
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
name|int
name|getBitsForLogicalTime
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
specifier|public
name|boolean
name|isLikelyOfType
parameter_list|(
name|long
name|timestamp
parameter_list|,
name|boolean
name|isClockMonotonic
parameter_list|)
block|{
comment|// heuristic: the timestamp should be up to year 3K (32503680000000L).
if|if
condition|(
operator|!
name|isClockMonotonic
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|timestamp
operator|<
literal|32503680000000L
return|;
block|}
comment|/**      * Returns a string representation for Physical Time and Logical Time components. The format is:      *<code>yyyy-MM-dd HH:mm:ss:SSS(Physical Time)</code>      * Physical Time is converted to UTC time and not to local time for uniformity.      * Example: 2015-07-17 16:56:35:891(1437177395891), 0      * @param timestamp epoch time in milliseconds      * @return A date time string formatted as mentioned in the method description      */
specifier|public
name|String
name|toString
parameter_list|(
name|long
name|timestamp
parameter_list|)
block|{
name|long
name|physicalTime
init|=
name|timestamp
decl_stmt|;
return|return
operator|new
name|StringBuilder
argument_list|()
operator|.
name|append
argument_list|(
name|dateFormat
operator|.
name|format
argument_list|(
name|physicalTime
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
operator|.
name|append
argument_list|(
name|physicalTime
argument_list|)
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
operator|.
name|append
argument_list|(
literal|"0"
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
block|;
comment|/**    * This is used internally by the enum methods of Hybrid and Physical Timestamp types to    * convert the    * timestamp to the format set here. UTC timezone instead of local time zone for convenience    * and uniformity    */
specifier|private
specifier|static
specifier|final
name|FastDateFormat
name|dateFormat
init|=
name|FastDateFormat
operator|.
name|getInstance
argument_list|(
literal|"yyyy-MM-dd'T'HH:mm:ss:SSS"
argument_list|,
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
literal|"UTC"
argument_list|)
argument_list|)
decl_stmt|;
comment|/**    * Converts the given timestamp to the unix epoch timestamp with millisecond resolution.    * Returned timestamp is compatible with System.currentTimeMillis().    * @param timestamp {@link #HYBRID} or {@link #PHYSICAL} Timestamp    * @return number of milliseconds from epoch    */
specifier|abstract
specifier|public
name|long
name|toEpochTimeMillisFromTimestamp
parameter_list|(
name|long
name|timestamp
parameter_list|)
function_decl|;
comment|/**    * Converts the given time in milliseconds to the corresponding {@link TimestampType}    * representation.    * @param timeInMillis epoch time in {@link TimeUnit#MILLISECONDS}    * @return a timestamp representation corresponding to {@link TimestampType}.    */
specifier|abstract
specifier|public
name|long
name|fromEpochTimeMillisToTimestamp
parameter_list|(
name|long
name|timeInMillis
parameter_list|)
function_decl|;
comment|/**    * Converts the given physical clock in the given {@link TimeUnit} to a 64-bit timestamp    * @param timeUnit a time unit as in the enum {@link TimeUnit}    * @param physicalTime physical time    * @param logicalTime logical time    * @return a timestamp in 64 bits    */
specifier|abstract
specifier|public
name|long
name|toTimestamp
parameter_list|(
name|TimeUnit
name|timeUnit
parameter_list|,
name|long
name|physicalTime
parameter_list|,
name|long
name|logicalTime
parameter_list|)
function_decl|;
comment|/**    * Extracts and returns the physical time from the timestamp    * @param timestamp {@link #HYBRID} or {@link #PHYSICAL} Timestamp    * @return physical time in {@link TimeUnit#MILLISECONDS}    */
specifier|abstract
specifier|public
name|long
name|getPhysicalTime
parameter_list|(
name|long
name|timestamp
parameter_list|)
function_decl|;
comment|/**    * Extracts and returns the logical time from the timestamp    * @param timestamp {@link #HYBRID} or {@link #PHYSICAL} Timestamp    * @return logical time    */
specifier|abstract
name|long
name|getLogicalTime
parameter_list|(
name|long
name|timestamp
parameter_list|)
function_decl|;
comment|/**    * @return the maximum possible physical time in {@link TimeUnit#MILLISECONDS}    */
specifier|abstract
specifier|public
name|long
name|getMaxPhysicalTime
parameter_list|()
function_decl|;
comment|/**    * @return the maximum possible logical time    */
specifier|abstract
specifier|public
name|long
name|getMaxLogicalTime
parameter_list|()
function_decl|;
comment|/**    * @return number of least significant bits allocated for logical time    */
specifier|abstract
name|int
name|getBitsForLogicalTime
parameter_list|()
function_decl|;
comment|/**    * @param timestamp epoch time in milliseconds    * @param isClockMonotonic if the clock that generated this timestamp is monotonic    * @return True if the timestamp generated by the clock is of type {@link #PHYSICAL} else False    */
specifier|abstract
specifier|public
name|boolean
name|isLikelyOfType
parameter_list|(
name|long
name|timestamp
parameter_list|,
name|boolean
name|isClockMonotonic
parameter_list|)
function_decl|;
specifier|public
specifier|abstract
name|String
name|toString
parameter_list|(
name|long
name|timestamp
parameter_list|)
function_decl|;
block|}
end_enum

end_unit

