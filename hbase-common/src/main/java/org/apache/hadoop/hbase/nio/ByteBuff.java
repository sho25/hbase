begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|nio
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ReadableByteChannel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ByteBufferUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ObjectIntPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_comment
comment|/**  * An abstract class that abstracts out as to how the byte buffers are used,  * either single or multiple. We have this interface because the java's ByteBuffers  * cannot be sub-classed. This class provides APIs similar to the ones provided  * in java's nio ByteBuffers and allows you to do positional reads/writes and relative  * reads and writes on the underlying BB. In addition to it, we have some additional APIs which  * helps us in the read path.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
comment|// TODO to have another name. This can easily get confused with netty's ByteBuf
specifier|public
specifier|abstract
class|class
name|ByteBuff
block|{
specifier|private
specifier|static
specifier|final
name|int
name|NIO_BUFFER_LIMIT
init|=
literal|64
operator|*
literal|1024
decl_stmt|;
comment|// should not be more than 64KB.
comment|/**    * @return this ByteBuff's current position    */
specifier|public
specifier|abstract
name|int
name|position
parameter_list|()
function_decl|;
comment|/**    * Sets this ByteBuff's position to the given value.    * @param position    * @return this object    */
specifier|public
specifier|abstract
name|ByteBuff
name|position
parameter_list|(
name|int
name|position
parameter_list|)
function_decl|;
comment|/**    * Jumps the current position of this ByteBuff by specified length.    * @param len the length to be skipped    */
specifier|public
specifier|abstract
name|ByteBuff
name|skip
parameter_list|(
name|int
name|len
parameter_list|)
function_decl|;
comment|/**    * Jumps back the current position of this ByteBuff by specified length.    * @param len the length to move back    */
specifier|public
specifier|abstract
name|ByteBuff
name|moveBack
parameter_list|(
name|int
name|len
parameter_list|)
function_decl|;
comment|/**    * @return the total capacity of this ByteBuff.    */
specifier|public
specifier|abstract
name|int
name|capacity
parameter_list|()
function_decl|;
comment|/**    * Returns the limit of this ByteBuff    * @return limit of the ByteBuff    */
specifier|public
specifier|abstract
name|int
name|limit
parameter_list|()
function_decl|;
comment|/**    * Marks the limit of this ByteBuff.    * @param limit    * @return This ByteBuff    */
specifier|public
specifier|abstract
name|ByteBuff
name|limit
parameter_list|(
name|int
name|limit
parameter_list|)
function_decl|;
comment|/**    * Rewinds this ByteBuff and the position is set to 0    * @return this object    */
specifier|public
specifier|abstract
name|ByteBuff
name|rewind
parameter_list|()
function_decl|;
comment|/**    * Marks the current position of the ByteBuff    * @return this object    */
specifier|public
specifier|abstract
name|ByteBuff
name|mark
parameter_list|()
function_decl|;
comment|/**    * Returns bytes from current position till length specified, as a single ByteBuffer. When all    * these bytes happen to be in a single ByteBuffer, which this object wraps, that ByteBuffer item    * as such will be returned. So users are warned not to change the position or limit of this    * returned ByteBuffer. The position of the returned byte buffer is at the begin of the required    * bytes. When the required bytes happen to span across multiple ByteBuffers, this API will copy    * the bytes to a newly created ByteBuffer of required size and return that.    *    * @param length number of bytes required.    * @return bytes from current position till length specified, as a single ByteButter.    */
specifier|public
specifier|abstract
name|ByteBuffer
name|asSubByteBuffer
parameter_list|(
name|int
name|length
parameter_list|)
function_decl|;
comment|/**    * Returns bytes from given offset till length specified, as a single ByteBuffer. When all these    * bytes happen to be in a single ByteBuffer, which this object wraps, that ByteBuffer item as    * such will be returned (with offset in this ByteBuffer where the bytes starts). So users are    * warned not to change the position or limit of this returned ByteBuffer. When the required bytes    * happen to span across multiple ByteBuffers, this API will copy the bytes to a newly created    * ByteBuffer of required size and return that.    *    * @param offset the offset in this ByteBuff from where the subBuffer should be created    * @param length the length of the subBuffer    * @param pair a pair that will have the bytes from the current position till length specified,    *        as a single ByteBuffer and offset in that Buffer where the bytes starts.    *        Since this API gets called in a loop we are passing a pair to it which could be created    *        outside the loop and the method would set the values on the pair that is passed in by    *        the caller. Thus it avoids more object creations that would happen if the pair that is    *        returned is created by this method every time.    */
specifier|public
specifier|abstract
name|void
name|asSubByteBuffer
parameter_list|(
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|ObjectIntPair
argument_list|<
name|ByteBuffer
argument_list|>
name|pair
parameter_list|)
function_decl|;
comment|/**    * Returns the number of elements between the current position and the    * limit.    * @return the remaining elements in this ByteBuff    */
specifier|public
specifier|abstract
name|int
name|remaining
parameter_list|()
function_decl|;
comment|/**    * Returns true if there are elements between the current position and the limt    * @return true if there are elements, false otherwise    */
specifier|public
specifier|abstract
name|boolean
name|hasRemaining
parameter_list|()
function_decl|;
comment|/**    * Similar to {@link ByteBuffer}.reset(), ensures that this ByteBuff    * is reset back to last marked position.    * @return This ByteBuff    */
specifier|public
specifier|abstract
name|ByteBuff
name|reset
parameter_list|()
function_decl|;
comment|/**    * Returns an ByteBuff which is a sliced version of this ByteBuff. The position, limit and mark    * of the new ByteBuff will be independent than that of the original ByteBuff.    * The content of the new ByteBuff will start at this ByteBuff's current position    * @return a sliced ByteBuff    */
specifier|public
specifier|abstract
name|ByteBuff
name|slice
parameter_list|()
function_decl|;
comment|/**    * Returns an ByteBuff which is a duplicate version of this ByteBuff. The    * position, limit and mark of the new ByteBuff will be independent than that    * of the original ByteBuff. The content of the new ByteBuff will start at    * this ByteBuff's current position The position, limit and mark of the new    * ByteBuff would be identical to this ByteBuff in terms of values.    *    * @return a sliced ByteBuff    */
specifier|public
specifier|abstract
name|ByteBuff
name|duplicate
parameter_list|()
function_decl|;
comment|/**    * A relative method that returns byte at the current position.  Increments the    * current position by the size of a byte.    * @return the byte at the current position    */
specifier|public
specifier|abstract
name|byte
name|get
parameter_list|()
function_decl|;
comment|/**    * Fetches the byte at the given index. Does not change position of the underlying ByteBuffers    * @param index    * @return the byte at the given index    */
specifier|public
specifier|abstract
name|byte
name|get
parameter_list|(
name|int
name|index
parameter_list|)
function_decl|;
comment|/**    * Fetches the byte at the given offset from current position. Does not change position    * of the underlying ByteBuffers.    *    * @param offset    * @return the byte value at the given index.    */
specifier|public
specifier|abstract
name|byte
name|getByteAfterPosition
parameter_list|(
name|int
name|offset
parameter_list|)
function_decl|;
comment|/**    * Writes a byte to this ByteBuff at the current position and increments the position    * @param b    * @return this object    */
specifier|public
specifier|abstract
name|ByteBuff
name|put
parameter_list|(
name|byte
name|b
parameter_list|)
function_decl|;
comment|/**    * Writes a byte to this ByteBuff at the given index    * @param index    * @param b    * @return this object    */
specifier|public
specifier|abstract
name|ByteBuff
name|put
parameter_list|(
name|int
name|index
parameter_list|,
name|byte
name|b
parameter_list|)
function_decl|;
comment|/**    * Copies the specified number of bytes from this ByteBuff's current position to    * the byte[]'s offset. Also advances the position of the ByteBuff by the given length.    * @param dst    * @param offset within the current array    * @param length upto which the bytes to be copied    */
specifier|public
specifier|abstract
name|void
name|get
parameter_list|(
name|byte
index|[]
name|dst
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
comment|/**    * Copies the specified number of bytes from this ByteBuff's given position to    * the byte[]'s offset. The position of the ByteBuff remains in the current position only    * @param sourceOffset the offset in this ByteBuff from where the copy should happen    * @param dst the byte[] to which the ByteBuff's content is to be copied    * @param offset within the current array    * @param length upto which the bytes to be copied    */
specifier|public
specifier|abstract
name|void
name|get
parameter_list|(
name|int
name|sourceOffset
parameter_list|,
name|byte
index|[]
name|dst
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
comment|/**    * Copies the content from this ByteBuff's current position to the byte array and fills it. Also    * advances the position of the ByteBuff by the length of the byte[].    * @param dst    */
specifier|public
specifier|abstract
name|void
name|get
parameter_list|(
name|byte
index|[]
name|dst
parameter_list|)
function_decl|;
comment|/**    * Copies from the given byte[] to this ByteBuff    * @param src    * @param offset the position in the byte array from which the copy should be done    * @param length the length upto which the copy should happen    * @return this ByteBuff    */
specifier|public
specifier|abstract
name|ByteBuff
name|put
parameter_list|(
name|byte
index|[]
name|src
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
comment|/**    * Copies from the given byte[] to this ByteBuff    * @param src    * @return this ByteBuff    */
specifier|public
specifier|abstract
name|ByteBuff
name|put
parameter_list|(
name|byte
index|[]
name|src
parameter_list|)
function_decl|;
comment|/**    * @return true or false if the underlying BB support hasArray    */
specifier|public
specifier|abstract
name|boolean
name|hasArray
parameter_list|()
function_decl|;
comment|/**    * @return the byte[] if the underlying BB has single BB and hasArray true    */
specifier|public
specifier|abstract
name|byte
index|[]
name|array
parameter_list|()
function_decl|;
comment|/**    * @return the arrayOffset of the byte[] incase of a single BB backed ByteBuff    */
specifier|public
specifier|abstract
name|int
name|arrayOffset
parameter_list|()
function_decl|;
comment|/**    * Returns the short value at the current position. Also advances the position by the size    * of short    *    * @return the short value at the current position    */
specifier|public
specifier|abstract
name|short
name|getShort
parameter_list|()
function_decl|;
comment|/**    * Fetches the short value at the given index. Does not change position of the    * underlying ByteBuffers. The caller is sure that the index will be after    * the current position of this ByteBuff. So even if the current short does not fit in the    * current item we can safely move to the next item and fetch the remaining bytes forming    * the short    *    * @param index    * @return the short value at the given index    */
specifier|public
specifier|abstract
name|short
name|getShort
parameter_list|(
name|int
name|index
parameter_list|)
function_decl|;
comment|/**    * Fetches the short value at the given offset from current position. Does not change position    * of the underlying ByteBuffers.    *    * @param offset    * @return the short value at the given index.    */
specifier|public
specifier|abstract
name|short
name|getShortAfterPosition
parameter_list|(
name|int
name|offset
parameter_list|)
function_decl|;
comment|/**    * Returns the int value at the current position. Also advances the position by the size of int    *    * @return the int value at the current position    */
specifier|public
specifier|abstract
name|int
name|getInt
parameter_list|()
function_decl|;
comment|/**    * Writes an int to this ByteBuff at its current position. Also advances the position    * by size of int    * @param value Int value to write    * @return this object    */
specifier|public
specifier|abstract
name|ByteBuff
name|putInt
parameter_list|(
name|int
name|value
parameter_list|)
function_decl|;
comment|/**    * Fetches the int at the given index. Does not change position of the underlying ByteBuffers.    * Even if the current int does not fit in the    * current item we can safely move to the next item and fetch the remaining bytes forming    * the int    *    * @param index    * @return the int value at the given index    */
specifier|public
specifier|abstract
name|int
name|getInt
parameter_list|(
name|int
name|index
parameter_list|)
function_decl|;
comment|/**    * Fetches the int value at the given offset from current position. Does not change position    * of the underlying ByteBuffers.    *    * @param offset    * @return the int value at the given index.    */
specifier|public
specifier|abstract
name|int
name|getIntAfterPosition
parameter_list|(
name|int
name|offset
parameter_list|)
function_decl|;
comment|/**    * Returns the long value at the current position. Also advances the position by the size of long    *    * @return the long value at the current position    */
specifier|public
specifier|abstract
name|long
name|getLong
parameter_list|()
function_decl|;
comment|/**    * Writes a long to this ByteBuff at its current position.    * Also advances the position by size of long    * @param value Long value to write    * @return this object    */
specifier|public
specifier|abstract
name|ByteBuff
name|putLong
parameter_list|(
name|long
name|value
parameter_list|)
function_decl|;
comment|/**    * Fetches the long at the given index. Does not change position of the    * underlying ByteBuffers. The caller is sure that the index will be after    * the current position of this ByteBuff. So even if the current long does not fit in the    * current item we can safely move to the next item and fetch the remaining bytes forming    * the long    *    * @param index    * @return the long value at the given index    */
specifier|public
specifier|abstract
name|long
name|getLong
parameter_list|(
name|int
name|index
parameter_list|)
function_decl|;
comment|/**    * Fetches the long value at the given offset from current position. Does not change position    * of the underlying ByteBuffers.    *    * @param offset    * @return the long value at the given index.    */
specifier|public
specifier|abstract
name|long
name|getLongAfterPosition
parameter_list|(
name|int
name|offset
parameter_list|)
function_decl|;
comment|/**    * Copy the content from this ByteBuff to a byte[].    * @return byte[] with the copied contents from this ByteBuff.    */
specifier|public
name|byte
index|[]
name|toBytes
parameter_list|()
block|{
return|return
name|toBytes
argument_list|(
literal|0
argument_list|,
name|this
operator|.
name|limit
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Copy the content from this ByteBuff to a byte[] based on the given offset and    * length    *    * @param offset    *          the position from where the copy should start    * @param length    *          the length upto which the copy has to be done    * @return byte[] with the copied contents from this ByteBuff.    */
specifier|public
specifier|abstract
name|byte
index|[]
name|toBytes
parameter_list|(
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
comment|/**    * Copies the content from this ByteBuff to a ByteBuffer    * Note : This will advance the position marker of {@code out} but not change the position maker    * for this ByteBuff    * @param out the ByteBuffer to which the copy has to happen    * @param sourceOffset the offset in the ByteBuff from which the elements has    * to be copied    * @param length the length in this ByteBuff upto which the elements has to be copied    */
specifier|public
specifier|abstract
name|void
name|get
parameter_list|(
name|ByteBuffer
name|out
parameter_list|,
name|int
name|sourceOffset
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
comment|/**    * Copies the contents from the src ByteBuff to this ByteBuff. This will be    * absolute positional copying and    * won't affect the position of any of the buffers.    * @param offset the position in this ByteBuff to which the copy should happen    * @param src the src ByteBuff    * @param srcOffset the offset in the src ByteBuff from where the elements should be read    * @param length the length up to which the copy should happen    */
specifier|public
specifier|abstract
name|ByteBuff
name|put
parameter_list|(
name|int
name|offset
parameter_list|,
name|ByteBuff
name|src
parameter_list|,
name|int
name|srcOffset
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
comment|/**    * Reads bytes from the given channel into this ByteBuff    * @param channel    * @return The number of bytes read from the channel    * @throws IOException    */
specifier|public
specifier|abstract
name|int
name|read
parameter_list|(
name|ReadableByteChannel
name|channel
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|// static helper methods
specifier|public
specifier|static
name|int
name|channelRead
parameter_list|(
name|ReadableByteChannel
name|channel
parameter_list|,
name|ByteBuffer
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|buf
operator|.
name|remaining
argument_list|()
operator|<=
name|NIO_BUFFER_LIMIT
condition|)
block|{
return|return
name|channel
operator|.
name|read
argument_list|(
name|buf
argument_list|)
return|;
block|}
name|int
name|originalLimit
init|=
name|buf
operator|.
name|limit
argument_list|()
decl_stmt|;
name|int
name|initialRemaining
init|=
name|buf
operator|.
name|remaining
argument_list|()
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|buf
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|int
name|ioSize
init|=
name|Math
operator|.
name|min
argument_list|(
name|buf
operator|.
name|remaining
argument_list|()
argument_list|,
name|NIO_BUFFER_LIMIT
argument_list|)
decl_stmt|;
name|buf
operator|.
name|limit
argument_list|(
name|buf
operator|.
name|position
argument_list|()
operator|+
name|ioSize
argument_list|)
expr_stmt|;
name|ret
operator|=
name|channel
operator|.
name|read
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
name|ioSize
condition|)
block|{
break|break;
block|}
block|}
finally|finally
block|{
name|buf
operator|.
name|limit
argument_list|(
name|originalLimit
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|nBytes
init|=
name|initialRemaining
operator|-
name|buf
operator|.
name|remaining
argument_list|()
decl_stmt|;
return|return
operator|(
name|nBytes
operator|>
literal|0
operator|)
condition|?
name|nBytes
else|:
name|ret
return|;
block|}
comment|/**    * Read integer from ByteBuff coded in 7 bits and increment position.    * @return Read integer.    */
specifier|public
specifier|static
name|int
name|readCompressedInt
parameter_list|(
name|ByteBuff
name|buf
parameter_list|)
block|{
name|byte
name|b
init|=
name|buf
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|b
operator|&
name|ByteBufferUtils
operator|.
name|NEXT_BIT_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|b
operator|&
name|ByteBufferUtils
operator|.
name|VALUE_MASK
operator|)
operator|+
operator|(
name|readCompressedInt
argument_list|(
name|buf
argument_list|)
operator|<<
name|ByteBufferUtils
operator|.
name|NEXT_BIT_SHIFT
operator|)
return|;
block|}
return|return
name|b
operator|&
name|ByteBufferUtils
operator|.
name|VALUE_MASK
return|;
block|}
comment|/**    * Compares two ByteBuffs    *    * @param buf1 the first ByteBuff    * @param o1 the offset in the first ByteBuff from where the compare has to happen    * @param len1 the length in the first ByteBuff upto which the compare has to happen    * @param buf2 the second ByteBuff    * @param o2 the offset in the second ByteBuff from where the compare has to happen    * @param len2 the length in the second ByteBuff upto which the compare has to happen    * @return Positive if buf1 is bigger than buf2, 0 if they are equal, and negative if buf1 is    *         smaller than buf2.    */
specifier|public
specifier|static
name|int
name|compareTo
parameter_list|(
name|ByteBuff
name|buf1
parameter_list|,
name|int
name|o1
parameter_list|,
name|int
name|len1
parameter_list|,
name|ByteBuff
name|buf2
parameter_list|,
name|int
name|o2
parameter_list|,
name|int
name|len2
parameter_list|)
block|{
if|if
condition|(
name|buf1
operator|.
name|hasArray
argument_list|()
operator|&&
name|buf2
operator|.
name|hasArray
argument_list|()
condition|)
block|{
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|buf1
operator|.
name|array
argument_list|()
argument_list|,
name|buf1
operator|.
name|arrayOffset
argument_list|()
operator|+
name|o1
argument_list|,
name|len1
argument_list|,
name|buf2
operator|.
name|array
argument_list|()
argument_list|,
name|buf2
operator|.
name|arrayOffset
argument_list|()
operator|+
name|o2
argument_list|,
name|len2
argument_list|)
return|;
block|}
name|int
name|end1
init|=
name|o1
operator|+
name|len1
decl_stmt|;
name|int
name|end2
init|=
name|o2
operator|+
name|len2
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|o1
init|,
name|j
init|=
name|o2
init|;
name|i
operator|<
name|end1
operator|&&
name|j
operator|<
name|end2
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|int
name|a
init|=
name|buf1
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|&
literal|0xFF
decl_stmt|;
name|int
name|b
init|=
name|buf2
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|&
literal|0xFF
decl_stmt|;
if|if
condition|(
name|a
operator|!=
name|b
condition|)
block|{
return|return
name|a
operator|-
name|b
return|;
block|}
block|}
return|return
name|len1
operator|-
name|len2
return|;
block|}
comment|/**    * Read long which was written to fitInBytes bytes and increment position.    * @param fitInBytes In how many bytes given long is stored.    * @return The value of parsed long.    */
specifier|public
specifier|static
name|long
name|readLong
parameter_list|(
name|ByteBuff
name|in
parameter_list|,
specifier|final
name|int
name|fitInBytes
parameter_list|)
block|{
name|long
name|tmpLength
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fitInBytes
condition|;
operator|++
name|i
control|)
block|{
name|tmpLength
operator||=
operator|(
name|in
operator|.
name|get
argument_list|()
operator|&
literal|0xffl
operator|)
operator|<<
operator|(
literal|8l
operator|*
name|i
operator|)
expr_stmt|;
block|}
return|return
name|tmpLength
return|;
block|}
comment|/**    * Similar to {@link WritableUtils#readVLong(java.io.DataInput)} but reads from a    * {@link ByteBuff}.    */
specifier|public
specifier|static
name|long
name|readVLong
parameter_list|(
name|ByteBuff
name|in
parameter_list|)
block|{
name|byte
name|firstByte
init|=
name|in
operator|.
name|get
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|WritableUtils
operator|.
name|decodeVIntSize
argument_list|(
name|firstByte
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
return|return
name|firstByte
return|;
block|}
name|long
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|len
operator|-
literal|1
condition|;
name|idx
operator|++
control|)
block|{
name|byte
name|b
init|=
name|in
operator|.
name|get
argument_list|()
decl_stmt|;
name|i
operator|=
name|i
operator|<<
literal|8
expr_stmt|;
name|i
operator|=
name|i
operator||
operator|(
name|b
operator|&
literal|0xFF
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|WritableUtils
operator|.
name|isNegativeVInt
argument_list|(
name|firstByte
argument_list|)
condition|?
operator|(
name|i
operator|^
operator|-
literal|1L
operator|)
else|:
name|i
operator|)
return|;
block|}
comment|/**    * Search sorted array "a" for byte "key".    *     * @param a Array to search. Entries must be sorted and unique.    * @param fromIndex First index inclusive of "a" to include in the search.    * @param toIndex Last index exclusive of "a" to include in the search.    * @param key The byte to search for.    * @return The index of key if found. If not found, return -(index + 1), where    *         negative indicates "not found" and the "index + 1" handles the "-0"    *         case.    */
specifier|public
specifier|static
name|int
name|unsignedBinarySearch
parameter_list|(
name|ByteBuff
name|a
parameter_list|,
name|int
name|fromIndex
parameter_list|,
name|int
name|toIndex
parameter_list|,
name|byte
name|key
parameter_list|)
block|{
name|int
name|unsignedKey
init|=
name|key
operator|&
literal|0xff
decl_stmt|;
name|int
name|low
init|=
name|fromIndex
decl_stmt|;
name|int
name|high
init|=
name|toIndex
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|low
operator|<=
name|high
condition|)
block|{
name|int
name|mid
init|=
name|low
operator|+
operator|(
operator|(
name|high
operator|-
name|low
operator|)
operator|>>
literal|1
operator|)
decl_stmt|;
name|int
name|midVal
init|=
name|a
operator|.
name|get
argument_list|(
name|mid
argument_list|)
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
name|midVal
operator|<
name|unsignedKey
condition|)
block|{
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|midVal
operator|>
name|unsignedKey
condition|)
block|{
name|high
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
return|return
name|mid
return|;
comment|// key found
block|}
block|}
return|return
operator|-
operator|(
name|low
operator|+
literal|1
operator|)
return|;
comment|// key not found.
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"[pos="
operator|+
name|position
argument_list|()
operator|+
literal|", lim="
operator|+
name|limit
argument_list|()
operator|+
literal|", cap= "
operator|+
name|capacity
argument_list|()
operator|+
literal|"]"
return|;
block|}
specifier|public
specifier|static
name|String
name|toStringBinary
parameter_list|(
specifier|final
name|ByteBuff
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|// Just in case we are passed a 'len' that is> buffer length...
if|if
condition|(
name|off
operator|>=
name|b
operator|.
name|capacity
argument_list|()
condition|)
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
if|if
condition|(
name|off
operator|+
name|len
operator|>
name|b
operator|.
name|capacity
argument_list|()
condition|)
name|len
operator|=
name|b
operator|.
name|capacity
argument_list|()
operator|-
name|off
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|off
init|;
name|i
operator|<
name|off
operator|+
name|len
condition|;
operator|++
name|i
control|)
block|{
name|int
name|ch
init|=
name|b
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|&
literal|0xFF
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'z'
operator|)
operator|||
literal|" `~!@#$%^&*()-_=+[]{}|;:'\",.<>/?"
operator|.
name|indexOf
argument_list|(
name|ch
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|ch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"\\x%02X"
argument_list|,
name|ch
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

end_unit

