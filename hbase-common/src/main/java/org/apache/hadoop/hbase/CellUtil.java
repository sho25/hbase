begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
operator|.
name|COLUMN_FAMILY_DELIMITER
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
operator|.
name|COLUMN_FAMILY_DELIM_ARRAY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
operator|.
name|getDelimiter
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Tag
operator|.
name|TAG_LENGTH_SIZE
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|HeapSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ByteBufferUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ByteRange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
operator|.
name|Private
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * Utility methods helpful for slinging {@link Cell} instances. Some methods below are for internal  * use only and are marked InterfaceAudience.Private at the method level. Note that all such methods  * have been marked deprecated in HBase-2.0 which will be subsequently removed in HBase-3.0  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
specifier|public
specifier|final
class|class
name|CellUtil
block|{
comment|/**    * Private constructor to keep this class from being instantiated.    */
specifier|private
name|CellUtil
parameter_list|()
block|{   }
comment|/******************* ByteRange *******************************/
comment|/**    * @deprecated As of HBase-2.0. Will be removed in HBase-3.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|ByteRange
name|fillRowRange
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|ByteRange
name|range
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|fillRowRange
argument_list|(
name|cell
argument_list|,
name|range
argument_list|)
return|;
block|}
comment|/**    * @deprecated As of HBase-2.0. Will be removed in HBase-3.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|ByteRange
name|fillFamilyRange
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|ByteRange
name|range
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|fillFamilyRange
argument_list|(
name|cell
argument_list|,
name|range
argument_list|)
return|;
block|}
comment|/**    * @deprecated As of HBase-2.0. Will be removed in HBase-3.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|ByteRange
name|fillQualifierRange
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|ByteRange
name|range
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|fillQualifierRange
argument_list|(
name|cell
argument_list|,
name|range
argument_list|)
return|;
block|}
comment|/**    * @deprecated As of HBase-2.0. Will be removed in HBase-3.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|ByteRange
name|fillValueRange
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|ByteRange
name|range
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|fillValueRange
argument_list|(
name|cell
argument_list|,
name|range
argument_list|)
return|;
block|}
comment|/**    * @deprecated As of HBase-2.0. Will be removed in HBase-3.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|ByteRange
name|fillTagRange
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|ByteRange
name|range
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|fillTagRange
argument_list|(
name|cell
argument_list|,
name|range
argument_list|)
return|;
block|}
comment|/***************** get individual arrays for tests ************/
specifier|public
specifier|static
name|byte
index|[]
name|cloneRow
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
name|byte
index|[]
name|output
init|=
operator|new
name|byte
index|[
name|cell
operator|.
name|getRowLength
argument_list|()
index|]
decl_stmt|;
name|copyRowTo
argument_list|(
name|cell
argument_list|,
name|output
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
specifier|public
specifier|static
name|byte
index|[]
name|cloneFamily
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
name|byte
index|[]
name|output
init|=
operator|new
name|byte
index|[
name|cell
operator|.
name|getFamilyLength
argument_list|()
index|]
decl_stmt|;
name|copyFamilyTo
argument_list|(
name|cell
argument_list|,
name|output
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
specifier|public
specifier|static
name|byte
index|[]
name|cloneQualifier
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
name|byte
index|[]
name|output
init|=
operator|new
name|byte
index|[
name|cell
operator|.
name|getQualifierLength
argument_list|()
index|]
decl_stmt|;
name|copyQualifierTo
argument_list|(
name|cell
argument_list|,
name|output
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
specifier|public
specifier|static
name|byte
index|[]
name|cloneValue
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
name|byte
index|[]
name|output
init|=
operator|new
name|byte
index|[
name|cell
operator|.
name|getValueLength
argument_list|()
index|]
decl_stmt|;
name|copyValueTo
argument_list|(
name|cell
argument_list|,
name|output
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
comment|/**    * @deprecated As of HBase-2.0. Will be removed in HBase-3.0.    *             Use {@link RawCell#cloneTags()}    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|byte
index|[]
name|cloneTags
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|cloneTags
argument_list|(
name|cell
argument_list|)
return|;
block|}
comment|/**    * Returns tag value in a new byte array. If server-side, use {@link Tag#getValueArray()} with    * appropriate {@link Tag#getValueOffset()} and {@link Tag#getValueLength()} instead to save on    * allocations.    * @param cell    * @return tag value in a new byte array.    * @deprecated As of HBase-2.0. Will be removed in HBase-3.0    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|byte
index|[]
name|getTagArray
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|cloneTags
argument_list|(
name|cell
argument_list|)
return|;
block|}
comment|/**    * Makes a column in family:qualifier form from separate byte arrays.    *<p>    * Not recommended for usage as this is old-style API.    * @param family    * @param qualifier    * @return family:qualifier    */
specifier|public
specifier|static
name|byte
index|[]
name|makeColumn
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|add
argument_list|(
name|family
argument_list|,
name|COLUMN_FAMILY_DELIM_ARRAY
argument_list|,
name|qualifier
argument_list|)
return|;
block|}
comment|/**    * Splits a column in {@code family:qualifier} form into separate byte arrays. An empty qualifier    * (ie, {@code fam:}) is parsed as<code>{ fam, EMPTY_BYTE_ARRAY }</code> while no delimiter (ie,    * {@code fam}) is parsed as an array of one element,<code>{ fam }</code>.    *<p>    * Don't forget, HBase DOES support empty qualifiers. (see HBASE-9549)    *</p>    *<p>    * Not recommend to be used as this is old-style API.    *</p>    * @param c The column.    * @return The parsed column.    */
specifier|public
specifier|static
name|byte
index|[]
index|[]
name|parseColumn
parameter_list|(
name|byte
index|[]
name|c
parameter_list|)
block|{
specifier|final
name|int
name|index
init|=
name|getDelimiter
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
name|c
operator|.
name|length
argument_list|,
name|COLUMN_FAMILY_DELIMITER
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
comment|// If no delimiter, return array of size 1
return|return
operator|new
name|byte
index|[]
index|[]
block|{
name|c
block|}
return|;
block|}
elseif|else
if|if
condition|(
name|index
operator|==
name|c
operator|.
name|length
operator|-
literal|1
condition|)
block|{
comment|// family with empty qualifier, return array size 2
name|byte
index|[]
name|family
init|=
operator|new
name|byte
index|[
name|c
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
name|family
argument_list|,
literal|0
argument_list|,
name|family
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
operator|new
name|byte
index|[]
index|[]
block|{
name|family
block|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
block|}
return|;
block|}
comment|// Family and column, return array size 2
specifier|final
name|byte
index|[]
index|[]
name|result
init|=
operator|new
name|byte
index|[
literal|2
index|]
index|[]
decl_stmt|;
name|result
index|[
literal|0
index|]
operator|=
operator|new
name|byte
index|[
name|index
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
name|result
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|index
argument_list|)
expr_stmt|;
specifier|final
name|int
name|len
init|=
name|c
operator|.
name|length
operator|-
operator|(
name|index
operator|+
literal|1
operator|)
decl_stmt|;
name|result
index|[
literal|1
index|]
operator|=
operator|new
name|byte
index|[
name|len
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|c
argument_list|,
name|index
operator|+
literal|1
comment|/* Skip delimiter */
argument_list|,
name|result
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/******************** copyTo **********************************/
comment|/**    * Copies the row to the given byte[]    * @param cell the cell whose row has to be copied    * @param destination the destination byte[] to which the row has to be copied    * @param destinationOffset the offset in the destination byte[]    * @return the offset of the byte[] after the copy has happened    */
specifier|public
specifier|static
name|int
name|copyRowTo
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|byte
index|[]
name|destination
parameter_list|,
name|int
name|destinationOffset
parameter_list|)
block|{
name|short
name|rowLen
init|=
name|cell
operator|.
name|getRowLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|cell
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
name|ByteBufferUtils
operator|.
name|copyFromBufferToArray
argument_list|(
name|destination
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getRowByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getRowPosition
argument_list|()
argument_list|,
name|destinationOffset
argument_list|,
name|rowLen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|cell
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|destination
argument_list|,
name|destinationOffset
argument_list|,
name|rowLen
argument_list|)
expr_stmt|;
block|}
return|return
name|destinationOffset
operator|+
name|rowLen
return|;
block|}
comment|/**    * Copies the row to the given bytebuffer    * @param cell cell the cell whose row has to be copied    * @param destination the destination bytebuffer to which the row has to be copied    * @param destinationOffset the offset in the destination byte[]    * @return the offset of the bytebuffer after the copy has happened    */
specifier|public
specifier|static
name|int
name|copyRowTo
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|ByteBuffer
name|destination
parameter_list|,
name|int
name|destinationOffset
parameter_list|)
block|{
name|short
name|rowLen
init|=
name|cell
operator|.
name|getRowLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|cell
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
name|ByteBufferUtils
operator|.
name|copyFromBufferToBuffer
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getRowByteBuffer
argument_list|()
argument_list|,
name|destination
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getRowPosition
argument_list|()
argument_list|,
name|destinationOffset
argument_list|,
name|rowLen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ByteBufferUtils
operator|.
name|copyFromArrayToBuffer
argument_list|(
name|destination
argument_list|,
name|destinationOffset
argument_list|,
name|cell
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|rowLen
argument_list|)
expr_stmt|;
block|}
return|return
name|destinationOffset
operator|+
name|rowLen
return|;
block|}
comment|/**    * Copies the row to a new byte[]    * @param cell the cell from which row has to copied    * @return the byte[] containing the row    */
specifier|public
specifier|static
name|byte
index|[]
name|copyRow
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
if|if
condition|(
name|cell
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|copyOfRange
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getRowByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getRowPosition
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getRowPosition
argument_list|()
operator|+
name|cell
operator|.
name|getRowLength
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|cell
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getRowOffset
argument_list|()
operator|+
name|cell
operator|.
name|getRowLength
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * Copies the family to the given byte[]    * @param cell the cell whose family has to be copied    * @param destination the destination byte[] to which the family has to be copied    * @param destinationOffset the offset in the destination byte[]    * @return the offset of the byte[] after the copy has happened    */
specifier|public
specifier|static
name|int
name|copyFamilyTo
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|byte
index|[]
name|destination
parameter_list|,
name|int
name|destinationOffset
parameter_list|)
block|{
name|byte
name|fLen
init|=
name|cell
operator|.
name|getFamilyLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|cell
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
name|ByteBufferUtils
operator|.
name|copyFromBufferToArray
argument_list|(
name|destination
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getFamilyByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getFamilyPosition
argument_list|()
argument_list|,
name|destinationOffset
argument_list|,
name|fLen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|cell
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|destination
argument_list|,
name|destinationOffset
argument_list|,
name|fLen
argument_list|)
expr_stmt|;
block|}
return|return
name|destinationOffset
operator|+
name|fLen
return|;
block|}
comment|/**    * Copies the family to the given bytebuffer    * @param cell the cell whose family has to be copied    * @param destination the destination bytebuffer to which the family has to be copied    * @param destinationOffset the offset in the destination bytebuffer    * @return the offset of the bytebuffer after the copy has happened    */
specifier|public
specifier|static
name|int
name|copyFamilyTo
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|ByteBuffer
name|destination
parameter_list|,
name|int
name|destinationOffset
parameter_list|)
block|{
name|byte
name|fLen
init|=
name|cell
operator|.
name|getFamilyLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|cell
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
name|ByteBufferUtils
operator|.
name|copyFromBufferToBuffer
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getFamilyByteBuffer
argument_list|()
argument_list|,
name|destination
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getFamilyPosition
argument_list|()
argument_list|,
name|destinationOffset
argument_list|,
name|fLen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ByteBufferUtils
operator|.
name|copyFromArrayToBuffer
argument_list|(
name|destination
argument_list|,
name|destinationOffset
argument_list|,
name|cell
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|fLen
argument_list|)
expr_stmt|;
block|}
return|return
name|destinationOffset
operator|+
name|fLen
return|;
block|}
comment|/**    * Copies the qualifier to the given byte[]    * @param cell the cell whose qualifier has to be copied    * @param destination the destination byte[] to which the qualifier has to be copied    * @param destinationOffset the offset in the destination byte[]    * @return the offset of the byte[] after the copy has happened    */
specifier|public
specifier|static
name|int
name|copyQualifierTo
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|byte
index|[]
name|destination
parameter_list|,
name|int
name|destinationOffset
parameter_list|)
block|{
name|int
name|qlen
init|=
name|cell
operator|.
name|getQualifierLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|cell
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
name|ByteBufferUtils
operator|.
name|copyFromBufferToArray
argument_list|(
name|destination
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getQualifierByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getQualifierPosition
argument_list|()
argument_list|,
name|destinationOffset
argument_list|,
name|qlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|cell
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|destination
argument_list|,
name|destinationOffset
argument_list|,
name|qlen
argument_list|)
expr_stmt|;
block|}
return|return
name|destinationOffset
operator|+
name|qlen
return|;
block|}
comment|/**    * Copies the qualifier to the given bytebuffer    * @param cell the cell whose qualifier has to be copied    * @param destination the destination bytebuffer to which the qualifier has to be copied    * @param destinationOffset the offset in the destination bytebuffer    * @return the offset of the bytebuffer after the copy has happened    */
specifier|public
specifier|static
name|int
name|copyQualifierTo
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|ByteBuffer
name|destination
parameter_list|,
name|int
name|destinationOffset
parameter_list|)
block|{
name|int
name|qlen
init|=
name|cell
operator|.
name|getQualifierLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|cell
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
name|ByteBufferUtils
operator|.
name|copyFromBufferToBuffer
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getQualifierByteBuffer
argument_list|()
argument_list|,
name|destination
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getQualifierPosition
argument_list|()
argument_list|,
name|destinationOffset
argument_list|,
name|qlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ByteBufferUtils
operator|.
name|copyFromArrayToBuffer
argument_list|(
name|destination
argument_list|,
name|destinationOffset
argument_list|,
name|cell
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|qlen
argument_list|)
expr_stmt|;
block|}
return|return
name|destinationOffset
operator|+
name|qlen
return|;
block|}
comment|/**    * Copies the value to the given byte[]    * @param cell the cell whose value has to be copied    * @param destination the destination byte[] to which the value has to be copied    * @param destinationOffset the offset in the destination byte[]    * @return the offset of the byte[] after the copy has happened    */
specifier|public
specifier|static
name|int
name|copyValueTo
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|byte
index|[]
name|destination
parameter_list|,
name|int
name|destinationOffset
parameter_list|)
block|{
name|int
name|vlen
init|=
name|cell
operator|.
name|getValueLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|cell
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
name|ByteBufferUtils
operator|.
name|copyFromBufferToArray
argument_list|(
name|destination
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getValueByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getValuePosition
argument_list|()
argument_list|,
name|destinationOffset
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|cell
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|destination
argument_list|,
name|destinationOffset
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
block|}
return|return
name|destinationOffset
operator|+
name|vlen
return|;
block|}
comment|/**    * Copies the value to the given bytebuffer    * @param cell the cell whose value has to be copied    * @param destination the destination bytebuffer to which the value has to be copied    * @param destinationOffset the offset in the destination bytebuffer    * @return the offset of the bytebuffer after the copy has happened    */
specifier|public
specifier|static
name|int
name|copyValueTo
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|ByteBuffer
name|destination
parameter_list|,
name|int
name|destinationOffset
parameter_list|)
block|{
name|int
name|vlen
init|=
name|cell
operator|.
name|getValueLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|cell
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
name|ByteBufferUtils
operator|.
name|copyFromBufferToBuffer
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getValueByteBuffer
argument_list|()
argument_list|,
name|destination
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getValuePosition
argument_list|()
argument_list|,
name|destinationOffset
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ByteBufferUtils
operator|.
name|copyFromArrayToBuffer
argument_list|(
name|destination
argument_list|,
name|destinationOffset
argument_list|,
name|cell
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
block|}
return|return
name|destinationOffset
operator|+
name|vlen
return|;
block|}
comment|/**    * Copies the tags info into the tag portion of the cell    * @param cell    * @param destination    * @param destinationOffset    * @return position after tags    * @deprecated As of HBase-2.0. Will be removed in HBase-3.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|int
name|copyTagTo
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|byte
index|[]
name|destination
parameter_list|,
name|int
name|destinationOffset
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|copyTagsTo
argument_list|(
name|cell
argument_list|,
name|destination
argument_list|,
name|destinationOffset
argument_list|)
return|;
block|}
comment|/**    * Copies the tags info into the tag portion of the cell    * @param cell    * @param destination    * @param destinationOffset    * @return position after tags    * @deprecated As of HBase-2.0. Will be removed in 3.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|int
name|copyTagTo
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|ByteBuffer
name|destination
parameter_list|,
name|int
name|destinationOffset
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|copyTagsTo
argument_list|(
name|cell
argument_list|,
name|destination
argument_list|,
name|destinationOffset
argument_list|)
return|;
block|}
comment|/********************* misc *************************************/
annotation|@
name|Private
comment|/**    * @deprecated As of HBase-2.0. Will be removed in HBase-3.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|byte
name|getRowByte
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|int
name|index
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|getRowByte
argument_list|(
name|cell
argument_list|,
name|index
argument_list|)
return|;
block|}
comment|/**    * @deprecated As of HBase-2.0. Will be removed in 3.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|ByteBuffer
name|getValueBufferShallowCopy
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|getValueBufferShallowCopy
argument_list|(
name|cell
argument_list|)
return|;
block|}
comment|/**    * @param cell    * @return cell's qualifier wrapped into a ByteBuffer.    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|ByteBuffer
name|getQualifierBufferShallowCopy
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
comment|// No usage of this in code.
name|ByteBuffer
name|buffer
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|cell
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getQualifierLength
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|buffer
return|;
block|}
comment|/**    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. Use {@link CellBuilder}    *             instead    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|Cell
name|createCell
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|byte
name|type
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|)
block|{
return|return
name|ExtendedCellBuilderFactory
operator|.
name|create
argument_list|(
name|CellBuilderType
operator|.
name|DEEP_COPY
argument_list|)
operator|.
name|setRow
argument_list|(
name|row
argument_list|)
operator|.
name|setFamily
argument_list|(
name|family
argument_list|)
operator|.
name|setQualifier
argument_list|(
name|qualifier
argument_list|)
operator|.
name|setTimestamp
argument_list|(
name|timestamp
argument_list|)
operator|.
name|setType
argument_list|(
name|type
argument_list|)
operator|.
name|setValue
argument_list|(
name|value
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Creates a cell with deep copy of all passed bytes.    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. Use {@link CellBuilder}    *             instead    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|Cell
name|createCell
parameter_list|(
specifier|final
name|byte
index|[]
name|rowArray
parameter_list|,
specifier|final
name|int
name|rowOffset
parameter_list|,
specifier|final
name|int
name|rowLength
parameter_list|,
specifier|final
name|byte
index|[]
name|familyArray
parameter_list|,
specifier|final
name|int
name|familyOffset
parameter_list|,
specifier|final
name|int
name|familyLength
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifierArray
parameter_list|,
specifier|final
name|int
name|qualifierOffset
parameter_list|,
specifier|final
name|int
name|qualifierLength
parameter_list|)
block|{
comment|// See createCell(final byte [] row, final byte [] value) for why we default Maximum type.
return|return
name|ExtendedCellBuilderFactory
operator|.
name|create
argument_list|(
name|CellBuilderType
operator|.
name|DEEP_COPY
argument_list|)
operator|.
name|setRow
argument_list|(
name|rowArray
argument_list|,
name|rowOffset
argument_list|,
name|rowLength
argument_list|)
operator|.
name|setFamily
argument_list|(
name|familyArray
argument_list|,
name|familyOffset
argument_list|,
name|familyLength
argument_list|)
operator|.
name|setQualifier
argument_list|(
name|qualifierArray
argument_list|,
name|qualifierOffset
argument_list|,
name|qualifierLength
argument_list|)
operator|.
name|setTimestamp
argument_list|(
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|)
operator|.
name|setType
argument_list|(
name|KeyValue
operator|.
name|Type
operator|.
name|Maximum
operator|.
name|getCode
argument_list|()
argument_list|)
operator|.
name|setValue
argument_list|(
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|,
literal|0
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
operator|.
name|length
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Marked as audience Private as of 1.2.0.    * Creating a Cell with a memstoreTS/mvcc is an internal    * implementation detail not for public use.    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. Use    *             {@link ExtendedCellBuilder} instead    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|Deprecated
specifier|public
specifier|static
name|Cell
name|createCell
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|byte
name|type
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|long
name|memstoreTS
parameter_list|)
block|{
return|return
name|createCell
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|timestamp
argument_list|,
name|type
argument_list|,
name|value
argument_list|,
literal|null
argument_list|,
name|memstoreTS
argument_list|)
return|;
block|}
comment|/**    * Marked as audience Private as of 1.2.0.    * Creating a Cell with tags and a memstoreTS/mvcc is an    * internal implementation detail not for public use.    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. Use    *             {@link ExtendedCellBuilder} instead    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|Deprecated
specifier|public
specifier|static
name|Cell
name|createCell
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|byte
name|type
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
name|byte
index|[]
name|tags
parameter_list|,
specifier|final
name|long
name|memstoreTS
parameter_list|)
block|{
return|return
name|ExtendedCellBuilderFactory
operator|.
name|create
argument_list|(
name|CellBuilderType
operator|.
name|DEEP_COPY
argument_list|)
operator|.
name|setRow
argument_list|(
name|row
argument_list|)
operator|.
name|setFamily
argument_list|(
name|family
argument_list|)
operator|.
name|setQualifier
argument_list|(
name|qualifier
argument_list|)
operator|.
name|setTimestamp
argument_list|(
name|timestamp
argument_list|)
operator|.
name|setType
argument_list|(
name|type
argument_list|)
operator|.
name|setValue
argument_list|(
name|value
argument_list|)
operator|.
name|setTags
argument_list|(
name|tags
argument_list|)
operator|.
name|setSequenceId
argument_list|(
name|memstoreTS
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Marked as audience Private as of 1.2.0.    * Creating a Cell with tags is an internal implementation detail not for public use.    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. Use    *             {@link ExtendedCellBuilder} instead    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|Deprecated
specifier|public
specifier|static
name|Cell
name|createCell
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
name|Type
name|type
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
name|byte
index|[]
name|tags
parameter_list|)
block|{
return|return
name|createCell
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|timestamp
argument_list|,
name|type
operator|.
name|getCode
argument_list|()
argument_list|,
name|value
argument_list|,
name|tags
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Create a Cell with specific row. Other fields defaulted.    * @param row    * @return Cell with passed row but all other fields are arbitrary    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. Use {@link CellBuilder}    *             instead    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|Cell
name|createCell
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|)
block|{
return|return
name|createCell
argument_list|(
name|row
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|)
return|;
block|}
comment|/**    * Create a Cell with specific row and value. Other fields are defaulted.    * @param row    * @param value    * @return Cell with passed row and value but all other fields are arbitrary    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0. Use {@link CellBuilder}    *             instead    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|Cell
name|createCell
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|)
block|{
comment|// An empty family + empty qualifier + Type.Minimum is used as flag to indicate last on row.
comment|// See the CellComparator and KeyValue comparator. Search for compareWithoutRow.
comment|// Lets not make a last-on-row key as default but at same time, if you are making a key
comment|// without specifying type, etc., flag it as weird by setting type to be Maximum.
return|return
name|createCell
argument_list|(
name|row
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|,
name|KeyValue
operator|.
name|Type
operator|.
name|Maximum
operator|.
name|getCode
argument_list|()
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/**    * Create a Cell with specific row.  Other fields defaulted.    * @param row    * @param family    * @param qualifier    * @return Cell with passed row but all other fields are arbitrary    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    *             Use {@link CellBuilder} instead    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|Cell
name|createCell
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
comment|// See above in createCell(final byte [] row, final byte [] value) why we set type to Maximum.
return|return
name|createCell
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|,
name|KeyValue
operator|.
name|Type
operator|.
name|Maximum
operator|.
name|getCode
argument_list|()
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|)
return|;
block|}
comment|/**    * Note : Now only CPs can create cell with tags using the CP environment    * @return A new cell which is having the extra tags also added to it.    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    *    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|Cell
name|createCell
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|List
argument_list|<
name|Tag
argument_list|>
name|tags
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|createCell
argument_list|(
name|cell
argument_list|,
name|tags
argument_list|)
return|;
block|}
comment|/**    * Now only CPs can create cell with tags using the CP environment    * @return A new cell which is having the extra tags also added to it.    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|Cell
name|createCell
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|byte
index|[]
name|tags
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|createCell
argument_list|(
name|cell
argument_list|,
name|tags
argument_list|)
return|;
block|}
comment|/**    * Now only CPs can create cell with tags using the CP environment    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|Cell
name|createCell
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|byte
index|[]
name|value
parameter_list|,
name|byte
index|[]
name|tags
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|createCell
argument_list|(
name|cell
argument_list|,
name|value
argument_list|,
name|tags
argument_list|)
return|;
block|}
comment|/**    * @param cellScannerables    * @return CellScanner interface over<code>cellIterables</code>    */
specifier|public
specifier|static
name|CellScanner
name|createCellScanner
parameter_list|(
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|CellScannable
argument_list|>
name|cellScannerables
parameter_list|)
block|{
return|return
operator|new
name|CellScanner
argument_list|()
block|{
specifier|private
specifier|final
name|Iterator
argument_list|<
name|?
extends|extends
name|CellScannable
argument_list|>
name|iterator
init|=
name|cellScannerables
operator|.
name|iterator
argument_list|()
decl_stmt|;
specifier|private
name|CellScanner
name|cellScanner
init|=
literal|null
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Cell
name|current
parameter_list|()
block|{
return|return
name|this
operator|.
name|cellScanner
operator|!=
literal|null
condition|?
name|this
operator|.
name|cellScanner
operator|.
name|current
argument_list|()
else|:
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|advance
parameter_list|()
throws|throws
name|IOException
block|{
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|cellScanner
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
return|return
literal|false
return|;
name|this
operator|.
name|cellScanner
operator|=
name|this
operator|.
name|iterator
operator|.
name|next
argument_list|()
operator|.
name|cellScanner
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|cellScanner
operator|.
name|advance
argument_list|()
condition|)
return|return
literal|true
return|;
name|this
operator|.
name|cellScanner
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
return|;
block|}
comment|/**    * @param cellIterable    * @return CellScanner interface over<code>cellIterable</code>    */
specifier|public
specifier|static
name|CellScanner
name|createCellScanner
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|Cell
argument_list|>
name|cellIterable
parameter_list|)
block|{
if|if
condition|(
name|cellIterable
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|createCellScanner
argument_list|(
name|cellIterable
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @param cells    * @return CellScanner interface over<code>cellIterable</code> or null if<code>cells</code> is    * null    */
specifier|public
specifier|static
name|CellScanner
name|createCellScanner
parameter_list|(
specifier|final
name|Iterator
argument_list|<
name|Cell
argument_list|>
name|cells
parameter_list|)
block|{
if|if
condition|(
name|cells
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
operator|new
name|CellScanner
argument_list|()
block|{
specifier|private
specifier|final
name|Iterator
argument_list|<
name|Cell
argument_list|>
name|iterator
init|=
name|cells
decl_stmt|;
specifier|private
name|Cell
name|current
init|=
literal|null
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Cell
name|current
parameter_list|()
block|{
return|return
name|this
operator|.
name|current
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|advance
parameter_list|()
block|{
name|boolean
name|hasNext
init|=
name|this
operator|.
name|iterator
operator|.
name|hasNext
argument_list|()
decl_stmt|;
name|this
operator|.
name|current
operator|=
name|hasNext
condition|?
name|this
operator|.
name|iterator
operator|.
name|next
argument_list|()
else|:
literal|null
expr_stmt|;
return|return
name|hasNext
return|;
block|}
block|}
return|;
block|}
comment|/**    * @param cellArray    * @return CellScanner interface over<code>cellArray</code>    */
specifier|public
specifier|static
name|CellScanner
name|createCellScanner
parameter_list|(
specifier|final
name|Cell
index|[]
name|cellArray
parameter_list|)
block|{
return|return
operator|new
name|CellScanner
argument_list|()
block|{
specifier|private
specifier|final
name|Cell
index|[]
name|cells
init|=
name|cellArray
decl_stmt|;
specifier|private
name|int
name|index
init|=
operator|-
literal|1
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Cell
name|current
parameter_list|()
block|{
if|if
condition|(
name|cells
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
operator|(
name|index
operator|<
literal|0
operator|)
condition|?
literal|null
else|:
name|this
operator|.
name|cells
index|[
name|index
index|]
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|advance
parameter_list|()
block|{
if|if
condition|(
name|cells
operator|==
literal|null
condition|)
return|return
literal|false
return|;
return|return
operator|++
name|index
operator|<
name|this
operator|.
name|cells
operator|.
name|length
return|;
block|}
block|}
return|;
block|}
comment|/**    * Flatten the map of cells out under the CellScanner    * @param map Map of Cell Lists; for example, the map of families to Cells that is used    * inside Put, etc., keeping Cells organized by family.    * @return CellScanner interface over<code>cellIterable</code>    */
specifier|public
specifier|static
name|CellScanner
name|createCellScanner
parameter_list|(
specifier|final
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|List
argument_list|<
name|Cell
argument_list|>
argument_list|>
name|map
parameter_list|)
block|{
return|return
operator|new
name|CellScanner
argument_list|()
block|{
specifier|private
specifier|final
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|List
argument_list|<
name|Cell
argument_list|>
argument_list|>
argument_list|>
name|entries
init|=
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
specifier|private
name|Iterator
argument_list|<
name|Cell
argument_list|>
name|currentIterator
init|=
literal|null
decl_stmt|;
specifier|private
name|Cell
name|currentCell
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Cell
name|current
parameter_list|()
block|{
return|return
name|this
operator|.
name|currentCell
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|advance
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|currentIterator
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|entries
operator|.
name|hasNext
argument_list|()
condition|)
return|return
literal|false
return|;
name|this
operator|.
name|currentIterator
operator|=
name|this
operator|.
name|entries
operator|.
name|next
argument_list|()
operator|.
name|getValue
argument_list|()
operator|.
name|iterator
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|currentIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|this
operator|.
name|currentCell
operator|=
name|this
operator|.
name|currentIterator
operator|.
name|next
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
name|this
operator|.
name|currentCell
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|currentIterator
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
return|;
block|}
comment|/**    * @param left    * @param right    * @return True if the rows in<code>left</code> and<code>right</code> Cells match    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    *             Instead use {@link #matchingRows(Cell, Cell)}    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|boolean
name|matchingRow
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|)
block|{
return|return
name|matchingRows
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/**    *  @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    *             Instead use {@link #matchingRows(Cell, byte[])}    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|boolean
name|matchingRow
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|byte
index|[]
name|buf
parameter_list|)
block|{
return|return
name|matchingRows
argument_list|(
name|left
argument_list|,
name|buf
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|matchingRows
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|byte
index|[]
name|buf
parameter_list|)
block|{
if|if
condition|(
name|buf
operator|==
literal|null
condition|)
block|{
return|return
name|left
operator|.
name|getRowLength
argument_list|()
operator|==
literal|0
return|;
block|}
return|return
name|PrivateCellUtil
operator|.
name|matchingRows
argument_list|(
name|left
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|matchingRow
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|byte
index|[]
name|buf
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|matchingRows
argument_list|(
name|left
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|matchingFamily
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|)
block|{
name|byte
name|lfamlength
init|=
name|left
operator|.
name|getFamilyLength
argument_list|()
decl_stmt|;
name|byte
name|rfamlength
init|=
name|right
operator|.
name|getFamilyLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferExtendedCell
operator|&&
name|right
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getFamilyByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getFamilyPosition
argument_list|()
argument_list|,
name|lfamlength
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getFamilyByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getFamilyPosition
argument_list|()
argument_list|,
name|rfamlength
argument_list|)
return|;
block|}
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getFamilyByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getFamilyPosition
argument_list|()
argument_list|,
name|lfamlength
argument_list|,
name|right
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|rfamlength
argument_list|)
return|;
block|}
if|if
condition|(
name|right
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getFamilyByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getFamilyPosition
argument_list|()
argument_list|,
name|rfamlength
argument_list|,
name|left
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|lfamlength
argument_list|)
return|;
block|}
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|left
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|lfamlength
argument_list|,
name|right
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|rfamlength
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|matchingFamily
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|byte
index|[]
name|buf
parameter_list|)
block|{
if|if
condition|(
name|buf
operator|==
literal|null
condition|)
block|{
return|return
name|left
operator|.
name|getFamilyLength
argument_list|()
operator|==
literal|0
return|;
block|}
return|return
name|matchingFamily
argument_list|(
name|left
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|boolean
name|matchingFamily
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|byte
index|[]
name|buf
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|matchingFamily
argument_list|(
name|left
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|matchingQualifier
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|)
block|{
name|int
name|lqlength
init|=
name|left
operator|.
name|getQualifierLength
argument_list|()
decl_stmt|;
name|int
name|rqlength
init|=
name|right
operator|.
name|getQualifierLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferExtendedCell
operator|&&
name|right
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getQualifierByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getQualifierPosition
argument_list|()
argument_list|,
name|lqlength
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getQualifierByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getQualifierPosition
argument_list|()
argument_list|,
name|rqlength
argument_list|)
return|;
block|}
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getQualifierByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getQualifierPosition
argument_list|()
argument_list|,
name|lqlength
argument_list|,
name|right
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|right
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|rqlength
argument_list|)
return|;
block|}
if|if
condition|(
name|right
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getQualifierByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getQualifierPosition
argument_list|()
argument_list|,
name|rqlength
argument_list|,
name|left
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|lqlength
argument_list|)
return|;
block|}
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|left
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|lqlength
argument_list|,
name|right
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|right
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|rqlength
argument_list|)
return|;
block|}
comment|/**    * Finds if the qualifier part of the cell and the KV serialized    * byte[] are equal    * @param left    * @param buf the serialized keyvalue format byte[]    * @return true if the qualifier matches, false otherwise    */
specifier|public
specifier|static
name|boolean
name|matchingQualifier
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|byte
index|[]
name|buf
parameter_list|)
block|{
if|if
condition|(
name|buf
operator|==
literal|null
condition|)
block|{
return|return
name|left
operator|.
name|getQualifierLength
argument_list|()
operator|==
literal|0
return|;
block|}
return|return
name|matchingQualifier
argument_list|(
name|left
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * Finds if the qualifier part of the cell and the KV serialized    * byte[] are equal    * @param left    * @param buf the serialized keyvalue format byte[]    * @param offset the offset of the qualifier in the byte[]    * @param length the length of the qualifier in the byte[]    * @return true if the qualifier matches, false otherwise    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|boolean
name|matchingQualifier
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|byte
index|[]
name|buf
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|matchingQualifier
argument_list|(
name|left
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|matchingColumn
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|byte
index|[]
name|fam
parameter_list|,
specifier|final
name|byte
index|[]
name|qual
parameter_list|)
block|{
if|if
condition|(
operator|!
name|matchingFamily
argument_list|(
name|left
argument_list|,
name|fam
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
name|matchingQualifier
argument_list|(
name|left
argument_list|,
name|qual
argument_list|)
return|;
block|}
comment|/**    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|boolean
name|matchingColumn
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|byte
index|[]
name|fam
parameter_list|,
specifier|final
name|int
name|foffset
parameter_list|,
specifier|final
name|int
name|flength
parameter_list|,
specifier|final
name|byte
index|[]
name|qual
parameter_list|,
specifier|final
name|int
name|qoffset
parameter_list|,
specifier|final
name|int
name|qlength
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|matchingColumn
argument_list|(
name|left
argument_list|,
name|fam
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qual
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|matchingColumn
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|)
block|{
if|if
condition|(
operator|!
name|matchingFamily
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
name|matchingQualifier
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|matchingValue
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|)
block|{
return|return
name|matchingValue
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|left
operator|.
name|getValueLength
argument_list|()
argument_list|,
name|right
operator|.
name|getValueLength
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|matchingValue
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|,
name|int
name|lvlength
parameter_list|,
name|int
name|rvlength
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferExtendedCell
operator|&&
name|right
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getValueByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getValuePosition
argument_list|()
argument_list|,
name|lvlength
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getValueByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getValuePosition
argument_list|()
argument_list|,
name|rvlength
argument_list|)
return|;
block|}
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getValueByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getValuePosition
argument_list|()
argument_list|,
name|lvlength
argument_list|,
name|right
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|right
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|rvlength
argument_list|)
return|;
block|}
if|if
condition|(
name|right
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getValueByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getValuePosition
argument_list|()
argument_list|,
name|rvlength
argument_list|,
name|left
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|left
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|lvlength
argument_list|)
return|;
block|}
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|left
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|left
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|lvlength
argument_list|,
name|right
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|right
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|rvlength
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|matchingValue
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|byte
index|[]
name|buf
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|compareTo
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getValueByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getValuePosition
argument_list|()
argument_list|,
name|left
operator|.
name|getValueLength
argument_list|()
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|)
operator|==
literal|0
return|;
block|}
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|left
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|left
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getValueLength
argument_list|()
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * @return True if a delete type, a {@link KeyValue.Type#Delete} or a    *         {KeyValue.Type#DeleteFamily} or a    *         {@link KeyValue.Type#DeleteColumn} KeyValue type.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|public
specifier|static
name|boolean
name|isDelete
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|isDelete
argument_list|(
name|cell
operator|.
name|getTypeByte
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @return True if a delete type, a {@link KeyValue.Type#Delete} or a    *         {KeyValue.Type#DeleteFamily} or a    *         {@link KeyValue.Type#DeleteColumn} KeyValue type.    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|boolean
name|isDelete
parameter_list|(
specifier|final
name|byte
name|type
parameter_list|)
block|{
return|return
name|Type
operator|.
name|Delete
operator|.
name|getCode
argument_list|()
operator|<=
name|type
operator|&&
name|type
operator|<=
name|Type
operator|.
name|DeleteFamily
operator|.
name|getCode
argument_list|()
return|;
block|}
comment|/**    * @return True if this cell is a {@link KeyValue.Type#Delete} type.    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|boolean
name|isDeleteType
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
return|return
name|cell
operator|.
name|getTypeByte
argument_list|()
operator|==
name|Type
operator|.
name|Delete
operator|.
name|getCode
argument_list|()
return|;
block|}
comment|/**    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|boolean
name|isDeleteFamily
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
return|return
name|cell
operator|.
name|getTypeByte
argument_list|()
operator|==
name|Type
operator|.
name|DeleteFamily
operator|.
name|getCode
argument_list|()
return|;
block|}
comment|/**    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|boolean
name|isDeleteFamilyVersion
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
return|return
name|cell
operator|.
name|getTypeByte
argument_list|()
operator|==
name|Type
operator|.
name|DeleteFamilyVersion
operator|.
name|getCode
argument_list|()
return|;
block|}
comment|/**    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|boolean
name|isDeleteColumns
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
return|return
name|cell
operator|.
name|getTypeByte
argument_list|()
operator|==
name|Type
operator|.
name|DeleteColumn
operator|.
name|getCode
argument_list|()
return|;
block|}
comment|/**    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|boolean
name|isDeleteColumnVersion
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
return|return
name|cell
operator|.
name|getTypeByte
argument_list|()
operator|==
name|Type
operator|.
name|Delete
operator|.
name|getCode
argument_list|()
return|;
block|}
comment|/**    *    * @return True if this cell is a delete family or column type.    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|boolean
name|isDeleteColumnOrFamily
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
name|int
name|t
init|=
name|cell
operator|.
name|getTypeByte
argument_list|()
decl_stmt|;
return|return
name|t
operator|==
name|Type
operator|.
name|DeleteColumn
operator|.
name|getCode
argument_list|()
operator|||
name|t
operator|==
name|Type
operator|.
name|DeleteFamily
operator|.
name|getCode
argument_list|()
return|;
block|}
comment|/**    * @return True if this cell is a Put.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|public
specifier|static
name|boolean
name|isPut
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
return|return
name|cell
operator|.
name|getTypeByte
argument_list|()
operator|==
name|Type
operator|.
name|Put
operator|.
name|getCode
argument_list|()
return|;
block|}
comment|/**    * Estimate based on keyvalue's serialization format in the RPC layer. Note that there is an extra    * SIZEOF_INT added to the size here that indicates the actual length of the cell for cases where    * cell's are serialized in a contiguous format (For eg in RPCs).    * @param cell    * @return Estimate of the<code>cell</code> size in bytes plus an extra SIZEOF_INT indicating the    *         actual cell length.    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|int
name|estimatedSerializedSizeOf
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|estimatedSerializedSizeOf
argument_list|(
name|cell
argument_list|)
return|;
block|}
comment|/**    * Calculates the serialized key size. We always serialize in the KeyValue's serialization    * format.    * @param cell the cell for which the key size has to be calculated.    * @return the key size    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|int
name|estimatedSerializedSizeOfKey
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|estimatedSerializedSizeOfKey
argument_list|(
name|cell
argument_list|)
return|;
block|}
comment|/**    * This is an estimate of the heap space occupied by a cell. When the cell is of type    * {@link HeapSize} we call {@link HeapSize#heapSize()} so cell can give a correct value. In other    * cases we just consider the bytes occupied by the cell components ie. row, CF, qualifier,    * timestamp, type, value and tags.    * @param cell    * @return estimate of the heap space    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|long
name|estimatedHeapSizeOf
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
return|return
name|cell
operator|.
name|heapSize
argument_list|()
return|;
block|}
comment|/********************* tags *************************************/
comment|/**    * Util method to iterate through the tags    *    * @param tags    * @param offset    * @param length    * @return iterator for the tags    * @deprecated As of 2.0.0 and will be removed in 3.0.0    *             Instead use {@link #tagsIterator(Cell)}    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|Iterator
argument_list|<
name|Tag
argument_list|>
name|tagsIterator
parameter_list|(
specifier|final
name|byte
index|[]
name|tags
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|)
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Tag
argument_list|>
argument_list|()
block|{
specifier|private
name|int
name|pos
init|=
name|offset
decl_stmt|;
specifier|private
name|int
name|endOffset
init|=
name|offset
operator|+
name|length
operator|-
literal|1
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|this
operator|.
name|pos
operator|<
name|endOffset
return|;
block|}
annotation|@
name|Override
specifier|public
name|Tag
name|next
parameter_list|()
block|{
if|if
condition|(
name|hasNext
argument_list|()
condition|)
block|{
name|int
name|curTagLen
init|=
name|Bytes
operator|.
name|readAsInt
argument_list|(
name|tags
argument_list|,
name|this
operator|.
name|pos
argument_list|,
name|Tag
operator|.
name|TAG_LENGTH_SIZE
argument_list|)
decl_stmt|;
name|Tag
name|tag
init|=
operator|new
name|ArrayBackedTag
argument_list|(
name|tags
argument_list|,
name|pos
argument_list|,
name|curTagLen
operator|+
name|TAG_LENGTH_SIZE
argument_list|)
decl_stmt|;
name|this
operator|.
name|pos
operator|+=
name|Bytes
operator|.
name|SIZEOF_SHORT
operator|+
name|curTagLen
expr_stmt|;
return|return
name|tag
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
comment|/**    * @param cell The Cell    * @return Tags in the given Cell as a List    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    *             Use {@link RawCell#getTags()}    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|List
argument_list|<
name|Tag
argument_list|>
name|getTags
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|getTags
argument_list|(
name|cell
argument_list|)
return|;
block|}
comment|/**    * Retrieve Cell's first tag, matching the passed in type    *    * @param cell The Cell    * @param type Type of the Tag to retrieve    * @return null if there is no tag of the passed in tag type    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    *             Use {@link RawCell#getTag(byte)}    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|Tag
name|getTag
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|byte
name|type
parameter_list|)
block|{
name|Optional
argument_list|<
name|Tag
argument_list|>
name|tag
init|=
name|PrivateCellUtil
operator|.
name|getTag
argument_list|(
name|cell
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|tag
operator|.
name|isPresent
argument_list|()
condition|)
block|{
return|return
name|tag
operator|.
name|get
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Returns true if the first range start1...end1 overlaps with the second range    * start2...end2, assuming the byte arrays represent row keys    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|boolean
name|overlappingKeys
parameter_list|(
specifier|final
name|byte
index|[]
name|start1
parameter_list|,
specifier|final
name|byte
index|[]
name|end1
parameter_list|,
specifier|final
name|byte
index|[]
name|start2
parameter_list|,
specifier|final
name|byte
index|[]
name|end2
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|overlappingKeys
argument_list|(
name|start1
argument_list|,
name|end1
argument_list|,
name|start2
argument_list|,
name|end2
argument_list|)
return|;
block|}
comment|/**    * Sets the given seqId to the cell.    * Marked as audience Private as of 1.2.0.    * Setting a Cell sequenceid is an internal implementation detail not for general public use.    * @param cell    * @param seqId    * @throws IOException when the passed cell is not of type {@link ExtendedCell}    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|void
name|setSequenceId
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|long
name|seqId
parameter_list|)
throws|throws
name|IOException
block|{
name|PrivateCellUtil
operator|.
name|setSequenceId
argument_list|(
name|cell
argument_list|,
name|seqId
argument_list|)
expr_stmt|;
block|}
comment|/**    * Sets the given timestamp to the cell.    *    * Note that this method is a LimitedPrivate API and may change between minor releases.    * @param cell    * @param ts    * @throws IOException when the passed cell is not of type {@link ExtendedCell}    */
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
name|HBaseInterfaceAudience
operator|.
name|COPROC
argument_list|)
specifier|public
specifier|static
name|void
name|setTimestamp
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|long
name|ts
parameter_list|)
throws|throws
name|IOException
block|{
name|PrivateCellUtil
operator|.
name|setTimestamp
argument_list|(
name|cell
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
comment|/**    * Sets the given timestamp to the cell.    *    * Note that this method is a LimitedPrivate API and may change between minor releases.    * @param cell    * @param ts buffer containing the timestamp value    * @param tsOffset offset to the new timestamp    * @throws IOException when the passed cell is not of type {@link ExtendedCell}    */
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
name|HBaseInterfaceAudience
operator|.
name|COPROC
argument_list|)
specifier|public
specifier|static
name|void
name|setTimestamp
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|byte
index|[]
name|ts
parameter_list|,
name|int
name|tsOffset
parameter_list|)
throws|throws
name|IOException
block|{
name|PrivateCellUtil
operator|.
name|setTimestamp
argument_list|(
name|cell
argument_list|,
name|Bytes
operator|.
name|toLong
argument_list|(
name|ts
argument_list|,
name|tsOffset
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Sets the given timestamp to the cell iff current timestamp is    * {@link HConstants#LATEST_TIMESTAMP}.    * @param cell    * @param ts    * @return True if cell timestamp is modified.    * @throws IOException when the passed cell is not of type {@link ExtendedCell}    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|boolean
name|updateLatestStamp
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|long
name|ts
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|PrivateCellUtil
operator|.
name|updateLatestStamp
argument_list|(
name|cell
argument_list|,
name|ts
argument_list|)
return|;
block|}
comment|/**    * Sets the given timestamp to the cell iff current timestamp is    * {@link HConstants#LATEST_TIMESTAMP}.    * @param cell    * @param ts buffer containing the timestamp value    * @param tsOffset offset to the new timestamp    * @return True if cell timestamp is modified.    * @throws IOException when the passed cell is not of type {@link ExtendedCell}    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|boolean
name|updateLatestStamp
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|byte
index|[]
name|ts
parameter_list|,
name|int
name|tsOffset
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|PrivateCellUtil
operator|.
name|updateLatestStamp
argument_list|(
name|cell
argument_list|,
name|Bytes
operator|.
name|toLong
argument_list|(
name|ts
argument_list|,
name|tsOffset
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|int
name|writeFlatKey
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|PrivateCellUtil
operator|.
name|writeFlatKey
argument_list|(
name|cell
argument_list|,
name|out
argument_list|)
return|;
block|}
comment|/**    * Writes the row from the given cell to the output stream excluding the common prefix    * @param out The dataoutputstream to which the data has to be written    * @param cell The cell whose contents has to be written    * @param rlength the row length    * @throws IOException    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|void
name|writeRowSkippingBytes
parameter_list|(
name|DataOutputStream
name|out
parameter_list|,
name|Cell
name|cell
parameter_list|,
name|short
name|rlength
parameter_list|,
name|int
name|commonPrefix
parameter_list|)
throws|throws
name|IOException
block|{
name|PrivateCellUtil
operator|.
name|writeRowSkippingBytes
argument_list|(
name|out
argument_list|,
name|cell
argument_list|,
name|rlength
argument_list|,
name|commonPrefix
argument_list|)
expr_stmt|;
block|}
comment|/**    * Writes the qualifier from the given cell to the output stream excluding the common prefix    * @param out The dataoutputstream to which the data has to be written    * @param cell The cell whose contents has to be written    * @param qlength the qualifier length    * @throws IOException    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|void
name|writeQualifierSkippingBytes
parameter_list|(
name|DataOutputStream
name|out
parameter_list|,
name|Cell
name|cell
parameter_list|,
name|int
name|qlength
parameter_list|,
name|int
name|commonPrefix
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|cell
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
name|ByteBufferUtils
operator|.
name|copyBufferToStream
argument_list|(
operator|(
name|DataOutput
operator|)
name|out
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getQualifierByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getQualifierPosition
argument_list|()
operator|+
name|commonPrefix
argument_list|,
name|qlength
operator|-
name|commonPrefix
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|write
argument_list|(
name|cell
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getQualifierOffset
argument_list|()
operator|+
name|commonPrefix
argument_list|,
name|qlength
operator|-
name|commonPrefix
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @param cell    * @return The Key portion of the passed<code>cell</code> as a String.    */
specifier|public
specifier|static
name|String
name|getCellKeyAsString
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|cell
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getRowLength
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|cell
operator|.
name|getFamilyLength
argument_list|()
operator|==
literal|0
condition|?
literal|""
else|:
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|cell
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getFamilyLength
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// KeyValue only added ':' if family is non-null.  Do same.
if|if
condition|(
name|cell
operator|.
name|getFamilyLength
argument_list|()
operator|>
literal|0
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|cell
operator|.
name|getQualifierLength
argument_list|()
operator|==
literal|0
condition|?
literal|""
else|:
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|cell
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getQualifierLength
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|KeyValue
operator|.
name|humanReadableTimestamp
argument_list|(
name|cell
operator|.
name|getTimestamp
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|Type
operator|.
name|codeToType
argument_list|(
name|cell
operator|.
name|getTypeByte
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cell
operator|instanceof
name|KeyValue
operator|.
name|KeyOnlyKeyValue
operator|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"/vlen="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|cell
operator|.
name|getValueLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"/seqid="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|cell
operator|.
name|getSequenceId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * This method exists just to encapsulate how we serialize keys.  To be replaced by a factory    * that we query to figure what the Cell implementation is and then, what serialization engine    * to use and further, how to serialize the key for inclusion in hfile index. TODO.    * @param cell    * @return The key portion of the Cell serialized in the old-school KeyValue way or null if    * passed a null<code>cell</code>    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|byte
index|[]
name|getCellKeySerializedAsKeyValueKey
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|getCellKeySerializedAsKeyValueKey
argument_list|(
name|cell
argument_list|)
return|;
block|}
comment|/**    * Write rowkey excluding the common part.    * @param cell    * @param rLen    * @param commonPrefix    * @param out    * @throws IOException    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|void
name|writeRowKeyExcludingCommon
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|short
name|rLen
parameter_list|,
name|int
name|commonPrefix
parameter_list|,
name|DataOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|PrivateCellUtil
operator|.
name|writeRowKeyExcludingCommon
argument_list|(
name|cell
argument_list|,
name|rLen
argument_list|,
name|commonPrefix
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
comment|/**    * Find length of common prefix in keys of the cells, considering key as byte[] if serialized in    * {@link KeyValue}. The key format is&lt;2 bytes rk len&gt;&lt;rk&gt;&lt;1 byte cf    * len&gt;&lt;cf&gt;&lt;qualifier&gt;&lt;8 bytes timestamp&gt;&lt;1 byte type&gt;    * @param c1 the cell    * @param c2 the cell    * @param bypassFamilyCheck when true assume the family bytes same in both cells. Pass it as true    *          when dealing with Cells in same CF so as to avoid some checks    * @param withTsType when true check timestamp and type bytes also.    * @return length of common prefix    * @deprecated As of HBase-2.0. Will be removed in HBase-3.0    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|int
name|findCommonPrefixInFlatKey
parameter_list|(
name|Cell
name|c1
parameter_list|,
name|Cell
name|c2
parameter_list|,
name|boolean
name|bypassFamilyCheck
parameter_list|,
name|boolean
name|withTsType
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|findCommonPrefixInFlatKey
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|,
name|bypassFamilyCheck
argument_list|,
name|withTsType
argument_list|)
return|;
block|}
comment|/** Returns a string representation of the cell */
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|boolean
name|verbose
parameter_list|)
block|{
if|if
condition|(
name|cell
operator|==
literal|null
condition|)
block|{
return|return
literal|""
return|;
block|}
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|String
name|keyStr
init|=
name|getCellKeyAsString
argument_list|(
name|cell
argument_list|)
decl_stmt|;
name|String
name|tag
init|=
literal|null
decl_stmt|;
name|String
name|value
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
comment|// TODO: pretty print tags as well
if|if
condition|(
name|cell
operator|.
name|getTagsLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|tag
operator|=
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|cell
operator|.
name|getTagsArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getTagsOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getTagsLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|cell
operator|instanceof
name|KeyValue
operator|.
name|KeyOnlyKeyValue
operator|)
condition|)
block|{
name|value
operator|=
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|cell
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getValueLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|builder
operator|.
name|append
argument_list|(
name|keyStr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
literal|null
operator|&&
operator|!
name|tag
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"/"
argument_list|)
operator|.
name|append
argument_list|(
name|tag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"/"
argument_list|)
operator|.
name|append
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/***************** special cases ****************************/
comment|/**    * special case for Cell.equals    * @deprecated As of HBase-2.0. Will be removed in HBase-3.0    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|boolean
name|equalsIgnoreMvccVersion
parameter_list|(
name|Cell
name|a
parameter_list|,
name|Cell
name|b
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|equalsIgnoreMvccVersion
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
comment|/**************** equals ****************************/
specifier|public
specifier|static
name|boolean
name|equals
parameter_list|(
name|Cell
name|a
parameter_list|,
name|Cell
name|b
parameter_list|)
block|{
return|return
name|matchingRows
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|&&
name|matchingFamily
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|&&
name|matchingQualifier
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|&&
name|matchingTimestamp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|&&
name|PrivateCellUtil
operator|.
name|matchingType
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|matchingTimestamp
parameter_list|(
name|Cell
name|a
parameter_list|,
name|Cell
name|b
parameter_list|)
block|{
return|return
name|CellComparator
operator|.
name|getInstance
argument_list|()
operator|.
name|compareTimestamps
argument_list|(
name|a
operator|.
name|getTimestamp
argument_list|()
argument_list|,
name|b
operator|.
name|getTimestamp
argument_list|()
argument_list|)
operator|==
literal|0
return|;
block|}
comment|/**    * @deprecated As of HBase-2.0. Will be removed in HBase-3.0    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|boolean
name|matchingType
parameter_list|(
name|Cell
name|a
parameter_list|,
name|Cell
name|b
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|matchingType
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
comment|/**    * Compares the row of two keyvalues for equality    * @param left    * @param right    * @return True if rows match.    */
specifier|public
specifier|static
name|boolean
name|matchingRows
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|)
block|{
name|short
name|lrowlength
init|=
name|left
operator|.
name|getRowLength
argument_list|()
decl_stmt|;
name|short
name|rrowlength
init|=
name|right
operator|.
name|getRowLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|lrowlength
operator|!=
name|rrowlength
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferExtendedCell
operator|&&
name|right
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getRowByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getRowPosition
argument_list|()
argument_list|,
name|lrowlength
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getRowByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getRowPosition
argument_list|()
argument_list|,
name|rrowlength
argument_list|)
return|;
block|}
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getRowByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getRowPosition
argument_list|()
argument_list|,
name|lrowlength
argument_list|,
name|right
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|right
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|rrowlength
argument_list|)
return|;
block|}
if|if
condition|(
name|right
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getRowByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getRowPosition
argument_list|()
argument_list|,
name|rrowlength
argument_list|,
name|left
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|left
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|lrowlength
argument_list|)
return|;
block|}
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|left
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|left
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|lrowlength
argument_list|,
name|right
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|right
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|rrowlength
argument_list|)
return|;
block|}
comment|/**    * Compares the row and column of two keyvalues for equality    * @param left    * @param right    * @return True if same row and column.    */
specifier|public
specifier|static
name|boolean
name|matchingRowColumn
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|)
block|{
if|if
condition|(
operator|(
name|left
operator|.
name|getRowLength
argument_list|()
operator|+
name|left
operator|.
name|getFamilyLength
argument_list|()
operator|+
name|left
operator|.
name|getQualifierLength
argument_list|()
operator|)
operator|!=
operator|(
name|right
operator|.
name|getRowLength
argument_list|()
operator|+
name|right
operator|.
name|getFamilyLength
argument_list|()
operator|+
name|right
operator|.
name|getQualifierLength
argument_list|()
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|matchingRows
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|matchingColumn
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|matchingRowColumnBytes
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|)
block|{
name|int
name|lrowlength
init|=
name|left
operator|.
name|getRowLength
argument_list|()
decl_stmt|;
name|int
name|rrowlength
init|=
name|right
operator|.
name|getRowLength
argument_list|()
decl_stmt|;
name|int
name|lfamlength
init|=
name|left
operator|.
name|getFamilyLength
argument_list|()
decl_stmt|;
name|int
name|rfamlength
init|=
name|right
operator|.
name|getFamilyLength
argument_list|()
decl_stmt|;
name|int
name|lqlength
init|=
name|left
operator|.
name|getQualifierLength
argument_list|()
decl_stmt|;
name|int
name|rqlength
init|=
name|right
operator|.
name|getQualifierLength
argument_list|()
decl_stmt|;
comment|// match length
if|if
condition|(
operator|(
name|lrowlength
operator|+
name|lfamlength
operator|+
name|lqlength
operator|)
operator|!=
operator|(
name|rrowlength
operator|+
name|rfamlength
operator|+
name|rqlength
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// match row
if|if
condition|(
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|left
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|left
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|lrowlength
argument_list|,
name|right
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|right
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|rrowlength
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|//match family
if|if
condition|(
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|left
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|lfamlength
argument_list|,
name|right
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|rfamlength
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|//match qualifier
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|left
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|lqlength
argument_list|,
name|right
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|right
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|rqlength
argument_list|)
return|;
block|}
comment|/**    * Compares the cell's qualifier with the given byte[]    * @param left the cell for which the qualifier has to be compared    * @param right the byte[] having the qualifier    * @param rOffset the offset of the qualifier    * @param rLength the length of the qualifier    * @return greater than 0 if left cell's qualifier is bigger than byte[], lesser than 0 if left    *         cell's qualifier is lesser than byte[] and 0 otherwise    */
specifier|public
specifier|final
specifier|static
name|int
name|compareQualifiers
parameter_list|(
name|Cell
name|left
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|rOffset
parameter_list|,
name|int
name|rLength
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|compareTo
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getQualifierByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getQualifierPosition
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierLength
argument_list|()
argument_list|,
name|right
argument_list|,
name|rOffset
argument_list|,
name|rLength
argument_list|)
return|;
block|}
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierLength
argument_list|()
argument_list|,
name|right
argument_list|,
name|rOffset
argument_list|,
name|rLength
argument_list|)
return|;
block|}
comment|/**    * Used when a cell needs to be compared with a key byte[] such as cases of finding the index from    * the index block, bloom keys from the bloom blocks This byte[] is expected to be serialized in    * the KeyValue serialization format If the KeyValue (Cell's) serialization format changes this    * method cannot be used.    * @param comparator the cell comparator    * @param left the cell to be compared    * @param key the serialized key part of a KeyValue    * @param offset the offset in the key byte[]    * @param length the length of the key byte[]    * @return an int greater than 0 if left is greater than right lesser than 0 if left is lesser    *         than right equal to 0 if left is equal to right    * @deprecated As of HBase-2.0. Will be removed in HBase-3.0    */
annotation|@
name|VisibleForTesting
annotation|@
name|Deprecated
specifier|public
specifier|static
specifier|final
name|int
name|compare
parameter_list|(
name|CellComparator
name|comparator
parameter_list|,
name|Cell
name|left
parameter_list|,
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
comment|// row
name|short
name|rrowlength
init|=
name|Bytes
operator|.
name|toShort
argument_list|(
name|key
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|int
name|c
init|=
name|comparator
operator|.
name|compareRows
argument_list|(
name|left
argument_list|,
name|key
argument_list|,
name|offset
operator|+
name|Bytes
operator|.
name|SIZEOF_SHORT
argument_list|,
name|rrowlength
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
return|return
name|c
return|;
comment|// Compare the rest of the two KVs without making any assumptions about
comment|// the common prefix. This function will not compare rows anyway, so we
comment|// don't need to tell it that the common prefix includes the row.
return|return
name|PrivateCellUtil
operator|.
name|compareWithoutRow
argument_list|(
name|comparator
argument_list|,
name|left
argument_list|,
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|rrowlength
argument_list|)
return|;
block|}
comment|/**    * Compares the cell's family with the given byte[]    * @param left the cell for which the family has to be compared    * @param right the byte[] having the family    * @param roffset the offset of the family    * @param rlength the length of the family    * @return greater than 0 if left cell's family is bigger than byte[], lesser than 0 if left    *         cell's family is lesser than byte[] and 0 otherwise    */
specifier|public
specifier|final
specifier|static
name|int
name|compareFamilies
parameter_list|(
name|Cell
name|left
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|roffset
parameter_list|,
name|int
name|rlength
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|compareTo
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getFamilyByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getFamilyPosition
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|right
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|)
return|;
block|}
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|right
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|)
return|;
block|}
comment|/**    * Compares the cell's column (family and qualifier) with the given byte[]    * @param left the cell for which the column has to be compared    * @param right the byte[] having the column    * @param rfoffset the offset of the family    * @param rflength the length of the family    * @param rqoffset the offset of the qualifier    * @param rqlength the length of the qualifier    * @return greater than 0 if left cell's column is bigger than byte[], lesser than 0 if left    *         cell's column is lesser than byte[] and 0 otherwise    */
specifier|public
specifier|final
specifier|static
name|int
name|compareColumns
parameter_list|(
name|Cell
name|left
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|rfoffset
parameter_list|,
name|int
name|rflength
parameter_list|,
name|int
name|rqoffset
parameter_list|,
name|int
name|rqlength
parameter_list|)
block|{
name|int
name|diff
init|=
name|compareFamilies
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|rfoffset
argument_list|,
name|rflength
argument_list|)
decl_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|0
condition|)
return|return
name|diff
return|;
return|return
name|compareQualifiers
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|rqoffset
argument_list|,
name|rqlength
argument_list|)
return|;
block|}
block|}
end_class

end_unit

