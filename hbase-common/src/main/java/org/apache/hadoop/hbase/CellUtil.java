begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
operator|.
name|COLUMN_FAMILY_DELIMITER
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
operator|.
name|COLUMN_FAMILY_DELIM_ARRAY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
operator|.
name|getDelimiter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ByteBufferUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_comment
comment|/**  * Utility methods helpful for slinging {@link Cell} instances. Some methods below are for internal  * use only and are marked InterfaceAudience.Private at the method level. Note that all such methods  * have been marked deprecated in HBase-2.0 which will be subsequently removed in HBase-3.0  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
specifier|public
specifier|final
class|class
name|CellUtil
block|{
comment|/**    * Private constructor to keep this class from being instantiated.    */
specifier|private
name|CellUtil
parameter_list|()
block|{   }
comment|/***************** get individual arrays for tests ************/
specifier|public
specifier|static
name|byte
index|[]
name|cloneRow
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
name|byte
index|[]
name|output
init|=
operator|new
name|byte
index|[
name|cell
operator|.
name|getRowLength
argument_list|()
index|]
decl_stmt|;
name|copyRowTo
argument_list|(
name|cell
argument_list|,
name|output
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
specifier|public
specifier|static
name|byte
index|[]
name|cloneFamily
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
name|byte
index|[]
name|output
init|=
operator|new
name|byte
index|[
name|cell
operator|.
name|getFamilyLength
argument_list|()
index|]
decl_stmt|;
name|copyFamilyTo
argument_list|(
name|cell
argument_list|,
name|output
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
specifier|public
specifier|static
name|byte
index|[]
name|cloneQualifier
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
name|byte
index|[]
name|output
init|=
operator|new
name|byte
index|[
name|cell
operator|.
name|getQualifierLength
argument_list|()
index|]
decl_stmt|;
name|copyQualifierTo
argument_list|(
name|cell
argument_list|,
name|output
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
specifier|public
specifier|static
name|byte
index|[]
name|cloneValue
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
name|byte
index|[]
name|output
init|=
operator|new
name|byte
index|[
name|cell
operator|.
name|getValueLength
argument_list|()
index|]
decl_stmt|;
name|copyValueTo
argument_list|(
name|cell
argument_list|,
name|output
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
comment|/**    * Makes a column in family:qualifier form from separate byte arrays.    *<p>    * Not recommended for usage as this is old-style API.    * @param family    * @param qualifier    * @return family:qualifier    */
specifier|public
specifier|static
name|byte
index|[]
name|makeColumn
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|add
argument_list|(
name|family
argument_list|,
name|COLUMN_FAMILY_DELIM_ARRAY
argument_list|,
name|qualifier
argument_list|)
return|;
block|}
comment|/**    * Splits a column in {@code family:qualifier} form into separate byte arrays. An empty qualifier    * (ie, {@code fam:}) is parsed as<code>{ fam, EMPTY_BYTE_ARRAY }</code> while no delimiter (ie,    * {@code fam}) is parsed as an array of one element,<code>{ fam }</code>.    *<p>    * Don't forget, HBase DOES support empty qualifiers. (see HBASE-9549)    *</p>    *<p>    * Not recommend to be used as this is old-style API.    *</p>    * @param c The column.    * @return The parsed column.    */
specifier|public
specifier|static
name|byte
index|[]
index|[]
name|parseColumn
parameter_list|(
name|byte
index|[]
name|c
parameter_list|)
block|{
specifier|final
name|int
name|index
init|=
name|getDelimiter
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
name|c
operator|.
name|length
argument_list|,
name|COLUMN_FAMILY_DELIMITER
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
comment|// If no delimiter, return array of size 1
return|return
operator|new
name|byte
index|[]
index|[]
block|{
name|c
block|}
return|;
block|}
elseif|else
if|if
condition|(
name|index
operator|==
name|c
operator|.
name|length
operator|-
literal|1
condition|)
block|{
comment|// family with empty qualifier, return array size 2
name|byte
index|[]
name|family
init|=
operator|new
name|byte
index|[
name|c
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
name|family
argument_list|,
literal|0
argument_list|,
name|family
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
operator|new
name|byte
index|[]
index|[]
block|{
name|family
block|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
block|}
return|;
block|}
comment|// Family and column, return array size 2
specifier|final
name|byte
index|[]
index|[]
name|result
init|=
operator|new
name|byte
index|[
literal|2
index|]
index|[]
decl_stmt|;
name|result
index|[
literal|0
index|]
operator|=
operator|new
name|byte
index|[
name|index
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
name|result
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|index
argument_list|)
expr_stmt|;
specifier|final
name|int
name|len
init|=
name|c
operator|.
name|length
operator|-
operator|(
name|index
operator|+
literal|1
operator|)
decl_stmt|;
name|result
index|[
literal|1
index|]
operator|=
operator|new
name|byte
index|[
name|len
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|c
argument_list|,
name|index
operator|+
literal|1
comment|/* Skip delimiter */
argument_list|,
name|result
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/******************** copyTo **********************************/
comment|/**    * Copies the row to the given byte[]    * @param cell the cell whose row has to be copied    * @param destination the destination byte[] to which the row has to be copied    * @param destinationOffset the offset in the destination byte[]    * @return the offset of the byte[] after the copy has happened    */
specifier|public
specifier|static
name|int
name|copyRowTo
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|byte
index|[]
name|destination
parameter_list|,
name|int
name|destinationOffset
parameter_list|)
block|{
name|short
name|rowLen
init|=
name|cell
operator|.
name|getRowLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|cell
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
name|ByteBufferUtils
operator|.
name|copyFromBufferToArray
argument_list|(
name|destination
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getRowByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getRowPosition
argument_list|()
argument_list|,
name|destinationOffset
argument_list|,
name|rowLen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|cell
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|destination
argument_list|,
name|destinationOffset
argument_list|,
name|rowLen
argument_list|)
expr_stmt|;
block|}
return|return
name|destinationOffset
operator|+
name|rowLen
return|;
block|}
comment|/**    * Copies the row to the given bytebuffer    * @param cell cell the cell whose row has to be copied    * @param destination the destination bytebuffer to which the row has to be copied    * @param destinationOffset the offset in the destination byte[]    * @return the offset of the bytebuffer after the copy has happened    */
specifier|public
specifier|static
name|int
name|copyRowTo
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|ByteBuffer
name|destination
parameter_list|,
name|int
name|destinationOffset
parameter_list|)
block|{
name|short
name|rowLen
init|=
name|cell
operator|.
name|getRowLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|cell
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
name|ByteBufferUtils
operator|.
name|copyFromBufferToBuffer
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getRowByteBuffer
argument_list|()
argument_list|,
name|destination
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getRowPosition
argument_list|()
argument_list|,
name|destinationOffset
argument_list|,
name|rowLen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ByteBufferUtils
operator|.
name|copyFromArrayToBuffer
argument_list|(
name|destination
argument_list|,
name|destinationOffset
argument_list|,
name|cell
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|rowLen
argument_list|)
expr_stmt|;
block|}
return|return
name|destinationOffset
operator|+
name|rowLen
return|;
block|}
comment|/**    * Copies the row to a new byte[]    * @param cell the cell from which row has to copied    * @return the byte[] containing the row    */
specifier|public
specifier|static
name|byte
index|[]
name|copyRow
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
if|if
condition|(
name|cell
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|copyOfRange
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getRowByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getRowPosition
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getRowPosition
argument_list|()
operator|+
name|cell
operator|.
name|getRowLength
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|cell
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getRowOffset
argument_list|()
operator|+
name|cell
operator|.
name|getRowLength
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * Copies the family to the given byte[]    * @param cell the cell whose family has to be copied    * @param destination the destination byte[] to which the family has to be copied    * @param destinationOffset the offset in the destination byte[]    * @return the offset of the byte[] after the copy has happened    */
specifier|public
specifier|static
name|int
name|copyFamilyTo
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|byte
index|[]
name|destination
parameter_list|,
name|int
name|destinationOffset
parameter_list|)
block|{
name|byte
name|fLen
init|=
name|cell
operator|.
name|getFamilyLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|cell
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
name|ByteBufferUtils
operator|.
name|copyFromBufferToArray
argument_list|(
name|destination
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getFamilyByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getFamilyPosition
argument_list|()
argument_list|,
name|destinationOffset
argument_list|,
name|fLen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|cell
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|destination
argument_list|,
name|destinationOffset
argument_list|,
name|fLen
argument_list|)
expr_stmt|;
block|}
return|return
name|destinationOffset
operator|+
name|fLen
return|;
block|}
comment|/**    * Copies the family to the given bytebuffer    * @param cell the cell whose family has to be copied    * @param destination the destination bytebuffer to which the family has to be copied    * @param destinationOffset the offset in the destination bytebuffer    * @return the offset of the bytebuffer after the copy has happened    */
specifier|public
specifier|static
name|int
name|copyFamilyTo
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|ByteBuffer
name|destination
parameter_list|,
name|int
name|destinationOffset
parameter_list|)
block|{
name|byte
name|fLen
init|=
name|cell
operator|.
name|getFamilyLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|cell
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
name|ByteBufferUtils
operator|.
name|copyFromBufferToBuffer
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getFamilyByteBuffer
argument_list|()
argument_list|,
name|destination
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getFamilyPosition
argument_list|()
argument_list|,
name|destinationOffset
argument_list|,
name|fLen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ByteBufferUtils
operator|.
name|copyFromArrayToBuffer
argument_list|(
name|destination
argument_list|,
name|destinationOffset
argument_list|,
name|cell
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|fLen
argument_list|)
expr_stmt|;
block|}
return|return
name|destinationOffset
operator|+
name|fLen
return|;
block|}
comment|/**    * Copies the qualifier to the given byte[]    * @param cell the cell whose qualifier has to be copied    * @param destination the destination byte[] to which the qualifier has to be copied    * @param destinationOffset the offset in the destination byte[]    * @return the offset of the byte[] after the copy has happened    */
specifier|public
specifier|static
name|int
name|copyQualifierTo
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|byte
index|[]
name|destination
parameter_list|,
name|int
name|destinationOffset
parameter_list|)
block|{
name|int
name|qlen
init|=
name|cell
operator|.
name|getQualifierLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|cell
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
name|ByteBufferUtils
operator|.
name|copyFromBufferToArray
argument_list|(
name|destination
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getQualifierByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getQualifierPosition
argument_list|()
argument_list|,
name|destinationOffset
argument_list|,
name|qlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|cell
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|destination
argument_list|,
name|destinationOffset
argument_list|,
name|qlen
argument_list|)
expr_stmt|;
block|}
return|return
name|destinationOffset
operator|+
name|qlen
return|;
block|}
comment|/**    * Copies the qualifier to the given bytebuffer    * @param cell the cell whose qualifier has to be copied    * @param destination the destination bytebuffer to which the qualifier has to be copied    * @param destinationOffset the offset in the destination bytebuffer    * @return the offset of the bytebuffer after the copy has happened    */
specifier|public
specifier|static
name|int
name|copyQualifierTo
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|ByteBuffer
name|destination
parameter_list|,
name|int
name|destinationOffset
parameter_list|)
block|{
name|int
name|qlen
init|=
name|cell
operator|.
name|getQualifierLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|cell
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
name|ByteBufferUtils
operator|.
name|copyFromBufferToBuffer
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getQualifierByteBuffer
argument_list|()
argument_list|,
name|destination
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getQualifierPosition
argument_list|()
argument_list|,
name|destinationOffset
argument_list|,
name|qlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ByteBufferUtils
operator|.
name|copyFromArrayToBuffer
argument_list|(
name|destination
argument_list|,
name|destinationOffset
argument_list|,
name|cell
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|qlen
argument_list|)
expr_stmt|;
block|}
return|return
name|destinationOffset
operator|+
name|qlen
return|;
block|}
comment|/**    * Copies the value to the given byte[]    * @param cell the cell whose value has to be copied    * @param destination the destination byte[] to which the value has to be copied    * @param destinationOffset the offset in the destination byte[]    * @return the offset of the byte[] after the copy has happened    */
specifier|public
specifier|static
name|int
name|copyValueTo
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|byte
index|[]
name|destination
parameter_list|,
name|int
name|destinationOffset
parameter_list|)
block|{
name|int
name|vlen
init|=
name|cell
operator|.
name|getValueLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|cell
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
name|ByteBufferUtils
operator|.
name|copyFromBufferToArray
argument_list|(
name|destination
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getValueByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getValuePosition
argument_list|()
argument_list|,
name|destinationOffset
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|cell
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|destination
argument_list|,
name|destinationOffset
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
block|}
return|return
name|destinationOffset
operator|+
name|vlen
return|;
block|}
comment|/**    * Copies the value to the given bytebuffer    * @param cell the cell whose value has to be copied    * @param destination the destination bytebuffer to which the value has to be copied    * @param destinationOffset the offset in the destination bytebuffer    * @return the offset of the bytebuffer after the copy has happened    */
specifier|public
specifier|static
name|int
name|copyValueTo
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|ByteBuffer
name|destination
parameter_list|,
name|int
name|destinationOffset
parameter_list|)
block|{
name|int
name|vlen
init|=
name|cell
operator|.
name|getValueLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|cell
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
name|ByteBufferUtils
operator|.
name|copyFromBufferToBuffer
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getValueByteBuffer
argument_list|()
argument_list|,
name|destination
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|cell
operator|)
operator|.
name|getValuePosition
argument_list|()
argument_list|,
name|destinationOffset
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ByteBufferUtils
operator|.
name|copyFromArrayToBuffer
argument_list|(
name|destination
argument_list|,
name|destinationOffset
argument_list|,
name|cell
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
block|}
return|return
name|destinationOffset
operator|+
name|vlen
return|;
block|}
comment|/**    * @param cellScannerables    * @return CellScanner interface over<code>cellIterables</code>    */
specifier|public
specifier|static
name|CellScanner
name|createCellScanner
parameter_list|(
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|CellScannable
argument_list|>
name|cellScannerables
parameter_list|)
block|{
return|return
operator|new
name|CellScanner
argument_list|()
block|{
specifier|private
specifier|final
name|Iterator
argument_list|<
name|?
extends|extends
name|CellScannable
argument_list|>
name|iterator
init|=
name|cellScannerables
operator|.
name|iterator
argument_list|()
decl_stmt|;
specifier|private
name|CellScanner
name|cellScanner
init|=
literal|null
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Cell
name|current
parameter_list|()
block|{
return|return
name|this
operator|.
name|cellScanner
operator|!=
literal|null
condition|?
name|this
operator|.
name|cellScanner
operator|.
name|current
argument_list|()
else|:
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|advance
parameter_list|()
throws|throws
name|IOException
block|{
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|cellScanner
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
return|return
literal|false
return|;
name|this
operator|.
name|cellScanner
operator|=
name|this
operator|.
name|iterator
operator|.
name|next
argument_list|()
operator|.
name|cellScanner
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|cellScanner
operator|.
name|advance
argument_list|()
condition|)
return|return
literal|true
return|;
name|this
operator|.
name|cellScanner
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
return|;
block|}
comment|/**    * @param cellIterable    * @return CellScanner interface over<code>cellIterable</code>    */
specifier|public
specifier|static
name|CellScanner
name|createCellScanner
parameter_list|(
specifier|final
name|Iterable
argument_list|<
name|Cell
argument_list|>
name|cellIterable
parameter_list|)
block|{
if|if
condition|(
name|cellIterable
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|createCellScanner
argument_list|(
name|cellIterable
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @param cells    * @return CellScanner interface over<code>cellIterable</code> or null if<code>cells</code> is    * null    */
specifier|public
specifier|static
name|CellScanner
name|createCellScanner
parameter_list|(
specifier|final
name|Iterator
argument_list|<
name|Cell
argument_list|>
name|cells
parameter_list|)
block|{
if|if
condition|(
name|cells
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
operator|new
name|CellScanner
argument_list|()
block|{
specifier|private
specifier|final
name|Iterator
argument_list|<
name|Cell
argument_list|>
name|iterator
init|=
name|cells
decl_stmt|;
specifier|private
name|Cell
name|current
init|=
literal|null
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Cell
name|current
parameter_list|()
block|{
return|return
name|this
operator|.
name|current
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|advance
parameter_list|()
block|{
name|boolean
name|hasNext
init|=
name|this
operator|.
name|iterator
operator|.
name|hasNext
argument_list|()
decl_stmt|;
name|this
operator|.
name|current
operator|=
name|hasNext
condition|?
name|this
operator|.
name|iterator
operator|.
name|next
argument_list|()
else|:
literal|null
expr_stmt|;
return|return
name|hasNext
return|;
block|}
block|}
return|;
block|}
comment|/**    * @param cellArray    * @return CellScanner interface over<code>cellArray</code>    */
specifier|public
specifier|static
name|CellScanner
name|createCellScanner
parameter_list|(
specifier|final
name|Cell
index|[]
name|cellArray
parameter_list|)
block|{
return|return
operator|new
name|CellScanner
argument_list|()
block|{
specifier|private
specifier|final
name|Cell
index|[]
name|cells
init|=
name|cellArray
decl_stmt|;
specifier|private
name|int
name|index
init|=
operator|-
literal|1
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Cell
name|current
parameter_list|()
block|{
if|if
condition|(
name|cells
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
operator|(
name|index
operator|<
literal|0
operator|)
condition|?
literal|null
else|:
name|this
operator|.
name|cells
index|[
name|index
index|]
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|advance
parameter_list|()
block|{
if|if
condition|(
name|cells
operator|==
literal|null
condition|)
return|return
literal|false
return|;
return|return
operator|++
name|index
operator|<
name|this
operator|.
name|cells
operator|.
name|length
return|;
block|}
block|}
return|;
block|}
comment|/**    * Flatten the map of cells out under the CellScanner    * @param map Map of Cell Lists; for example, the map of families to Cells that is used    * inside Put, etc., keeping Cells organized by family.    * @return CellScanner interface over<code>cellIterable</code>    */
specifier|public
specifier|static
name|CellScanner
name|createCellScanner
parameter_list|(
specifier|final
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|List
argument_list|<
name|Cell
argument_list|>
argument_list|>
name|map
parameter_list|)
block|{
return|return
operator|new
name|CellScanner
argument_list|()
block|{
specifier|private
specifier|final
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|List
argument_list|<
name|Cell
argument_list|>
argument_list|>
argument_list|>
name|entries
init|=
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
specifier|private
name|Iterator
argument_list|<
name|Cell
argument_list|>
name|currentIterator
init|=
literal|null
decl_stmt|;
specifier|private
name|Cell
name|currentCell
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Cell
name|current
parameter_list|()
block|{
return|return
name|this
operator|.
name|currentCell
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|advance
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|currentIterator
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|entries
operator|.
name|hasNext
argument_list|()
condition|)
return|return
literal|false
return|;
name|this
operator|.
name|currentIterator
operator|=
name|this
operator|.
name|entries
operator|.
name|next
argument_list|()
operator|.
name|getValue
argument_list|()
operator|.
name|iterator
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|currentIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|this
operator|.
name|currentCell
operator|=
name|this
operator|.
name|currentIterator
operator|.
name|next
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
name|this
operator|.
name|currentCell
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|currentIterator
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
return|;
block|}
specifier|public
specifier|static
name|boolean
name|matchingRows
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|byte
index|[]
name|buf
parameter_list|)
block|{
if|if
condition|(
name|buf
operator|==
literal|null
condition|)
block|{
return|return
name|left
operator|.
name|getRowLength
argument_list|()
operator|==
literal|0
return|;
block|}
return|return
name|PrivateCellUtil
operator|.
name|matchingRows
argument_list|(
name|left
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|matchingRow
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|byte
index|[]
name|buf
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|matchingRows
argument_list|(
name|left
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|matchingFamily
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|)
block|{
name|byte
name|lfamlength
init|=
name|left
operator|.
name|getFamilyLength
argument_list|()
decl_stmt|;
name|byte
name|rfamlength
init|=
name|right
operator|.
name|getFamilyLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferExtendedCell
operator|&&
name|right
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getFamilyByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getFamilyPosition
argument_list|()
argument_list|,
name|lfamlength
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getFamilyByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getFamilyPosition
argument_list|()
argument_list|,
name|rfamlength
argument_list|)
return|;
block|}
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getFamilyByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getFamilyPosition
argument_list|()
argument_list|,
name|lfamlength
argument_list|,
name|right
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|rfamlength
argument_list|)
return|;
block|}
if|if
condition|(
name|right
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getFamilyByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getFamilyPosition
argument_list|()
argument_list|,
name|rfamlength
argument_list|,
name|left
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|lfamlength
argument_list|)
return|;
block|}
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|left
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|lfamlength
argument_list|,
name|right
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|rfamlength
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|matchingFamily
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|byte
index|[]
name|buf
parameter_list|)
block|{
if|if
condition|(
name|buf
operator|==
literal|null
condition|)
block|{
return|return
name|left
operator|.
name|getFamilyLength
argument_list|()
operator|==
literal|0
return|;
block|}
return|return
name|PrivateCellUtil
operator|.
name|matchingFamily
argument_list|(
name|left
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|matchingQualifier
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|)
block|{
name|int
name|lqlength
init|=
name|left
operator|.
name|getQualifierLength
argument_list|()
decl_stmt|;
name|int
name|rqlength
init|=
name|right
operator|.
name|getQualifierLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferExtendedCell
operator|&&
name|right
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getQualifierByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getQualifierPosition
argument_list|()
argument_list|,
name|lqlength
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getQualifierByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getQualifierPosition
argument_list|()
argument_list|,
name|rqlength
argument_list|)
return|;
block|}
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getQualifierByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getQualifierPosition
argument_list|()
argument_list|,
name|lqlength
argument_list|,
name|right
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|right
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|rqlength
argument_list|)
return|;
block|}
if|if
condition|(
name|right
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getQualifierByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getQualifierPosition
argument_list|()
argument_list|,
name|rqlength
argument_list|,
name|left
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|lqlength
argument_list|)
return|;
block|}
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|left
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|lqlength
argument_list|,
name|right
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|right
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|rqlength
argument_list|)
return|;
block|}
comment|/**    * Finds if the qualifier part of the cell and the KV serialized    * byte[] are equal    * @param left    * @param buf the serialized keyvalue format byte[]    * @return true if the qualifier matches, false otherwise    */
specifier|public
specifier|static
name|boolean
name|matchingQualifier
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|byte
index|[]
name|buf
parameter_list|)
block|{
if|if
condition|(
name|buf
operator|==
literal|null
condition|)
block|{
return|return
name|left
operator|.
name|getQualifierLength
argument_list|()
operator|==
literal|0
return|;
block|}
return|return
name|PrivateCellUtil
operator|.
name|matchingQualifier
argument_list|(
name|left
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|matchingColumn
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|byte
index|[]
name|fam
parameter_list|,
specifier|final
name|byte
index|[]
name|qual
parameter_list|)
block|{
if|if
condition|(
operator|!
name|matchingFamily
argument_list|(
name|left
argument_list|,
name|fam
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
name|matchingQualifier
argument_list|(
name|left
argument_list|,
name|qual
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|matchingColumn
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|)
block|{
if|if
condition|(
operator|!
name|matchingFamily
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
name|matchingQualifier
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|matchingValue
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|)
block|{
return|return
name|matchingValue
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|left
operator|.
name|getValueLength
argument_list|()
argument_list|,
name|right
operator|.
name|getValueLength
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|matchingValue
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|,
name|int
name|lvlength
parameter_list|,
name|int
name|rvlength
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferExtendedCell
operator|&&
name|right
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getValueByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getValuePosition
argument_list|()
argument_list|,
name|lvlength
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getValueByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getValuePosition
argument_list|()
argument_list|,
name|rvlength
argument_list|)
return|;
block|}
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getValueByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getValuePosition
argument_list|()
argument_list|,
name|lvlength
argument_list|,
name|right
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|right
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|rvlength
argument_list|)
return|;
block|}
if|if
condition|(
name|right
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getValueByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getValuePosition
argument_list|()
argument_list|,
name|rvlength
argument_list|,
name|left
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|left
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|lvlength
argument_list|)
return|;
block|}
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|left
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|left
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|lvlength
argument_list|,
name|right
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|right
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|rvlength
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|matchingValue
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|byte
index|[]
name|buf
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|compareTo
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getValueByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getValuePosition
argument_list|()
argument_list|,
name|left
operator|.
name|getValueLength
argument_list|()
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|)
operator|==
literal|0
return|;
block|}
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|left
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|left
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getValueLength
argument_list|()
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * @return True if a delete type, a {@link KeyValue.Type#Delete} or a    *         {KeyValue.Type#DeleteFamily} or a    *         {@link KeyValue.Type#DeleteColumn} KeyValue type.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|public
specifier|static
name|boolean
name|isDelete
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
return|return
name|PrivateCellUtil
operator|.
name|isDelete
argument_list|(
name|cell
operator|.
name|getTypeByte
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @return True if this cell is a Put.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|public
specifier|static
name|boolean
name|isPut
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
return|return
name|cell
operator|.
name|getTypeByte
argument_list|()
operator|==
name|Type
operator|.
name|Put
operator|.
name|getCode
argument_list|()
return|;
block|}
comment|/**    * Sets the given timestamp to the cell.    *    * Note that this method is a LimitedPrivate API and may change between minor releases.    * @param cell    * @param ts    * @throws IOException when the passed cell is not of type {@link ExtendedCell}    */
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
name|HBaseInterfaceAudience
operator|.
name|COPROC
argument_list|)
specifier|public
specifier|static
name|void
name|setTimestamp
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|long
name|ts
parameter_list|)
throws|throws
name|IOException
block|{
name|PrivateCellUtil
operator|.
name|setTimestamp
argument_list|(
name|cell
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
comment|/**    * Sets the given timestamp to the cell.    *    * Note that this method is a LimitedPrivate API and may change between minor releases.    * @param cell    * @param ts buffer containing the timestamp value    * @param tsOffset offset to the new timestamp    * @throws IOException when the passed cell is not of type {@link ExtendedCell}    */
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
name|HBaseInterfaceAudience
operator|.
name|COPROC
argument_list|)
specifier|public
specifier|static
name|void
name|setTimestamp
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|byte
index|[]
name|ts
parameter_list|,
name|int
name|tsOffset
parameter_list|)
throws|throws
name|IOException
block|{
name|PrivateCellUtil
operator|.
name|setTimestamp
argument_list|(
name|cell
argument_list|,
name|Bytes
operator|.
name|toLong
argument_list|(
name|ts
argument_list|,
name|tsOffset
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param cell    * @return The Key portion of the passed<code>cell</code> as a String.    */
specifier|public
specifier|static
name|String
name|getCellKeyAsString
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|cell
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getRowLength
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|cell
operator|.
name|getFamilyLength
argument_list|()
operator|==
literal|0
condition|?
literal|""
else|:
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|cell
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getFamilyLength
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// KeyValue only added ':' if family is non-null.  Do same.
if|if
condition|(
name|cell
operator|.
name|getFamilyLength
argument_list|()
operator|>
literal|0
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|cell
operator|.
name|getQualifierLength
argument_list|()
operator|==
literal|0
condition|?
literal|""
else|:
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|cell
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getQualifierLength
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|KeyValue
operator|.
name|humanReadableTimestamp
argument_list|(
name|cell
operator|.
name|getTimestamp
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|Type
operator|.
name|codeToType
argument_list|(
name|cell
operator|.
name|getTypeByte
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cell
operator|instanceof
name|KeyValue
operator|.
name|KeyOnlyKeyValue
operator|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"/vlen="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|cell
operator|.
name|getValueLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"/seqid="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|cell
operator|.
name|getSequenceId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Returns a string representation of the cell */
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|boolean
name|verbose
parameter_list|)
block|{
if|if
condition|(
name|cell
operator|==
literal|null
condition|)
block|{
return|return
literal|""
return|;
block|}
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|String
name|keyStr
init|=
name|getCellKeyAsString
argument_list|(
name|cell
argument_list|)
decl_stmt|;
name|String
name|tag
init|=
literal|null
decl_stmt|;
name|String
name|value
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
comment|// TODO: pretty print tags as well
if|if
condition|(
name|cell
operator|.
name|getTagsLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|tag
operator|=
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|cell
operator|.
name|getTagsArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getTagsOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getTagsLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|cell
operator|instanceof
name|KeyValue
operator|.
name|KeyOnlyKeyValue
operator|)
condition|)
block|{
name|value
operator|=
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|cell
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getValueLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|builder
operator|.
name|append
argument_list|(
name|keyStr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
literal|null
operator|&&
operator|!
name|tag
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"/"
argument_list|)
operator|.
name|append
argument_list|(
name|tag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"/"
argument_list|)
operator|.
name|append
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**************** equals ****************************/
specifier|public
specifier|static
name|boolean
name|equals
parameter_list|(
name|Cell
name|a
parameter_list|,
name|Cell
name|b
parameter_list|)
block|{
return|return
name|matchingRows
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|&&
name|matchingFamily
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|&&
name|matchingQualifier
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|&&
name|matchingTimestamp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|&&
name|PrivateCellUtil
operator|.
name|matchingType
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|matchingTimestamp
parameter_list|(
name|Cell
name|a
parameter_list|,
name|Cell
name|b
parameter_list|)
block|{
return|return
name|CellComparator
operator|.
name|getInstance
argument_list|()
operator|.
name|compareTimestamps
argument_list|(
name|a
operator|.
name|getTimestamp
argument_list|()
argument_list|,
name|b
operator|.
name|getTimestamp
argument_list|()
argument_list|)
operator|==
literal|0
return|;
block|}
comment|/**    * Compares the row of two keyvalues for equality    * @param left    * @param right    * @return True if rows match.    */
specifier|public
specifier|static
name|boolean
name|matchingRows
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|)
block|{
name|short
name|lrowlength
init|=
name|left
operator|.
name|getRowLength
argument_list|()
decl_stmt|;
name|short
name|rrowlength
init|=
name|right
operator|.
name|getRowLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|lrowlength
operator|!=
name|rrowlength
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferExtendedCell
operator|&&
name|right
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getRowByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getRowPosition
argument_list|()
argument_list|,
name|lrowlength
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getRowByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getRowPosition
argument_list|()
argument_list|,
name|rrowlength
argument_list|)
return|;
block|}
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getRowByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getRowPosition
argument_list|()
argument_list|,
name|lrowlength
argument_list|,
name|right
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|right
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|rrowlength
argument_list|)
return|;
block|}
if|if
condition|(
name|right
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getRowByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|right
operator|)
operator|.
name|getRowPosition
argument_list|()
argument_list|,
name|rrowlength
argument_list|,
name|left
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|left
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|lrowlength
argument_list|)
return|;
block|}
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|left
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|left
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|lrowlength
argument_list|,
name|right
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|right
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|rrowlength
argument_list|)
return|;
block|}
comment|/**    * Compares the row and column of two keyvalues for equality    * @param left    * @param right    * @return True if same row and column.    */
specifier|public
specifier|static
name|boolean
name|matchingRowColumn
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|)
block|{
if|if
condition|(
operator|(
name|left
operator|.
name|getRowLength
argument_list|()
operator|+
name|left
operator|.
name|getFamilyLength
argument_list|()
operator|+
name|left
operator|.
name|getQualifierLength
argument_list|()
operator|)
operator|!=
operator|(
name|right
operator|.
name|getRowLength
argument_list|()
operator|+
name|right
operator|.
name|getFamilyLength
argument_list|()
operator|+
name|right
operator|.
name|getQualifierLength
argument_list|()
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|matchingRows
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|matchingColumn
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|matchingRowColumnBytes
parameter_list|(
specifier|final
name|Cell
name|left
parameter_list|,
specifier|final
name|Cell
name|right
parameter_list|)
block|{
name|int
name|lrowlength
init|=
name|left
operator|.
name|getRowLength
argument_list|()
decl_stmt|;
name|int
name|rrowlength
init|=
name|right
operator|.
name|getRowLength
argument_list|()
decl_stmt|;
name|int
name|lfamlength
init|=
name|left
operator|.
name|getFamilyLength
argument_list|()
decl_stmt|;
name|int
name|rfamlength
init|=
name|right
operator|.
name|getFamilyLength
argument_list|()
decl_stmt|;
name|int
name|lqlength
init|=
name|left
operator|.
name|getQualifierLength
argument_list|()
decl_stmt|;
name|int
name|rqlength
init|=
name|right
operator|.
name|getQualifierLength
argument_list|()
decl_stmt|;
comment|// match length
if|if
condition|(
operator|(
name|lrowlength
operator|+
name|lfamlength
operator|+
name|lqlength
operator|)
operator|!=
operator|(
name|rrowlength
operator|+
name|rfamlength
operator|+
name|rqlength
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// match row
if|if
condition|(
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|left
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|left
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|lrowlength
argument_list|,
name|right
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|right
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|rrowlength
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|//match family
if|if
condition|(
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|left
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|lfamlength
argument_list|,
name|right
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|right
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|rfamlength
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|//match qualifier
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|left
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|lqlength
argument_list|,
name|right
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|right
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|rqlength
argument_list|)
return|;
block|}
comment|/**    * Compares the cell's qualifier with the given byte[]    * @param left the cell for which the qualifier has to be compared    * @param right the byte[] having the qualifier    * @param rOffset the offset of the qualifier    * @param rLength the length of the qualifier    * @return greater than 0 if left cell's qualifier is bigger than byte[], lesser than 0 if left    *         cell's qualifier is lesser than byte[] and 0 otherwise    */
specifier|public
specifier|final
specifier|static
name|int
name|compareQualifiers
parameter_list|(
name|Cell
name|left
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|rOffset
parameter_list|,
name|int
name|rLength
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|compareTo
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getQualifierByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getQualifierPosition
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierLength
argument_list|()
argument_list|,
name|right
argument_list|,
name|rOffset
argument_list|,
name|rLength
argument_list|)
return|;
block|}
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getQualifierLength
argument_list|()
argument_list|,
name|right
argument_list|,
name|rOffset
argument_list|,
name|rLength
argument_list|)
return|;
block|}
comment|/**    * Compares the cell's family with the given byte[]    * @param left the cell for which the family has to be compared    * @param right the byte[] having the family    * @param roffset the offset of the family    * @param rlength the length of the family    * @return greater than 0 if left cell's family is bigger than byte[], lesser than 0 if left    *         cell's family is lesser than byte[] and 0 otherwise    */
specifier|public
specifier|final
specifier|static
name|int
name|compareFamilies
parameter_list|(
name|Cell
name|left
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|roffset
parameter_list|,
name|int
name|rlength
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|ByteBufferExtendedCell
condition|)
block|{
return|return
name|ByteBufferUtils
operator|.
name|compareTo
argument_list|(
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getFamilyByteBuffer
argument_list|()
argument_list|,
operator|(
operator|(
name|ByteBufferExtendedCell
operator|)
name|left
operator|)
operator|.
name|getFamilyPosition
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|right
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|)
return|;
block|}
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|right
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|)
return|;
block|}
comment|/**    * Compares the cell's column (family and qualifier) with the given byte[]    * @param left the cell for which the column has to be compared    * @param right the byte[] having the column    * @param rfoffset the offset of the family    * @param rflength the length of the family    * @param rqoffset the offset of the qualifier    * @param rqlength the length of the qualifier    * @return greater than 0 if left cell's column is bigger than byte[], lesser than 0 if left    *         cell's column is lesser than byte[] and 0 otherwise    */
specifier|public
specifier|final
specifier|static
name|int
name|compareColumns
parameter_list|(
name|Cell
name|left
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|rfoffset
parameter_list|,
name|int
name|rflength
parameter_list|,
name|int
name|rqoffset
parameter_list|,
name|int
name|rqlength
parameter_list|)
block|{
name|int
name|diff
init|=
name|compareFamilies
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|rfoffset
argument_list|,
name|rflength
argument_list|)
decl_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|0
condition|)
return|return
name|diff
return|;
return|return
name|compareQualifiers
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|rqoffset
argument_list|,
name|rqlength
argument_list|)
return|;
block|}
block|}
end_class

end_unit

