begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shell
operator|.
name|formatter
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shell
operator|.
name|TableFormatter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|znerd
operator|.
name|xmlenc
operator|.
name|LineBreak
import|;
end_import

begin_import
import|import
name|org
operator|.
name|znerd
operator|.
name|xmlenc
operator|.
name|XMLOutputter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|znerd
operator|.
name|xmlenc
operator|.
name|XMLEncoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|znerd
operator|.
name|xmlenc
operator|.
name|InvalidXMLException
import|;
end_import

begin_comment
comment|/**  * Formatter that outputs data inside an HTML table. If only a single cell  * result, then no formatting is done.  Presumption is that client manages  * serial access outputting tables.  Does not close passed {@link Writer}.  * Since hbase columns have no typing, the formatter presumes a type of  * UTF-8 String.  If cells contain images, etc., this formatter will mangle  * their display.  *<p>TODO: Uses xmlenc. Hopefully it flushes every so often (Claims its a   * stream-based outputter).  Verify.  */
end_comment

begin_class
specifier|public
class|class
name|HtmlTableFormatter
implements|implements
name|TableFormatter
block|{
specifier|private
specifier|final
name|XMLOutputter
name|outputter
decl_stmt|;
specifier|private
name|boolean
name|noFormatting
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
name|Writer
name|out
decl_stmt|;
comment|// Uninstantiable
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|private
name|HtmlTableFormatter
parameter_list|()
block|{
name|this
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/*    * An encoder that replaces illegal XML characters with the '@' sign.    */
specifier|private
specifier|static
class|class
name|HbaseXMLEncoder
extends|extends
name|XMLEncoder
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|public
name|HbaseXMLEncoder
parameter_list|()
throws|throws
name|IllegalArgumentException
throws|,
name|UnsupportedEncodingException
block|{
name|super
argument_list|(
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|text
parameter_list|(
name|Writer
name|w
parameter_list|,
name|char
name|c
parameter_list|,
name|boolean
name|escape
parameter_list|)
throws|throws
name|InvalidXMLException
throws|,
name|IOException
block|{
name|super
operator|.
name|text
argument_list|(
name|w
argument_list|,
name|legalize
argument_list|(
name|c
argument_list|)
argument_list|,
name|escape
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|text
parameter_list|(
name|Writer
name|w
parameter_list|,
name|char
index|[]
name|cs
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|b
parameter_list|)
throws|throws
name|NullPointerException
throws|,
name|IndexOutOfBoundsException
throws|,
name|InvalidXMLException
throws|,
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|start
operator|+
name|length
condition|;
name|i
operator|++
control|)
block|{
name|cs
index|[
name|i
index|]
operator|=
name|legalize
argument_list|(
name|cs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|super
operator|.
name|text
argument_list|(
name|w
argument_list|,
name|cs
argument_list|,
name|start
argument_list|,
name|length
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
comment|/**      * If character is in range A, C, or E, then replace with '@'      *<pre>      * A   0-8     Control characters   -- Not allowed in XML 1.0 --      * B   9-10    Normal characters    Never needed      * C   11-12   Control characters   -- Not allowed in XML 1.0 --      * D   13      Normal character     Never needed      * E   14-31   Control characters   -- Not allowed in XML 1.0 --      *</pre>      * @param c Character to look at.      * @return      */
specifier|private
name|char
name|legalize
parameter_list|(
specifier|final
name|char
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|<=
literal|8
operator|||
name|c
operator|==
literal|11
operator|||
name|c
operator|==
literal|12
operator|||
operator|(
name|c
operator|>=
literal|14
operator|&&
name|c
operator|<=
literal|31
operator|)
operator|)
condition|?
literal|'@'
else|:
name|c
return|;
block|}
block|}
specifier|public
name|HtmlTableFormatter
parameter_list|(
specifier|final
name|Writer
name|o
parameter_list|)
block|{
name|this
operator|.
name|out
operator|=
name|o
expr_stmt|;
try|try
block|{
comment|// Looking at the xmlenc source, there should be no issue w/ wrapping
comment|// the stream -- i.e. no hanging resources.
name|this
operator|.
name|outputter
operator|=
operator|new
name|XMLOutputter
argument_list|(
name|this
operator|.
name|out
argument_list|,
operator|new
name|HbaseXMLEncoder
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|os
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"os.name"
argument_list|)
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
comment|// Shell likes the DOS output.
name|this
operator|.
name|outputter
operator|.
name|setLineBreak
argument_list|(
name|os
operator|.
name|contains
argument_list|(
literal|"windows"
argument_list|)
condition|?
name|LineBreak
operator|.
name|DOS
else|:
name|LineBreak
operator|.
name|UNIX
argument_list|)
expr_stmt|;
name|this
operator|.
name|outputter
operator|.
name|setIndentation
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * @param titles List of titles.  Pass null if no formatting (i.e.    * no header, no footer, etc.    * @throws IOException     */
specifier|public
name|void
name|header
parameter_list|(
name|String
index|[]
name|titles
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|titles
operator|==
literal|null
condition|)
block|{
comment|// print nothing.
name|setNoFormatting
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Can't add a 'border=1' attribute because its included on the end in
name|this
operator|.
name|outputter
operator|.
name|startTag
argument_list|(
literal|"table"
argument_list|)
expr_stmt|;
name|this
operator|.
name|outputter
operator|.
name|startTag
argument_list|(
literal|"tr"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|titles
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|this
operator|.
name|outputter
operator|.
name|startTag
argument_list|(
literal|"th"
argument_list|)
expr_stmt|;
name|this
operator|.
name|outputter
operator|.
name|pcdata
argument_list|(
name|titles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|this
operator|.
name|outputter
operator|.
name|endTag
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|outputter
operator|.
name|endTag
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|row
parameter_list|(
name|String
index|[]
name|cells
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isNoFormatting
argument_list|()
condition|)
block|{
name|getOut
argument_list|()
operator|.
name|write
argument_list|(
name|cells
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|this
operator|.
name|outputter
operator|.
name|startTag
argument_list|(
literal|"tr"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cells
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|this
operator|.
name|outputter
operator|.
name|startTag
argument_list|(
literal|"td"
argument_list|)
expr_stmt|;
name|this
operator|.
name|outputter
operator|.
name|pcdata
argument_list|(
name|cells
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|this
operator|.
name|outputter
operator|.
name|endTag
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|outputter
operator|.
name|endTag
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|footer
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isNoFormatting
argument_list|()
condition|)
block|{
comment|// To close the table
name|this
operator|.
name|outputter
operator|.
name|endTag
argument_list|()
expr_stmt|;
name|this
operator|.
name|outputter
operator|.
name|endDocument
argument_list|()
expr_stmt|;
block|}
comment|// We're done. Clear flag.
name|this
operator|.
name|setNoFormatting
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// If no formatting, output a newline to delimit cell and the
comment|// result summary output at end of every command.  If html, also emit a
comment|// newline to delimit html and summary line.
name|getOut
argument_list|()
operator|.
name|write
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
argument_list|)
expr_stmt|;
name|getOut
argument_list|()
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
specifier|public
name|Writer
name|getOut
parameter_list|()
block|{
return|return
name|this
operator|.
name|out
return|;
block|}
specifier|public
name|boolean
name|isNoFormatting
parameter_list|()
block|{
return|return
name|this
operator|.
name|noFormatting
return|;
block|}
specifier|public
name|void
name|setNoFormatting
parameter_list|(
name|boolean
name|noFormatting
parameter_list|)
block|{
name|this
operator|.
name|noFormatting
operator|=
name|noFormatting
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|IOException
block|{
name|HtmlTableFormatter
name|f
init|=
operator|new
name|HtmlTableFormatter
argument_list|(
operator|new
name|OutputStreamWriter
argument_list|(
name|System
operator|.
name|out
argument_list|,
literal|"UTF-8"
argument_list|)
argument_list|)
decl_stmt|;
name|f
operator|.
name|header
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"b"
block|}
argument_list|)
expr_stmt|;
name|f
operator|.
name|row
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"b"
block|}
argument_list|)
expr_stmt|;
name|f
operator|.
name|footer
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

