begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2009 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|UndeclaredThrowableException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|WeakHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|DoNotRetryIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerAddress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MasterNotRunningException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|RemoteExceptionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MetaScanner
operator|.
name|MetaScannerVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HBaseRPC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HBaseRPCProtocolVersion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HMasterInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HRegionInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|MetaUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|SoftValueSortedMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Writables
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperWrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|WatchedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|Watcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|Watcher
operator|.
name|Event
operator|.
name|KeeperState
import|;
end_import

begin_comment
comment|/**  * A non-instantiable class that manages connections to multiple tables in  * multiple HBase instances.  *   * Used by {@link HTable} and {@link HBaseAdmin}  */
end_comment

begin_class
specifier|public
class|class
name|HConnectionManager
implements|implements
name|HConstants
block|{
comment|/*    * Not instantiable.    */
specifier|protected
name|HConnectionManager
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
comment|// A Map of master HBaseConfiguration -> connection information for that
comment|// instance. Note that although the Map is synchronized, the objects it
comment|// contains are mutable and hence require synchronized access to them
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|HBaseConfiguration
argument_list|,
name|TableServers
argument_list|>
name|HBASE_INSTANCES
init|=
operator|new
name|WeakHashMap
argument_list|<
name|HBaseConfiguration
argument_list|,
name|TableServers
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Get the connection object for the instance specified by the configuration    * If no current connection exists, create a new connection for that instance    * @param conf    * @return HConnection object for the instance specified by the configuration    */
specifier|public
specifier|static
name|HConnection
name|getConnection
parameter_list|(
name|HBaseConfiguration
name|conf
parameter_list|)
block|{
name|TableServers
name|connection
decl_stmt|;
synchronized|synchronized
init|(
name|HBASE_INSTANCES
init|)
block|{
name|connection
operator|=
name|HBASE_INSTANCES
operator|.
name|get
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|connection
operator|==
literal|null
condition|)
block|{
name|connection
operator|=
operator|new
name|TableServers
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|HBASE_INSTANCES
operator|.
name|put
argument_list|(
name|conf
argument_list|,
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|connection
return|;
block|}
comment|/**    * Delete connection information for the instance specified by configuration    * @param conf    * @param stopProxy    */
specifier|public
specifier|static
name|void
name|deleteConnectionInfo
parameter_list|(
name|HBaseConfiguration
name|conf
parameter_list|,
name|boolean
name|stopProxy
parameter_list|)
block|{
synchronized|synchronized
init|(
name|HBASE_INSTANCES
init|)
block|{
name|TableServers
name|t
init|=
name|HBASE_INSTANCES
operator|.
name|remove
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|close
argument_list|(
name|stopProxy
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Delete information for all connections.    * @param stopProxy    */
specifier|public
specifier|static
name|void
name|deleteAllConnections
parameter_list|(
name|boolean
name|stopProxy
parameter_list|)
block|{
synchronized|synchronized
init|(
name|HBASE_INSTANCES
init|)
block|{
for|for
control|(
name|TableServers
name|t
range|:
name|HBASE_INSTANCES
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|close
argument_list|(
name|stopProxy
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Encapsulates finding the servers for an HBase instance */
specifier|private
specifier|static
class|class
name|TableServers
implements|implements
name|ServerConnection
implements|,
name|HConstants
implements|,
name|Watcher
block|{
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TableServers
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|HRegionInterface
argument_list|>
name|serverInterfaceClass
decl_stmt|;
specifier|private
specifier|final
name|long
name|pause
decl_stmt|;
specifier|private
specifier|final
name|int
name|numRetries
decl_stmt|;
specifier|private
specifier|final
name|int
name|maxRPCAttempts
decl_stmt|;
specifier|private
specifier|final
name|long
name|rpcTimeout
decl_stmt|;
specifier|private
specifier|final
name|Object
name|masterLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|closed
decl_stmt|;
specifier|private
specifier|volatile
name|HMasterInterface
name|master
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|masterChecked
decl_stmt|;
specifier|private
specifier|final
name|Object
name|rootRegionLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Object
name|metaRegionLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Object
name|userRegionLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
specifier|volatile
name|HBaseConfiguration
name|conf
decl_stmt|;
comment|// Known region HServerAddress.toString() -> HRegionInterface
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|HRegionInterface
argument_list|>
name|servers
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|HRegionInterface
argument_list|>
argument_list|()
decl_stmt|;
comment|// Used by master and region servers during safe mode only
specifier|private
specifier|volatile
name|HRegionLocation
name|rootRegionLocation
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|SoftValueSortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
argument_list|>
name|cachedRegionLocations
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|SoftValueSortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|ZooKeeperWrapper
name|zooKeeperWrapper
decl_stmt|;
comment|/**       * constructor      * @param conf Configuration object      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|TableServers
parameter_list|(
name|HBaseConfiguration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|String
name|serverClassName
init|=
name|conf
operator|.
name|get
argument_list|(
name|REGION_SERVER_CLASS
argument_list|,
name|DEFAULT_REGION_SERVER_CLASS
argument_list|)
decl_stmt|;
name|this
operator|.
name|closed
operator|=
literal|false
expr_stmt|;
try|try
block|{
name|this
operator|.
name|serverInterfaceClass
operator|=
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|HRegionInterface
argument_list|>
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|serverClassName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Unable to find region server interface "
operator|+
name|serverClassName
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|this
operator|.
name|pause
operator|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.client.pause"
argument_list|,
literal|2
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|this
operator|.
name|numRetries
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.client.retries.number"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxRPCAttempts
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.client.rpc.maxattempts"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|this
operator|.
name|rpcTimeout
operator|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.regionserver.lease.period"
argument_list|,
literal|60000
argument_list|)
expr_stmt|;
name|this
operator|.
name|master
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|masterChecked
operator|=
literal|false
expr_stmt|;
block|}
specifier|private
name|long
name|getPauseTime
parameter_list|(
name|int
name|tries
parameter_list|)
block|{
name|int
name|ntries
init|=
name|tries
decl_stmt|;
if|if
condition|(
name|ntries
operator|>=
name|HConstants
operator|.
name|RETRY_BACKOFF
operator|.
name|length
condition|)
name|ntries
operator|=
name|HConstants
operator|.
name|RETRY_BACKOFF
operator|.
name|length
operator|-
literal|1
expr_stmt|;
return|return
name|this
operator|.
name|pause
operator|*
name|HConstants
operator|.
name|RETRY_BACKOFF
index|[
name|ntries
index|]
return|;
block|}
comment|/**      * Called by ZooKeeper when an event occurs on our connection. We use this to      * detect our session expiring. When our session expires, we have lost our      * connection to ZooKeeper. Our handle is dead, and we need to recreate it.      *      * See http://hadoop.apache.org/zookeeper/docs/current/zookeeperProgrammers.html#ch_zkSessions      * for more information.      *      * @param event WatchedEvent witnessed by ZooKeeper.      */
specifier|public
name|void
name|process
parameter_list|(
name|WatchedEvent
name|event
parameter_list|)
block|{
name|KeeperState
name|state
init|=
name|event
operator|.
name|getState
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Got ZooKeeper event, state: "
operator|+
name|state
operator|+
literal|", type: "
operator|+
name|event
operator|.
name|getType
argument_list|()
operator|+
literal|", path: "
operator|+
name|event
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|KeeperState
operator|.
name|Expired
condition|)
block|{
name|resetZooKeeper
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
specifier|synchronized
name|void
name|resetZooKeeper
parameter_list|()
block|{
if|if
condition|(
name|zooKeeperWrapper
operator|!=
literal|null
condition|)
block|{
name|zooKeeperWrapper
operator|.
name|close
argument_list|()
expr_stmt|;
name|zooKeeperWrapper
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// Used by master and region servers during safe mode only
specifier|public
name|void
name|unsetRootRegionLocation
parameter_list|()
block|{
name|this
operator|.
name|rootRegionLocation
operator|=
literal|null
expr_stmt|;
block|}
comment|// Used by master and region servers during safe mode only
specifier|public
name|void
name|setRootRegionLocation
parameter_list|(
name|HRegionLocation
name|rootRegion
parameter_list|)
block|{
if|if
condition|(
name|rootRegion
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot set root region location to null."
argument_list|)
throw|;
block|}
name|this
operator|.
name|rootRegionLocation
operator|=
name|rootRegion
expr_stmt|;
block|}
specifier|public
name|HMasterInterface
name|getMaster
parameter_list|()
throws|throws
name|MasterNotRunningException
block|{
name|ZooKeeperWrapper
name|zk
init|=
literal|null
decl_stmt|;
try|try
block|{
name|zk
operator|=
name|getZooKeeperWrapper
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|MasterNotRunningException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|HServerAddress
name|masterLocation
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|masterLock
init|)
block|{
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
operator|!
name|this
operator|.
name|closed
operator|&&
operator|!
name|this
operator|.
name|masterChecked
operator|&&
name|this
operator|.
name|master
operator|==
literal|null
operator|&&
name|tries
operator|<
name|numRetries
condition|;
name|tries
operator|++
control|)
block|{
try|try
block|{
name|masterLocation
operator|=
name|zk
operator|.
name|readMasterAddressOrThrow
argument_list|()
expr_stmt|;
name|HMasterInterface
name|tryMaster
init|=
operator|(
name|HMasterInterface
operator|)
name|HBaseRPC
operator|.
name|getProxy
argument_list|(
name|HMasterInterface
operator|.
name|class
argument_list|,
name|HBaseRPCProtocolVersion
operator|.
name|versionID
argument_list|,
name|masterLocation
operator|.
name|getInetSocketAddress
argument_list|()
argument_list|,
name|this
operator|.
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|tryMaster
operator|.
name|isMasterRunning
argument_list|()
condition|)
block|{
name|this
operator|.
name|master
operator|=
name|tryMaster
expr_stmt|;
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
comment|// This was our last chance - don't bother sleeping
break|break;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"getMaster attempt "
operator|+
name|tries
operator|+
literal|" of "
operator|+
name|this
operator|.
name|numRetries
operator|+
literal|" failed; retrying after sleep of "
operator|+
name|getPauseTime
argument_list|(
name|tries
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// Cannot connect to master or it is not running. Sleep& retry
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|getPauseTime
argument_list|(
name|tries
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// continue
block|}
block|}
name|this
operator|.
name|masterChecked
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|master
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|masterLocation
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|MasterNotRunningException
argument_list|()
throw|;
block|}
throw|throw
operator|new
name|MasterNotRunningException
argument_list|(
name|masterLocation
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|this
operator|.
name|master
return|;
block|}
specifier|public
name|boolean
name|isMasterRunning
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|master
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|getMaster
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MasterNotRunningException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|tableExists
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|MasterNotRunningException
block|{
name|getMaster
argument_list|()
expr_stmt|;
if|if
condition|(
name|tableName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Table name cannot be null"
argument_list|)
throw|;
block|}
if|if
condition|(
name|isMetaTableName
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|boolean
name|exists
init|=
literal|false
decl_stmt|;
try|try
block|{
name|HTableDescriptor
index|[]
name|tables
init|=
name|listTables
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tables
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|tables
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
argument_list|,
name|tableName
argument_list|)
condition|)
block|{
name|exists
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Testing for table existence threw exception"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|exists
return|;
block|}
comment|/*      * @param n      * @return Truen if passed tablename<code>n</code> is equal to the name      * of a catalog table.      */
specifier|private
specifier|static
name|boolean
name|isMetaTableName
parameter_list|(
specifier|final
name|byte
index|[]
name|n
parameter_list|)
block|{
return|return
name|MetaUtils
operator|.
name|isMetaTableName
argument_list|(
name|n
argument_list|)
return|;
block|}
specifier|public
name|HRegionLocation
name|getRegionLocation
parameter_list|(
specifier|final
name|byte
index|[]
name|name
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
name|boolean
name|reload
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|reload
condition|?
name|relocateRegion
argument_list|(
name|name
argument_list|,
name|row
argument_list|)
else|:
name|locateRegion
argument_list|(
name|name
argument_list|,
name|row
argument_list|)
return|;
block|}
specifier|public
name|HTableDescriptor
index|[]
name|listTables
parameter_list|()
throws|throws
name|IOException
block|{
name|getMaster
argument_list|()
expr_stmt|;
specifier|final
name|TreeSet
argument_list|<
name|HTableDescriptor
argument_list|>
name|uniqueTables
init|=
operator|new
name|TreeSet
argument_list|<
name|HTableDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|MetaScannerVisitor
name|visitor
init|=
operator|new
name|MetaScannerVisitor
argument_list|()
block|{
specifier|public
name|boolean
name|processRow
parameter_list|(
name|Result
name|result
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|byte
index|[]
name|value
init|=
name|result
operator|.
name|getValue
argument_list|(
name|CATALOG_FAMILY
argument_list|,
name|REGIONINFO_QUALIFIER
argument_list|)
decl_stmt|;
name|HRegionInfo
name|info
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|info
operator|=
name|Writables
operator|.
name|getHRegionInfo
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
comment|// Only examine the rows where the startKey is zero length
if|if
condition|(
name|info
operator|!=
literal|null
operator|&&
name|info
operator|.
name|getStartKey
argument_list|()
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|uniqueTables
operator|.
name|add
argument_list|(
name|info
operator|.
name|getTableDesc
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Result="
operator|+
name|result
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
block|}
decl_stmt|;
name|MetaScanner
operator|.
name|metaScan
argument_list|(
name|conf
argument_list|,
name|visitor
argument_list|)
expr_stmt|;
return|return
name|uniqueTables
operator|.
name|toArray
argument_list|(
operator|new
name|HTableDescriptor
index|[
name|uniqueTables
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isTableEnabled
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|testTableOnlineState
argument_list|(
name|tableName
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isTableDisabled
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|testTableOnlineState
argument_list|(
name|tableName
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/*      * If online == true      *   Returns true if all regions are online      *   Returns false in any other case      * If online == false      *   Returns true if all regions are offline      *   Returns false in any other case      */
specifier|private
name|boolean
name|testTableOnlineState
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|,
name|boolean
name|online
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|tableExists
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TableNotFoundException
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|tableName
argument_list|,
name|HConstants
operator|.
name|ROOT_TABLE_NAME
argument_list|)
condition|)
block|{
comment|// The root region is always enabled
return|return
literal|true
return|;
block|}
name|int
name|rowsScanned
init|=
literal|0
decl_stmt|;
name|int
name|rowsOffline
init|=
literal|0
decl_stmt|;
name|byte
index|[]
name|startKey
init|=
name|HRegionInfo
operator|.
name|createRegionName
argument_list|(
name|tableName
argument_list|,
literal|null
argument_list|,
name|HConstants
operator|.
name|ZEROES
argument_list|)
decl_stmt|;
name|byte
index|[]
name|endKey
init|=
literal|null
decl_stmt|;
name|HRegionInfo
name|currentRegion
init|=
literal|null
decl_stmt|;
name|Scan
name|scan
init|=
operator|new
name|Scan
argument_list|(
name|startKey
argument_list|)
decl_stmt|;
name|scan
operator|.
name|addColumn
argument_list|(
name|CATALOG_FAMILY
argument_list|,
name|REGIONINFO_QUALIFIER
argument_list|)
expr_stmt|;
name|ScannerCallable
name|s
init|=
operator|new
name|ScannerCallable
argument_list|(
name|this
argument_list|,
operator|(
name|Bytes
operator|.
name|equals
argument_list|(
name|tableName
argument_list|,
name|HConstants
operator|.
name|META_TABLE_NAME
argument_list|)
condition|?
name|HConstants
operator|.
name|ROOT_TABLE_NAME
else|:
name|HConstants
operator|.
name|META_TABLE_NAME
operator|)
argument_list|,
name|scan
argument_list|)
decl_stmt|;
try|try
block|{
comment|// Open scanner
name|getRegionServerWithRetries
argument_list|(
name|s
argument_list|)
expr_stmt|;
do|do
block|{
name|HRegionInfo
name|oldRegion
init|=
name|currentRegion
decl_stmt|;
if|if
condition|(
name|oldRegion
operator|!=
literal|null
condition|)
block|{
name|startKey
operator|=
name|oldRegion
operator|.
name|getEndKey
argument_list|()
expr_stmt|;
block|}
name|currentRegion
operator|=
name|s
operator|.
name|getHRegionInfo
argument_list|()
expr_stmt|;
name|Result
name|r
init|=
literal|null
decl_stmt|;
name|Result
index|[]
name|rrs
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|(
name|rrs
operator|=
name|getRegionServerWithRetries
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|r
operator|=
name|rrs
index|[
literal|0
index|]
expr_stmt|;
name|byte
index|[]
name|value
init|=
name|r
operator|.
name|getValue
argument_list|(
name|HConstants
operator|.
name|CATALOG_FAMILY
argument_list|,
name|HConstants
operator|.
name|REGIONINFO_QUALIFIER
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|HRegionInfo
name|info
init|=
name|Writables
operator|.
name|getHRegionInfoOrNull
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|info
operator|.
name|getTableDesc
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|tableName
argument_list|)
condition|)
block|{
name|rowsScanned
operator|+=
literal|1
expr_stmt|;
name|rowsOffline
operator|+=
name|info
operator|.
name|isOffline
argument_list|()
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
name|endKey
operator|=
name|currentRegion
operator|.
name|getEndKey
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|endKey
operator|==
literal|null
operator|||
name|Bytes
operator|.
name|equals
argument_list|(
name|endKey
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|)
operator|)
condition|)
do|;
block|}
finally|finally
block|{
name|s
operator|.
name|setClose
argument_list|()
expr_stmt|;
block|}
name|boolean
name|onlineOffline
init|=
name|online
condition|?
name|rowsOffline
operator|==
literal|0
else|:
name|rowsOffline
operator|==
name|rowsScanned
decl_stmt|;
return|return
name|rowsScanned
operator|>
literal|0
operator|&&
name|onlineOffline
return|;
block|}
specifier|private
specifier|static
class|class
name|HTableDescriptorFinder
implements|implements
name|MetaScanner
operator|.
name|MetaScannerVisitor
block|{
name|byte
index|[]
name|tableName
decl_stmt|;
name|HTableDescriptor
name|result
decl_stmt|;
specifier|protected
name|HTableDescriptorFinder
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|)
block|{
name|this
operator|.
name|tableName
operator|=
name|tableName
expr_stmt|;
block|}
specifier|public
name|boolean
name|processRow
parameter_list|(
name|Result
name|rowResult
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegionInfo
name|info
init|=
name|Writables
operator|.
name|getHRegionInfo
argument_list|(
name|rowResult
operator|.
name|getValue
argument_list|(
name|CATALOG_FAMILY
argument_list|,
name|REGIONINFO_QUALIFIER
argument_list|)
argument_list|)
decl_stmt|;
name|HTableDescriptor
name|desc
init|=
name|info
operator|.
name|getTableDesc
argument_list|()
decl_stmt|;
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|desc
operator|.
name|getName
argument_list|()
argument_list|,
name|tableName
argument_list|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|desc
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
name|HTableDescriptor
name|getResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
block|}
specifier|public
name|HTableDescriptor
name|getHTableDescriptor
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|tableName
argument_list|,
name|HConstants
operator|.
name|ROOT_TABLE_NAME
argument_list|)
condition|)
block|{
return|return
operator|new
name|UnmodifyableHTableDescriptor
argument_list|(
name|HTableDescriptor
operator|.
name|ROOT_TABLEDESC
argument_list|)
return|;
block|}
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|tableName
argument_list|,
name|HConstants
operator|.
name|META_TABLE_NAME
argument_list|)
condition|)
block|{
return|return
name|HTableDescriptor
operator|.
name|META_TABLEDESC
return|;
block|}
name|HTableDescriptorFinder
name|finder
init|=
operator|new
name|HTableDescriptorFinder
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|MetaScanner
operator|.
name|metaScan
argument_list|(
name|conf
argument_list|,
name|finder
argument_list|)
expr_stmt|;
name|HTableDescriptor
name|result
init|=
name|finder
operator|.
name|getResult
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|TableNotFoundException
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|result
return|;
block|}
specifier|public
name|HRegionLocation
name|locateRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|locateRegion
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|public
name|HRegionLocation
name|relocateRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|locateRegion
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|private
name|HRegionLocation
name|locateRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
name|boolean
name|useCache
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|tableName
operator|==
literal|null
operator|||
name|tableName
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"table name cannot be null or zero length"
argument_list|)
throw|;
block|}
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|tableName
argument_list|,
name|ROOT_TABLE_NAME
argument_list|)
condition|)
block|{
synchronized|synchronized
init|(
name|rootRegionLock
init|)
block|{
comment|// This block guards against two threads trying to find the root
comment|// region at the same time. One will go do the find while the
comment|// second waits. The second thread will not do find.
if|if
condition|(
operator|!
name|useCache
operator|||
name|rootRegionLocation
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|rootRegionLocation
operator|=
name|locateRootRegion
argument_list|()
expr_stmt|;
block|}
return|return
name|this
operator|.
name|rootRegionLocation
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|tableName
argument_list|,
name|META_TABLE_NAME
argument_list|)
condition|)
block|{
synchronized|synchronized
init|(
name|metaRegionLock
init|)
block|{
comment|// This block guards against two threads trying to load the meta
comment|// region at the same time. The first will load the meta region and
comment|// the second will use the value that the first one found.
return|return
name|locateRegionInMeta
argument_list|(
name|ROOT_TABLE_NAME
argument_list|,
name|tableName
argument_list|,
name|row
argument_list|,
name|useCache
argument_list|)
return|;
block|}
block|}
else|else
block|{
synchronized|synchronized
init|(
name|userRegionLock
init|)
block|{
return|return
name|locateRegionInMeta
argument_list|(
name|META_TABLE_NAME
argument_list|,
name|tableName
argument_list|,
name|row
argument_list|,
name|useCache
argument_list|)
return|;
block|}
block|}
block|}
comment|/*       * Search one of the meta tables (-ROOT- or .META.) for the HRegionLocation       * info that contains the table and row we're seeking.       */
specifier|private
name|HRegionLocation
name|locateRegionInMeta
parameter_list|(
specifier|final
name|byte
index|[]
name|parentTable
parameter_list|,
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
name|boolean
name|useCache
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegionLocation
name|location
init|=
literal|null
decl_stmt|;
comment|// If supposed to be using the cache, then check it for a possible hit.
comment|// Otherwise, delete any existing cached location so it won't interfere.
if|if
condition|(
name|useCache
condition|)
block|{
name|location
operator|=
name|getCachedLocation
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
literal|null
condition|)
block|{
return|return
name|location
return|;
block|}
block|}
else|else
block|{
name|deleteCachedLocation
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
comment|// build the key of the meta region we should be looking for.
comment|// the extra 9's on the end are necessary to allow "exact" matches
comment|// without knowing the precise region names.
name|byte
index|[]
name|metaKey
init|=
name|HRegionInfo
operator|.
name|createRegionName
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|,
name|HConstants
operator|.
name|NINES
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
literal|true
condition|;
name|tries
operator|++
control|)
block|{
if|if
condition|(
name|tries
operator|>=
name|numRetries
condition|)
block|{
throw|throw
operator|new
name|NoServerForRegionException
argument_list|(
literal|"Unable to find region for "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|row
argument_list|)
operator|+
literal|" after "
operator|+
name|numRetries
operator|+
literal|" tries."
argument_list|)
throw|;
block|}
try|try
block|{
comment|// locate the root or meta region
name|HRegionLocation
name|metaLocation
init|=
name|locateRegion
argument_list|(
name|parentTable
argument_list|,
name|metaKey
argument_list|)
decl_stmt|;
name|HRegionInterface
name|server
init|=
name|getHRegionConnection
argument_list|(
name|metaLocation
operator|.
name|getServerAddress
argument_list|()
argument_list|)
decl_stmt|;
comment|// Query the root or meta region for the location of the meta region
name|Result
name|regionInfoRow
init|=
name|server
operator|.
name|getClosestRowBefore
argument_list|(
name|metaLocation
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|metaKey
argument_list|,
name|HConstants
operator|.
name|CATALOG_FAMILY
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionInfoRow
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|TableNotFoundException
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
throw|;
block|}
name|byte
index|[]
name|value
init|=
name|regionInfoRow
operator|.
name|getValue
argument_list|(
name|CATALOG_FAMILY
argument_list|,
name|REGIONINFO_QUALIFIER
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
operator|||
name|value
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"HRegionInfo was null or empty in "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|parentTable
argument_list|)
argument_list|)
throw|;
block|}
comment|// convert the row result into the HRegionLocation we need!
name|HRegionInfo
name|regionInfo
init|=
operator|(
name|HRegionInfo
operator|)
name|Writables
operator|.
name|getWritable
argument_list|(
name|value
argument_list|,
operator|new
name|HRegionInfo
argument_list|()
argument_list|)
decl_stmt|;
comment|// possible we got a region of a different table...
if|if
condition|(
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|regionInfo
operator|.
name|getTableDesc
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TableNotFoundException
argument_list|(
literal|"Table '"
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
operator|+
literal|"' was not found."
argument_list|)
throw|;
block|}
if|if
condition|(
name|regionInfo
operator|.
name|isOffline
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RegionOfflineException
argument_list|(
literal|"region offline: "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
throw|;
block|}
name|value
operator|=
name|regionInfoRow
operator|.
name|getValue
argument_list|(
name|CATALOG_FAMILY
argument_list|,
name|SERVER_QUALIFIER
argument_list|)
expr_stmt|;
name|String
name|serverAddress
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|serverAddress
operator|=
name|Bytes
operator|.
name|toString
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|serverAddress
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|NoServerForRegionException
argument_list|(
literal|"No server address listed "
operator|+
literal|"in "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|parentTable
argument_list|)
operator|+
literal|" for region "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
throw|;
block|}
comment|// instantiate the location
name|location
operator|=
operator|new
name|HRegionLocation
argument_list|(
name|regionInfo
argument_list|,
operator|new
name|HServerAddress
argument_list|(
name|serverAddress
argument_list|)
argument_list|)
expr_stmt|;
name|cacheLocation
argument_list|(
name|tableName
argument_list|,
name|location
argument_list|)
expr_stmt|;
return|return
name|location
return|;
block|}
catch|catch
parameter_list|(
name|TableNotFoundException
name|e
parameter_list|)
block|{
comment|// if we got this error, probably means the table just plain doesn't
comment|// exist. rethrow the error immediately. this should always be coming
comment|// from the HTable constructor.
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|RemoteException
condition|)
block|{
name|e
operator|=
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
operator|(
name|RemoteException
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tries
operator|<
name|numRetries
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"locateRegionInMeta attempt "
operator|+
name|tries
operator|+
literal|" of "
operator|+
name|this
operator|.
name|numRetries
operator|+
literal|" failed; retrying after sleep of "
operator|+
name|getPauseTime
argument_list|(
name|tries
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|relocateRegion
argument_list|(
name|parentTable
argument_list|,
name|metaKey
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|getPauseTime
argument_list|(
name|tries
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// continue
block|}
block|}
block|}
comment|/*      * Search the cache for a location that fits our table and row key.      * Return null if no suitable region is located. TODO: synchronization note      *       *<p>TODO: This method during writing consumes 15% of CPU doing lookup      * into the Soft Reference SortedMap.  Improve.      *       * @param tableName      * @param row      * @return Null or region location found in cache.      */
specifier|private
name|HRegionLocation
name|getCachedLocation
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|)
block|{
name|SoftValueSortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|tableLocations
init|=
name|getTableLocations
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
comment|// start to examine the cache. we can only do cache actions
comment|// if there's something in the cache for this table.
if|if
condition|(
name|tableLocations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|HRegionLocation
name|rl
init|=
name|tableLocations
operator|.
name|get
argument_list|(
name|row
argument_list|)
decl_stmt|;
if|if
condition|(
name|rl
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Cache hit for row<"
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|row
argument_list|)
operator|+
literal|"> in tableName "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
operator|+
literal|": location server "
operator|+
name|rl
operator|.
name|getServerAddress
argument_list|()
operator|+
literal|", location region name "
operator|+
name|rl
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|rl
return|;
block|}
comment|// Cut the cache so that we only get the part that could contain
comment|// regions that match our key
name|SoftValueSortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|matchingRegions
init|=
name|tableLocations
operator|.
name|headMap
argument_list|(
name|row
argument_list|)
decl_stmt|;
comment|// if that portion of the map is empty, then we're done. otherwise,
comment|// we need to examine the cached location to verify that it is
comment|// a match by end key as well.
if|if
condition|(
operator|!
name|matchingRegions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|HRegionLocation
name|possibleRegion
init|=
name|matchingRegions
operator|.
name|get
argument_list|(
name|matchingRegions
operator|.
name|lastKey
argument_list|()
argument_list|)
decl_stmt|;
comment|// there is a possibility that the reference was garbage collected
comment|// in the instant since we checked isEmpty().
if|if
condition|(
name|possibleRegion
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|endKey
init|=
name|possibleRegion
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEndKey
argument_list|()
decl_stmt|;
comment|// make sure that the end key is greater than the row we're looking
comment|// for, otherwise the row actually belongs in the next region, not
comment|// this one. the exception case is when the endkey is EMPTY_START_ROW,
comment|// signifying that the region we're checking is actually the last
comment|// region in the table.
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|endKey
argument_list|,
name|HConstants
operator|.
name|EMPTY_END_ROW
argument_list|)
operator|||
name|KeyValue
operator|.
name|getRowComparator
argument_list|(
name|tableName
argument_list|)
operator|.
name|compareRows
argument_list|(
name|endKey
argument_list|,
literal|0
argument_list|,
name|endKey
operator|.
name|length
argument_list|,
name|row
argument_list|,
literal|0
argument_list|,
name|row
operator|.
name|length
argument_list|)
operator|>
literal|0
condition|)
block|{
return|return
name|possibleRegion
return|;
block|}
block|}
block|}
comment|// Passed all the way through, so we got nothin - complete cache miss
return|return
literal|null
return|;
block|}
comment|/*      * Delete a cached location, if it satisfies the table name and row      * requirements.      */
specifier|private
name|void
name|deleteCachedLocation
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|)
block|{
name|SoftValueSortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|tableLocations
init|=
name|getTableLocations
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
comment|// start to examine the cache. we can only do cache actions
comment|// if there's something in the cache for this table.
if|if
condition|(
operator|!
name|tableLocations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// cut the cache so that we only get the part that could contain
comment|// regions that match our key
name|SoftValueSortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|matchingRegions
init|=
name|tableLocations
operator|.
name|headMap
argument_list|(
name|row
argument_list|)
decl_stmt|;
comment|// if that portion of the map is empty, then we're done. otherwise,
comment|// we need to examine the cached location to verify that it is
comment|// a match by end key as well.
if|if
condition|(
operator|!
name|matchingRegions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|HRegionLocation
name|possibleRegion
init|=
name|matchingRegions
operator|.
name|get
argument_list|(
name|matchingRegions
operator|.
name|lastKey
argument_list|()
argument_list|)
decl_stmt|;
name|byte
index|[]
name|endKey
init|=
name|possibleRegion
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEndKey
argument_list|()
decl_stmt|;
comment|// by nature of the map, we know that the start key has to be<
comment|// otherwise it wouldn't be in the headMap.
if|if
condition|(
name|KeyValue
operator|.
name|getRowComparator
argument_list|(
name|tableName
argument_list|)
operator|.
name|compareRows
argument_list|(
name|endKey
argument_list|,
literal|0
argument_list|,
name|endKey
operator|.
name|length
argument_list|,
name|row
argument_list|,
literal|0
argument_list|,
name|row
operator|.
name|length
argument_list|)
operator|<=
literal|0
condition|)
block|{
comment|// delete any matching entry
name|HRegionLocation
name|rl
init|=
name|tableLocations
operator|.
name|remove
argument_list|(
name|matchingRegions
operator|.
name|lastKey
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rl
operator|!=
literal|null
operator|&&
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removed "
operator|+
name|rl
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" for tableName="
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
operator|+
literal|" from cache "
operator|+
literal|"because of "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|row
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/*      * @param tableName      * @return Map of cached locations for passed<code>tableName</code>      */
specifier|private
name|SoftValueSortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|getTableLocations
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
block|{
comment|// find the map of cached locations for this table
name|Integer
name|key
init|=
name|Bytes
operator|.
name|mapKey
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|SoftValueSortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|result
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|cachedRegionLocations
init|)
block|{
name|result
operator|=
name|this
operator|.
name|cachedRegionLocations
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
comment|// if tableLocations for this table isn't built yet, make one
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|result
operator|=
operator|new
name|SoftValueSortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
expr_stmt|;
name|this
operator|.
name|cachedRegionLocations
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/*      * Put a newly discovered HRegionLocation into the cache.      */
specifier|private
name|void
name|cacheLocation
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|HRegionLocation
name|location
parameter_list|)
block|{
name|byte
index|[]
name|startKey
init|=
name|location
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getStartKey
argument_list|()
decl_stmt|;
name|SoftValueSortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|tableLocations
init|=
name|getTableLocations
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|tableLocations
operator|.
name|put
argument_list|(
name|startKey
argument_list|,
name|location
argument_list|)
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Cached location "
operator|+
name|location
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|HRegionInterface
name|getHRegionConnection
parameter_list|(
name|HServerAddress
name|regionServer
parameter_list|,
name|boolean
name|getMaster
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|getMaster
condition|)
block|{
name|getMaster
argument_list|()
expr_stmt|;
block|}
name|HRegionInterface
name|server
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|servers
init|)
block|{
comment|// See if we already have a connection
name|server
operator|=
name|this
operator|.
name|servers
operator|.
name|get
argument_list|(
name|regionServer
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
operator|==
literal|null
condition|)
block|{
comment|// Get a connection
try|try
block|{
name|server
operator|=
operator|(
name|HRegionInterface
operator|)
name|HBaseRPC
operator|.
name|waitForProxy
argument_list|(
name|serverInterfaceClass
argument_list|,
name|HBaseRPCProtocolVersion
operator|.
name|versionID
argument_list|,
name|regionServer
operator|.
name|getInetSocketAddress
argument_list|()
argument_list|,
name|this
operator|.
name|conf
argument_list|,
name|this
operator|.
name|maxRPCAttempts
argument_list|,
name|this
operator|.
name|rpcTimeout
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
throw|throw
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|this
operator|.
name|servers
operator|.
name|put
argument_list|(
name|regionServer
operator|.
name|toString
argument_list|()
argument_list|,
name|server
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|server
return|;
block|}
specifier|public
name|HRegionInterface
name|getHRegionConnection
parameter_list|(
name|HServerAddress
name|regionServer
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getHRegionConnection
argument_list|(
name|regionServer
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
specifier|synchronized
name|ZooKeeperWrapper
name|getZooKeeperWrapper
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|zooKeeperWrapper
operator|==
literal|null
condition|)
block|{
name|zooKeeperWrapper
operator|=
operator|new
name|ZooKeeperWrapper
argument_list|(
name|conf
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
return|return
name|zooKeeperWrapper
return|;
block|}
comment|/*      * Repeatedly try to find the root region in ZK      * @return HRegionLocation for root region if found      * @throws NoServerForRegionException - if the root region can not be      * located after retrying      * @throws IOException       */
specifier|private
name|HRegionLocation
name|locateRootRegion
parameter_list|()
throws|throws
name|IOException
block|{
comment|// We lazily instantiate the ZooKeeper object because we don't want to
comment|// make the constructor have to throw IOException or handle it itself.
name|ZooKeeperWrapper
name|zk
init|=
name|getZooKeeperWrapper
argument_list|()
decl_stmt|;
name|HServerAddress
name|rootRegionAddress
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
name|numRetries
condition|;
name|tries
operator|++
control|)
block|{
name|int
name|localTimeouts
init|=
literal|0
decl_stmt|;
comment|// ask the master which server has the root region
while|while
condition|(
name|rootRegionAddress
operator|==
literal|null
operator|&&
name|localTimeouts
operator|<
name|numRetries
condition|)
block|{
comment|// Don't read root region until we're out of safe mode so we know
comment|// that the meta regions have been assigned.
name|boolean
name|outOfSafeMode
init|=
name|zk
operator|.
name|checkOutOfSafeMode
argument_list|()
decl_stmt|;
if|if
condition|(
name|outOfSafeMode
condition|)
block|{
name|rootRegionAddress
operator|=
name|zk
operator|.
name|readRootRegionLocation
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|rootRegionAddress
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sleeping "
operator|+
name|getPauseTime
argument_list|(
name|tries
argument_list|)
operator|+
literal|"ms, waiting for root region."
argument_list|)
expr_stmt|;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
name|getPauseTime
argument_list|(
name|tries
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{
comment|// continue
block|}
name|localTimeouts
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rootRegionAddress
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoServerForRegionException
argument_list|(
literal|"Timed out trying to locate root region"
argument_list|)
throw|;
block|}
comment|// get a connection to the region server
name|HRegionInterface
name|server
init|=
name|getHRegionConnection
argument_list|(
name|rootRegionAddress
argument_list|)
decl_stmt|;
try|try
block|{
comment|// if this works, then we're good, and we have an acceptable address,
comment|// so we can stop doing retries and return the result.
name|server
operator|.
name|getRegionInfo
argument_list|(
name|HRegionInfo
operator|.
name|ROOT_REGIONINFO
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found ROOT at "
operator|+
name|rootRegionAddress
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
comment|// Don't bother sleeping. We've run out of retries.
if|if
condition|(
name|e
operator|instanceof
name|RemoteException
condition|)
block|{
name|e
operator|=
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
operator|(
name|RemoteException
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
comment|// Sleep and retry finding root region.
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Root region location changed. Sleeping."
argument_list|)
expr_stmt|;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
name|getPauseTime
argument_list|(
name|tries
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Wake. Retry finding root region."
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{
comment|// continue
block|}
block|}
name|rootRegionAddress
operator|=
literal|null
expr_stmt|;
block|}
comment|// if the address is null by this point, then the retries have failed,
comment|// and we're sort of sunk
if|if
condition|(
name|rootRegionAddress
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoServerForRegionException
argument_list|(
literal|"unable to locate root region server"
argument_list|)
throw|;
block|}
comment|// return the region location
return|return
operator|new
name|HRegionLocation
argument_list|(
name|HRegionInfo
operator|.
name|ROOT_REGIONINFO
argument_list|,
name|rootRegionAddress
argument_list|)
return|;
block|}
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|getRegionServerWithRetries
parameter_list|(
name|ServerCallable
argument_list|<
name|T
argument_list|>
name|callable
parameter_list|)
throws|throws
name|IOException
throws|,
name|RuntimeException
block|{
name|List
argument_list|<
name|Throwable
argument_list|>
name|exceptions
init|=
operator|new
name|ArrayList
argument_list|<
name|Throwable
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
name|numRetries
condition|;
name|tries
operator|++
control|)
block|{
try|try
block|{
name|callable
operator|.
name|instantiateServer
argument_list|(
name|tries
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|callable
operator|.
name|call
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|UndeclaredThrowableException
condition|)
block|{
name|t
operator|=
name|t
operator|.
name|getCause
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|instanceof
name|RemoteException
condition|)
block|{
name|t
operator|=
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
operator|(
name|RemoteException
operator|)
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|instanceof
name|DoNotRetryIOException
condition|)
block|{
throw|throw
operator|(
name|DoNotRetryIOException
operator|)
name|t
throw|;
block|}
name|exceptions
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|RetriesExhaustedException
argument_list|(
name|callable
operator|.
name|getServerName
argument_list|()
argument_list|,
name|callable
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|callable
operator|.
name|getRow
argument_list|()
argument_list|,
name|tries
argument_list|,
name|exceptions
argument_list|)
throw|;
block|}
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|getPauseTime
argument_list|(
name|tries
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// continue
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|getRegionServerForWithoutRetries
parameter_list|(
name|ServerCallable
argument_list|<
name|T
argument_list|>
name|callable
parameter_list|)
throws|throws
name|IOException
throws|,
name|RuntimeException
block|{
try|try
block|{
name|callable
operator|.
name|instantiateServer
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
name|callable
operator|.
name|call
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|UndeclaredThrowableException
condition|)
block|{
name|t
operator|=
name|t
operator|.
name|getCause
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|instanceof
name|RemoteException
condition|)
block|{
name|t
operator|=
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
operator|(
name|RemoteException
operator|)
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|instanceof
name|DoNotRetryIOException
condition|)
block|{
throw|throw
operator|(
name|DoNotRetryIOException
operator|)
name|t
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|HRegionLocation
name|getRegionLocationForRowWithRetries
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|,
name|byte
index|[]
name|rowKey
parameter_list|,
name|boolean
name|reload
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|reloadFlag
init|=
name|reload
decl_stmt|;
name|List
argument_list|<
name|Throwable
argument_list|>
name|exceptions
init|=
operator|new
name|ArrayList
argument_list|<
name|Throwable
argument_list|>
argument_list|()
decl_stmt|;
name|HRegionLocation
name|location
init|=
literal|null
decl_stmt|;
name|int
name|tries
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|tries
operator|<
name|numRetries
condition|;
control|)
block|{
try|try
block|{
name|location
operator|=
name|getRegionLocation
argument_list|(
name|tableName
argument_list|,
name|rowKey
argument_list|,
name|reloadFlag
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|exceptions
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|location
operator|!=
literal|null
condition|)
block|{
break|break;
block|}
name|reloadFlag
operator|=
literal|true
expr_stmt|;
name|tries
operator|++
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|getPauseTime
argument_list|(
name|tries
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// continue
block|}
block|}
if|if
condition|(
name|location
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RetriesExhaustedException
argument_list|(
literal|"Some server"
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|,
name|rowKey
argument_list|,
name|tries
argument_list|,
name|exceptions
argument_list|)
throw|;
block|}
return|return
name|location
return|;
block|}
specifier|public
name|void
name|processBatchOfRows
parameter_list|(
name|ArrayList
argument_list|<
name|Put
argument_list|>
name|list
parameter_list|,
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|boolean
name|retryOnlyOne
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|list
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Put
argument_list|>
name|currentPuts
init|=
operator|new
name|ArrayList
argument_list|<
name|Put
argument_list|>
argument_list|()
decl_stmt|;
name|HRegionLocation
name|location
init|=
name|getRegionLocationForRowWithRetries
argument_list|(
name|tableName
argument_list|,
name|list
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRow
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|byte
index|[]
name|currentRegion
init|=
name|location
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
decl_stmt|;
name|byte
index|[]
name|region
init|=
name|currentRegion
decl_stmt|;
name|boolean
name|isLastRow
init|=
literal|false
decl_stmt|;
name|Put
index|[]
name|putarray
init|=
operator|new
name|Put
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|tries
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
operator|&&
name|tries
operator|<
name|this
operator|.
name|numRetries
condition|;
name|i
operator|++
control|)
block|{
name|Put
name|put
init|=
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|currentPuts
operator|.
name|add
argument_list|(
name|put
argument_list|)
expr_stmt|;
comment|// If the next Put goes to a new region, then we are to clear
comment|// currentPuts now during this cycle.
name|isLastRow
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|==
name|list
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isLastRow
condition|)
block|{
name|location
operator|=
name|getRegionLocationForRowWithRetries
argument_list|(
name|tableName
argument_list|,
name|list
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|.
name|getRow
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|region
operator|=
name|location
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|currentRegion
argument_list|,
name|region
argument_list|)
operator|||
name|isLastRow
operator|||
name|retryOnlyOne
condition|)
block|{
specifier|final
name|Put
index|[]
name|puts
init|=
name|currentPuts
operator|.
name|toArray
argument_list|(
name|putarray
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|getRegionServerWithRetries
argument_list|(
operator|new
name|ServerCallable
argument_list|<
name|Integer
argument_list|>
argument_list|(
name|this
argument_list|,
name|tableName
argument_list|,
name|put
operator|.
name|getRow
argument_list|()
argument_list|)
block|{
specifier|public
name|Integer
name|call
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|server
operator|.
name|put
argument_list|(
name|location
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|puts
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
comment|// index is == -1 if all puts processed successfully, else its index
comment|// of last Put successfully processed.
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|RetriesExhaustedException
argument_list|(
literal|"Some server, retryOnlyOne="
operator|+
name|retryOnlyOne
operator|+
literal|", index="
operator|+
name|index
operator|+
literal|", islastrow="
operator|+
name|isLastRow
operator|+
literal|", tries="
operator|+
name|tries
operator|+
literal|", numtries="
operator|+
name|numRetries
operator|+
literal|", i="
operator|+
name|i
operator|+
literal|", listsize="
operator|+
name|list
operator|.
name|size
argument_list|()
operator|+
literal|", location="
operator|+
name|location
operator|+
literal|", region="
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|region
argument_list|)
argument_list|,
name|currentRegion
argument_list|,
name|put
operator|.
name|getRow
argument_list|()
argument_list|,
name|tries
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|Throwable
argument_list|>
argument_list|()
argument_list|)
throw|;
block|}
name|long
name|sleepTime
init|=
name|getPauseTime
argument_list|(
name|tries
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reloading region "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|currentRegion
argument_list|)
operator|+
literal|" location because regionserver didn't accept updates; "
operator|+
literal|"tries="
operator|+
name|tries
operator|+
literal|" of max="
operator|+
name|this
operator|.
name|numRetries
operator|+
literal|", waiting="
operator|+
name|sleepTime
operator|+
literal|"ms"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepTime
argument_list|)
expr_stmt|;
name|tries
operator|++
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// continue
block|}
name|i
operator|=
name|i
operator|-
name|puts
operator|.
name|length
operator|+
name|index
expr_stmt|;
name|retryOnlyOne
operator|=
literal|true
expr_stmt|;
comment|// Reload location.
name|location
operator|=
name|getRegionLocationForRowWithRetries
argument_list|(
name|tableName
argument_list|,
name|list
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|.
name|getRow
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|region
operator|=
name|location
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Reset these flags/counters on successful batch Put
name|retryOnlyOne
operator|=
literal|false
expr_stmt|;
name|tries
operator|=
literal|0
expr_stmt|;
block|}
name|currentRegion
operator|=
name|region
expr_stmt|;
name|currentPuts
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|void
name|close
parameter_list|(
name|boolean
name|stopProxy
parameter_list|)
block|{
if|if
condition|(
name|master
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|stopProxy
condition|)
block|{
name|HBaseRPC
operator|.
name|stopProxy
argument_list|(
name|master
argument_list|)
expr_stmt|;
block|}
name|master
operator|=
literal|null
expr_stmt|;
name|masterChecked
operator|=
literal|false
expr_stmt|;
block|}
name|resetZooKeeper
argument_list|()
expr_stmt|;
if|if
condition|(
name|stopProxy
condition|)
block|{
synchronized|synchronized
init|(
name|servers
init|)
block|{
for|for
control|(
name|HRegionInterface
name|i
range|:
name|servers
operator|.
name|values
argument_list|()
control|)
block|{
name|HBaseRPC
operator|.
name|stopProxy
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

