begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *   */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|migration
operator|.
name|nineteen
operator|.
name|io
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|migration
operator|.
name|nineteen
operator|.
name|HStoreKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_comment
comment|/**  * A reference to a part of a store file.  The file referenced usually lives  * under a different region.  The part referenced is usually the top or bottom  * half of the file.  References are made at region split time.  Being lazy  * about copying data between the parent of the split and the split daughters  * makes splitting faster.  *   *<p>References work with {@link HalfMapFileReader}.  References know how to  * write out the reference format in the file system and are whats juggled when  * references are mixed in with direct store files.  The  * {@link HalfMapFileReader} is used reading the referred to file.  *  *<p>References to store files located over in some other region look like  * this in the file system  *<code>1278437856009925445.hbaserepository,qAReLZD-OyQORZWq_vqR1k==,959247014679548184</code>:  * i.e. an id followed by the name of the referenced region.  The data  * ('mapfiles') of references are empty. The accompanying<code>info</code> file  * contains the<code>midkey</code> that demarks top and bottom of the  * referenced storefile, the id of the remote store we're referencing and  * whether we're to serve the top or bottom region of the remote store file.  * Note, a region is itself not splitable if it has instances of store file  * references.  References are cleaned up by compactions.  */
end_comment

begin_class
specifier|public
class|class
name|Reference
implements|implements
name|Writable
block|{
comment|// TODO: see if it makes sense making a ReferenceMapFile whose Writer is this
comment|// class and whose Reader is the {@link HalfMapFileReader}.
specifier|private
name|int
name|encodedRegionName
decl_stmt|;
specifier|private
name|long
name|fileid
decl_stmt|;
specifier|private
name|Range
name|region
decl_stmt|;
specifier|private
name|HStoreKey
name|midkey
decl_stmt|;
comment|/**     * For split HStoreFiles, it specifies if the file covers the lower half or    * the upper half of the key range    */
specifier|public
specifier|static
enum|enum
name|Range
block|{
comment|/** HStoreFile contains upper half of key range */
name|top
block|,
comment|/** HStoreFile contains lower half of key range */
name|bottom
block|}
specifier|public
name|Reference
parameter_list|(
specifier|final
name|int
name|ern
parameter_list|,
specifier|final
name|long
name|fid
parameter_list|,
specifier|final
name|HStoreKey
name|m
parameter_list|,
specifier|final
name|Range
name|fr
parameter_list|)
block|{
name|this
operator|.
name|encodedRegionName
operator|=
name|ern
expr_stmt|;
name|this
operator|.
name|fileid
operator|=
name|fid
expr_stmt|;
name|this
operator|.
name|region
operator|=
name|fr
expr_stmt|;
name|this
operator|.
name|midkey
operator|=
name|m
expr_stmt|;
block|}
specifier|public
name|Reference
parameter_list|()
block|{
name|this
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
name|Range
operator|.
name|bottom
argument_list|)
expr_stmt|;
block|}
specifier|public
name|long
name|getFileId
parameter_list|()
block|{
return|return
name|fileid
return|;
block|}
specifier|public
name|Range
name|getFileRegion
parameter_list|()
block|{
return|return
name|region
return|;
block|}
specifier|public
name|HStoreKey
name|getMidkey
parameter_list|()
block|{
return|return
name|midkey
return|;
block|}
specifier|public
name|int
name|getEncodedRegionName
parameter_list|()
block|{
return|return
name|this
operator|.
name|encodedRegionName
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|encodedRegionName
operator|+
literal|"/"
operator|+
name|fileid
operator|+
literal|"/"
operator|+
name|region
return|;
block|}
comment|// Make it serializable.
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Write out the encoded region name as a String.  Doing it as a String
comment|// keeps a Reference's serialization backword compatible with
comment|// pre-HBASE-82 serializations.  ALternative is rewriting all
comment|// info files in hbase (Serialized References are written into the
comment|// 'info' file that accompanies HBase Store files).
name|out
operator|.
name|writeUTF
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|encodedRegionName
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeLong
argument_list|(
name|fileid
argument_list|)
expr_stmt|;
comment|// Write true if we're doing top of the file.
name|out
operator|.
name|writeBoolean
argument_list|(
name|isTopFileRegion
argument_list|(
name|region
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|midkey
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|encodedRegionName
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|in
operator|.
name|readUTF
argument_list|()
argument_list|)
expr_stmt|;
name|fileid
operator|=
name|in
operator|.
name|readLong
argument_list|()
expr_stmt|;
name|boolean
name|tmp
init|=
name|in
operator|.
name|readBoolean
argument_list|()
decl_stmt|;
comment|// If true, set region to top.
name|region
operator|=
name|tmp
condition|?
name|Range
operator|.
name|top
else|:
name|Range
operator|.
name|bottom
expr_stmt|;
name|midkey
operator|=
operator|new
name|HStoreKey
argument_list|()
expr_stmt|;
name|midkey
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|boolean
name|isTopFileRegion
parameter_list|(
specifier|final
name|Range
name|r
parameter_list|)
block|{
return|return
name|r
operator|.
name|equals
argument_list|(
name|Range
operator|.
name|top
argument_list|)
return|;
block|}
block|}
end_class

end_unit

