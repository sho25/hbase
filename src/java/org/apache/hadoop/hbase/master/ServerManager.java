begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2008 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerLoad
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerAddress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HMsg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HMsg
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperWrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|WatchedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|Watcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|Watcher
operator|.
name|Event
operator|.
name|EventType
import|;
end_import

begin_comment
comment|/**  * The ServerManager class manages info about region servers - HServerInfo,   * load numbers, dying servers, etc.  */
end_comment

begin_class
class|class
name|ServerManager
implements|implements
name|HConstants
block|{
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ServerManager
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|HMsg
name|REGIONSERVER_QUIESCE
init|=
operator|new
name|HMsg
argument_list|(
name|Type
operator|.
name|MSG_REGIONSERVER_QUIESCE
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|HMsg
name|REGIONSERVER_STOP
init|=
operator|new
name|HMsg
argument_list|(
name|Type
operator|.
name|MSG_REGIONSERVER_STOP
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|HMsg
name|CALL_SERVER_STARTUP
init|=
operator|new
name|HMsg
argument_list|(
name|Type
operator|.
name|MSG_CALL_SERVER_STARTUP
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|HMsg
index|[]
name|EMPTY_HMSG_ARRAY
init|=
operator|new
name|HMsg
index|[
literal|0
index|]
decl_stmt|;
specifier|private
specifier|final
name|AtomicInteger
name|quiescedServers
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|ZooKeeperWrapper
name|zooKeeperWrapper
decl_stmt|;
comment|/** The map of known server names to server info */
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|HServerInfo
argument_list|>
name|serversToServerInfo
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|HServerInfo
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Set of known dead servers.  On znode expiration, servers are added here.    * Boolean holds whether its logs have been split or not.  Initially set to    * false.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
name|deadServers
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
argument_list|()
decl_stmt|;
comment|/** SortedMap server load -> Set of server names */
specifier|final
name|SortedMap
argument_list|<
name|HServerLoad
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|loadToServers
init|=
name|Collections
operator|.
name|synchronizedSortedMap
argument_list|(
operator|new
name|TreeMap
argument_list|<
name|HServerLoad
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|/** Map of server names -> server load */
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|HServerLoad
argument_list|>
name|serversToLoad
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|HServerLoad
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|HMaster
name|master
decl_stmt|;
comment|// Last time we logged average load.
specifier|private
specifier|volatile
name|long
name|lastLogOfAverageLaod
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|long
name|loggingPeriodForAverageLoad
decl_stmt|;
comment|/* The regionserver will not be assigned or asked close regions if it    * is currently opening>= this many regions.    */
specifier|private
specifier|final
name|int
name|nobalancingCount
decl_stmt|;
comment|/**    * @param master    */
specifier|public
name|ServerManager
parameter_list|(
name|HMaster
name|master
parameter_list|)
block|{
name|this
operator|.
name|master
operator|=
name|master
expr_stmt|;
name|zooKeeperWrapper
operator|=
name|master
operator|.
name|getZooKeeperWrapper
argument_list|()
expr_stmt|;
name|this
operator|.
name|loggingPeriodForAverageLoad
operator|=
name|master
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getLong
argument_list|(
literal|"hbase.master.avgload.logging.period"
argument_list|,
literal|60000
argument_list|)
expr_stmt|;
name|this
operator|.
name|nobalancingCount
operator|=
name|master
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"hbase.regions.nobalancing.count"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/**    * Look to see if we have ghost references to this regionserver such as    * if regionserver is on the dead servers list getting its logs processed.    * @param serverInfo    * @return True if still ghost references and we have not been able to clear    * them or the server is shutting down.    */
specifier|private
name|boolean
name|checkForGhostReferences
parameter_list|(
specifier|final
name|HServerInfo
name|serverInfo
parameter_list|)
block|{
name|boolean
name|result
init|=
literal|false
decl_stmt|;
for|for
control|(
name|long
name|sleepTime
init|=
operator|-
literal|1
init|;
operator|!
name|master
operator|.
name|closed
operator|.
name|get
argument_list|()
operator|&&
operator|!
name|result
condition|;
control|)
block|{
if|if
condition|(
name|sleepTime
operator|!=
operator|-
literal|1
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// Continue
block|}
block|}
comment|// May be on list of dead servers.  If so, wait till we've cleared it.
name|String
name|addr
init|=
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|isDead
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting on "
operator|+
name|addr
operator|+
literal|" removal from dead list before "
operator|+
literal|"processing report-for-duty request"
argument_list|)
expr_stmt|;
name|sleepTime
operator|=
name|this
operator|.
name|master
operator|.
name|threadWakeFrequency
expr_stmt|;
continue|continue;
block|}
name|result
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Let the server manager know a new regionserver has come online    * @param serverInfo    */
specifier|public
name|void
name|regionServerStartup
parameter_list|(
specifier|final
name|HServerInfo
name|serverInfo
parameter_list|)
block|{
name|String
name|s
init|=
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
name|Watcher
name|watcher
init|=
operator|new
name|ServerExpirer
argument_list|(
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
argument_list|)
decl_stmt|;
name|zooKeeperWrapper
operator|.
name|updateRSLocationGetWatch
argument_list|(
name|serverInfo
argument_list|,
name|watcher
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Received start message from: "
operator|+
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkForGhostReferences
argument_list|(
name|serverInfo
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Go on to process the regionserver registration.
name|HServerLoad
name|load
init|=
name|serversToLoad
operator|.
name|remove
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|load
operator|!=
literal|null
condition|)
block|{
comment|// The startup message was from a known server.
comment|// Remove stale information about the server's load.
synchronized|synchronized
init|(
name|loadToServers
init|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|servers
init|=
name|loadToServers
operator|.
name|get
argument_list|(
name|load
argument_list|)
decl_stmt|;
if|if
condition|(
name|servers
operator|!=
literal|null
condition|)
block|{
name|servers
operator|.
name|remove
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|loadToServers
operator|.
name|put
argument_list|(
name|load
argument_list|,
name|servers
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|HServerInfo
name|storedInfo
init|=
name|serversToServerInfo
operator|.
name|remove
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedInfo
operator|!=
literal|null
operator|&&
operator|!
name|master
operator|.
name|closed
operator|.
name|get
argument_list|()
condition|)
block|{
comment|// The startup message was from a known server with the same name.
comment|// Timeout the old one right away.
name|HServerAddress
name|root
init|=
name|master
operator|.
name|getRootRegionLocation
argument_list|()
decl_stmt|;
name|boolean
name|rootServer
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|root
operator|!=
literal|null
operator|&&
name|root
operator|.
name|equals
argument_list|(
name|storedInfo
operator|.
name|getServerAddress
argument_list|()
argument_list|)
condition|)
block|{
name|master
operator|.
name|regionManager
operator|.
name|unsetRootRegion
argument_list|()
expr_stmt|;
name|rootServer
operator|=
literal|true
expr_stmt|;
block|}
try|try
block|{
name|master
operator|.
name|toDoQueue
operator|.
name|put
argument_list|(
operator|new
name|ProcessServerShutdown
argument_list|(
name|master
argument_list|,
name|storedInfo
argument_list|,
name|rootServer
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Insertion into toDoQueue was interrupted"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|// record new server
name|load
operator|=
operator|new
name|HServerLoad
argument_list|()
expr_stmt|;
name|serverInfo
operator|.
name|setLoad
argument_list|(
name|load
argument_list|)
expr_stmt|;
name|serversToServerInfo
operator|.
name|put
argument_list|(
name|s
argument_list|,
name|serverInfo
argument_list|)
expr_stmt|;
name|serversToLoad
operator|.
name|put
argument_list|(
name|s
argument_list|,
name|load
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|loadToServers
init|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|servers
init|=
name|loadToServers
operator|.
name|get
argument_list|(
name|load
argument_list|)
decl_stmt|;
if|if
condition|(
name|servers
operator|==
literal|null
condition|)
block|{
name|servers
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|servers
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|loadToServers
operator|.
name|put
argument_list|(
name|load
argument_list|,
name|servers
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Called to process the messages sent from the region server to the master    * along with the heart beat.    *     * @param serverInfo    * @param msgs    * @param mostLoadedRegions Array of regions the region server is submitting    * as candidates to be rebalanced, should it be overloaded    * @return messages from master to region server indicating what region    * server should do.    *     * @throws IOException    */
specifier|public
name|HMsg
index|[]
name|regionServerReport
parameter_list|(
specifier|final
name|HServerInfo
name|serverInfo
parameter_list|,
specifier|final
name|HMsg
name|msgs
index|[]
parameter_list|,
specifier|final
name|HRegionInfo
index|[]
name|mostLoadedRegions
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|serverName
init|=
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|msgs
operator|.
name|length
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|msgs
index|[
literal|0
index|]
operator|.
name|isType
argument_list|(
name|HMsg
operator|.
name|Type
operator|.
name|MSG_REPORT_EXITING
argument_list|)
condition|)
block|{
name|processRegionServerExit
argument_list|(
name|serverName
argument_list|,
name|msgs
argument_list|)
expr_stmt|;
return|return
name|EMPTY_HMSG_ARRAY
return|;
block|}
elseif|else
if|if
condition|(
name|msgs
index|[
literal|0
index|]
operator|.
name|isType
argument_list|(
name|HMsg
operator|.
name|Type
operator|.
name|MSG_REPORT_QUIESCED
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Region server "
operator|+
name|serverName
operator|+
literal|" quiesced"
argument_list|)
expr_stmt|;
name|quiescedServers
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|master
operator|.
name|shutdownRequested
operator|.
name|get
argument_list|()
condition|)
block|{
if|if
condition|(
name|quiescedServers
operator|.
name|get
argument_list|()
operator|>=
name|serversToServerInfo
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// If the only servers we know about are meta servers, then we can
comment|// proceed with shutdown
name|LOG
operator|.
name|info
argument_list|(
literal|"All user tables quiesced. Proceeding with shutdown"
argument_list|)
expr_stmt|;
name|master
operator|.
name|startShutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|master
operator|.
name|closed
operator|.
name|get
argument_list|()
condition|)
block|{
if|if
condition|(
name|msgs
operator|.
name|length
operator|>
literal|0
operator|&&
name|msgs
index|[
literal|0
index|]
operator|.
name|isType
argument_list|(
name|HMsg
operator|.
name|Type
operator|.
name|MSG_REPORT_QUIESCED
argument_list|)
condition|)
block|{
comment|// Server is already quiesced, but we aren't ready to shut down
comment|// return empty response
return|return
name|EMPTY_HMSG_ARRAY
return|;
block|}
comment|// Tell the server to stop serving any user regions
return|return
operator|new
name|HMsg
index|[]
block|{
name|REGIONSERVER_QUIESCE
block|}
return|;
block|}
block|}
if|if
condition|(
name|master
operator|.
name|closed
operator|.
name|get
argument_list|()
condition|)
block|{
comment|// Tell server to shut down if we are shutting down.  This should
comment|// happen after check of MSG_REPORT_EXITING above, since region server
comment|// will send us one of these messages after it gets MSG_REGIONSERVER_STOP
return|return
operator|new
name|HMsg
index|[]
block|{
name|REGIONSERVER_STOP
block|}
return|;
block|}
name|HServerInfo
name|storedInfo
init|=
name|serversToServerInfo
operator|.
name|get
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedInfo
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"received server report from unknown server: "
operator|+
name|serverName
argument_list|)
expr_stmt|;
block|}
comment|// The HBaseMaster may have been restarted.
comment|// Tell the RegionServer to start over and call regionServerStartup()
return|return
operator|new
name|HMsg
index|[]
block|{
name|CALL_SERVER_STARTUP
block|}
return|;
block|}
elseif|else
if|if
condition|(
name|storedInfo
operator|.
name|getStartCode
argument_list|()
operator|!=
name|serverInfo
operator|.
name|getStartCode
argument_list|()
condition|)
block|{
comment|// This state is reachable if:
comment|//
comment|// 1) RegionServer A started
comment|// 2) RegionServer B started on the same machine, then
comment|//    clobbered A in regionServerStartup.
comment|// 3) RegionServer A returns, expecting to work as usual.
comment|//
comment|// The answer is to ask A to shut down for good.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"region server race condition detected: "
operator|+
name|serverName
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|serversToServerInfo
init|)
block|{
name|removeServerInfo
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
name|serversToServerInfo
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|HMsg
index|[]
block|{
name|REGIONSERVER_STOP
block|}
return|;
block|}
else|else
block|{
return|return
name|processRegionServerAllsWell
argument_list|(
name|serverName
argument_list|,
name|serverInfo
argument_list|,
name|mostLoadedRegions
argument_list|,
name|msgs
argument_list|)
return|;
block|}
block|}
comment|/** Region server is exiting */
specifier|private
name|void
name|processRegionServerExit
parameter_list|(
name|String
name|serverName
parameter_list|,
name|HMsg
index|[]
name|msgs
parameter_list|)
block|{
synchronized|synchronized
init|(
name|serversToServerInfo
init|)
block|{
try|try
block|{
comment|// HRegionServer is shutting down.
if|if
condition|(
name|removeServerInfo
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
comment|// Only process the exit message if the server still has registered info.
comment|// Otherwise we could end up processing the server exit twice.
name|LOG
operator|.
name|info
argument_list|(
literal|"Region server "
operator|+
name|serverName
operator|+
literal|": MSG_REPORT_EXITING"
argument_list|)
expr_stmt|;
comment|// Get all the regions the server was serving reassigned
comment|// (if we are not shutting down).
if|if
condition|(
operator|!
name|master
operator|.
name|closed
operator|.
name|get
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|msgs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing "
operator|+
name|msgs
index|[
name|i
index|]
operator|+
literal|" from "
operator|+
name|serverName
argument_list|)
expr_stmt|;
name|HRegionInfo
name|info
init|=
name|msgs
index|[
name|i
index|]
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|master
operator|.
name|regionManager
init|)
block|{
if|if
condition|(
name|info
operator|.
name|isRootRegion
argument_list|()
condition|)
block|{
name|master
operator|.
name|regionManager
operator|.
name|reassignRootRegion
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|info
operator|.
name|isMetaTable
argument_list|()
condition|)
block|{
name|master
operator|.
name|regionManager
operator|.
name|offlineMetaRegion
argument_list|(
name|info
operator|.
name|getStartKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|master
operator|.
name|regionManager
operator|.
name|isOfflined
argument_list|(
name|info
operator|.
name|getRegionName
argument_list|()
argument_list|)
condition|)
block|{
name|master
operator|.
name|regionManager
operator|.
name|setUnassigned
argument_list|(
name|info
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|master
operator|.
name|regionManager
operator|.
name|removeRegion
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|// We don't need to return anything to the server because it isn't
comment|// going to do any more work.
block|}
finally|finally
block|{
name|serversToServerInfo
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    *  RegionServer is checking in, no exceptional circumstances    * @param serverName    * @param serverInfo    * @param mostLoadedRegions    * @param msgs    * @return    * @throws IOException    */
specifier|private
name|HMsg
index|[]
name|processRegionServerAllsWell
parameter_list|(
name|String
name|serverName
parameter_list|,
name|HServerInfo
name|serverInfo
parameter_list|,
name|HRegionInfo
index|[]
name|mostLoadedRegions
parameter_list|,
name|HMsg
index|[]
name|msgs
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Refresh the info object and the load information
name|serversToServerInfo
operator|.
name|put
argument_list|(
name|serverName
argument_list|,
name|serverInfo
argument_list|)
expr_stmt|;
name|HServerLoad
name|load
init|=
name|serversToLoad
operator|.
name|get
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
if|if
condition|(
name|load
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|master
operator|.
name|getMetrics
argument_list|()
operator|.
name|incrementRequests
argument_list|(
name|load
operator|.
name|getNumberOfRequests
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|load
operator|.
name|equals
argument_list|(
name|serverInfo
operator|.
name|getLoad
argument_list|()
argument_list|)
condition|)
block|{
comment|// We have previous information about the load on this server
comment|// and the load on this server has changed
synchronized|synchronized
init|(
name|loadToServers
init|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|servers
init|=
name|loadToServers
operator|.
name|get
argument_list|(
name|load
argument_list|)
decl_stmt|;
comment|// Note that servers should never be null because loadToServers
comment|// and serversToLoad are manipulated in pairs
name|servers
operator|.
name|remove
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
name|loadToServers
operator|.
name|put
argument_list|(
name|load
argument_list|,
name|servers
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Set the current load information
name|load
operator|=
name|serverInfo
operator|.
name|getLoad
argument_list|()
expr_stmt|;
name|serversToLoad
operator|.
name|put
argument_list|(
name|serverName
argument_list|,
name|load
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|loadToServers
init|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|servers
init|=
name|loadToServers
operator|.
name|get
argument_list|(
name|load
argument_list|)
decl_stmt|;
if|if
condition|(
name|servers
operator|==
literal|null
condition|)
block|{
name|servers
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|servers
operator|.
name|add
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
name|loadToServers
operator|.
name|put
argument_list|(
name|load
argument_list|,
name|servers
argument_list|)
expr_stmt|;
block|}
comment|// Next, process messages for this server
return|return
name|processMsgs
argument_list|(
name|serverName
argument_list|,
name|serverInfo
argument_list|,
name|mostLoadedRegions
argument_list|,
name|msgs
argument_list|)
return|;
block|}
comment|/**     * Process all the incoming messages from a server that's contacted us.    *     * Note that we never need to update the server's load information because    * that has already been done in regionServerReport.    */
specifier|private
name|HMsg
index|[]
name|processMsgs
parameter_list|(
name|String
name|serverName
parameter_list|,
name|HServerInfo
name|serverInfo
parameter_list|,
name|HRegionInfo
index|[]
name|mostLoadedRegions
parameter_list|,
name|HMsg
name|incomingMsgs
index|[]
parameter_list|)
throws|throws
name|IOException
block|{
name|ArrayList
argument_list|<
name|HMsg
argument_list|>
name|returnMsgs
init|=
operator|new
name|ArrayList
argument_list|<
name|HMsg
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Server address cannot be null; "
operator|+
literal|"hbase-958 debugging"
argument_list|)
throw|;
block|}
comment|// Get reports on what the RegionServer did.
name|int
name|openingCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|incomingMsgs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|HRegionInfo
name|region
init|=
name|incomingMsgs
index|[
name|i
index|]
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Received "
operator|+
name|incomingMsgs
index|[
name|i
index|]
operator|+
literal|" from "
operator|+
name|serverName
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|incomingMsgs
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|MSG_REPORT_PROCESS_OPEN
case|:
name|openingCount
operator|++
expr_stmt|;
break|break;
case|case
name|MSG_REPORT_OPEN
case|:
name|processRegionOpen
argument_list|(
name|serverName
argument_list|,
name|serverInfo
argument_list|,
name|region
argument_list|,
name|returnMsgs
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_REPORT_CLOSE
case|:
name|processRegionClose
argument_list|(
name|region
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_REPORT_SPLIT
case|:
name|processSplitRegion
argument_list|(
name|serverName
argument_list|,
name|serverInfo
argument_list|,
name|region
argument_list|,
name|incomingMsgs
index|[
operator|++
name|i
index|]
argument_list|,
name|incomingMsgs
index|[
operator|++
name|i
index|]
argument_list|,
name|returnMsgs
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Impossible state during message processing. Instruction: "
operator|+
name|incomingMsgs
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
argument_list|)
throw|;
block|}
block|}
synchronized|synchronized
init|(
name|master
operator|.
name|regionManager
init|)
block|{
comment|// Tell the region server to close regions that we have marked for closing.
for|for
control|(
name|HRegionInfo
name|i
range|:
name|master
operator|.
name|regionManager
operator|.
name|getMarkedToClose
argument_list|(
name|serverName
argument_list|)
control|)
block|{
name|returnMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|Type
operator|.
name|MSG_REGION_CLOSE
argument_list|,
name|i
argument_list|,
name|master
operator|.
name|regionManager
operator|.
name|inSafeMode
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Transition the region from toClose to closing state
name|master
operator|.
name|regionManager
operator|.
name|setPendingClose
argument_list|(
name|i
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Figure out what the RegionServer ought to do, and write back.
comment|// Should we tell it close regions because its overloaded?  If its
comment|// currently opening regions, leave it alone till all are open.
if|if
condition|(
name|openingCount
operator|<
name|this
operator|.
name|nobalancingCount
condition|)
block|{
name|this
operator|.
name|master
operator|.
name|regionManager
operator|.
name|assignRegions
argument_list|(
name|serverInfo
argument_list|,
name|serverName
argument_list|,
name|mostLoadedRegions
argument_list|,
name|returnMsgs
argument_list|)
expr_stmt|;
block|}
comment|// Send any pending table actions.
name|this
operator|.
name|master
operator|.
name|regionManager
operator|.
name|applyActions
argument_list|(
name|serverInfo
argument_list|,
name|returnMsgs
argument_list|)
expr_stmt|;
block|}
return|return
name|returnMsgs
operator|.
name|toArray
argument_list|(
operator|new
name|HMsg
index|[
name|returnMsgs
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**    * A region has split.    *    * @param serverName    * @param serverInfo    * @param region    * @param splitA    * @param splitB    * @param returnMsgs    */
specifier|private
name|void
name|processSplitRegion
parameter_list|(
name|String
name|serverName
parameter_list|,
name|HServerInfo
name|serverInfo
parameter_list|,
name|HRegionInfo
name|region
parameter_list|,
name|HMsg
name|splitA
parameter_list|,
name|HMsg
name|splitB
parameter_list|,
name|ArrayList
argument_list|<
name|HMsg
argument_list|>
name|returnMsgs
parameter_list|)
block|{
synchronized|synchronized
init|(
name|master
operator|.
name|regionManager
init|)
block|{
comment|// Cancel any actions pending for the affected region.
comment|// This prevents the master from sending a SPLIT message if the table
comment|// has already split by the region server.
name|master
operator|.
name|regionManager
operator|.
name|endActions
argument_list|(
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
name|HRegionInfo
name|newRegionA
init|=
name|splitA
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
name|master
operator|.
name|regionManager
operator|.
name|setUnassigned
argument_list|(
name|newRegionA
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|HRegionInfo
name|newRegionB
init|=
name|splitB
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
name|master
operator|.
name|regionManager
operator|.
name|setUnassigned
argument_list|(
name|newRegionB
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|.
name|isMetaTable
argument_list|()
condition|)
block|{
comment|// A meta region has split.
name|master
operator|.
name|regionManager
operator|.
name|offlineMetaRegion
argument_list|(
name|region
operator|.
name|getStartKey
argument_list|()
argument_list|)
expr_stmt|;
name|master
operator|.
name|regionManager
operator|.
name|incrementNumMetaRegions
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/** Region server is reporting that a region is now opened */
specifier|private
name|void
name|processRegionOpen
parameter_list|(
name|String
name|serverName
parameter_list|,
name|HServerInfo
name|serverInfo
parameter_list|,
name|HRegionInfo
name|region
parameter_list|,
name|ArrayList
argument_list|<
name|HMsg
argument_list|>
name|returnMsgs
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|duplicateAssignment
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|master
operator|.
name|regionManager
init|)
block|{
if|if
condition|(
operator|!
name|master
operator|.
name|regionManager
operator|.
name|isUnassigned
argument_list|(
name|region
argument_list|)
operator|&&
operator|!
name|master
operator|.
name|regionManager
operator|.
name|isPendingOpen
argument_list|(
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|region
operator|.
name|isRootRegion
argument_list|()
condition|)
block|{
comment|// Root region
name|HServerAddress
name|rootServer
init|=
name|master
operator|.
name|getRootRegionLocation
argument_list|()
decl_stmt|;
if|if
condition|(
name|rootServer
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|rootServer
operator|.
name|toString
argument_list|()
operator|.
name|compareTo
argument_list|(
name|serverName
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// A duplicate open report from the correct server
return|return;
block|}
comment|// We received an open report on the root region, but it is
comment|// assigned to a different server
name|duplicateAssignment
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Not root region. If it is not a pending region, then we are
comment|// going to treat it as a duplicate assignment, although we can't
comment|// tell for certain that's the case.
if|if
condition|(
name|master
operator|.
name|regionManager
operator|.
name|isPendingOpen
argument_list|(
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|)
condition|)
block|{
comment|// A duplicate report from the correct server
return|return;
block|}
name|duplicateAssignment
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|duplicateAssignment
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"region server "
operator|+
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|" should not have opened region "
operator|+
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// This Region should not have been opened.
comment|// Ask the server to shut it down, but don't report it as closed.
comment|// Otherwise the HMaster will think the Region was closed on purpose,
comment|// and then try to reopen it elsewhere; that's not what we want.
name|returnMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|Type
operator|.
name|MSG_REGION_CLOSE_WITHOUT_REPORT
argument_list|,
name|region
argument_list|,
literal|"Duplicate assignment"
operator|.
name|getBytes
argument_list|()
argument_list|,
name|master
operator|.
name|regionManager
operator|.
name|inSafeMode
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|region
operator|.
name|isRootRegion
argument_list|()
condition|)
block|{
comment|// it was assigned, and it's not a duplicate assignment, so take it out
comment|// of the unassigned list.
name|master
operator|.
name|regionManager
operator|.
name|removeRegion
argument_list|(
name|region
argument_list|)
expr_stmt|;
comment|// Store the Root Region location (in memory)
name|HServerAddress
name|rootServer
init|=
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
decl_stmt|;
if|if
condition|(
name|master
operator|.
name|regionManager
operator|.
name|inSafeMode
argument_list|()
condition|)
block|{
name|master
operator|.
name|connection
operator|.
name|setRootRegionLocation
argument_list|(
operator|new
name|HRegionLocation
argument_list|(
name|region
argument_list|,
name|rootServer
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|master
operator|.
name|regionManager
operator|.
name|setRootRegionLocation
argument_list|(
name|rootServer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Note that the table has been assigned and is waiting for the
comment|// meta table to be updated.
name|master
operator|.
name|regionManager
operator|.
name|setOpen
argument_list|(
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Queue up an update to note the region location.
try|try
block|{
name|master
operator|.
name|toDoQueue
operator|.
name|put
argument_list|(
operator|new
name|ProcessRegionOpen
argument_list|(
name|master
argument_list|,
name|serverInfo
argument_list|,
name|region
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Putting into toDoQueue was interrupted."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|}
block|}
specifier|private
name|void
name|processRegionClose
parameter_list|(
name|HRegionInfo
name|region
parameter_list|)
block|{
synchronized|synchronized
init|(
name|master
operator|.
name|regionManager
init|)
block|{
if|if
condition|(
name|region
operator|.
name|isRootRegion
argument_list|()
condition|)
block|{
comment|// Root region
name|master
operator|.
name|regionManager
operator|.
name|unsetRootRegion
argument_list|()
expr_stmt|;
if|if
condition|(
name|region
operator|.
name|isOffline
argument_list|()
condition|)
block|{
comment|// Can't proceed without root region. Shutdown.
name|LOG
operator|.
name|fatal
argument_list|(
literal|"root region is marked offline"
argument_list|)
expr_stmt|;
name|master
operator|.
name|shutdown
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|region
operator|.
name|isMetaTable
argument_list|()
condition|)
block|{
comment|// Region is part of the meta table. Remove it from onlineMetaRegions
name|master
operator|.
name|regionManager
operator|.
name|offlineMetaRegion
argument_list|(
name|region
operator|.
name|getStartKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|boolean
name|offlineRegion
init|=
name|master
operator|.
name|regionManager
operator|.
name|isOfflined
argument_list|(
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|reassignRegion
init|=
operator|!
name|region
operator|.
name|isOffline
argument_list|()
operator|&&
operator|!
name|offlineRegion
decl_stmt|;
comment|// NOTE: If the region was just being closed and not offlined, we cannot
comment|//       mark the region unassignedRegions as that changes the ordering of
comment|//       the messages we've received. In this case, a close could be
comment|//       processed before an open resulting in the master not agreeing on
comment|//       the region's state.
name|master
operator|.
name|regionManager
operator|.
name|setClosed
argument_list|(
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|master
operator|.
name|toDoQueue
operator|.
name|put
argument_list|(
operator|new
name|ProcessRegionClose
argument_list|(
name|master
argument_list|,
name|region
argument_list|,
name|offlineRegion
argument_list|,
name|reassignRegion
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Putting into toDoQueue was interrupted."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** Update a server load information because it's shutting down*/
specifier|private
name|boolean
name|removeServerInfo
parameter_list|(
specifier|final
name|String
name|serverName
parameter_list|)
block|{
name|boolean
name|infoUpdated
init|=
literal|false
decl_stmt|;
name|HServerInfo
name|info
init|=
name|serversToServerInfo
operator|.
name|remove
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
comment|// Only update load information once.
comment|// This method can be called a couple of times during shutdown.
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing server's info "
operator|+
name|serverName
argument_list|)
expr_stmt|;
if|if
condition|(
name|master
operator|.
name|getRootRegionLocation
argument_list|()
operator|!=
literal|null
operator|&&
name|info
operator|.
name|getServerAddress
argument_list|()
operator|.
name|equals
argument_list|(
name|master
operator|.
name|getRootRegionLocation
argument_list|()
argument_list|)
condition|)
block|{
name|master
operator|.
name|regionManager
operator|.
name|unsetRootRegion
argument_list|()
expr_stmt|;
block|}
name|infoUpdated
operator|=
literal|true
expr_stmt|;
comment|// update load information
name|HServerLoad
name|load
init|=
name|serversToLoad
operator|.
name|remove
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
if|if
condition|(
name|load
operator|!=
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|loadToServers
init|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|servers
init|=
name|loadToServers
operator|.
name|get
argument_list|(
name|load
argument_list|)
decl_stmt|;
if|if
condition|(
name|servers
operator|!=
literal|null
condition|)
block|{
name|servers
operator|.
name|remove
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
name|loadToServers
operator|.
name|put
argument_list|(
name|load
argument_list|,
name|servers
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|infoUpdated
return|;
block|}
comment|/**     * Compute the average load across all region servers.     * Currently, this uses a very naive computation - just uses the number of     * regions being served, ignoring stats about number of requests.    * @return the average load    */
specifier|public
name|double
name|getAverageLoad
parameter_list|()
block|{
name|int
name|totalLoad
init|=
literal|0
decl_stmt|;
name|int
name|numServers
init|=
literal|0
decl_stmt|;
name|double
name|averageLoad
init|=
literal|0.0
decl_stmt|;
synchronized|synchronized
init|(
name|serversToLoad
init|)
block|{
name|numServers
operator|=
name|serversToLoad
operator|.
name|size
argument_list|()
expr_stmt|;
for|for
control|(
name|HServerLoad
name|load
range|:
name|serversToLoad
operator|.
name|values
argument_list|()
control|)
block|{
name|totalLoad
operator|+=
name|load
operator|.
name|getNumberOfRegions
argument_list|()
expr_stmt|;
block|}
name|averageLoad
operator|=
name|Math
operator|.
name|ceil
argument_list|(
operator|(
name|double
operator|)
name|totalLoad
operator|/
operator|(
name|double
operator|)
name|numServers
argument_list|)
expr_stmt|;
comment|// Only log on a period, not on every invocation of this method.
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|(
name|now
operator|>
operator|(
name|this
operator|.
name|loggingPeriodForAverageLoad
operator|+
name|this
operator|.
name|lastLogOfAverageLaod
operator|)
operator|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Total Load: "
operator|+
name|totalLoad
operator|+
literal|", Num Servers: "
operator|+
name|numServers
operator|+
literal|", Avg Load: "
operator|+
name|averageLoad
argument_list|)
expr_stmt|;
name|this
operator|.
name|lastLogOfAverageLaod
operator|=
name|now
expr_stmt|;
block|}
block|}
return|return
name|averageLoad
return|;
block|}
comment|/** @return the number of active servers */
specifier|public
name|int
name|numServers
parameter_list|()
block|{
return|return
name|serversToServerInfo
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * @param address server address    * @return HServerInfo for the given server address    */
specifier|public
name|HServerInfo
name|getServerInfo
parameter_list|(
name|String
name|address
parameter_list|)
block|{
return|return
name|serversToServerInfo
operator|.
name|get
argument_list|(
name|address
argument_list|)
return|;
block|}
comment|/**    * @return Read-only map of servers to serverinfo.    */
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|HServerInfo
argument_list|>
name|getServersToServerInfo
parameter_list|()
block|{
synchronized|synchronized
init|(
name|serversToServerInfo
init|)
block|{
return|return
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|HServerInfo
argument_list|>
argument_list|(
name|serversToServerInfo
argument_list|)
return|;
block|}
block|}
comment|/**    * @return Read-only map of servers to load.    */
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|HServerLoad
argument_list|>
name|getServersToLoad
parameter_list|()
block|{
synchronized|synchronized
init|(
name|serversToLoad
init|)
block|{
return|return
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|HServerLoad
argument_list|>
argument_list|(
name|serversToLoad
argument_list|)
return|;
block|}
block|}
comment|/**    * @return Read-only map of load to servers.    */
specifier|public
name|Map
argument_list|<
name|HServerLoad
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|getLoadToServers
parameter_list|()
block|{
synchronized|synchronized
init|(
name|loadToServers
init|)
block|{
return|return
operator|new
name|HashMap
argument_list|<
name|HServerLoad
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|(
name|loadToServers
argument_list|)
return|;
block|}
block|}
comment|/**    * Wakes up threads waiting on serversToServerInfo    */
specifier|public
name|void
name|notifyServers
parameter_list|()
block|{
synchronized|synchronized
init|(
name|serversToServerInfo
init|)
block|{
name|serversToServerInfo
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*    * Wait on regionservers to report in    * with {@link #regionServerReport(HServerInfo, HMsg[])} so they get notice    * the master is going down.  Waits until all region servers come back with    * a MSG_REGIONSERVER_STOP.    */
name|void
name|letRegionServersShutdown
parameter_list|()
block|{
if|if
condition|(
operator|!
name|master
operator|.
name|fsOk
condition|)
block|{
comment|// Forget waiting for the region servers if the file system has gone
comment|// away. Just exit as quickly as possible.
return|return;
block|}
synchronized|synchronized
init|(
name|serversToServerInfo
init|)
block|{
while|while
condition|(
name|serversToServerInfo
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting on following regionserver(s) to go down "
operator|+
name|serversToServerInfo
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|serversToServerInfo
operator|.
name|wait
argument_list|(
name|master
operator|.
name|threadWakeFrequency
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// continue
block|}
block|}
block|}
block|}
comment|/** Watcher triggered when a RS znode is deleted */
specifier|private
class|class
name|ServerExpirer
implements|implements
name|Watcher
block|{
specifier|private
name|String
name|server
decl_stmt|;
name|ServerExpirer
parameter_list|(
name|String
name|server
parameter_list|)
block|{
name|this
operator|.
name|server
operator|=
name|server
expr_stmt|;
block|}
specifier|public
name|void
name|process
parameter_list|(
name|WatchedEvent
name|event
parameter_list|)
block|{
if|if
condition|(
name|event
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|EventType
operator|.
name|NodeDeleted
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|server
operator|+
literal|" znode expired"
argument_list|)
expr_stmt|;
comment|// Remove the server from the known servers list and update load info
name|HServerInfo
name|info
init|=
name|serversToServerInfo
operator|.
name|remove
argument_list|(
name|server
argument_list|)
decl_stmt|;
name|boolean
name|rootServer
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
name|HServerAddress
name|root
init|=
name|master
operator|.
name|getRootRegionLocation
argument_list|()
decl_stmt|;
if|if
condition|(
name|root
operator|!=
literal|null
operator|&&
name|root
operator|.
name|equals
argument_list|(
name|info
operator|.
name|getServerAddress
argument_list|()
argument_list|)
condition|)
block|{
comment|// NOTE: If the server was serving the root region, we cannot
comment|// reassign
comment|// it here because the new server will start serving the root region
comment|// before ProcessServerShutdown has a chance to split the log file.
name|master
operator|.
name|regionManager
operator|.
name|unsetRootRegion
argument_list|()
expr_stmt|;
name|rootServer
operator|=
literal|true
expr_stmt|;
block|}
name|String
name|serverName
init|=
name|info
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|HServerLoad
name|load
init|=
name|serversToLoad
operator|.
name|remove
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
if|if
condition|(
name|load
operator|!=
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|loadToServers
init|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|servers
init|=
name|loadToServers
operator|.
name|get
argument_list|(
name|load
argument_list|)
decl_stmt|;
if|if
condition|(
name|servers
operator|!=
literal|null
condition|)
block|{
name|servers
operator|.
name|remove
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
name|loadToServers
operator|.
name|put
argument_list|(
name|load
argument_list|,
name|servers
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|deadServers
operator|.
name|put
argument_list|(
name|server
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
try|try
block|{
name|master
operator|.
name|toDoQueue
operator|.
name|put
argument_list|(
operator|new
name|ProcessServerShutdown
argument_list|(
name|master
argument_list|,
name|info
argument_list|,
name|rootServer
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"insert into toDoQueue was interrupted"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
synchronized|synchronized
init|(
name|serversToServerInfo
init|)
block|{
name|serversToServerInfo
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * @param serverName    */
specifier|public
name|void
name|removeDeadServer
parameter_list|(
name|String
name|serverName
parameter_list|)
block|{
name|deadServers
operator|.
name|remove
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param serverName    * @return true if server is dead    */
specifier|public
name|boolean
name|isDead
parameter_list|(
name|String
name|serverName
parameter_list|)
block|{
return|return
name|deadServers
operator|.
name|containsKey
argument_list|(
name|serverName
argument_list|)
return|;
block|}
block|}
end_class

end_unit

