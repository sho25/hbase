begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2008 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerLoad
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerAddress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HMsg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|LeaseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Leases
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|LeaseListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionLocation
import|;
end_import

begin_comment
comment|/**  * The ServerManager class manages info about region servers - HServerInfo,   * load numbers, dying servers, etc.  */
end_comment

begin_class
class|class
name|ServerManager
implements|implements
name|HConstants
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ServerManager
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|AtomicInteger
name|quiescedServers
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/** The map of known server names to server info */
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|HServerInfo
argument_list|>
name|serversToServerInfo
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|HServerInfo
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Set of known dead servers */
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|deadServers
init|=
name|Collections
operator|.
name|synchronizedSet
argument_list|(
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|/** SortedMap server load -> Set of server names */
specifier|final
name|SortedMap
argument_list|<
name|HServerLoad
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|loadToServers
init|=
name|Collections
operator|.
name|synchronizedSortedMap
argument_list|(
operator|new
name|TreeMap
argument_list|<
name|HServerLoad
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|/** Map of server names -> server load */
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|HServerLoad
argument_list|>
name|serversToLoad
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|HServerLoad
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|HMaster
name|master
decl_stmt|;
specifier|private
specifier|final
name|Leases
name|serverLeases
decl_stmt|;
comment|// Last time we logged average load.
specifier|private
specifier|volatile
name|long
name|lastLogOfAverageLaod
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|long
name|loggingPeriodForAverageLoad
decl_stmt|;
comment|/**    * @param master    */
specifier|public
name|ServerManager
parameter_list|(
name|HMaster
name|master
parameter_list|)
block|{
name|this
operator|.
name|master
operator|=
name|master
expr_stmt|;
name|serverLeases
operator|=
operator|new
name|Leases
argument_list|(
name|master
operator|.
name|leaseTimeout
argument_list|,
name|master
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"hbase.master.lease.thread.wakefrequency"
argument_list|,
literal|15
operator|*
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|loggingPeriodForAverageLoad
operator|=
name|master
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getLong
argument_list|(
literal|"hbase.master.avgload.logging.period"
argument_list|,
literal|15000
argument_list|)
expr_stmt|;
block|}
comment|/**    * Let the server manager know a new regionserver has come online    * @param serverInfo    */
specifier|public
name|void
name|regionServerStartup
parameter_list|(
name|HServerInfo
name|serverInfo
parameter_list|)
block|{
name|String
name|s
init|=
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Received start message from: "
operator|+
name|s
argument_list|)
expr_stmt|;
comment|// Do the lease check up here. There might already be one out on this
comment|// server expecially if it just shutdown and came back up near-immediately.
if|if
condition|(
operator|!
name|master
operator|.
name|closed
operator|.
name|get
argument_list|()
condition|)
block|{
try|try
block|{
name|serverLeases
operator|.
name|createLease
argument_list|(
name|s
argument_list|,
operator|new
name|ServerExpirer
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Leases
operator|.
name|LeaseStillHeldException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Lease still held on "
operator|+
name|e
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|HServerLoad
name|load
init|=
name|serversToLoad
operator|.
name|remove
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|load
operator|!=
literal|null
condition|)
block|{
comment|// The startup message was from a known server.
comment|// Remove stale information about the server's load.
synchronized|synchronized
init|(
name|loadToServers
init|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|servers
init|=
name|loadToServers
operator|.
name|get
argument_list|(
name|load
argument_list|)
decl_stmt|;
if|if
condition|(
name|servers
operator|!=
literal|null
condition|)
block|{
name|servers
operator|.
name|remove
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|loadToServers
operator|.
name|put
argument_list|(
name|load
argument_list|,
name|servers
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|HServerInfo
name|storedInfo
init|=
name|serversToServerInfo
operator|.
name|remove
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedInfo
operator|!=
literal|null
operator|&&
operator|!
name|master
operator|.
name|closed
operator|.
name|get
argument_list|()
condition|)
block|{
comment|// The startup message was from a known server with the same name.
comment|// Timeout the old one right away.
name|HServerAddress
name|root
init|=
name|master
operator|.
name|getRootRegionLocation
argument_list|()
decl_stmt|;
if|if
condition|(
name|root
operator|!=
literal|null
operator|&&
name|root
operator|.
name|equals
argument_list|(
name|storedInfo
operator|.
name|getServerAddress
argument_list|()
argument_list|)
condition|)
block|{
name|master
operator|.
name|regionManager
operator|.
name|unassignRootRegion
argument_list|()
expr_stmt|;
block|}
name|master
operator|.
name|delayedToDoQueue
operator|.
name|put
argument_list|(
operator|new
name|ProcessServerShutdown
argument_list|(
name|master
argument_list|,
name|storedInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// record new server
name|load
operator|=
operator|new
name|HServerLoad
argument_list|()
expr_stmt|;
name|serverInfo
operator|.
name|setLoad
argument_list|(
name|load
argument_list|)
expr_stmt|;
name|serversToServerInfo
operator|.
name|put
argument_list|(
name|s
argument_list|,
name|serverInfo
argument_list|)
expr_stmt|;
name|serversToLoad
operator|.
name|put
argument_list|(
name|s
argument_list|,
name|load
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|loadToServers
init|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|servers
init|=
name|loadToServers
operator|.
name|get
argument_list|(
name|load
argument_list|)
decl_stmt|;
if|if
condition|(
name|servers
operator|==
literal|null
condition|)
block|{
name|servers
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|servers
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|loadToServers
operator|.
name|put
argument_list|(
name|load
argument_list|,
name|servers
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Called to process the messages sent from the region server to the master    * along with the heart beat.    *     * @param serverInfo    * @param msgs    * @param mostLoadedRegions Array of regions the region server is submitting    * as candidates to be rebalanced, should it be overloaded    * @return messages from master to region server indicating what region    * server should do.    *     * @throws IOException    */
specifier|public
name|HMsg
index|[]
name|regionServerReport
parameter_list|(
specifier|final
name|HServerInfo
name|serverInfo
parameter_list|,
specifier|final
name|HMsg
name|msgs
index|[]
parameter_list|,
specifier|final
name|HRegionInfo
index|[]
name|mostLoadedRegions
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|serverName
init|=
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|msgs
operator|.
name|length
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|msgs
index|[
literal|0
index|]
operator|.
name|isType
argument_list|(
name|HMsg
operator|.
name|Type
operator|.
name|MSG_REPORT_EXITING
argument_list|)
condition|)
block|{
name|processRegionServerExit
argument_list|(
name|serverName
argument_list|,
name|msgs
argument_list|)
expr_stmt|;
return|return
name|HMsg
operator|.
name|EMPTY_HMSG_ARRAY
return|;
block|}
elseif|else
if|if
condition|(
name|msgs
index|[
literal|0
index|]
operator|.
name|isType
argument_list|(
name|HMsg
operator|.
name|Type
operator|.
name|MSG_REPORT_QUIESCED
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Region server "
operator|+
name|serverName
operator|+
literal|" quiesced"
argument_list|)
expr_stmt|;
name|quiescedServers
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|master
operator|.
name|shutdownRequested
condition|)
block|{
if|if
condition|(
name|quiescedServers
operator|.
name|get
argument_list|()
operator|>=
name|serversToServerInfo
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// If the only servers we know about are meta servers, then we can
comment|// proceed with shutdown
name|LOG
operator|.
name|info
argument_list|(
literal|"All user tables quiesced. Proceeding with shutdown"
argument_list|)
expr_stmt|;
name|master
operator|.
name|startShutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|master
operator|.
name|closed
operator|.
name|get
argument_list|()
condition|)
block|{
if|if
condition|(
name|msgs
operator|.
name|length
operator|>
literal|0
operator|&&
name|msgs
index|[
literal|0
index|]
operator|.
name|isType
argument_list|(
name|HMsg
operator|.
name|Type
operator|.
name|MSG_REPORT_QUIESCED
argument_list|)
condition|)
block|{
comment|// Server is already quiesced, but we aren't ready to shut down
comment|// return empty response
return|return
name|HMsg
operator|.
name|EMPTY_HMSG_ARRAY
return|;
block|}
comment|// Tell the server to stop serving any user regions
return|return
operator|new
name|HMsg
index|[]
block|{
name|HMsg
operator|.
name|REGIONSERVER_QUIESCE
block|}
return|;
block|}
block|}
if|if
condition|(
name|master
operator|.
name|closed
operator|.
name|get
argument_list|()
condition|)
block|{
comment|// Tell server to shut down if we are shutting down.  This should
comment|// happen after check of MSG_REPORT_EXITING above, since region server
comment|// will send us one of these messages after it gets MSG_REGIONSERVER_STOP
return|return
operator|new
name|HMsg
index|[]
block|{
name|HMsg
operator|.
name|REGIONSERVER_STOP
block|}
return|;
block|}
name|HServerInfo
name|storedInfo
init|=
name|serversToServerInfo
operator|.
name|get
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
if|if
condition|(
name|storedInfo
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"received server report from unknown server: "
operator|+
name|serverName
argument_list|)
expr_stmt|;
block|}
comment|// The HBaseMaster may have been restarted.
comment|// Tell the RegionServer to start over and call regionServerStartup()
return|return
operator|new
name|HMsg
index|[]
block|{
name|HMsg
operator|.
name|CALL_SERVER_STARTUP
block|}
return|;
block|}
elseif|else
if|if
condition|(
name|storedInfo
operator|.
name|getStartCode
argument_list|()
operator|!=
name|serverInfo
operator|.
name|getStartCode
argument_list|()
condition|)
block|{
comment|// This state is reachable if:
comment|//
comment|// 1) RegionServer A started
comment|// 2) RegionServer B started on the same machine, then
comment|//    clobbered A in regionServerStartup.
comment|// 3) RegionServer A returns, expecting to work as usual.
comment|//
comment|// The answer is to ask A to shut down for good.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"region server race condition detected: "
operator|+
name|serverName
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|serversToServerInfo
init|)
block|{
name|cancelLease
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
name|serversToServerInfo
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|HMsg
index|[]
block|{
name|HMsg
operator|.
name|REGIONSERVER_STOP
block|}
return|;
block|}
else|else
block|{
return|return
name|processRegionServerAllsWell
argument_list|(
name|serverName
argument_list|,
name|serverInfo
argument_list|,
name|mostLoadedRegions
argument_list|,
name|msgs
argument_list|)
return|;
block|}
block|}
comment|/** Region server is exiting */
specifier|private
name|void
name|processRegionServerExit
parameter_list|(
name|String
name|serverName
parameter_list|,
name|HMsg
index|[]
name|msgs
parameter_list|)
block|{
synchronized|synchronized
init|(
name|serversToServerInfo
init|)
block|{
try|try
block|{
comment|// HRegionServer is shutting down. Cancel the server's lease.
comment|// Note that canceling the server's lease takes care of updating
comment|// serversToServerInfo, etc.
if|if
condition|(
name|cancelLease
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
comment|// Only process the exit message if the server still has a lease.
comment|// Otherwise we could end up processing the server exit twice.
name|LOG
operator|.
name|info
argument_list|(
literal|"Region server "
operator|+
name|serverName
operator|+
literal|": MSG_REPORT_EXITING -- lease cancelled"
argument_list|)
expr_stmt|;
comment|// Get all the regions the server was serving reassigned
comment|// (if we are not shutting down).
if|if
condition|(
operator|!
name|master
operator|.
name|closed
operator|.
name|get
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|msgs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing "
operator|+
name|msgs
index|[
name|i
index|]
operator|+
literal|" from "
operator|+
name|serverName
argument_list|)
expr_stmt|;
name|HRegionInfo
name|info
init|=
name|msgs
index|[
name|i
index|]
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|isRootRegion
argument_list|()
condition|)
block|{
name|master
operator|.
name|regionManager
operator|.
name|unassignRootRegion
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|.
name|isMetaTable
argument_list|()
condition|)
block|{
name|master
operator|.
name|regionManager
operator|.
name|offlineMetaRegion
argument_list|(
name|info
operator|.
name|getStartKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|master
operator|.
name|regionManager
operator|.
name|isMarkedToClose
argument_list|(
name|serverName
argument_list|,
name|info
operator|.
name|getRegionName
argument_list|()
argument_list|)
condition|)
block|{
name|master
operator|.
name|regionManager
operator|.
name|setUnassigned
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// We don't need to return anything to the server because it isn't
comment|// going to do any more work.
block|}
finally|finally
block|{
name|serversToServerInfo
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/** RegionServer is checking in, no exceptional circumstances */
specifier|private
name|HMsg
index|[]
name|processRegionServerAllsWell
parameter_list|(
name|String
name|serverName
parameter_list|,
name|HServerInfo
name|serverInfo
parameter_list|,
name|HRegionInfo
index|[]
name|mostLoadedRegions
parameter_list|,
name|HMsg
index|[]
name|msgs
parameter_list|)
throws|throws
name|IOException
block|{
comment|// All's well.  Renew the server's lease.
comment|// This will always succeed; otherwise, the fetch of serversToServerInfo
comment|// would have failed above.
name|serverLeases
operator|.
name|renewLease
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
comment|// Refresh the info object and the load information
name|serversToServerInfo
operator|.
name|put
argument_list|(
name|serverName
argument_list|,
name|serverInfo
argument_list|)
expr_stmt|;
name|HServerLoad
name|load
init|=
name|serversToLoad
operator|.
name|get
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
if|if
condition|(
name|load
operator|!=
literal|null
operator|&&
operator|!
name|load
operator|.
name|equals
argument_list|(
name|serverInfo
operator|.
name|getLoad
argument_list|()
argument_list|)
condition|)
block|{
comment|// We have previous information about the load on this server
comment|// and the load on this server has changed
synchronized|synchronized
init|(
name|loadToServers
init|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|servers
init|=
name|loadToServers
operator|.
name|get
argument_list|(
name|load
argument_list|)
decl_stmt|;
comment|// Note that servers should never be null because loadToServers
comment|// and serversToLoad are manipulated in pairs
name|servers
operator|.
name|remove
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
name|loadToServers
operator|.
name|put
argument_list|(
name|load
argument_list|,
name|servers
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Set the current load information
name|load
operator|=
name|serverInfo
operator|.
name|getLoad
argument_list|()
expr_stmt|;
name|serversToLoad
operator|.
name|put
argument_list|(
name|serverName
argument_list|,
name|load
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|loadToServers
init|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|servers
init|=
name|loadToServers
operator|.
name|get
argument_list|(
name|load
argument_list|)
decl_stmt|;
if|if
condition|(
name|servers
operator|==
literal|null
condition|)
block|{
name|servers
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|servers
operator|.
name|add
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
name|loadToServers
operator|.
name|put
argument_list|(
name|load
argument_list|,
name|servers
argument_list|)
expr_stmt|;
block|}
comment|// Next, process messages for this server
return|return
name|processMsgs
argument_list|(
name|serverName
argument_list|,
name|serverInfo
argument_list|,
name|mostLoadedRegions
argument_list|,
name|msgs
argument_list|)
return|;
block|}
comment|/**     * Process all the incoming messages from a server that's contacted us.    *     * Note that we never need to update the server's load information because    * that has already been done in regionServerReport.    */
specifier|private
name|HMsg
index|[]
name|processMsgs
parameter_list|(
name|String
name|serverName
parameter_list|,
name|HServerInfo
name|serverInfo
parameter_list|,
name|HRegionInfo
index|[]
name|mostLoadedRegions
parameter_list|,
name|HMsg
name|incomingMsgs
index|[]
parameter_list|)
throws|throws
name|IOException
block|{
name|ArrayList
argument_list|<
name|HMsg
argument_list|>
name|returnMsgs
init|=
operator|new
name|ArrayList
argument_list|<
name|HMsg
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionInfo
argument_list|>
name|regionsToKill
init|=
name|master
operator|.
name|regionManager
operator|.
name|removeMarkedToClose
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
comment|// Get reports on what the RegionServer did.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|incomingMsgs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|HRegionInfo
name|region
init|=
name|incomingMsgs
index|[
name|i
index|]
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Received "
operator|+
name|incomingMsgs
index|[
name|i
index|]
operator|+
literal|" from "
operator|+
name|serverName
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|incomingMsgs
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|MSG_REPORT_PROCESS_OPEN
case|:
name|master
operator|.
name|regionManager
operator|.
name|updateAssignmentDeadline
argument_list|(
name|region
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_REPORT_OPEN
case|:
name|processRegionOpen
argument_list|(
name|serverName
argument_list|,
name|serverInfo
argument_list|,
name|region
argument_list|,
name|returnMsgs
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_REPORT_CLOSE
case|:
name|processRegionClose
argument_list|(
name|serverInfo
argument_list|,
name|region
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_REPORT_SPLIT
case|:
name|processSplitRegion
argument_list|(
name|serverName
argument_list|,
name|serverInfo
argument_list|,
name|region
argument_list|,
name|incomingMsgs
index|[
operator|++
name|i
index|]
argument_list|,
name|incomingMsgs
index|[
operator|++
name|i
index|]
argument_list|,
name|returnMsgs
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Impossible state during message processing. Instruction: "
operator|+
name|incomingMsgs
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|// Tell the region server to close regions that we have marked for closing.
if|if
condition|(
name|regionsToKill
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|HRegionInfo
name|i
range|:
name|regionsToKill
operator|.
name|values
argument_list|()
control|)
block|{
name|returnMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|Type
operator|.
name|MSG_REGION_CLOSE
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|// Transition the region from toClose to closing state
name|master
operator|.
name|regionManager
operator|.
name|setClosing
argument_list|(
name|i
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Figure out what the RegionServer ought to do, and write back.
name|master
operator|.
name|regionManager
operator|.
name|assignRegions
argument_list|(
name|serverInfo
argument_list|,
name|serverName
argument_list|,
name|mostLoadedRegions
argument_list|,
name|returnMsgs
argument_list|)
expr_stmt|;
return|return
name|returnMsgs
operator|.
name|toArray
argument_list|(
operator|new
name|HMsg
index|[
name|returnMsgs
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**    * A region has split.    *    * @param serverName    * @param serverInfo    * @param region    * @param splitA    * @param splitB    * @param returnMsgs    */
specifier|private
name|void
name|processSplitRegion
parameter_list|(
name|String
name|serverName
parameter_list|,
name|HServerInfo
name|serverInfo
parameter_list|,
name|HRegionInfo
name|region
parameter_list|,
name|HMsg
name|splitA
parameter_list|,
name|HMsg
name|splitB
parameter_list|,
name|ArrayList
argument_list|<
name|HMsg
argument_list|>
name|returnMsgs
parameter_list|)
block|{
name|HRegionInfo
name|newRegionA
init|=
name|splitA
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
name|master
operator|.
name|regionManager
operator|.
name|setUnassigned
argument_list|(
name|newRegionA
argument_list|)
expr_stmt|;
name|HRegionInfo
name|newRegionB
init|=
name|splitB
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
name|master
operator|.
name|regionManager
operator|.
name|setUnassigned
argument_list|(
name|newRegionB
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|.
name|isMetaTable
argument_list|()
condition|)
block|{
comment|// A meta region has split.
name|master
operator|.
name|regionManager
operator|.
name|offlineMetaRegion
argument_list|(
name|region
operator|.
name|getStartKey
argument_list|()
argument_list|)
expr_stmt|;
name|master
operator|.
name|regionManager
operator|.
name|incrementNumMetaRegions
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Region server is reporting that a region is now opened */
specifier|private
name|void
name|processRegionOpen
parameter_list|(
name|String
name|serverName
parameter_list|,
name|HServerInfo
name|serverInfo
parameter_list|,
name|HRegionInfo
name|region
parameter_list|,
name|ArrayList
argument_list|<
name|HMsg
argument_list|>
name|returnMsgs
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|duplicateAssignment
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|master
operator|.
name|regionManager
operator|.
name|isUnassigned
argument_list|(
name|region
argument_list|)
condition|)
block|{
if|if
condition|(
name|region
operator|.
name|isRootRegion
argument_list|()
condition|)
block|{
comment|// Root region
name|HServerAddress
name|rootServer
init|=
name|master
operator|.
name|getRootRegionLocation
argument_list|()
decl_stmt|;
if|if
condition|(
name|rootServer
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|rootServer
operator|.
name|toString
argument_list|()
operator|.
name|compareTo
argument_list|(
name|serverName
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// A duplicate open report from the correct server
return|return;
block|}
comment|// We received an open report on the root region, but it is
comment|// assigned to a different server
name|duplicateAssignment
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Not root region. If it is not a pending region, then we are
comment|// going to treat it as a duplicate assignment, although we can't
comment|// tell for certain that's the case.
if|if
condition|(
name|master
operator|.
name|regionManager
operator|.
name|isPending
argument_list|(
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|)
condition|)
block|{
comment|// A duplicate report from the correct server
return|return;
block|}
name|duplicateAssignment
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|duplicateAssignment
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"region server "
operator|+
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|" should not have opened region "
operator|+
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// This Region should not have been opened.
comment|// Ask the server to shut it down, but don't report it as closed.
comment|// Otherwise the HMaster will think the Region was closed on purpose,
comment|// and then try to reopen it elsewhere; that's not what we want.
name|returnMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|Type
operator|.
name|MSG_REGION_CLOSE_WITHOUT_REPORT
argument_list|,
name|region
argument_list|,
literal|"Duplicate assignment"
operator|.
name|getBytes
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// it was assigned, and it's not a duplicate assignment, so take it out
comment|// of the unassigned list.
name|master
operator|.
name|regionManager
operator|.
name|noLongerUnassigned
argument_list|(
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|.
name|isRootRegion
argument_list|()
condition|)
block|{
comment|// Store the Root Region location (in memory)
name|HServerAddress
name|rootServer
init|=
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
decl_stmt|;
name|master
operator|.
name|connection
operator|.
name|setRootRegionLocation
argument_list|(
operator|new
name|HRegionLocation
argument_list|(
name|region
argument_list|,
name|rootServer
argument_list|)
argument_list|)
expr_stmt|;
name|master
operator|.
name|regionManager
operator|.
name|setRootRegionLocation
argument_list|(
name|rootServer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Note that the table has been assigned and is waiting for the
comment|// meta table to be updated.
name|master
operator|.
name|regionManager
operator|.
name|setPending
argument_list|(
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Queue up an update to note the region location.
try|try
block|{
name|master
operator|.
name|toDoQueue
operator|.
name|put
argument_list|(
operator|new
name|ProcessRegionOpen
argument_list|(
name|master
argument_list|,
name|serverInfo
argument_list|,
name|region
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Putting into toDoQueue was interrupted."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|}
specifier|private
name|void
name|processRegionClose
parameter_list|(
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
name|HServerInfo
name|serverInfo
parameter_list|,
name|HRegionInfo
name|region
parameter_list|)
block|{
if|if
condition|(
name|region
operator|.
name|isRootRegion
argument_list|()
condition|)
block|{
comment|// Root region
if|if
condition|(
name|region
operator|.
name|isOffline
argument_list|()
condition|)
block|{
comment|// Can't proceed without root region. Shutdown.
name|LOG
operator|.
name|fatal
argument_list|(
literal|"root region is marked offline"
argument_list|)
expr_stmt|;
name|master
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
name|master
operator|.
name|connection
operator|.
name|setRootRegionLocation
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|master
operator|.
name|regionManager
operator|.
name|unassignRootRegion
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|boolean
name|reassignRegion
init|=
operator|!
name|region
operator|.
name|isOffline
argument_list|()
decl_stmt|;
name|boolean
name|offlineRegion
init|=
literal|false
decl_stmt|;
comment|// either this region is being closed because it was marked to close, or
comment|// the region server is going down peacefully. in either case, we should
comment|// at least try to remove it from the closing list.
name|master
operator|.
name|regionManager
operator|.
name|noLongerClosing
argument_list|(
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
comment|// if the region is marked to be offlined, we don't want to reassign it.
if|if
condition|(
name|master
operator|.
name|regionManager
operator|.
name|isMarkedForOffline
argument_list|(
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|)
condition|)
block|{
name|reassignRegion
operator|=
literal|false
expr_stmt|;
name|offlineRegion
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|region
operator|.
name|isMetaTable
argument_list|()
condition|)
block|{
comment|// Region is part of the meta table. Remove it from onlineMetaRegions
name|master
operator|.
name|regionManager
operator|.
name|offlineMetaRegion
argument_list|(
name|region
operator|.
name|getStartKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// if the region is already on the unassigned list, let's remove it. this
comment|// is safe because if it's going to be reassigned, it'll get added again
comment|// shortly. if it's not going to get reassigned, then we need to make
comment|// sure it's not on the unassigned list, because that would contend with
comment|// the ProcessRegionClose going on asynchronously.
name|master
operator|.
name|regionManager
operator|.
name|noLongerUnassigned
argument_list|(
name|region
argument_list|)
expr_stmt|;
comment|// NOTE: we cannot put the region into unassignedRegions as that
comment|//       changes the ordering of the messages we've received. In
comment|//       this case, a close could be processed before an open
comment|//       resulting in the master not agreeing on the region's
comment|//       state.
try|try
block|{
name|master
operator|.
name|toDoQueue
operator|.
name|put
argument_list|(
operator|new
name|ProcessRegionClose
argument_list|(
name|master
argument_list|,
name|region
argument_list|,
name|offlineRegion
argument_list|,
name|reassignRegion
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Putting into toDoQueue was interrupted."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** Cancel a server's lease and update its load information */
specifier|private
name|boolean
name|cancelLease
parameter_list|(
specifier|final
name|String
name|serverName
parameter_list|)
block|{
name|boolean
name|leaseCancelled
init|=
literal|false
decl_stmt|;
name|HServerInfo
name|info
init|=
name|serversToServerInfo
operator|.
name|remove
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
comment|// Only cancel lease and update load information once.
comment|// This method can be called a couple of times during shutdown.
if|if
condition|(
name|master
operator|.
name|getRootRegionLocation
argument_list|()
operator|!=
literal|null
operator|&&
name|info
operator|.
name|getServerAddress
argument_list|()
operator|.
name|equals
argument_list|(
name|master
operator|.
name|getRootRegionLocation
argument_list|()
argument_list|)
condition|)
block|{
name|master
operator|.
name|regionManager
operator|.
name|unassignRootRegion
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Cancelling lease for "
operator|+
name|serverName
argument_list|)
expr_stmt|;
try|try
block|{
name|serverLeases
operator|.
name|cancelLease
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LeaseException
name|e
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Cancelling "
operator|+
name|serverName
operator|+
literal|" got "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
operator|+
literal|"...continuing"
argument_list|)
expr_stmt|;
block|}
block|}
name|leaseCancelled
operator|=
literal|true
expr_stmt|;
comment|// update load information
name|HServerLoad
name|load
init|=
name|serversToLoad
operator|.
name|remove
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
if|if
condition|(
name|load
operator|!=
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|loadToServers
init|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|servers
init|=
name|loadToServers
operator|.
name|get
argument_list|(
name|load
argument_list|)
decl_stmt|;
if|if
condition|(
name|servers
operator|!=
literal|null
condition|)
block|{
name|servers
operator|.
name|remove
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
name|loadToServers
operator|.
name|put
argument_list|(
name|load
argument_list|,
name|servers
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|leaseCancelled
return|;
block|}
comment|/**     * Compute the average load across all region servers.     * Currently, this uses a very naive computation - just uses the number of     * regions being served, ignoring stats about number of requests.    * @return the average load    */
specifier|public
name|double
name|getAverageLoad
parameter_list|()
block|{
name|int
name|totalLoad
init|=
literal|0
decl_stmt|;
name|int
name|numServers
init|=
literal|0
decl_stmt|;
name|double
name|averageLoad
init|=
literal|0.0
decl_stmt|;
synchronized|synchronized
init|(
name|serversToLoad
init|)
block|{
name|numServers
operator|=
name|serversToLoad
operator|.
name|size
argument_list|()
expr_stmt|;
for|for
control|(
name|HServerLoad
name|load
range|:
name|serversToLoad
operator|.
name|values
argument_list|()
control|)
block|{
name|totalLoad
operator|+=
name|load
operator|.
name|getNumberOfRegions
argument_list|()
expr_stmt|;
block|}
name|averageLoad
operator|=
name|Math
operator|.
name|ceil
argument_list|(
operator|(
name|double
operator|)
name|totalLoad
operator|/
operator|(
name|double
operator|)
name|numServers
argument_list|)
expr_stmt|;
comment|// Only log on a period, not on every invocation of this method.
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|(
name|now
operator|>
operator|(
name|this
operator|.
name|loggingPeriodForAverageLoad
operator|+
name|this
operator|.
name|lastLogOfAverageLaod
operator|)
operator|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Total Load: "
operator|+
name|totalLoad
operator|+
literal|", Num Servers: "
operator|+
name|numServers
operator|+
literal|", Avg Load: "
operator|+
name|averageLoad
argument_list|)
expr_stmt|;
name|this
operator|.
name|lastLogOfAverageLaod
operator|=
name|now
expr_stmt|;
block|}
block|}
return|return
name|averageLoad
return|;
block|}
comment|/** @return the number of active servers */
specifier|public
name|int
name|numServers
parameter_list|()
block|{
return|return
name|serversToServerInfo
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * @param address server address    * @return HServerInfo for the given server address    */
specifier|public
name|HServerInfo
name|getServerInfo
parameter_list|(
name|String
name|address
parameter_list|)
block|{
return|return
name|serversToServerInfo
operator|.
name|get
argument_list|(
name|address
argument_list|)
return|;
block|}
comment|/**    * @return Read-only map of servers to serverinfo.    */
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|HServerInfo
argument_list|>
name|getServersToServerInfo
parameter_list|()
block|{
synchronized|synchronized
init|(
name|serversToServerInfo
init|)
block|{
return|return
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|HServerInfo
argument_list|>
argument_list|(
name|serversToServerInfo
argument_list|)
return|;
block|}
block|}
comment|/**    * @return Read-only map of servers to load.    */
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|HServerLoad
argument_list|>
name|getServersToLoad
parameter_list|()
block|{
synchronized|synchronized
init|(
name|serversToLoad
init|)
block|{
return|return
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|HServerLoad
argument_list|>
argument_list|(
name|serversToLoad
argument_list|)
return|;
block|}
block|}
comment|/**    * @return Read-only map of load to servers.    */
specifier|public
name|Map
argument_list|<
name|HServerLoad
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|getLoadToServers
parameter_list|()
block|{
synchronized|synchronized
init|(
name|loadToServers
init|)
block|{
return|return
operator|new
name|HashMap
argument_list|<
name|HServerLoad
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|(
name|loadToServers
argument_list|)
return|;
block|}
block|}
comment|/**    * Wakes up threads waiting on serversToServerInfo    */
specifier|public
name|void
name|notifyServers
parameter_list|()
block|{
synchronized|synchronized
init|(
name|serversToServerInfo
init|)
block|{
name|serversToServerInfo
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*    * Wait on regionservers to report in    * with {@link #regionServerReport(HServerInfo, HMsg[])} so they get notice    * the master is going down.  Waits until all region servers come back with    * a MSG_REGIONSERVER_STOP which will cancel their lease or until leases held    * by remote region servers have expired.    */
name|void
name|letRegionServersShutdown
parameter_list|()
block|{
if|if
condition|(
operator|!
name|master
operator|.
name|fsOk
condition|)
block|{
comment|// Forget waiting for the region servers if the file system has gone
comment|// away. Just exit as quickly as possible.
return|return;
block|}
synchronized|synchronized
init|(
name|serversToServerInfo
init|)
block|{
while|while
condition|(
name|serversToServerInfo
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting on following regionserver(s) to go down (or "
operator|+
literal|"region server lease expiration, whichever happens first): "
operator|+
name|serversToServerInfo
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|serversToServerInfo
operator|.
name|wait
argument_list|(
name|master
operator|.
name|threadWakeFrequency
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// continue
block|}
block|}
block|}
block|}
comment|/** Instantiated to monitor the health of a region server */
specifier|private
class|class
name|ServerExpirer
implements|implements
name|LeaseListener
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"hiding"
argument_list|)
specifier|private
name|String
name|server
decl_stmt|;
name|ServerExpirer
parameter_list|(
name|String
name|server
parameter_list|)
block|{
name|this
operator|.
name|server
operator|=
name|server
expr_stmt|;
block|}
specifier|public
name|void
name|leaseExpired
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
name|server
operator|+
literal|" lease expired"
argument_list|)
expr_stmt|;
comment|// Remove the server from the known servers list and update load info
name|HServerInfo
name|info
init|=
name|serversToServerInfo
operator|.
name|remove
argument_list|(
name|server
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
name|HServerAddress
name|root
init|=
name|master
operator|.
name|getRootRegionLocation
argument_list|()
decl_stmt|;
if|if
condition|(
name|root
operator|!=
literal|null
operator|&&
name|root
operator|.
name|equals
argument_list|(
name|info
operator|.
name|getServerAddress
argument_list|()
argument_list|)
condition|)
block|{
name|master
operator|.
name|regionManager
operator|.
name|unassignRootRegion
argument_list|()
expr_stmt|;
block|}
name|String
name|serverName
init|=
name|info
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|HServerLoad
name|load
init|=
name|serversToLoad
operator|.
name|remove
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
if|if
condition|(
name|load
operator|!=
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|loadToServers
init|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|servers
init|=
name|loadToServers
operator|.
name|get
argument_list|(
name|load
argument_list|)
decl_stmt|;
if|if
condition|(
name|servers
operator|!=
literal|null
condition|)
block|{
name|servers
operator|.
name|remove
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
name|loadToServers
operator|.
name|put
argument_list|(
name|load
argument_list|,
name|servers
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|deadServers
operator|.
name|add
argument_list|(
name|server
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|serversToServerInfo
init|)
block|{
name|serversToServerInfo
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
comment|// NOTE: If the server was serving the root region, we cannot reassign it
comment|// here because the new server will start serving the root region before
comment|// the ProcessServerShutdown operation has a chance to split the log file.
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
name|master
operator|.
name|delayedToDoQueue
operator|.
name|put
argument_list|(
operator|new
name|ProcessServerShutdown
argument_list|(
name|master
argument_list|,
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Start up the server manager */
specifier|public
name|void
name|start
parameter_list|()
block|{
comment|// Leases are not the same as Chore threads. Set name differently.
name|this
operator|.
name|serverLeases
operator|.
name|setName
argument_list|(
literal|"ServerManager.leaseChecker"
argument_list|)
expr_stmt|;
name|this
operator|.
name|serverLeases
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|/** Shut down the server manager */
specifier|public
name|void
name|stop
parameter_list|()
block|{
comment|// stop monitor lease monitor
name|serverLeases
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * @param serverName    */
specifier|public
name|void
name|removeDeadServer
parameter_list|(
name|String
name|serverName
parameter_list|)
block|{
name|deadServers
operator|.
name|remove
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param serverName    * @return true if server is dead    */
specifier|public
name|boolean
name|isDead
parameter_list|(
name|String
name|serverName
parameter_list|)
block|{
return|return
name|deadServers
operator|.
name|contains
argument_list|(
name|serverName
argument_list|)
return|;
block|}
block|}
end_class

end_unit

