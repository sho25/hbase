begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|rmi
operator|.
name|server
operator|.
name|UID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|MessageDigest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|DataInputBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IntWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|RawComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|UTF8
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|VersionMismatchException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableComparable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|CodecPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|CompressionCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|CompressionInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|CompressionOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|Compressor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|Decompressor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|DefaultCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|GzipCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|zlib
operator|.
name|ZlibFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|serializer
operator|.
name|Deserializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|serializer
operator|.
name|SerializationFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|serializer
operator|.
name|Serializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Progressable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Progress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|NativeCodeLoader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|MergeSort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import

begin_comment
comment|/**   *<code>SequenceFile</code>s are flat files consisting of binary key/value   * pairs.  *   *<p>This is copy of Hadoop SequenceFile brought local so we can fix bugs;  * e.g. hbase-1097</p>  *   *<p><code>SequenceFile</code> provides {@link Writer}, {@link Reader} and  * {@link Sorter} classes for writing, reading and sorting respectively.</p>  *   * There are three<code>SequenceFile</code><code>Writer</code>s based on the   * {@link CompressionType} used to compress key/value pairs:  *<ol>  *<li>  *<code>Writer</code> : Uncompressed records.  *</li>  *<li>  *<code>RecordCompressWriter</code> : Record-compressed files, only compress   *                                       values.  *</li>  *<li>  *<code>BlockCompressWriter</code> : Block-compressed files, both keys&   *                                      values are collected in 'blocks'   *                                      separately and compressed. The size of   *                                      the 'block' is configurable.  *</ol>  *   *<p>The actual compression algorithm used to compress key and/or values can be  * specified by using the appropriate {@link CompressionCodec}.</p>  *   *<p>The recommended way is to use the static<tt>createWriter</tt> methods  * provided by the<code>SequenceFile</code> to chose the preferred format.</p>  *  *<p>The {@link Reader} acts as the bridge and can read any of the above   *<code>SequenceFile</code> formats.</p>  *  *<h4 id="Formats">SequenceFile Formats</h4>  *   *<p>Essentially there are 3 different formats for<code>SequenceFile</code>s  * depending on the<code>CompressionType</code> specified. All of them share a  *<a href="#Header">common header</a> described below.  *   *<h5 id="Header">SequenceFile Header</h5>  *<ul>  *<li>  *   version - 3 bytes of magic header<b>SEQ</b>, followed by 1 byte of actual   *             version number (e.g. SEQ4 or SEQ6)  *</li>  *<li>  *   keyClassName -key class  *</li>  *<li>  *   valueClassName - value class  *</li>  *<li>  *   compression - A boolean which specifies if compression is turned on for   *                 keys/values in this file.  *</li>  *<li>  *   blockCompression - A boolean which specifies if block-compression is   *                      turned on for keys/values in this file.  *</li>  *<li>  *   compression codec -<code>CompressionCodec</code> class which is used for    *                       compression of keys and/or values (if compression is   *                       enabled).  *</li>  *<li>  *   metadata - {@link Metadata} for this file.  *</li>  *<li>  *   sync - A sync marker to denote end of the header.  *</li>  *</ul>  *   *<h5 id="#UncompressedFormat">Uncompressed SequenceFile Format</h5>  *<ul>  *<li>  *<a href="#Header">Header</a>  *</li>  *<li>  * Record  *<ul>  *<li>Record length</li>  *<li>Key length</li>  *<li>Key</li>  *<li>Value</li>  *</ul>  *</li>  *<li>  * A sync-marker every few<code>100</code> bytes or so.  *</li>  *</ul>  *  *<h5 id="#RecordCompressedFormat">Record-Compressed SequenceFile Format</h5>  *<ul>  *<li>  *<a href="#Header">Header</a>  *</li>  *<li>  * Record  *<ul>  *<li>Record length</li>  *<li>Key length</li>  *<li>Key</li>  *<li><i>Compressed</i> Value</li>  *</ul>  *</li>  *<li>  * A sync-marker every few<code>100</code> bytes or so.  *</li>  *</ul>  *   *<h5 id="#BlockCompressedFormat">Block-Compressed SequenceFile Format</h5>  *<ul>  *<li>  *<a href="#Header">Header</a>  *</li>  *<li>  * Record<i>Block</i>  *<ul>  *<li>Compressed key-lengths block-size</li>  *<li>Compressed key-lengths block</li>  *<li>Compressed keys block-size</li>  *<li>Compressed keys block</li>  *<li>Compressed value-lengths block-size</li>  *<li>Compressed value-lengths block</li>  *<li>Compressed values block-size</li>  *<li>Compressed values block</li>  *</ul>  *</li>  *<li>  * A sync-marker every few<code>100</code> bytes or so.  *</li>  *</ul>  *   *<p>The compressed blocks of key lengths and value lengths consist of the   * actual lengths of individual keys/values encoded in ZeroCompressedInteger   * format.</p>  *   * @see CompressionCodec  */
end_comment

begin_class
specifier|public
class|class
name|SequenceFile
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|SequenceFile
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|SequenceFile
parameter_list|()
block|{}
comment|// no public ctor
specifier|private
specifier|static
specifier|final
name|byte
name|BLOCK_COMPRESS_VERSION
init|=
operator|(
name|byte
operator|)
literal|4
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
name|CUSTOM_COMPRESS_VERSION
init|=
operator|(
name|byte
operator|)
literal|5
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
name|VERSION_WITH_METADATA
init|=
operator|(
name|byte
operator|)
literal|6
decl_stmt|;
specifier|private
specifier|static
name|byte
index|[]
name|VERSION
init|=
operator|new
name|byte
index|[]
block|{
operator|(
name|byte
operator|)
literal|'S'
block|,
operator|(
name|byte
operator|)
literal|'E'
block|,
operator|(
name|byte
operator|)
literal|'Q'
block|,
name|VERSION_WITH_METADATA
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|SYNC_ESCAPE
init|=
operator|-
literal|1
decl_stmt|;
comment|// "length" of sync entries
specifier|private
specifier|static
specifier|final
name|int
name|SYNC_HASH_SIZE
init|=
literal|16
decl_stmt|;
comment|// number of bytes in hash
specifier|private
specifier|static
specifier|final
name|int
name|SYNC_SIZE
init|=
literal|4
operator|+
name|SYNC_HASH_SIZE
decl_stmt|;
comment|// escape + hash
comment|/** The number of bytes between sync points.*/
specifier|public
specifier|static
specifier|final
name|int
name|SYNC_INTERVAL
init|=
literal|100
operator|*
name|SYNC_SIZE
decl_stmt|;
comment|/**     * The compression type used to compress key/value pairs in the     * {@link SequenceFile}.    *     * @see SequenceFile.Writer    */
specifier|public
specifier|static
enum|enum
name|CompressionType
block|{
comment|/** Do not compress records. */
name|NONE
block|,
comment|/** Compress values only, each separately. */
name|RECORD
block|,
comment|/** Compress sequences of records together in blocks. */
name|BLOCK
block|}
comment|/**    * Get the compression type for the reduce outputs    * @param job the job config to look in    * @return the kind of compression to use    * @deprecated Use     *             {@link org.apache.hadoop.mapred.SequenceFileOutputFormat#getOutputCompressionType(org.apache.hadoop.mapred.JobConf)}     *             to get {@link CompressionType} for job-outputs.    */
annotation|@
name|Deprecated
specifier|static
specifier|public
name|CompressionType
name|getCompressionType
parameter_list|(
name|Configuration
name|job
parameter_list|)
block|{
name|String
name|name
init|=
name|job
operator|.
name|get
argument_list|(
literal|"io.seqfile.compression.type"
argument_list|)
decl_stmt|;
return|return
name|name
operator|==
literal|null
condition|?
name|CompressionType
operator|.
name|RECORD
else|:
name|CompressionType
operator|.
name|valueOf
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**    * Set the compression type for sequence files.    * @param job the configuration to modify    * @param val the new compression type (none, block, record)    * @deprecated Use the one of the many SequenceFile.createWriter methods to specify    *             the {@link CompressionType} while creating the {@link SequenceFile} or    *             {@link org.apache.hadoop.mapred.SequenceFileOutputFormat#setOutputCompressionType(org.apache.hadoop.mapred.JobConf, org.apache.hadoop.io.SequenceFile.CompressionType)}    *             to specify the {@link CompressionType} for job-outputs.     * or     */
annotation|@
name|Deprecated
specifier|static
specifier|public
name|void
name|setCompressionType
parameter_list|(
name|Configuration
name|job
parameter_list|,
name|CompressionType
name|val
parameter_list|)
block|{
name|job
operator|.
name|set
argument_list|(
literal|"io.seqfile.compression.type"
argument_list|,
name|val
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct the preferred type of SequenceFile Writer.    * @param fs The configured filesystem.     * @param conf The configuration.    * @param name The name of the file.     * @param keyClass The 'key' type.    * @param valClass The 'value' type.    * @return Returns the handle to the constructed SequenceFile Writer.    * @throws IOException    */
specifier|public
specifier|static
name|Writer
name|createWriter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createWriter
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|name
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|getCompressionType
argument_list|(
name|conf
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Construct the preferred type of SequenceFile Writer.    * @param fs The configured filesystem.     * @param conf The configuration.    * @param name The name of the file.     * @param keyClass The 'key' type.    * @param valClass The 'value' type.    * @param compressionType The compression type.    * @return Returns the handle to the constructed SequenceFile Writer.    * @throws IOException    */
specifier|public
specifier|static
name|Writer
name|createWriter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|CompressionType
name|compressionType
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createWriter
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|name
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|fs
operator|.
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"io.file.buffer.size"
argument_list|,
literal|4096
argument_list|)
argument_list|,
name|fs
operator|.
name|getDefaultReplication
argument_list|()
argument_list|,
name|fs
operator|.
name|getDefaultBlockSize
argument_list|()
argument_list|,
name|compressionType
argument_list|,
operator|new
name|DefaultCodec
argument_list|()
argument_list|,
literal|null
argument_list|,
operator|new
name|Metadata
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Construct the preferred type of SequenceFile Writer.    * @param fs The configured filesystem.     * @param conf The configuration.    * @param name The name of the file.     * @param keyClass The 'key' type.    * @param valClass The 'value' type.    * @param compressionType The compression type.    * @param progress The Progressable object to track progress.    * @return Returns the handle to the constructed SequenceFile Writer.    * @throws IOException    */
specifier|public
specifier|static
name|Writer
name|createWriter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|CompressionType
name|compressionType
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createWriter
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|name
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|fs
operator|.
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"io.file.buffer.size"
argument_list|,
literal|4096
argument_list|)
argument_list|,
name|fs
operator|.
name|getDefaultReplication
argument_list|()
argument_list|,
name|fs
operator|.
name|getDefaultBlockSize
argument_list|()
argument_list|,
name|compressionType
argument_list|,
operator|new
name|DefaultCodec
argument_list|()
argument_list|,
name|progress
argument_list|,
operator|new
name|Metadata
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Construct the preferred type of SequenceFile Writer.    * @param fs The configured filesystem.     * @param conf The configuration.    * @param name The name of the file.     * @param keyClass The 'key' type.    * @param valClass The 'value' type.    * @param compressionType The compression type.    * @param codec The compression codec.    * @return Returns the handle to the constructed SequenceFile Writer.    * @throws IOException    */
specifier|public
specifier|static
name|Writer
name|createWriter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|CompressionType
name|compressionType
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createWriter
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|name
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|fs
operator|.
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"io.file.buffer.size"
argument_list|,
literal|4096
argument_list|)
argument_list|,
name|fs
operator|.
name|getDefaultReplication
argument_list|()
argument_list|,
name|fs
operator|.
name|getDefaultBlockSize
argument_list|()
argument_list|,
name|compressionType
argument_list|,
name|codec
argument_list|,
literal|null
argument_list|,
operator|new
name|Metadata
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Construct the preferred type of SequenceFile Writer.    * @param fs The configured filesystem.     * @param conf The configuration.    * @param name The name of the file.     * @param keyClass The 'key' type.    * @param valClass The 'value' type.    * @param compressionType The compression type.    * @param codec The compression codec.    * @param progress The Progressable object to track progress.    * @param metadata The metadata of the file.    * @return Returns the handle to the constructed SequenceFile Writer.    * @throws IOException    */
specifier|public
specifier|static
name|Writer
name|createWriter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|CompressionType
name|compressionType
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createWriter
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|name
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|fs
operator|.
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"io.file.buffer.size"
argument_list|,
literal|4096
argument_list|)
argument_list|,
name|fs
operator|.
name|getDefaultReplication
argument_list|()
argument_list|,
name|fs
operator|.
name|getDefaultBlockSize
argument_list|()
argument_list|,
name|compressionType
argument_list|,
name|codec
argument_list|,
name|progress
argument_list|,
name|metadata
argument_list|)
return|;
block|}
comment|/**    * Construct the preferred type of SequenceFile Writer.    * @param fs The configured filesystem.    * @param conf The configuration.    * @param name The name of the file.    * @param keyClass The 'key' type.    * @param valClass The 'value' type.    * @param bufferSize buffer size for the underlaying outputstream.    * @param replication replication factor for the file.    * @param blockSize block size for the file.    * @param compressionType The compression type.    * @param codec The compression codec.    * @param progress The Progressable object to track progress.    * @param metadata The metadata of the file.    * @return Returns the handle to the constructed SequenceFile Writer.    * @throws IOException    */
specifier|public
specifier|static
name|Writer
name|createWriter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|CompressionType
name|compressionType
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|(
name|codec
operator|instanceof
name|GzipCodec
operator|)
operator|&&
operator|!
name|NativeCodeLoader
operator|.
name|isNativeCodeLoaded
argument_list|()
operator|&&
operator|!
name|ZlibFactory
operator|.
name|isNativeZlibLoaded
argument_list|(
name|conf
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"SequenceFile doesn't work with "
operator|+
literal|"GzipCodec without native-hadoop code!"
argument_list|)
throw|;
block|}
name|Writer
name|writer
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|compressionType
operator|==
name|CompressionType
operator|.
name|NONE
condition|)
block|{
name|writer
operator|=
operator|new
name|Writer
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|name
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compressionType
operator|==
name|CompressionType
operator|.
name|RECORD
condition|)
block|{
name|writer
operator|=
operator|new
name|RecordCompressWriter
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|name
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|codec
argument_list|,
name|progress
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compressionType
operator|==
name|CompressionType
operator|.
name|BLOCK
condition|)
block|{
name|writer
operator|=
operator|new
name|BlockCompressWriter
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|name
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|codec
argument_list|,
name|progress
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
block|}
return|return
name|writer
return|;
block|}
comment|/**    * Construct the preferred type of SequenceFile Writer.    * @param fs The configured filesystem.     * @param conf The configuration.    * @param name The name of the file.     * @param keyClass The 'key' type.    * @param valClass The 'value' type.    * @param compressionType The compression type.    * @param codec The compression codec.    * @param progress The Progressable object to track progress.    * @return Returns the handle to the constructed SequenceFile Writer.    * @throws IOException    */
specifier|public
specifier|static
name|Writer
name|createWriter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|CompressionType
name|compressionType
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
name|Writer
name|writer
init|=
name|createWriter
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|name
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|compressionType
argument_list|,
name|codec
argument_list|,
name|progress
argument_list|,
operator|new
name|Metadata
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|writer
return|;
block|}
comment|/**    * Construct the preferred type of 'raw' SequenceFile Writer.    * @param out The stream on top which the writer is to be constructed.    * @param keyClass The 'key' type.    * @param valClass The 'value' type.    * @param compress Compress data?    * @param blockCompress Compress blocks?    * @param metadata The metadata of the file.    * @return Returns the handle to the constructed SequenceFile Writer.    * @throws IOException    */
specifier|private
specifier|static
name|Writer
name|createWriter
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FSDataOutputStream
name|out
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|boolean
name|compress
parameter_list|,
name|boolean
name|blockCompress
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|codec
operator|!=
literal|null
operator|&&
operator|(
name|codec
operator|instanceof
name|GzipCodec
operator|)
operator|&&
operator|!
name|NativeCodeLoader
operator|.
name|isNativeCodeLoaded
argument_list|()
operator|&&
operator|!
name|ZlibFactory
operator|.
name|isNativeZlibLoaded
argument_list|(
name|conf
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"SequenceFile doesn't work with "
operator|+
literal|"GzipCodec without native-hadoop code!"
argument_list|)
throw|;
block|}
name|Writer
name|writer
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|compress
condition|)
block|{
name|writer
operator|=
operator|new
name|Writer
argument_list|(
name|conf
argument_list|,
name|out
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compress
operator|&&
operator|!
name|blockCompress
condition|)
block|{
name|writer
operator|=
operator|new
name|RecordCompressWriter
argument_list|(
name|conf
argument_list|,
name|out
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|codec
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writer
operator|=
operator|new
name|BlockCompressWriter
argument_list|(
name|conf
argument_list|,
name|out
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|codec
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
block|}
return|return
name|writer
return|;
block|}
comment|/**    * Construct the preferred type of 'raw' SequenceFile Writer.    * @param fs The configured filesystem.     * @param conf The configuration.    * @param file The name of the file.     * @param keyClass The 'key' type.    * @param valClass The 'value' type.    * @param compress Compress data?    * @param blockCompress Compress blocks?    * @param codec The compression codec.    * @param progress    * @param metadata The metadata of the file.    * @return Returns the handle to the constructed SequenceFile Writer.    * @throws IOException    */
specifier|private
specifier|static
name|Writer
name|createWriter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|file
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|boolean
name|compress
parameter_list|,
name|boolean
name|blockCompress
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|codec
operator|!=
literal|null
operator|&&
operator|(
name|codec
operator|instanceof
name|GzipCodec
operator|)
operator|&&
operator|!
name|NativeCodeLoader
operator|.
name|isNativeCodeLoaded
argument_list|()
operator|&&
operator|!
name|ZlibFactory
operator|.
name|isNativeZlibLoaded
argument_list|(
name|conf
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"SequenceFile doesn't work with "
operator|+
literal|"GzipCodec without native-hadoop code!"
argument_list|)
throw|;
block|}
name|Writer
name|writer
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|compress
condition|)
block|{
name|writer
operator|=
operator|new
name|Writer
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|file
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|progress
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compress
operator|&&
operator|!
name|blockCompress
condition|)
block|{
name|writer
operator|=
operator|new
name|RecordCompressWriter
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|file
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|codec
argument_list|,
name|progress
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writer
operator|=
operator|new
name|BlockCompressWriter
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|file
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|codec
argument_list|,
name|progress
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
block|}
return|return
name|writer
return|;
block|}
comment|/**    * Construct the preferred type of 'raw' SequenceFile Writer.    * @param conf The configuration.    * @param out The stream on top which the writer is to be constructed.    * @param keyClass The 'key' type.    * @param valClass The 'value' type.    * @param compressionType The compression type.    * @param codec The compression codec.    * @param metadata The metadata of the file.    * @return Returns the handle to the constructed SequenceFile Writer.    * @throws IOException    */
specifier|public
specifier|static
name|Writer
name|createWriter
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FSDataOutputStream
name|out
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|CompressionType
name|compressionType
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|(
name|codec
operator|instanceof
name|GzipCodec
operator|)
operator|&&
operator|!
name|NativeCodeLoader
operator|.
name|isNativeCodeLoaded
argument_list|()
operator|&&
operator|!
name|ZlibFactory
operator|.
name|isNativeZlibLoaded
argument_list|(
name|conf
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"SequenceFile doesn't work with "
operator|+
literal|"GzipCodec without native-hadoop code!"
argument_list|)
throw|;
block|}
name|Writer
name|writer
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|compressionType
operator|==
name|CompressionType
operator|.
name|NONE
condition|)
block|{
name|writer
operator|=
operator|new
name|Writer
argument_list|(
name|conf
argument_list|,
name|out
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compressionType
operator|==
name|CompressionType
operator|.
name|RECORD
condition|)
block|{
name|writer
operator|=
operator|new
name|RecordCompressWriter
argument_list|(
name|conf
argument_list|,
name|out
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|codec
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compressionType
operator|==
name|CompressionType
operator|.
name|BLOCK
condition|)
block|{
name|writer
operator|=
operator|new
name|BlockCompressWriter
argument_list|(
name|conf
argument_list|,
name|out
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|codec
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
block|}
return|return
name|writer
return|;
block|}
comment|/**    * Construct the preferred type of 'raw' SequenceFile Writer.    * @param conf The configuration.    * @param out The stream on top which the writer is to be constructed.    * @param keyClass The 'key' type.    * @param valClass The 'value' type.    * @param compressionType The compression type.    * @param codec The compression codec.    * @return Returns the handle to the constructed SequenceFile Writer.    * @throws IOException    */
specifier|public
specifier|static
name|Writer
name|createWriter
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FSDataOutputStream
name|out
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|CompressionType
name|compressionType
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|)
throws|throws
name|IOException
block|{
name|Writer
name|writer
init|=
name|createWriter
argument_list|(
name|conf
argument_list|,
name|out
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|compressionType
argument_list|,
name|codec
argument_list|,
operator|new
name|Metadata
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|writer
return|;
block|}
comment|/** The interface to 'raw' values of SequenceFiles. */
specifier|public
specifier|static
interface|interface
name|ValueBytes
block|{
comment|/** Writes the uncompressed bytes to the outStream.      * @param outStream : Stream to write uncompressed bytes into.      * @throws IOException      */
specifier|public
name|void
name|writeUncompressedBytes
parameter_list|(
name|DataOutputStream
name|outStream
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Write compressed bytes to outStream.       * Note: that it will NOT compress the bytes if they are not compressed.      * @param outStream : Stream to write compressed bytes into.      */
specifier|public
name|void
name|writeCompressedBytes
parameter_list|(
name|DataOutputStream
name|outStream
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|IOException
function_decl|;
comment|/**      * Size of stored data.      */
specifier|public
name|int
name|getSize
parameter_list|()
function_decl|;
block|}
specifier|private
specifier|static
class|class
name|UncompressedBytes
implements|implements
name|ValueBytes
block|{
specifier|private
name|int
name|dataSize
decl_stmt|;
specifier|private
name|byte
index|[]
name|data
decl_stmt|;
specifier|private
name|UncompressedBytes
parameter_list|()
block|{
name|data
operator|=
literal|null
expr_stmt|;
name|dataSize
operator|=
literal|0
expr_stmt|;
block|}
specifier|private
name|void
name|reset
parameter_list|(
name|DataInputStream
name|in
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|data
operator|=
operator|new
name|byte
index|[
name|length
index|]
expr_stmt|;
name|dataSize
operator|=
operator|-
literal|1
expr_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|dataSize
operator|=
name|data
operator|.
name|length
expr_stmt|;
block|}
specifier|public
name|int
name|getSize
parameter_list|()
block|{
return|return
name|dataSize
return|;
block|}
specifier|public
name|void
name|writeUncompressedBytes
parameter_list|(
name|DataOutputStream
name|outStream
parameter_list|)
throws|throws
name|IOException
block|{
name|outStream
operator|.
name|write
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|dataSize
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|writeCompressedBytes
parameter_list|(
name|DataOutputStream
name|outStream
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|IOException
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"UncompressedBytes cannot be compressed!"
argument_list|)
throw|;
block|}
block|}
comment|// UncompressedBytes
specifier|private
specifier|static
class|class
name|CompressedBytes
implements|implements
name|ValueBytes
block|{
specifier|private
name|int
name|dataSize
decl_stmt|;
specifier|private
name|byte
index|[]
name|data
decl_stmt|;
name|DataInputBuffer
name|rawData
init|=
literal|null
decl_stmt|;
name|CompressionCodec
name|codec
init|=
literal|null
decl_stmt|;
name|CompressionInputStream
name|decompressedStream
init|=
literal|null
decl_stmt|;
specifier|private
name|CompressedBytes
parameter_list|(
name|CompressionCodec
name|codec
parameter_list|)
block|{
name|data
operator|=
literal|null
expr_stmt|;
name|dataSize
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|codec
operator|=
name|codec
expr_stmt|;
block|}
specifier|private
name|void
name|reset
parameter_list|(
name|DataInputStream
name|in
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|data
operator|=
operator|new
name|byte
index|[
name|length
index|]
expr_stmt|;
name|dataSize
operator|=
operator|-
literal|1
expr_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|dataSize
operator|=
name|data
operator|.
name|length
expr_stmt|;
block|}
specifier|public
name|int
name|getSize
parameter_list|()
block|{
return|return
name|dataSize
return|;
block|}
specifier|public
name|void
name|writeUncompressedBytes
parameter_list|(
name|DataOutputStream
name|outStream
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|decompressedStream
operator|==
literal|null
condition|)
block|{
name|rawData
operator|=
operator|new
name|DataInputBuffer
argument_list|()
expr_stmt|;
name|decompressedStream
operator|=
name|codec
operator|.
name|createInputStream
argument_list|(
name|rawData
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decompressedStream
operator|.
name|resetState
argument_list|()
expr_stmt|;
block|}
name|rawData
operator|.
name|reset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|dataSize
argument_list|)
expr_stmt|;
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
literal|8192
index|]
decl_stmt|;
name|int
name|bytesRead
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|bytesRead
operator|=
name|decompressedStream
operator|.
name|read
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
literal|8192
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|outStream
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|bytesRead
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|writeCompressedBytes
parameter_list|(
name|DataOutputStream
name|outStream
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|IOException
block|{
name|outStream
operator|.
name|write
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|dataSize
argument_list|)
expr_stmt|;
block|}
block|}
comment|// CompressedBytes
comment|/**    * The class encapsulating with the metadata of a file.    * The metadata of a file is a list of attribute name/value    * pairs of Text type.    *    */
specifier|public
specifier|static
class|class
name|Metadata
implements|implements
name|Writable
block|{
specifier|private
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
name|theMetadata
decl_stmt|;
specifier|public
name|Metadata
parameter_list|()
block|{
name|this
argument_list|(
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Metadata
parameter_list|(
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|theMetadata
operator|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|theMetadata
operator|=
name|arg
expr_stmt|;
block|}
block|}
specifier|public
name|Text
name|get
parameter_list|(
name|Text
name|name
parameter_list|)
block|{
return|return
name|this
operator|.
name|theMetadata
operator|.
name|get
argument_list|(
name|name
argument_list|)
return|;
block|}
specifier|public
name|void
name|set
parameter_list|(
name|Text
name|name
parameter_list|,
name|Text
name|value
parameter_list|)
block|{
name|this
operator|.
name|theMetadata
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
specifier|public
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
name|getMetadata
parameter_list|()
block|{
return|return
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
argument_list|(
name|this
operator|.
name|theMetadata
argument_list|)
return|;
block|}
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|writeInt
argument_list|(
name|this
operator|.
name|theMetadata
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
argument_list|>
name|iter
init|=
name|this
operator|.
name|theMetadata
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
name|en
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|en
operator|.
name|getKey
argument_list|()
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|en
operator|.
name|getValue
argument_list|()
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|sz
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|sz
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid size: "
operator|+
name|sz
operator|+
literal|" for file metadata object"
argument_list|)
throw|;
name|this
operator|.
name|theMetadata
operator|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
name|Text
name|key
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
name|Text
name|val
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
name|key
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|val
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|this
operator|.
name|theMetadata
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|equals
parameter_list|(
name|Metadata
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|==
literal|null
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|this
operator|.
name|theMetadata
operator|.
name|size
argument_list|()
operator|!=
name|other
operator|.
name|theMetadata
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
argument_list|>
name|iter1
init|=
name|this
operator|.
name|theMetadata
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
argument_list|>
name|iter2
init|=
name|other
operator|.
name|theMetadata
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter1
operator|.
name|hasNext
argument_list|()
operator|&&
name|iter2
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
name|en1
init|=
name|iter1
operator|.
name|next
argument_list|()
decl_stmt|;
name|Map
operator|.
name|Entry
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
name|en2
init|=
name|iter2
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|en1
operator|.
name|getKey
argument_list|()
operator|.
name|equals
argument_list|(
name|en2
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|en1
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
name|en2
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|iter1
operator|.
name|hasNext
argument_list|()
operator|||
name|iter2
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
assert|assert
literal|false
operator|:
literal|"hashCode not designed"
assert|;
return|return
literal|42
return|;
comment|// any arbitrary constant will do
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"size: "
argument_list|)
operator|.
name|append
argument_list|(
name|this
operator|.
name|theMetadata
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
argument_list|>
name|iter
init|=
name|this
operator|.
name|theMetadata
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
name|en
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
name|en
operator|.
name|getKey
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
name|en
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/** Write key/value pairs to a sequence-format file. */
specifier|public
specifier|static
class|class
name|Writer
implements|implements
name|java
operator|.
name|io
operator|.
name|Closeable
block|{
name|Configuration
name|conf
decl_stmt|;
name|FSDataOutputStream
name|out
decl_stmt|;
name|boolean
name|ownOutputStream
init|=
literal|true
decl_stmt|;
name|DataOutputBuffer
name|buffer
init|=
operator|new
name|DataOutputBuffer
argument_list|()
decl_stmt|;
name|Class
name|keyClass
decl_stmt|;
name|Class
name|valClass
decl_stmt|;
specifier|private
name|boolean
name|compress
decl_stmt|;
name|CompressionCodec
name|codec
init|=
literal|null
decl_stmt|;
name|CompressionOutputStream
name|deflateFilter
init|=
literal|null
decl_stmt|;
name|DataOutputStream
name|deflateOut
init|=
literal|null
decl_stmt|;
name|Metadata
name|metadata
init|=
literal|null
decl_stmt|;
name|Compressor
name|compressor
init|=
literal|null
decl_stmt|;
specifier|protected
name|Serializer
name|keySerializer
decl_stmt|;
specifier|protected
name|Serializer
name|uncompressedValSerializer
decl_stmt|;
specifier|protected
name|Serializer
name|compressedValSerializer
decl_stmt|;
comment|// Insert a globally unique 16-byte value every few entries, so that one
comment|// can seek into the middle of a file and then synchronize with record
comment|// starts and ends by scanning for this value.
name|long
name|lastSyncPos
decl_stmt|;
comment|// position of last sync
name|byte
index|[]
name|sync
decl_stmt|;
comment|// 16 random bytes
block|{
try|try
block|{
name|MessageDigest
name|digester
init|=
name|MessageDigest
operator|.
name|getInstance
argument_list|(
literal|"MD5"
argument_list|)
decl_stmt|;
name|long
name|time
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|digester
operator|.
name|update
argument_list|(
operator|(
operator|new
name|UID
argument_list|()
operator|+
literal|"@"
operator|+
name|time
operator|)
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
name|sync
operator|=
name|digester
operator|.
name|digest
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** Implicit constructor: needed for the period of transition!*/
name|Writer
parameter_list|()
block|{}
comment|/** Create the named file. */
specifier|public
name|Writer
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|name
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
literal|null
argument_list|,
operator|new
name|Metadata
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Create the named file with write-progress reporter. */
specifier|public
name|Writer
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|name
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|fs
operator|.
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"io.file.buffer.size"
argument_list|,
literal|4096
argument_list|)
argument_list|,
name|fs
operator|.
name|getDefaultReplication
argument_list|()
argument_list|,
name|fs
operator|.
name|getDefaultBlockSize
argument_list|()
argument_list|,
name|progress
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
block|}
comment|/** Create the named file with write-progress reporter. */
specifier|public
name|Writer
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
throws|throws
name|IOException
block|{
name|init
argument_list|(
name|name
argument_list|,
name|conf
argument_list|,
name|fs
operator|.
name|create
argument_list|(
name|name
argument_list|,
literal|true
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|)
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
name|initializeFileHeader
argument_list|()
expr_stmt|;
name|writeFileHeader
argument_list|()
expr_stmt|;
name|finalizeFileHeader
argument_list|()
expr_stmt|;
block|}
comment|/** Write to an arbitrary stream using a specified buffer size. */
specifier|private
name|Writer
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FSDataOutputStream
name|out
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|ownOutputStream
operator|=
literal|false
expr_stmt|;
name|init
argument_list|(
literal|null
argument_list|,
name|conf
argument_list|,
name|out
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
name|initializeFileHeader
argument_list|()
expr_stmt|;
name|writeFileHeader
argument_list|()
expr_stmt|;
name|finalizeFileHeader
argument_list|()
expr_stmt|;
block|}
comment|/** Write the initial part of file header. */
name|void
name|initializeFileHeader
parameter_list|()
throws|throws
name|IOException
block|{
name|out
operator|.
name|write
argument_list|(
name|VERSION
argument_list|)
expr_stmt|;
block|}
comment|/** Write the final part of file header. */
name|void
name|finalizeFileHeader
parameter_list|()
throws|throws
name|IOException
block|{
name|out
operator|.
name|write
argument_list|(
name|sync
argument_list|)
expr_stmt|;
comment|// write the sync bytes
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
comment|// flush header
block|}
name|boolean
name|isCompressed
parameter_list|()
block|{
return|return
name|compress
return|;
block|}
name|boolean
name|isBlockCompressed
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/** Write and flush the file header. */
name|void
name|writeFileHeader
parameter_list|()
throws|throws
name|IOException
block|{
name|Text
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|keyClass
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Text
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|valClass
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBoolean
argument_list|(
name|this
operator|.
name|isCompressed
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBoolean
argument_list|(
name|this
operator|.
name|isBlockCompressed
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|isCompressed
argument_list|()
condition|)
block|{
name|Text
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
operator|(
name|codec
operator|.
name|getClass
argument_list|()
operator|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|metadata
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
comment|/** Initialize. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|void
name|init
parameter_list|(
name|Path
name|name
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|FSDataOutputStream
name|out
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|boolean
name|compress
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|out
operator|=
name|out
expr_stmt|;
name|this
operator|.
name|keyClass
operator|=
name|keyClass
expr_stmt|;
name|this
operator|.
name|valClass
operator|=
name|valClass
expr_stmt|;
name|this
operator|.
name|compress
operator|=
name|compress
expr_stmt|;
name|this
operator|.
name|codec
operator|=
name|codec
expr_stmt|;
name|this
operator|.
name|metadata
operator|=
name|metadata
expr_stmt|;
name|SerializationFactory
name|serializationFactory
init|=
operator|new
name|SerializationFactory
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|this
operator|.
name|keySerializer
operator|=
name|serializationFactory
operator|.
name|getSerializer
argument_list|(
name|keyClass
argument_list|)
expr_stmt|;
name|this
operator|.
name|keySerializer
operator|.
name|open
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|this
operator|.
name|uncompressedValSerializer
operator|=
name|serializationFactory
operator|.
name|getSerializer
argument_list|(
name|valClass
argument_list|)
expr_stmt|;
name|this
operator|.
name|uncompressedValSerializer
operator|.
name|open
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|codec
operator|!=
literal|null
condition|)
block|{
name|ReflectionUtils
operator|.
name|setConf
argument_list|(
name|this
operator|.
name|codec
argument_list|,
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|compressor
operator|=
name|CodecPool
operator|.
name|getCompressor
argument_list|(
name|this
operator|.
name|codec
argument_list|)
expr_stmt|;
name|this
operator|.
name|deflateFilter
operator|=
name|this
operator|.
name|codec
operator|.
name|createOutputStream
argument_list|(
name|buffer
argument_list|,
name|compressor
argument_list|)
expr_stmt|;
name|this
operator|.
name|deflateOut
operator|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|deflateFilter
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|compressedValSerializer
operator|=
name|serializationFactory
operator|.
name|getSerializer
argument_list|(
name|valClass
argument_list|)
expr_stmt|;
name|this
operator|.
name|compressedValSerializer
operator|.
name|open
argument_list|(
name|deflateOut
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Returns the class of keys in this file. */
specifier|public
name|Class
name|getKeyClass
parameter_list|()
block|{
return|return
name|keyClass
return|;
block|}
comment|/** Returns the class of values in this file. */
specifier|public
name|Class
name|getValueClass
parameter_list|()
block|{
return|return
name|valClass
return|;
block|}
comment|/** Returns the compression codec of data in this file. */
specifier|public
name|CompressionCodec
name|getCompressionCodec
parameter_list|()
block|{
return|return
name|codec
return|;
block|}
comment|/** create a sync point */
specifier|public
name|void
name|sync
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|sync
operator|!=
literal|null
operator|&&
name|lastSyncPos
operator|!=
name|out
operator|.
name|getPos
argument_list|()
condition|)
block|{
name|out
operator|.
name|writeInt
argument_list|(
name|SYNC_ESCAPE
argument_list|)
expr_stmt|;
comment|// mark the start of the sync
name|out
operator|.
name|write
argument_list|(
name|sync
argument_list|)
expr_stmt|;
comment|// write sync
name|lastSyncPos
operator|=
name|out
operator|.
name|getPos
argument_list|()
expr_stmt|;
comment|// update lastSyncPos
block|}
block|}
comment|/** Returns the configuration of this file. */
name|Configuration
name|getConf
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
comment|/** Close the file. */
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|keySerializer
operator|.
name|close
argument_list|()
expr_stmt|;
name|uncompressedValSerializer
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|compressedValSerializer
operator|!=
literal|null
condition|)
block|{
name|compressedValSerializer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|CodecPool
operator|.
name|returnCompressor
argument_list|(
name|compressor
argument_list|)
expr_stmt|;
name|compressor
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
comment|// Close the underlying stream iff we own it...
if|if
condition|(
name|ownOutputStream
condition|)
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
name|out
operator|=
literal|null
expr_stmt|;
block|}
block|}
specifier|synchronized
name|void
name|checkAndWriteSync
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|sync
operator|!=
literal|null
operator|&&
name|out
operator|.
name|getPos
argument_list|()
operator|>=
name|lastSyncPos
operator|+
name|SYNC_INTERVAL
condition|)
block|{
comment|// time to emit sync
name|sync
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Append a key/value pair. */
specifier|public
specifier|synchronized
name|void
name|append
parameter_list|(
name|Writable
name|key
parameter_list|,
name|Writable
name|val
parameter_list|)
throws|throws
name|IOException
block|{
name|append
argument_list|(
operator|(
name|Object
operator|)
name|key
argument_list|,
operator|(
name|Object
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
comment|/** Append a key/value pair. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|synchronized
name|void
name|append
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|val
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|key
operator|.
name|getClass
argument_list|()
operator|!=
name|keyClass
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"wrong key class: "
operator|+
name|key
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" is not "
operator|+
name|keyClass
argument_list|)
throw|;
if|if
condition|(
name|val
operator|.
name|getClass
argument_list|()
operator|!=
name|valClass
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"wrong value class: "
operator|+
name|val
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" is not "
operator|+
name|valClass
argument_list|)
throw|;
name|buffer
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// Append the 'key'
name|keySerializer
operator|.
name|serialize
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|int
name|keyLength
init|=
name|buffer
operator|.
name|getLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|keyLength
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"negative length keys not allowed: "
operator|+
name|key
argument_list|)
throw|;
comment|// Append the 'value'
if|if
condition|(
name|compress
condition|)
block|{
name|deflateFilter
operator|.
name|resetState
argument_list|()
expr_stmt|;
name|compressedValSerializer
operator|.
name|serialize
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|deflateOut
operator|.
name|flush
argument_list|()
expr_stmt|;
name|deflateFilter
operator|.
name|finish
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|uncompressedValSerializer
operator|.
name|serialize
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
comment|// Write the record out
name|checkAndWriteSync
argument_list|()
expr_stmt|;
comment|// sync
name|out
operator|.
name|writeInt
argument_list|(
name|buffer
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
comment|// total record length
name|out
operator|.
name|writeInt
argument_list|(
name|keyLength
argument_list|)
expr_stmt|;
comment|// key portion length
name|out
operator|.
name|write
argument_list|(
name|buffer
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|buffer
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
comment|// data
block|}
specifier|public
specifier|synchronized
name|void
name|appendRaw
parameter_list|(
name|byte
index|[]
name|keyData
parameter_list|,
name|int
name|keyOffset
parameter_list|,
name|int
name|keyLength
parameter_list|,
name|ValueBytes
name|val
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|keyLength
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"negative length keys not allowed: "
operator|+
name|keyLength
argument_list|)
throw|;
name|int
name|valLength
init|=
name|val
operator|.
name|getSize
argument_list|()
decl_stmt|;
name|checkAndWriteSync
argument_list|()
expr_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|keyLength
operator|+
name|valLength
argument_list|)
expr_stmt|;
comment|// total record length
name|out
operator|.
name|writeInt
argument_list|(
name|keyLength
argument_list|)
expr_stmt|;
comment|// key portion length
name|out
operator|.
name|write
argument_list|(
name|keyData
argument_list|,
name|keyOffset
argument_list|,
name|keyLength
argument_list|)
expr_stmt|;
comment|// key
name|val
operator|.
name|writeUncompressedBytes
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|// value
block|}
comment|/** Returns the current length of the output file.      *      *<p>This always returns a synchronized position.  In other words,      * immediately after calling {@link SequenceFile.Reader#seek(long)} with a position      * returned by this method, {@link SequenceFile.Reader#next(Writable)} may be called.  However      * the key may be earlier in the file than key last written when this      * method was called (e.g., with block-compression, it may be the first key      * in the block that was being written when this method was called).      */
specifier|public
specifier|synchronized
name|long
name|getLength
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|out
operator|.
name|getPos
argument_list|()
return|;
block|}
block|}
comment|// class Writer
comment|/** Write key/compressed-value pairs to a sequence-format file. */
specifier|static
class|class
name|RecordCompressWriter
extends|extends
name|Writer
block|{
comment|/** Create the named file. */
specifier|public
name|RecordCompressWriter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|conf
argument_list|,
name|fs
operator|.
name|create
argument_list|(
name|name
argument_list|)
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|codec
argument_list|,
operator|new
name|Metadata
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Create the named file with write-progress reporter. */
specifier|public
name|RecordCompressWriter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|name
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|fs
operator|.
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"io.file.buffer.size"
argument_list|,
literal|4096
argument_list|)
argument_list|,
name|fs
operator|.
name|getDefaultReplication
argument_list|()
argument_list|,
name|fs
operator|.
name|getDefaultBlockSize
argument_list|()
argument_list|,
name|codec
argument_list|,
name|progress
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
block|}
comment|/** Create the named file with write-progress reporter. */
specifier|public
name|RecordCompressWriter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|init
argument_list|(
name|name
argument_list|,
name|conf
argument_list|,
name|fs
operator|.
name|create
argument_list|(
name|name
argument_list|,
literal|true
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|)
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
literal|true
argument_list|,
name|codec
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
name|initializeFileHeader
argument_list|()
expr_stmt|;
name|writeFileHeader
argument_list|()
expr_stmt|;
name|finalizeFileHeader
argument_list|()
expr_stmt|;
block|}
comment|/** Create the named file with write-progress reporter. */
specifier|public
name|RecordCompressWriter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|name
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|codec
argument_list|,
name|progress
argument_list|,
operator|new
name|Metadata
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Write to an arbitrary stream using a specified buffer size. */
specifier|private
name|RecordCompressWriter
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FSDataOutputStream
name|out
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|ownOutputStream
operator|=
literal|false
expr_stmt|;
name|super
operator|.
name|init
argument_list|(
literal|null
argument_list|,
name|conf
argument_list|,
name|out
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
literal|true
argument_list|,
name|codec
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
name|initializeFileHeader
argument_list|()
expr_stmt|;
name|writeFileHeader
argument_list|()
expr_stmt|;
name|finalizeFileHeader
argument_list|()
expr_stmt|;
block|}
name|boolean
name|isCompressed
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
name|boolean
name|isBlockCompressed
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/** Append a key/value pair. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|synchronized
name|void
name|append
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|val
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|key
operator|.
name|getClass
argument_list|()
operator|!=
name|keyClass
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"wrong key class: "
operator|+
name|key
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" is not "
operator|+
name|keyClass
argument_list|)
throw|;
if|if
condition|(
name|val
operator|.
name|getClass
argument_list|()
operator|!=
name|valClass
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"wrong value class: "
operator|+
name|val
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" is not "
operator|+
name|valClass
argument_list|)
throw|;
name|buffer
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// Append the 'key'
name|keySerializer
operator|.
name|serialize
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|int
name|keyLength
init|=
name|buffer
operator|.
name|getLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|keyLength
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"negative length keys not allowed: "
operator|+
name|key
argument_list|)
throw|;
comment|// Compress 'value' and append it
name|deflateFilter
operator|.
name|resetState
argument_list|()
expr_stmt|;
name|compressedValSerializer
operator|.
name|serialize
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|deflateOut
operator|.
name|flush
argument_list|()
expr_stmt|;
name|deflateFilter
operator|.
name|finish
argument_list|()
expr_stmt|;
comment|// Write the record out
name|checkAndWriteSync
argument_list|()
expr_stmt|;
comment|// sync
name|out
operator|.
name|writeInt
argument_list|(
name|buffer
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
comment|// total record length
name|out
operator|.
name|writeInt
argument_list|(
name|keyLength
argument_list|)
expr_stmt|;
comment|// key portion length
name|out
operator|.
name|write
argument_list|(
name|buffer
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|buffer
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
comment|// data
block|}
comment|/** Append a key/value pair. */
specifier|public
specifier|synchronized
name|void
name|appendRaw
parameter_list|(
name|byte
index|[]
name|keyData
parameter_list|,
name|int
name|keyOffset
parameter_list|,
name|int
name|keyLength
parameter_list|,
name|ValueBytes
name|val
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|keyLength
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"negative length keys not allowed: "
operator|+
name|keyLength
argument_list|)
throw|;
name|int
name|valLength
init|=
name|val
operator|.
name|getSize
argument_list|()
decl_stmt|;
name|checkAndWriteSync
argument_list|()
expr_stmt|;
comment|// sync
name|out
operator|.
name|writeInt
argument_list|(
name|keyLength
operator|+
name|valLength
argument_list|)
expr_stmt|;
comment|// total record length
name|out
operator|.
name|writeInt
argument_list|(
name|keyLength
argument_list|)
expr_stmt|;
comment|// key portion length
name|out
operator|.
name|write
argument_list|(
name|keyData
argument_list|,
name|keyOffset
argument_list|,
name|keyLength
argument_list|)
expr_stmt|;
comment|// 'key' data
name|val
operator|.
name|writeCompressedBytes
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|// 'value' data
block|}
block|}
comment|// RecordCompressionWriter
comment|/** Write compressed key/value blocks to a sequence-format file. */
specifier|static
class|class
name|BlockCompressWriter
extends|extends
name|Writer
block|{
specifier|private
name|int
name|noBufferedRecords
init|=
literal|0
decl_stmt|;
specifier|private
name|DataOutputBuffer
name|keyLenBuffer
init|=
operator|new
name|DataOutputBuffer
argument_list|()
decl_stmt|;
specifier|private
name|DataOutputBuffer
name|keyBuffer
init|=
operator|new
name|DataOutputBuffer
argument_list|()
decl_stmt|;
specifier|private
name|DataOutputBuffer
name|valLenBuffer
init|=
operator|new
name|DataOutputBuffer
argument_list|()
decl_stmt|;
specifier|private
name|DataOutputBuffer
name|valBuffer
init|=
operator|new
name|DataOutputBuffer
argument_list|()
decl_stmt|;
specifier|private
name|int
name|compressionBlockSize
decl_stmt|;
comment|/** Create the named file. */
specifier|public
name|BlockCompressWriter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|name
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|fs
operator|.
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"io.file.buffer.size"
argument_list|,
literal|4096
argument_list|)
argument_list|,
name|fs
operator|.
name|getDefaultReplication
argument_list|()
argument_list|,
name|fs
operator|.
name|getDefaultBlockSize
argument_list|()
argument_list|,
name|codec
argument_list|,
literal|null
argument_list|,
operator|new
name|Metadata
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Create the named file with write-progress reporter. */
specifier|public
name|BlockCompressWriter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|name
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|fs
operator|.
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"io.file.buffer.size"
argument_list|,
literal|4096
argument_list|)
argument_list|,
name|fs
operator|.
name|getDefaultReplication
argument_list|()
argument_list|,
name|fs
operator|.
name|getDefaultBlockSize
argument_list|()
argument_list|,
name|codec
argument_list|,
name|progress
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
block|}
comment|/** Create the named file with write-progress reporter. */
specifier|public
name|BlockCompressWriter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|init
argument_list|(
name|name
argument_list|,
name|conf
argument_list|,
name|fs
operator|.
name|create
argument_list|(
name|name
argument_list|,
literal|true
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|)
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
literal|true
argument_list|,
name|codec
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
name|init
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
literal|"io.seqfile.compress.blocksize"
argument_list|,
literal|1000000
argument_list|)
argument_list|)
expr_stmt|;
name|initializeFileHeader
argument_list|()
expr_stmt|;
name|writeFileHeader
argument_list|()
expr_stmt|;
name|finalizeFileHeader
argument_list|()
expr_stmt|;
block|}
comment|/** Create the named file with write-progress reporter. */
specifier|public
name|BlockCompressWriter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|name
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|codec
argument_list|,
name|progress
argument_list|,
operator|new
name|Metadata
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Write to an arbitrary stream using a specified buffer size. */
specifier|private
name|BlockCompressWriter
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FSDataOutputStream
name|out
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|ownOutputStream
operator|=
literal|false
expr_stmt|;
name|super
operator|.
name|init
argument_list|(
literal|null
argument_list|,
name|conf
argument_list|,
name|out
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
literal|true
argument_list|,
name|codec
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
name|init
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|initializeFileHeader
argument_list|()
expr_stmt|;
name|writeFileHeader
argument_list|()
expr_stmt|;
name|finalizeFileHeader
argument_list|()
expr_stmt|;
block|}
name|boolean
name|isCompressed
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
name|boolean
name|isBlockCompressed
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/** Initialize */
name|void
name|init
parameter_list|(
name|int
name|compressionBlockSize
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|compressionBlockSize
operator|=
name|compressionBlockSize
expr_stmt|;
name|keySerializer
operator|.
name|close
argument_list|()
expr_stmt|;
name|keySerializer
operator|.
name|open
argument_list|(
name|keyBuffer
argument_list|)
expr_stmt|;
name|uncompressedValSerializer
operator|.
name|close
argument_list|()
expr_stmt|;
name|uncompressedValSerializer
operator|.
name|open
argument_list|(
name|valBuffer
argument_list|)
expr_stmt|;
block|}
comment|/** Workhorse to check and write out compressed data/lengths */
specifier|private
specifier|synchronized
name|void
name|writeBuffer
parameter_list|(
name|DataOutputBuffer
name|uncompressedDataBuffer
parameter_list|)
throws|throws
name|IOException
block|{
name|deflateFilter
operator|.
name|resetState
argument_list|()
expr_stmt|;
name|buffer
operator|.
name|reset
argument_list|()
expr_stmt|;
name|deflateOut
operator|.
name|write
argument_list|(
name|uncompressedDataBuffer
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|uncompressedDataBuffer
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|deflateOut
operator|.
name|flush
argument_list|()
expr_stmt|;
name|deflateFilter
operator|.
name|finish
argument_list|()
expr_stmt|;
name|WritableUtils
operator|.
name|writeVInt
argument_list|(
name|out
argument_list|,
name|buffer
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|buffer
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|buffer
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Compress and flush contents to dfs */
specifier|public
specifier|synchronized
name|void
name|sync
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|noBufferedRecords
operator|>
literal|0
condition|)
block|{
name|super
operator|.
name|sync
argument_list|()
expr_stmt|;
comment|// No. of records
name|WritableUtils
operator|.
name|writeVInt
argument_list|(
name|out
argument_list|,
name|noBufferedRecords
argument_list|)
expr_stmt|;
comment|// Write 'keys' and lengths
name|writeBuffer
argument_list|(
name|keyLenBuffer
argument_list|)
expr_stmt|;
name|writeBuffer
argument_list|(
name|keyBuffer
argument_list|)
expr_stmt|;
comment|// Write 'values' and lengths
name|writeBuffer
argument_list|(
name|valLenBuffer
argument_list|)
expr_stmt|;
name|writeBuffer
argument_list|(
name|valBuffer
argument_list|)
expr_stmt|;
comment|// Flush the file-stream
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
comment|// Reset internal states
name|keyLenBuffer
operator|.
name|reset
argument_list|()
expr_stmt|;
name|keyBuffer
operator|.
name|reset
argument_list|()
expr_stmt|;
name|valLenBuffer
operator|.
name|reset
argument_list|()
expr_stmt|;
name|valBuffer
operator|.
name|reset
argument_list|()
expr_stmt|;
name|noBufferedRecords
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/** Close the file. */
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|sync
argument_list|()
expr_stmt|;
block|}
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** Append a key/value pair. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|synchronized
name|void
name|append
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|val
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|key
operator|.
name|getClass
argument_list|()
operator|!=
name|keyClass
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"wrong key class: "
operator|+
name|key
operator|+
literal|" is not "
operator|+
name|keyClass
argument_list|)
throw|;
if|if
condition|(
name|val
operator|.
name|getClass
argument_list|()
operator|!=
name|valClass
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"wrong value class: "
operator|+
name|val
operator|+
literal|" is not "
operator|+
name|valClass
argument_list|)
throw|;
comment|// Save key/value into respective buffers
name|int
name|oldKeyLength
init|=
name|keyBuffer
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|keySerializer
operator|.
name|serialize
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|int
name|keyLength
init|=
name|keyBuffer
operator|.
name|getLength
argument_list|()
operator|-
name|oldKeyLength
decl_stmt|;
if|if
condition|(
name|keyLength
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"negative length keys not allowed: "
operator|+
name|key
argument_list|)
throw|;
name|WritableUtils
operator|.
name|writeVInt
argument_list|(
name|keyLenBuffer
argument_list|,
name|keyLength
argument_list|)
expr_stmt|;
name|int
name|oldValLength
init|=
name|valBuffer
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|uncompressedValSerializer
operator|.
name|serialize
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|int
name|valLength
init|=
name|valBuffer
operator|.
name|getLength
argument_list|()
operator|-
name|oldValLength
decl_stmt|;
name|WritableUtils
operator|.
name|writeVInt
argument_list|(
name|valLenBuffer
argument_list|,
name|valLength
argument_list|)
expr_stmt|;
comment|// Added another key/value pair
operator|++
name|noBufferedRecords
expr_stmt|;
comment|// Compress and flush?
name|int
name|currentBlockSize
init|=
name|keyBuffer
operator|.
name|getLength
argument_list|()
operator|+
name|valBuffer
operator|.
name|getLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentBlockSize
operator|>=
name|compressionBlockSize
condition|)
block|{
name|sync
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Append a key/value pair. */
specifier|public
specifier|synchronized
name|void
name|appendRaw
parameter_list|(
name|byte
index|[]
name|keyData
parameter_list|,
name|int
name|keyOffset
parameter_list|,
name|int
name|keyLength
parameter_list|,
name|ValueBytes
name|val
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|keyLength
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"negative length keys not allowed"
argument_list|)
throw|;
name|int
name|valLength
init|=
name|val
operator|.
name|getSize
argument_list|()
decl_stmt|;
comment|// Save key/value data in relevant buffers
name|WritableUtils
operator|.
name|writeVInt
argument_list|(
name|keyLenBuffer
argument_list|,
name|keyLength
argument_list|)
expr_stmt|;
name|keyBuffer
operator|.
name|write
argument_list|(
name|keyData
argument_list|,
name|keyOffset
argument_list|,
name|keyLength
argument_list|)
expr_stmt|;
name|WritableUtils
operator|.
name|writeVInt
argument_list|(
name|valLenBuffer
argument_list|,
name|valLength
argument_list|)
expr_stmt|;
name|val
operator|.
name|writeUncompressedBytes
argument_list|(
name|valBuffer
argument_list|)
expr_stmt|;
comment|// Added another key/value pair
operator|++
name|noBufferedRecords
expr_stmt|;
comment|// Compress and flush?
name|int
name|currentBlockSize
init|=
name|keyBuffer
operator|.
name|getLength
argument_list|()
operator|+
name|valBuffer
operator|.
name|getLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentBlockSize
operator|>=
name|compressionBlockSize
condition|)
block|{
name|sync
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// BlockCompressionWriter
comment|/** Reads key/value pairs from a sequence-format file. */
specifier|public
specifier|static
class|class
name|Reader
implements|implements
name|java
operator|.
name|io
operator|.
name|Closeable
block|{
specifier|private
name|Path
name|file
decl_stmt|;
specifier|private
name|FSDataInputStream
name|in
decl_stmt|;
specifier|private
name|DataOutputBuffer
name|outBuf
init|=
operator|new
name|DataOutputBuffer
argument_list|(
literal|32
argument_list|)
decl_stmt|;
specifier|private
name|byte
name|version
decl_stmt|;
specifier|private
name|String
name|keyClassName
decl_stmt|;
specifier|private
name|String
name|valClassName
decl_stmt|;
specifier|private
name|Class
name|keyClass
decl_stmt|;
specifier|private
name|Class
name|valClass
decl_stmt|;
specifier|private
name|CompressionCodec
name|codec
init|=
literal|null
decl_stmt|;
specifier|private
name|Metadata
name|metadata
init|=
literal|null
decl_stmt|;
specifier|private
name|byte
index|[]
name|sync
init|=
operator|new
name|byte
index|[
name|SYNC_HASH_SIZE
index|]
decl_stmt|;
specifier|private
name|byte
index|[]
name|syncCheck
init|=
operator|new
name|byte
index|[
name|SYNC_HASH_SIZE
index|]
decl_stmt|;
specifier|private
name|boolean
name|syncSeen
decl_stmt|;
specifier|private
name|long
name|end
decl_stmt|;
specifier|private
name|int
name|keyLength
decl_stmt|;
specifier|private
name|int
name|recordLength
decl_stmt|;
specifier|private
name|boolean
name|decompress
decl_stmt|;
specifier|private
name|boolean
name|blockCompressed
decl_stmt|;
specifier|private
name|Configuration
name|conf
decl_stmt|;
specifier|private
name|int
name|noBufferedRecords
init|=
literal|0
decl_stmt|;
specifier|private
name|boolean
name|lazyDecompress
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|valuesDecompressed
init|=
literal|true
decl_stmt|;
specifier|private
name|int
name|noBufferedKeys
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|noBufferedValues
init|=
literal|0
decl_stmt|;
specifier|private
name|DataInputBuffer
name|keyLenBuffer
init|=
literal|null
decl_stmt|;
specifier|private
name|CompressionInputStream
name|keyLenInFilter
init|=
literal|null
decl_stmt|;
specifier|private
name|DataInputStream
name|keyLenIn
init|=
literal|null
decl_stmt|;
specifier|private
name|Decompressor
name|keyLenDecompressor
init|=
literal|null
decl_stmt|;
specifier|private
name|DataInputBuffer
name|keyBuffer
init|=
literal|null
decl_stmt|;
specifier|private
name|CompressionInputStream
name|keyInFilter
init|=
literal|null
decl_stmt|;
specifier|private
name|DataInputStream
name|keyIn
init|=
literal|null
decl_stmt|;
specifier|private
name|Decompressor
name|keyDecompressor
init|=
literal|null
decl_stmt|;
specifier|private
name|DataInputBuffer
name|valLenBuffer
init|=
literal|null
decl_stmt|;
specifier|private
name|CompressionInputStream
name|valLenInFilter
init|=
literal|null
decl_stmt|;
specifier|private
name|DataInputStream
name|valLenIn
init|=
literal|null
decl_stmt|;
specifier|private
name|Decompressor
name|valLenDecompressor
init|=
literal|null
decl_stmt|;
specifier|private
name|DataInputBuffer
name|valBuffer
init|=
literal|null
decl_stmt|;
specifier|private
name|CompressionInputStream
name|valInFilter
init|=
literal|null
decl_stmt|;
specifier|private
name|DataInputStream
name|valIn
init|=
literal|null
decl_stmt|;
specifier|private
name|Decompressor
name|valDecompressor
init|=
literal|null
decl_stmt|;
specifier|private
name|Deserializer
name|keyDeserializer
decl_stmt|;
specifier|private
name|Deserializer
name|valDeserializer
decl_stmt|;
comment|/** Open the named file. */
specifier|public
name|Reader
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|file
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|fs
argument_list|,
name|file
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"io.file.buffer.size"
argument_list|,
literal|4096
argument_list|)
argument_list|,
name|conf
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|private
name|Reader
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|file
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|boolean
name|tempReader
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|fs
argument_list|,
name|file
argument_list|,
name|bufferSize
argument_list|,
literal|0
argument_list|,
name|fs
operator|.
name|getLength
argument_list|(
name|file
argument_list|)
argument_list|,
name|conf
argument_list|,
name|tempReader
argument_list|)
expr_stmt|;
block|}
specifier|private
name|Reader
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|file
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|length
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|boolean
name|tempReader
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|file
operator|=
name|file
expr_stmt|;
name|this
operator|.
name|in
operator|=
name|openFile
argument_list|(
name|fs
argument_list|,
name|file
argument_list|,
name|bufferSize
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|seek
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|this
operator|.
name|end
operator|=
name|in
operator|.
name|getPos
argument_list|()
operator|+
name|length
expr_stmt|;
name|init
argument_list|(
name|tempReader
argument_list|)
expr_stmt|;
block|}
comment|/**      * Override this method to specialize the type of      * {@link FSDataInputStream} returned.      */
specifier|protected
name|FSDataInputStream
name|openFile
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|file
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|long
name|length
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|open
argument_list|(
name|file
argument_list|,
name|bufferSize
argument_list|)
return|;
block|}
comment|/**      * Initialize the {@link Reader}      * @param tmpReader<code>true</code> if we are constructing a temporary      *                  reader {@link SequenceFile.Sorter.cloneFileAttributes},       *                  and hence do not initialize every component;       *<code>false</code> otherwise.      * @throws IOException      */
specifier|private
name|void
name|init
parameter_list|(
name|boolean
name|tempReader
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|versionBlock
init|=
operator|new
name|byte
index|[
name|VERSION
operator|.
name|length
index|]
decl_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|versionBlock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|versionBlock
index|[
literal|0
index|]
operator|!=
name|VERSION
index|[
literal|0
index|]
operator|)
operator|||
operator|(
name|versionBlock
index|[
literal|1
index|]
operator|!=
name|VERSION
index|[
literal|1
index|]
operator|)
operator|||
operator|(
name|versionBlock
index|[
literal|2
index|]
operator|!=
name|VERSION
index|[
literal|2
index|]
operator|)
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
name|file
operator|+
literal|" not a SequenceFile"
argument_list|)
throw|;
comment|// Set 'version'
name|version
operator|=
name|versionBlock
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|version
operator|>
name|VERSION
index|[
literal|3
index|]
condition|)
throw|throw
operator|new
name|VersionMismatchException
argument_list|(
name|VERSION
index|[
literal|3
index|]
argument_list|,
name|version
argument_list|)
throw|;
if|if
condition|(
name|version
operator|<
name|BLOCK_COMPRESS_VERSION
condition|)
block|{
name|UTF8
name|className
init|=
operator|new
name|UTF8
argument_list|()
decl_stmt|;
name|className
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|keyClassName
operator|=
name|className
operator|.
name|toString
argument_list|()
expr_stmt|;
comment|// key class name
name|className
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|valClassName
operator|=
name|className
operator|.
name|toString
argument_list|()
expr_stmt|;
comment|// val class name
block|}
else|else
block|{
name|keyClassName
operator|=
name|Text
operator|.
name|readString
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|valClassName
operator|=
name|Text
operator|.
name|readString
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|version
operator|>
literal|2
condition|)
block|{
comment|// if version> 2
name|this
operator|.
name|decompress
operator|=
name|in
operator|.
name|readBoolean
argument_list|()
expr_stmt|;
comment|// is compressed?
block|}
else|else
block|{
name|decompress
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|version
operator|>=
name|BLOCK_COMPRESS_VERSION
condition|)
block|{
comment|// if version>= 4
name|this
operator|.
name|blockCompressed
operator|=
name|in
operator|.
name|readBoolean
argument_list|()
expr_stmt|;
comment|// is block-compressed?
block|}
else|else
block|{
name|blockCompressed
operator|=
literal|false
expr_stmt|;
block|}
comment|// if version>= 5
comment|// setup the compression codec
if|if
condition|(
name|decompress
condition|)
block|{
if|if
condition|(
name|version
operator|>=
name|CUSTOM_COMPRESS_VERSION
condition|)
block|{
name|String
name|codecClassname
init|=
name|Text
operator|.
name|readString
argument_list|(
name|in
argument_list|)
decl_stmt|;
try|try
block|{
name|Class
argument_list|<
name|?
extends|extends
name|CompressionCodec
argument_list|>
name|codecClass
init|=
name|conf
operator|.
name|getClassByName
argument_list|(
name|codecClassname
argument_list|)
operator|.
name|asSubclass
argument_list|(
name|CompressionCodec
operator|.
name|class
argument_list|)
decl_stmt|;
name|this
operator|.
name|codec
operator|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|codecClass
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|cnfe
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown codec: "
operator|+
name|codecClassname
argument_list|,
name|cnfe
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|codec
operator|=
operator|new
name|DefaultCodec
argument_list|()
expr_stmt|;
operator|(
operator|(
name|Configurable
operator|)
name|codec
operator|)
operator|.
name|setConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|metadata
operator|=
operator|new
name|Metadata
argument_list|()
expr_stmt|;
if|if
condition|(
name|version
operator|>=
name|VERSION_WITH_METADATA
condition|)
block|{
comment|// if version>= 6
name|this
operator|.
name|metadata
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|version
operator|>
literal|1
condition|)
block|{
comment|// if version> 1
name|in
operator|.
name|readFully
argument_list|(
name|sync
argument_list|)
expr_stmt|;
comment|// read sync bytes
block|}
comment|// Initialize... *not* if this we are constructing a temporary Reader
if|if
condition|(
operator|!
name|tempReader
condition|)
block|{
name|valBuffer
operator|=
operator|new
name|DataInputBuffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|decompress
condition|)
block|{
name|valDecompressor
operator|=
name|CodecPool
operator|.
name|getDecompressor
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|valInFilter
operator|=
name|codec
operator|.
name|createInputStream
argument_list|(
name|valBuffer
argument_list|,
name|valDecompressor
argument_list|)
expr_stmt|;
name|valIn
operator|=
operator|new
name|DataInputStream
argument_list|(
name|valInFilter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|valIn
operator|=
name|valBuffer
expr_stmt|;
block|}
if|if
condition|(
name|blockCompressed
condition|)
block|{
name|keyLenBuffer
operator|=
operator|new
name|DataInputBuffer
argument_list|()
expr_stmt|;
name|keyBuffer
operator|=
operator|new
name|DataInputBuffer
argument_list|()
expr_stmt|;
name|valLenBuffer
operator|=
operator|new
name|DataInputBuffer
argument_list|()
expr_stmt|;
name|keyLenDecompressor
operator|=
name|CodecPool
operator|.
name|getDecompressor
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|keyLenInFilter
operator|=
name|codec
operator|.
name|createInputStream
argument_list|(
name|keyLenBuffer
argument_list|,
name|keyLenDecompressor
argument_list|)
expr_stmt|;
name|keyLenIn
operator|=
operator|new
name|DataInputStream
argument_list|(
name|keyLenInFilter
argument_list|)
expr_stmt|;
name|keyDecompressor
operator|=
name|CodecPool
operator|.
name|getDecompressor
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|keyInFilter
operator|=
name|codec
operator|.
name|createInputStream
argument_list|(
name|keyBuffer
argument_list|,
name|keyDecompressor
argument_list|)
expr_stmt|;
name|keyIn
operator|=
operator|new
name|DataInputStream
argument_list|(
name|keyInFilter
argument_list|)
expr_stmt|;
name|valLenDecompressor
operator|=
name|CodecPool
operator|.
name|getDecompressor
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|valLenInFilter
operator|=
name|codec
operator|.
name|createInputStream
argument_list|(
name|valLenBuffer
argument_list|,
name|valLenDecompressor
argument_list|)
expr_stmt|;
name|valLenIn
operator|=
operator|new
name|DataInputStream
argument_list|(
name|valLenInFilter
argument_list|)
expr_stmt|;
block|}
name|SerializationFactory
name|serializationFactory
init|=
operator|new
name|SerializationFactory
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|this
operator|.
name|keyDeserializer
operator|=
name|getDeserializer
argument_list|(
name|serializationFactory
argument_list|,
name|getKeyClass
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blockCompressed
condition|)
block|{
name|this
operator|.
name|keyDeserializer
operator|.
name|open
argument_list|(
name|valBuffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|keyDeserializer
operator|.
name|open
argument_list|(
name|keyIn
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|valDeserializer
operator|=
name|getDeserializer
argument_list|(
name|serializationFactory
argument_list|,
name|getValueClass
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|valDeserializer
operator|.
name|open
argument_list|(
name|valIn
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
name|Deserializer
name|getDeserializer
parameter_list|(
name|SerializationFactory
name|sf
parameter_list|,
name|Class
name|c
parameter_list|)
block|{
return|return
name|sf
operator|.
name|getDeserializer
argument_list|(
name|c
argument_list|)
return|;
block|}
comment|/** Close the file. */
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Return the decompressors to the pool
name|CodecPool
operator|.
name|returnDecompressor
argument_list|(
name|keyLenDecompressor
argument_list|)
expr_stmt|;
name|CodecPool
operator|.
name|returnDecompressor
argument_list|(
name|keyDecompressor
argument_list|)
expr_stmt|;
name|CodecPool
operator|.
name|returnDecompressor
argument_list|(
name|valLenDecompressor
argument_list|)
expr_stmt|;
name|CodecPool
operator|.
name|returnDecompressor
argument_list|(
name|valDecompressor
argument_list|)
expr_stmt|;
name|keyLenDecompressor
operator|=
name|keyDecompressor
operator|=
literal|null
expr_stmt|;
name|valLenDecompressor
operator|=
name|valDecompressor
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|keyDeserializer
operator|!=
literal|null
condition|)
block|{
name|keyDeserializer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|valDeserializer
operator|!=
literal|null
condition|)
block|{
name|valDeserializer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Close the input-stream
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** Returns the name of the key class. */
specifier|public
name|String
name|getKeyClassName
parameter_list|()
block|{
return|return
name|keyClassName
return|;
block|}
comment|/** Returns the class of keys in this file. */
specifier|public
specifier|synchronized
name|Class
argument_list|<
name|?
argument_list|>
name|getKeyClass
parameter_list|()
block|{
if|if
condition|(
literal|null
operator|==
name|keyClass
condition|)
block|{
try|try
block|{
name|keyClass
operator|=
name|WritableName
operator|.
name|getClass
argument_list|(
name|getKeyClassName
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|keyClass
return|;
block|}
comment|/** Returns the name of the value class. */
specifier|public
name|String
name|getValueClassName
parameter_list|()
block|{
return|return
name|valClassName
return|;
block|}
comment|/** Returns the class of values in this file. */
specifier|public
specifier|synchronized
name|Class
argument_list|<
name|?
argument_list|>
name|getValueClass
parameter_list|()
block|{
if|if
condition|(
literal|null
operator|==
name|valClass
condition|)
block|{
try|try
block|{
name|valClass
operator|=
name|WritableName
operator|.
name|getClass
argument_list|(
name|getValueClassName
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|valClass
return|;
block|}
comment|/** Returns true if values are compressed. */
specifier|public
name|boolean
name|isCompressed
parameter_list|()
block|{
return|return
name|decompress
return|;
block|}
comment|/** Returns true if records are block-compressed. */
specifier|public
name|boolean
name|isBlockCompressed
parameter_list|()
block|{
return|return
name|blockCompressed
return|;
block|}
comment|/** Returns the compression codec of data in this file. */
specifier|public
name|CompressionCodec
name|getCompressionCodec
parameter_list|()
block|{
return|return
name|codec
return|;
block|}
comment|/** Returns the metadata object of the file */
specifier|public
name|Metadata
name|getMetadata
parameter_list|()
block|{
return|return
name|this
operator|.
name|metadata
return|;
block|}
comment|/** Returns the configuration used for this file. */
name|Configuration
name|getConf
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
comment|/** Read a compressed buffer */
specifier|private
specifier|synchronized
name|void
name|readBuffer
parameter_list|(
name|DataInputBuffer
name|buffer
parameter_list|,
name|CompressionInputStream
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Read data into a temporary buffer
name|DataOutputBuffer
name|dataBuffer
init|=
operator|new
name|DataOutputBuffer
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|dataBufferLength
init|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|dataBuffer
operator|.
name|write
argument_list|(
name|in
argument_list|,
name|dataBufferLength
argument_list|)
expr_stmt|;
comment|// Set up 'buffer' connected to the input-stream
name|buffer
operator|.
name|reset
argument_list|(
name|dataBuffer
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|dataBuffer
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|dataBuffer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Reset the codec
name|filter
operator|.
name|resetState
argument_list|()
expr_stmt|;
block|}
comment|/** Read the next 'compressed' block */
specifier|private
specifier|synchronized
name|void
name|readBlock
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Check if we need to throw away a whole block of
comment|// 'values' due to 'lazy decompression'
if|if
condition|(
name|lazyDecompress
operator|&&
operator|!
name|valuesDecompressed
condition|)
block|{
name|in
operator|.
name|seek
argument_list|(
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|in
argument_list|)
operator|+
name|in
operator|.
name|getPos
argument_list|()
argument_list|)
expr_stmt|;
name|in
operator|.
name|seek
argument_list|(
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|in
argument_list|)
operator|+
name|in
operator|.
name|getPos
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Reset internal states
name|noBufferedKeys
operator|=
literal|0
expr_stmt|;
name|noBufferedValues
operator|=
literal|0
expr_stmt|;
name|noBufferedRecords
operator|=
literal|0
expr_stmt|;
name|valuesDecompressed
operator|=
literal|false
expr_stmt|;
comment|//Process sync
if|if
condition|(
name|sync
operator|!=
literal|null
condition|)
block|{
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|syncCheck
argument_list|)
expr_stmt|;
comment|// read syncCheck
if|if
condition|(
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|sync
argument_list|,
name|syncCheck
argument_list|)
condition|)
comment|// check it
throw|throw
operator|new
name|IOException
argument_list|(
literal|"File is corrupt!"
argument_list|)
throw|;
block|}
name|syncSeen
operator|=
literal|true
expr_stmt|;
comment|// Read number of records in this block
name|noBufferedRecords
operator|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|in
argument_list|)
expr_stmt|;
comment|// Read key lengths and keys
name|readBuffer
argument_list|(
name|keyLenBuffer
argument_list|,
name|keyLenInFilter
argument_list|)
expr_stmt|;
name|readBuffer
argument_list|(
name|keyBuffer
argument_list|,
name|keyInFilter
argument_list|)
expr_stmt|;
name|noBufferedKeys
operator|=
name|noBufferedRecords
expr_stmt|;
comment|// Read value lengths and values
if|if
condition|(
operator|!
name|lazyDecompress
condition|)
block|{
name|readBuffer
argument_list|(
name|valLenBuffer
argument_list|,
name|valLenInFilter
argument_list|)
expr_stmt|;
name|readBuffer
argument_list|(
name|valBuffer
argument_list|,
name|valInFilter
argument_list|)
expr_stmt|;
name|noBufferedValues
operator|=
name|noBufferedRecords
expr_stmt|;
name|valuesDecompressed
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/**       * Position valLenIn/valIn to the 'value'       * corresponding to the 'current' key       */
specifier|private
specifier|synchronized
name|void
name|seekToCurrentValue
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|blockCompressed
condition|)
block|{
if|if
condition|(
name|decompress
condition|)
block|{
name|valInFilter
operator|.
name|resetState
argument_list|()
expr_stmt|;
block|}
name|valBuffer
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Check if this is the first value in the 'block' to be read
if|if
condition|(
name|lazyDecompress
operator|&&
operator|!
name|valuesDecompressed
condition|)
block|{
comment|// Read the value lengths and values
name|readBuffer
argument_list|(
name|valLenBuffer
argument_list|,
name|valLenInFilter
argument_list|)
expr_stmt|;
name|readBuffer
argument_list|(
name|valBuffer
argument_list|,
name|valInFilter
argument_list|)
expr_stmt|;
name|noBufferedValues
operator|=
name|noBufferedRecords
expr_stmt|;
name|valuesDecompressed
operator|=
literal|true
expr_stmt|;
block|}
comment|// Calculate the no. of bytes to skip
comment|// Note: 'current' key has already been read!
name|int
name|skipValBytes
init|=
literal|0
decl_stmt|;
name|int
name|currentKey
init|=
name|noBufferedKeys
operator|+
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|noBufferedValues
init|;
name|i
operator|>
name|currentKey
condition|;
operator|--
name|i
control|)
block|{
name|skipValBytes
operator|+=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|valLenIn
argument_list|)
expr_stmt|;
operator|--
name|noBufferedValues
expr_stmt|;
block|}
comment|// Skip to the 'val' corresponding to 'current' key
if|if
condition|(
name|skipValBytes
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|valIn
operator|.
name|skipBytes
argument_list|(
name|skipValBytes
argument_list|)
operator|!=
name|skipValBytes
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to seek to "
operator|+
name|currentKey
operator|+
literal|"(th) value!"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/**      * Get the 'value' corresponding to the last read 'key'.      * @param val : The 'value' to be read.      * @throws IOException      */
specifier|public
specifier|synchronized
name|void
name|getCurrentValue
parameter_list|(
name|Writable
name|val
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|val
operator|instanceof
name|Configurable
condition|)
block|{
operator|(
operator|(
name|Configurable
operator|)
name|val
operator|)
operator|.
name|setConf
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
block|}
comment|// Position stream to 'current' value
name|seekToCurrentValue
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|blockCompressed
condition|)
block|{
name|val
operator|.
name|readFields
argument_list|(
name|valIn
argument_list|)
expr_stmt|;
if|if
condition|(
name|valIn
operator|.
name|read
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"available bytes: "
operator|+
name|valIn
operator|.
name|available
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|val
operator|+
literal|" read "
operator|+
operator|(
name|valBuffer
operator|.
name|getPosition
argument_list|()
operator|-
name|keyLength
operator|)
operator|+
literal|" bytes, should read "
operator|+
operator|(
name|valBuffer
operator|.
name|getLength
argument_list|()
operator|-
name|keyLength
operator|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// Get the value
name|int
name|valLength
init|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|valLenIn
argument_list|)
decl_stmt|;
name|val
operator|.
name|readFields
argument_list|(
name|valIn
argument_list|)
expr_stmt|;
comment|// Read another compressed 'value'
operator|--
name|noBufferedValues
expr_stmt|;
comment|// Sanity check
if|if
condition|(
name|valLength
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|val
operator|+
literal|" is a zero-length value"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Get the 'value' corresponding to the last read 'key'.      * @param val : The 'value' to be read.      * @throws IOException      */
specifier|public
specifier|synchronized
name|Object
name|getCurrentValue
parameter_list|(
name|Object
name|val
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|val
operator|instanceof
name|Configurable
condition|)
block|{
operator|(
operator|(
name|Configurable
operator|)
name|val
operator|)
operator|.
name|setConf
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
block|}
comment|// Position stream to 'current' value
name|seekToCurrentValue
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|blockCompressed
condition|)
block|{
name|val
operator|=
name|deserializeValue
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|valIn
operator|.
name|read
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"available bytes: "
operator|+
name|valIn
operator|.
name|available
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|val
operator|+
literal|" read "
operator|+
operator|(
name|valBuffer
operator|.
name|getPosition
argument_list|()
operator|-
name|keyLength
operator|)
operator|+
literal|" bytes, should read "
operator|+
operator|(
name|valBuffer
operator|.
name|getLength
argument_list|()
operator|-
name|keyLength
operator|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// Get the value
name|int
name|valLength
init|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|valLenIn
argument_list|)
decl_stmt|;
name|val
operator|=
name|deserializeValue
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|// Read another compressed 'value'
operator|--
name|noBufferedValues
expr_stmt|;
comment|// Sanity check
if|if
condition|(
name|valLength
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|val
operator|+
literal|" is a zero-length value"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|val
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
name|Object
name|deserializeValue
parameter_list|(
name|Object
name|val
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|valDeserializer
operator|.
name|deserialize
argument_list|(
name|val
argument_list|)
return|;
block|}
comment|/** Read the next key in the file into<code>key</code>, skipping its      * value.  True if another entry exists, and false at end of file. */
specifier|public
specifier|synchronized
name|boolean
name|next
parameter_list|(
name|Writable
name|key
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|key
operator|.
name|getClass
argument_list|()
operator|!=
name|getKeyClass
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"wrong key class: "
operator|+
name|key
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" is not "
operator|+
name|keyClass
argument_list|)
throw|;
if|if
condition|(
operator|!
name|blockCompressed
condition|)
block|{
name|outBuf
operator|.
name|reset
argument_list|()
expr_stmt|;
name|keyLength
operator|=
name|next
argument_list|(
name|outBuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyLength
operator|<
literal|0
condition|)
return|return
literal|false
return|;
name|valBuffer
operator|.
name|reset
argument_list|(
name|outBuf
operator|.
name|getData
argument_list|()
argument_list|,
name|outBuf
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|key
operator|.
name|readFields
argument_list|(
name|valBuffer
argument_list|)
expr_stmt|;
name|valBuffer
operator|.
name|mark
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|valBuffer
operator|.
name|getPosition
argument_list|()
operator|!=
name|keyLength
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
name|key
operator|+
literal|" read "
operator|+
name|valBuffer
operator|.
name|getPosition
argument_list|()
operator|+
literal|" bytes, should read "
operator|+
name|keyLength
argument_list|)
throw|;
block|}
else|else
block|{
comment|//Reset syncSeen
name|syncSeen
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|noBufferedKeys
operator|==
literal|0
condition|)
block|{
try|try
block|{
name|readBlock
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|eof
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
name|int
name|keyLength
init|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|keyLenIn
argument_list|)
decl_stmt|;
comment|// Sanity check
if|if
condition|(
name|keyLength
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|//Read another compressed 'key'
name|key
operator|.
name|readFields
argument_list|(
name|keyIn
argument_list|)
expr_stmt|;
operator|--
name|noBufferedKeys
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/** Read the next key/value pair in the file into<code>key</code> and      *<code>val</code>.  Returns true if such a pair exists and false when at      * end of file */
specifier|public
specifier|synchronized
name|boolean
name|next
parameter_list|(
name|Writable
name|key
parameter_list|,
name|Writable
name|val
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|val
operator|.
name|getClass
argument_list|()
operator|!=
name|getValueClass
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"wrong value class: "
operator|+
name|val
operator|+
literal|" is not "
operator|+
name|valClass
argument_list|)
throw|;
name|boolean
name|more
init|=
name|next
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|more
condition|)
block|{
name|getCurrentValue
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
return|return
name|more
return|;
block|}
comment|/**      * Read and return the next record length, potentially skipping over       * a sync block.      * @return the length of the next record or -1 if there is no next record      * @throws IOException      */
specifier|private
specifier|synchronized
name|int
name|readRecordLength
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|in
operator|.
name|getPos
argument_list|()
operator|>=
name|end
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|int
name|length
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|version
operator|>
literal|1
operator|&&
name|sync
operator|!=
literal|null
operator|&&
name|length
operator|==
name|SYNC_ESCAPE
condition|)
block|{
comment|// process a sync entry
name|in
operator|.
name|readFully
argument_list|(
name|syncCheck
argument_list|)
expr_stmt|;
comment|// read syncCheck
if|if
condition|(
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|sync
argument_list|,
name|syncCheck
argument_list|)
condition|)
comment|// check it
throw|throw
operator|new
name|IOException
argument_list|(
literal|"File is corrupt!"
argument_list|)
throw|;
name|syncSeen
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|in
operator|.
name|getPos
argument_list|()
operator|>=
name|end
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|length
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
comment|// re-read length
block|}
else|else
block|{
name|syncSeen
operator|=
literal|false
expr_stmt|;
block|}
return|return
name|length
return|;
block|}
comment|/** Read the next key/value pair in the file into<code>buffer</code>.      * Returns the length of the key read, or -1 if at end of file.  The length      * of the value may be computed by calling buffer.getLength() before and      * after calls to this method. */
comment|/** @deprecated Call {@link #nextRaw(DataOutputBuffer,SequenceFile.ValueBytes)}. */
specifier|public
specifier|synchronized
name|int
name|next
parameter_list|(
name|DataOutputBuffer
name|buffer
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Unsupported for block-compressed sequence files
if|if
condition|(
name|blockCompressed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unsupported call for block-compressed"
operator|+
literal|" SequenceFiles - use SequenceFile.Reader.next(DataOutputStream, ValueBytes)"
argument_list|)
throw|;
block|}
try|try
block|{
name|int
name|length
init|=
name|readRecordLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|length
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|int
name|keyLength
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|buffer
operator|.
name|write
argument_list|(
name|in
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|keyLength
return|;
block|}
catch|catch
parameter_list|(
name|ChecksumException
name|e
parameter_list|)
block|{
comment|// checksum failure
name|handleChecksumException
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|next
argument_list|(
name|buffer
argument_list|)
return|;
block|}
block|}
specifier|public
name|ValueBytes
name|createValueBytes
parameter_list|()
block|{
name|ValueBytes
name|val
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|decompress
operator|||
name|blockCompressed
condition|)
block|{
name|val
operator|=
operator|new
name|UncompressedBytes
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
operator|new
name|CompressedBytes
argument_list|(
name|codec
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
comment|/**      * Read 'raw' records.      * @param key - The buffer into which the key is read      * @param val - The 'raw' value      * @return Returns the total record length or -1 for end of file      * @throws IOException      */
specifier|public
specifier|synchronized
name|int
name|nextRaw
parameter_list|(
name|DataOutputBuffer
name|key
parameter_list|,
name|ValueBytes
name|val
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|blockCompressed
condition|)
block|{
name|int
name|length
init|=
name|readRecordLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|length
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|int
name|keyLength
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|int
name|valLength
init|=
name|length
operator|-
name|keyLength
decl_stmt|;
name|key
operator|.
name|write
argument_list|(
name|in
argument_list|,
name|keyLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|decompress
condition|)
block|{
name|CompressedBytes
name|value
init|=
operator|(
name|CompressedBytes
operator|)
name|val
decl_stmt|;
name|value
operator|.
name|reset
argument_list|(
name|in
argument_list|,
name|valLength
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UncompressedBytes
name|value
init|=
operator|(
name|UncompressedBytes
operator|)
name|val
decl_stmt|;
name|value
operator|.
name|reset
argument_list|(
name|in
argument_list|,
name|valLength
argument_list|)
expr_stmt|;
block|}
return|return
name|length
return|;
block|}
else|else
block|{
comment|//Reset syncSeen
name|syncSeen
operator|=
literal|false
expr_stmt|;
comment|// Read 'key'
if|if
condition|(
name|noBufferedKeys
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|in
operator|.
name|getPos
argument_list|()
operator|>=
name|end
condition|)
return|return
operator|-
literal|1
return|;
try|try
block|{
name|readBlock
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|eof
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
name|int
name|keyLength
init|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|keyLenIn
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyLength
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"zero length key found!"
argument_list|)
throw|;
block|}
name|key
operator|.
name|write
argument_list|(
name|keyIn
argument_list|,
name|keyLength
argument_list|)
expr_stmt|;
operator|--
name|noBufferedKeys
expr_stmt|;
comment|// Read raw 'value'
name|seekToCurrentValue
argument_list|()
expr_stmt|;
name|int
name|valLength
init|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|valLenIn
argument_list|)
decl_stmt|;
name|UncompressedBytes
name|rawValue
init|=
operator|(
name|UncompressedBytes
operator|)
name|val
decl_stmt|;
name|rawValue
operator|.
name|reset
argument_list|(
name|valIn
argument_list|,
name|valLength
argument_list|)
expr_stmt|;
operator|--
name|noBufferedValues
expr_stmt|;
return|return
operator|(
name|keyLength
operator|+
name|valLength
operator|)
return|;
block|}
block|}
comment|/**      * Read 'raw' keys.      * @param key - The buffer into which the key is read      * @return Returns the key length or -1 for end of file      * @throws IOException      */
specifier|public
name|int
name|nextRawKey
parameter_list|(
name|DataOutputBuffer
name|key
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|blockCompressed
condition|)
block|{
name|recordLength
operator|=
name|readRecordLength
argument_list|()
expr_stmt|;
if|if
condition|(
name|recordLength
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|keyLength
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|key
operator|.
name|write
argument_list|(
name|in
argument_list|,
name|keyLength
argument_list|)
expr_stmt|;
return|return
name|keyLength
return|;
block|}
else|else
block|{
comment|//Reset syncSeen
name|syncSeen
operator|=
literal|false
expr_stmt|;
comment|// Read 'key'
if|if
condition|(
name|noBufferedKeys
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|in
operator|.
name|getPos
argument_list|()
operator|>=
name|end
condition|)
return|return
operator|-
literal|1
return|;
try|try
block|{
name|readBlock
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|eof
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
name|int
name|keyLength
init|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|keyLenIn
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyLength
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"zero length key found!"
argument_list|)
throw|;
block|}
name|key
operator|.
name|write
argument_list|(
name|keyIn
argument_list|,
name|keyLength
argument_list|)
expr_stmt|;
operator|--
name|noBufferedKeys
expr_stmt|;
return|return
name|keyLength
return|;
block|}
block|}
comment|/** Read the next key in the file, skipping its      * value.  Return null at end of file. */
specifier|public
specifier|synchronized
name|Object
name|next
parameter_list|(
name|Object
name|key
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|key
operator|!=
literal|null
operator|&&
name|key
operator|.
name|getClass
argument_list|()
operator|!=
name|getKeyClass
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"wrong key class: "
operator|+
name|key
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" is not "
operator|+
name|keyClass
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|blockCompressed
condition|)
block|{
name|outBuf
operator|.
name|reset
argument_list|()
expr_stmt|;
name|keyLength
operator|=
name|next
argument_list|(
name|outBuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyLength
operator|<
literal|0
condition|)
return|return
literal|null
return|;
name|valBuffer
operator|.
name|reset
argument_list|(
name|outBuf
operator|.
name|getData
argument_list|()
argument_list|,
name|outBuf
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|key
operator|=
name|deserializeKey
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|valBuffer
operator|.
name|mark
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|valBuffer
operator|.
name|getPosition
argument_list|()
operator|!=
name|keyLength
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
name|key
operator|+
literal|" read "
operator|+
name|valBuffer
operator|.
name|getPosition
argument_list|()
operator|+
literal|" bytes, should read "
operator|+
name|keyLength
argument_list|)
throw|;
block|}
else|else
block|{
comment|//Reset syncSeen
name|syncSeen
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|noBufferedKeys
operator|==
literal|0
condition|)
block|{
try|try
block|{
name|readBlock
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|eof
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
name|int
name|keyLength
init|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|keyLenIn
argument_list|)
decl_stmt|;
comment|// Sanity check
if|if
condition|(
name|keyLength
operator|<
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|//Read another compressed 'key'
name|key
operator|=
name|deserializeKey
argument_list|(
name|key
argument_list|)
expr_stmt|;
operator|--
name|noBufferedKeys
expr_stmt|;
block|}
return|return
name|key
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
name|Object
name|deserializeKey
parameter_list|(
name|Object
name|key
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|keyDeserializer
operator|.
name|deserialize
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|/**      * Read 'raw' values.      * @param val - The 'raw' value      * @return Returns the value length      * @throws IOException      */
specifier|public
specifier|synchronized
name|int
name|nextRawValue
parameter_list|(
name|ValueBytes
name|val
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Position stream to current value
name|seekToCurrentValue
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|blockCompressed
condition|)
block|{
name|int
name|valLength
init|=
name|recordLength
operator|-
name|keyLength
decl_stmt|;
if|if
condition|(
name|decompress
condition|)
block|{
name|CompressedBytes
name|value
init|=
operator|(
name|CompressedBytes
operator|)
name|val
decl_stmt|;
name|value
operator|.
name|reset
argument_list|(
name|in
argument_list|,
name|valLength
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UncompressedBytes
name|value
init|=
operator|(
name|UncompressedBytes
operator|)
name|val
decl_stmt|;
name|value
operator|.
name|reset
argument_list|(
name|in
argument_list|,
name|valLength
argument_list|)
expr_stmt|;
block|}
return|return
name|valLength
return|;
block|}
else|else
block|{
name|int
name|valLength
init|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|valLenIn
argument_list|)
decl_stmt|;
name|UncompressedBytes
name|rawValue
init|=
operator|(
name|UncompressedBytes
operator|)
name|val
decl_stmt|;
name|rawValue
operator|.
name|reset
argument_list|(
name|valIn
argument_list|,
name|valLength
argument_list|)
expr_stmt|;
operator|--
name|noBufferedValues
expr_stmt|;
return|return
name|valLength
return|;
block|}
block|}
specifier|private
name|void
name|handleChecksumException
parameter_list|(
name|ChecksumException
name|e
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"io.skip.checksum.errors"
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Bad checksum at "
operator|+
name|getPosition
argument_list|()
operator|+
literal|". Skipping entries."
argument_list|)
expr_stmt|;
name|sync
argument_list|(
name|getPosition
argument_list|()
operator|+
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"io.bytes.per.checksum"
argument_list|,
literal|512
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
comment|/** Set the current byte position in the input file.      *      *<p>The position passed must be a position returned by {@link      * SequenceFile.Writer#getLength()} when writing this file.  To seek to an arbitrary      * position, use {@link SequenceFile.Reader#sync(long)}.      */
specifier|public
specifier|synchronized
name|void
name|seek
parameter_list|(
name|long
name|position
parameter_list|)
throws|throws
name|IOException
block|{
name|in
operator|.
name|seek
argument_list|(
name|position
argument_list|)
expr_stmt|;
if|if
condition|(
name|blockCompressed
condition|)
block|{
comment|// trigger block read
name|noBufferedKeys
operator|=
literal|0
expr_stmt|;
name|valuesDecompressed
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/** Seek to the next sync mark past a given position.*/
specifier|public
specifier|synchronized
name|void
name|sync
parameter_list|(
name|long
name|position
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|position
operator|+
name|SYNC_SIZE
operator|>=
name|end
condition|)
block|{
name|seek
argument_list|(
name|end
argument_list|)
expr_stmt|;
return|return;
block|}
try|try
block|{
name|seek
argument_list|(
name|position
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|// skip escape
name|in
operator|.
name|readFully
argument_list|(
name|syncCheck
argument_list|)
expr_stmt|;
name|int
name|syncLen
init|=
name|sync
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|in
operator|.
name|getPos
argument_list|()
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|j
operator|<
name|syncLen
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|sync
index|[
name|j
index|]
operator|!=
name|syncCheck
index|[
operator|(
name|i
operator|+
name|j
operator|)
operator|%
name|syncLen
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|syncLen
condition|)
block|{
name|in
operator|.
name|seek
argument_list|(
name|in
operator|.
name|getPos
argument_list|()
operator|-
name|SYNC_SIZE
argument_list|)
expr_stmt|;
comment|// position before sync
return|return;
block|}
name|syncCheck
index|[
name|i
operator|%
name|syncLen
index|]
operator|=
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ChecksumException
name|e
parameter_list|)
block|{
comment|// checksum failure
name|handleChecksumException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Returns true iff the previous call to next passed a sync mark.*/
specifier|public
name|boolean
name|syncSeen
parameter_list|()
block|{
return|return
name|syncSeen
return|;
block|}
comment|/** Return the current byte position in the input file. */
specifier|public
specifier|synchronized
name|long
name|getPosition
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|in
operator|.
name|getPos
argument_list|()
return|;
block|}
comment|/** Returns the name of the file. */
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|file
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/** Sorts key/value pairs in a sequence-format file.    *    *<p>For best performance, applications should make sure that the {@link    * Writable#readFields(DataInput)} implementation of their keys is    * very efficient.  In particular, it should avoid allocating memory.    */
specifier|public
specifier|static
class|class
name|Sorter
block|{
specifier|private
name|RawComparator
name|comparator
decl_stmt|;
specifier|private
name|MergeSort
name|mergeSort
decl_stmt|;
comment|//the implementation of merge sort
specifier|private
name|Path
index|[]
name|inFiles
decl_stmt|;
comment|// when merging or sorting
specifier|private
name|Path
name|outFile
decl_stmt|;
specifier|private
name|int
name|memory
decl_stmt|;
comment|// bytes
specifier|private
name|int
name|factor
decl_stmt|;
comment|// merged per pass
specifier|private
name|FileSystem
name|fs
init|=
literal|null
decl_stmt|;
specifier|private
name|Class
name|keyClass
decl_stmt|;
specifier|private
name|Class
name|valClass
decl_stmt|;
specifier|private
name|Configuration
name|conf
decl_stmt|;
specifier|private
name|Progressable
name|progressable
init|=
literal|null
decl_stmt|;
comment|/** Sort and merge files containing the named classes. */
specifier|public
name|Sorter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|WritableComparable
argument_list|>
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
argument_list|(
name|fs
argument_list|,
name|WritableComparator
operator|.
name|get
argument_list|(
name|keyClass
argument_list|)
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/** Sort and merge using an arbitrary {@link RawComparator}. */
specifier|public
name|Sorter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|RawComparator
name|comparator
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|this
operator|.
name|comparator
operator|=
name|comparator
expr_stmt|;
name|this
operator|.
name|keyClass
operator|=
name|keyClass
expr_stmt|;
name|this
operator|.
name|valClass
operator|=
name|valClass
expr_stmt|;
name|this
operator|.
name|memory
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"io.sort.mb"
argument_list|,
literal|100
argument_list|)
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
name|this
operator|.
name|factor
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"io.sort.factor"
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
block|}
comment|/** Set the number of streams to merge at once.*/
specifier|public
name|void
name|setFactor
parameter_list|(
name|int
name|factor
parameter_list|)
block|{
name|this
operator|.
name|factor
operator|=
name|factor
expr_stmt|;
block|}
comment|/** Get the number of streams to merge at once.*/
specifier|public
name|int
name|getFactor
parameter_list|()
block|{
return|return
name|factor
return|;
block|}
comment|/** Set the total amount of buffer memory, in bytes.*/
specifier|public
name|void
name|setMemory
parameter_list|(
name|int
name|memory
parameter_list|)
block|{
name|this
operator|.
name|memory
operator|=
name|memory
expr_stmt|;
block|}
comment|/** Get the total amount of buffer memory, in bytes.*/
specifier|public
name|int
name|getMemory
parameter_list|()
block|{
return|return
name|memory
return|;
block|}
comment|/** Set the progressable object in order to report progress. */
specifier|public
name|void
name|setProgressable
parameter_list|(
name|Progressable
name|progressable
parameter_list|)
block|{
name|this
operator|.
name|progressable
operator|=
name|progressable
expr_stmt|;
block|}
comment|/**       * Perform a file sort from a set of input files into an output file.      * @param inFiles the files to be sorted      * @param outFile the sorted output file      * @param deleteInput should the input files be deleted as they are read?      */
specifier|public
name|void
name|sort
parameter_list|(
name|Path
index|[]
name|inFiles
parameter_list|,
name|Path
name|outFile
parameter_list|,
name|boolean
name|deleteInput
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|outFile
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"already exists: "
operator|+
name|outFile
argument_list|)
throw|;
block|}
name|this
operator|.
name|inFiles
operator|=
name|inFiles
expr_stmt|;
name|this
operator|.
name|outFile
operator|=
name|outFile
expr_stmt|;
name|int
name|segments
init|=
name|sortPass
argument_list|(
name|deleteInput
argument_list|)
decl_stmt|;
if|if
condition|(
name|segments
operator|>
literal|1
condition|)
block|{
name|mergePass
argument_list|(
name|outFile
operator|.
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**       * Perform a file sort from a set of input files and return an iterator.      * @param inFiles the files to be sorted      * @param tempDir the directory where temp files are created during sort      * @param deleteInput should the input files be deleted as they are read?      * @return iterator the RawKeyValueIterator      */
specifier|public
name|RawKeyValueIterator
name|sortAndIterate
parameter_list|(
name|Path
index|[]
name|inFiles
parameter_list|,
name|Path
name|tempDir
parameter_list|,
name|boolean
name|deleteInput
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|outFile
init|=
operator|new
name|Path
argument_list|(
name|tempDir
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
literal|"all.2"
argument_list|)
decl_stmt|;
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|outFile
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"already exists: "
operator|+
name|outFile
argument_list|)
throw|;
block|}
name|this
operator|.
name|inFiles
operator|=
name|inFiles
expr_stmt|;
comment|//outFile will basically be used as prefix for temp files in the cases
comment|//where sort outputs multiple sorted segments. For the single segment
comment|//case, the outputFile itself will contain the sorted data for that
comment|//segment
name|this
operator|.
name|outFile
operator|=
name|outFile
expr_stmt|;
name|int
name|segments
init|=
name|sortPass
argument_list|(
name|deleteInput
argument_list|)
decl_stmt|;
if|if
condition|(
name|segments
operator|>
literal|1
condition|)
return|return
name|merge
argument_list|(
name|outFile
operator|.
name|suffix
argument_list|(
literal|".0"
argument_list|)
argument_list|,
name|outFile
operator|.
name|suffix
argument_list|(
literal|".0.index"
argument_list|)
argument_list|,
name|tempDir
argument_list|)
return|;
elseif|else
if|if
condition|(
name|segments
operator|==
literal|1
condition|)
return|return
name|merge
argument_list|(
operator|new
name|Path
index|[]
block|{
name|outFile
block|}
argument_list|,
literal|true
argument_list|,
name|tempDir
argument_list|)
return|;
else|else
return|return
literal|null
return|;
block|}
comment|/**      * The backwards compatible interface to sort.      * @param inFile the input file to sort      * @param outFile the sorted output file      */
specifier|public
name|void
name|sort
parameter_list|(
name|Path
name|inFile
parameter_list|,
name|Path
name|outFile
parameter_list|)
throws|throws
name|IOException
block|{
name|sort
argument_list|(
operator|new
name|Path
index|[]
block|{
name|inFile
block|}
argument_list|,
name|outFile
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|private
name|int
name|sortPass
parameter_list|(
name|boolean
name|deleteInput
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"running sort pass"
argument_list|)
expr_stmt|;
name|SortPass
name|sortPass
init|=
operator|new
name|SortPass
argument_list|()
decl_stmt|;
comment|// make the SortPass
name|sortPass
operator|.
name|setProgressable
argument_list|(
name|progressable
argument_list|)
expr_stmt|;
name|mergeSort
operator|=
operator|new
name|MergeSort
argument_list|(
name|sortPass
operator|.
expr|new
name|SeqFileComparator
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|sortPass
operator|.
name|run
argument_list|(
name|deleteInput
argument_list|)
return|;
comment|// run it
block|}
finally|finally
block|{
name|sortPass
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// close it
block|}
block|}
specifier|private
class|class
name|SortPass
block|{
specifier|private
name|int
name|memoryLimit
init|=
name|memory
operator|/
literal|4
decl_stmt|;
specifier|private
name|int
name|recordLimit
init|=
literal|1000000
decl_stmt|;
specifier|private
name|DataOutputBuffer
name|rawKeys
init|=
operator|new
name|DataOutputBuffer
argument_list|()
decl_stmt|;
specifier|private
name|byte
index|[]
name|rawBuffer
decl_stmt|;
specifier|private
name|int
index|[]
name|keyOffsets
init|=
operator|new
name|int
index|[
literal|1024
index|]
decl_stmt|;
specifier|private
name|int
index|[]
name|pointers
init|=
operator|new
name|int
index|[
name|keyOffsets
operator|.
name|length
index|]
decl_stmt|;
specifier|private
name|int
index|[]
name|pointersCopy
init|=
operator|new
name|int
index|[
name|keyOffsets
operator|.
name|length
index|]
decl_stmt|;
specifier|private
name|int
index|[]
name|keyLengths
init|=
operator|new
name|int
index|[
name|keyOffsets
operator|.
name|length
index|]
decl_stmt|;
specifier|private
name|ValueBytes
index|[]
name|rawValues
init|=
operator|new
name|ValueBytes
index|[
name|keyOffsets
operator|.
name|length
index|]
decl_stmt|;
specifier|private
name|ArrayList
name|segmentLengths
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
specifier|private
name|Reader
name|in
init|=
literal|null
decl_stmt|;
specifier|private
name|FSDataOutputStream
name|out
init|=
literal|null
decl_stmt|;
specifier|private
name|FSDataOutputStream
name|indexOut
init|=
literal|null
decl_stmt|;
specifier|private
name|Path
name|outName
decl_stmt|;
specifier|private
name|Progressable
name|progressable
init|=
literal|null
decl_stmt|;
specifier|public
name|int
name|run
parameter_list|(
name|boolean
name|deleteInput
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|segments
init|=
literal|0
decl_stmt|;
name|int
name|currentFile
init|=
literal|0
decl_stmt|;
name|boolean
name|atEof
init|=
operator|(
name|currentFile
operator|>=
name|inFiles
operator|.
name|length
operator|)
decl_stmt|;
name|boolean
name|isCompressed
init|=
literal|false
decl_stmt|;
name|boolean
name|isBlockCompressed
init|=
literal|false
decl_stmt|;
name|CompressionCodec
name|codec
init|=
literal|null
decl_stmt|;
name|segmentLengths
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|atEof
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|// Initialize
name|in
operator|=
operator|new
name|Reader
argument_list|(
name|fs
argument_list|,
name|inFiles
index|[
name|currentFile
index|]
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|isCompressed
operator|=
name|in
operator|.
name|isCompressed
argument_list|()
expr_stmt|;
name|isBlockCompressed
operator|=
name|in
operator|.
name|isBlockCompressed
argument_list|()
expr_stmt|;
name|codec
operator|=
name|in
operator|.
name|getCompressionCodec
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rawValues
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|rawValues
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|atEof
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|bytesProcessed
init|=
literal|0
decl_stmt|;
name|rawKeys
operator|.
name|reset
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|atEof
operator|&&
name|bytesProcessed
operator|<
name|memoryLimit
operator|&&
name|count
operator|<
name|recordLimit
condition|)
block|{
comment|// Read a record into buffer
comment|// Note: Attempt to re-use 'rawValue' as far as possible
name|int
name|keyOffset
init|=
name|rawKeys
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|ValueBytes
name|rawValue
init|=
operator|(
name|count
operator|==
name|keyOffsets
operator|.
name|length
operator|||
name|rawValues
index|[
name|count
index|]
operator|==
literal|null
operator|)
condition|?
name|in
operator|.
name|createValueBytes
argument_list|()
else|:
name|rawValues
index|[
name|count
index|]
decl_stmt|;
name|int
name|recordLength
init|=
name|in
operator|.
name|nextRaw
argument_list|(
name|rawKeys
argument_list|,
name|rawValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|recordLength
operator|==
operator|-
literal|1
condition|)
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|deleteInput
condition|)
block|{
name|fs
operator|.
name|delete
argument_list|(
name|inFiles
index|[
name|currentFile
index|]
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|currentFile
operator|+=
literal|1
expr_stmt|;
name|atEof
operator|=
name|currentFile
operator|>=
name|inFiles
operator|.
name|length
expr_stmt|;
if|if
condition|(
operator|!
name|atEof
condition|)
block|{
name|in
operator|=
operator|new
name|Reader
argument_list|(
name|fs
argument_list|,
name|inFiles
index|[
name|currentFile
index|]
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|in
operator|=
literal|null
expr_stmt|;
block|}
continue|continue;
block|}
name|int
name|keyLength
init|=
name|rawKeys
operator|.
name|getLength
argument_list|()
operator|-
name|keyOffset
decl_stmt|;
if|if
condition|(
name|count
operator|==
name|keyOffsets
operator|.
name|length
condition|)
name|grow
argument_list|()
expr_stmt|;
name|keyOffsets
index|[
name|count
index|]
operator|=
name|keyOffset
expr_stmt|;
comment|// update pointers
name|pointers
index|[
name|count
index|]
operator|=
name|count
expr_stmt|;
name|keyLengths
index|[
name|count
index|]
operator|=
name|keyLength
expr_stmt|;
name|rawValues
index|[
name|count
index|]
operator|=
name|rawValue
expr_stmt|;
name|bytesProcessed
operator|+=
name|recordLength
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
comment|// buffer is full -- sort& flush it
name|LOG
operator|.
name|debug
argument_list|(
literal|"flushing segment "
operator|+
name|segments
argument_list|)
expr_stmt|;
name|rawBuffer
operator|=
name|rawKeys
operator|.
name|getData
argument_list|()
expr_stmt|;
name|sort
argument_list|(
name|count
argument_list|)
expr_stmt|;
comment|// indicate we're making progress
if|if
condition|(
name|progressable
operator|!=
literal|null
condition|)
block|{
name|progressable
operator|.
name|progress
argument_list|()
expr_stmt|;
block|}
name|flush
argument_list|(
name|count
argument_list|,
name|bytesProcessed
argument_list|,
name|isCompressed
argument_list|,
name|isBlockCompressed
argument_list|,
name|codec
argument_list|,
name|segments
operator|==
literal|0
operator|&&
name|atEof
argument_list|)
expr_stmt|;
name|segments
operator|++
expr_stmt|;
block|}
return|return
name|segments
return|;
block|}
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|in
operator|!=
literal|null
condition|)
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|indexOut
operator|!=
literal|null
condition|)
block|{
name|indexOut
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|grow
parameter_list|()
block|{
name|int
name|newLength
init|=
name|keyOffsets
operator|.
name|length
operator|*
literal|3
operator|/
literal|2
decl_stmt|;
name|keyOffsets
operator|=
name|grow
argument_list|(
name|keyOffsets
argument_list|,
name|newLength
argument_list|)
expr_stmt|;
name|pointers
operator|=
name|grow
argument_list|(
name|pointers
argument_list|,
name|newLength
argument_list|)
expr_stmt|;
name|pointersCopy
operator|=
operator|new
name|int
index|[
name|newLength
index|]
expr_stmt|;
name|keyLengths
operator|=
name|grow
argument_list|(
name|keyLengths
argument_list|,
name|newLength
argument_list|)
expr_stmt|;
name|rawValues
operator|=
name|grow
argument_list|(
name|rawValues
argument_list|,
name|newLength
argument_list|)
expr_stmt|;
block|}
specifier|private
name|int
index|[]
name|grow
parameter_list|(
name|int
index|[]
name|old
parameter_list|,
name|int
name|newLength
parameter_list|)
block|{
name|int
index|[]
name|result
init|=
operator|new
name|int
index|[
name|newLength
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|old
argument_list|,
literal|0
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
name|old
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|private
name|ValueBytes
index|[]
name|grow
parameter_list|(
name|ValueBytes
index|[]
name|old
parameter_list|,
name|int
name|newLength
parameter_list|)
block|{
name|ValueBytes
index|[]
name|result
init|=
operator|new
name|ValueBytes
index|[
name|newLength
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|old
argument_list|,
literal|0
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
name|old
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|old
operator|.
name|length
init|;
name|i
operator|<
name|newLength
condition|;
operator|++
name|i
control|)
block|{
name|result
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|private
name|void
name|flush
parameter_list|(
name|int
name|count
parameter_list|,
name|int
name|bytesProcessed
parameter_list|,
name|boolean
name|isCompressed
parameter_list|,
name|boolean
name|isBlockCompressed
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|boolean
name|done
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|out
operator|==
literal|null
condition|)
block|{
name|outName
operator|=
name|done
condition|?
name|outFile
else|:
name|outFile
operator|.
name|suffix
argument_list|(
literal|".0"
argument_list|)
expr_stmt|;
name|out
operator|=
name|fs
operator|.
name|create
argument_list|(
name|outName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|indexOut
operator|=
name|fs
operator|.
name|create
argument_list|(
name|outName
operator|.
name|suffix
argument_list|(
literal|".index"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|segmentStart
init|=
name|out
operator|.
name|getPos
argument_list|()
decl_stmt|;
name|Writer
name|writer
init|=
name|createWriter
argument_list|(
name|conf
argument_list|,
name|out
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|isCompressed
argument_list|,
name|isBlockCompressed
argument_list|,
name|codec
argument_list|,
operator|new
name|Metadata
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|writer
operator|.
name|sync
operator|=
literal|null
expr_stmt|;
comment|// disable sync on temp files
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|// write in sorted order
name|int
name|p
init|=
name|pointers
index|[
name|i
index|]
decl_stmt|;
name|writer
operator|.
name|appendRaw
argument_list|(
name|rawBuffer
argument_list|,
name|keyOffsets
index|[
name|p
index|]
argument_list|,
name|keyLengths
index|[
name|p
index|]
argument_list|,
name|rawValues
index|[
name|p
index|]
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
block|{
comment|// Save the segment length
name|WritableUtils
operator|.
name|writeVLong
argument_list|(
name|indexOut
argument_list|,
name|segmentStart
argument_list|)
expr_stmt|;
name|WritableUtils
operator|.
name|writeVLong
argument_list|(
name|indexOut
argument_list|,
operator|(
name|out
operator|.
name|getPos
argument_list|()
operator|-
name|segmentStart
operator|)
argument_list|)
expr_stmt|;
name|indexOut
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|sort
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|pointers
argument_list|,
literal|0
argument_list|,
name|pointersCopy
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|mergeSort
operator|.
name|mergeSort
argument_list|(
name|pointersCopy
argument_list|,
name|pointers
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
class|class
name|SeqFileComparator
implements|implements
name|Comparator
argument_list|<
name|IntWritable
argument_list|>
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|IntWritable
name|I
parameter_list|,
name|IntWritable
name|J
parameter_list|)
block|{
return|return
name|comparator
operator|.
name|compare
argument_list|(
name|rawBuffer
argument_list|,
name|keyOffsets
index|[
name|I
operator|.
name|get
argument_list|()
index|]
argument_list|,
name|keyLengths
index|[
name|I
operator|.
name|get
argument_list|()
index|]
argument_list|,
name|rawBuffer
argument_list|,
name|keyOffsets
index|[
name|J
operator|.
name|get
argument_list|()
index|]
argument_list|,
name|keyLengths
index|[
name|J
operator|.
name|get
argument_list|()
index|]
argument_list|)
return|;
block|}
block|}
comment|/** set the progressable object in order to report progress */
specifier|public
name|void
name|setProgressable
parameter_list|(
name|Progressable
name|progressable
parameter_list|)
block|{
name|this
operator|.
name|progressable
operator|=
name|progressable
expr_stmt|;
block|}
block|}
comment|// SequenceFile.Sorter.SortPass
comment|/** The interface to iterate over raw keys/values of SequenceFiles. */
specifier|public
specifier|static
interface|interface
name|RawKeyValueIterator
block|{
comment|/** Gets the current raw key        * @return DataOutputBuffer        * @throws IOException        */
name|DataOutputBuffer
name|getKey
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Gets the current raw value        * @return ValueBytes         * @throws IOException        */
name|ValueBytes
name|getValue
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Sets up the current key and value (for getKey and getValue)        * @return true if there exists a key/value, false otherwise         * @throws IOException        */
name|boolean
name|next
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** closes the iterator so that the underlying streams can be closed        * @throws IOException        */
name|void
name|close
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Gets the Progress object; this has a float (0.0 - 1.0)         * indicating the bytes processed by the iterator so far        */
name|Progress
name|getProgress
parameter_list|()
function_decl|;
block|}
comment|/**      * Merges the list of segments of type<code>SegmentDescriptor</code>      * @param segments the list of SegmentDescriptors      * @param tmpDir the directory to write temporary files into      * @return RawKeyValueIterator      * @throws IOException      */
specifier|public
name|RawKeyValueIterator
name|merge
parameter_list|(
name|List
argument_list|<
name|SegmentDescriptor
argument_list|>
name|segments
parameter_list|,
name|Path
name|tmpDir
parameter_list|)
throws|throws
name|IOException
block|{
comment|// pass in object to report progress, if present
name|MergeQueue
name|mQueue
init|=
operator|new
name|MergeQueue
argument_list|(
name|segments
argument_list|,
name|tmpDir
argument_list|,
name|progressable
argument_list|)
decl_stmt|;
return|return
name|mQueue
operator|.
name|merge
argument_list|()
return|;
block|}
comment|/**      * Merges the contents of files passed in Path[] using a max factor value      * that is already set      * @param inNames the array of path names      * @param deleteInputs true if the input files should be deleted when       * unnecessary      * @param tmpDir the directory to write temporary files into      * @return RawKeyValueIteratorMergeQueue      * @throws IOException      */
specifier|public
name|RawKeyValueIterator
name|merge
parameter_list|(
name|Path
index|[]
name|inNames
parameter_list|,
name|boolean
name|deleteInputs
parameter_list|,
name|Path
name|tmpDir
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|merge
argument_list|(
name|inNames
argument_list|,
name|deleteInputs
argument_list|,
operator|(
name|inNames
operator|.
name|length
operator|<
name|factor
operator|)
condition|?
name|inNames
operator|.
name|length
else|:
name|factor
argument_list|,
name|tmpDir
argument_list|)
return|;
block|}
comment|/**      * Merges the contents of files passed in Path[]      * @param inNames the array of path names      * @param deleteInputs true if the input files should be deleted when       * unnecessary      * @param factor the factor that will be used as the maximum merge fan-in      * @param tmpDir the directory to write temporary files into      * @return RawKeyValueIteratorMergeQueue      * @throws IOException      */
specifier|public
name|RawKeyValueIterator
name|merge
parameter_list|(
name|Path
index|[]
name|inNames
parameter_list|,
name|boolean
name|deleteInputs
parameter_list|,
name|int
name|factor
parameter_list|,
name|Path
name|tmpDir
parameter_list|)
throws|throws
name|IOException
block|{
comment|//get the segments from inNames
name|ArrayList
argument_list|<
name|SegmentDescriptor
argument_list|>
name|a
init|=
operator|new
name|ArrayList
argument_list|<
name|SegmentDescriptor
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inNames
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|SegmentDescriptor
name|s
init|=
operator|new
name|SegmentDescriptor
argument_list|(
literal|0
argument_list|,
name|fs
operator|.
name|getLength
argument_list|(
name|inNames
index|[
name|i
index|]
argument_list|)
argument_list|,
name|inNames
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|s
operator|.
name|preserveInput
argument_list|(
operator|!
name|deleteInputs
argument_list|)
expr_stmt|;
name|s
operator|.
name|doSync
argument_list|()
expr_stmt|;
name|a
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|factor
operator|=
name|factor
expr_stmt|;
name|MergeQueue
name|mQueue
init|=
operator|new
name|MergeQueue
argument_list|(
name|a
argument_list|,
name|tmpDir
argument_list|,
name|progressable
argument_list|)
decl_stmt|;
return|return
name|mQueue
operator|.
name|merge
argument_list|()
return|;
block|}
comment|/**      * Merges the contents of files passed in Path[]      * @param inNames the array of path names      * @param tempDir the directory for creating temp files during merge      * @param deleteInputs true if the input files should be deleted when       * unnecessary      * @return RawKeyValueIteratorMergeQueue      * @throws IOException      */
specifier|public
name|RawKeyValueIterator
name|merge
parameter_list|(
name|Path
index|[]
name|inNames
parameter_list|,
name|Path
name|tempDir
parameter_list|,
name|boolean
name|deleteInputs
parameter_list|)
throws|throws
name|IOException
block|{
comment|//outFile will basically be used as prefix for temp files for the
comment|//intermediate merge outputs
name|this
operator|.
name|outFile
operator|=
operator|new
name|Path
argument_list|(
name|tempDir
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
literal|"merged"
argument_list|)
expr_stmt|;
comment|//get the segments from inNames
name|ArrayList
argument_list|<
name|SegmentDescriptor
argument_list|>
name|a
init|=
operator|new
name|ArrayList
argument_list|<
name|SegmentDescriptor
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inNames
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|SegmentDescriptor
name|s
init|=
operator|new
name|SegmentDescriptor
argument_list|(
literal|0
argument_list|,
name|fs
operator|.
name|getLength
argument_list|(
name|inNames
index|[
name|i
index|]
argument_list|)
argument_list|,
name|inNames
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|s
operator|.
name|preserveInput
argument_list|(
operator|!
name|deleteInputs
argument_list|)
expr_stmt|;
name|s
operator|.
name|doSync
argument_list|()
expr_stmt|;
name|a
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|factor
operator|=
operator|(
name|inNames
operator|.
name|length
operator|<
name|factor
operator|)
condition|?
name|inNames
operator|.
name|length
else|:
name|factor
expr_stmt|;
comment|// pass in object to report progress, if present
name|MergeQueue
name|mQueue
init|=
operator|new
name|MergeQueue
argument_list|(
name|a
argument_list|,
name|tempDir
argument_list|,
name|progressable
argument_list|)
decl_stmt|;
return|return
name|mQueue
operator|.
name|merge
argument_list|()
return|;
block|}
comment|/**      * Clones the attributes (like compression of the input file and creates a       * corresponding Writer      * @param inputFile the path of the input file whose attributes should be       * cloned      * @param outputFile the path of the output file       * @param prog the Progressable to report status during the file write      * @return Writer      * @throws IOException      */
specifier|public
name|Writer
name|cloneFileAttributes
parameter_list|(
name|Path
name|inputFile
parameter_list|,
name|Path
name|outputFile
parameter_list|,
name|Progressable
name|prog
parameter_list|)
throws|throws
name|IOException
block|{
name|FileSystem
name|srcFileSys
init|=
name|inputFile
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Reader
name|reader
init|=
operator|new
name|Reader
argument_list|(
name|srcFileSys
argument_list|,
name|inputFile
argument_list|,
literal|4096
argument_list|,
name|conf
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|boolean
name|compress
init|=
name|reader
operator|.
name|isCompressed
argument_list|()
decl_stmt|;
name|boolean
name|blockCompress
init|=
name|reader
operator|.
name|isBlockCompressed
argument_list|()
decl_stmt|;
name|CompressionCodec
name|codec
init|=
name|reader
operator|.
name|getCompressionCodec
argument_list|()
decl_stmt|;
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
name|Writer
name|writer
init|=
name|createWriter
argument_list|(
name|outputFile
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
argument_list|,
name|conf
argument_list|,
name|outputFile
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|compress
argument_list|,
name|blockCompress
argument_list|,
name|codec
argument_list|,
name|prog
argument_list|,
operator|new
name|Metadata
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|writer
return|;
block|}
comment|/**      * Writes records from RawKeyValueIterator into a file represented by the       * passed writer      * @param records the RawKeyValueIterator      * @param writer the Writer created earlier       * @throws IOException      */
specifier|public
name|void
name|writeFile
parameter_list|(
name|RawKeyValueIterator
name|records
parameter_list|,
name|Writer
name|writer
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
name|records
operator|.
name|next
argument_list|()
condition|)
block|{
name|writer
operator|.
name|appendRaw
argument_list|(
name|records
operator|.
name|getKey
argument_list|()
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|records
operator|.
name|getKey
argument_list|()
operator|.
name|getLength
argument_list|()
argument_list|,
name|records
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|sync
argument_list|()
expr_stmt|;
block|}
comment|/** Merge the provided files.      * @param inFiles the array of input path names      * @param outFile the final output file      * @throws IOException      */
specifier|public
name|void
name|merge
parameter_list|(
name|Path
index|[]
name|inFiles
parameter_list|,
name|Path
name|outFile
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|outFile
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"already exists: "
operator|+
name|outFile
argument_list|)
throw|;
block|}
name|RawKeyValueIterator
name|r
init|=
name|merge
argument_list|(
name|inFiles
argument_list|,
literal|false
argument_list|,
name|outFile
operator|.
name|getParent
argument_list|()
argument_list|)
decl_stmt|;
name|Writer
name|writer
init|=
name|cloneFileAttributes
argument_list|(
name|inFiles
index|[
literal|0
index|]
argument_list|,
name|outFile
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|writeFile
argument_list|(
name|r
argument_list|,
name|writer
argument_list|)
expr_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** sort calls this to generate the final merged output */
specifier|private
name|int
name|mergePass
parameter_list|(
name|Path
name|tmpDir
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"running merge pass"
argument_list|)
expr_stmt|;
name|Writer
name|writer
init|=
name|cloneFileAttributes
argument_list|(
name|outFile
operator|.
name|suffix
argument_list|(
literal|".0"
argument_list|)
argument_list|,
name|outFile
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|RawKeyValueIterator
name|r
init|=
name|merge
argument_list|(
name|outFile
operator|.
name|suffix
argument_list|(
literal|".0"
argument_list|)
argument_list|,
name|outFile
operator|.
name|suffix
argument_list|(
literal|".0.index"
argument_list|)
argument_list|,
name|tmpDir
argument_list|)
decl_stmt|;
name|writeFile
argument_list|(
name|r
argument_list|,
name|writer
argument_list|)
expr_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/** Used by mergePass to merge the output of the sort      * @param inName the name of the input file containing sorted segments      * @param indexIn the offsets of the sorted segments      * @param tmpDir the relative directory to store intermediate results in      * @return RawKeyValueIterator      * @throws IOException      */
specifier|private
name|RawKeyValueIterator
name|merge
parameter_list|(
name|Path
name|inName
parameter_list|,
name|Path
name|indexIn
parameter_list|,
name|Path
name|tmpDir
parameter_list|)
throws|throws
name|IOException
block|{
comment|//get the segments from indexIn
comment|//we create a SegmentContainer so that we can track segments belonging to
comment|//inName and delete inName as soon as we see that we have looked at all
comment|//the contained segments during the merge process& hence don't need
comment|//them anymore
name|SegmentContainer
name|container
init|=
operator|new
name|SegmentContainer
argument_list|(
name|inName
argument_list|,
name|indexIn
argument_list|)
decl_stmt|;
name|MergeQueue
name|mQueue
init|=
operator|new
name|MergeQueue
argument_list|(
name|container
operator|.
name|getSegmentList
argument_list|()
argument_list|,
name|tmpDir
argument_list|,
name|progressable
argument_list|)
decl_stmt|;
return|return
name|mQueue
operator|.
name|merge
argument_list|()
return|;
block|}
comment|/** This class implements the core of the merge logic */
specifier|private
class|class
name|MergeQueue
extends|extends
name|PriorityQueue
implements|implements
name|RawKeyValueIterator
block|{
specifier|private
name|boolean
name|compress
decl_stmt|;
specifier|private
name|boolean
name|blockCompress
decl_stmt|;
specifier|private
name|DataOutputBuffer
name|rawKey
init|=
operator|new
name|DataOutputBuffer
argument_list|()
decl_stmt|;
specifier|private
name|ValueBytes
name|rawValue
decl_stmt|;
specifier|private
name|long
name|totalBytesProcessed
decl_stmt|;
specifier|private
name|float
name|progPerByte
decl_stmt|;
specifier|private
name|Progress
name|mergeProgress
init|=
operator|new
name|Progress
argument_list|()
decl_stmt|;
specifier|private
name|Path
name|tmpDir
decl_stmt|;
specifier|private
name|Progressable
name|progress
init|=
literal|null
decl_stmt|;
comment|//handle to the progress reporting object
specifier|private
name|SegmentDescriptor
name|minSegment
decl_stmt|;
comment|//a TreeMap used to store the segments sorted by size (segment offset and
comment|//segment path name is used to break ties between segments of same sizes)
specifier|private
name|Map
argument_list|<
name|SegmentDescriptor
argument_list|,
name|Void
argument_list|>
name|sortedSegmentSizes
init|=
operator|new
name|TreeMap
argument_list|<
name|SegmentDescriptor
argument_list|,
name|Void
argument_list|>
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|void
name|put
parameter_list|(
name|SegmentDescriptor
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|compress
operator|=
name|stream
operator|.
name|in
operator|.
name|isCompressed
argument_list|()
expr_stmt|;
name|blockCompress
operator|=
name|stream
operator|.
name|in
operator|.
name|isBlockCompressed
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compress
operator|!=
name|stream
operator|.
name|in
operator|.
name|isCompressed
argument_list|()
operator|||
name|blockCompress
operator|!=
name|stream
operator|.
name|in
operator|.
name|isBlockCompressed
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"All merged files must be compressed or not."
argument_list|)
throw|;
block|}
name|super
operator|.
name|put
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/**        * A queue of file segments to merge        * @param segments the file segments to merge        * @param tmpDir a relative local directory to save intermediate files in        * @param progress the reference to the Progressable object        */
specifier|public
name|MergeQueue
parameter_list|(
name|List
argument_list|<
name|SegmentDescriptor
argument_list|>
name|segments
parameter_list|,
name|Path
name|tmpDir
parameter_list|,
name|Progressable
name|progress
parameter_list|)
block|{
name|int
name|size
init|=
name|segments
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|sortedSegmentSizes
operator|.
name|put
argument_list|(
name|segments
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|tmpDir
operator|=
name|tmpDir
expr_stmt|;
name|this
operator|.
name|progress
operator|=
name|progress
expr_stmt|;
block|}
specifier|protected
name|boolean
name|lessThan
parameter_list|(
name|Object
name|a
parameter_list|,
name|Object
name|b
parameter_list|)
block|{
comment|// indicate we're making progress
if|if
condition|(
name|progress
operator|!=
literal|null
condition|)
block|{
name|progress
operator|.
name|progress
argument_list|()
expr_stmt|;
block|}
name|SegmentDescriptor
name|msa
init|=
operator|(
name|SegmentDescriptor
operator|)
name|a
decl_stmt|;
name|SegmentDescriptor
name|msb
init|=
operator|(
name|SegmentDescriptor
operator|)
name|b
decl_stmt|;
return|return
name|comparator
operator|.
name|compare
argument_list|(
name|msa
operator|.
name|getKey
argument_list|()
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|msa
operator|.
name|getKey
argument_list|()
operator|.
name|getLength
argument_list|()
argument_list|,
name|msb
operator|.
name|getKey
argument_list|()
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|msb
operator|.
name|getKey
argument_list|()
operator|.
name|getLength
argument_list|()
argument_list|)
operator|<
literal|0
return|;
block|}
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|SegmentDescriptor
name|ms
decl_stmt|;
comment|// close inputs
while|while
condition|(
operator|(
name|ms
operator|=
operator|(
name|SegmentDescriptor
operator|)
name|pop
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|ms
operator|.
name|cleanup
argument_list|()
expr_stmt|;
block|}
name|minSegment
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
name|DataOutputBuffer
name|getKey
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|rawKey
return|;
block|}
specifier|public
name|ValueBytes
name|getValue
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|rawValue
return|;
block|}
specifier|public
name|boolean
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|minSegment
operator|!=
literal|null
condition|)
block|{
comment|//minSegment is non-null for all invocations of next except the first
comment|//one. For the first invocation, the priority queue is ready for use
comment|//but for the subsequent invocations, first adjust the queue
name|adjustPriorityQueue
argument_list|(
name|minSegment
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|minSegment
operator|=
literal|null
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|minSegment
operator|=
operator|(
name|SegmentDescriptor
operator|)
name|top
argument_list|()
expr_stmt|;
name|long
name|startPos
init|=
name|minSegment
operator|.
name|in
operator|.
name|getPosition
argument_list|()
decl_stmt|;
comment|// Current position in stream
comment|//save the raw key reference
name|rawKey
operator|=
name|minSegment
operator|.
name|getKey
argument_list|()
expr_stmt|;
comment|//load the raw value. Re-use the existing rawValue buffer
if|if
condition|(
name|rawValue
operator|==
literal|null
condition|)
block|{
name|rawValue
operator|=
name|minSegment
operator|.
name|in
operator|.
name|createValueBytes
argument_list|()
expr_stmt|;
block|}
name|minSegment
operator|.
name|nextRawValue
argument_list|(
name|rawValue
argument_list|)
expr_stmt|;
name|long
name|endPos
init|=
name|minSegment
operator|.
name|in
operator|.
name|getPosition
argument_list|()
decl_stmt|;
comment|// End position after reading value
name|updateProgress
argument_list|(
name|endPos
operator|-
name|startPos
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
name|Progress
name|getProgress
parameter_list|()
block|{
return|return
name|mergeProgress
return|;
block|}
specifier|private
name|void
name|adjustPriorityQueue
parameter_list|(
name|SegmentDescriptor
name|ms
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|startPos
init|=
name|ms
operator|.
name|in
operator|.
name|getPosition
argument_list|()
decl_stmt|;
comment|// Current position in stream
name|boolean
name|hasNext
init|=
name|ms
operator|.
name|nextRawKey
argument_list|()
decl_stmt|;
name|long
name|endPos
init|=
name|ms
operator|.
name|in
operator|.
name|getPosition
argument_list|()
decl_stmt|;
comment|// End position after reading key
name|updateProgress
argument_list|(
name|endPos
operator|-
name|startPos
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasNext
condition|)
block|{
name|adjustTop
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|pop
argument_list|()
expr_stmt|;
name|ms
operator|.
name|cleanup
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|updateProgress
parameter_list|(
name|long
name|bytesProcessed
parameter_list|)
block|{
name|totalBytesProcessed
operator|+=
name|bytesProcessed
expr_stmt|;
if|if
condition|(
name|progPerByte
operator|>
literal|0
condition|)
block|{
name|mergeProgress
operator|.
name|set
argument_list|(
name|totalBytesProcessed
operator|*
name|progPerByte
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** This is the single level merge that is called multiple times         * depending on the factor size and the number of segments        * @return RawKeyValueIterator        * @throws IOException        */
specifier|public
name|RawKeyValueIterator
name|merge
parameter_list|()
throws|throws
name|IOException
block|{
comment|//create the MergeStreams from the sorted map created in the constructor
comment|//and dump the final output to a file
name|int
name|numSegments
init|=
name|sortedSegmentSizes
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|origFactor
init|=
name|factor
decl_stmt|;
name|int
name|passNo
init|=
literal|1
decl_stmt|;
name|LocalDirAllocator
name|lDirAlloc
init|=
operator|new
name|LocalDirAllocator
argument_list|(
literal|"mapred.local.dir"
argument_list|)
decl_stmt|;
do|do
block|{
comment|//get the factor for this pass of merge
name|factor
operator|=
name|getPassFactor
argument_list|(
name|passNo
argument_list|,
name|numSegments
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|SegmentDescriptor
argument_list|>
name|segmentsToMerge
init|=
operator|new
name|ArrayList
argument_list|<
name|SegmentDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|segmentsConsidered
init|=
literal|0
decl_stmt|;
name|int
name|numSegmentsToConsider
init|=
name|factor
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|//extract the smallest 'factor' number of segment pointers from the
comment|//TreeMap. Call cleanup on the empty segments (no key/value data)
name|SegmentDescriptor
index|[]
name|mStream
init|=
name|getSegmentDescriptors
argument_list|(
name|numSegmentsToConsider
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mStream
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mStream
index|[
name|i
index|]
operator|.
name|nextRawKey
argument_list|()
condition|)
block|{
name|segmentsToMerge
operator|.
name|add
argument_list|(
name|mStream
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|segmentsConsidered
operator|++
expr_stmt|;
comment|// Count the fact that we read some bytes in calling nextRawKey()
name|updateProgress
argument_list|(
name|mStream
index|[
name|i
index|]
operator|.
name|in
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mStream
index|[
name|i
index|]
operator|.
name|cleanup
argument_list|()
expr_stmt|;
name|numSegments
operator|--
expr_stmt|;
comment|//we ignore this segment for the merge
block|}
block|}
comment|//if we have the desired number of segments
comment|//or looked at all available segments, we break
if|if
condition|(
name|segmentsConsidered
operator|==
name|factor
operator|||
name|sortedSegmentSizes
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|numSegmentsToConsider
operator|=
name|factor
operator|-
name|segmentsConsidered
expr_stmt|;
block|}
comment|//feed the streams to the priority queue
name|initialize
argument_list|(
name|segmentsToMerge
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segmentsToMerge
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|put
argument_list|(
name|segmentsToMerge
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//if we have lesser number of segments remaining, then just return the
comment|//iterator, else do another single level merge
if|if
condition|(
name|numSegments
operator|<=
name|factor
condition|)
block|{
comment|//calculate the length of the remaining segments. Required for
comment|//calculating the merge progress
name|long
name|totalBytes
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segmentsToMerge
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|totalBytes
operator|+=
name|segmentsToMerge
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|segmentLength
expr_stmt|;
block|}
if|if
condition|(
name|totalBytes
operator|!=
literal|0
condition|)
comment|//being paranoid
name|progPerByte
operator|=
literal|1.0f
operator|/
operator|(
name|float
operator|)
name|totalBytes
expr_stmt|;
comment|//reset factor to what it originally was
name|factor
operator|=
name|origFactor
expr_stmt|;
return|return
name|this
return|;
block|}
else|else
block|{
comment|//we want to spread the creation of temp files on multiple disks if
comment|//available under the space constraints
name|long
name|approxOutputSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|SegmentDescriptor
name|s
range|:
name|segmentsToMerge
control|)
block|{
name|approxOutputSize
operator|+=
name|s
operator|.
name|segmentLength
operator|+
name|ChecksumFileSystem
operator|.
name|getApproxChkSumLength
argument_list|(
name|s
operator|.
name|segmentLength
argument_list|)
expr_stmt|;
block|}
name|Path
name|tmpFilename
init|=
operator|new
name|Path
argument_list|(
name|tmpDir
argument_list|,
literal|"intermediate"
argument_list|)
operator|.
name|suffix
argument_list|(
literal|"."
operator|+
name|passNo
argument_list|)
decl_stmt|;
name|Path
name|outputFile
init|=
name|lDirAlloc
operator|.
name|getLocalPathForWrite
argument_list|(
name|tmpFilename
operator|.
name|toString
argument_list|()
argument_list|,
name|approxOutputSize
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"writing intermediate results to "
operator|+
name|outputFile
argument_list|)
expr_stmt|;
name|Writer
name|writer
init|=
name|cloneFileAttributes
argument_list|(
name|fs
operator|.
name|makeQualified
argument_list|(
name|segmentsToMerge
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|segmentPathName
argument_list|)
argument_list|,
name|fs
operator|.
name|makeQualified
argument_list|(
name|outputFile
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|writer
operator|.
name|sync
operator|=
literal|null
expr_stmt|;
comment|//disable sync for temp files
name|writeFile
argument_list|(
name|this
argument_list|,
name|writer
argument_list|)
expr_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
comment|//we finished one single level merge; now clean up the priority
comment|//queue
name|this
operator|.
name|close
argument_list|()
expr_stmt|;
name|SegmentDescriptor
name|tempSegment
init|=
operator|new
name|SegmentDescriptor
argument_list|(
literal|0
argument_list|,
name|fs
operator|.
name|getLength
argument_list|(
name|outputFile
argument_list|)
argument_list|,
name|outputFile
argument_list|)
decl_stmt|;
comment|//put the segment back in the TreeMap
name|sortedSegmentSizes
operator|.
name|put
argument_list|(
name|tempSegment
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|numSegments
operator|=
name|sortedSegmentSizes
operator|.
name|size
argument_list|()
expr_stmt|;
name|passNo
operator|++
expr_stmt|;
block|}
comment|//we are worried about only the first pass merge factor. So reset the
comment|//factor to what it originally was
name|factor
operator|=
name|origFactor
expr_stmt|;
block|}
do|while
condition|(
literal|true
condition|)
do|;
block|}
comment|//Hadoop-591
specifier|public
name|int
name|getPassFactor
parameter_list|(
name|int
name|passNo
parameter_list|,
name|int
name|numSegments
parameter_list|)
block|{
if|if
condition|(
name|passNo
operator|>
literal|1
operator|||
name|numSegments
operator|<=
name|factor
operator|||
name|factor
operator|==
literal|1
condition|)
return|return
name|factor
return|;
name|int
name|mod
init|=
operator|(
name|numSegments
operator|-
literal|1
operator|)
operator|%
operator|(
name|factor
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|mod
operator|==
literal|0
condition|)
return|return
name|factor
return|;
return|return
name|mod
operator|+
literal|1
return|;
block|}
comment|/** Return (& remove) the requested number of segment descriptors from the        * sorted map.        */
specifier|public
name|SegmentDescriptor
index|[]
name|getSegmentDescriptors
parameter_list|(
name|int
name|numDescriptors
parameter_list|)
block|{
if|if
condition|(
name|numDescriptors
operator|>
name|sortedSegmentSizes
operator|.
name|size
argument_list|()
condition|)
name|numDescriptors
operator|=
name|sortedSegmentSizes
operator|.
name|size
argument_list|()
expr_stmt|;
name|SegmentDescriptor
index|[]
name|SegmentDescriptors
init|=
operator|new
name|SegmentDescriptor
index|[
name|numDescriptors
index|]
decl_stmt|;
name|Iterator
name|iter
init|=
name|sortedSegmentSizes
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|numDescriptors
condition|)
block|{
name|SegmentDescriptors
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|SegmentDescriptor
operator|)
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
return|return
name|SegmentDescriptors
return|;
block|}
block|}
comment|// SequenceFile.Sorter.MergeQueue
comment|/** This class defines a merge segment. This class can be subclassed to       * provide a customized cleanup method implementation. In this       * implementation, cleanup closes the file handle and deletes the file       */
specifier|public
class|class
name|SegmentDescriptor
implements|implements
name|Comparable
block|{
name|long
name|segmentOffset
decl_stmt|;
comment|//the start of the segment in the file
name|long
name|segmentLength
decl_stmt|;
comment|//the length of the segment
name|Path
name|segmentPathName
decl_stmt|;
comment|//the path name of the file containing the segment
name|boolean
name|ignoreSync
init|=
literal|true
decl_stmt|;
comment|//set to true for temp files
specifier|private
name|Reader
name|in
init|=
literal|null
decl_stmt|;
specifier|private
name|DataOutputBuffer
name|rawKey
init|=
literal|null
decl_stmt|;
comment|//this will hold the current key
specifier|private
name|boolean
name|preserveInput
init|=
literal|false
decl_stmt|;
comment|//delete input segment files?
comment|/** Constructs a segment        * @param segmentOffset the offset of the segment in the file        * @param segmentLength the length of the segment        * @param segmentPathName the path name of the file containing the segment        */
specifier|public
name|SegmentDescriptor
parameter_list|(
name|long
name|segmentOffset
parameter_list|,
name|long
name|segmentLength
parameter_list|,
name|Path
name|segmentPathName
parameter_list|)
block|{
name|this
operator|.
name|segmentOffset
operator|=
name|segmentOffset
expr_stmt|;
name|this
operator|.
name|segmentLength
operator|=
name|segmentLength
expr_stmt|;
name|this
operator|.
name|segmentPathName
operator|=
name|segmentPathName
expr_stmt|;
block|}
comment|/** Do the sync checks */
specifier|public
name|void
name|doSync
parameter_list|()
block|{
name|ignoreSync
operator|=
literal|false
expr_stmt|;
block|}
comment|/** Whether to delete the files when no longer needed */
specifier|public
name|void
name|preserveInput
parameter_list|(
name|boolean
name|preserve
parameter_list|)
block|{
name|preserveInput
operator|=
name|preserve
expr_stmt|;
block|}
specifier|public
name|boolean
name|shouldPreserveInput
parameter_list|()
block|{
return|return
name|preserveInput
return|;
block|}
specifier|public
name|int
name|compareTo
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|SegmentDescriptor
name|that
init|=
operator|(
name|SegmentDescriptor
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|segmentLength
operator|!=
name|that
operator|.
name|segmentLength
condition|)
block|{
return|return
operator|(
name|this
operator|.
name|segmentLength
operator|<
name|that
operator|.
name|segmentLength
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|this
operator|.
name|segmentOffset
operator|!=
name|that
operator|.
name|segmentOffset
condition|)
block|{
return|return
operator|(
name|this
operator|.
name|segmentOffset
operator|<
name|that
operator|.
name|segmentOffset
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|this
operator|.
name|segmentPathName
operator|.
name|toString
argument_list|()
operator|)
operator|.
name|compareTo
argument_list|(
name|that
operator|.
name|segmentPathName
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|SegmentDescriptor
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|SegmentDescriptor
name|that
init|=
operator|(
name|SegmentDescriptor
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|segmentLength
operator|==
name|that
operator|.
name|segmentLength
operator|&&
name|this
operator|.
name|segmentOffset
operator|==
name|that
operator|.
name|segmentOffset
operator|&&
name|this
operator|.
name|segmentPathName
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
name|that
operator|.
name|segmentPathName
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
literal|37
operator|*
literal|17
operator|+
call|(
name|int
call|)
argument_list|(
name|segmentOffset
operator|^
operator|(
name|segmentOffset
operator|>>>
literal|32
operator|)
argument_list|)
return|;
block|}
comment|/** Fills up the rawKey object with the key returned by the Reader        * @return true if there is a key returned; false, otherwise        * @throws IOException        */
specifier|public
name|boolean
name|nextRawKey
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|in
operator|==
literal|null
condition|)
block|{
name|int
name|bufferSize
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"io.file.buffer.size"
argument_list|,
literal|4096
argument_list|)
decl_stmt|;
if|if
condition|(
name|fs
operator|.
name|getUri
argument_list|()
operator|.
name|getScheme
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"ramfs"
argument_list|)
condition|)
block|{
name|bufferSize
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"io.bytes.per.checksum"
argument_list|,
literal|512
argument_list|)
expr_stmt|;
block|}
name|Reader
name|reader
init|=
operator|new
name|Reader
argument_list|(
name|fs
argument_list|,
name|segmentPathName
argument_list|,
name|bufferSize
argument_list|,
name|segmentOffset
argument_list|,
name|segmentLength
argument_list|,
name|conf
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|//sometimes we ignore syncs especially for temp merge files
if|if
condition|(
name|ignoreSync
condition|)
name|reader
operator|.
name|sync
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|reader
operator|.
name|getKeyClass
argument_list|()
operator|!=
name|keyClass
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"wrong key class: "
operator|+
name|reader
operator|.
name|getKeyClass
argument_list|()
operator|+
literal|" is not "
operator|+
name|keyClass
argument_list|)
throw|;
if|if
condition|(
name|reader
operator|.
name|getValueClass
argument_list|()
operator|!=
name|valClass
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"wrong value class: "
operator|+
name|reader
operator|.
name|getValueClass
argument_list|()
operator|+
literal|" is not "
operator|+
name|valClass
argument_list|)
throw|;
name|this
operator|.
name|in
operator|=
name|reader
expr_stmt|;
name|rawKey
operator|=
operator|new
name|DataOutputBuffer
argument_list|()
expr_stmt|;
block|}
name|rawKey
operator|.
name|reset
argument_list|()
expr_stmt|;
name|int
name|keyLength
init|=
name|in
operator|.
name|nextRawKey
argument_list|(
name|rawKey
argument_list|)
decl_stmt|;
return|return
operator|(
name|keyLength
operator|>=
literal|0
operator|)
return|;
block|}
comment|/** Fills up the passed rawValue with the value corresponding to the key        * read earlier        * @param rawValue        * @return the length of the value        * @throws IOException        */
specifier|public
name|int
name|nextRawValue
parameter_list|(
name|ValueBytes
name|rawValue
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|valLength
init|=
name|in
operator|.
name|nextRawValue
argument_list|(
name|rawValue
argument_list|)
decl_stmt|;
return|return
name|valLength
return|;
block|}
comment|/** Returns the stored rawKey */
specifier|public
name|DataOutputBuffer
name|getKey
parameter_list|()
block|{
return|return
name|rawKey
return|;
block|}
comment|/** closes the underlying reader */
specifier|private
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
name|this
operator|.
name|in
operator|=
literal|null
expr_stmt|;
block|}
comment|/** The default cleanup. Subclasses can override this with a custom         * cleanup         */
specifier|public
name|void
name|cleanup
parameter_list|()
throws|throws
name|IOException
block|{
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|preserveInput
condition|)
block|{
name|fs
operator|.
name|delete
argument_list|(
name|segmentPathName
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// SequenceFile.Sorter.SegmentDescriptor
comment|/** This class provisions multiple segments contained within a single      *  file      */
specifier|private
class|class
name|LinkedSegmentsDescriptor
extends|extends
name|SegmentDescriptor
block|{
name|SegmentContainer
name|parentContainer
init|=
literal|null
decl_stmt|;
comment|/** Constructs a segment        * @param segmentOffset the offset of the segment in the file        * @param segmentLength the length of the segment        * @param segmentPathName the path name of the file containing the segment        * @param parent the parent SegmentContainer that holds the segment        */
specifier|public
name|LinkedSegmentsDescriptor
parameter_list|(
name|long
name|segmentOffset
parameter_list|,
name|long
name|segmentLength
parameter_list|,
name|Path
name|segmentPathName
parameter_list|,
name|SegmentContainer
name|parent
parameter_list|)
block|{
name|super
argument_list|(
name|segmentOffset
argument_list|,
name|segmentLength
argument_list|,
name|segmentPathName
argument_list|)
expr_stmt|;
name|this
operator|.
name|parentContainer
operator|=
name|parent
expr_stmt|;
block|}
comment|/** The default cleanup. Subclasses can override this with a custom         * cleanup         */
specifier|public
name|void
name|cleanup
parameter_list|()
throws|throws
name|IOException
block|{
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|super
operator|.
name|shouldPreserveInput
argument_list|()
condition|)
return|return;
name|parentContainer
operator|.
name|cleanup
argument_list|()
expr_stmt|;
block|}
block|}
comment|//SequenceFile.Sorter.LinkedSegmentsDescriptor
comment|/** The class that defines a container for segments to be merged. Primarily      * required to delete temp files as soon as all the contained segments      * have been looked at */
specifier|private
class|class
name|SegmentContainer
block|{
specifier|private
name|int
name|numSegmentsCleanedUp
init|=
literal|0
decl_stmt|;
comment|//track the no. of segment cleanups
specifier|private
name|int
name|numSegmentsContained
decl_stmt|;
comment|//# of segments contained
specifier|private
name|Path
name|inName
decl_stmt|;
comment|//input file from where segments are created
comment|//the list of segments read from the file
specifier|private
name|ArrayList
argument_list|<
name|SegmentDescriptor
argument_list|>
name|segments
init|=
operator|new
name|ArrayList
argument_list|<
name|SegmentDescriptor
argument_list|>
argument_list|()
decl_stmt|;
comment|/** This constructor is there primarily to serve the sort routine that         * generates a single output file with an associated index file */
specifier|public
name|SegmentContainer
parameter_list|(
name|Path
name|inName
parameter_list|,
name|Path
name|indexIn
parameter_list|)
throws|throws
name|IOException
block|{
comment|//get the segments from indexIn
name|FSDataInputStream
name|fsIndexIn
init|=
name|fs
operator|.
name|open
argument_list|(
name|indexIn
argument_list|)
decl_stmt|;
name|long
name|end
init|=
name|fs
operator|.
name|getLength
argument_list|(
name|indexIn
argument_list|)
decl_stmt|;
while|while
condition|(
name|fsIndexIn
operator|.
name|getPos
argument_list|()
operator|<
name|end
condition|)
block|{
name|long
name|segmentOffset
init|=
name|WritableUtils
operator|.
name|readVLong
argument_list|(
name|fsIndexIn
argument_list|)
decl_stmt|;
name|long
name|segmentLength
init|=
name|WritableUtils
operator|.
name|readVLong
argument_list|(
name|fsIndexIn
argument_list|)
decl_stmt|;
name|Path
name|segmentName
init|=
name|inName
decl_stmt|;
name|segments
operator|.
name|add
argument_list|(
operator|new
name|LinkedSegmentsDescriptor
argument_list|(
name|segmentOffset
argument_list|,
name|segmentLength
argument_list|,
name|segmentName
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fsIndexIn
operator|.
name|close
argument_list|()
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|indexIn
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|numSegmentsContained
operator|=
name|segments
operator|.
name|size
argument_list|()
expr_stmt|;
name|this
operator|.
name|inName
operator|=
name|inName
expr_stmt|;
block|}
specifier|public
name|List
argument_list|<
name|SegmentDescriptor
argument_list|>
name|getSegmentList
parameter_list|()
block|{
return|return
name|segments
return|;
block|}
specifier|public
name|void
name|cleanup
parameter_list|()
throws|throws
name|IOException
block|{
name|numSegmentsCleanedUp
operator|++
expr_stmt|;
if|if
condition|(
name|numSegmentsCleanedUp
operator|==
name|numSegmentsContained
condition|)
block|{
name|fs
operator|.
name|delete
argument_list|(
name|inName
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//SequenceFile.Sorter.SegmentContainer
block|}
comment|// SequenceFile.Sorter
block|}
end_class

begin_comment
comment|// SequenceFile
end_comment

end_unit

