begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2009 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|HbaseMapWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|HeapSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|RawComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|Compressor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|Decompressor
import|;
end_import

begin_comment
comment|/**  * File format for hbase.  * A file of sorted key/value pairs. Both keys and values are byte arrays.  *<p>  * The memory footprint of a HFile includes the following (below is taken from  *<a  * href=https://issues.apache.org/jira/browse/HADOOP-3315>Hadoop-3315 tfile</a>  * but applies also to HFile):  *<ul>  *<li>Some constant overhead of reading or writing a compressed block.  *<ul>  *<li>Each compressed block requires one compression/decompression codec for  * I/O.  *<li>Temporary space to buffer the key.  *<li>Temporary space to buffer the value.  *</ul>  *<li>HFile index, which is proportional to the total number of Data Blocks.  * The total amount of memory needed to hold the index can be estimated as  * (56+AvgKeySize)*NumBlocks.  *</ul>  * Suggestions on performance optimization.  *<ul>  *<li>Minimum block size. We recommend a setting of minimum block size between  * 8KB to 1MB for general usage. Larger block size is preferred if files are  * primarily for sequential access. However, it would lead to inefficient random  * access (because there are more data to decompress). Smaller blocks are good  * for random access, but require more memory to hold the block index, and may  * be slower to create (because we must flush the compressor stream at the  * conclusion of each data block, which leads to an FS I/O flush). Further, due  * to the internal caching in Compression codec, the smallest possible block  * size would be around 20KB-30KB.  *<li>The current implementation does not offer true multi-threading for  * reading. The implementation uses FSDataInputStream seek()+read(), which is  * shown to be much faster than positioned-read call in single thread mode.  * However, it also means that if multiple threads attempt to access the same  * HFile (using multiple scanners) simultaneously, the actual I/O is carried out  * sequentially even if they access different DFS blocks (Reexamine! pread seems  * to be 10% faster than seek+read in my testing -- stack).  *<li>Compression codec. Use "none" if the data is not very compressable (by  * compressable, I mean a compression ratio at least 2:1). Generally, use "lzo"  * as the starting point for experimenting. "gz" overs slightly better  * compression ratio over "lzo" but requires 4x CPU to compress and 2x CPU to  * decompress, comparing to "lzo".  *</ul>  *   * For more on the background behind HFile, see<a  * href=https://issues.apache.org/jira/browse/HBASE-3315>HBASE-61</a>.  *<p>  * File is made of data blocks followed by meta data blocks (if any), a fileinfo  * block, data block index, meta data block index, and a fixed size trailer  * which records the offsets at which file changes content type.  *<pre>&lt;data blocks>&lt;meta blocks>&lt;fileinfo>&lt;data index>&lt;meta index>&lt;trailer></pre>  * Each block has a bit of magic at its start.  Block are comprised of  * key/values.  In data blocks, they are both byte arrays.  Metadata blocks are  * a String key and a byte array value.  An empty file looks like this:  *<pre>&lt;fileinfo>&lt;trailer></pre>.  That is, there are not data nor meta  * blocks present.  *<p>  * TODO: Do scanners need to be able to take a start and end row?  * TODO: Should BlockIndex know the name of its file?  Should it have a Path  * that points at its file say for the case where an index lives apart from  * an HFile instance?  */
end_comment

begin_class
specifier|public
class|class
name|HFile
block|{
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HFile
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/* These values are more or less arbitrary, and they are used as a     * form of check to make sure the file isn't completely corrupt.    */
specifier|final
specifier|static
name|byte
index|[]
name|DATABLOCKMAGIC
init|=
block|{
literal|'D'
block|,
literal|'A'
block|,
literal|'T'
block|,
literal|'A'
block|,
literal|'B'
block|,
literal|'L'
block|,
literal|'K'
block|,
literal|42
block|}
decl_stmt|;
specifier|final
specifier|static
name|byte
index|[]
name|INDEXBLOCKMAGIC
init|=
block|{
literal|'I'
block|,
literal|'D'
block|,
literal|'X'
block|,
literal|'B'
block|,
literal|'L'
block|,
literal|'K'
block|,
literal|41
block|,
literal|43
block|}
decl_stmt|;
specifier|final
specifier|static
name|byte
index|[]
name|METABLOCKMAGIC
init|=
block|{
literal|'M'
block|,
literal|'E'
block|,
literal|'T'
block|,
literal|'A'
block|,
literal|'B'
block|,
literal|'L'
block|,
literal|'K'
block|,
literal|99
block|}
decl_stmt|;
specifier|final
specifier|static
name|byte
index|[]
name|TRAILERBLOCKMAGIC
init|=
block|{
literal|'T'
block|,
literal|'R'
block|,
literal|'A'
block|,
literal|'B'
block|,
literal|'L'
block|,
literal|'K'
block|,
literal|34
block|,
literal|36
block|}
decl_stmt|;
comment|/**    * Maximum length of key in HFile.    */
specifier|public
specifier|final
specifier|static
name|int
name|MAXIMUM_KEY_LENGTH
init|=
literal|64
operator|*
literal|1024
decl_stmt|;
comment|/**    * Default blocksize for hfile.    */
specifier|public
specifier|final
specifier|static
name|int
name|DEFAULT_BLOCKSIZE
init|=
literal|64
operator|*
literal|1024
decl_stmt|;
comment|/**    * Default compression: none.    */
specifier|public
specifier|final
specifier|static
name|Compression
operator|.
name|Algorithm
name|DEFAULT_COMPRESSION_ALGORITHM
init|=
name|Compression
operator|.
name|Algorithm
operator|.
name|NONE
decl_stmt|;
comment|/** Default compression name: none. */
specifier|public
specifier|final
specifier|static
name|String
name|DEFAULT_COMPRESSION
init|=
name|DEFAULT_COMPRESSION_ALGORITHM
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|/**    * HFile Writer.    */
specifier|public
specifier|static
class|class
name|Writer
implements|implements
name|Closeable
block|{
comment|// FileSystem stream to write on.
specifier|private
name|FSDataOutputStream
name|outputStream
decl_stmt|;
comment|// True if we opened the<code>outputStream</code> (and so will close it).
specifier|private
name|boolean
name|closeOutputStream
decl_stmt|;
comment|// Name for this object used when logging or in toString.  Is either
comment|// the result of a toString on stream or else toString of passed file Path.
specifier|protected
name|String
name|name
decl_stmt|;
comment|// Total uncompressed bytes, maybe calculate a compression ratio later.
specifier|private
name|int
name|totalBytes
init|=
literal|0
decl_stmt|;
comment|// Total # of key/value entries, ie: how many times add() was called.
specifier|private
name|int
name|entryCount
init|=
literal|0
decl_stmt|;
comment|// Used calculating average key and value lengths.
specifier|private
name|long
name|keylength
init|=
literal|0
decl_stmt|;
specifier|private
name|long
name|valuelength
init|=
literal|0
decl_stmt|;
comment|// Used to ensure we write in order.
specifier|private
specifier|final
name|RawComparator
argument_list|<
name|byte
index|[]
argument_list|>
name|comparator
decl_stmt|;
comment|// A stream made per block written.
specifier|private
name|DataOutputStream
name|out
decl_stmt|;
comment|// Number of uncompressed bytes per block.  Reinitialized when we start
comment|// new block.
specifier|private
name|int
name|blocksize
decl_stmt|;
comment|// Offset where the current block began.
specifier|private
name|long
name|blockBegin
decl_stmt|;
comment|// First key in a block (Not first key in file).
specifier|private
name|byte
index|[]
name|firstKey
init|=
literal|null
decl_stmt|;
comment|// Key previously appended.  Becomes the last key in the file.
specifier|private
name|byte
index|[]
name|lastKeyBuffer
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|lastKeyOffset
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|int
name|lastKeyLength
init|=
operator|-
literal|1
decl_stmt|;
comment|// See {@link BlockIndex}. Below four fields are used to write the block
comment|// index.
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
name|blockKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
comment|// Block offset in backing stream.
name|ArrayList
argument_list|<
name|Long
argument_list|>
name|blockOffsets
init|=
operator|new
name|ArrayList
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
comment|// Raw (decompressed) data size.
name|ArrayList
argument_list|<
name|Integer
argument_list|>
name|blockDataSizes
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
comment|// Meta block system.
specifier|private
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
name|metaNames
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
name|metaData
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
comment|// Used compression.  Used even if no compression -- 'none'.
specifier|private
specifier|final
name|Compression
operator|.
name|Algorithm
name|compressAlgo
decl_stmt|;
specifier|private
name|Compressor
name|compressor
decl_stmt|;
comment|// Special datastructure to hold fileinfo.
specifier|private
name|FileInfo
name|fileinfo
init|=
operator|new
name|FileInfo
argument_list|()
decl_stmt|;
comment|// May be null if we were passed a stream.
specifier|private
name|Path
name|path
init|=
literal|null
decl_stmt|;
comment|/**      * Constructor that uses all defaults for compression and block size.      * @param fs      * @param path      * @throws IOException      */
specifier|public
name|Writer
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|DEFAULT_BLOCKSIZE
argument_list|,
operator|(
name|Compression
operator|.
name|Algorithm
operator|)
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor that takes a Path.      * @param fs      * @param path      * @param blocksize      * @param compress      * @param comparator      * @throws IOException       * @throws IOException      */
specifier|public
name|Writer
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|int
name|blocksize
parameter_list|,
name|String
name|compress
parameter_list|,
specifier|final
name|RawComparator
argument_list|<
name|byte
index|[]
argument_list|>
name|comparator
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|blocksize
argument_list|,
name|compress
operator|==
literal|null
condition|?
name|DEFAULT_COMPRESSION_ALGORITHM
else|:
name|Compression
operator|.
name|getCompressionAlgorithmByName
argument_list|(
name|compress
argument_list|)
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor that takes a Path.      * @param fs      * @param path      * @param blocksize      * @param compress      * @param comparator      * @throws IOException      */
specifier|public
name|Writer
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|int
name|blocksize
parameter_list|,
name|Compression
operator|.
name|Algorithm
name|compress
parameter_list|,
specifier|final
name|RawComparator
argument_list|<
name|byte
index|[]
argument_list|>
name|comparator
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|fs
operator|.
name|create
argument_list|(
name|path
argument_list|)
argument_list|,
name|blocksize
argument_list|,
name|compress
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
name|this
operator|.
name|closeOutputStream
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|path
operator|.
name|toString
argument_list|()
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
block|}
comment|/**      * Constructor that takes a stream.      * @param ostream Stream to use.      * @param blocksize      * @param compress      * @param c RawComparator to use.      * @throws IOException      */
specifier|public
name|Writer
parameter_list|(
specifier|final
name|FSDataOutputStream
name|ostream
parameter_list|,
specifier|final
name|int
name|blocksize
parameter_list|,
specifier|final
name|String
name|compress
parameter_list|,
specifier|final
name|RawComparator
argument_list|<
name|byte
index|[]
argument_list|>
name|c
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|ostream
argument_list|,
name|blocksize
argument_list|,
name|Compression
operator|.
name|getCompressionAlgorithmByName
argument_list|(
name|compress
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor that takes a stream.      * @param ostream Stream to use.      * @param blocksize      * @param compress      * @param c      * @throws IOException      */
specifier|public
name|Writer
parameter_list|(
specifier|final
name|FSDataOutputStream
name|ostream
parameter_list|,
specifier|final
name|int
name|blocksize
parameter_list|,
specifier|final
name|Compression
operator|.
name|Algorithm
name|compress
parameter_list|,
specifier|final
name|RawComparator
argument_list|<
name|byte
index|[]
argument_list|>
name|c
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|outputStream
operator|=
name|ostream
expr_stmt|;
name|this
operator|.
name|closeOutputStream
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|blocksize
operator|=
name|blocksize
expr_stmt|;
name|this
operator|.
name|comparator
operator|=
name|c
operator|==
literal|null
condition|?
name|Bytes
operator|.
name|BYTES_RAWCOMPARATOR
else|:
name|c
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|this
operator|.
name|outputStream
operator|.
name|toString
argument_list|()
expr_stmt|;
name|this
operator|.
name|compressAlgo
operator|=
name|compress
operator|==
literal|null
condition|?
name|DEFAULT_COMPRESSION_ALGORITHM
else|:
name|compress
expr_stmt|;
block|}
comment|/*      * If at block boundary, opens new block.      * @throws IOException      */
specifier|private
name|void
name|checkBlockBoundary
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|out
operator|!=
literal|null
operator|&&
name|this
operator|.
name|out
operator|.
name|size
argument_list|()
operator|<
name|blocksize
condition|)
return|return;
name|finishBlock
argument_list|()
expr_stmt|;
name|newBlock
argument_list|()
expr_stmt|;
block|}
comment|/*      * Do the cleanup if a current block.      * @throws IOException      */
specifier|private
name|void
name|finishBlock
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|out
operator|==
literal|null
condition|)
return|return;
name|long
name|size
init|=
name|releaseCompressingStream
argument_list|(
name|this
operator|.
name|out
argument_list|)
decl_stmt|;
name|this
operator|.
name|out
operator|=
literal|null
expr_stmt|;
name|blockKeys
operator|.
name|add
argument_list|(
name|firstKey
argument_list|)
expr_stmt|;
name|int
name|written
init|=
name|longToInt
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|blockOffsets
operator|.
name|add
argument_list|(
name|Long
operator|.
name|valueOf
argument_list|(
name|blockBegin
argument_list|)
argument_list|)
expr_stmt|;
name|blockDataSizes
operator|.
name|add
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|written
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|totalBytes
operator|+=
name|written
expr_stmt|;
block|}
comment|/*      * Ready a new block for writing.      * @throws IOException      */
specifier|private
name|void
name|newBlock
parameter_list|()
throws|throws
name|IOException
block|{
comment|// This is where the next block begins.
name|blockBegin
operator|=
name|outputStream
operator|.
name|getPos
argument_list|()
expr_stmt|;
name|this
operator|.
name|out
operator|=
name|getCompressingStream
argument_list|()
expr_stmt|;
name|this
operator|.
name|out
operator|.
name|write
argument_list|(
name|DATABLOCKMAGIC
argument_list|)
expr_stmt|;
name|firstKey
operator|=
literal|null
expr_stmt|;
block|}
comment|/*      * Sets up a compressor and creates a compression stream on top of      * this.outputStream.  Get one per block written.      * @return A compressing stream; if 'none' compression, returned stream      * does not compress.      * @throws IOException      * @see {@link #releaseCompressingStream(DataOutputStream)}      */
specifier|private
name|DataOutputStream
name|getCompressingStream
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|compressor
operator|=
name|compressAlgo
operator|.
name|getCompressor
argument_list|()
expr_stmt|;
comment|// Get new DOS compression stream.  In tfile, the DOS, is not closed,
comment|// just finished, and that seems to be fine over there.  TODO: Check
comment|// no memory retention of the DOS.  Should I disable the 'flush' on the
comment|// DOS as the BCFile over in tfile does?  It wants to make it so flushes
comment|// don't go through to the underlying compressed stream.  Flush on the
comment|// compressed downstream should be only when done.  I was going to but
comment|// looks like when we call flush in here, its legitimate flush that
comment|// should go through to the compressor.
name|OutputStream
name|os
init|=
name|this
operator|.
name|compressAlgo
operator|.
name|createCompressionStream
argument_list|(
name|this
operator|.
name|outputStream
argument_list|,
name|this
operator|.
name|compressor
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
operator|new
name|DataOutputStream
argument_list|(
name|os
argument_list|)
return|;
block|}
comment|/*      * Let go of block compressor and compressing stream gotten in call      * {@link #getCompressingStream}.      * @param dos      * @return How much was written on this stream since it was taken out.      * @see #getCompressingStream()       * @throws IOException      */
specifier|private
name|int
name|releaseCompressingStream
parameter_list|(
specifier|final
name|DataOutputStream
name|dos
parameter_list|)
throws|throws
name|IOException
block|{
name|dos
operator|.
name|flush
argument_list|()
expr_stmt|;
name|this
operator|.
name|compressAlgo
operator|.
name|returnCompressor
argument_list|(
name|this
operator|.
name|compressor
argument_list|)
expr_stmt|;
name|this
operator|.
name|compressor
operator|=
literal|null
expr_stmt|;
return|return
name|dos
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Add a meta block to the end of the file. Call before close().      * Metadata blocks are expensive.  Fill one with a bunch of serialized data      * rather than do a metadata block per metadata instance.  If metadata is      * small, consider adding to file info using      * {@link #appendFileInfo(byte[], byte[])}      * @param metaBlockName name of the block      * @param bytes uninterpreted bytes of the block.      */
specifier|public
name|void
name|appendMetaBlock
parameter_list|(
name|String
name|metaBlockName
parameter_list|,
name|byte
index|[]
name|bytes
parameter_list|)
block|{
name|metaNames
operator|.
name|add
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|metaBlockName
argument_list|)
argument_list|)
expr_stmt|;
name|metaData
operator|.
name|add
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add to the file info.  Added key value can be gotten out of the return      * from {@link Reader#loadFileInfo()}.      * @param k Key      * @param v Value      * @throws IOException       */
specifier|public
name|void
name|appendFileInfo
parameter_list|(
specifier|final
name|byte
index|[]
name|k
parameter_list|,
specifier|final
name|byte
index|[]
name|v
parameter_list|)
throws|throws
name|IOException
block|{
name|appendFileInfo
argument_list|(
name|this
operator|.
name|fileinfo
argument_list|,
name|k
argument_list|,
name|v
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|FileInfo
name|appendFileInfo
parameter_list|(
name|FileInfo
name|fi
parameter_list|,
specifier|final
name|byte
index|[]
name|k
parameter_list|,
specifier|final
name|byte
index|[]
name|v
parameter_list|,
specifier|final
name|boolean
name|checkPrefix
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|k
operator|==
literal|null
operator|||
name|v
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Key nor value may be null"
argument_list|)
throw|;
block|}
if|if
condition|(
name|checkPrefix
operator|&&
name|Bytes
operator|.
name|toString
argument_list|(
name|k
argument_list|)
operator|.
name|toLowerCase
argument_list|()
operator|.
name|startsWith
argument_list|(
name|FileInfo
operator|.
name|RESERVED_PREFIX
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Keys with a "
operator|+
name|FileInfo
operator|.
name|RESERVED_PREFIX
operator|+
literal|" are reserved"
argument_list|)
throw|;
block|}
name|fi
operator|.
name|put
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
name|fi
return|;
block|}
comment|/**      * @return Path or null if we were passed a stream rather than a Path.      */
specifier|public
name|Path
name|getPath
parameter_list|()
block|{
return|return
name|this
operator|.
name|path
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"writer="
operator|+
name|this
operator|.
name|name
operator|+
literal|", compression="
operator|+
name|this
operator|.
name|compressAlgo
operator|.
name|getName
argument_list|()
return|;
block|}
comment|/**      * Add key/value to file.      * Keys must be added in an order that agrees with the Comparator passed      * on construction.      * @param kv KeyValue to add.  Cannot be empty nor null.      * @throws IOException      */
specifier|public
name|void
name|append
parameter_list|(
specifier|final
name|KeyValue
name|kv
parameter_list|)
throws|throws
name|IOException
block|{
name|append
argument_list|(
name|kv
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|kv
operator|.
name|getKeyOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getKeyLength
argument_list|()
argument_list|,
name|kv
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|kv
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getValueLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add key/value to file.      * Keys must be added in an order that agrees with the Comparator passed      * on construction.      * @param key Key to add.  Cannot be empty nor null.      * @param value Value to add.  Cannot be empty nor null.      * @throws IOException      */
specifier|public
name|void
name|append
parameter_list|(
specifier|final
name|byte
index|[]
name|key
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|append
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|length
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|value
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add key/value to file.      * Keys must be added in an order that agrees with the Comparator passed      * on construction.      * @param key      * @param koffset      * @param klength      * @param value      * @param voffset      * @param vlength      * @throws IOException      */
specifier|public
name|void
name|append
parameter_list|(
specifier|final
name|byte
index|[]
name|key
parameter_list|,
specifier|final
name|int
name|koffset
parameter_list|,
specifier|final
name|int
name|klength
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|int
name|voffset
parameter_list|,
specifier|final
name|int
name|vlength
parameter_list|)
throws|throws
name|IOException
block|{
name|checkKey
argument_list|(
name|key
argument_list|,
name|koffset
argument_list|,
name|klength
argument_list|)
expr_stmt|;
name|checkValue
argument_list|(
name|value
argument_list|,
name|voffset
argument_list|,
name|vlength
argument_list|)
expr_stmt|;
name|checkBlockBoundary
argument_list|()
expr_stmt|;
comment|// Write length of key and value and then actual key and value bytes.
name|this
operator|.
name|out
operator|.
name|writeInt
argument_list|(
name|klength
argument_list|)
expr_stmt|;
name|this
operator|.
name|keylength
operator|+=
name|klength
expr_stmt|;
name|this
operator|.
name|out
operator|.
name|writeInt
argument_list|(
name|vlength
argument_list|)
expr_stmt|;
name|this
operator|.
name|valuelength
operator|+=
name|vlength
expr_stmt|;
name|this
operator|.
name|out
operator|.
name|write
argument_list|(
name|key
argument_list|,
name|koffset
argument_list|,
name|klength
argument_list|)
expr_stmt|;
name|this
operator|.
name|out
operator|.
name|write
argument_list|(
name|value
argument_list|,
name|voffset
argument_list|,
name|vlength
argument_list|)
expr_stmt|;
comment|// Are we the first key in this block?
if|if
condition|(
name|this
operator|.
name|firstKey
operator|==
literal|null
condition|)
block|{
comment|// Copy the key.
name|this
operator|.
name|firstKey
operator|=
operator|new
name|byte
index|[
name|klength
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|key
argument_list|,
name|koffset
argument_list|,
name|this
operator|.
name|firstKey
argument_list|,
literal|0
argument_list|,
name|klength
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|lastKeyBuffer
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|lastKeyOffset
operator|=
name|koffset
expr_stmt|;
name|this
operator|.
name|lastKeyLength
operator|=
name|klength
expr_stmt|;
name|this
operator|.
name|entryCount
operator|++
expr_stmt|;
block|}
comment|/*      * @param key Key to check.      * @throws IOException      */
specifier|private
name|void
name|checkKey
parameter_list|(
specifier|final
name|byte
index|[]
name|key
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|key
operator|==
literal|null
operator|||
name|length
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Key cannot be null or empty"
argument_list|)
throw|;
block|}
if|if
condition|(
name|length
operator|>
name|MAXIMUM_KEY_LENGTH
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Key length "
operator|+
name|length
operator|+
literal|"> "
operator|+
name|MAXIMUM_KEY_LENGTH
argument_list|)
throw|;
block|}
if|if
condition|(
name|this
operator|.
name|lastKeyBuffer
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|comparator
operator|.
name|compare
argument_list|(
name|this
operator|.
name|lastKeyBuffer
argument_list|,
name|this
operator|.
name|lastKeyOffset
argument_list|,
name|this
operator|.
name|lastKeyLength
argument_list|,
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Added a key not lexically larger than"
operator|+
literal|" previous key="
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
operator|+
literal|", lastkey="
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|this
operator|.
name|lastKeyBuffer
argument_list|,
name|this
operator|.
name|lastKeyOffset
argument_list|,
name|this
operator|.
name|lastKeyLength
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
name|void
name|checkValue
parameter_list|(
specifier|final
name|byte
index|[]
name|value
parameter_list|,
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Value cannot be null"
argument_list|)
throw|;
block|}
block|}
specifier|public
name|long
name|getTotalBytes
parameter_list|()
block|{
return|return
name|this
operator|.
name|totalBytes
return|;
block|}
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|outputStream
operator|==
literal|null
condition|)
block|{
return|return;
block|}
comment|// Write out the end of the data blocks, then write meta data blocks.
comment|// followed by fileinfo, data block index and meta block index.
name|finishBlock
argument_list|()
expr_stmt|;
name|FixedFileTrailer
name|trailer
init|=
operator|new
name|FixedFileTrailer
argument_list|()
decl_stmt|;
comment|// Write out the metadata blocks if any.
name|ArrayList
argument_list|<
name|Long
argument_list|>
name|metaOffsets
init|=
literal|null
decl_stmt|;
name|ArrayList
argument_list|<
name|Integer
argument_list|>
name|metaDataSizes
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|metaNames
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|metaOffsets
operator|=
operator|new
name|ArrayList
argument_list|<
name|Long
argument_list|>
argument_list|(
name|metaNames
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|metaDataSizes
operator|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|(
name|metaNames
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|metaNames
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|metaOffsets
operator|.
name|add
argument_list|(
name|Long
operator|.
name|valueOf
argument_list|(
name|outputStream
operator|.
name|getPos
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|metaDataSizes
operator|.
name|add
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|METABLOCKMAGIC
operator|.
name|length
operator|+
name|metaData
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|writeMetaBlock
argument_list|(
name|metaData
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Write fileinfo.
name|trailer
operator|.
name|fileinfoOffset
operator|=
name|writeFileInfo
argument_list|(
name|this
operator|.
name|outputStream
argument_list|)
expr_stmt|;
comment|// Write the data block index.
name|trailer
operator|.
name|dataIndexOffset
operator|=
name|BlockIndex
operator|.
name|writeIndex
argument_list|(
name|this
operator|.
name|outputStream
argument_list|,
name|this
operator|.
name|blockKeys
argument_list|,
name|this
operator|.
name|blockOffsets
argument_list|,
name|this
operator|.
name|blockDataSizes
argument_list|)
expr_stmt|;
comment|// Meta block index.
if|if
condition|(
name|metaNames
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|trailer
operator|.
name|metaIndexOffset
operator|=
name|BlockIndex
operator|.
name|writeIndex
argument_list|(
name|this
operator|.
name|outputStream
argument_list|,
name|this
operator|.
name|metaNames
argument_list|,
name|metaOffsets
argument_list|,
name|metaDataSizes
argument_list|)
expr_stmt|;
block|}
comment|// Now finish off the trailer.
name|trailer
operator|.
name|dataIndexCount
operator|=
name|blockKeys
operator|.
name|size
argument_list|()
expr_stmt|;
name|trailer
operator|.
name|metaIndexCount
operator|=
name|metaNames
operator|.
name|size
argument_list|()
expr_stmt|;
name|trailer
operator|.
name|totalUncompressedBytes
operator|=
name|totalBytes
expr_stmt|;
name|trailer
operator|.
name|entryCount
operator|=
name|entryCount
expr_stmt|;
name|trailer
operator|.
name|compressionCodec
operator|=
name|this
operator|.
name|compressAlgo
operator|.
name|ordinal
argument_list|()
expr_stmt|;
name|trailer
operator|.
name|serialize
argument_list|(
name|outputStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|closeOutputStream
condition|)
block|{
name|this
operator|.
name|outputStream
operator|.
name|close
argument_list|()
expr_stmt|;
name|this
operator|.
name|outputStream
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/* Write a metadata block.      * @param metadata      * @throws IOException      */
specifier|private
name|void
name|writeMetaBlock
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|DataOutputStream
name|dos
init|=
name|getCompressingStream
argument_list|()
decl_stmt|;
name|dos
operator|.
name|write
argument_list|(
name|METABLOCKMAGIC
argument_list|)
expr_stmt|;
name|dos
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|releaseCompressingStream
argument_list|(
name|dos
argument_list|)
expr_stmt|;
block|}
comment|/*      * Add last bits of metadata to fileinfo and then write it out.      * Reader will be expecting to find all below.      * @param o Stream to write on.      * @return Position at which we started writing.      * @throws IOException      */
specifier|private
name|long
name|writeFileInfo
parameter_list|(
name|FSDataOutputStream
name|o
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|lastKeyBuffer
operator|!=
literal|null
condition|)
block|{
comment|// Make a copy.  The copy is stuffed into HMapWritable.  Needs a clean
comment|// byte buffer.  Won't take a tuple.
name|byte
index|[]
name|b
init|=
operator|new
name|byte
index|[
name|this
operator|.
name|lastKeyLength
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|this
operator|.
name|lastKeyBuffer
argument_list|,
name|this
operator|.
name|lastKeyOffset
argument_list|,
name|b
argument_list|,
literal|0
argument_list|,
name|this
operator|.
name|lastKeyLength
argument_list|)
expr_stmt|;
name|appendFileInfo
argument_list|(
name|this
operator|.
name|fileinfo
argument_list|,
name|FileInfo
operator|.
name|LASTKEY
argument_list|,
name|b
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|int
name|avgKeyLen
init|=
name|this
operator|.
name|entryCount
operator|==
literal|0
condition|?
literal|0
else|:
call|(
name|int
call|)
argument_list|(
name|this
operator|.
name|keylength
operator|/
name|this
operator|.
name|entryCount
argument_list|)
decl_stmt|;
name|appendFileInfo
argument_list|(
name|this
operator|.
name|fileinfo
argument_list|,
name|FileInfo
operator|.
name|AVG_KEY_LEN
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|avgKeyLen
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|int
name|avgValueLen
init|=
name|this
operator|.
name|entryCount
operator|==
literal|0
condition|?
literal|0
else|:
call|(
name|int
call|)
argument_list|(
name|this
operator|.
name|keylength
operator|/
name|this
operator|.
name|entryCount
argument_list|)
decl_stmt|;
name|appendFileInfo
argument_list|(
name|this
operator|.
name|fileinfo
argument_list|,
name|FileInfo
operator|.
name|AVG_VALUE_LEN
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|avgValueLen
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|appendFileInfo
argument_list|(
name|this
operator|.
name|fileinfo
argument_list|,
name|FileInfo
operator|.
name|COMPARATOR
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|this
operator|.
name|comparator
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|long
name|pos
init|=
name|o
operator|.
name|getPos
argument_list|()
decl_stmt|;
name|this
operator|.
name|fileinfo
operator|.
name|write
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|pos
return|;
block|}
block|}
comment|/**    * HFile Reader.    */
specifier|public
specifier|static
class|class
name|Reader
implements|implements
name|Closeable
block|{
comment|// Stream to read from.
specifier|private
name|FSDataInputStream
name|istream
decl_stmt|;
comment|// True if we should close istream when done.  We don't close it if we
comment|// didn't open it.
specifier|private
name|boolean
name|closeIStream
decl_stmt|;
comment|// These are read in when the file info is loaded.
name|HFile
operator|.
name|BlockIndex
name|blockIndex
decl_stmt|;
specifier|private
name|BlockIndex
name|metaIndex
decl_stmt|;
name|FixedFileTrailer
name|trailer
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|fileInfoLoaded
init|=
literal|false
decl_stmt|;
comment|// Filled when we read in the trailer.
specifier|private
name|Compression
operator|.
name|Algorithm
name|compressAlgo
decl_stmt|;
comment|// Last key in the file.  Filled in when we read in the file info
specifier|private
name|byte
index|[]
name|lastkey
init|=
literal|null
decl_stmt|;
comment|// Stats read in when we load file info.
specifier|private
name|int
name|avgKeyLen
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|int
name|avgValueLen
init|=
operator|-
literal|1
decl_stmt|;
comment|// Used to ensure we seek correctly.
name|RawComparator
argument_list|<
name|byte
index|[]
argument_list|>
name|comparator
decl_stmt|;
comment|// Size of this file.
specifier|private
specifier|final
name|long
name|fileSize
decl_stmt|;
comment|// Block cache to use.
specifier|private
specifier|final
name|BlockCache
name|cache
decl_stmt|;
specifier|public
name|int
name|cacheHits
init|=
literal|0
decl_stmt|;
specifier|public
name|int
name|blockLoads
init|=
literal|0
decl_stmt|;
comment|// Name for this object used when logging or in toString.  Is either
comment|// the result of a toString on the stream or else is toString of passed
comment|// file Path plus metadata key/value pairs.
specifier|private
name|String
name|name
decl_stmt|;
comment|/*      * Do not expose the default constructor.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|private
name|Reader
parameter_list|()
throws|throws
name|IOException
block|{
name|this
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**       * Opens a HFile.  You must load the file info before you can       * use it by calling {@link #loadFileInfo()}.      *      * @param fs filesystem to load from      * @param path path within said filesystem      * @param cache block cache. Pass null if none.      * @throws IOException      */
specifier|public
name|Reader
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|BlockCache
name|cache
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|fs
operator|.
name|open
argument_list|(
name|path
argument_list|)
argument_list|,
name|fs
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
operator|.
name|getLen
argument_list|()
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|this
operator|.
name|closeIStream
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|path
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
comment|/**       * Opens a HFile.  You must load the index before you can       * use it by calling {@link #loadFileInfo()}.      *      * @param fsdis input stream.  Caller is responsible for closing the passed      * stream.      * @param size Length of the stream.      * @param cache block cache. Pass null if none.      * @throws IOException      */
specifier|public
name|Reader
parameter_list|(
specifier|final
name|FSDataInputStream
name|fsdis
parameter_list|,
specifier|final
name|long
name|size
parameter_list|,
specifier|final
name|BlockCache
name|cache
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|cache
operator|=
name|cache
expr_stmt|;
name|this
operator|.
name|fileSize
operator|=
name|size
expr_stmt|;
name|this
operator|.
name|istream
operator|=
name|fsdis
expr_stmt|;
name|this
operator|.
name|closeIStream
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|this
operator|.
name|istream
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"reader="
operator|+
name|this
operator|.
name|name
operator|+
operator|(
operator|!
name|isFileInfoLoaded
argument_list|()
condition|?
literal|""
else|:
literal|", compression="
operator|+
name|this
operator|.
name|compressAlgo
operator|.
name|getName
argument_list|()
operator|+
literal|", firstKey="
operator|+
name|toStringFirstKey
argument_list|()
operator|+
literal|", lastKey="
operator|+
name|toStringLastKey
argument_list|()
operator|)
operator|+
literal|", avgKeyLen="
operator|+
name|this
operator|.
name|avgKeyLen
operator|+
literal|", avgValueLen="
operator|+
name|this
operator|.
name|avgValueLen
operator|+
literal|", entries="
operator|+
name|this
operator|.
name|trailer
operator|.
name|entryCount
operator|+
literal|", length="
operator|+
name|this
operator|.
name|fileSize
return|;
block|}
specifier|protected
name|String
name|toStringFirstKey
parameter_list|()
block|{
return|return
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|getFirstKey
argument_list|()
argument_list|)
return|;
block|}
specifier|protected
name|String
name|toStringLastKey
parameter_list|()
block|{
return|return
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|getFirstKey
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|long
name|length
parameter_list|()
block|{
return|return
name|this
operator|.
name|fileSize
return|;
block|}
comment|/**      * Read in the index and file info.      * @return A map of fileinfo data.      * See {@link Writer#appendFileInfo(byte[], byte[])}.      * @throws IOException      */
specifier|public
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|loadFileInfo
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|trailer
operator|=
name|readTrailer
argument_list|()
expr_stmt|;
comment|// Read in the fileinfo and get what we need from it.
name|this
operator|.
name|istream
operator|.
name|seek
argument_list|(
name|this
operator|.
name|trailer
operator|.
name|fileinfoOffset
argument_list|)
expr_stmt|;
name|FileInfo
name|fi
init|=
operator|new
name|FileInfo
argument_list|()
decl_stmt|;
name|fi
operator|.
name|readFields
argument_list|(
name|this
operator|.
name|istream
argument_list|)
expr_stmt|;
name|this
operator|.
name|lastkey
operator|=
name|fi
operator|.
name|get
argument_list|(
name|FileInfo
operator|.
name|LASTKEY
argument_list|)
expr_stmt|;
name|this
operator|.
name|avgKeyLen
operator|=
name|Bytes
operator|.
name|toInt
argument_list|(
name|fi
operator|.
name|get
argument_list|(
name|FileInfo
operator|.
name|AVG_KEY_LEN
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|avgValueLen
operator|=
name|Bytes
operator|.
name|toInt
argument_list|(
name|fi
operator|.
name|get
argument_list|(
name|FileInfo
operator|.
name|AVG_VALUE_LEN
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|clazzName
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|fi
operator|.
name|get
argument_list|(
name|FileInfo
operator|.
name|COMPARATOR
argument_list|)
argument_list|)
decl_stmt|;
name|this
operator|.
name|comparator
operator|=
name|getComparator
argument_list|(
name|clazzName
argument_list|)
expr_stmt|;
comment|// Read in the data index.
name|this
operator|.
name|blockIndex
operator|=
name|BlockIndex
operator|.
name|readIndex
argument_list|(
name|this
operator|.
name|comparator
argument_list|,
name|this
operator|.
name|istream
argument_list|,
name|this
operator|.
name|trailer
operator|.
name|dataIndexOffset
argument_list|,
name|this
operator|.
name|trailer
operator|.
name|dataIndexCount
argument_list|)
expr_stmt|;
comment|// Read in the metadata index.
if|if
condition|(
name|trailer
operator|.
name|metaIndexCount
operator|>
literal|0
condition|)
block|{
name|this
operator|.
name|metaIndex
operator|=
name|BlockIndex
operator|.
name|readIndex
argument_list|(
name|Bytes
operator|.
name|BYTES_RAWCOMPARATOR
argument_list|,
name|this
operator|.
name|istream
argument_list|,
name|this
operator|.
name|trailer
operator|.
name|metaIndexOffset
argument_list|,
name|trailer
operator|.
name|metaIndexCount
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|fileInfoLoaded
operator|=
literal|true
expr_stmt|;
return|return
name|fi
return|;
block|}
name|boolean
name|isFileInfoLoaded
parameter_list|()
block|{
return|return
name|this
operator|.
name|fileInfoLoaded
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
name|RawComparator
argument_list|<
name|byte
index|[]
argument_list|>
name|getComparator
parameter_list|(
specifier|final
name|String
name|clazzName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|clazzName
operator|==
literal|null
operator|||
name|clazzName
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
try|try
block|{
return|return
operator|(
name|RawComparator
argument_list|<
name|byte
index|[]
argument_list|>
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|clazzName
argument_list|)
operator|.
name|newInstance
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|InstantiationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/* Read the trailer off the input stream.  As side effect, sets the      * compression algorithm.      * @return Populated FixedFileTrailer.      * @throws IOException      */
specifier|private
name|FixedFileTrailer
name|readTrailer
parameter_list|()
throws|throws
name|IOException
block|{
name|FixedFileTrailer
name|fft
init|=
operator|new
name|FixedFileTrailer
argument_list|()
decl_stmt|;
name|long
name|seekPoint
init|=
name|this
operator|.
name|fileSize
operator|-
name|FixedFileTrailer
operator|.
name|trailerSize
argument_list|()
decl_stmt|;
name|this
operator|.
name|istream
operator|.
name|seek
argument_list|(
name|seekPoint
argument_list|)
expr_stmt|;
name|fft
operator|.
name|deserialize
argument_list|(
name|this
operator|.
name|istream
argument_list|)
expr_stmt|;
comment|// Set up the codec.
name|this
operator|.
name|compressAlgo
operator|=
name|Compression
operator|.
name|Algorithm
operator|.
name|values
argument_list|()
index|[
name|fft
operator|.
name|compressionCodec
index|]
expr_stmt|;
return|return
name|fft
return|;
block|}
comment|/**      * Create a Scanner on this file.  No seeks or reads are done on creation.      * Call {@link HFileScanner#seekTo(byte[])} to position an start the read.      * There is nothing to clean up in a Scanner. Letting go of your references      * to the scanner is sufficient.      * @return Scanner on this file.      */
specifier|public
name|HFileScanner
name|getScanner
parameter_list|()
block|{
return|return
operator|new
name|Scanner
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**      * @param key Key to search.      * @return Block number of the block containing the key or -1 if not in this      * file.      */
specifier|protected
name|int
name|blockContainingKey
parameter_list|(
specifier|final
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
name|blockIndex
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Block index not loaded"
argument_list|)
throw|;
block|}
return|return
name|blockIndex
operator|.
name|blockContainingKey
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
comment|/**      * @param metaBlockName      * @return Block wrapped in a ByteBuffer      * @throws IOException      */
specifier|public
name|ByteBuffer
name|getMetaBlock
parameter_list|(
name|String
name|metaBlockName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|trailer
operator|.
name|metaIndexCount
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
comment|// there are no meta blocks
block|}
if|if
condition|(
name|metaIndex
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Meta index not loaded"
argument_list|)
throw|;
block|}
name|byte
index|[]
name|mbname
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|metaBlockName
argument_list|)
decl_stmt|;
name|int
name|block
init|=
name|metaIndex
operator|.
name|blockContainingKey
argument_list|(
name|mbname
argument_list|,
literal|0
argument_list|,
name|mbname
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|block
operator|==
operator|-
literal|1
condition|)
return|return
literal|null
return|;
name|long
name|blockSize
decl_stmt|;
if|if
condition|(
name|block
operator|==
name|metaIndex
operator|.
name|count
operator|-
literal|1
condition|)
block|{
name|blockSize
operator|=
name|trailer
operator|.
name|fileinfoOffset
operator|-
name|metaIndex
operator|.
name|blockOffsets
index|[
name|block
index|]
expr_stmt|;
block|}
else|else
block|{
name|blockSize
operator|=
name|metaIndex
operator|.
name|blockOffsets
index|[
name|block
operator|+
literal|1
index|]
operator|-
name|metaIndex
operator|.
name|blockOffsets
index|[
name|block
index|]
expr_stmt|;
block|}
name|ByteBuffer
name|buf
init|=
name|decompress
argument_list|(
name|metaIndex
operator|.
name|blockOffsets
index|[
name|block
index|]
argument_list|,
name|longToInt
argument_list|(
name|blockSize
argument_list|)
argument_list|,
name|metaIndex
operator|.
name|blockDataSizes
index|[
name|block
index|]
argument_list|)
decl_stmt|;
name|byte
index|[]
name|magic
init|=
operator|new
name|byte
index|[
name|METABLOCKMAGIC
operator|.
name|length
index|]
decl_stmt|;
name|buf
operator|.
name|get
argument_list|(
name|magic
argument_list|,
literal|0
argument_list|,
name|magic
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|magic
argument_list|,
name|METABLOCKMAGIC
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Meta magic is bad in block "
operator|+
name|block
argument_list|)
throw|;
block|}
comment|// Toss the header. May have to remove later due to performance.
name|buf
operator|.
name|compact
argument_list|()
expr_stmt|;
name|buf
operator|.
name|limit
argument_list|(
name|buf
operator|.
name|limit
argument_list|()
operator|-
name|METABLOCKMAGIC
operator|.
name|length
argument_list|)
expr_stmt|;
name|buf
operator|.
name|rewind
argument_list|()
expr_stmt|;
return|return
name|buf
return|;
block|}
comment|/**      * Read in a file block.      * @param block Index of block to read.      * @return Block wrapped in a ByteBuffer.      * @throws IOException      */
name|ByteBuffer
name|readBlock
parameter_list|(
name|int
name|block
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|blockIndex
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block index not loaded"
argument_list|)
throw|;
block|}
if|if
condition|(
name|block
argument_list|<
literal|0
operator|||
name|block
argument_list|>
name|blockIndex
operator|.
name|count
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Requested block is out of range: "
operator|+
name|block
operator|+
literal|", max: "
operator|+
name|blockIndex
operator|.
name|count
argument_list|)
throw|;
block|}
comment|// For any given block from any given file, synchronize reads for said
comment|// block.
comment|// Without a cache, this synchronizing is needless overhead, but really
comment|// the other choice is to duplicate work (which the cache would prevent you from doing).
synchronized|synchronized
init|(
name|blockIndex
operator|.
name|blockKeys
index|[
name|block
index|]
init|)
block|{
name|blockLoads
operator|++
expr_stmt|;
comment|// Check cache for block.  If found return.
if|if
condition|(
name|cache
operator|!=
literal|null
condition|)
block|{
name|ByteBuffer
name|cachedBuf
init|=
name|cache
operator|.
name|getBlock
argument_list|(
name|name
operator|+
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|cachedBuf
operator|!=
literal|null
condition|)
block|{
comment|// Return a distinct 'copy' of the block, so pos doesnt get messed by
comment|// the scanner
name|cacheHits
operator|++
expr_stmt|;
return|return
name|cachedBuf
operator|.
name|duplicate
argument_list|()
return|;
block|}
comment|// Carry on, please load.
block|}
comment|// Load block from filesystem.
name|long
name|onDiskBlockSize
decl_stmt|;
if|if
condition|(
name|block
operator|==
name|blockIndex
operator|.
name|count
operator|-
literal|1
condition|)
block|{
comment|// last block!  The end of data block is first meta block if there is
comment|// one or if there isn't, the fileinfo offset.
name|long
name|offset
init|=
name|this
operator|.
name|metaIndex
operator|!=
literal|null
condition|?
name|this
operator|.
name|metaIndex
operator|.
name|blockOffsets
index|[
literal|0
index|]
else|:
name|this
operator|.
name|trailer
operator|.
name|fileinfoOffset
decl_stmt|;
name|onDiskBlockSize
operator|=
name|offset
operator|-
name|blockIndex
operator|.
name|blockOffsets
index|[
name|block
index|]
expr_stmt|;
block|}
else|else
block|{
name|onDiskBlockSize
operator|=
name|blockIndex
operator|.
name|blockOffsets
index|[
name|block
operator|+
literal|1
index|]
operator|-
name|blockIndex
operator|.
name|blockOffsets
index|[
name|block
index|]
expr_stmt|;
block|}
name|ByteBuffer
name|buf
init|=
name|decompress
argument_list|(
name|blockIndex
operator|.
name|blockOffsets
index|[
name|block
index|]
argument_list|,
name|longToInt
argument_list|(
name|onDiskBlockSize
argument_list|)
argument_list|,
name|this
operator|.
name|blockIndex
operator|.
name|blockDataSizes
index|[
name|block
index|]
argument_list|)
decl_stmt|;
name|byte
index|[]
name|magic
init|=
operator|new
name|byte
index|[
name|DATABLOCKMAGIC
operator|.
name|length
index|]
decl_stmt|;
name|buf
operator|.
name|get
argument_list|(
name|magic
argument_list|,
literal|0
argument_list|,
name|magic
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|magic
argument_list|,
name|DATABLOCKMAGIC
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Data magic is bad in block "
operator|+
name|block
argument_list|)
throw|;
block|}
comment|// Toss the header. May have to remove later due to performance.
name|buf
operator|.
name|compact
argument_list|()
expr_stmt|;
name|buf
operator|.
name|limit
argument_list|(
name|buf
operator|.
name|limit
argument_list|()
operator|-
name|DATABLOCKMAGIC
operator|.
name|length
argument_list|)
expr_stmt|;
name|buf
operator|.
name|rewind
argument_list|()
expr_stmt|;
comment|// Cache a copy, not the one we are sending back, so the position doesnt
comment|// get messed.
if|if
condition|(
name|cache
operator|!=
literal|null
condition|)
block|{
name|cache
operator|.
name|cacheBlock
argument_list|(
name|name
operator|+
name|block
argument_list|,
name|buf
operator|.
name|duplicate
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
block|}
comment|/*      * Decompress<code>compressedSize</code> bytes off the backing      * FSDataInputStream.      * @param offset      * @param compressedSize      * @param decompressedSize      * @return      * @throws IOException      */
specifier|private
name|ByteBuffer
name|decompress
parameter_list|(
specifier|final
name|long
name|offset
parameter_list|,
specifier|final
name|int
name|compressedSize
parameter_list|,
specifier|final
name|int
name|decompressedSize
parameter_list|)
throws|throws
name|IOException
block|{
name|Decompressor
name|decompressor
init|=
name|this
operator|.
name|compressAlgo
operator|.
name|getDecompressor
argument_list|()
decl_stmt|;
comment|// My guess is that the bounded range fis is needed to stop the
comment|// decompressor reading into next block -- IIRC, it just grabs a
comment|// bunch of data w/o regard to whether decompressor is coming to end of a
comment|// decompression.
name|InputStream
name|is
init|=
name|this
operator|.
name|compressAlgo
operator|.
name|createDecompressionStream
argument_list|(
operator|new
name|BoundedRangeFileInputStream
argument_list|(
name|this
operator|.
name|istream
argument_list|,
name|offset
argument_list|,
name|compressedSize
argument_list|)
argument_list|,
name|decompressor
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ByteBuffer
name|buf
init|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|decompressedSize
argument_list|)
decl_stmt|;
name|IOUtils
operator|.
name|readFully
argument_list|(
name|is
argument_list|,
name|buf
operator|.
name|array
argument_list|()
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|capacity
argument_list|()
argument_list|)
expr_stmt|;
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
name|this
operator|.
name|compressAlgo
operator|.
name|returnDecompressor
argument_list|(
name|decompressor
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
comment|/**      * @return First key in the file.      */
specifier|public
name|byte
index|[]
name|getFirstKey
parameter_list|()
block|{
if|if
condition|(
name|blockIndex
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Block index not loaded"
argument_list|)
throw|;
block|}
return|return
name|blockIndex
operator|.
name|blockKeys
index|[
literal|0
index|]
return|;
block|}
specifier|public
name|int
name|getEntries
parameter_list|()
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|isFileInfoLoaded
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"File info not loaded"
argument_list|)
throw|;
block|}
return|return
name|this
operator|.
name|trailer
operator|.
name|entryCount
return|;
block|}
comment|/**      * @return Last key in the file.      */
specifier|public
name|byte
index|[]
name|getLastKey
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isFileInfoLoaded
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Load file info first"
argument_list|)
throw|;
block|}
return|return
name|this
operator|.
name|lastkey
return|;
block|}
comment|/**      * @return Comparator.      */
specifier|public
name|RawComparator
argument_list|<
name|byte
index|[]
argument_list|>
name|getComparator
parameter_list|()
block|{
return|return
name|this
operator|.
name|comparator
return|;
block|}
comment|/**      * @return index size      */
specifier|public
name|long
name|indexSize
parameter_list|()
block|{
return|return
operator|(
name|this
operator|.
name|blockIndex
operator|!=
literal|null
condition|?
name|this
operator|.
name|blockIndex
operator|.
name|heapSize
argument_list|()
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|this
operator|.
name|metaIndex
operator|!=
literal|null
operator|)
condition|?
name|this
operator|.
name|metaIndex
operator|.
name|heapSize
argument_list|()
else|:
literal|0
operator|)
return|;
block|}
comment|/**      * @return Midkey for this file.  We work with block boundaries only so      * returned midkey is an approximation only.      * @throws IOException      */
specifier|public
name|byte
index|[]
name|midkey
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isFileInfoLoaded
argument_list|()
operator|||
name|this
operator|.
name|blockIndex
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|this
operator|.
name|blockIndex
operator|.
name|midkey
argument_list|()
return|;
block|}
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|closeIStream
operator|&&
name|this
operator|.
name|istream
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|istream
operator|.
name|close
argument_list|()
expr_stmt|;
name|this
operator|.
name|istream
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/*      * Implementation of {@link HFileScanner} interface.      */
specifier|private
specifier|static
class|class
name|Scanner
implements|implements
name|HFileScanner
block|{
specifier|private
specifier|final
name|Reader
name|reader
decl_stmt|;
specifier|private
name|ByteBuffer
name|block
decl_stmt|;
specifier|private
name|int
name|currBlock
decl_stmt|;
specifier|private
name|int
name|currKeyLen
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|currValueLen
init|=
literal|0
decl_stmt|;
specifier|public
name|int
name|blockFetches
init|=
literal|0
decl_stmt|;
specifier|public
name|Scanner
parameter_list|(
name|Reader
name|r
parameter_list|)
block|{
name|this
operator|.
name|reader
operator|=
name|r
expr_stmt|;
block|}
specifier|public
name|KeyValue
name|getKeyValue
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|block
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|KeyValue
argument_list|(
name|this
operator|.
name|block
operator|.
name|array
argument_list|()
argument_list|,
name|this
operator|.
name|block
operator|.
name|arrayOffset
argument_list|()
operator|+
name|this
operator|.
name|block
operator|.
name|position
argument_list|()
operator|-
literal|8
argument_list|)
return|;
block|}
specifier|public
name|ByteBuffer
name|getKey
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|block
operator|==
literal|null
operator|||
name|this
operator|.
name|currKeyLen
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"you need to seekTo() before calling getKey()"
argument_list|)
throw|;
block|}
name|ByteBuffer
name|keyBuff
init|=
name|this
operator|.
name|block
operator|.
name|slice
argument_list|()
decl_stmt|;
name|keyBuff
operator|.
name|limit
argument_list|(
name|this
operator|.
name|currKeyLen
argument_list|)
expr_stmt|;
name|keyBuff
operator|.
name|rewind
argument_list|()
expr_stmt|;
comment|// Do keyBuff.asReadOnly()?
return|return
name|keyBuff
return|;
block|}
specifier|public
name|ByteBuffer
name|getValue
parameter_list|()
block|{
if|if
condition|(
name|block
operator|==
literal|null
operator|||
name|currKeyLen
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"you need to seekTo() before calling getValue()"
argument_list|)
throw|;
block|}
comment|// TODO: Could this be done with one ByteBuffer rather than create two?
name|ByteBuffer
name|valueBuff
init|=
name|this
operator|.
name|block
operator|.
name|slice
argument_list|()
decl_stmt|;
name|valueBuff
operator|.
name|position
argument_list|(
name|this
operator|.
name|currKeyLen
argument_list|)
expr_stmt|;
name|valueBuff
operator|=
name|valueBuff
operator|.
name|slice
argument_list|()
expr_stmt|;
name|valueBuff
operator|.
name|limit
argument_list|(
name|currValueLen
argument_list|)
expr_stmt|;
name|valueBuff
operator|.
name|rewind
argument_list|()
expr_stmt|;
return|return
name|valueBuff
return|;
block|}
specifier|public
name|boolean
name|next
parameter_list|()
throws|throws
name|IOException
block|{
comment|// LOG.deug("rem:" + block.remaining() + " p:" + block.position() +
comment|// " kl: " + currKeyLen + " kv: " + currValueLen);
if|if
condition|(
name|block
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Next called on non-seeked scanner"
argument_list|)
throw|;
block|}
name|block
operator|.
name|position
argument_list|(
name|block
operator|.
name|position
argument_list|()
operator|+
name|currKeyLen
operator|+
name|currValueLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|.
name|remaining
argument_list|()
operator|<=
literal|0
condition|)
block|{
comment|// LOG.debug("Fetch next block");
name|currBlock
operator|++
expr_stmt|;
if|if
condition|(
name|currBlock
operator|>=
name|reader
operator|.
name|blockIndex
operator|.
name|count
condition|)
block|{
comment|// damn we are at the end
name|currBlock
operator|=
literal|0
expr_stmt|;
name|block
operator|=
literal|null
expr_stmt|;
return|return
literal|false
return|;
block|}
name|block
operator|=
name|reader
operator|.
name|readBlock
argument_list|(
name|currBlock
argument_list|)
expr_stmt|;
name|currKeyLen
operator|=
name|block
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|currValueLen
operator|=
name|block
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|blockFetches
operator|++
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// LOG.debug("rem:" + block.remaining() + " p:" + block.position() +
comment|// " kl: " + currKeyLen + " kv: " + currValueLen);
name|currKeyLen
operator|=
name|block
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|currValueLen
operator|=
name|block
operator|.
name|getInt
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
name|int
name|seekTo
parameter_list|(
name|byte
index|[]
name|key
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|seekTo
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|length
argument_list|)
return|;
block|}
specifier|public
name|int
name|seekTo
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|b
init|=
name|reader
operator|.
name|blockContainingKey
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|// falls before the beginning of the file! :-(
comment|// Avoid re-reading the same block (that'd be dumb).
name|loadBlock
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|blockSeek
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**        * Within a loaded block, seek looking for the first key        * that is smaller than (or equal to?) the key we are interested in.        *         * A note on the seekBefore - if you have seekBefore = true, AND the        * first key in the block = key, then you'll get thrown exceptions.        * @param key to find        * @param seekBefore find the key before the exact match.        * @return        */
specifier|private
name|int
name|blockSeek
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|seekBefore
parameter_list|)
block|{
name|int
name|klen
decl_stmt|,
name|vlen
decl_stmt|;
name|int
name|lastLen
init|=
literal|0
decl_stmt|;
do|do
block|{
name|klen
operator|=
name|block
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|vlen
operator|=
name|block
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|int
name|comp
init|=
name|this
operator|.
name|reader
operator|.
name|comparator
operator|.
name|compare
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|block
operator|.
name|array
argument_list|()
argument_list|,
name|block
operator|.
name|arrayOffset
argument_list|()
operator|+
name|block
operator|.
name|position
argument_list|()
argument_list|,
name|klen
argument_list|)
decl_stmt|;
if|if
condition|(
name|comp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|seekBefore
condition|)
block|{
name|block
operator|.
name|position
argument_list|(
name|block
operator|.
name|position
argument_list|()
operator|-
name|lastLen
operator|-
literal|16
argument_list|)
expr_stmt|;
name|currKeyLen
operator|=
name|block
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|currValueLen
operator|=
name|block
operator|.
name|getInt
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
comment|// non exact match.
block|}
name|currKeyLen
operator|=
name|klen
expr_stmt|;
name|currValueLen
operator|=
name|vlen
expr_stmt|;
return|return
literal|0
return|;
comment|// indicate exact match
block|}
if|if
condition|(
name|comp
operator|<
literal|0
condition|)
block|{
comment|// go back one key:
name|block
operator|.
name|position
argument_list|(
name|block
operator|.
name|position
argument_list|()
operator|-
name|lastLen
operator|-
literal|16
argument_list|)
expr_stmt|;
name|currKeyLen
operator|=
name|block
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|currValueLen
operator|=
name|block
operator|.
name|getInt
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
name|block
operator|.
name|position
argument_list|(
name|block
operator|.
name|position
argument_list|()
operator|+
name|klen
operator|+
name|vlen
argument_list|)
expr_stmt|;
name|lastLen
operator|=
name|klen
operator|+
name|vlen
expr_stmt|;
block|}
do|while
condition|(
name|block
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
do|;
comment|// ok we are at the end, so go back a littleeeeee....
comment|// The 8 in the below is intentionally different to the 16s in the above
comment|// Do the math you you'll figure it.
name|block
operator|.
name|position
argument_list|(
name|block
operator|.
name|position
argument_list|()
operator|-
name|lastLen
operator|-
literal|8
argument_list|)
expr_stmt|;
name|currKeyLen
operator|=
name|block
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|currValueLen
operator|=
name|block
operator|.
name|getInt
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
comment|// didn't exactly find it.
block|}
specifier|public
name|boolean
name|seekBefore
parameter_list|(
name|byte
index|[]
name|key
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|seekBefore
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|length
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|seekBefore
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|b
init|=
name|reader
operator|.
name|blockContainingKey
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|<
literal|0
condition|)
return|return
literal|false
return|;
comment|// key is before the start of the file.
comment|// Question: does this block begin with 'key'?
if|if
condition|(
name|this
operator|.
name|reader
operator|.
name|comparator
operator|.
name|compare
argument_list|(
name|reader
operator|.
name|blockIndex
operator|.
name|blockKeys
index|[
name|b
index|]
argument_list|,
literal|0
argument_list|,
name|reader
operator|.
name|blockIndex
operator|.
name|blockKeys
index|[
name|b
index|]
operator|.
name|length
argument_list|,
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// Ok the key we're interested in is the first of the block, so go back one.
if|if
condition|(
name|b
operator|==
literal|0
condition|)
block|{
comment|// we have a 'problem', the key we want is the first of the file.
return|return
literal|false
return|;
block|}
name|b
operator|--
expr_stmt|;
comment|// TODO shortcut: seek forward in this block to the last key of the block.
block|}
name|loadBlock
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|blockSeek
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
name|String
name|getKeyString
parameter_list|()
block|{
return|return
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|block
operator|.
name|array
argument_list|()
argument_list|,
name|block
operator|.
name|arrayOffset
argument_list|()
operator|+
name|block
operator|.
name|position
argument_list|()
argument_list|,
name|currKeyLen
argument_list|)
return|;
block|}
specifier|public
name|String
name|getValueString
parameter_list|()
block|{
return|return
name|Bytes
operator|.
name|toString
argument_list|(
name|block
operator|.
name|array
argument_list|()
argument_list|,
name|block
operator|.
name|arrayOffset
argument_list|()
operator|+
name|block
operator|.
name|position
argument_list|()
operator|+
name|currKeyLen
argument_list|,
name|currValueLen
argument_list|)
return|;
block|}
specifier|public
name|Reader
name|getReader
parameter_list|()
block|{
return|return
name|this
operator|.
name|reader
return|;
block|}
specifier|public
name|boolean
name|isSeeked
parameter_list|()
block|{
return|return
name|this
operator|.
name|block
operator|!=
literal|null
return|;
block|}
specifier|public
name|boolean
name|seekTo
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|reader
operator|.
name|blockIndex
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|block
operator|!=
literal|null
operator|&&
name|currBlock
operator|==
literal|0
condition|)
block|{
name|block
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|currKeyLen
operator|=
name|block
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|currValueLen
operator|=
name|block
operator|.
name|getInt
argument_list|()
expr_stmt|;
block|}
name|currBlock
operator|=
literal|0
expr_stmt|;
name|block
operator|=
name|reader
operator|.
name|readBlock
argument_list|(
name|currBlock
argument_list|)
expr_stmt|;
name|currKeyLen
operator|=
name|block
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|currValueLen
operator|=
name|block
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|blockFetches
operator|++
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|loadBlock
parameter_list|(
name|int
name|bloc
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|block
operator|==
literal|null
condition|)
block|{
name|block
operator|=
name|reader
operator|.
name|readBlock
argument_list|(
name|bloc
argument_list|)
expr_stmt|;
name|currBlock
operator|=
name|bloc
expr_stmt|;
name|blockFetches
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bloc
operator|!=
name|currBlock
condition|)
block|{
name|block
operator|=
name|reader
operator|.
name|readBlock
argument_list|(
name|bloc
argument_list|)
expr_stmt|;
name|currBlock
operator|=
name|bloc
expr_stmt|;
name|blockFetches
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|// we are already in the same block, just rewind to seek again.
name|block
operator|.
name|rewind
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|public
name|String
name|getTrailerInfo
parameter_list|()
block|{
return|return
name|trailer
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/*    * The RFile has a fixed trailer which contains offsets to other variable    * parts of the file.  Also includes basic metadata on this file.    */
specifier|private
specifier|static
class|class
name|FixedFileTrailer
block|{
comment|// Offset to the data block index.
name|long
name|dataIndexOffset
decl_stmt|;
comment|// Offset to the fileinfo data, a small block of vitals..
name|long
name|fileinfoOffset
decl_stmt|;
comment|// How many index counts are there (aka: block count)
name|int
name|dataIndexCount
decl_stmt|;
comment|// Offset to the meta block index.
name|long
name|metaIndexOffset
decl_stmt|;
comment|// How many meta block index entries (aka: meta block count)
name|int
name|metaIndexCount
decl_stmt|;
name|long
name|totalUncompressedBytes
decl_stmt|;
name|int
name|entryCount
decl_stmt|;
name|int
name|compressionCodec
decl_stmt|;
name|int
name|version
init|=
literal|1
decl_stmt|;
name|FixedFileTrailer
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
specifier|static
name|int
name|trailerSize
parameter_list|()
block|{
comment|// Keep this up to date...
return|return
operator|(
name|Bytes
operator|.
name|SIZEOF_INT
operator|*
literal|5
operator|)
operator|+
operator|(
name|Bytes
operator|.
name|SIZEOF_LONG
operator|*
literal|4
operator|)
operator|+
name|TRAILERBLOCKMAGIC
operator|.
name|length
return|;
block|}
name|void
name|serialize
parameter_list|(
name|DataOutputStream
name|outputStream
parameter_list|)
throws|throws
name|IOException
block|{
name|outputStream
operator|.
name|write
argument_list|(
name|TRAILERBLOCKMAGIC
argument_list|)
expr_stmt|;
name|outputStream
operator|.
name|writeLong
argument_list|(
name|fileinfoOffset
argument_list|)
expr_stmt|;
name|outputStream
operator|.
name|writeLong
argument_list|(
name|dataIndexOffset
argument_list|)
expr_stmt|;
name|outputStream
operator|.
name|writeInt
argument_list|(
name|dataIndexCount
argument_list|)
expr_stmt|;
name|outputStream
operator|.
name|writeLong
argument_list|(
name|metaIndexOffset
argument_list|)
expr_stmt|;
name|outputStream
operator|.
name|writeInt
argument_list|(
name|metaIndexCount
argument_list|)
expr_stmt|;
name|outputStream
operator|.
name|writeLong
argument_list|(
name|totalUncompressedBytes
argument_list|)
expr_stmt|;
name|outputStream
operator|.
name|writeInt
argument_list|(
name|entryCount
argument_list|)
expr_stmt|;
name|outputStream
operator|.
name|writeInt
argument_list|(
name|compressionCodec
argument_list|)
expr_stmt|;
name|outputStream
operator|.
name|writeInt
argument_list|(
name|version
argument_list|)
expr_stmt|;
block|}
name|void
name|deserialize
parameter_list|(
name|DataInputStream
name|inputStream
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|header
init|=
operator|new
name|byte
index|[
name|TRAILERBLOCKMAGIC
operator|.
name|length
index|]
decl_stmt|;
name|inputStream
operator|.
name|readFully
argument_list|(
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|header
argument_list|,
name|TRAILERBLOCKMAGIC
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Trailer 'header' is wrong; does the trailer "
operator|+
literal|"size match content?"
argument_list|)
throw|;
block|}
name|fileinfoOffset
operator|=
name|inputStream
operator|.
name|readLong
argument_list|()
expr_stmt|;
name|dataIndexOffset
operator|=
name|inputStream
operator|.
name|readLong
argument_list|()
expr_stmt|;
name|dataIndexCount
operator|=
name|inputStream
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|metaIndexOffset
operator|=
name|inputStream
operator|.
name|readLong
argument_list|()
expr_stmt|;
name|metaIndexCount
operator|=
name|inputStream
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|totalUncompressedBytes
operator|=
name|inputStream
operator|.
name|readLong
argument_list|()
expr_stmt|;
name|entryCount
operator|=
name|inputStream
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|compressionCodec
operator|=
name|inputStream
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|version
operator|=
name|inputStream
operator|.
name|readInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|version
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Wrong version: "
operator|+
name|version
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"fileinfoOffset="
operator|+
name|fileinfoOffset
operator|+
literal|", dataIndexOffset="
operator|+
name|dataIndexOffset
operator|+
literal|", dataIndexCount="
operator|+
name|dataIndexCount
operator|+
literal|", metaIndexOffset="
operator|+
name|metaIndexOffset
operator|+
literal|", metaIndexCount="
operator|+
name|metaIndexCount
operator|+
literal|", totalBytes="
operator|+
name|totalUncompressedBytes
operator|+
literal|", entryCount="
operator|+
name|entryCount
operator|+
literal|", version="
operator|+
name|version
return|;
block|}
block|}
comment|/*    * The block index for a RFile.    * Used reading.    */
specifier|static
class|class
name|BlockIndex
implements|implements
name|HeapSize
block|{
comment|// How many actual items are there? The next insert location too.
name|int
name|count
init|=
literal|0
decl_stmt|;
name|byte
index|[]
index|[]
name|blockKeys
decl_stmt|;
name|long
index|[]
name|blockOffsets
decl_stmt|;
name|int
index|[]
name|blockDataSizes
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
comment|/* Needed doing lookup on blocks.      */
specifier|final
name|RawComparator
argument_list|<
name|byte
index|[]
argument_list|>
name|comparator
decl_stmt|;
comment|/*      * Shutdown default constructor      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|private
name|BlockIndex
parameter_list|()
block|{
name|this
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * @param c comparator used to compare keys.      */
name|BlockIndex
parameter_list|(
specifier|final
name|RawComparator
argument_list|<
name|byte
index|[]
argument_list|>
name|c
parameter_list|)
block|{
name|this
operator|.
name|comparator
operator|=
name|c
expr_stmt|;
comment|// Guess that cost of three arrays + this object is 4 * 8 bytes.
name|this
operator|.
name|size
operator|+=
operator|(
literal|4
operator|*
literal|8
operator|)
expr_stmt|;
block|}
comment|/**      * @return True if block index is empty.      */
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|this
operator|.
name|blockKeys
operator|.
name|length
operator|<=
literal|0
return|;
block|}
comment|/**      * Adds a new entry in the block index.      *       * @param key Last key in the block      * @param offset file offset where the block is stored      * @param dataSize the uncompressed data size      */
name|void
name|add
parameter_list|(
specifier|final
name|byte
index|[]
name|key
parameter_list|,
specifier|final
name|long
name|offset
parameter_list|,
specifier|final
name|int
name|dataSize
parameter_list|)
block|{
name|blockOffsets
index|[
name|count
index|]
operator|=
name|offset
expr_stmt|;
name|blockKeys
index|[
name|count
index|]
operator|=
name|key
expr_stmt|;
name|blockDataSizes
index|[
name|count
index|]
operator|=
name|dataSize
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|this
operator|.
name|size
operator|+=
operator|(
name|Bytes
operator|.
name|SIZEOF_INT
operator|*
literal|2
operator|+
name|key
operator|.
name|length
operator|)
expr_stmt|;
block|}
comment|/**      * @param key Key to find      * @return Offset of block containing<code>key</code> or -1 if this file      * does not contain the request.      */
name|int
name|blockContainingKey
parameter_list|(
specifier|final
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|pos
init|=
name|Bytes
operator|.
name|binarySearch
argument_list|(
name|blockKeys
argument_list|,
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|this
operator|.
name|comparator
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
name|pos
operator|++
expr_stmt|;
name|pos
operator|*=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
block|{
comment|// falls before the beginning of the file.
return|return
operator|-
literal|1
return|;
block|}
comment|// When switched to "first key in block" index, binarySearch now returns
comment|// the block with a firstKey< key.  This means the value we want is potentially
comment|// in the next block.
name|pos
operator|--
expr_stmt|;
comment|// in previous block.
return|return
name|pos
return|;
block|}
comment|// wow, a perfect hit, how unlikely?
return|return
name|pos
return|;
block|}
comment|/*      * @return File midkey.  Inexact.  Operates on block boundaries.  Does      * not go into blocks.      */
name|byte
index|[]
name|midkey
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|pos
init|=
operator|(
operator|(
name|this
operator|.
name|count
operator|-
literal|1
operator|)
operator|/
literal|2
operator|)
decl_stmt|;
comment|// middle of the index
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"HFile empty"
argument_list|)
throw|;
block|}
return|return
name|this
operator|.
name|blockKeys
index|[
name|pos
index|]
return|;
block|}
comment|/*      * Write out index. Whatever we write here must jibe with what      * BlockIndex#readIndex is expecting.  Make sure the two ends of the      * index serialization match.      * @param o      * @param keys      * @param offsets      * @param sizes      * @param c      * @return Position at which we entered the index.      * @throws IOException      */
specifier|static
name|long
name|writeIndex
parameter_list|(
specifier|final
name|FSDataOutputStream
name|o
parameter_list|,
specifier|final
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|keys
parameter_list|,
specifier|final
name|List
argument_list|<
name|Long
argument_list|>
name|offsets
parameter_list|,
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|sizes
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|pos
init|=
name|o
operator|.
name|getPos
argument_list|()
decl_stmt|;
comment|// Don't write an index if nothing in the index.
if|if
condition|(
name|keys
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|o
operator|.
name|write
argument_list|(
name|INDEXBLOCKMAGIC
argument_list|)
expr_stmt|;
comment|// Write the index.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keys
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|o
operator|.
name|writeLong
argument_list|(
name|offsets
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
name|o
operator|.
name|writeInt
argument_list|(
name|sizes
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
name|byte
index|[]
name|key
init|=
name|keys
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Bytes
operator|.
name|writeByteArray
argument_list|(
name|o
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|pos
return|;
block|}
comment|/*      * Read in the index that is at<code>indexOffset</code>      * Must match what was written by writeIndex in the Writer.close.      * @param in      * @param indexOffset      * @throws IOException      */
specifier|static
name|BlockIndex
name|readIndex
parameter_list|(
specifier|final
name|RawComparator
argument_list|<
name|byte
index|[]
argument_list|>
name|c
parameter_list|,
specifier|final
name|FSDataInputStream
name|in
parameter_list|,
specifier|final
name|long
name|indexOffset
parameter_list|,
specifier|final
name|int
name|indexSize
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockIndex
name|bi
init|=
operator|new
name|BlockIndex
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|bi
operator|.
name|blockOffsets
operator|=
operator|new
name|long
index|[
name|indexSize
index|]
expr_stmt|;
name|bi
operator|.
name|blockKeys
operator|=
operator|new
name|byte
index|[
name|indexSize
index|]
index|[]
expr_stmt|;
name|bi
operator|.
name|blockDataSizes
operator|=
operator|new
name|int
index|[
name|indexSize
index|]
expr_stmt|;
comment|// If index size is zero, no index was written.
if|if
condition|(
name|indexSize
operator|>
literal|0
condition|)
block|{
name|in
operator|.
name|seek
argument_list|(
name|indexOffset
argument_list|)
expr_stmt|;
name|byte
index|[]
name|magic
init|=
operator|new
name|byte
index|[
name|INDEXBLOCKMAGIC
operator|.
name|length
index|]
decl_stmt|;
name|IOUtils
operator|.
name|readFully
argument_list|(
name|in
argument_list|,
name|magic
argument_list|,
literal|0
argument_list|,
name|magic
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|magic
argument_list|,
name|INDEXBLOCKMAGIC
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Index block magic is wrong: "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|magic
argument_list|)
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|indexSize
condition|;
operator|++
name|i
control|)
block|{
name|long
name|offset
init|=
name|in
operator|.
name|readLong
argument_list|()
decl_stmt|;
name|int
name|dataSize
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|byte
index|[]
name|key
init|=
name|Bytes
operator|.
name|readByteArray
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|bi
operator|.
name|add
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|dataSize
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|bi
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"size="
operator|+
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"key="
argument_list|)
operator|.
name|append
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|blockKeys
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|", offset="
argument_list|)
operator|.
name|append
argument_list|(
name|blockOffsets
index|[
name|i
index|]
argument_list|)
operator|.
name|append
argument_list|(
literal|", dataSize="
operator|+
name|blockDataSizes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
name|long
name|heapSize
parameter_list|()
block|{
return|return
name|this
operator|.
name|size
return|;
block|}
block|}
comment|/*    * Metadata for this file.  Conjured by the writer.  Read in by the reader.    */
specifier|static
class|class
name|FileInfo
extends|extends
name|HbaseMapWritable
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
block|{
specifier|static
specifier|final
name|String
name|RESERVED_PREFIX
init|=
literal|"hfile."
decl_stmt|;
specifier|static
specifier|final
name|byte
index|[]
name|LASTKEY
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|RESERVED_PREFIX
operator|+
literal|"LASTKEY"
argument_list|)
decl_stmt|;
specifier|static
specifier|final
name|byte
index|[]
name|AVG_KEY_LEN
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|RESERVED_PREFIX
operator|+
literal|"AVG_KEY_LEN"
argument_list|)
decl_stmt|;
specifier|static
specifier|final
name|byte
index|[]
name|AVG_VALUE_LEN
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|RESERVED_PREFIX
operator|+
literal|"AVG_VALUE_LEN"
argument_list|)
decl_stmt|;
specifier|static
specifier|final
name|byte
index|[]
name|COMPARATOR
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|RESERVED_PREFIX
operator|+
literal|"COMPARATOR"
argument_list|)
decl_stmt|;
comment|/*      * Constructor.      */
name|FileInfo
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get names of supported compression algorithms. The names are acceptable by    * HFile.Writer.    *     * @return Array of strings, each represents a supported compression    *         algorithm. Currently, the following compression algorithms are    *         supported.    *<ul>    *<li>"none" - No compression.    *<li>"gz" - GZIP compression.    *</ul>    */
specifier|public
specifier|static
name|String
index|[]
name|getSupportedCompressionAlgorithms
parameter_list|()
block|{
return|return
name|Compression
operator|.
name|getSupportedAlgorithms
argument_list|()
return|;
block|}
comment|// Utility methods.
comment|/*    * @param l Long to convert to an int.    * @return<code>l</code> cast as an int.    */
specifier|static
name|int
name|longToInt
parameter_list|(
specifier|final
name|long
name|l
parameter_list|)
block|{
comment|// Expecting the size() of a block not exceeding 4GB. Assuming the
comment|// size() will wrap to negative integer if it exceeds 2GB (From tfile).
return|return
call|(
name|int
call|)
argument_list|(
name|l
operator|&
literal|0x00000000ffffffffL
argument_list|)
return|;
block|}
block|}
end_class

end_unit

