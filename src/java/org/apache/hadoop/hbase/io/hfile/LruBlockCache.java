begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2009 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|HeapSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|BlockCache
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_comment
comment|/**  * The LruBlockCache is a memory-aware HashMap with a configurable maximum  * memory footprint.  This is a modified version of LruHashMap specialized  * for use as the HBase block cache map.  Keys are String, and values are   * ByteBuffer.  *<p>  * It maintains an ordered list of all entries in the map ordered by   * access time.  When space needs to be freed becase the maximum has been   * reached, or the application has asked to free memory, entries will be  * evicted according to an LRU (least-recently-used) algorithm.  That is,  * those entries which have not been accessed the longest will be evicted  * first.  *<p>  * This class contains internal synchronization and is thread-safe.  */
end_comment

begin_class
specifier|public
class|class
name|LruBlockCache
implements|implements
name|HeapSize
implements|,
name|Map
argument_list|<
name|String
argument_list|,
name|ByteBuffer
argument_list|>
implements|,
name|BlockCache
block|{
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|LruBlockCache
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** The default size (in bytes) of the LRU */
specifier|public
specifier|static
specifier|final
name|long
name|DEFAULT_MAX_MEM_USAGE
init|=
literal|50000000
decl_stmt|;
comment|/** The default capacity of the hash table */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_INITIAL_CAPACITY
init|=
literal|16
decl_stmt|;
comment|/** The maxmum capacity of the hash table */
specifier|private
specifier|static
specifier|final
name|int
name|MAXIMUM_CAPACITY
init|=
literal|1
operator|<<
literal|30
decl_stmt|;
comment|/** The default load factor to use */
specifier|public
specifier|static
specifier|final
name|float
name|DEFAULT_LOAD_FACTOR
init|=
literal|0.75f
decl_stmt|;
comment|/** Memory overhead of this Object (for HeapSize) */
specifier|private
specifier|static
specifier|final
name|int
name|OVERHEAD
init|=
literal|5
operator|*
name|HeapSize
operator|.
name|LONG
operator|+
literal|2
operator|*
name|HeapSize
operator|.
name|INT
operator|+
literal|2
operator|*
name|HeapSize
operator|.
name|FLOAT
operator|+
literal|3
operator|*
name|HeapSize
operator|.
name|REFERENCE
operator|+
literal|1
operator|*
name|HeapSize
operator|.
name|ARRAY
decl_stmt|;
comment|/** Load factor allowed (usually 75%) */
specifier|private
specifier|final
name|float
name|loadFactor
decl_stmt|;
comment|/** Number of key/vals in the map */
specifier|private
name|int
name|size
decl_stmt|;
comment|/** Size at which we grow hash */
specifier|private
name|int
name|threshold
decl_stmt|;
comment|/** Entries in the map */
specifier|private
name|Entry
index|[]
name|entries
decl_stmt|;
comment|/** Pointer to least recently used entry */
specifier|private
name|Entry
name|headPtr
decl_stmt|;
comment|/** Pointer to most recently used entry */
specifier|private
name|Entry
name|tailPtr
decl_stmt|;
comment|/** Maximum memory usage of this map */
specifier|private
name|long
name|memTotal
init|=
literal|0
decl_stmt|;
comment|/** Amount of available memory */
specifier|private
name|long
name|memFree
init|=
literal|0
decl_stmt|;
comment|/** Number of successful (found) get() calls */
specifier|private
name|long
name|hitCount
init|=
literal|0
decl_stmt|;
comment|/** Number of unsuccessful (not found) get() calls */
specifier|private
name|long
name|missCount
init|=
literal|0
decl_stmt|;
comment|/**    * Constructs a new, empty map with the specified initial capacity,    * load factor, and maximum memory usage.    *    * @param initialCapacity the initial capacity    * @param loadFactor the load factor    * @param maxMemUsage the maximum total memory usage    * @throws IllegalArgumentException if the initial capacity is less than one    * @throws IllegalArgumentException if the initial capacity is greater than    * the maximum capacity    * @throws IllegalArgumentException if the load factor is<= 0    * @throws IllegalArgumentException if the max memory usage is too small    * to support the base overhead    */
specifier|public
name|LruBlockCache
parameter_list|(
name|int
name|initialCapacity
parameter_list|,
name|float
name|loadFactor
parameter_list|,
name|long
name|maxMemUsage
parameter_list|)
block|{
if|if
condition|(
name|initialCapacity
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Initial capacity must be> 0"
argument_list|)
throw|;
block|}
if|if
condition|(
name|initialCapacity
operator|>
name|MAXIMUM_CAPACITY
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Initial capacity is too large"
argument_list|)
throw|;
block|}
if|if
condition|(
name|loadFactor
operator|<=
literal|0
operator|||
name|Float
operator|.
name|isNaN
argument_list|(
name|loadFactor
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Load factor must be> 0"
argument_list|)
throw|;
block|}
if|if
condition|(
name|maxMemUsage
operator|<=
operator|(
name|OVERHEAD
operator|+
name|initialCapacity
operator|*
name|HeapSize
operator|.
name|REFERENCE
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Max memory usage too small to "
operator|+
literal|"support base overhead"
argument_list|)
throw|;
block|}
comment|/** Find a power of 2>= initialCapacity */
name|int
name|capacity
init|=
name|calculateCapacity
argument_list|(
name|initialCapacity
argument_list|)
decl_stmt|;
name|this
operator|.
name|loadFactor
operator|=
name|loadFactor
expr_stmt|;
name|this
operator|.
name|threshold
operator|=
name|calculateThreshold
argument_list|(
name|capacity
argument_list|,
name|loadFactor
argument_list|)
expr_stmt|;
name|this
operator|.
name|entries
operator|=
operator|new
name|Entry
index|[
name|capacity
index|]
expr_stmt|;
name|this
operator|.
name|memFree
operator|=
name|maxMemUsage
expr_stmt|;
name|this
operator|.
name|memTotal
operator|=
name|maxMemUsage
expr_stmt|;
name|init
argument_list|()
expr_stmt|;
block|}
comment|/**    * Constructs a new, empty map with the specified initial capacity and    * load factor, and default maximum memory usage.    *    * @param initialCapacity the initial capacity    * @param loadFactor the load factor    * @throws IllegalArgumentException if the initial capacity is less than one    * @throws IllegalArgumentException if the initial capacity is greater than    * the maximum capacity    * @throws IllegalArgumentException if the load factor is<= 0    */
specifier|public
name|LruBlockCache
parameter_list|(
name|int
name|initialCapacity
parameter_list|,
name|float
name|loadFactor
parameter_list|)
block|{
name|this
argument_list|(
name|initialCapacity
argument_list|,
name|loadFactor
argument_list|,
name|DEFAULT_MAX_MEM_USAGE
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs a new, empty map with the specified initial capacity and    * with the default load factor and maximum memory usage.    *    * @param initialCapacity the initial capacity    * @throws IllegalArgumentException if the initial capacity is less than one    * @throws IllegalArgumentException if the initial capacity is greater than    * the maximum capacity    */
specifier|public
name|LruBlockCache
parameter_list|(
name|int
name|initialCapacity
parameter_list|)
block|{
name|this
argument_list|(
name|initialCapacity
argument_list|,
name|DEFAULT_LOAD_FACTOR
argument_list|,
name|DEFAULT_MAX_MEM_USAGE
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs a new, empty map with the specified maximum memory usage    * and with default initial capacity and load factor.    *    * @param maxMemUsage the maximum total memory usage    * @throws IllegalArgumentException if the max memory usage is too small    * to support the base overhead    */
specifier|public
name|LruBlockCache
parameter_list|(
name|long
name|maxMemUsage
parameter_list|)
block|{
name|this
argument_list|(
name|DEFAULT_INITIAL_CAPACITY
argument_list|,
name|DEFAULT_LOAD_FACTOR
argument_list|,
name|maxMemUsage
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs a new, empty map with the default initial capacity,     * load factor and maximum memory usage.    */
specifier|public
name|LruBlockCache
parameter_list|()
block|{
name|this
argument_list|(
name|DEFAULT_INITIAL_CAPACITY
argument_list|,
name|DEFAULT_LOAD_FACTOR
argument_list|,
name|DEFAULT_MAX_MEM_USAGE
argument_list|)
expr_stmt|;
block|}
comment|//--------------------------------------------------------------------------
comment|/**    * BlockCache Implementation    */
comment|/**    * Returns the ByteBuffer associated with the specified blockName, or null    * if none exists.    *    * @param blockName block identifier    * @return the ByteBuffer associated with the block name, or null    */
specifier|public
specifier|synchronized
name|ByteBuffer
name|getBlock
parameter_list|(
name|String
name|blockName
parameter_list|)
block|{
return|return
name|get
argument_list|(
name|blockName
argument_list|)
return|;
block|}
comment|/**    * Inserts the specified ByteBuffer into the LRU map with the specified    * blockName as the key.    *    * This automatically handles evicting other blocks if the LRU is full.    *    * @param blockName block identifier    * @param buf the ByteBuffer associated with the block name    */
specifier|public
specifier|synchronized
name|void
name|cacheBlock
parameter_list|(
name|String
name|blockName
parameter_list|,
name|ByteBuffer
name|buf
parameter_list|)
block|{
name|put
argument_list|(
name|blockName
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
comment|//--------------------------------------------------------------------------
comment|/**    * Get the currently available memory for this LRU in bytes.    * This is (maxAllowed - currentlyUsed).    *    * @return currently available bytes    */
specifier|public
name|long
name|getMemFree
parameter_list|()
block|{
return|return
name|memFree
return|;
block|}
comment|/**    * Get the maximum memory allowed for this LRU in bytes.    *    * @return maximum allowed bytes    */
specifier|public
name|long
name|getMemMax
parameter_list|()
block|{
return|return
name|memTotal
return|;
block|}
comment|/**    * Get the currently used memory for this LRU in bytes.    *    * @return currently used memory in bytes    */
specifier|public
name|long
name|getMemUsed
parameter_list|()
block|{
return|return
operator|(
name|memTotal
operator|-
name|memFree
operator|)
return|;
block|}
comment|/**    * Get the number of hits to the map.  This is the number of times    * a call to get() returns a matched key.    *    * @return number of hits    */
specifier|public
name|long
name|getHitCount
parameter_list|()
block|{
return|return
name|hitCount
return|;
block|}
comment|/**    * Get the number of misses to the map.  This is the number of times    * a call to get() returns null.    *    * @return number of misses    */
specifier|public
name|long
name|getMissCount
parameter_list|()
block|{
return|return
name|missCount
return|;
block|}
comment|/**    * Get the hit ratio.  This is the number of hits divided by the    * total number of requests.    *    * @return hit ratio (double between 0 and 1)    */
specifier|public
name|double
name|getHitRatio
parameter_list|()
block|{
return|return
call|(
name|double
call|)
argument_list|(
operator|(
name|double
operator|)
name|hitCount
operator|/
operator|(
call|(
name|double
call|)
argument_list|(
name|hitCount
operator|+
name|missCount
argument_list|)
operator|)
argument_list|)
return|;
block|}
comment|/**    * Free the requested amount of memory from the LRU map.    *    * This will do LRU eviction from the map until at least as much    * memory as requested is freed.  This does not affect the maximum    * memory usage parameter.    *    * @param requestedAmount memory to free from LRU in bytes    * @return actual amount of memory freed in bytes    */
specifier|public
specifier|synchronized
name|long
name|freeMemory
parameter_list|(
name|long
name|requestedAmount
parameter_list|)
throws|throws
name|Exception
block|{
name|long
name|minMemory
init|=
name|getMinimumUsage
argument_list|()
decl_stmt|;
if|if
condition|(
name|requestedAmount
operator|>
operator|(
name|getMemUsed
argument_list|()
operator|-
name|getMinimumUsage
argument_list|()
operator|)
condition|)
block|{
return|return
name|clearAll
argument_list|()
return|;
block|}
name|long
name|freedMemory
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|freedMemory
operator|<
name|requestedAmount
condition|)
block|{
name|freedMemory
operator|+=
name|evictFromLru
argument_list|()
expr_stmt|;
block|}
return|return
name|freedMemory
return|;
block|}
comment|/**    * The total memory usage of this map    *    * @return memory usage of map in bytes    */
specifier|public
name|long
name|heapSize
parameter_list|()
block|{
return|return
operator|(
name|memTotal
operator|-
name|memFree
operator|)
return|;
block|}
comment|//--------------------------------------------------------------------------
comment|/**    * Retrieves the value associated with the specified key.    *    * If an entry is found, it is updated in the LRU as the most recently    * used (last to be evicted) entry in the map.    *    * @param k the key    * @return the associated value, or null if none found    * @throws NullPointerException if key is null    */
specifier|public
specifier|synchronized
name|ByteBuffer
name|get
parameter_list|(
name|Object
name|k
parameter_list|)
block|{
name|String
name|key
init|=
operator|(
name|String
operator|)
name|k
decl_stmt|;
name|checkKey
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|int
name|i
init|=
name|hashIndex
argument_list|(
name|hash
argument_list|,
name|entries
operator|.
name|length
argument_list|)
decl_stmt|;
name|Entry
name|e
init|=
name|entries
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
name|missCount
operator|++
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|e
operator|.
name|hash
operator|==
name|hash
operator|&&
name|isEqual
argument_list|(
name|key
argument_list|,
name|e
operator|.
name|key
argument_list|)
condition|)
block|{
comment|// Hit!  Update position in LRU
name|hitCount
operator|++
expr_stmt|;
name|updateLru
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|e
operator|.
name|value
return|;
block|}
name|e
operator|=
name|e
operator|.
name|next
expr_stmt|;
block|}
block|}
comment|/**    * Insert a key-value mapping into the map.    *    * Entry will be inserted as the most recently used.    *    * Both the key and value are required to be Objects and must    * implement the HeapSize interface.    *    * @param key the key    * @param value the value    * @return the value that was previously mapped to this key, null if none    * @throws UnsupportedOperationException if either objects do not     * implement HeapSize    * @throws NullPointerException if the key or value is null    */
specifier|public
specifier|synchronized
name|ByteBuffer
name|put
parameter_list|(
name|String
name|key
parameter_list|,
name|ByteBuffer
name|value
parameter_list|)
block|{
name|checkKey
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|checkValue
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|int
name|i
init|=
name|hashIndex
argument_list|(
name|hash
argument_list|,
name|entries
operator|.
name|length
argument_list|)
decl_stmt|;
comment|// For old values
for|for
control|(
name|Entry
name|e
init|=
name|entries
index|[
name|i
index|]
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|next
control|)
block|{
if|if
condition|(
name|e
operator|.
name|hash
operator|==
name|hash
operator|&&
name|isEqual
argument_list|(
name|key
argument_list|,
name|e
operator|.
name|key
argument_list|)
condition|)
block|{
name|ByteBuffer
name|oldValue
init|=
name|e
operator|.
name|value
decl_stmt|;
name|long
name|memChange
init|=
name|e
operator|.
name|replaceValue
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|checkAndFreeMemory
argument_list|(
name|memChange
argument_list|)
expr_stmt|;
comment|// If replacing an old value for this key, update in LRU
name|updateLru
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|oldValue
return|;
block|}
block|}
name|long
name|memChange
init|=
name|addEntry
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|value
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|checkAndFreeMemory
argument_list|(
name|memChange
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/**    * Deletes the mapping for the specified key if it exists.    *    * @param key the key of the entry to be removed from the map    * @return the value associated with the specified key, or null    * if no mapping exists.    */
specifier|public
specifier|synchronized
name|ByteBuffer
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|Entry
name|e
init|=
name|removeEntryForKey
argument_list|(
operator|(
name|String
operator|)
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
return|return
literal|null
return|;
comment|// Add freed memory back to available
name|memFree
operator|+=
name|e
operator|.
name|heapSize
argument_list|()
expr_stmt|;
return|return
name|e
operator|.
name|value
return|;
block|}
comment|/**    * Gets the size (number of entries) of the map.    *    * @return size of the map    */
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|size
return|;
block|}
comment|/**    * Checks whether the map is currently empty.    *    * @return true if size of map is zero    */
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|size
operator|==
literal|0
return|;
block|}
comment|/**    * Clears all entries from the map.    *    * This frees all entries, tracking memory usage along the way.    * All references to entries are removed so they can be GC'd.    */
specifier|public
specifier|synchronized
name|void
name|clear
parameter_list|()
block|{
name|memFree
operator|+=
name|clearAll
argument_list|()
expr_stmt|;
block|}
comment|//--------------------------------------------------------------------------
comment|/**    * Checks whether there is a value in the map for the specified key.    *    * Does not affect the LRU.    *    * @param k the key to check    * @return true if the map contains a value for this key, false if not    * @throws NullPointerException if the key is null    */
specifier|public
specifier|synchronized
name|boolean
name|containsKey
parameter_list|(
name|Object
name|k
parameter_list|)
block|{
name|String
name|key
init|=
operator|(
name|String
operator|)
name|k
decl_stmt|;
name|checkKey
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|int
name|i
init|=
name|hashIndex
argument_list|(
name|hash
argument_list|,
name|entries
operator|.
name|length
argument_list|)
decl_stmt|;
name|Entry
name|e
init|=
name|entries
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|e
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|e
operator|.
name|hash
operator|==
name|hash
operator|&&
name|isEqual
argument_list|(
name|key
argument_list|,
name|e
operator|.
name|key
argument_list|)
condition|)
return|return
literal|true
return|;
name|e
operator|=
name|e
operator|.
name|next
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Checks whether this is a mapping which contains the specified value.    *     * Does not affect the LRU.  This is an inefficient operation.    *    * @param v the value to check    * @return true if the map contains an entry for this value, false    * if not    * @throws NullPointerException if the value is null    */
specifier|public
specifier|synchronized
name|boolean
name|containsValue
parameter_list|(
name|Object
name|v
parameter_list|)
block|{
name|ByteBuffer
name|value
init|=
operator|(
name|ByteBuffer
operator|)
name|v
decl_stmt|;
name|checkValue
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|Entry
index|[]
name|tab
init|=
name|entries
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tab
operator|.
name|length
condition|;
name|i
operator|++
control|)
for|for
control|(
name|Entry
name|e
init|=
name|tab
index|[
name|i
index|]
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|next
control|)
if|if
condition|(
name|value
operator|.
name|equals
argument_list|(
name|e
operator|.
name|value
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
comment|//--------------------------------------------------------------------------
comment|/**    * Enforces key constraints.  Null keys are not permitted and key must    * implement HeapSize.  It should not be necessary to verify the second    * constraint because that's enforced on instantiation?    *    * Can add other constraints in the future.    *    * @param key the key    * @throws NullPointerException if the key is null    * @throws UnsupportedOperationException if the key class does not    * implement the HeapSize interface    */
specifier|private
name|void
name|checkKey
parameter_list|(
name|String
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"null keys are not allowed"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Enforces value constraints.  Null values are not permitted and value must    * implement HeapSize.  It should not be necessary to verify the second    * constraint because that's enforced on instantiation?    *    * Can add other contraints in the future.    *    * @param value the value    * @throws NullPointerException if the value is null    * @throws UnsupportedOperationException if the value class does not    * implement the HeapSize interface    */
specifier|private
name|void
name|checkValue
parameter_list|(
name|ByteBuffer
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"null values are not allowed"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns the minimum memory usage of the base map structure.    *    * @return baseline memory overhead of object in bytes    */
specifier|private
name|long
name|getMinimumUsage
parameter_list|()
block|{
return|return
name|OVERHEAD
operator|+
operator|(
name|entries
operator|.
name|length
operator|*
name|HeapSize
operator|.
name|REFERENCE
operator|)
return|;
block|}
comment|//--------------------------------------------------------------------------
comment|/**    * Evicts and frees based on LRU until at least as much memory as requested    * is available.    *    * @param memNeeded the amount of memory needed in bytes    */
specifier|private
name|void
name|checkAndFreeMemory
parameter_list|(
name|long
name|memNeeded
parameter_list|)
block|{
while|while
condition|(
name|memFree
operator|<
name|memNeeded
condition|)
block|{
name|evictFromLru
argument_list|()
expr_stmt|;
block|}
name|memFree
operator|-=
name|memNeeded
expr_stmt|;
block|}
comment|/**    * Evicts based on LRU.  This removes all references and updates available    * memory.    *    * @return amount of memory freed in bytes    */
specifier|private
name|long
name|evictFromLru
parameter_list|()
block|{
name|long
name|freed
init|=
name|headPtr
operator|.
name|heapSize
argument_list|()
decl_stmt|;
name|memFree
operator|+=
name|freed
expr_stmt|;
name|removeEntry
argument_list|(
name|headPtr
argument_list|)
expr_stmt|;
return|return
name|freed
return|;
block|}
comment|/**    * Moves the specified entry to the most recently used slot of the    * LRU.  This is called whenever an entry is fetched.    *    * @param e entry that was accessed    */
specifier|private
name|void
name|updateLru
parameter_list|(
name|Entry
name|e
parameter_list|)
block|{
name|Entry
name|prev
init|=
name|e
operator|.
name|getPrevPtr
argument_list|()
decl_stmt|;
name|Entry
name|next
init|=
name|e
operator|.
name|getNextPtr
argument_list|()
decl_stmt|;
if|if
condition|(
name|next
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|prev
operator|!=
literal|null
condition|)
block|{
name|prev
operator|.
name|setNextPtr
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|.
name|setPrevPtr
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|headPtr
operator|=
name|next
expr_stmt|;
name|headPtr
operator|.
name|setPrevPtr
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
name|e
operator|.
name|setNextPtr
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|e
operator|.
name|setPrevPtr
argument_list|(
name|tailPtr
argument_list|)
expr_stmt|;
name|tailPtr
operator|.
name|setNextPtr
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|tailPtr
operator|=
name|e
expr_stmt|;
block|}
block|}
comment|/**    * Removes the specified entry from the map and LRU structure.    *    * @param entry entry to be removed    */
specifier|private
name|void
name|removeEntry
parameter_list|(
name|Entry
name|entry
parameter_list|)
block|{
name|String
name|k
init|=
name|entry
operator|.
name|key
decl_stmt|;
name|int
name|hash
init|=
name|entry
operator|.
name|hash
decl_stmt|;
name|int
name|i
init|=
name|hashIndex
argument_list|(
name|hash
argument_list|,
name|entries
operator|.
name|length
argument_list|)
decl_stmt|;
name|Entry
name|prev
init|=
name|entries
index|[
name|i
index|]
decl_stmt|;
name|Entry
name|e
init|=
name|prev
decl_stmt|;
while|while
condition|(
name|e
operator|!=
literal|null
condition|)
block|{
name|Entry
name|next
init|=
name|e
operator|.
name|next
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|hash
operator|==
name|hash
operator|&&
name|isEqual
argument_list|(
name|k
argument_list|,
name|e
operator|.
name|key
argument_list|)
condition|)
block|{
name|size
operator|--
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|e
condition|)
block|{
name|entries
index|[
name|i
index|]
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
name|Entry
name|prevPtr
init|=
name|e
operator|.
name|getPrevPtr
argument_list|()
decl_stmt|;
name|Entry
name|nextPtr
init|=
name|e
operator|.
name|getNextPtr
argument_list|()
decl_stmt|;
if|if
condition|(
name|prevPtr
operator|!=
literal|null
operator|&&
name|nextPtr
operator|!=
literal|null
condition|)
block|{
name|prevPtr
operator|.
name|setNextPtr
argument_list|(
name|nextPtr
argument_list|)
expr_stmt|;
name|nextPtr
operator|.
name|setPrevPtr
argument_list|(
name|prevPtr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prevPtr
operator|!=
literal|null
condition|)
block|{
name|tailPtr
operator|=
name|prevPtr
expr_stmt|;
name|prevPtr
operator|.
name|setNextPtr
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextPtr
operator|!=
literal|null
condition|)
block|{
name|headPtr
operator|=
name|nextPtr
expr_stmt|;
name|nextPtr
operator|.
name|setPrevPtr
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|prev
operator|=
name|e
expr_stmt|;
name|e
operator|=
name|next
expr_stmt|;
block|}
block|}
comment|/**    * Removes and returns the entry associated with the specified    * key.    *    * @param key key of the entry to be deleted    * @return entry that was removed, or null if none found    */
specifier|private
name|Entry
name|removeEntryForKey
parameter_list|(
name|String
name|key
parameter_list|)
block|{
name|int
name|hash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|int
name|i
init|=
name|hashIndex
argument_list|(
name|hash
argument_list|,
name|entries
operator|.
name|length
argument_list|)
decl_stmt|;
name|Entry
name|prev
init|=
name|entries
index|[
name|i
index|]
decl_stmt|;
name|Entry
name|e
init|=
name|prev
decl_stmt|;
while|while
condition|(
name|e
operator|!=
literal|null
condition|)
block|{
name|Entry
name|next
init|=
name|e
operator|.
name|next
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|hash
operator|==
name|hash
operator|&&
name|isEqual
argument_list|(
name|key
argument_list|,
name|e
operator|.
name|key
argument_list|)
condition|)
block|{
name|size
operator|--
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|e
condition|)
block|{
name|entries
index|[
name|i
index|]
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
comment|// Updating LRU
name|Entry
name|prevPtr
init|=
name|e
operator|.
name|getPrevPtr
argument_list|()
decl_stmt|;
name|Entry
name|nextPtr
init|=
name|e
operator|.
name|getNextPtr
argument_list|()
decl_stmt|;
if|if
condition|(
name|prevPtr
operator|!=
literal|null
operator|&&
name|nextPtr
operator|!=
literal|null
condition|)
block|{
name|prevPtr
operator|.
name|setNextPtr
argument_list|(
name|nextPtr
argument_list|)
expr_stmt|;
name|nextPtr
operator|.
name|setPrevPtr
argument_list|(
name|prevPtr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prevPtr
operator|!=
literal|null
condition|)
block|{
name|tailPtr
operator|=
name|prevPtr
expr_stmt|;
name|prevPtr
operator|.
name|setNextPtr
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextPtr
operator|!=
literal|null
condition|)
block|{
name|headPtr
operator|=
name|nextPtr
expr_stmt|;
name|nextPtr
operator|.
name|setPrevPtr
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|e
return|;
block|}
name|prev
operator|=
name|e
expr_stmt|;
name|e
operator|=
name|next
expr_stmt|;
block|}
return|return
name|e
return|;
block|}
comment|/**   * Adds a new entry with the specified key, value, hash code, and   * bucket index to the map.   *   * Also puts it in the bottom (most-recent) slot of the list and   * checks to see if we need to grow the array.   *   * @param hash hash value of key   * @param key the key   * @param value the value   * @param bucketIndex index into hash array to store this entry   * @return the amount of heap size used to store the new entry   */
specifier|private
name|long
name|addEntry
parameter_list|(
name|int
name|hash
parameter_list|,
name|String
name|key
parameter_list|,
name|ByteBuffer
name|value
parameter_list|,
name|int
name|bucketIndex
parameter_list|)
block|{
name|Entry
name|e
init|=
name|entries
index|[
name|bucketIndex
index|]
decl_stmt|;
name|Entry
name|newE
init|=
operator|new
name|Entry
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|value
argument_list|,
name|e
argument_list|,
name|tailPtr
argument_list|)
decl_stmt|;
name|entries
index|[
name|bucketIndex
index|]
operator|=
name|newE
expr_stmt|;
comment|// add as most recently used in lru
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|headPtr
operator|=
name|newE
expr_stmt|;
name|tailPtr
operator|=
name|newE
expr_stmt|;
block|}
else|else
block|{
name|newE
operator|.
name|setPrevPtr
argument_list|(
name|tailPtr
argument_list|)
expr_stmt|;
name|tailPtr
operator|.
name|setNextPtr
argument_list|(
name|newE
argument_list|)
expr_stmt|;
name|tailPtr
operator|=
name|newE
expr_stmt|;
block|}
comment|// Grow table if we are past the threshold now
if|if
condition|(
name|size
operator|++
operator|>=
name|threshold
condition|)
block|{
name|growTable
argument_list|(
literal|2
operator|*
name|entries
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
return|return
name|newE
operator|.
name|heapSize
argument_list|()
return|;
block|}
comment|/**    * Clears all the entries in the map.  Tracks the amount of memory being    * freed along the way and returns the total.    *    * Cleans up all references to allow old entries to be GC'd.    *    * @return total memory freed in bytes    */
specifier|private
name|long
name|clearAll
parameter_list|()
block|{
name|Entry
name|cur
decl_stmt|;
name|Entry
name|prev
decl_stmt|;
name|long
name|freedMemory
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|entries
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|cur
operator|=
name|entries
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|cur
operator|!=
literal|null
condition|)
block|{
name|freedMemory
operator|+=
name|cur
operator|.
name|heapSize
argument_list|()
expr_stmt|;
name|cur
operator|=
name|cur
operator|.
name|next
expr_stmt|;
block|}
name|entries
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
name|headPtr
operator|=
literal|null
expr_stmt|;
name|tailPtr
operator|=
literal|null
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
return|return
name|freedMemory
return|;
block|}
comment|//--------------------------------------------------------------------------
comment|/**    * Recreates the entire contents of the hashmap into a new array    * with double the capacity.  This method is called when the number of    * keys in the map reaches the current threshold.    *    * @param newCapacity the new size of the hash entries    */
specifier|private
name|void
name|growTable
parameter_list|(
name|int
name|newCapacity
parameter_list|)
block|{
name|Entry
index|[]
name|oldTable
init|=
name|entries
decl_stmt|;
name|int
name|oldCapacity
init|=
name|oldTable
operator|.
name|length
decl_stmt|;
comment|// Do not allow growing the table beyond the max capacity
if|if
condition|(
name|oldCapacity
operator|==
name|MAXIMUM_CAPACITY
condition|)
block|{
name|threshold
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
return|return;
block|}
comment|// Determine how much additional space will be required to grow the array
name|long
name|requiredSpace
init|=
operator|(
name|newCapacity
operator|-
name|oldCapacity
operator|)
operator|*
name|HeapSize
operator|.
name|REFERENCE
decl_stmt|;
comment|// Verify/enforce we have sufficient memory to grow
name|checkAndFreeMemory
argument_list|(
name|requiredSpace
argument_list|)
expr_stmt|;
name|Entry
index|[]
name|newTable
init|=
operator|new
name|Entry
index|[
name|newCapacity
index|]
decl_stmt|;
comment|// Transfer existing entries to new hash table
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|oldCapacity
condition|;
name|i
operator|++
control|)
block|{
name|Entry
name|entry
init|=
name|oldTable
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
comment|// Set to null for GC
name|oldTable
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
do|do
block|{
name|Entry
name|next
init|=
name|entry
operator|.
name|next
decl_stmt|;
name|int
name|idx
init|=
name|hashIndex
argument_list|(
name|entry
operator|.
name|hash
argument_list|,
name|newCapacity
argument_list|)
decl_stmt|;
name|entry
operator|.
name|next
operator|=
name|newTable
index|[
name|idx
index|]
expr_stmt|;
name|newTable
index|[
name|idx
index|]
operator|=
name|entry
expr_stmt|;
name|entry
operator|=
name|next
expr_stmt|;
block|}
do|while
condition|(
name|entry
operator|!=
literal|null
condition|)
do|;
block|}
block|}
name|entries
operator|=
name|newTable
expr_stmt|;
name|threshold
operator|=
call|(
name|int
call|)
argument_list|(
name|newCapacity
operator|*
name|loadFactor
argument_list|)
expr_stmt|;
block|}
comment|/**    * Gets the hash code for the specified key.    * This implementation uses the additional hashing routine    * from JDK 1.4.    *    * @param key the key to get a hash value for    * @return the hash value    */
specifier|private
name|int
name|hash
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|int
name|h
init|=
name|key
operator|.
name|hashCode
argument_list|()
decl_stmt|;
name|h
operator|+=
operator|~
operator|(
name|h
operator|<<
literal|9
operator|)
expr_stmt|;
name|h
operator|^=
operator|(
name|h
operator|>>>
literal|14
operator|)
expr_stmt|;
name|h
operator|+=
operator|(
name|h
operator|<<
literal|4
operator|)
expr_stmt|;
name|h
operator|^=
operator|(
name|h
operator|>>>
literal|10
operator|)
expr_stmt|;
return|return
name|h
return|;
block|}
comment|/**    * Compares two objects for equality.  Method uses equals method and    * assumes neither value is null.    *    * @param x the first value    * @param y the second value    * @return true if equal    */
specifier|private
name|boolean
name|isEqual
parameter_list|(
name|Object
name|x
parameter_list|,
name|Object
name|y
parameter_list|)
block|{
return|return
operator|(
name|x
operator|==
name|y
operator|||
name|x
operator|.
name|equals
argument_list|(
name|y
argument_list|)
operator|)
return|;
block|}
comment|/**    * Determines the index into the current hash table for the specified    * hashValue.    *    * @param hashValue the hash value    * @param length the current number of hash buckets    * @return the index of the current hash array to use    */
specifier|private
name|int
name|hashIndex
parameter_list|(
name|int
name|hashValue
parameter_list|,
name|int
name|length
parameter_list|)
block|{
return|return
name|hashValue
operator|&
operator|(
name|length
operator|-
literal|1
operator|)
return|;
block|}
comment|/**    * Calculates the capacity of the array backing the hash    * by normalizing capacity to a power of 2 and enforcing    * capacity limits.    *    * @param proposedCapacity the proposed capacity    * @return the normalized capacity    */
specifier|private
name|int
name|calculateCapacity
parameter_list|(
name|int
name|proposedCapacity
parameter_list|)
block|{
name|int
name|newCapacity
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|proposedCapacity
operator|>
name|MAXIMUM_CAPACITY
condition|)
block|{
name|newCapacity
operator|=
name|MAXIMUM_CAPACITY
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|newCapacity
operator|<
name|proposedCapacity
condition|)
block|{
name|newCapacity
operator|<<=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|newCapacity
operator|>
name|MAXIMUM_CAPACITY
condition|)
block|{
name|newCapacity
operator|=
name|MAXIMUM_CAPACITY
expr_stmt|;
block|}
block|}
return|return
name|newCapacity
return|;
block|}
comment|/**    * Calculates the threshold of the map given the capacity and load    * factor.  Once the number of entries in the map grows to the    * threshold we will double the size of the array.    *    * @param capacity the size of the array    * @param factor the load factor of the hash    */
specifier|private
name|int
name|calculateThreshold
parameter_list|(
name|int
name|capacity
parameter_list|,
name|float
name|factor
parameter_list|)
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|capacity
operator|*
name|factor
argument_list|)
return|;
block|}
comment|/**    * Set the initial heap usage of this class.  Includes class variable    * overhead and the entry array.    */
specifier|private
name|void
name|init
parameter_list|()
block|{
name|memFree
operator|-=
name|OVERHEAD
expr_stmt|;
name|memFree
operator|-=
operator|(
name|entries
operator|.
name|length
operator|*
name|HeapSize
operator|.
name|REFERENCE
operator|)
expr_stmt|;
block|}
comment|//--------------------------------------------------------------------------
comment|/**    * Debugging function that returns a List sorted by access time.    *    * The order is oldest to newest (first in list is next to be evicted).    *    * @return Sorted list of entries    */
specifier|public
name|List
argument_list|<
name|Entry
argument_list|>
name|entryLruList
parameter_list|()
block|{
name|List
argument_list|<
name|Entry
argument_list|>
name|entryList
init|=
operator|new
name|ArrayList
argument_list|<
name|Entry
argument_list|>
argument_list|()
decl_stmt|;
name|Entry
name|entry
init|=
name|headPtr
decl_stmt|;
while|while
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
name|entryList
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|=
name|entry
operator|.
name|getNextPtr
argument_list|()
expr_stmt|;
block|}
return|return
name|entryList
return|;
block|}
comment|/**    * Debugging function that returns a Set of all entries in the hash table.    *    * @return Set of entries in hash    */
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|>
name|entryTableSet
parameter_list|()
block|{
name|Set
argument_list|<
name|Entry
argument_list|>
name|entrySet
init|=
operator|new
name|HashSet
argument_list|<
name|Entry
argument_list|>
argument_list|()
decl_stmt|;
name|Entry
index|[]
name|table
init|=
name|entries
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|table
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|Entry
name|e
init|=
name|table
index|[
name|i
index|]
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|next
control|)
block|{
name|entrySet
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|entrySet
return|;
block|}
comment|/**    * Get the head of the linked list (least recently used).    *    * @return head of linked list    */
specifier|public
name|Entry
name|getHeadPtr
parameter_list|()
block|{
return|return
name|headPtr
return|;
block|}
comment|/**    * Get the tail of the linked list (most recently used).    *     * @return tail of linked list    */
specifier|public
name|Entry
name|getTailPtr
parameter_list|()
block|{
return|return
name|tailPtr
return|;
block|}
comment|//--------------------------------------------------------------------------
comment|/**    * To best optimize this class, some of the methods that are part of a    * Map implementation are not supported.  This is primarily related    * to being able to get Sets and Iterators of this map which require    * significant overhead and code complexity to support and are    * unnecessary for the requirements of this class.    */
comment|/**    * Intentionally unimplemented.    */
specifier|public
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ByteBuffer
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"entrySet() is intentionally unimplemented"
argument_list|)
throw|;
block|}
comment|/**    * Intentionally unimplemented.    */
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"equals(Object) is intentionally unimplemented"
argument_list|)
throw|;
block|}
comment|/**    * Intentionally unimplemented.    */
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"hashCode(Object) is intentionally unimplemented"
argument_list|)
throw|;
block|}
comment|/**    * Intentionally unimplemented.    */
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|keySet
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"keySet() is intentionally unimplemented"
argument_list|)
throw|;
block|}
comment|/**    * Intentionally unimplemented.    */
specifier|public
name|void
name|putAll
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|String
argument_list|,
name|?
extends|extends
name|ByteBuffer
argument_list|>
name|m
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"putAll() is intentionally unimplemented"
argument_list|)
throw|;
block|}
comment|/**    * Intentionally unimplemented.    */
specifier|public
name|Collection
argument_list|<
name|ByteBuffer
argument_list|>
name|values
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"values() is intentionally unimplemented"
argument_list|)
throw|;
block|}
comment|//--------------------------------------------------------------------------
comment|/**    * Entry to store key/value mappings.    *<p>    * Contains previous and next pointers for the doubly linked-list which is    * used for LRU eviction.    *<p>    * Instantiations of this class are memory aware.  Both the key and value    * classes used must also implement<code>HeapSize</code>.    */
specifier|protected
specifier|static
class|class
name|Entry
implements|implements
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ByteBuffer
argument_list|>
implements|,
name|HeapSize
block|{
comment|/** The baseline overhead memory usage of this class */
specifier|static
specifier|final
name|int
name|OVERHEAD
init|=
literal|1
operator|*
name|HeapSize
operator|.
name|LONG
operator|+
literal|5
operator|*
name|HeapSize
operator|.
name|REFERENCE
operator|+
literal|2
operator|*
name|HeapSize
operator|.
name|INT
decl_stmt|;
comment|/** The key */
specifier|protected
specifier|final
name|String
name|key
decl_stmt|;
comment|/** The value */
specifier|protected
name|ByteBuffer
name|value
decl_stmt|;
comment|/** The hash value for this entries key */
specifier|protected
specifier|final
name|int
name|hash
decl_stmt|;
comment|/** The next entry in the hash chain (for collisions) */
specifier|protected
name|Entry
name|next
decl_stmt|;
comment|/** The previous entry in the LRU list (towards LRU) */
specifier|protected
name|Entry
name|prevPtr
decl_stmt|;
comment|/** The next entry in the LRU list (towards MRU) */
specifier|protected
name|Entry
name|nextPtr
decl_stmt|;
comment|/** The precomputed heap size of this entry */
specifier|protected
name|long
name|heapSize
decl_stmt|;
comment|/**      * Create a new entry.      *      * @param h the hash value of the key      * @param k the key      * @param v the value      * @param nextChainPtr the next entry in the hash chain, null if none      * @param prevLruPtr the previous entry in the LRU      */
name|Entry
parameter_list|(
name|int
name|h
parameter_list|,
name|String
name|k
parameter_list|,
name|ByteBuffer
name|v
parameter_list|,
name|Entry
name|nextChainPtr
parameter_list|,
name|Entry
name|prevLruPtr
parameter_list|)
block|{
name|value
operator|=
name|v
expr_stmt|;
name|next
operator|=
name|nextChainPtr
expr_stmt|;
name|key
operator|=
name|k
expr_stmt|;
name|hash
operator|=
name|h
expr_stmt|;
name|prevPtr
operator|=
name|prevLruPtr
expr_stmt|;
name|nextPtr
operator|=
literal|null
expr_stmt|;
comment|// Pre-compute heap size
name|heapSize
operator|=
name|OVERHEAD
operator|+
name|heapSize
argument_list|(
name|k
argument_list|)
operator|+
name|heapSize
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
comment|/**      * Get the key of this entry.      *      * @return the key associated with this entry      */
specifier|public
name|String
name|getKey
parameter_list|()
block|{
return|return
name|key
return|;
block|}
comment|/**      * Get the value of this entry.      *      * @return the value currently associated with this entry      */
specifier|public
name|ByteBuffer
name|getValue
parameter_list|()
block|{
return|return
name|value
return|;
block|}
comment|/**      * Set the value of this entry.      *      * It is not recommended to use this method when changing the value.      * Rather, using<code>replaceValue</code> will return the difference      * in heap usage between the previous and current values.      *      * @param newValue the new value to associate with this entry      * @return the value previously associated with this entry      */
specifier|public
name|ByteBuffer
name|setValue
parameter_list|(
name|ByteBuffer
name|newValue
parameter_list|)
block|{
name|ByteBuffer
name|oldValue
init|=
name|value
decl_stmt|;
name|value
operator|=
name|newValue
expr_stmt|;
return|return
name|oldValue
return|;
block|}
comment|/**      * Replace the value of this entry.      *      * Computes and returns the difference in heap size when changing      * the value associated with this entry.      *      * @param newValue the new value to associate with this entry      * @return the change in heap usage of this entry in bytes      */
specifier|protected
name|long
name|replaceValue
parameter_list|(
name|ByteBuffer
name|newValue
parameter_list|)
block|{
name|long
name|sizeDiff
init|=
name|heapSize
argument_list|(
name|newValue
argument_list|)
operator|-
name|heapSize
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|value
operator|=
name|newValue
expr_stmt|;
name|heapSize
operator|+=
name|sizeDiff
expr_stmt|;
return|return
name|sizeDiff
return|;
block|}
comment|/**      * Returns true is the specified entry has the same key and the      * same value as this entry.      *      * @param o entry to test against current      * @return true is entries have equal key and value, false if no      */
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Map
operator|.
name|Entry
operator|)
condition|)
return|return
literal|false
return|;
name|Map
operator|.
name|Entry
name|e
init|=
operator|(
name|Map
operator|.
name|Entry
operator|)
name|o
decl_stmt|;
name|Object
name|k1
init|=
name|getKey
argument_list|()
decl_stmt|;
name|Object
name|k2
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|k1
operator|==
name|k2
operator|||
operator|(
name|k1
operator|!=
literal|null
operator|&&
name|k1
operator|.
name|equals
argument_list|(
name|k2
argument_list|)
operator|)
condition|)
block|{
name|Object
name|v1
init|=
name|getValue
argument_list|()
decl_stmt|;
name|Object
name|v2
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|v1
operator|==
name|v2
operator|||
operator|(
name|v1
operator|!=
literal|null
operator|&&
name|v1
operator|.
name|equals
argument_list|(
name|v2
argument_list|)
operator|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**       * Returns the hash code of the entry by xor'ing the hash values      * of the key and value of this entry.      *      * @return hash value of this entry      */
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
operator|(
name|key
operator|.
name|hashCode
argument_list|()
operator|^
name|value
operator|.
name|hashCode
argument_list|()
operator|)
return|;
block|}
comment|/**      * Returns String representation of the entry in form "key=value"      *      * @return string value of entry      */
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getKey
argument_list|()
return|;
block|}
comment|//------------------------------------------------------------------------
comment|/**      * Sets the previous pointer for the entry in the LRU.      * @param prevPtr previous entry      */
specifier|protected
name|void
name|setPrevPtr
parameter_list|(
name|Entry
name|prevPtr
parameter_list|)
block|{
name|this
operator|.
name|prevPtr
operator|=
name|prevPtr
expr_stmt|;
block|}
comment|/**      * Returns the previous pointer for the entry in the LRU.      * @return previous entry      */
specifier|protected
name|Entry
name|getPrevPtr
parameter_list|()
block|{
return|return
name|prevPtr
return|;
block|}
comment|/**      * Sets the next pointer for the entry in the LRU.      * @param nextPtr next entry      */
specifier|protected
name|void
name|setNextPtr
parameter_list|(
name|Entry
name|nextPtr
parameter_list|)
block|{
name|this
operator|.
name|nextPtr
operator|=
name|nextPtr
expr_stmt|;
block|}
comment|/**      * Returns the next pointer for the entry in teh LRU.      * @return next entry      */
specifier|protected
name|Entry
name|getNextPtr
parameter_list|()
block|{
return|return
name|nextPtr
return|;
block|}
comment|/**      * Returns the pre-computed and "deep" size of the Entry      * @return size of the entry in bytes      */
specifier|public
name|long
name|heapSize
parameter_list|()
block|{
return|return
name|heapSize
return|;
block|}
comment|/**      * Returns the estimated heap size of the passed String.      *      * Testing shows fixed overhead of 64 bytes per String and      * 2 bytes per character, 8 byte aligned.      *      * @return size of String in bytes      */
specifier|private
name|long
name|heapSize
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
name|HeapSize
operator|.
name|OBJECT
operator|+
name|alignSize
argument_list|(
name|s
operator|.
name|length
argument_list|()
operator|*
literal|2
argument_list|)
return|;
block|}
comment|/**      * Returns the estimated heap size of the passed ByteBuffer.      * @return size of ByteBuffer in bytes      */
specifier|private
name|long
name|heapSize
parameter_list|(
name|ByteBuffer
name|b
parameter_list|)
block|{
return|return
name|HeapSize
operator|.
name|BYTE_BUFFER
operator|+
name|alignSize
argument_list|(
name|b
operator|.
name|capacity
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Aligns a number to 8.      * @param num number to align to 8      * @return smallest number>= input that is a multiple of 8      */
specifier|private
name|long
name|alignSize
parameter_list|(
name|long
name|num
parameter_list|)
block|{
if|if
condition|(
name|num
operator|%
literal|8
operator|==
literal|0
condition|)
return|return
name|num
return|;
return|return
operator|(
name|num
operator|+
operator|(
literal|8
operator|-
operator|(
name|num
operator|%
literal|8
operator|)
operator|)
operator|)
return|;
block|}
block|}
block|}
end_class

end_unit

