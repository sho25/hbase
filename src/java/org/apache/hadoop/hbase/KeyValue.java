begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2009 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|RawComparator
import|;
end_import

begin_comment
comment|/**  * An HBase Key/Value.  Instances of this class are immutable.  They are not  * comparable but Comparators are provided  Comparators change with context,  * whether user table or a catalog table comparison context.  Its  * important that you use the appropriate comparator comparing rows in  * particular.  There are Comparators for KeyValue instances and then for  * just the Key portion of a KeyValue used mostly in {@link HFile}.  *   *<p>KeyValue wraps a byte array and has offset and length for passed array  * at where to start interpreting the content as a KeyValue blob.  The KeyValue  * blob format inside the byte array is:  *<code>&lt;keylength>&lt;valuelength>&lt;key>&lt;value></code>  * Key is decomposed as:  *<code>&lt;rowlength>&lt;row>&lt;columnfamilylength>&lt;columnfamily>&lt;columnqualifier>&lt;timestamp>&lt;keytype></code>  * Rowlength maximum is Short.MAX_SIZE, column family length maximum is  * Byte.MAX_SIZE, and column qualifier + key length must be< Integer.MAX_SIZE.  * The column does not contain the family/qualifier delimiter.  *   *<p>TODO: Group Key-only compartors and operations into a Key class, just  * for neatness sake, if can figure what to call it.  */
end_comment

begin_class
specifier|public
class|class
name|KeyValue
block|{
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|KeyValue
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Colon character in UTF-8    */
specifier|public
specifier|static
specifier|final
name|char
name|COLUMN_FAMILY_DELIMITER
init|=
literal|':'
decl_stmt|;
comment|/**    * Comparator for plain key/values; i.e. non-catalog table key/values.    */
specifier|public
specifier|static
name|KVComparator
name|COMPARATOR
init|=
operator|new
name|KVComparator
argument_list|()
decl_stmt|;
comment|/**    * Comparator for plain key; i.e. non-catalog table key.  Works on Key portion    * of KeyValue only.    */
specifier|public
specifier|static
name|KeyComparator
name|KEY_COMPARATOR
init|=
operator|new
name|KeyComparator
argument_list|()
decl_stmt|;
comment|/**    * A {@link KVComparator} for<code>.META.</code> catalog table    * {@link KeyValue}s.    */
specifier|public
specifier|static
name|KVComparator
name|META_COMPARATOR
init|=
operator|new
name|MetaComparator
argument_list|()
decl_stmt|;
comment|/**    * A {@link KVComparator} for<code>.META.</code> catalog table    * {@link KeyValue} keys.    */
specifier|public
specifier|static
name|KeyComparator
name|META_KEY_COMPARATOR
init|=
operator|new
name|MetaKeyComparator
argument_list|()
decl_stmt|;
comment|/**    * A {@link KVComparator} for<code>-ROOT-</code> catalog table    * {@link KeyValue}s.    */
specifier|public
specifier|static
name|KVComparator
name|ROOT_COMPARATOR
init|=
operator|new
name|RootComparator
argument_list|()
decl_stmt|;
comment|/**    * A {@link KVComparator} for<code>-ROOT-</code> catalog table    * {@link KeyValue} keys.    */
specifier|public
specifier|static
name|KeyComparator
name|ROOT_KEY_COMPARATOR
init|=
operator|new
name|RootKeyComparator
argument_list|()
decl_stmt|;
comment|/**    * Comparator that compares the family portion of columns only.    * Use this making NavigableMaps of Stores or when you need to compare    * column family portion only of two column names.    */
specifier|public
specifier|static
specifier|final
name|RawComparator
argument_list|<
name|byte
index|[]
argument_list|>
name|FAMILY_COMPARATOR
init|=
operator|new
name|RawComparator
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|byte
index|[]
name|a
parameter_list|,
name|int
name|ao
parameter_list|,
name|int
name|al
parameter_list|,
name|byte
index|[]
name|b
parameter_list|,
name|int
name|bo
parameter_list|,
name|int
name|bl
parameter_list|)
block|{
name|int
name|indexa
init|=
name|KeyValue
operator|.
name|getDelimiter
argument_list|(
name|a
argument_list|,
name|ao
argument_list|,
name|al
argument_list|,
name|COLUMN_FAMILY_DELIMITER
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexa
operator|<
literal|0
condition|)
block|{
name|indexa
operator|=
name|al
expr_stmt|;
block|}
name|int
name|indexb
init|=
name|KeyValue
operator|.
name|getDelimiter
argument_list|(
name|b
argument_list|,
name|bo
argument_list|,
name|bl
argument_list|,
name|COLUMN_FAMILY_DELIMITER
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexb
operator|<
literal|0
condition|)
block|{
name|indexb
operator|=
name|bl
expr_stmt|;
block|}
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|a
argument_list|,
name|ao
argument_list|,
name|indexa
argument_list|,
name|b
argument_list|,
name|bo
argument_list|,
name|indexb
argument_list|)
return|;
block|}
specifier|public
name|int
name|compare
parameter_list|(
name|byte
index|[]
name|a
parameter_list|,
name|byte
index|[]
name|b
parameter_list|)
block|{
return|return
name|compare
argument_list|(
name|a
argument_list|,
literal|0
argument_list|,
name|a
operator|.
name|length
argument_list|,
name|b
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|length
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|// Size of the timestamp and type byte on end of a key -- a long + a byte.
specifier|private
specifier|static
specifier|final
name|int
name|TIMESTAMP_TYPE_SIZE
init|=
name|Bytes
operator|.
name|SIZEOF_LONG
comment|/* timestamp */
operator|+
name|Bytes
operator|.
name|SIZEOF_BYTE
comment|/*keytype*/
decl_stmt|;
comment|// Size of the length shorts and bytes in key.
specifier|private
specifier|static
specifier|final
name|int
name|KEY_INFRASTRUCTURE_SIZE
init|=
name|Bytes
operator|.
name|SIZEOF_SHORT
comment|/*rowlength*/
operator|+
name|Bytes
operator|.
name|SIZEOF_BYTE
comment|/*columnfamilylength*/
operator|+
name|TIMESTAMP_TYPE_SIZE
decl_stmt|;
comment|// How far into the key the row starts at. First thing to read is the short
comment|// that says how long the row is.
specifier|private
specifier|static
specifier|final
name|int
name|ROW_OFFSET
init|=
name|Bytes
operator|.
name|SIZEOF_INT
comment|/*keylength*/
operator|+
name|Bytes
operator|.
name|SIZEOF_INT
comment|/*valuelength*/
decl_stmt|;
comment|// Size of the length ints in a KeyValue datastructure.
specifier|private
specifier|static
specifier|final
name|int
name|KEYVALUE_INFRASTRUCTURE_SIZE
init|=
name|ROW_OFFSET
decl_stmt|;
comment|/**    * Key type.    * Has space for other key types to be added later.  Cannot rely on    * enum ordinals . They change if item is removed or moved.  Do our own codes.    */
specifier|public
specifier|static
enum|enum
name|Type
block|{
name|Put
argument_list|(
operator|(
name|byte
operator|)
literal|4
argument_list|)
block|,
name|Delete
argument_list|(
operator|(
name|byte
operator|)
literal|8
argument_list|)
block|,
name|DeleteColumn
argument_list|(
operator|(
name|byte
operator|)
literal|16
argument_list|)
block|,
name|DeleteFamily
argument_list|(
operator|(
name|byte
operator|)
literal|32
argument_list|)
block|,
comment|// Maximum is used when searching; you look from maximum on down.
name|Maximum
argument_list|(
operator|(
name|byte
operator|)
literal|255
argument_list|)
block|;
specifier|private
specifier|final
name|byte
name|code
decl_stmt|;
name|Type
parameter_list|(
specifier|final
name|byte
name|c
parameter_list|)
block|{
name|this
operator|.
name|code
operator|=
name|c
expr_stmt|;
block|}
specifier|public
name|byte
name|getCode
parameter_list|()
block|{
return|return
name|this
operator|.
name|code
return|;
block|}
comment|/**      * Cannot rely on enum ordinals . They change if item is removed or moved.      * Do our own codes.      * @param b      * @return Type associated with passed code.      */
specifier|public
specifier|static
name|Type
name|codeToType
parameter_list|(
specifier|final
name|byte
name|b
parameter_list|)
block|{
comment|// This is messy repeating each type here below but no way around it; we
comment|// can't use the enum ordinal.
if|if
condition|(
name|b
operator|==
name|Put
operator|.
name|getCode
argument_list|()
condition|)
block|{
return|return
name|Put
return|;
block|}
elseif|else
if|if
condition|(
name|b
operator|==
name|Delete
operator|.
name|getCode
argument_list|()
condition|)
block|{
return|return
name|Delete
return|;
block|}
elseif|else
if|if
condition|(
name|b
operator|==
name|DeleteColumn
operator|.
name|getCode
argument_list|()
condition|)
block|{
return|return
name|DeleteColumn
return|;
block|}
elseif|else
if|if
condition|(
name|b
operator|==
name|DeleteFamily
operator|.
name|getCode
argument_list|()
condition|)
block|{
return|return
name|DeleteFamily
return|;
block|}
elseif|else
if|if
condition|(
name|b
operator|==
name|Maximum
operator|.
name|getCode
argument_list|()
condition|)
block|{
return|return
name|Maximum
return|;
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unknown code "
operator|+
name|b
argument_list|)
throw|;
block|}
block|}
comment|/**    * Lowest possible key.    * Makes a Key with highest possible Timestamp, empty row and column.  No    * key can be equal or lower than this one in memcache or in store file.    */
specifier|public
specifier|static
specifier|final
name|KeyValue
name|LOWESTKEY
init|=
operator|new
name|KeyValue
argument_list|(
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|bytes
decl_stmt|;
specifier|private
specifier|final
name|int
name|offset
decl_stmt|;
specifier|private
specifier|final
name|int
name|length
decl_stmt|;
comment|/**    * Creates a KeyValue from the start of the specified byte array.    * Presumes<code>bytes</code> content is formatted as a KeyValue blob.    * @param bytes byte array    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|)
block|{
name|this
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a KeyValue from the specified byte array and offset.    * Presumes<code>bytes</code> content starting at<code>offset</code> is    * formatted as a KeyValue blob.    * @param bytes byte array    * @param offset offset to start of KeyValue    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|)
block|{
name|this
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|getLength
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a KeyValue from the specified byte array, starting at offset, and    * for length<code>length</code>.    * @param bytes byte array    * @param offset offset to start of the KeyValue    * @param length length of the KeyValue    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|)
block|{
name|this
operator|.
name|bytes
operator|=
name|bytes
expr_stmt|;
name|this
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|this
operator|.
name|length
operator|=
name|length
expr_stmt|;
block|}
comment|/**    * @param row    * @param timestamp    * @return KeyValue structure filled with specified values.    * @throws IllegalArgumentException    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|String
name|row
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|)
block|{
name|this
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|row
argument_list|)
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param row    * @param timestamp    * @return KeyValue structure filled with specified values.    * @throws IllegalArgumentException    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|)
block|{
name|this
argument_list|(
name|row
argument_list|,
literal|null
argument_list|,
name|timestamp
argument_list|,
name|Type
operator|.
name|Put
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param row    * @param column Column with delimiter between family and qualifier    * @return KeyValue structure filled with specified values.    * @throws IllegalArgumentException    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|String
name|row
parameter_list|,
specifier|final
name|String
name|column
parameter_list|)
block|{
name|this
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param row    * @param column Column with delimiter between family and qualifier    * @return KeyValue structure filled with specified values.    * @throws IllegalArgumentException    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|column
parameter_list|)
block|{
name|this
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param row    * @param column Column with delimiter between family and qualifier    * @param value    * @return KeyValue structure filled with specified values.    * @throws IllegalArgumentException    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|String
name|row
parameter_list|,
specifier|final
name|String
name|column
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|)
block|{
name|this
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|row
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|column
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param row    * @param column Column with delimiter between family and qualifier    * @param value    * @return KeyValue structure filled with specified values.    * @throws IllegalArgumentException    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|column
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|)
block|{
name|this
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param row    * @param column Column with delimiter between family and qualifier    * @param ts    * @return KeyValue structure filled with specified values.    * @throws IllegalArgumentException    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|String
name|row
parameter_list|,
specifier|final
name|String
name|column
parameter_list|,
specifier|final
name|long
name|ts
parameter_list|)
block|{
name|this
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|ts
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param row    * @param column Column with delimiter between family and qualifier    * @param ts    * @return KeyValue structure filled with specified values.    * @throws IllegalArgumentException    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|column
parameter_list|,
specifier|final
name|long
name|ts
parameter_list|)
block|{
name|this
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|ts
argument_list|,
name|Type
operator|.
name|Put
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param row    * @param column Column with delimiter between family and qualifier    * @param timestamp    * @param value    * @return KeyValue structure filled with specified values.    * @throws IllegalArgumentException    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|String
name|row
parameter_list|,
specifier|final
name|String
name|column
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|)
block|{
name|this
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|row
argument_list|)
argument_list|,
name|column
operator|==
literal|null
condition|?
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
else|:
name|Bytes
operator|.
name|toBytes
argument_list|(
name|column
argument_list|)
argument_list|,
name|timestamp
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param row    * @param column Column with delimiter between family and qualifier    * @param timestamp    * @param value    * @return KeyValue structure filled with specified values.    * @throws IllegalArgumentException    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|column
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|)
block|{
name|this
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|timestamp
argument_list|,
name|Type
operator|.
name|Put
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param row    * @param column Column with delimiter between family and qualifier    * @param timestamp    * @param type    * @param value    * @return KeyValue structure filled with specified values.    * @throws IllegalArgumentException    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|String
name|row
parameter_list|,
specifier|final
name|String
name|column
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|)
block|{
name|this
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|row
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|column
argument_list|)
argument_list|,
name|timestamp
argument_list|,
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param row    * @param column Column with delimiter between family and qualifier    * @param timestamp    * @param type    * @return KeyValue structure filled with specified values.    * @throws IllegalArgumentException    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|column
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|)
block|{
name|this
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
name|row
operator|.
name|length
argument_list|,
name|column
argument_list|,
literal|0
argument_list|,
name|column
operator|==
literal|null
condition|?
literal|0
else|:
name|column
operator|.
name|length
argument_list|,
name|timestamp
argument_list|,
name|type
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param row    * @param column Column with delimiter between family and qualifier    * @param timestamp    * @param type    * @param value    * @return KeyValue structure filled with specified values.    * @throws IllegalArgumentException    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|column
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|)
block|{
name|this
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
name|row
operator|.
name|length
argument_list|,
name|column
argument_list|,
literal|0
argument_list|,
name|column
operator|==
literal|null
condition|?
literal|0
else|:
name|column
operator|.
name|length
argument_list|,
name|timestamp
argument_list|,
name|type
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|value
operator|==
literal|null
condition|?
literal|0
else|:
name|value
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param row    * @param roffset    * @param rlength    * @param column Column with delimiter between family and qualifier    * @param coffset Where to start reading the column.    * @param clength How long column is (including the family/qualifier delimiter.    * @param timestamp    * @param type    * @param value    * @param voffset    * @param vlength    * @return KeyValue    * @throws IllegalArgumentException    */
specifier|public
name|KeyValue
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|int
name|roffset
parameter_list|,
specifier|final
name|int
name|rlength
parameter_list|,
specifier|final
name|byte
index|[]
name|column
parameter_list|,
specifier|final
name|int
name|coffset
parameter_list|,
name|int
name|clength
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|int
name|voffset
parameter_list|,
name|int
name|vlength
parameter_list|)
block|{
name|this
operator|.
name|bytes
operator|=
name|createByteArray
argument_list|(
name|row
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|,
name|column
argument_list|,
name|coffset
argument_list|,
name|clength
argument_list|,
name|timestamp
argument_list|,
name|type
argument_list|,
name|value
argument_list|,
name|voffset
argument_list|,
name|vlength
argument_list|)
expr_stmt|;
name|this
operator|.
name|length
operator|=
name|bytes
operator|.
name|length
expr_stmt|;
name|this
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/**    * Write KeyValue format into a byte array.    * @param row    * @param roffset    * @param rlength    * @param column    * @param coffset    * @param clength    * @param timestamp    * @param type    * @param value    * @param voffset    * @param vlength    * @return    */
specifier|static
name|byte
index|[]
name|createByteArray
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|int
name|roffset
parameter_list|,
specifier|final
name|int
name|rlength
parameter_list|,
specifier|final
name|byte
index|[]
name|column
parameter_list|,
specifier|final
name|int
name|coffset
parameter_list|,
name|int
name|clength
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|int
name|voffset
parameter_list|,
name|int
name|vlength
parameter_list|)
block|{
if|if
condition|(
name|rlength
operator|>
name|Short
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Row> "
operator|+
name|Short
operator|.
name|MAX_VALUE
argument_list|)
throw|;
block|}
if|if
condition|(
name|row
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Row is null"
argument_list|)
throw|;
block|}
comment|// If column is non-null, figure where the delimiter is at.
name|int
name|delimiteroffset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|column
operator|!=
literal|null
operator|&&
name|column
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|delimiteroffset
operator|=
name|getFamilyDelimiterIndex
argument_list|(
name|column
argument_list|,
name|coffset
argument_list|,
name|clength
argument_list|)
expr_stmt|;
if|if
condition|(
name|delimiteroffset
operator|>
name|Byte
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Family> "
operator|+
name|Byte
operator|.
name|MAX_VALUE
argument_list|)
throw|;
block|}
block|}
comment|// Value length
name|vlength
operator|=
name|value
operator|==
literal|null
condition|?
literal|0
else|:
name|vlength
expr_stmt|;
comment|// Column length - minus delimiter
name|clength
operator|=
name|column
operator|==
literal|null
operator|||
name|column
operator|.
name|length
operator|==
literal|0
condition|?
literal|0
else|:
name|clength
operator|-
literal|1
expr_stmt|;
name|long
name|longkeylength
init|=
name|KEY_INFRASTRUCTURE_SIZE
operator|+
name|rlength
operator|+
name|clength
decl_stmt|;
if|if
condition|(
name|longkeylength
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"keylength "
operator|+
name|longkeylength
operator|+
literal|"> "
operator|+
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
throw|;
block|}
name|int
name|keylength
init|=
operator|(
name|int
operator|)
name|longkeylength
decl_stmt|;
comment|// Allocate right-sized byte array.
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|KEYVALUE_INFRASTRUCTURE_SIZE
operator|+
name|keylength
operator|+
name|vlength
index|]
decl_stmt|;
comment|// Write key, value and key row length.
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putInt
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|keylength
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putInt
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|vlength
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putShort
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
call|(
name|short
call|)
argument_list|(
name|rlength
operator|&
literal|0x0000ffff
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putBytes
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|row
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|)
expr_stmt|;
comment|// Write out column family length.
name|pos
operator|=
name|Bytes
operator|.
name|putByte
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
call|(
name|byte
call|)
argument_list|(
name|delimiteroffset
operator|&
literal|0x0000ff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|column
operator|!=
literal|null
operator|&&
name|column
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
comment|// Write family.
name|pos
operator|=
name|Bytes
operator|.
name|putBytes
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|column
argument_list|,
name|coffset
argument_list|,
name|delimiteroffset
argument_list|)
expr_stmt|;
comment|// Write qualifier.
name|delimiteroffset
operator|++
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putBytes
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|column
argument_list|,
name|coffset
operator|+
name|delimiteroffset
argument_list|,
name|column
operator|.
name|length
operator|-
name|delimiteroffset
argument_list|)
expr_stmt|;
block|}
name|pos
operator|=
name|Bytes
operator|.
name|putLong
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Bytes
operator|.
name|putByte
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|type
operator|.
name|getCode
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
name|value
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|pos
operator|=
name|Bytes
operator|.
name|putBytes
argument_list|(
name|bytes
argument_list|,
name|pos
argument_list|,
name|value
argument_list|,
name|voffset
argument_list|,
name|vlength
argument_list|)
expr_stmt|;
block|}
return|return
name|bytes
return|;
block|}
comment|// Needed doing 'contains' on List.
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
name|KeyValue
name|kv
init|=
operator|(
name|KeyValue
operator|)
name|other
decl_stmt|;
comment|// Comparing bytes should be fine doing equals test.  Shouldn't have to
comment|// worry about special .META. comparators doing straight equals.
name|boolean
name|result
init|=
name|Bytes
operator|.
name|BYTES_RAWCOMPARATOR
operator|.
name|compare
argument_list|(
name|getBuffer
argument_list|()
argument_list|,
name|getKeyOffset
argument_list|()
argument_list|,
name|getKeyLength
argument_list|()
argument_list|,
name|kv
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|kv
operator|.
name|getKeyOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getKeyLength
argument_list|()
argument_list|)
operator|==
literal|0
decl_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * @param timestamp    * @return Clone of bb's key portion with only the row and timestamp filled in.    * @throws IOException    */
specifier|public
name|KeyValue
name|cloneRow
parameter_list|(
specifier|final
name|long
name|timestamp
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|getBuffer
argument_list|()
argument_list|,
name|getRowOffset
argument_list|()
argument_list|,
name|getRowLength
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|timestamp
argument_list|,
name|Type
operator|.
name|codeToType
argument_list|(
name|getType
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * @return Clone of bb's key portion with type set to Type.Delete.    * @throws IOException    */
specifier|public
name|KeyValue
name|cloneDelete
parameter_list|()
block|{
return|return
name|createKey
argument_list|(
name|Type
operator|.
name|Delete
argument_list|)
return|;
block|}
comment|/**    * @return Clone of bb's key portion with type set to Type.Maximum. Use this    * doing lookups where you are doing getClosest.  Using Maximum, you'll be    * sure to trip over all of the other key types since Maximum sorts first.    * @throws IOException    */
specifier|public
name|KeyValue
name|cloneMaximum
parameter_list|()
block|{
return|return
name|createKey
argument_list|(
name|Type
operator|.
name|Maximum
argument_list|)
return|;
block|}
comment|/*    * Make a clone with the new type.    * Does not copy value.    * @param newtype New type to set on clone of this key.    * @return Clone of this key with type set to<code>newtype</code>    */
specifier|private
name|KeyValue
name|createKey
parameter_list|(
specifier|final
name|Type
name|newtype
parameter_list|)
block|{
name|int
name|keylength
init|=
name|getKeyLength
argument_list|()
decl_stmt|;
name|int
name|l
init|=
name|keylength
operator|+
name|ROW_OFFSET
decl_stmt|;
name|byte
index|[]
name|other
init|=
operator|new
name|byte
index|[
name|l
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|getBuffer
argument_list|()
argument_list|,
name|getOffset
argument_list|()
argument_list|,
name|other
argument_list|,
literal|0
argument_list|,
name|l
argument_list|)
expr_stmt|;
comment|// Set value length to zero.
name|Bytes
operator|.
name|putInt
argument_list|(
name|other
argument_list|,
name|Bytes
operator|.
name|SIZEOF_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Set last byte, the type, to new type
name|other
index|[
name|l
operator|-
literal|1
index|]
operator|=
name|newtype
operator|.
name|getCode
argument_list|()
expr_stmt|;
return|return
operator|new
name|KeyValue
argument_list|(
name|other
argument_list|,
literal|0
argument_list|,
name|other
operator|.
name|length
argument_list|)
return|;
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|keyToString
argument_list|(
name|this
operator|.
name|bytes
argument_list|,
name|this
operator|.
name|offset
operator|+
name|ROW_OFFSET
argument_list|,
name|getKeyLength
argument_list|()
argument_list|)
operator|+
literal|"/vlen="
operator|+
name|getValueLength
argument_list|()
return|;
block|}
comment|/**    * @param b Key portion of a KeyValue.    * @return Key as a String.    */
specifier|public
specifier|static
name|String
name|keyToString
parameter_list|(
specifier|final
name|byte
index|[]
name|k
parameter_list|)
block|{
return|return
name|keyToString
argument_list|(
name|k
argument_list|,
literal|0
argument_list|,
name|k
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * @param b Key portion of a KeyValue.    * @param o Offset to start of key    * @param l Length of key.    * @return Key as a String.    */
specifier|public
specifier|static
name|String
name|keyToString
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|,
specifier|final
name|int
name|o
parameter_list|,
specifier|final
name|int
name|l
parameter_list|)
block|{
name|int
name|rowlength
init|=
name|Bytes
operator|.
name|toShort
argument_list|(
name|b
argument_list|,
name|o
argument_list|)
decl_stmt|;
name|String
name|row
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|b
argument_list|,
name|o
operator|+
name|Bytes
operator|.
name|SIZEOF_SHORT
argument_list|,
name|rowlength
argument_list|)
decl_stmt|;
name|int
name|columnoffset
init|=
name|o
operator|+
name|Bytes
operator|.
name|SIZEOF_SHORT
operator|+
literal|1
operator|+
name|rowlength
decl_stmt|;
name|int
name|familylength
init|=
name|b
index|[
name|columnoffset
operator|-
literal|1
index|]
decl_stmt|;
name|int
name|columnlength
init|=
name|l
operator|-
operator|(
operator|(
name|columnoffset
operator|-
name|o
operator|)
operator|+
name|TIMESTAMP_TYPE_SIZE
operator|)
decl_stmt|;
name|String
name|family
init|=
name|familylength
operator|==
literal|0
condition|?
literal|""
else|:
name|Bytes
operator|.
name|toString
argument_list|(
name|b
argument_list|,
name|columnoffset
argument_list|,
name|familylength
argument_list|)
decl_stmt|;
name|String
name|qualifier
init|=
name|columnlength
operator|==
literal|0
condition|?
literal|""
else|:
name|Bytes
operator|.
name|toString
argument_list|(
name|b
argument_list|,
name|columnoffset
operator|+
name|familylength
argument_list|,
name|columnlength
operator|-
name|familylength
argument_list|)
decl_stmt|;
name|long
name|timestamp
init|=
name|Bytes
operator|.
name|toLong
argument_list|(
name|b
argument_list|,
name|o
operator|+
operator|(
name|l
operator|-
name|TIMESTAMP_TYPE_SIZE
operator|)
argument_list|)
decl_stmt|;
name|byte
name|type
init|=
name|b
index|[
name|o
operator|+
name|l
operator|-
literal|1
index|]
decl_stmt|;
return|return
name|row
operator|+
literal|"/"
operator|+
name|family
operator|+
operator|(
name|family
operator|!=
literal|null
operator|&&
name|family
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|?
name|COLUMN_FAMILY_DELIMITER
else|:
literal|""
operator|)
operator|+
name|qualifier
operator|+
literal|"/"
operator|+
name|timestamp
operator|+
literal|"/"
operator|+
name|Type
operator|.
name|codeToType
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/**    * @return The byte array backing this KeyValue.    */
specifier|public
name|byte
index|[]
name|getBuffer
parameter_list|()
block|{
return|return
name|this
operator|.
name|bytes
return|;
block|}
comment|/**    * @return Offset into {@link #getBuffer()} at which this KeyValue starts.    */
specifier|public
name|int
name|getOffset
parameter_list|()
block|{
return|return
name|this
operator|.
name|offset
return|;
block|}
comment|/**    * @return Length of bytes this KeyValue occupies in {@link #getBuffer()}.    */
specifier|public
name|int
name|getLength
parameter_list|()
block|{
return|return
name|length
return|;
block|}
comment|/*    * Determines the total length of the KeyValue stored in the specified    * byte array and offset.  Includes all headers.    * @param bytes byte array    * @param offset offset to start of the KeyValue    * @return length of entire KeyValue, in bytes    */
specifier|private
specifier|static
name|int
name|getLength
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
return|return
operator|(
literal|2
operator|*
name|Bytes
operator|.
name|SIZEOF_INT
operator|)
operator|+
name|Bytes
operator|.
name|toInt
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|)
operator|+
name|Bytes
operator|.
name|toInt
argument_list|(
name|bytes
argument_list|,
name|offset
operator|+
name|Bytes
operator|.
name|SIZEOF_INT
argument_list|)
return|;
block|}
comment|/**    * @return Copy of the key portion only.  Used compacting and testing.    */
specifier|public
name|byte
index|[]
name|getKey
parameter_list|()
block|{
name|int
name|keylength
init|=
name|getKeyLength
argument_list|()
decl_stmt|;
name|byte
index|[]
name|key
init|=
operator|new
name|byte
index|[
name|keylength
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|getBuffer
argument_list|()
argument_list|,
name|ROW_OFFSET
argument_list|,
name|key
argument_list|,
literal|0
argument_list|,
name|keylength
argument_list|)
expr_stmt|;
return|return
name|key
return|;
block|}
comment|/**    * @return Key offset in backing buffer..    */
specifier|public
name|int
name|getKeyOffset
parameter_list|()
block|{
return|return
name|this
operator|.
name|offset
operator|+
name|ROW_OFFSET
return|;
block|}
comment|/**    * @return Row length.    */
specifier|public
name|short
name|getRowLength
parameter_list|()
block|{
return|return
name|Bytes
operator|.
name|toShort
argument_list|(
name|this
operator|.
name|bytes
argument_list|,
name|getKeyOffset
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @return Offset into backing buffer at which row starts.    */
specifier|public
name|int
name|getRowOffset
parameter_list|()
block|{
return|return
name|getKeyOffset
argument_list|()
operator|+
name|Bytes
operator|.
name|SIZEOF_SHORT
return|;
block|}
comment|/**    * Do not use this unless you have to.    * Use {@link #getBuffer()} with appropriate offsets and lengths instead.    * @return Row in a new byte array.    */
specifier|public
name|byte
index|[]
name|getRow
parameter_list|()
block|{
name|int
name|o
init|=
name|getRowOffset
argument_list|()
decl_stmt|;
name|short
name|l
init|=
name|getRowLength
argument_list|()
decl_stmt|;
name|byte
index|[]
name|result
init|=
operator|new
name|byte
index|[
name|l
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|getBuffer
argument_list|()
argument_list|,
name|o
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * @return Timestamp    */
specifier|public
name|long
name|getTimestamp
parameter_list|()
block|{
return|return
name|getTimestamp
argument_list|(
name|getKeyLength
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @param keylength Pass if you have it to save on a int creation.    * @return Timestamp    */
name|long
name|getTimestamp
parameter_list|(
specifier|final
name|int
name|keylength
parameter_list|)
block|{
name|int
name|tsOffset
init|=
name|getTimestampOffset
argument_list|(
name|keylength
argument_list|)
decl_stmt|;
return|return
name|Bytes
operator|.
name|toLong
argument_list|(
name|this
operator|.
name|bytes
argument_list|,
name|tsOffset
argument_list|)
return|;
block|}
comment|/**    * @param keylength Pass if you have it to save on a int creation.    * @return Offset into backing buffer at which timestamp starts.    */
name|int
name|getTimestampOffset
parameter_list|(
specifier|final
name|int
name|keylength
parameter_list|)
block|{
return|return
name|getKeyOffset
argument_list|()
operator|+
name|keylength
operator|-
name|TIMESTAMP_TYPE_SIZE
return|;
block|}
comment|/**    * @return True if a {@link Type#Delete}.    */
specifier|public
name|boolean
name|isDeleteType
parameter_list|()
block|{
return|return
name|getType
argument_list|()
operator|==
name|Type
operator|.
name|Delete
operator|.
name|getCode
argument_list|()
return|;
block|}
comment|/**    * @return Type of this KeyValue.    */
name|byte
name|getType
parameter_list|()
block|{
return|return
name|getType
argument_list|(
name|getKeyLength
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @param keylength Pass if you have it to save on a int creation.    * @return Type of this KeyValue.    */
name|byte
name|getType
parameter_list|(
specifier|final
name|int
name|keylength
parameter_list|)
block|{
return|return
name|this
operator|.
name|bytes
index|[
name|this
operator|.
name|offset
operator|+
name|keylength
operator|-
literal|1
operator|+
name|ROW_OFFSET
index|]
return|;
block|}
comment|/**    * @return Length of key portion.    */
specifier|public
name|int
name|getKeyLength
parameter_list|()
block|{
return|return
name|Bytes
operator|.
name|toInt
argument_list|(
name|this
operator|.
name|bytes
argument_list|,
name|this
operator|.
name|offset
argument_list|)
return|;
block|}
comment|/**    * @return Value length    */
specifier|public
name|int
name|getValueLength
parameter_list|()
block|{
return|return
name|Bytes
operator|.
name|toInt
argument_list|(
name|this
operator|.
name|bytes
argument_list|,
name|this
operator|.
name|offset
operator|+
name|Bytes
operator|.
name|SIZEOF_INT
argument_list|)
return|;
block|}
comment|/**    * @return Offset into backing buffer at which value starts.    */
specifier|public
name|int
name|getValueOffset
parameter_list|()
block|{
return|return
name|getKeyOffset
argument_list|()
operator|+
name|getKeyLength
argument_list|()
return|;
block|}
comment|/**    * Do not use unless you have to.  Use {@link #getBuffer()} with appropriate    * offset and lengths instead.    * @return Value in a new byte array.    */
specifier|public
name|byte
index|[]
name|getValue
parameter_list|()
block|{
name|int
name|o
init|=
name|getValueOffset
argument_list|()
decl_stmt|;
name|int
name|l
init|=
name|getValueLength
argument_list|()
decl_stmt|;
name|byte
index|[]
name|result
init|=
operator|new
name|byte
index|[
name|l
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|getBuffer
argument_list|()
argument_list|,
name|o
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * @return Offset into backing buffer at which the column begins    */
specifier|public
name|int
name|getColumnOffset
parameter_list|()
block|{
return|return
name|getColumnOffset
argument_list|(
name|getRowLength
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @param rowlength Pass if you have it to save on an int creation.    * @return Offset into backing buffer at which the column begins    */
specifier|public
name|int
name|getColumnOffset
parameter_list|(
specifier|final
name|int
name|rowlength
parameter_list|)
block|{
return|return
name|getRowOffset
argument_list|()
operator|+
name|rowlength
operator|+
literal|1
return|;
block|}
comment|/**    * @param columnoffset Pass if you have it to save on an int creation.    * @return Length of family portion of column.    */
name|int
name|getFamilyLength
parameter_list|(
specifier|final
name|int
name|columnoffset
parameter_list|)
block|{
return|return
name|this
operator|.
name|bytes
index|[
name|columnoffset
operator|-
literal|1
index|]
return|;
block|}
comment|/**    * @param columnoffset Pass if you have it to save on an int creation.    * @return Length of column.    */
specifier|public
name|int
name|getColumnLength
parameter_list|(
specifier|final
name|int
name|columnoffset
parameter_list|)
block|{
return|return
name|getColumnLength
argument_list|(
name|columnoffset
argument_list|,
name|getKeyLength
argument_list|()
argument_list|)
return|;
block|}
name|int
name|getColumnLength
parameter_list|(
specifier|final
name|int
name|columnoffset
parameter_list|,
specifier|final
name|int
name|keylength
parameter_list|)
block|{
return|return
operator|(
name|keylength
operator|+
name|ROW_OFFSET
operator|)
operator|-
operator|(
name|columnoffset
operator|-
name|this
operator|.
name|offset
operator|)
operator|-
name|TIMESTAMP_TYPE_SIZE
return|;
block|}
comment|/**    * @param family    * @return True if matching families.    */
specifier|public
name|boolean
name|matchingFamily
parameter_list|(
specifier|final
name|byte
index|[]
name|family
parameter_list|)
block|{
name|int
name|o
init|=
name|getColumnOffset
argument_list|()
decl_stmt|;
comment|// Family length byte is just before the column starts.
name|int
name|l
init|=
name|this
operator|.
name|bytes
index|[
name|o
operator|-
literal|1
index|]
decl_stmt|;
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|family
argument_list|,
literal|0
argument_list|,
name|family
operator|.
name|length
argument_list|,
name|this
operator|.
name|bytes
argument_list|,
name|o
argument_list|,
name|l
argument_list|)
operator|==
literal|0
return|;
block|}
comment|/**    * @param column Column minus its delimiter    * @return True if column matches.    * @see #matchingColumn(byte[])    */
specifier|public
name|boolean
name|matchingColumnNoDelimiter
parameter_list|(
specifier|final
name|byte
index|[]
name|column
parameter_list|)
block|{
name|int
name|o
init|=
name|getColumnOffset
argument_list|()
decl_stmt|;
name|int
name|l
init|=
name|getColumnLength
argument_list|(
name|o
argument_list|)
decl_stmt|;
return|return
name|compareColumns
argument_list|(
name|getBuffer
argument_list|()
argument_list|,
name|o
argument_list|,
name|l
argument_list|,
name|column
argument_list|,
literal|0
argument_list|,
name|column
operator|.
name|length
argument_list|)
operator|==
literal|0
return|;
block|}
comment|/**    * @param column Column with delimiter    * @return True if column matches.    */
specifier|public
name|boolean
name|matchingColumn
parameter_list|(
specifier|final
name|byte
index|[]
name|column
parameter_list|)
block|{
name|int
name|index
init|=
name|getFamilyDelimiterIndex
argument_list|(
name|column
argument_list|,
literal|0
argument_list|,
name|column
operator|.
name|length
argument_list|)
decl_stmt|;
name|int
name|o
init|=
name|getColumnOffset
argument_list|()
decl_stmt|;
name|int
name|l
init|=
name|getColumnLength
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|int
name|result
init|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|getBuffer
argument_list|()
argument_list|,
name|o
argument_list|,
name|index
argument_list|,
name|column
argument_list|,
literal|0
argument_list|,
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|getBuffer
argument_list|()
argument_list|,
name|o
operator|+
name|index
argument_list|,
name|l
operator|-
name|index
argument_list|,
name|column
argument_list|,
name|index
operator|+
literal|1
argument_list|,
name|column
operator|.
name|length
operator|-
operator|(
name|index
operator|+
literal|1
operator|)
argument_list|)
operator|==
literal|0
return|;
block|}
comment|/**    * @param left    * @param loffset    * @param llength    * @param right    * @param roffset    * @param rlength    * @return    */
specifier|static
name|int
name|compareColumns
parameter_list|(
specifier|final
name|byte
index|[]
name|left
parameter_list|,
specifier|final
name|int
name|loffset
parameter_list|,
specifier|final
name|int
name|llength
parameter_list|,
specifier|final
name|byte
index|[]
name|right
parameter_list|,
specifier|final
name|int
name|roffset
parameter_list|,
specifier|final
name|int
name|rlength
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
argument_list|,
name|loffset
argument_list|,
name|llength
argument_list|,
name|right
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|)
return|;
block|}
comment|/**    * @return True if non-null row and column.    */
specifier|public
name|boolean
name|nonNullRowAndColumn
parameter_list|()
block|{
return|return
name|getRowLength
argument_list|()
operator|>
literal|0
operator|&&
operator|!
name|isEmptyColumn
argument_list|()
return|;
block|}
comment|/**    * @return Returns column String with delimiter added back. Expensive!    */
specifier|public
name|String
name|getColumnString
parameter_list|()
block|{
name|int
name|o
init|=
name|getColumnOffset
argument_list|()
decl_stmt|;
name|int
name|l
init|=
name|getColumnLength
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|int
name|familylength
init|=
name|getFamilyLength
argument_list|(
name|o
argument_list|)
decl_stmt|;
return|return
name|Bytes
operator|.
name|toString
argument_list|(
name|this
operator|.
name|bytes
argument_list|,
name|o
argument_list|,
name|familylength
argument_list|)
operator|+
name|COLUMN_FAMILY_DELIMITER
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|this
operator|.
name|bytes
argument_list|,
name|o
operator|+
name|familylength
argument_list|,
name|l
operator|-
name|familylength
argument_list|)
return|;
block|}
comment|/**    * Do not use this unless you have to.    * Use {@link #getBuffer()} with appropriate offsets and lengths instead.    * @return Returns column. Makes a copy.  Inserts delimiter.    */
specifier|public
name|byte
index|[]
name|getColumn
parameter_list|()
block|{
name|int
name|o
init|=
name|getColumnOffset
argument_list|()
decl_stmt|;
name|int
name|l
init|=
name|getColumnLength
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|int
name|familylength
init|=
name|getFamilyLength
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|byte
index|[]
name|result
init|=
operator|new
name|byte
index|[
name|l
operator|+
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|getBuffer
argument_list|()
argument_list|,
name|o
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
name|familylength
argument_list|)
expr_stmt|;
name|result
index|[
name|familylength
index|]
operator|=
name|COLUMN_FAMILY_DELIMITER
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|getBuffer
argument_list|()
argument_list|,
name|o
operator|+
name|familylength
argument_list|,
name|result
argument_list|,
name|familylength
operator|+
literal|1
argument_list|,
name|l
operator|-
name|familylength
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * @return True if column is empty.    */
specifier|public
name|boolean
name|isEmptyColumn
parameter_list|()
block|{
return|return
name|getColumnLength
argument_list|(
name|getColumnOffset
argument_list|()
argument_list|)
operator|==
literal|0
return|;
block|}
comment|/**    * @param b    * @return Index of the family-qualifier colon delimiter character in passed    * buffer.    */
specifier|public
specifier|static
name|int
name|getFamilyDelimiterIndex
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|)
block|{
return|return
name|getRequiredDelimiter
argument_list|(
name|b
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|COLUMN_FAMILY_DELIMITER
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|int
name|getRequiredDelimiter
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|,
specifier|final
name|int
name|delimiter
parameter_list|)
block|{
name|int
name|index
init|=
name|getDelimiter
argument_list|(
name|b
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|delimiter
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"No "
operator|+
operator|(
name|char
operator|)
name|delimiter
operator|+
literal|" in<"
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|b
argument_list|)
operator|+
literal|">"
operator|+
literal|", length="
operator|+
name|length
operator|+
literal|", offset="
operator|+
name|offset
argument_list|)
throw|;
block|}
return|return
name|index
return|;
block|}
specifier|static
name|int
name|getRequiredDelimiterInReverse
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|,
specifier|final
name|int
name|delimiter
parameter_list|)
block|{
name|int
name|index
init|=
name|getDelimiterInReverse
argument_list|(
name|b
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|delimiter
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"No "
operator|+
name|delimiter
operator|+
literal|" in<"
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|b
argument_list|)
operator|+
literal|">"
operator|+
literal|", length="
operator|+
name|length
operator|+
literal|", offset="
operator|+
name|offset
argument_list|)
throw|;
block|}
return|return
name|index
return|;
block|}
comment|/*    * @param b    * @param delimiter    * @return Index of delimiter having started from end of<code>b</code> moving    * leftward.    */
specifier|static
name|int
name|getDelimiter
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|,
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|,
specifier|final
name|int
name|delimiter
parameter_list|)
block|{
if|if
condition|(
name|b
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|offset
init|;
name|i
operator|<
name|length
operator|+
name|offset
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|b
index|[
name|i
index|]
operator|==
name|delimiter
condition|)
block|{
name|result
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/*    * @param b    * @param delimiter    * @return Index of delimiter    */
specifier|static
name|int
name|getDelimiterInReverse
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|,
specifier|final
name|int
name|delimiter
parameter_list|)
block|{
if|if
condition|(
name|b
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
operator|(
name|offset
operator|+
name|length
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
name|offset
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|b
index|[
name|i
index|]
operator|==
name|delimiter
condition|)
block|{
name|result
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**    * A {@link KVComparator} for<code>-ROOT-</code> catalog table    * {@link KeyValue}s.    */
specifier|public
specifier|static
class|class
name|RootComparator
extends|extends
name|MetaComparator
block|{
specifier|private
specifier|final
name|KeyComparator
name|rawcomparator
init|=
operator|new
name|RootKeyComparator
argument_list|()
decl_stmt|;
specifier|public
name|KeyComparator
name|getRawComparator
parameter_list|()
block|{
return|return
name|this
operator|.
name|rawcomparator
return|;
block|}
block|}
comment|/**    * A {@link KVComparator} for<code>.META.</code> catalog table    * {@link KeyValue}s.    */
specifier|public
specifier|static
class|class
name|MetaComparator
extends|extends
name|KVComparator
block|{
specifier|private
specifier|final
name|KeyComparator
name|rawcomparator
init|=
operator|new
name|MetaKeyComparator
argument_list|()
decl_stmt|;
specifier|public
name|KeyComparator
name|getRawComparator
parameter_list|()
block|{
return|return
name|this
operator|.
name|rawcomparator
return|;
block|}
block|}
comment|/**    * Compare KeyValues.    * Hosts a {@link KeyComparator}.    */
specifier|public
specifier|static
class|class
name|KVComparator
implements|implements
name|java
operator|.
name|util
operator|.
name|Comparator
argument_list|<
name|KeyValue
argument_list|>
block|{
specifier|private
specifier|final
name|KeyComparator
name|rawcomparator
init|=
operator|new
name|KeyComparator
argument_list|()
decl_stmt|;
comment|/**      * @return RawComparator that can compare the Key portion of a KeyValue.      * Used in hfile where indices are the Key portion of a KeyValue.      */
specifier|public
name|KeyComparator
name|getRawComparator
parameter_list|()
block|{
return|return
name|this
operator|.
name|rawcomparator
return|;
block|}
specifier|public
name|int
name|compare
parameter_list|(
specifier|final
name|KeyValue
name|left
parameter_list|,
specifier|final
name|KeyValue
name|right
parameter_list|)
block|{
return|return
name|getRawComparator
argument_list|()
operator|.
name|compare
argument_list|(
name|left
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|left
operator|.
name|getOffset
argument_list|()
operator|+
name|ROW_OFFSET
argument_list|,
name|left
operator|.
name|getKeyLength
argument_list|()
argument_list|,
name|right
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|right
operator|.
name|getOffset
argument_list|()
operator|+
name|ROW_OFFSET
argument_list|,
name|right
operator|.
name|getKeyLength
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|int
name|compareTimestamps
parameter_list|(
specifier|final
name|KeyValue
name|left
parameter_list|,
specifier|final
name|KeyValue
name|right
parameter_list|)
block|{
return|return
name|compareTimestamps
argument_list|(
name|left
argument_list|,
name|left
operator|.
name|getKeyLength
argument_list|()
argument_list|,
name|right
argument_list|,
name|right
operator|.
name|getKeyLength
argument_list|()
argument_list|)
return|;
block|}
name|int
name|compareTimestamps
parameter_list|(
specifier|final
name|KeyValue
name|left
parameter_list|,
specifier|final
name|int
name|lkeylength
parameter_list|,
specifier|final
name|KeyValue
name|right
parameter_list|,
specifier|final
name|int
name|rkeylength
parameter_list|)
block|{
comment|// Compare timestamps
name|long
name|ltimestamp
init|=
name|left
operator|.
name|getTimestamp
argument_list|(
name|lkeylength
argument_list|)
decl_stmt|;
name|long
name|rtimestamp
init|=
name|right
operator|.
name|getTimestamp
argument_list|(
name|rkeylength
argument_list|)
decl_stmt|;
return|return
name|getRawComparator
argument_list|()
operator|.
name|compareTimestamps
argument_list|(
name|ltimestamp
argument_list|,
name|rtimestamp
argument_list|)
return|;
block|}
comment|/**      * @param left      * @param right      * @return Result comparing rows.      */
specifier|public
name|int
name|compareRows
parameter_list|(
specifier|final
name|KeyValue
name|left
parameter_list|,
specifier|final
name|KeyValue
name|right
parameter_list|)
block|{
return|return
name|compareRows
argument_list|(
name|left
argument_list|,
name|left
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|right
argument_list|,
name|right
operator|.
name|getRowLength
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * @param left      * @param lrowlength Length of left row.      * @param right      * @param rrowlength Length of right row.      * @return Result comparing rows.      */
specifier|public
name|int
name|compareRows
parameter_list|(
specifier|final
name|KeyValue
name|left
parameter_list|,
specifier|final
name|short
name|lrowlength
parameter_list|,
specifier|final
name|KeyValue
name|right
parameter_list|,
specifier|final
name|short
name|rrowlength
parameter_list|)
block|{
return|return
name|getRawComparator
argument_list|()
operator|.
name|compareRows
argument_list|(
name|left
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|left
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|lrowlength
argument_list|,
name|right
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|right
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|rrowlength
argument_list|)
return|;
block|}
comment|/**      * @param left      * @param row      * @return      */
specifier|public
name|int
name|compareRows
parameter_list|(
specifier|final
name|KeyValue
name|left
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|)
block|{
return|return
name|getRawComparator
argument_list|()
operator|.
name|compareRows
argument_list|(
name|left
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|left
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|left
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|row
argument_list|,
literal|0
argument_list|,
name|row
operator|.
name|length
argument_list|)
return|;
block|}
specifier|public
name|int
name|compareRows
parameter_list|(
name|byte
index|[]
name|left
parameter_list|,
name|int
name|loffset
parameter_list|,
name|int
name|llength
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|roffset
parameter_list|,
name|int
name|rlength
parameter_list|)
block|{
return|return
name|getRawComparator
argument_list|()
operator|.
name|compareRows
argument_list|(
name|left
argument_list|,
name|loffset
argument_list|,
name|llength
argument_list|,
name|right
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|)
return|;
block|}
specifier|public
name|int
name|compareColumns
parameter_list|(
specifier|final
name|KeyValue
name|left
parameter_list|,
specifier|final
name|byte
index|[]
name|right
parameter_list|,
specifier|final
name|int
name|roffset
parameter_list|,
specifier|final
name|int
name|rlength
parameter_list|)
block|{
name|int
name|offset
init|=
name|left
operator|.
name|getColumnOffset
argument_list|()
decl_stmt|;
name|int
name|length
init|=
name|left
operator|.
name|getColumnLength
argument_list|(
name|offset
argument_list|)
decl_stmt|;
return|return
name|getRawComparator
argument_list|()
operator|.
name|compareColumns
argument_list|(
name|left
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|right
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|)
return|;
block|}
name|int
name|compareColumns
parameter_list|(
specifier|final
name|KeyValue
name|left
parameter_list|,
specifier|final
name|short
name|lrowlength
parameter_list|,
specifier|final
name|int
name|lkeylength
parameter_list|,
specifier|final
name|KeyValue
name|right
parameter_list|,
specifier|final
name|short
name|rrowlength
parameter_list|,
specifier|final
name|int
name|rkeylength
parameter_list|)
block|{
name|int
name|loffset
init|=
name|left
operator|.
name|getColumnOffset
argument_list|(
name|lrowlength
argument_list|)
decl_stmt|;
name|int
name|roffset
init|=
name|right
operator|.
name|getColumnOffset
argument_list|(
name|rrowlength
argument_list|)
decl_stmt|;
name|int
name|llength
init|=
name|left
operator|.
name|getColumnLength
argument_list|(
name|loffset
argument_list|,
name|lkeylength
argument_list|)
decl_stmt|;
name|int
name|rlength
init|=
name|right
operator|.
name|getColumnLength
argument_list|(
name|roffset
argument_list|,
name|rkeylength
argument_list|)
decl_stmt|;
return|return
name|getRawComparator
argument_list|()
operator|.
name|compareColumns
argument_list|(
name|left
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|loffset
argument_list|,
name|llength
argument_list|,
name|right
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|)
return|;
block|}
comment|/**      * Compares the row and column of two keyvalues      * @param left      * @param right      * @return True if same row and column.      */
specifier|public
name|boolean
name|matchingRowColumn
parameter_list|(
specifier|final
name|KeyValue
name|left
parameter_list|,
specifier|final
name|KeyValue
name|right
parameter_list|)
block|{
name|short
name|lrowlength
init|=
name|left
operator|.
name|getRowLength
argument_list|()
decl_stmt|;
name|short
name|rrowlength
init|=
name|right
operator|.
name|getRowLength
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|matchingRows
argument_list|(
name|left
argument_list|,
name|lrowlength
argument_list|,
name|right
argument_list|,
name|rrowlength
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|lkeylength
init|=
name|left
operator|.
name|getKeyLength
argument_list|()
decl_stmt|;
name|int
name|rkeylength
init|=
name|right
operator|.
name|getKeyLength
argument_list|()
decl_stmt|;
return|return
name|compareColumns
argument_list|(
name|left
argument_list|,
name|lrowlength
argument_list|,
name|lkeylength
argument_list|,
name|right
argument_list|,
name|rrowlength
argument_list|,
name|rkeylength
argument_list|)
operator|==
literal|0
return|;
block|}
comment|/**      * @param left      * @param right      * @return True if rows match.      */
specifier|public
name|boolean
name|matchingRows
parameter_list|(
specifier|final
name|KeyValue
name|left
parameter_list|,
specifier|final
name|byte
index|[]
name|right
parameter_list|)
block|{
return|return
name|compareRows
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
operator|==
literal|0
return|;
block|}
comment|/**      * @param left      * @param right      * @return True if rows match.      */
specifier|public
name|boolean
name|matchingRows
parameter_list|(
specifier|final
name|KeyValue
name|left
parameter_list|,
specifier|final
name|KeyValue
name|right
parameter_list|)
block|{
name|short
name|lrowlength
init|=
name|left
operator|.
name|getRowLength
argument_list|()
decl_stmt|;
name|short
name|rrowlength
init|=
name|right
operator|.
name|getRowLength
argument_list|()
decl_stmt|;
return|return
name|matchingRows
argument_list|(
name|left
argument_list|,
name|lrowlength
argument_list|,
name|right
argument_list|,
name|rrowlength
argument_list|)
return|;
block|}
comment|/**      * @param left      * @param lrowlength      * @param right      * @param rrowlength      * @return True if rows match.      */
specifier|public
name|boolean
name|matchingRows
parameter_list|(
specifier|final
name|KeyValue
name|left
parameter_list|,
specifier|final
name|short
name|lrowlength
parameter_list|,
specifier|final
name|KeyValue
name|right
parameter_list|,
specifier|final
name|short
name|rrowlength
parameter_list|)
block|{
name|int
name|compare
init|=
name|compareRows
argument_list|(
name|left
argument_list|,
name|lrowlength
argument_list|,
name|right
argument_list|,
name|rrowlength
argument_list|)
decl_stmt|;
if|if
condition|(
name|compare
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|matchingRows
parameter_list|(
specifier|final
name|byte
index|[]
name|left
parameter_list|,
specifier|final
name|int
name|loffset
parameter_list|,
specifier|final
name|int
name|llength
parameter_list|,
specifier|final
name|byte
index|[]
name|right
parameter_list|,
specifier|final
name|int
name|roffset
parameter_list|,
specifier|final
name|int
name|rlength
parameter_list|)
block|{
name|int
name|compare
init|=
name|compareRows
argument_list|(
name|left
argument_list|,
name|loffset
argument_list|,
name|llength
argument_list|,
name|right
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|)
decl_stmt|;
if|if
condition|(
name|compare
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Compares the row and timestamp of two keys      * Was called matchesWithoutColumn in HStoreKey.      * @param right Key to compare against.      * @return True if same row and timestamp is greater than the timestamp in      *<code>right</code>      */
specifier|public
name|boolean
name|matchingRowsGreaterTimestamp
parameter_list|(
specifier|final
name|KeyValue
name|left
parameter_list|,
specifier|final
name|KeyValue
name|right
parameter_list|)
block|{
name|short
name|lrowlength
init|=
name|left
operator|.
name|getRowLength
argument_list|()
decl_stmt|;
name|short
name|rrowlength
init|=
name|right
operator|.
name|getRowLength
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|matchingRows
argument_list|(
name|left
argument_list|,
name|lrowlength
argument_list|,
name|right
argument_list|,
name|rrowlength
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|left
operator|.
name|getTimestamp
argument_list|()
operator|>=
name|right
operator|.
name|getTimestamp
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|protected
name|Object
name|clone
parameter_list|()
throws|throws
name|CloneNotSupportedException
block|{
return|return
operator|new
name|KVComparator
argument_list|()
return|;
block|}
comment|/**      * @return Comparator that ignores timestamps; useful counting versions.      * @throws IOException      */
specifier|public
name|KVComparator
name|getComparatorIgnoringTimestamps
parameter_list|()
block|{
name|KVComparator
name|c
init|=
literal|null
decl_stmt|;
try|try
block|{
name|c
operator|=
operator|(
name|KVComparator
operator|)
name|this
operator|.
name|clone
argument_list|()
expr_stmt|;
name|c
operator|.
name|getRawComparator
argument_list|()
operator|.
name|ignoreTimestamp
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Not supported"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
comment|/**      * @return Comparator that ignores key type; useful checking deletes      * @throws IOException      */
specifier|public
name|KVComparator
name|getComparatorIgnoringType
parameter_list|()
block|{
name|KVComparator
name|c
init|=
literal|null
decl_stmt|;
try|try
block|{
name|c
operator|=
operator|(
name|KVComparator
operator|)
name|this
operator|.
name|clone
argument_list|()
expr_stmt|;
name|c
operator|.
name|getRawComparator
argument_list|()
operator|.
name|ignoreType
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Not supported"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
block|}
comment|/**    * @param row    * @return First possible KeyValue on passed<code>row</code>    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|)
block|{
return|return
name|createFirstOnRow
argument_list|(
name|row
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|)
return|;
block|}
comment|/**    * @param row    * @param ts    * @return First possible key on passed<code>row</code> and timestamp.    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|long
name|ts
parameter_list|)
block|{
return|return
name|createFirstOnRow
argument_list|(
name|row
argument_list|,
literal|null
argument_list|,
name|ts
argument_list|)
return|;
block|}
comment|/**    * @param row    * @param ts    * @return First possible key on passed<code>row</code>, column and timestamp.    */
specifier|public
specifier|static
name|KeyValue
name|createFirstOnRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|c
parameter_list|,
specifier|final
name|long
name|ts
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
name|c
argument_list|,
name|ts
argument_list|,
name|Type
operator|.
name|Maximum
argument_list|)
return|;
block|}
comment|/**    * @param b    * @param o    * @param l    * @return A KeyValue made of a byte array that holds the key-only part.    * Needed to convert hfile index members to KeyValues.    */
specifier|public
specifier|static
name|KeyValue
name|createKeyValueFromKey
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|,
specifier|final
name|int
name|o
parameter_list|,
specifier|final
name|int
name|l
parameter_list|)
block|{
name|byte
index|[]
name|newb
init|=
operator|new
name|byte
index|[
name|b
operator|.
name|length
operator|+
name|ROW_OFFSET
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|b
argument_list|,
name|o
argument_list|,
name|newb
argument_list|,
name|ROW_OFFSET
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|Bytes
operator|.
name|putInt
argument_list|(
name|newb
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|length
argument_list|)
expr_stmt|;
name|Bytes
operator|.
name|putInt
argument_list|(
name|newb
argument_list|,
name|Bytes
operator|.
name|SIZEOF_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|new
name|KeyValue
argument_list|(
name|newb
argument_list|)
return|;
block|}
comment|/**    * Compare key portion of a {@link KeyValue} for keys in<code>-ROOT-<code>    * table.    */
specifier|public
specifier|static
class|class
name|RootKeyComparator
extends|extends
name|MetaKeyComparator
block|{
specifier|public
name|int
name|compareRows
parameter_list|(
name|byte
index|[]
name|left
parameter_list|,
name|int
name|loffset
parameter_list|,
name|int
name|llength
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|roffset
parameter_list|,
name|int
name|rlength
parameter_list|)
block|{
comment|// Rows look like this: .META.,ROW_FROM_META,RID
comment|//        LOG.info("ROOT " + Bytes.toString(left, loffset, llength) +
comment|//          "---" + Bytes.toString(right, roffset, rlength));
specifier|final
name|int
name|metalength
init|=
literal|7
decl_stmt|;
comment|// '.META.' length
name|int
name|lmetaOffsetPlusDelimiter
init|=
name|loffset
operator|+
name|metalength
decl_stmt|;
name|int
name|leftFarDelimiter
init|=
name|getDelimiterInReverse
argument_list|(
name|left
argument_list|,
name|lmetaOffsetPlusDelimiter
argument_list|,
name|llength
operator|-
name|metalength
argument_list|,
name|HRegionInfo
operator|.
name|DELIMITER
argument_list|)
decl_stmt|;
name|int
name|rmetaOffsetPlusDelimiter
init|=
name|roffset
operator|+
name|metalength
decl_stmt|;
name|int
name|rightFarDelimiter
init|=
name|getDelimiterInReverse
argument_list|(
name|right
argument_list|,
name|rmetaOffsetPlusDelimiter
argument_list|,
name|rlength
operator|-
name|metalength
argument_list|,
name|HRegionInfo
operator|.
name|DELIMITER
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftFarDelimiter
operator|<
literal|0
operator|&&
name|rightFarDelimiter
operator|>=
literal|0
condition|)
block|{
comment|// Nothing between .META. and regionid.  Its first key.
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|rightFarDelimiter
operator|<
literal|0
operator|&&
name|leftFarDelimiter
operator|>=
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|leftFarDelimiter
operator|<
literal|0
operator|&&
name|rightFarDelimiter
operator|<
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|int
name|result
init|=
name|super
operator|.
name|compareRows
argument_list|(
name|left
argument_list|,
name|lmetaOffsetPlusDelimiter
argument_list|,
name|leftFarDelimiter
operator|-
name|lmetaOffsetPlusDelimiter
argument_list|,
name|right
argument_list|,
name|rmetaOffsetPlusDelimiter
argument_list|,
name|rightFarDelimiter
operator|-
name|rmetaOffsetPlusDelimiter
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
comment|// Compare last part of row, the rowid.
name|leftFarDelimiter
operator|++
expr_stmt|;
name|rightFarDelimiter
operator|++
expr_stmt|;
name|result
operator|=
name|compareRowid
argument_list|(
name|left
argument_list|,
name|leftFarDelimiter
argument_list|,
name|llength
operator|-
operator|(
name|leftFarDelimiter
operator|-
name|loffset
operator|)
argument_list|,
name|right
argument_list|,
name|rightFarDelimiter
argument_list|,
name|rlength
operator|-
operator|(
name|rightFarDelimiter
operator|-
name|roffset
operator|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
comment|/**    * Compare key portion of a {@link KeyValue} for keys in<code>.META.</code>    * table.    */
specifier|public
specifier|static
class|class
name|MetaKeyComparator
extends|extends
name|KeyComparator
block|{
specifier|public
name|int
name|compareRows
parameter_list|(
name|byte
index|[]
name|left
parameter_list|,
name|int
name|loffset
parameter_list|,
name|int
name|llength
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|roffset
parameter_list|,
name|int
name|rlength
parameter_list|)
block|{
comment|//        LOG.info("META " + Bytes.toString(left, loffset, llength) +
comment|//          "---" + Bytes.toString(right, roffset, rlength));
name|int
name|leftDelimiter
init|=
name|getDelimiter
argument_list|(
name|left
argument_list|,
name|loffset
argument_list|,
name|llength
argument_list|,
name|HRegionInfo
operator|.
name|DELIMITER
argument_list|)
decl_stmt|;
name|int
name|rightDelimiter
init|=
name|getDelimiter
argument_list|(
name|right
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|,
name|HRegionInfo
operator|.
name|DELIMITER
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftDelimiter
operator|<
literal|0
operator|&&
name|rightDelimiter
operator|>=
literal|0
condition|)
block|{
comment|// Nothing between .META. and regionid.  Its first key.
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|rightDelimiter
operator|<
literal|0
operator|&&
name|leftDelimiter
operator|>=
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|leftDelimiter
operator|<
literal|0
operator|&&
name|rightDelimiter
operator|<
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|// Compare up to the delimiter
name|int
name|result
init|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
argument_list|,
name|loffset
argument_list|,
name|leftDelimiter
operator|-
name|loffset
argument_list|,
name|right
argument_list|,
name|roffset
argument_list|,
name|rightDelimiter
operator|-
name|roffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
comment|// Compare middle bit of the row.
comment|// Move past delimiter
name|leftDelimiter
operator|++
expr_stmt|;
name|rightDelimiter
operator|++
expr_stmt|;
name|int
name|leftFarDelimiter
init|=
name|getRequiredDelimiterInReverse
argument_list|(
name|left
argument_list|,
name|leftDelimiter
argument_list|,
name|llength
operator|-
operator|(
name|leftDelimiter
operator|-
name|loffset
operator|)
argument_list|,
name|HRegionInfo
operator|.
name|DELIMITER
argument_list|)
decl_stmt|;
name|int
name|rightFarDelimiter
init|=
name|getRequiredDelimiterInReverse
argument_list|(
name|right
argument_list|,
name|rightDelimiter
argument_list|,
name|rlength
operator|-
operator|(
name|rightDelimiter
operator|-
name|roffset
operator|)
argument_list|,
name|HRegionInfo
operator|.
name|DELIMITER
argument_list|)
decl_stmt|;
comment|// Now compare middlesection of row.
name|result
operator|=
name|super
operator|.
name|compareRows
argument_list|(
name|left
argument_list|,
name|leftDelimiter
argument_list|,
name|leftFarDelimiter
operator|-
name|leftDelimiter
argument_list|,
name|right
argument_list|,
name|rightDelimiter
argument_list|,
name|rightFarDelimiter
operator|-
name|rightDelimiter
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
comment|// Compare last part of row, the rowid.
name|leftFarDelimiter
operator|++
expr_stmt|;
name|rightFarDelimiter
operator|++
expr_stmt|;
name|result
operator|=
name|compareRowid
argument_list|(
name|left
argument_list|,
name|leftFarDelimiter
argument_list|,
name|llength
operator|-
operator|(
name|leftFarDelimiter
operator|-
name|loffset
operator|)
argument_list|,
name|right
argument_list|,
name|rightFarDelimiter
argument_list|,
name|rlength
operator|-
operator|(
name|rightFarDelimiter
operator|-
name|roffset
operator|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|protected
name|int
name|compareRowid
parameter_list|(
name|byte
index|[]
name|left
parameter_list|,
name|int
name|loffset
parameter_list|,
name|int
name|llength
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|roffset
parameter_list|,
name|int
name|rlength
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
argument_list|,
name|loffset
argument_list|,
name|llength
argument_list|,
name|right
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|)
return|;
block|}
block|}
comment|/**    * Compare key portion of a {@link KeyValue}    */
specifier|public
specifier|static
class|class
name|KeyComparator
implements|implements
name|RawComparator
argument_list|<
name|byte
index|[]
argument_list|>
block|{
specifier|volatile
name|boolean
name|ignoreTimestamp
init|=
literal|false
decl_stmt|;
specifier|volatile
name|boolean
name|ignoreType
init|=
literal|false
decl_stmt|;
specifier|public
name|int
name|compare
parameter_list|(
name|byte
index|[]
name|left
parameter_list|,
name|int
name|loffset
parameter_list|,
name|int
name|llength
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|roffset
parameter_list|,
name|int
name|rlength
parameter_list|)
block|{
comment|// Compare row
name|short
name|lrowlength
init|=
name|Bytes
operator|.
name|toShort
argument_list|(
name|left
argument_list|,
name|loffset
argument_list|)
decl_stmt|;
name|short
name|rrowlength
init|=
name|Bytes
operator|.
name|toShort
argument_list|(
name|right
argument_list|,
name|roffset
argument_list|)
decl_stmt|;
name|int
name|compare
init|=
name|compareRows
argument_list|(
name|left
argument_list|,
name|loffset
operator|+
name|Bytes
operator|.
name|SIZEOF_SHORT
argument_list|,
name|lrowlength
argument_list|,
name|right
argument_list|,
name|roffset
operator|+
name|Bytes
operator|.
name|SIZEOF_SHORT
argument_list|,
name|rrowlength
argument_list|)
decl_stmt|;
if|if
condition|(
name|compare
operator|!=
literal|0
condition|)
block|{
return|return
name|compare
return|;
block|}
comment|// Compare column family.  Start compare past row and family length.
name|int
name|lcolumnoffset
init|=
name|Bytes
operator|.
name|SIZEOF_SHORT
operator|+
name|lrowlength
operator|+
literal|1
operator|+
name|loffset
decl_stmt|;
name|int
name|rcolumnoffset
init|=
name|Bytes
operator|.
name|SIZEOF_SHORT
operator|+
name|rrowlength
operator|+
literal|1
operator|+
name|roffset
decl_stmt|;
name|int
name|lcolumnlength
init|=
name|llength
operator|-
name|TIMESTAMP_TYPE_SIZE
operator|-
operator|(
name|lcolumnoffset
operator|-
name|loffset
operator|)
decl_stmt|;
name|int
name|rcolumnlength
init|=
name|rlength
operator|-
name|TIMESTAMP_TYPE_SIZE
operator|-
operator|(
name|rcolumnoffset
operator|-
name|roffset
operator|)
decl_stmt|;
name|compare
operator|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
argument_list|,
name|lcolumnoffset
argument_list|,
name|lcolumnlength
argument_list|,
name|right
argument_list|,
name|rcolumnoffset
argument_list|,
name|rcolumnlength
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
operator|!=
literal|0
condition|)
block|{
return|return
name|compare
return|;
block|}
if|if
condition|(
operator|!
name|this
operator|.
name|ignoreTimestamp
condition|)
block|{
comment|// Get timestamps.
name|long
name|ltimestamp
init|=
name|Bytes
operator|.
name|toLong
argument_list|(
name|left
argument_list|,
name|loffset
operator|+
operator|(
name|llength
operator|-
name|TIMESTAMP_TYPE_SIZE
operator|)
argument_list|)
decl_stmt|;
name|long
name|rtimestamp
init|=
name|Bytes
operator|.
name|toLong
argument_list|(
name|right
argument_list|,
name|roffset
operator|+
operator|(
name|rlength
operator|-
name|TIMESTAMP_TYPE_SIZE
operator|)
argument_list|)
decl_stmt|;
name|compare
operator|=
name|compareTimestamps
argument_list|(
name|ltimestamp
argument_list|,
name|rtimestamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
operator|!=
literal|0
condition|)
block|{
return|return
name|compare
return|;
block|}
block|}
if|if
condition|(
operator|!
name|this
operator|.
name|ignoreType
condition|)
block|{
comment|// Compare types. Let the delete types sort ahead of puts; i.e. types
comment|// of higher numbers sort before those of lesser numbers
name|byte
name|ltype
init|=
name|left
index|[
name|loffset
operator|+
operator|(
name|llength
operator|-
literal|1
operator|)
index|]
decl_stmt|;
name|byte
name|rtype
init|=
name|right
index|[
name|roffset
operator|+
operator|(
name|rlength
operator|-
literal|1
operator|)
index|]
decl_stmt|;
return|return
operator|(
literal|0xff
operator|&
name|rtype
operator|)
operator|-
operator|(
literal|0xff
operator|&
name|ltype
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
specifier|public
name|int
name|compare
parameter_list|(
name|byte
index|[]
name|left
parameter_list|,
name|byte
index|[]
name|right
parameter_list|)
block|{
return|return
name|compare
argument_list|(
name|left
argument_list|,
literal|0
argument_list|,
name|left
operator|.
name|length
argument_list|,
name|right
argument_list|,
literal|0
argument_list|,
name|right
operator|.
name|length
argument_list|)
return|;
block|}
specifier|protected
name|int
name|compareRows
parameter_list|(
name|byte
index|[]
name|left
parameter_list|,
name|int
name|loffset
parameter_list|,
name|int
name|llength
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|roffset
parameter_list|,
name|int
name|rlength
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|left
argument_list|,
name|loffset
argument_list|,
name|llength
argument_list|,
name|right
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|)
return|;
block|}
specifier|protected
name|int
name|compareColumns
parameter_list|(
name|byte
index|[]
name|left
parameter_list|,
name|int
name|loffset
parameter_list|,
name|int
name|llength
parameter_list|,
name|byte
index|[]
name|right
parameter_list|,
name|int
name|roffset
parameter_list|,
name|int
name|rlength
parameter_list|)
block|{
return|return
name|KeyValue
operator|.
name|compareColumns
argument_list|(
name|left
argument_list|,
name|loffset
argument_list|,
name|llength
argument_list|,
name|right
argument_list|,
name|roffset
argument_list|,
name|rlength
argument_list|)
return|;
block|}
name|int
name|compareTimestamps
parameter_list|(
specifier|final
name|long
name|ltimestamp
parameter_list|,
specifier|final
name|long
name|rtimestamp
parameter_list|)
block|{
comment|// The below older timestamps sorting ahead of newer timestamps looks
comment|// wrong but it is intentional. This way, newer timestamps are first
comment|// found when we iterate over a memcache and newer versions are the
comment|// first we trip over when reading from a store file.
if|if
condition|(
name|ltimestamp
operator|<
name|rtimestamp
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|ltimestamp
operator|>
name|rtimestamp
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
block|}
end_class

end_unit

