begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2006 The Apache Software Foundation  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReadWriteLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_comment
comment|/*******************************************************************************  * HRegionServer makes a set of HRegions available to clients.  It checks in with  * the HMaster. There are many HRegionServers in a single HBase deployment.  ******************************************************************************/
end_comment

begin_class
specifier|public
class|class
name|HRegionServer
implements|implements
name|HConstants
implements|,
name|HRegionInterface
implements|,
name|Runnable
block|{
specifier|public
name|long
name|getProtocolVersion
parameter_list|(
name|String
name|protocol
parameter_list|,
name|long
name|clientVersion
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|HRegionInterface
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|HRegionInterface
operator|.
name|versionID
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown protocol to name node: "
operator|+
name|protocol
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HRegionServer
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|boolean
name|stopRequested
decl_stmt|;
specifier|private
name|Path
name|regionDir
decl_stmt|;
specifier|private
name|HServerAddress
name|address
decl_stmt|;
specifier|private
name|Configuration
name|conf
decl_stmt|;
specifier|private
name|Random
name|rand
decl_stmt|;
specifier|private
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|HRegion
argument_list|>
name|regions
decl_stmt|;
comment|// region name -> HRegion
specifier|private
name|ReadWriteLock
name|locker
decl_stmt|;
specifier|private
name|Vector
argument_list|<
name|HMsg
argument_list|>
name|outboundMsgs
decl_stmt|;
specifier|private
name|long
name|threadWakeFrequency
decl_stmt|;
specifier|private
name|int
name|maxLogEntries
decl_stmt|;
specifier|private
name|long
name|msgInterval
decl_stmt|;
comment|// Check to see if regions should be split
specifier|private
name|long
name|splitCheckFrequency
decl_stmt|;
specifier|private
name|SplitChecker
name|splitChecker
decl_stmt|;
specifier|private
name|Thread
name|splitCheckerThread
decl_stmt|;
specifier|private
class|class
name|SplitChecker
implements|implements
name|Runnable
block|{
specifier|private
name|HClient
name|client
init|=
operator|new
name|HClient
argument_list|(
name|conf
argument_list|)
decl_stmt|;
specifier|private
class|class
name|SplitRegion
block|{
specifier|public
name|HRegion
name|region
decl_stmt|;
specifier|public
name|Text
name|midKey
decl_stmt|;
name|SplitRegion
parameter_list|(
name|HRegion
name|region
parameter_list|,
name|Text
name|midKey
parameter_list|)
block|{
name|this
operator|.
name|region
operator|=
name|region
expr_stmt|;
name|this
operator|.
name|midKey
operator|=
name|midKey
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
operator|!
name|stopRequested
condition|)
block|{
name|long
name|startTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|// Grab a list of regions to check
name|Vector
argument_list|<
name|HRegion
argument_list|>
name|checkSplit
init|=
operator|new
name|Vector
argument_list|<
name|HRegion
argument_list|>
argument_list|()
decl_stmt|;
name|locker
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|checkSplit
operator|.
name|addAll
argument_list|(
name|regions
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|locker
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// Check to see if they need splitting
name|Vector
argument_list|<
name|SplitRegion
argument_list|>
name|toSplit
init|=
operator|new
name|Vector
argument_list|<
name|SplitRegion
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|HRegion
argument_list|>
name|it
init|=
name|checkSplit
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|HRegion
name|cur
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|Text
name|midKey
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|cur
operator|.
name|needsSplit
argument_list|(
name|midKey
argument_list|)
condition|)
block|{
name|toSplit
operator|.
name|add
argument_list|(
operator|new
name|SplitRegion
argument_list|(
name|cur
argument_list|,
name|midKey
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|iex
parameter_list|)
block|{
name|iex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
for|for
control|(
name|Iterator
argument_list|<
name|SplitRegion
argument_list|>
name|it
init|=
name|toSplit
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|SplitRegion
name|r
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|locker
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
name|regions
operator|.
name|remove
argument_list|(
name|r
operator|.
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
name|locker
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|HRegion
index|[]
name|newRegions
init|=
literal|null
decl_stmt|;
try|try
block|{
name|Text
name|oldRegion
init|=
name|r
operator|.
name|region
operator|.
name|getRegionName
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"splitting region: "
operator|+
name|oldRegion
argument_list|)
expr_stmt|;
name|newRegions
operator|=
name|r
operator|.
name|region
operator|.
name|closeAndSplit
argument_list|(
name|r
operator|.
name|midKey
argument_list|)
expr_stmt|;
comment|// When a region is split, the META table needs to updated if we're
comment|// splitting a 'normal' region, and the ROOT table needs to be
comment|// updated if we are splitting a META region.
name|Text
name|tableToUpdate
init|=
operator|(
name|oldRegion
operator|.
name|find
argument_list|(
name|META_TABLE_NAME
operator|.
name|toString
argument_list|()
argument_list|)
operator|==
literal|0
operator|)
condition|?
name|ROOT_TABLE_NAME
else|:
name|META_TABLE_NAME
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"region split complete. updating meta"
argument_list|)
expr_stmt|;
name|client
operator|.
name|openTable
argument_list|(
name|tableToUpdate
argument_list|)
expr_stmt|;
name|long
name|lockid
init|=
name|client
operator|.
name|startUpdate
argument_list|(
name|oldRegion
argument_list|)
decl_stmt|;
name|client
operator|.
name|delete
argument_list|(
name|lockid
argument_list|,
name|META_COL_REGIONINFO
argument_list|)
expr_stmt|;
name|client
operator|.
name|delete
argument_list|(
name|lockid
argument_list|,
name|META_COL_SERVER
argument_list|)
expr_stmt|;
name|client
operator|.
name|delete
argument_list|(
name|lockid
argument_list|,
name|META_COL_STARTCODE
argument_list|)
expr_stmt|;
name|client
operator|.
name|commit
argument_list|(
name|lockid
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newRegions
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ByteArrayOutputStream
name|bytes
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|DataOutputStream
name|out
init|=
operator|new
name|DataOutputStream
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
name|newRegions
index|[
name|i
index|]
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|lockid
operator|=
name|client
operator|.
name|startUpdate
argument_list|(
name|newRegions
index|[
name|i
index|]
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
name|client
operator|.
name|put
argument_list|(
name|lockid
argument_list|,
name|META_COL_REGIONINFO
argument_list|,
name|bytes
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
name|client
operator|.
name|commit
argument_list|(
name|lockid
argument_list|)
expr_stmt|;
block|}
comment|// Now tell the master about the new regions
name|LOG
operator|.
name|debug
argument_list|(
literal|"reporting region split to master"
argument_list|)
expr_stmt|;
name|reportSplit
argument_list|(
name|newRegions
index|[
literal|0
index|]
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|newRegions
index|[
literal|1
index|]
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"region split successful. old region="
operator|+
name|oldRegion
operator|+
literal|", new regions: "
operator|+
name|newRegions
index|[
literal|0
index|]
operator|.
name|getRegionName
argument_list|()
operator|+
literal|", "
operator|+
name|newRegions
index|[
literal|1
index|]
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
name|newRegions
index|[
literal|0
index|]
operator|.
name|close
argument_list|()
expr_stmt|;
name|newRegions
index|[
literal|1
index|]
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|//TODO: What happens if this fails? Are we toast?
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
comment|// Sleep
name|long
name|waitTime
init|=
name|splitCheckFrequency
operator|-
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
operator|)
decl_stmt|;
if|if
condition|(
name|waitTime
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|waitTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{           }
block|}
block|}
block|}
block|}
comment|// Cache flushing
specifier|private
name|Flusher
name|cacheFlusher
decl_stmt|;
specifier|private
name|Thread
name|cacheFlusherThread
decl_stmt|;
specifier|private
class|class
name|Flusher
implements|implements
name|Runnable
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
operator|!
name|stopRequested
condition|)
block|{
name|long
name|startTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|// Grab a list of items to flush
name|Vector
argument_list|<
name|HRegion
argument_list|>
name|toFlush
init|=
operator|new
name|Vector
argument_list|<
name|HRegion
argument_list|>
argument_list|()
decl_stmt|;
name|locker
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|toFlush
operator|.
name|addAll
argument_list|(
name|regions
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|locker
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// Flush them, if necessary
for|for
control|(
name|Iterator
argument_list|<
name|HRegion
argument_list|>
name|it
init|=
name|toFlush
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|HRegion
name|cur
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
name|cur
operator|.
name|optionallyFlush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|iex
parameter_list|)
block|{
name|iex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Sleep
name|long
name|waitTime
init|=
name|threadWakeFrequency
operator|-
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
operator|)
decl_stmt|;
if|if
condition|(
name|waitTime
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|waitTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{           }
block|}
block|}
block|}
block|}
comment|// File paths
specifier|private
name|FileSystem
name|fs
decl_stmt|;
specifier|private
name|Path
name|oldlogfile
decl_stmt|;
comment|// Logging
specifier|private
name|HLog
name|log
decl_stmt|;
specifier|private
name|LogRoller
name|logRoller
decl_stmt|;
specifier|private
name|Thread
name|logRollerThread
decl_stmt|;
specifier|private
class|class
name|LogRoller
implements|implements
name|Runnable
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
operator|!
name|stopRequested
condition|)
block|{
comment|// If the number of log entries is high enough, roll the log.  This is a
comment|// very fast operation, but should not be done too frequently.
if|if
condition|(
name|log
operator|.
name|getNumEntries
argument_list|()
operator|>
name|maxLogEntries
condition|)
block|{
try|try
block|{
name|log
operator|.
name|rollWriter
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|iex
parameter_list|)
block|{           }
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|threadWakeFrequency
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{         }
block|}
block|}
block|}
comment|// Remote HMaster
specifier|private
name|HMasterRegionInterface
name|hbaseMaster
decl_stmt|;
comment|// Server
specifier|private
name|Server
name|server
decl_stmt|;
comment|// Leases
specifier|private
name|Leases
name|leases
decl_stmt|;
comment|/** Start a HRegionServer at the default location */
specifier|public
name|HRegionServer
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|HREGION_DIR
argument_list|,
name|DEFAULT_HREGION_DIR
argument_list|)
argument_list|)
argument_list|,
operator|new
name|HServerAddress
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|REGIONSERVER_ADDRESS
argument_list|,
literal|"localhost:0"
argument_list|)
argument_list|)
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/** Start a HRegionServer at an indicated location */
specifier|public
name|HRegionServer
parameter_list|(
name|Path
name|regionDir
parameter_list|,
name|HServerAddress
name|address
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Basic setup
name|this
operator|.
name|stopRequested
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|regionDir
operator|=
name|regionDir
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|rand
operator|=
operator|new
name|Random
argument_list|()
expr_stmt|;
name|this
operator|.
name|regions
operator|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|HRegion
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|locker
operator|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
expr_stmt|;
name|this
operator|.
name|outboundMsgs
operator|=
operator|new
name|Vector
argument_list|<
name|HMsg
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|scanners
operator|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|HScannerInterface
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
comment|// Config'ed params
name|this
operator|.
name|threadWakeFrequency
operator|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.hregionserver.thread.wakefrequency"
argument_list|,
literal|10
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxLogEntries
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.hregionserver.maxlogentries"
argument_list|,
literal|30
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|this
operator|.
name|msgInterval
operator|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.hregionserver.msginterval"
argument_list|,
literal|15
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|this
operator|.
name|splitCheckFrequency
operator|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.hregionserver.thread.splitcheckfrequency"
argument_list|,
literal|60
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|// Cache flushing
name|this
operator|.
name|cacheFlusher
operator|=
operator|new
name|Flusher
argument_list|()
expr_stmt|;
name|this
operator|.
name|cacheFlusherThread
operator|=
operator|new
name|Thread
argument_list|(
name|cacheFlusher
argument_list|,
literal|"HRegionServer.cacheFlusher"
argument_list|)
expr_stmt|;
comment|// Check regions to see if they need to be split
name|this
operator|.
name|splitChecker
operator|=
operator|new
name|SplitChecker
argument_list|()
expr_stmt|;
name|this
operator|.
name|splitCheckerThread
operator|=
operator|new
name|Thread
argument_list|(
name|splitChecker
argument_list|,
literal|"HRegionServer.splitChecker"
argument_list|)
expr_stmt|;
comment|// Process requests from Master
name|this
operator|.
name|toDo
operator|=
operator|new
name|Vector
argument_list|<
name|HMsg
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|worker
operator|=
operator|new
name|Worker
argument_list|()
expr_stmt|;
name|this
operator|.
name|workerThread
operator|=
operator|new
name|Thread
argument_list|(
name|worker
argument_list|,
literal|"HRegionServer.worker"
argument_list|)
expr_stmt|;
try|try
block|{
comment|// Server to handle client requests
name|this
operator|.
name|server
operator|=
name|RPC
operator|.
name|getServer
argument_list|(
name|this
argument_list|,
name|address
operator|.
name|getBindAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|address
operator|.
name|getPort
argument_list|()
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.hregionserver.handler.count"
argument_list|,
literal|10
argument_list|)
argument_list|,
literal|false
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|address
operator|=
operator|new
name|HServerAddress
argument_list|(
name|server
operator|.
name|getListenerAddress
argument_list|()
argument_list|)
expr_stmt|;
comment|// Local file paths
name|String
name|serverName
init|=
name|this
operator|.
name|address
operator|.
name|getBindAddress
argument_list|()
operator|+
literal|"_"
operator|+
name|this
operator|.
name|address
operator|.
name|getPort
argument_list|()
decl_stmt|;
name|Path
name|newlogdir
init|=
operator|new
name|Path
argument_list|(
name|regionDir
argument_list|,
literal|"log"
operator|+
literal|"_"
operator|+
name|serverName
argument_list|)
decl_stmt|;
name|this
operator|.
name|oldlogfile
operator|=
operator|new
name|Path
argument_list|(
name|regionDir
argument_list|,
literal|"oldlogfile"
operator|+
literal|"_"
operator|+
name|serverName
argument_list|)
expr_stmt|;
comment|// Logging
name|this
operator|.
name|fs
operator|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|HLog
operator|.
name|consolidateOldLog
argument_list|(
name|newlogdir
argument_list|,
name|oldlogfile
argument_list|,
name|fs
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|log
operator|=
operator|new
name|HLog
argument_list|(
name|fs
argument_list|,
name|newlogdir
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|logRoller
operator|=
operator|new
name|LogRoller
argument_list|()
expr_stmt|;
name|this
operator|.
name|logRollerThread
operator|=
operator|new
name|Thread
argument_list|(
name|logRoller
argument_list|,
literal|"HRegionServer.logRoller"
argument_list|)
expr_stmt|;
comment|// Remote HMaster
name|this
operator|.
name|hbaseMaster
operator|=
operator|(
name|HMasterRegionInterface
operator|)
name|RPC
operator|.
name|waitForProxy
argument_list|(
name|HMasterRegionInterface
operator|.
name|class
argument_list|,
name|HMasterRegionInterface
operator|.
name|versionID
argument_list|,
operator|new
name|HServerAddress
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|MASTER_ADDRESS
argument_list|)
argument_list|)
operator|.
name|getInetSocketAddress
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
comment|// Threads
name|this
operator|.
name|workerThread
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|cacheFlusherThread
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|splitCheckerThread
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|logRollerThread
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|leases
operator|=
operator|new
name|Leases
argument_list|(
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.hregionserver.lease.period"
argument_list|,
literal|3
operator|*
literal|60
operator|*
literal|1000
argument_list|)
argument_list|,
name|threadWakeFrequency
argument_list|)
expr_stmt|;
comment|// Server
name|this
operator|.
name|server
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|this
operator|.
name|stopRequested
operator|=
literal|true
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"HRegionServer started at: "
operator|+
name|address
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Stop all the HRegionServer threads and close everything down. All ongoing     * transactions will be aborted all threads will be shut down. This method    * will return immediately. The caller should call join to wait for all     * processing to cease.    */
specifier|public
name|void
name|stop
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|stopRequested
condition|)
block|{
name|stopRequested
operator|=
literal|true
expr_stmt|;
name|closeAllRegions
argument_list|()
expr_stmt|;
name|log
operator|.
name|close
argument_list|()
expr_stmt|;
name|fs
operator|.
name|close
argument_list|()
expr_stmt|;
name|server
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"stopping server at: "
operator|+
name|address
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Call join to wait for all the threads to finish */
specifier|public
name|void
name|join
parameter_list|()
block|{
try|try
block|{
name|this
operator|.
name|workerThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{     }
try|try
block|{
name|this
operator|.
name|logRollerThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{     }
try|try
block|{
name|this
operator|.
name|cacheFlusherThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{     }
name|this
operator|.
name|leases
operator|.
name|close
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|server
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{     }
name|LOG
operator|.
name|info
argument_list|(
literal|"server stopped at: "
operator|+
name|address
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * The HRegionServer sticks in this loop until close. It repeatedly checks in     * with the HMaster, sending heartbeats& reports, and receiving HRegion     * load/unload instructions.    */
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
operator|!
name|stopRequested
condition|)
block|{
name|HServerInfo
name|info
init|=
operator|new
name|HServerInfo
argument_list|(
name|address
argument_list|,
name|rand
operator|.
name|nextLong
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|lastMsg
init|=
literal|0
decl_stmt|;
name|long
name|waitTime
decl_stmt|;
comment|// Let the master know we're here
try|try
block|{
name|hbaseMaster
operator|.
name|regionServerStartup
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|waitTime
operator|=
name|msgInterval
operator|-
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|lastMsg
operator|)
expr_stmt|;
if|if
condition|(
name|waitTime
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|waitTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{           }
block|}
continue|continue;
block|}
comment|// Now ask the master what it wants us to do and tell it what we have done.
while|while
condition|(
operator|!
name|stopRequested
condition|)
block|{
if|if
condition|(
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|lastMsg
operator|)
operator|>=
name|msgInterval
condition|)
block|{
name|HMsg
name|outboundArray
index|[]
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|outboundMsgs
init|)
block|{
name|outboundArray
operator|=
name|outboundMsgs
operator|.
name|toArray
argument_list|(
operator|new
name|HMsg
index|[
name|outboundMsgs
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
name|outboundMsgs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|HMsg
name|msgs
index|[]
init|=
name|hbaseMaster
operator|.
name|regionServerReport
argument_list|(
name|info
argument_list|,
name|outboundArray
argument_list|)
decl_stmt|;
name|lastMsg
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
comment|// Queue up the HMaster's instruction stream for processing
synchronized|synchronized
init|(
name|toDo
init|)
block|{
name|boolean
name|restartOrStop
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|msgs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|msgs
index|[
name|i
index|]
operator|.
name|getMsg
argument_list|()
condition|)
block|{
case|case
name|HMsg
operator|.
name|MSG_CALL_SERVER_STARTUP
case|:
name|closeAllRegions
argument_list|()
expr_stmt|;
name|restartOrStop
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HMsg
operator|.
name|MSG_REGIONSERVER_ALREADY_RUNNING
case|:
name|stop
argument_list|()
expr_stmt|;
name|restartOrStop
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
name|toDo
operator|.
name|add
argument_list|(
name|msgs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|toDo
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|toDo
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|restartOrStop
condition|)
block|{
break|break;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
name|waitTime
operator|=
name|msgInterval
operator|-
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|lastMsg
operator|)
expr_stmt|;
if|if
condition|(
name|waitTime
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|waitTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{           }
block|}
block|}
block|}
block|}
comment|/** Add to the outbound message buffer */
specifier|private
name|void
name|reportOpen
parameter_list|(
name|HRegion
name|region
parameter_list|)
block|{
synchronized|synchronized
init|(
name|outboundMsgs
init|)
block|{
name|outboundMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|MSG_REPORT_OPEN
argument_list|,
name|region
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Add to the outbound message buffer */
specifier|private
name|void
name|reportClose
parameter_list|(
name|HRegion
name|region
parameter_list|)
block|{
synchronized|synchronized
init|(
name|outboundMsgs
init|)
block|{
name|outboundMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|MSG_REPORT_CLOSE
argument_list|,
name|region
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**     * Add to the outbound message buffer    *     * When a region splits, we need to tell the master that there are two new     * regions that need to be assigned.    *     * We do not need to inform the master about the old region, because we've    * updated the meta or root regions, and the master will pick that up on its    * next rescan of the root or meta tables.    */
specifier|private
name|void
name|reportSplit
parameter_list|(
name|HRegionInfo
name|newRegionA
parameter_list|,
name|HRegionInfo
name|newRegionB
parameter_list|)
block|{
synchronized|synchronized
init|(
name|outboundMsgs
init|)
block|{
name|outboundMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|MSG_NEW_REGION
argument_list|,
name|newRegionA
argument_list|)
argument_list|)
expr_stmt|;
name|outboundMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|MSG_NEW_REGION
argument_list|,
name|newRegionB
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//////////////////////////////////////////////////////////////////////////////
comment|// HMaster-given operations
comment|//////////////////////////////////////////////////////////////////////////////
specifier|private
name|Vector
argument_list|<
name|HMsg
argument_list|>
name|toDo
decl_stmt|;
specifier|private
name|Worker
name|worker
decl_stmt|;
specifier|private
name|Thread
name|workerThread
decl_stmt|;
specifier|private
class|class
name|Worker
implements|implements
name|Runnable
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
operator|!
name|stopRequested
condition|)
block|{
name|HMsg
name|msg
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|toDo
init|)
block|{
while|while
condition|(
name|toDo
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
try|try
block|{
name|toDo
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{             }
block|}
name|msg
operator|=
name|toDo
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
try|try
block|{
switch|switch
condition|(
name|msg
operator|.
name|getMsg
argument_list|()
condition|)
block|{
case|case
name|HMsg
operator|.
name|MSG_REGION_OPEN
case|:
comment|// Open a region
name|openRegion
argument_list|(
name|msg
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|HMsg
operator|.
name|MSG_REGION_CLOSE
case|:
comment|// Close a region
name|closeRegion
argument_list|(
name|msg
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|HMsg
operator|.
name|MSG_REGION_MERGE
case|:
comment|// Merge two regions
comment|//TODO ???
throw|throw
operator|new
name|IOException
argument_list|(
literal|"TODO: need to figure out merge"
argument_list|)
throw|;
comment|//break;
case|case
name|HMsg
operator|.
name|MSG_CALL_SERVER_STARTUP
case|:
comment|// Close regions, restart
name|closeAllRegions
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|HMsg
operator|.
name|MSG_REGIONSERVER_ALREADY_RUNNING
case|:
comment|// Go away
name|stop
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|HMsg
operator|.
name|MSG_REGION_CLOSE_WITHOUT_REPORT
case|:
comment|// Close a region, don't reply
name|closeRegion
argument_list|(
name|msg
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|HMsg
operator|.
name|MSG_REGION_CLOSE_AND_DELETE
case|:
name|closeAndDeleteRegion
argument_list|(
name|msg
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Impossible state during msg processing.  Instruction: "
operator|+
name|msg
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
name|void
name|openRegion
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|locker
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|region
init|=
operator|new
name|HRegion
argument_list|(
name|regionDir
argument_list|,
name|log
argument_list|,
name|fs
argument_list|,
name|conf
argument_list|,
name|regionInfo
argument_list|,
literal|null
argument_list|,
name|oldlogfile
argument_list|)
decl_stmt|;
name|regions
operator|.
name|put
argument_list|(
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|region
argument_list|)
expr_stmt|;
name|reportOpen
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|locker
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|closeRegion
parameter_list|(
name|HRegionInfo
name|info
parameter_list|,
name|boolean
name|reportWhenCompleted
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|locker
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|region
init|=
name|regions
operator|.
name|remove
argument_list|(
name|info
operator|.
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|!=
literal|null
condition|)
block|{
name|region
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|reportWhenCompleted
condition|)
block|{
name|reportClose
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|this
operator|.
name|locker
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|closeAndDeleteRegion
parameter_list|(
name|HRegionInfo
name|info
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|locker
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|region
init|=
name|regions
operator|.
name|remove
argument_list|(
name|info
operator|.
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|!=
literal|null
condition|)
block|{
name|region
operator|.
name|closeAndDelete
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|this
operator|.
name|locker
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Called either when the master tells us to restart or from stop() */
specifier|private
name|void
name|closeAllRegions
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|locker
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|Iterator
argument_list|<
name|HRegion
argument_list|>
name|it
init|=
name|regions
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|HRegion
name|region
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|region
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|regions
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|locker
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*****************************************************************************    * TODO - Figure out how the master is to determine when regions should be    *        merged. It once it makes this determination, it needs to ensure that    *        the regions to be merged are first being served by the same    *        HRegionServer and if not, move them so they are.    *            *        For now, we do not do merging. Splits are driven by the HRegionServer.    ****************************************************************************/
comment|/*   private void mergeRegions(Text regionNameA, Text regionNameB) throws IOException {     locking.obtainWriteLock();     try {       HRegion srcA = regions.remove(regionNameA);       HRegion srcB = regions.remove(regionNameB);       HRegion newRegion = HRegion.closeAndMerge(srcA, srcB);       regions.put(newRegion.getRegionName(), newRegion);        reportClose(srcA);       reportClose(srcB);       reportOpen(newRegion);            } finally {       locking.releaseWriteLock();     }   } */
comment|//////////////////////////////////////////////////////////////////////////////
comment|// HRegionInterface
comment|//////////////////////////////////////////////////////////////////////////////
comment|/** Obtain a table descriptor for the given region */
specifier|public
name|HRegionInfo
name|getRegionInfo
parameter_list|(
name|Text
name|regionName
parameter_list|)
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|region
operator|.
name|getRegionInfo
argument_list|()
return|;
block|}
comment|/** Get the indicated row/column */
specifier|public
name|BytesWritable
name|get
parameter_list|(
name|Text
name|regionName
parameter_list|,
name|Text
name|row
parameter_list|,
name|Text
name|column
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not serving region "
operator|+
name|regionName
argument_list|)
throw|;
block|}
name|byte
name|results
index|[]
init|=
name|region
operator|.
name|get
argument_list|(
name|row
argument_list|,
name|column
argument_list|)
decl_stmt|;
if|if
condition|(
name|results
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|BytesWritable
argument_list|(
name|results
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/** Get multiple versions of the indicated row/col */
specifier|public
name|BytesWritable
index|[]
name|get
parameter_list|(
name|Text
name|regionName
parameter_list|,
name|Text
name|row
parameter_list|,
name|Text
name|column
parameter_list|,
name|int
name|numVersions
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not serving region "
operator|+
name|regionName
argument_list|)
throw|;
block|}
name|byte
name|results
index|[]
index|[]
init|=
name|region
operator|.
name|get
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|numVersions
argument_list|)
decl_stmt|;
if|if
condition|(
name|results
operator|!=
literal|null
condition|)
block|{
name|BytesWritable
name|realResults
index|[]
init|=
operator|new
name|BytesWritable
index|[
name|results
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|realResults
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|results
index|[
name|i
index|]
operator|!=
literal|null
condition|)
block|{
name|realResults
index|[
name|i
index|]
operator|=
operator|new
name|BytesWritable
argument_list|(
name|results
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|realResults
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/** Get multiple timestamped versions of the indicated row/col */
specifier|public
name|BytesWritable
index|[]
name|get
parameter_list|(
name|Text
name|regionName
parameter_list|,
name|Text
name|row
parameter_list|,
name|Text
name|column
parameter_list|,
name|long
name|timestamp
parameter_list|,
name|int
name|numVersions
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not serving region "
operator|+
name|regionName
argument_list|)
throw|;
block|}
name|byte
name|results
index|[]
index|[]
init|=
name|region
operator|.
name|get
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|timestamp
argument_list|,
name|numVersions
argument_list|)
decl_stmt|;
if|if
condition|(
name|results
operator|!=
literal|null
condition|)
block|{
name|BytesWritable
name|realResults
index|[]
init|=
operator|new
name|BytesWritable
index|[
name|results
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|realResults
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|results
index|[
name|i
index|]
operator|!=
literal|null
condition|)
block|{
name|realResults
index|[
name|i
index|]
operator|=
operator|new
name|BytesWritable
argument_list|(
name|results
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|realResults
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/** Get all the columns (along with their names) for a given row. */
specifier|public
name|LabelledData
index|[]
name|getRow
parameter_list|(
name|Text
name|regionName
parameter_list|,
name|Text
name|row
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not serving region "
operator|+
name|regionName
argument_list|)
throw|;
block|}
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
name|map
init|=
name|region
operator|.
name|getFull
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|LabelledData
name|result
index|[]
init|=
operator|new
name|LabelledData
index|[
name|map
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|counter
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|Text
argument_list|>
name|it
init|=
name|map
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Text
name|colname
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|byte
name|val
index|[]
init|=
name|map
operator|.
name|get
argument_list|(
name|colname
argument_list|)
decl_stmt|;
name|result
index|[
name|counter
operator|++
index|]
operator|=
operator|new
name|LabelledData
argument_list|(
name|colname
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Start an update to the HBase.  This also creates a lease associated with    * the caller.    */
specifier|private
class|class
name|RegionListener
extends|extends
name|LeaseListener
block|{
specifier|private
name|HRegion
name|localRegion
decl_stmt|;
specifier|private
name|long
name|localLockId
decl_stmt|;
specifier|public
name|RegionListener
parameter_list|(
name|HRegion
name|region
parameter_list|,
name|long
name|lockId
parameter_list|)
block|{
name|this
operator|.
name|localRegion
operator|=
name|region
expr_stmt|;
name|this
operator|.
name|localLockId
operator|=
name|lockId
expr_stmt|;
block|}
specifier|public
name|void
name|leaseExpired
parameter_list|()
block|{
try|try
block|{
name|localRegion
operator|.
name|abort
argument_list|(
name|localLockId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|iex
parameter_list|)
block|{
name|iex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|long
name|startUpdate
parameter_list|(
name|Text
name|regionName
parameter_list|,
name|long
name|clientid
parameter_list|,
name|Text
name|row
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not serving region "
operator|+
name|regionName
argument_list|)
throw|;
block|}
name|long
name|lockid
init|=
name|region
operator|.
name|startUpdate
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|leases
operator|.
name|createLease
argument_list|(
operator|new
name|Text
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|clientid
argument_list|)
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|lockid
argument_list|)
argument_list|)
argument_list|,
operator|new
name|RegionListener
argument_list|(
name|region
argument_list|,
name|lockid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|lockid
return|;
block|}
comment|/** Add something to the HBase. */
specifier|public
name|void
name|put
parameter_list|(
name|Text
name|regionName
parameter_list|,
name|long
name|clientid
parameter_list|,
name|long
name|lockid
parameter_list|,
name|Text
name|column
parameter_list|,
name|BytesWritable
name|val
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not serving region "
operator|+
name|regionName
argument_list|)
throw|;
block|}
name|leases
operator|.
name|renewLease
argument_list|(
operator|new
name|Text
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|clientid
argument_list|)
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|lockid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|region
operator|.
name|put
argument_list|(
name|lockid
argument_list|,
name|column
argument_list|,
name|val
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Remove a cell from the HBase. */
specifier|public
name|void
name|delete
parameter_list|(
name|Text
name|regionName
parameter_list|,
name|long
name|clientid
parameter_list|,
name|long
name|lockid
parameter_list|,
name|Text
name|column
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not serving region "
operator|+
name|regionName
argument_list|)
throw|;
block|}
name|leases
operator|.
name|renewLease
argument_list|(
operator|new
name|Text
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|clientid
argument_list|)
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|lockid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|region
operator|.
name|delete
argument_list|(
name|lockid
argument_list|,
name|column
argument_list|)
expr_stmt|;
block|}
comment|/** Abandon the transaction */
specifier|public
name|void
name|abort
parameter_list|(
name|Text
name|regionName
parameter_list|,
name|long
name|clientid
parameter_list|,
name|long
name|lockid
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not serving region "
operator|+
name|regionName
argument_list|)
throw|;
block|}
name|leases
operator|.
name|cancelLease
argument_list|(
operator|new
name|Text
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|clientid
argument_list|)
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|lockid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|region
operator|.
name|abort
argument_list|(
name|lockid
argument_list|)
expr_stmt|;
block|}
comment|/** Confirm the transaction */
specifier|public
name|void
name|commit
parameter_list|(
name|Text
name|regionName
parameter_list|,
name|long
name|clientid
parameter_list|,
name|long
name|lockid
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not serving region "
operator|+
name|regionName
argument_list|)
throw|;
block|}
name|leases
operator|.
name|cancelLease
argument_list|(
operator|new
name|Text
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|clientid
argument_list|)
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|lockid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|region
operator|.
name|commit
argument_list|(
name|lockid
argument_list|)
expr_stmt|;
block|}
comment|/** Don't let the client's lease expire just yet...  */
specifier|public
name|void
name|renewLease
parameter_list|(
name|long
name|lockid
parameter_list|,
name|long
name|clientid
parameter_list|)
throws|throws
name|IOException
block|{
name|leases
operator|.
name|renewLease
argument_list|(
operator|new
name|Text
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|clientid
argument_list|)
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|lockid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Private utility method for safely obtaining an HRegion handle. */
specifier|private
name|HRegion
name|getRegion
parameter_list|(
name|Text
name|regionName
parameter_list|)
block|{
name|this
operator|.
name|locker
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|regions
operator|.
name|get
argument_list|(
name|regionName
argument_list|)
return|;
block|}
finally|finally
block|{
name|this
operator|.
name|locker
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|//////////////////////////////////////////////////////////////////////////////
comment|// remote scanner interface
comment|//////////////////////////////////////////////////////////////////////////////
specifier|private
name|Map
argument_list|<
name|Text
argument_list|,
name|HScannerInterface
argument_list|>
name|scanners
decl_stmt|;
specifier|private
class|class
name|ScannerListener
extends|extends
name|LeaseListener
block|{
specifier|private
name|Text
name|scannerName
decl_stmt|;
specifier|public
name|ScannerListener
parameter_list|(
name|Text
name|scannerName
parameter_list|)
block|{
name|this
operator|.
name|scannerName
operator|=
name|scannerName
expr_stmt|;
block|}
specifier|public
name|void
name|leaseExpired
parameter_list|()
block|{
name|HScannerInterface
name|s
init|=
name|scanners
operator|.
name|remove
argument_list|(
name|scannerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|s
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/** Start a scanner for a given HRegion. */
specifier|public
name|long
name|openScanner
parameter_list|(
name|Text
name|regionName
parameter_list|,
name|Text
index|[]
name|cols
parameter_list|,
name|Text
name|firstRow
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegion
name|r
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not serving region "
operator|+
name|regionName
argument_list|)
throw|;
block|}
name|long
name|scannerId
init|=
operator|-
literal|1L
decl_stmt|;
try|try
block|{
name|HScannerInterface
name|s
init|=
name|r
operator|.
name|getScanner
argument_list|(
name|cols
argument_list|,
name|firstRow
argument_list|)
decl_stmt|;
name|scannerId
operator|=
name|rand
operator|.
name|nextLong
argument_list|()
expr_stmt|;
name|Text
name|scannerName
init|=
operator|new
name|Text
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|scannerId
argument_list|)
argument_list|)
decl_stmt|;
name|scanners
operator|.
name|put
argument_list|(
name|scannerName
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|leases
operator|.
name|createLease
argument_list|(
name|scannerName
argument_list|,
name|scannerName
argument_list|,
operator|new
name|ScannerListener
argument_list|(
name|scannerName
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
return|return
name|scannerId
return|;
block|}
specifier|public
name|LabelledData
index|[]
name|next
parameter_list|(
name|long
name|scannerId
parameter_list|,
name|HStoreKey
name|key
parameter_list|)
throws|throws
name|IOException
block|{
name|Text
name|scannerName
init|=
operator|new
name|Text
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|scannerId
argument_list|)
argument_list|)
decl_stmt|;
name|HScannerInterface
name|s
init|=
name|scanners
operator|.
name|get
argument_list|(
name|scannerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"unknown scanner"
argument_list|)
throw|;
block|}
name|leases
operator|.
name|renewLease
argument_list|(
name|scannerName
argument_list|,
name|scannerName
argument_list|)
expr_stmt|;
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
name|results
init|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|LabelledData
argument_list|>
name|values
init|=
operator|new
name|ArrayList
argument_list|<
name|LabelledData
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|next
argument_list|(
name|key
argument_list|,
name|results
argument_list|)
condition|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|it
init|=
name|results
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
name|e
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|values
operator|.
name|add
argument_list|(
operator|new
name|LabelledData
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|values
operator|.
name|toArray
argument_list|(
operator|new
name|LabelledData
index|[
name|values
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
specifier|public
name|void
name|close
parameter_list|(
name|long
name|scannerId
parameter_list|)
throws|throws
name|IOException
block|{
name|Text
name|scannerName
init|=
operator|new
name|Text
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|scannerId
argument_list|)
argument_list|)
decl_stmt|;
name|HScannerInterface
name|s
init|=
name|scanners
operator|.
name|remove
argument_list|(
name|scannerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"unknown scanner"
argument_list|)
throw|;
block|}
try|try
block|{
name|s
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
name|leases
operator|.
name|cancelLease
argument_list|(
name|scannerName
argument_list|,
name|scannerName
argument_list|)
expr_stmt|;
block|}
comment|//////////////////////////////////////////////////////////////////////////////
comment|// Main program
comment|//////////////////////////////////////////////////////////////////////////////
specifier|private
specifier|static
name|void
name|printUsage
parameter_list|()
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Usage: java "
operator|+
literal|"org.apache.hbase.HRegionServer [--bind=hostname:port]"
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
operator|new
name|HBaseConfiguration
argument_list|()
decl_stmt|;
comment|// Process command-line args. TODO: Better cmd-line processing
comment|// (but hopefully something not as painful as cli options).
for|for
control|(
name|String
name|cmd
range|:
name|args
control|)
block|{
if|if
condition|(
name|cmd
operator|.
name|equals
argument_list|(
literal|"-h"
argument_list|)
operator|||
name|cmd
operator|.
name|startsWith
argument_list|(
literal|"--h"
argument_list|)
condition|)
block|{
name|printUsage
argument_list|()
expr_stmt|;
return|return;
block|}
specifier|final
name|String
name|addressArgKey
init|=
literal|"--bind="
decl_stmt|;
if|if
condition|(
name|cmd
operator|.
name|startsWith
argument_list|(
name|addressArgKey
argument_list|)
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|REGIONSERVER_ADDRESS
argument_list|,
name|cmd
operator|.
name|substring
argument_list|(
name|addressArgKey
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|new
name|HRegionServer
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

