begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2007 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|MapWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RPC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|DNS
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|RowFilterInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|BatchUpdate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|BatchOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|ImmutableBytesWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Writables
import|;
end_import

begin_comment
comment|/**  * HRegionServer makes a set of HRegions available to clients.  It checks in with  * the HMaster. There are many HRegionServers in a single HBase deployment.  */
end_comment

begin_class
specifier|public
class|class
name|HRegionServer
implements|implements
name|HConstants
implements|,
name|HRegionInterface
implements|,
name|Runnable
block|{
comment|/** {@inheritDoc} */
specifier|public
name|long
name|getProtocolVersion
parameter_list|(
specifier|final
name|String
name|protocol
parameter_list|,
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|final
name|long
name|clientVersion
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|HRegionInterface
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|HRegionInterface
operator|.
name|versionID
return|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown protocol to name node: "
operator|+
name|protocol
argument_list|)
throw|;
block|}
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HRegionServer
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Set when a report to the master comes back with a message asking us to
comment|// shutdown.  Also set by call to stop when debugging or running unit tests
comment|// of HRegionServer in isolation.
specifier|protected
specifier|volatile
name|boolean
name|stopRequested
decl_stmt|;
comment|// Go down hard.  Used if file system becomes unavailable and also in
comment|// debugging and unit tests.
specifier|protected
specifier|volatile
name|boolean
name|abortRequested
decl_stmt|;
comment|// If false, the file system has become unavailable
specifier|protected
specifier|volatile
name|boolean
name|fsOk
decl_stmt|;
specifier|final
name|Path
name|rootDir
decl_stmt|;
specifier|protected
specifier|final
name|HServerInfo
name|serverInfo
decl_stmt|;
specifier|protected
specifier|final
name|Configuration
name|conf
decl_stmt|;
specifier|private
specifier|final
name|Random
name|rand
decl_stmt|;
comment|// region name -> HRegion
specifier|protected
specifier|final
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|HRegion
argument_list|>
name|onlineRegions
decl_stmt|;
specifier|protected
specifier|final
name|Map
argument_list|<
name|Text
argument_list|,
name|HRegion
argument_list|>
name|retiringRegions
init|=
operator|new
name|HashMap
argument_list|<
name|Text
argument_list|,
name|HRegion
argument_list|>
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|ReentrantReadWriteLock
name|lock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Vector
argument_list|<
name|HMsg
argument_list|>
name|outboundMsgs
decl_stmt|;
name|int
name|numRetries
decl_stmt|;
specifier|protected
specifier|final
name|long
name|threadWakeFrequency
decl_stmt|;
specifier|private
specifier|final
name|long
name|msgInterval
decl_stmt|;
comment|// Check to see if regions should be split
specifier|protected
specifier|final
name|long
name|splitOrCompactCheckFrequency
decl_stmt|;
specifier|private
specifier|final
name|SplitOrCompactChecker
name|splitOrCompactChecker
decl_stmt|;
specifier|private
specifier|final
name|Thread
name|splitOrCompactCheckerThread
decl_stmt|;
specifier|protected
specifier|final
name|Integer
name|splitOrCompactLock
init|=
operator|new
name|Integer
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/** Runs periodically to determine if regions need to be compacted or split */
class|class
name|SplitOrCompactChecker
implements|implements
name|Runnable
implements|,
name|RegionUnavailableListener
block|{
specifier|private
name|HTable
name|root
init|=
literal|null
decl_stmt|;
specifier|private
name|HTable
name|meta
init|=
literal|null
decl_stmt|;
comment|/**      * {@inheritDoc}      */
specifier|public
name|void
name|closing
parameter_list|(
specifier|final
name|Text
name|regionName
parameter_list|)
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Remove region from regions Map and add it to the Map of retiring
comment|// regions.
name|retiringRegions
operator|.
name|put
argument_list|(
name|regionName
argument_list|,
name|onlineRegions
operator|.
name|remove
argument_list|(
name|regionName
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|regionName
operator|.
name|toString
argument_list|()
operator|+
literal|" closing ("
operator|+
literal|"Adding to retiringRegions)"
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * {@inheritDoc}      */
specifier|public
name|void
name|closed
parameter_list|(
specifier|final
name|Text
name|regionName
parameter_list|)
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|retiringRegions
operator|.
name|remove
argument_list|(
name|regionName
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|regionName
operator|.
name|toString
argument_list|()
operator|+
literal|" closed"
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * {@inheritDoc}      */
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
operator|!
name|stopRequested
condition|)
block|{
name|long
name|startTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|splitOrCompactLock
init|)
block|{
comment|// Don't interrupt us while we're working
comment|// Grab a list of regions to check
name|ArrayList
argument_list|<
name|HRegion
argument_list|>
name|regionsToCheck
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegion
argument_list|>
argument_list|()
decl_stmt|;
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|regionsToCheck
operator|.
name|addAll
argument_list|(
name|onlineRegions
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|HRegion
name|cur
range|:
name|regionsToCheck
control|)
block|{
if|if
condition|(
name|cur
operator|.
name|isClosed
argument_list|()
condition|)
block|{
comment|// Skip if closed
continue|continue;
block|}
try|try
block|{
if|if
condition|(
name|cur
operator|.
name|needsCompaction
argument_list|()
condition|)
block|{
name|cur
operator|.
name|compactStores
argument_list|()
expr_stmt|;
block|}
comment|// After compaction, it probably needs splitting.  May also need
comment|// splitting just because one of the memcache flushes was big.
name|Text
name|midKey
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
if|if
condition|(
name|cur
operator|.
name|needsSplit
argument_list|(
name|midKey
argument_list|)
condition|)
block|{
name|split
argument_list|(
name|cur
argument_list|,
name|midKey
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|//TODO: What happens if this fails? Are we toast?
name|LOG
operator|.
name|error
argument_list|(
literal|"Split or compaction failed"
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkFileSystem
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|stopRequested
condition|)
block|{
continue|continue;
block|}
comment|// Sleep
name|long
name|waitTime
init|=
name|splitOrCompactCheckFrequency
operator|-
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
operator|)
decl_stmt|;
if|if
condition|(
name|waitTime
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|waitTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{
comment|// continue
block|}
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"splitOrCompactChecker exiting"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|split
parameter_list|(
specifier|final
name|HRegion
name|region
parameter_list|,
specifier|final
name|Text
name|midKey
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|HRegionInfo
name|oldRegionInfo
init|=
name|region
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
specifier|final
name|HRegion
index|[]
name|newRegions
init|=
name|region
operator|.
name|closeAndSplit
argument_list|(
name|midKey
argument_list|,
name|this
argument_list|)
decl_stmt|;
comment|// When a region is split, the META table needs to updated if we're
comment|// splitting a 'normal' region, and the ROOT table needs to be
comment|// updated if we are splitting a META region.
name|HTable
name|t
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|tableDesc
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|META_TABLE_NAME
argument_list|)
condition|)
block|{
comment|// We need to update the root region
if|if
condition|(
name|root
operator|==
literal|null
condition|)
block|{
name|root
operator|=
operator|new
name|HTable
argument_list|(
name|conf
argument_list|,
name|ROOT_TABLE_NAME
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|root
expr_stmt|;
block|}
else|else
block|{
comment|// For normal regions we need to update the meta region
if|if
condition|(
name|meta
operator|==
literal|null
condition|)
block|{
name|meta
operator|=
operator|new
name|HTable
argument_list|(
name|conf
argument_list|,
name|META_TABLE_NAME
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|meta
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Updating "
operator|+
name|t
operator|.
name|getTableName
argument_list|()
operator|+
literal|" with region split info"
argument_list|)
expr_stmt|;
comment|// Remove old region from META
comment|// NOTE: there is no need for retry logic here. HTable does it for us.
name|long
name|lockid
init|=
name|t
operator|.
name|startUpdate
argument_list|(
name|oldRegionInfo
operator|.
name|getRegionName
argument_list|()
argument_list|)
decl_stmt|;
name|oldRegionInfo
operator|.
name|offLine
operator|=
literal|true
expr_stmt|;
name|oldRegionInfo
operator|.
name|split
operator|=
literal|true
expr_stmt|;
name|t
operator|.
name|put
argument_list|(
name|lockid
argument_list|,
name|COL_REGIONINFO
argument_list|,
name|Writables
operator|.
name|getBytes
argument_list|(
name|oldRegionInfo
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|.
name|put
argument_list|(
name|lockid
argument_list|,
name|COL_SPLITA
argument_list|,
name|Writables
operator|.
name|getBytes
argument_list|(
name|newRegions
index|[
literal|0
index|]
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|.
name|put
argument_list|(
name|lockid
argument_list|,
name|COL_SPLITB
argument_list|,
name|Writables
operator|.
name|getBytes
argument_list|(
name|newRegions
index|[
literal|1
index|]
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|.
name|commit
argument_list|(
name|lockid
argument_list|)
expr_stmt|;
comment|// Add new regions to META
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newRegions
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|lockid
operator|=
name|t
operator|.
name|startUpdate
argument_list|(
name|newRegions
index|[
name|i
index|]
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|.
name|put
argument_list|(
name|lockid
argument_list|,
name|COL_REGIONINFO
argument_list|,
name|Writables
operator|.
name|getBytes
argument_list|(
name|newRegions
index|[
name|i
index|]
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|.
name|commit
argument_list|(
name|lockid
argument_list|)
expr_stmt|;
block|}
comment|// Now tell the master about the new regions
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reporting region split to master"
argument_list|)
expr_stmt|;
block|}
name|reportSplit
argument_list|(
name|oldRegionInfo
argument_list|,
name|newRegions
index|[
literal|0
index|]
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|newRegions
index|[
literal|1
index|]
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"region split, META update, and report to master all"
operator|+
literal|" successful. Old region="
operator|+
name|oldRegionInfo
operator|.
name|getRegionName
argument_list|()
operator|+
literal|", new regions: "
operator|+
name|newRegions
index|[
literal|0
index|]
operator|.
name|getRegionName
argument_list|()
operator|+
literal|", "
operator|+
name|newRegions
index|[
literal|1
index|]
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Do not serve the new regions. Let the Master assign them.
block|}
block|}
comment|// Cache flushing
specifier|private
specifier|final
name|Flusher
name|cacheFlusher
decl_stmt|;
specifier|private
specifier|final
name|Thread
name|cacheFlusherThread
decl_stmt|;
specifier|protected
specifier|final
name|Integer
name|cacheFlusherLock
init|=
operator|new
name|Integer
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/* Runs periodically to flush memcache.    */
class|class
name|Flusher
implements|implements
name|Runnable
block|{
comment|/**      * {@inheritDoc}      */
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
operator|!
name|stopRequested
condition|)
block|{
name|long
name|startTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|cacheFlusherLock
init|)
block|{
comment|// Grab a list of items to flush
name|ArrayList
argument_list|<
name|HRegion
argument_list|>
name|toFlush
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegion
argument_list|>
argument_list|()
decl_stmt|;
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|toFlush
operator|.
name|addAll
argument_list|(
name|onlineRegions
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// Flush them, if necessary
for|for
control|(
name|HRegion
name|cur
range|:
name|toFlush
control|)
block|{
if|if
condition|(
name|cur
operator|.
name|isClosed
argument_list|()
condition|)
block|{
comment|// Skip if closed
continue|continue;
block|}
try|try
block|{
name|cur
operator|.
name|optionallyFlush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|iex
parameter_list|)
block|{
if|if
condition|(
name|iex
operator|instanceof
name|RemoteException
condition|)
block|{
try|try
block|{
name|iex
operator|=
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
operator|(
name|RemoteException
operator|)
name|iex
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
name|iex
operator|=
name|x
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Cache flush failed"
argument_list|,
name|iex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkFileSystem
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
block|}
block|}
comment|// Sleep
name|long
name|waitTime
init|=
name|stopRequested
condition|?
literal|0
else|:
name|threadWakeFrequency
operator|-
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
operator|)
decl_stmt|;
if|if
condition|(
name|waitTime
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|waitTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{
comment|// continue
block|}
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"cacheFlusher exiting"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// File paths
name|FileSystem
name|fs
decl_stmt|;
comment|// Logging
specifier|protected
specifier|final
name|HLog
name|log
decl_stmt|;
specifier|private
specifier|final
name|LogRoller
name|logRoller
decl_stmt|;
specifier|private
specifier|final
name|Thread
name|logRollerThread
decl_stmt|;
specifier|protected
specifier|final
name|Integer
name|logRollerLock
init|=
operator|new
name|Integer
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/** Runs periodically to determine if the log should be rolled */
class|class
name|LogRoller
implements|implements
name|Runnable
block|{
specifier|private
name|int
name|maxLogEntries
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.maxlogentries"
argument_list|,
literal|30
operator|*
literal|1000
argument_list|)
decl_stmt|;
comment|/**      * {@inheritDoc}      */
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
operator|!
name|stopRequested
condition|)
block|{
synchronized|synchronized
init|(
name|logRollerLock
init|)
block|{
comment|// If the number of log entries is high enough, roll the log.  This
comment|// is a very fast operation, but should not be done too frequently.
name|int
name|nEntries
init|=
name|log
operator|.
name|getNumEntries
argument_list|()
decl_stmt|;
if|if
condition|(
name|nEntries
operator|>
name|this
operator|.
name|maxLogEntries
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Rolling hlog. Number of entries: "
operator|+
name|nEntries
argument_list|)
expr_stmt|;
name|log
operator|.
name|rollWriter
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|iex
parameter_list|)
block|{
if|if
condition|(
name|iex
operator|instanceof
name|RemoteException
condition|)
block|{
try|try
block|{
name|iex
operator|=
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
operator|(
name|RemoteException
operator|)
name|iex
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
name|iex
operator|=
name|x
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Log rolling failed"
argument_list|,
name|iex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkFileSystem
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|stopRequested
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|threadWakeFrequency
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{
comment|// continue
block|}
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"logRoller exiting"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Remote HMaster
specifier|private
name|HMasterRegionInterface
name|hbaseMaster
decl_stmt|;
comment|// Server
specifier|private
name|Server
name|server
decl_stmt|;
comment|// Leases
specifier|private
name|Leases
name|leases
decl_stmt|;
comment|// Request counter
specifier|private
name|AtomicInteger
name|requestCount
decl_stmt|;
comment|/**    * Starts a HRegionServer at the default location    * @param conf    * @throws IOException    */
specifier|public
name|HRegionServer
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|HBASE_DIR
argument_list|,
name|DEFAULT_HBASE_DIR
argument_list|)
argument_list|)
argument_list|,
operator|new
name|HServerAddress
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|REGIONSERVER_ADDRESS
argument_list|,
name|DEFAULT_REGIONSERVER_ADDRESS
argument_list|)
argument_list|)
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Starts a HRegionServer at the specified location    * @param rootDir    * @param address    * @param conf    * @throws IOException    */
specifier|public
name|HRegionServer
parameter_list|(
name|Path
name|rootDir
parameter_list|,
name|HServerAddress
name|address
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Basic setup
name|this
operator|.
name|stopRequested
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|abortRequested
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|fsOk
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|rootDir
operator|=
name|rootDir
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|rand
operator|=
operator|new
name|Random
argument_list|()
expr_stmt|;
name|this
operator|.
name|onlineRegions
operator|=
name|Collections
operator|.
name|synchronizedSortedMap
argument_list|(
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|HRegion
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|outboundMsgs
operator|=
operator|new
name|Vector
argument_list|<
name|HMsg
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|requestCount
operator|=
operator|new
name|AtomicInteger
argument_list|()
expr_stmt|;
comment|// Config'ed params
name|this
operator|.
name|numRetries
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.client.retries.number"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|this
operator|.
name|threadWakeFrequency
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|THREAD_WAKE_FREQUENCY
argument_list|,
literal|10
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|this
operator|.
name|msgInterval
operator|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.regionserver.msginterval"
argument_list|,
literal|3
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|this
operator|.
name|splitOrCompactCheckFrequency
operator|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.regionserver.thread.splitcompactcheckfrequency"
argument_list|,
literal|30
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|// Cache flushing
name|this
operator|.
name|cacheFlusher
operator|=
operator|new
name|Flusher
argument_list|()
expr_stmt|;
name|this
operator|.
name|cacheFlusherThread
operator|=
operator|new
name|Thread
argument_list|(
name|cacheFlusher
argument_list|)
expr_stmt|;
comment|// Check regions to see if they need to be split
name|this
operator|.
name|splitOrCompactChecker
operator|=
operator|new
name|SplitOrCompactChecker
argument_list|()
expr_stmt|;
name|this
operator|.
name|splitOrCompactCheckerThread
operator|=
operator|new
name|Thread
argument_list|(
name|splitOrCompactChecker
argument_list|)
expr_stmt|;
comment|// Process requests from Master
name|this
operator|.
name|toDo
operator|=
operator|new
name|LinkedBlockingQueue
argument_list|<
name|ToDoEntry
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|worker
operator|=
operator|new
name|Worker
argument_list|()
expr_stmt|;
name|this
operator|.
name|workerThread
operator|=
operator|new
name|Thread
argument_list|(
name|worker
argument_list|)
expr_stmt|;
try|try
block|{
comment|// Server to handle client requests
name|this
operator|.
name|server
operator|=
name|RPC
operator|.
name|getServer
argument_list|(
name|this
argument_list|,
name|address
operator|.
name|getBindAddress
argument_list|()
argument_list|,
name|address
operator|.
name|getPort
argument_list|()
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.handler.count"
argument_list|,
literal|10
argument_list|)
argument_list|,
literal|false
argument_list|,
name|conf
argument_list|)
expr_stmt|;
comment|// Use interface to get the 'real' IP for this host.
comment|// 'serverInfo' is sent to master.  Should have the real IP of this host
comment|// rather than 'localhost' or 0.0.0.0 or 127.0.0.1 in it.
name|String
name|realIP
init|=
name|DNS
operator|.
name|getDefaultIP
argument_list|(
name|conf
operator|.
name|get
argument_list|(
literal|"dfs.datanode.dns.interface"
argument_list|,
literal|"default"
argument_list|)
argument_list|)
decl_stmt|;
name|this
operator|.
name|serverInfo
operator|=
operator|new
name|HServerInfo
argument_list|(
operator|new
name|HServerAddress
argument_list|(
operator|new
name|InetSocketAddress
argument_list|(
name|realIP
argument_list|,
name|server
operator|.
name|getListenerAddress
argument_list|()
operator|.
name|getPort
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|this
operator|.
name|rand
operator|.
name|nextLong
argument_list|()
argument_list|)
expr_stmt|;
name|Path
name|logdir
init|=
operator|new
name|Path
argument_list|(
name|rootDir
argument_list|,
literal|"log"
operator|+
literal|"_"
operator|+
name|realIP
operator|+
literal|"_"
operator|+
name|this
operator|.
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|getPort
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Log dir "
operator|+
name|logdir
argument_list|)
expr_stmt|;
block|}
comment|// Logging
name|this
operator|.
name|fs
operator|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|logdir
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RegionServerRunningException
argument_list|(
literal|"region server already "
operator|+
literal|"running at "
operator|+
name|this
operator|.
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|" because logdir "
operator|+
name|logdir
operator|.
name|toString
argument_list|()
operator|+
literal|" exists"
argument_list|)
throw|;
block|}
name|this
operator|.
name|log
operator|=
operator|new
name|HLog
argument_list|(
name|fs
argument_list|,
name|logdir
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|logRoller
operator|=
operator|new
name|LogRoller
argument_list|()
expr_stmt|;
name|this
operator|.
name|logRollerThread
operator|=
operator|new
name|Thread
argument_list|(
name|logRoller
argument_list|)
expr_stmt|;
comment|// Remote HMaster
name|this
operator|.
name|hbaseMaster
operator|=
operator|(
name|HMasterRegionInterface
operator|)
name|RPC
operator|.
name|waitForProxy
argument_list|(
name|HMasterRegionInterface
operator|.
name|class
argument_list|,
name|HMasterRegionInterface
operator|.
name|versionID
argument_list|,
operator|new
name|HServerAddress
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|MASTER_ADDRESS
argument_list|)
argument_list|)
operator|.
name|getInetSocketAddress
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|this
operator|.
name|stopRequested
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|RemoteException
condition|)
block|{
name|e
operator|=
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
operator|(
name|RemoteException
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
comment|/** @return the HLog */
name|HLog
name|getLog
parameter_list|()
block|{
return|return
name|log
return|;
block|}
comment|/**    * Sets a flag that will cause all the HRegionServer threads to shut down    * in an orderly fashion.    *<p>FOR DEBUGGING ONLY    */
specifier|synchronized
name|void
name|stop
parameter_list|()
block|{
name|stopRequested
operator|=
literal|true
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
comment|// Wakes run() if it is sleeping
block|}
comment|/**    * Cause the server to exit without closing the regions it is serving, the    * log it is using and without notifying the master.    *<p>FOR DEBUGGING ONLY    */
specifier|synchronized
name|void
name|abort
parameter_list|()
block|{
name|abortRequested
operator|=
literal|true
expr_stmt|;
name|stop
argument_list|()
expr_stmt|;
block|}
comment|/**     * Wait on all threads to finish.    * Presumption is that all closes and stops have already been called.    */
name|void
name|join
parameter_list|()
block|{
try|try
block|{
name|this
operator|.
name|workerThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{
comment|// continue
block|}
try|try
block|{
name|this
operator|.
name|logRollerThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{
comment|// continue
block|}
try|try
block|{
name|this
operator|.
name|cacheFlusherThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{
comment|// continue
block|}
try|try
block|{
name|this
operator|.
name|splitOrCompactCheckerThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{
comment|// continue
block|}
try|try
block|{
name|this
operator|.
name|server
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{
comment|// continue
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"HRegionServer stopped at: "
operator|+
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * The HRegionServer sticks in this loop until closed. It repeatedly checks    * in with the HMaster, sending heartbeats& reports, and receiving HRegion     * load/unload instructions.    */
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// Threads
name|String
name|threadName
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|workerThread
operator|.
name|setName
argument_list|(
name|threadName
operator|+
literal|".worker"
argument_list|)
expr_stmt|;
name|workerThread
operator|.
name|start
argument_list|()
expr_stmt|;
name|cacheFlusherThread
operator|.
name|setName
argument_list|(
name|threadName
operator|+
literal|".cacheFlusher"
argument_list|)
expr_stmt|;
name|cacheFlusherThread
operator|.
name|start
argument_list|()
expr_stmt|;
name|splitOrCompactCheckerThread
operator|.
name|setName
argument_list|(
name|threadName
operator|+
literal|".splitOrCompactChecker"
argument_list|)
expr_stmt|;
name|splitOrCompactCheckerThread
operator|.
name|start
argument_list|()
expr_stmt|;
name|logRollerThread
operator|.
name|setName
argument_list|(
name|threadName
operator|+
literal|".logRoller"
argument_list|)
expr_stmt|;
name|logRollerThread
operator|.
name|start
argument_list|()
expr_stmt|;
name|leases
operator|=
operator|new
name|Leases
argument_list|(
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.regionserver.lease.period"
argument_list|,
literal|3
operator|*
literal|60
operator|*
literal|1000
argument_list|)
argument_list|,
name|threadWakeFrequency
argument_list|)
expr_stmt|;
name|leases
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Server
name|boolean
name|masterRequestedStop
init|=
literal|false
decl_stmt|;
try|try
block|{
name|this
operator|.
name|server
operator|.
name|start
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"HRegionServer started at: "
operator|+
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|stopRequested
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|RemoteException
condition|)
block|{
try|try
block|{
name|e
operator|=
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
operator|(
name|RemoteException
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|e
operator|=
name|ex
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|""
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|stopRequested
condition|)
block|{
name|long
name|lastMsg
init|=
literal|0
decl_stmt|;
name|long
name|waitTime
decl_stmt|;
comment|// Let the master know we're here
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Telling master we are up"
argument_list|)
expr_stmt|;
block|}
name|requestCount
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|serverInfo
operator|.
name|setLoad
argument_list|(
operator|new
name|HServerLoad
argument_list|(
literal|0
argument_list|,
name|onlineRegions
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|hbaseMaster
operator|.
name|regionServerStartup
argument_list|(
name|serverInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Done telling master we are up"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|waitTime
operator|=
name|stopRequested
condition|?
literal|0
else|:
name|msgInterval
operator|-
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|lastMsg
operator|)
expr_stmt|;
if|if
condition|(
name|waitTime
operator|>
literal|0
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
try|try
block|{
name|wait
argument_list|(
name|waitTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e1
parameter_list|)
block|{
comment|// Go back up to the while test if stop has been requested.
block|}
block|}
block|}
continue|continue;
block|}
comment|// Now ask master what it wants us to do and tell it what we have done.
while|while
condition|(
operator|!
name|stopRequested
condition|)
block|{
if|if
condition|(
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|lastMsg
operator|)
operator|>=
name|msgInterval
condition|)
block|{
name|HMsg
name|outboundArray
index|[]
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|outboundMsgs
init|)
block|{
name|outboundArray
operator|=
name|outboundMsgs
operator|.
name|toArray
argument_list|(
operator|new
name|HMsg
index|[
name|outboundMsgs
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
name|outboundMsgs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|serverInfo
operator|.
name|setLoad
argument_list|(
operator|new
name|HServerLoad
argument_list|(
name|requestCount
operator|.
name|get
argument_list|()
argument_list|,
name|onlineRegions
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|requestCount
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|HMsg
name|msgs
index|[]
init|=
name|hbaseMaster
operator|.
name|regionServerReport
argument_list|(
name|serverInfo
argument_list|,
name|outboundArray
argument_list|)
decl_stmt|;
name|lastMsg
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
comment|// Queue up the HMaster's instruction stream for processing
name|boolean
name|restart
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|msgs
operator|.
name|length
operator|&&
operator|!
name|stopRequested
operator|&&
operator|!
name|restart
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|msgs
index|[
name|i
index|]
operator|.
name|getMsg
argument_list|()
condition|)
block|{
case|case
name|HMsg
operator|.
name|MSG_CALL_SERVER_STARTUP
case|:
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Got call server startup message"
argument_list|)
expr_stmt|;
block|}
name|closeAllRegions
argument_list|()
expr_stmt|;
name|restart
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HMsg
operator|.
name|MSG_REGIONSERVER_STOP
case|:
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Got regionserver stop message"
argument_list|)
expr_stmt|;
block|}
name|masterRequestedStop
operator|=
literal|true
expr_stmt|;
name|stopRequested
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
try|try
block|{
name|toDo
operator|.
name|put
argument_list|(
operator|new
name|ToDoEntry
argument_list|(
name|msgs
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Putting into msgQueue was interrupted."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
name|restart
operator|||
name|stopRequested
condition|)
block|{
name|toDo
operator|.
name|clear
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|RemoteException
condition|)
block|{
try|try
block|{
name|e
operator|=
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
operator|(
name|RemoteException
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|e
operator|=
name|ex
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|""
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|waitTime
operator|=
name|stopRequested
condition|?
literal|0
else|:
name|msgInterval
operator|-
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|lastMsg
operator|)
expr_stmt|;
if|if
condition|(
name|waitTime
operator|>
literal|0
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
try|try
block|{
name|wait
argument_list|(
name|waitTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{
comment|// On interrupt we go around to the while test of stopRequested
block|}
block|}
block|}
block|}
block|}
name|leases
operator|.
name|closeAfterLeasesExpire
argument_list|()
expr_stmt|;
name|this
operator|.
name|worker
operator|.
name|stop
argument_list|()
expr_stmt|;
name|this
operator|.
name|server
operator|.
name|stop
argument_list|()
expr_stmt|;
comment|// Send interrupts to wake up threads if sleeping so they notice shutdown.
synchronized|synchronized
init|(
name|logRollerLock
init|)
block|{
name|this
operator|.
name|logRollerThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|cacheFlusherLock
init|)
block|{
name|this
operator|.
name|cacheFlusherThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|splitOrCompactLock
init|)
block|{
name|this
operator|.
name|splitOrCompactCheckerThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|abortRequested
condition|)
block|{
try|try
block|{
name|log
operator|.
name|close
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"On abort, closed hlog"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|RemoteException
condition|)
block|{
try|try
block|{
name|e
operator|=
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
operator|(
name|RemoteException
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|e
operator|=
name|ex
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to close log in abort"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|closeAllRegions
argument_list|()
expr_stmt|;
comment|// Don't leave any open file handles
name|LOG
operator|.
name|info
argument_list|(
literal|"aborting server at: "
operator|+
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ArrayList
argument_list|<
name|HRegion
argument_list|>
name|closedRegions
init|=
name|closeAllRegions
argument_list|()
decl_stmt|;
try|try
block|{
name|log
operator|.
name|closeAndDelete
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|RemoteException
condition|)
block|{
try|try
block|{
name|e
operator|=
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
operator|(
name|RemoteException
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|e
operator|=
name|ex
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|""
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
operator|!
name|masterRequestedStop
condition|)
block|{
name|HMsg
index|[]
name|exitMsg
init|=
operator|new
name|HMsg
index|[
name|closedRegions
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
decl_stmt|;
name|exitMsg
index|[
literal|0
index|]
operator|=
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|MSG_REPORT_EXITING
argument_list|)
expr_stmt|;
comment|// Tell the master what regions we are/were serving
name|int
name|i
init|=
literal|1
decl_stmt|;
for|for
control|(
name|HRegion
name|region
range|:
name|closedRegions
control|)
block|{
name|exitMsg
index|[
name|i
operator|++
index|]
operator|=
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|MSG_REPORT_CLOSE
argument_list|,
name|region
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"telling master that region server is shutting down at: "
operator|+
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|hbaseMaster
operator|.
name|regionServerReport
argument_list|(
name|serverInfo
argument_list|,
name|exitMsg
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|RemoteException
condition|)
block|{
try|try
block|{
name|e
operator|=
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
operator|(
name|RemoteException
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|e
operator|=
name|ex
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|""
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"stopping server at: "
operator|+
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|join
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"main thread exiting"
argument_list|)
expr_stmt|;
block|}
comment|/** Add to the outbound message buffer */
specifier|private
name|void
name|reportOpen
parameter_list|(
name|HRegion
name|region
parameter_list|)
block|{
synchronized|synchronized
init|(
name|outboundMsgs
init|)
block|{
name|outboundMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|MSG_REPORT_OPEN
argument_list|,
name|region
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Add to the outbound message buffer */
specifier|private
name|void
name|reportClose
parameter_list|(
name|HRegion
name|region
parameter_list|)
block|{
synchronized|synchronized
init|(
name|outboundMsgs
init|)
block|{
name|outboundMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|MSG_REPORT_CLOSE
argument_list|,
name|region
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Add to the outbound message buffer    *     * When a region splits, we need to tell the master that there are two new     * regions that need to be assigned.    *     * We do not need to inform the master about the old region, because we've    * updated the meta or root regions, and the master will pick that up on its    * next rescan of the root or meta tables.    */
name|void
name|reportSplit
parameter_list|(
name|HRegionInfo
name|oldRegion
parameter_list|,
name|HRegionInfo
name|newRegionA
parameter_list|,
name|HRegionInfo
name|newRegionB
parameter_list|)
block|{
synchronized|synchronized
init|(
name|outboundMsgs
init|)
block|{
name|outboundMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|MSG_REPORT_SPLIT
argument_list|,
name|oldRegion
argument_list|)
argument_list|)
expr_stmt|;
name|outboundMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|MSG_REPORT_OPEN
argument_list|,
name|newRegionA
argument_list|)
argument_list|)
expr_stmt|;
name|outboundMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|MSG_REPORT_OPEN
argument_list|,
name|newRegionB
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//////////////////////////////////////////////////////////////////////////////
comment|// HMaster-given operations
comment|//////////////////////////////////////////////////////////////////////////////
specifier|private
specifier|static
class|class
name|ToDoEntry
block|{
name|int
name|tries
decl_stmt|;
name|HMsg
name|msg
decl_stmt|;
name|ToDoEntry
parameter_list|(
name|HMsg
name|msg
parameter_list|)
block|{
name|this
operator|.
name|tries
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|msg
operator|=
name|msg
expr_stmt|;
block|}
block|}
name|BlockingQueue
argument_list|<
name|ToDoEntry
argument_list|>
name|toDo
decl_stmt|;
specifier|private
name|Worker
name|worker
decl_stmt|;
specifier|private
name|Thread
name|workerThread
decl_stmt|;
comment|/** Thread that performs long running requests from the master */
class|class
name|Worker
implements|implements
name|Runnable
block|{
name|void
name|stop
parameter_list|()
block|{
synchronized|synchronized
init|(
name|toDo
init|)
block|{
name|toDo
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * {@inheritDoc}      */
specifier|public
name|void
name|run
parameter_list|()
block|{
for|for
control|(
name|ToDoEntry
name|e
init|=
literal|null
init|;
operator|!
name|stopRequested
condition|;
control|)
block|{
try|try
block|{
name|e
operator|=
name|toDo
operator|.
name|poll
argument_list|(
name|threadWakeFrequency
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
comment|// continue
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|stopRequested
condition|)
block|{
continue|continue;
block|}
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
name|e
operator|.
name|msg
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|e
operator|.
name|msg
operator|.
name|getMsg
argument_list|()
condition|)
block|{
case|case
name|HMsg
operator|.
name|MSG_REGION_OPEN
case|:
comment|// Open a region
name|openRegion
argument_list|(
name|e
operator|.
name|msg
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|HMsg
operator|.
name|MSG_REGION_CLOSE
case|:
comment|// Close a region
name|closeRegion
argument_list|(
name|e
operator|.
name|msg
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|HMsg
operator|.
name|MSG_REGION_CLOSE_WITHOUT_REPORT
case|:
comment|// Close a region, don't reply
name|closeRegion
argument_list|(
name|e
operator|.
name|msg
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Impossible state during msg processing.  Instruction: "
operator|+
name|e
operator|.
name|msg
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
if|if
condition|(
name|ie
operator|instanceof
name|RemoteException
condition|)
block|{
try|try
block|{
name|ie
operator|=
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
operator|(
name|RemoteException
operator|)
name|ie
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
name|ie
operator|=
name|x
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|.
name|tries
operator|<
name|numRetries
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ie
argument_list|)
expr_stmt|;
name|e
operator|.
name|tries
operator|++
expr_stmt|;
try|try
block|{
name|toDo
operator|.
name|put
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Putting into msgQueue was interrupted."
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"unable to process message: "
operator|+
name|e
operator|.
name|msg
operator|.
name|toString
argument_list|()
argument_list|,
name|ie
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkFileSystem
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"worker thread exiting"
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|openRegion
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegion
name|region
init|=
name|onlineRegions
operator|.
name|get
argument_list|(
name|regionInfo
operator|.
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|==
literal|null
condition|)
block|{
name|region
operator|=
operator|new
name|HRegion
argument_list|(
name|rootDir
argument_list|,
name|log
argument_list|,
name|fs
argument_list|,
name|conf
argument_list|,
name|regionInfo
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|log
operator|.
name|setSequenceNumber
argument_list|(
name|region
operator|.
name|getMaxSequenceId
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|onlineRegions
operator|.
name|put
argument_list|(
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
name|reportOpen
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
name|void
name|closeRegion
parameter_list|(
specifier|final
name|HRegionInfo
name|hri
parameter_list|,
specifier|final
name|boolean
name|reportWhenCompleted
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
name|HRegion
name|region
init|=
literal|null
decl_stmt|;
try|try
block|{
name|region
operator|=
name|onlineRegions
operator|.
name|remove
argument_list|(
name|hri
operator|.
name|regionName
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|region
operator|!=
literal|null
condition|)
block|{
name|region
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|reportWhenCompleted
condition|)
block|{
name|reportClose
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Called either when the master tells us to restart or from stop() */
name|ArrayList
argument_list|<
name|HRegion
argument_list|>
name|closeAllRegions
parameter_list|()
block|{
name|ArrayList
argument_list|<
name|HRegion
argument_list|>
name|regionsToClose
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegion
argument_list|>
argument_list|()
decl_stmt|;
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|regionsToClose
operator|.
name|addAll
argument_list|(
name|onlineRegions
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|onlineRegions
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|HRegion
name|region
range|:
name|regionsToClose
control|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"closing region "
operator|+
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|region
operator|.
name|close
argument_list|(
name|abortRequested
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|RemoteException
condition|)
block|{
try|try
block|{
name|e
operator|=
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
operator|(
name|RemoteException
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
name|e
operator|=
name|x
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"error closing region "
operator|+
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|regionsToClose
return|;
block|}
comment|//
comment|// HRegionInterface
comment|//
comment|/** {@inheritDoc} */
specifier|public
name|HRegionInfo
name|getRegionInfo
parameter_list|(
specifier|final
name|Text
name|regionName
parameter_list|)
throws|throws
name|NotServingRegionException
block|{
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return
name|getRegion
argument_list|(
name|regionName
argument_list|)
operator|.
name|getRegionInfo
argument_list|()
return|;
block|}
comment|/** {@inheritDoc} */
specifier|public
name|byte
index|[]
name|get
parameter_list|(
specifier|final
name|Text
name|regionName
parameter_list|,
specifier|final
name|Text
name|row
parameter_list|,
specifier|final
name|Text
name|column
parameter_list|)
throws|throws
name|IOException
block|{
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|getRegion
argument_list|(
name|regionName
argument_list|)
operator|.
name|get
argument_list|(
name|row
argument_list|,
name|column
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkFileSystem
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/** {@inheritDoc} */
specifier|public
name|byte
index|[]
index|[]
name|get
parameter_list|(
specifier|final
name|Text
name|regionName
parameter_list|,
specifier|final
name|Text
name|row
parameter_list|,
specifier|final
name|Text
name|column
parameter_list|,
specifier|final
name|int
name|numVersions
parameter_list|)
throws|throws
name|IOException
block|{
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|getRegion
argument_list|(
name|regionName
argument_list|)
operator|.
name|get
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|numVersions
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkFileSystem
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/** {@inheritDoc} */
specifier|public
name|byte
index|[]
index|[]
name|get
parameter_list|(
specifier|final
name|Text
name|regionName
parameter_list|,
specifier|final
name|Text
name|row
parameter_list|,
specifier|final
name|Text
name|column
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|int
name|numVersions
parameter_list|)
throws|throws
name|IOException
block|{
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|getRegion
argument_list|(
name|regionName
argument_list|)
operator|.
name|get
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|timestamp
argument_list|,
name|numVersions
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkFileSystem
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/** {@inheritDoc} */
specifier|public
name|MapWritable
name|getRow
parameter_list|(
specifier|final
name|Text
name|regionName
parameter_list|,
specifier|final
name|Text
name|row
parameter_list|)
throws|throws
name|IOException
block|{
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|MapWritable
name|result
init|=
operator|new
name|MapWritable
argument_list|()
decl_stmt|;
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
name|map
init|=
name|region
operator|.
name|getFull
argument_list|(
name|row
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
name|es
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|result
operator|.
name|put
argument_list|(
operator|new
name|HStoreKey
argument_list|(
name|row
argument_list|,
name|es
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|,
operator|new
name|ImmutableBytesWritable
argument_list|(
name|es
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkFileSystem
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/** {@inheritDoc} */
specifier|public
name|MapWritable
name|next
parameter_list|(
specifier|final
name|long
name|scannerId
parameter_list|)
throws|throws
name|IOException
block|{
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|String
name|scannerName
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
name|HInternalScannerInterface
name|s
init|=
name|scanners
operator|.
name|get
argument_list|(
name|scannerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownScannerException
argument_list|(
literal|"Name: "
operator|+
name|scannerName
argument_list|)
throw|;
block|}
name|leases
operator|.
name|renewLease
argument_list|(
name|scannerId
argument_list|,
name|scannerId
argument_list|)
expr_stmt|;
comment|// Collect values to be returned here
name|MapWritable
name|values
init|=
operator|new
name|MapWritable
argument_list|()
decl_stmt|;
name|HStoreKey
name|key
init|=
operator|new
name|HStoreKey
argument_list|()
decl_stmt|;
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
name|results
init|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|s
operator|.
name|next
argument_list|(
name|key
argument_list|,
name|results
argument_list|)
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
name|e
range|:
name|results
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|values
operator|.
name|put
argument_list|(
operator|new
name|HStoreKey
argument_list|(
name|key
operator|.
name|getRow
argument_list|()
argument_list|,
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|key
operator|.
name|getTimestamp
argument_list|()
argument_list|)
argument_list|,
operator|new
name|ImmutableBytesWritable
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|values
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Row has something in it. Return the value.
break|break;
block|}
comment|// No data for this row, go get another.
name|results
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
return|return
name|values
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkFileSystem
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/** {@inheritDoc} */
specifier|public
name|void
name|batchUpdate
parameter_list|(
name|Text
name|regionName
parameter_list|,
name|long
name|timestamp
parameter_list|,
name|BatchUpdate
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
comment|// If timestamp == LATEST_TIMESTAMP and we have deletes, then they need
comment|// special treatment.  For these we need to first find the latest cell so
comment|// when we write the delete, we write it with the latest cells' timestamp
comment|// so the delete record overshadows.  This means deletes and puts do not
comment|// happen within the same row lock.
name|List
argument_list|<
name|Text
argument_list|>
name|deletes
init|=
literal|null
decl_stmt|;
try|try
block|{
name|long
name|lockid
init|=
name|startUpdate
argument_list|(
name|regionName
argument_list|,
name|b
operator|.
name|getRow
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|BatchOperation
name|op
range|:
name|b
control|)
block|{
switch|switch
condition|(
name|op
operator|.
name|getOp
argument_list|()
condition|)
block|{
case|case
name|PUT
case|:
name|put
argument_list|(
name|regionName
argument_list|,
name|lockid
argument_list|,
name|op
operator|.
name|getColumn
argument_list|()
argument_list|,
name|op
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|DELETE
case|:
if|if
condition|(
name|timestamp
operator|==
name|LATEST_TIMESTAMP
condition|)
block|{
comment|// Save off these deletes.
if|if
condition|(
name|deletes
operator|==
literal|null
condition|)
block|{
name|deletes
operator|=
operator|new
name|ArrayList
argument_list|<
name|Text
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|deletes
operator|.
name|add
argument_list|(
name|op
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|delete
argument_list|(
name|regionName
argument_list|,
name|lockid
argument_list|,
name|op
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|commit
argument_list|(
name|regionName
argument_list|,
name|lockid
argument_list|,
operator|(
name|timestamp
operator|==
name|LATEST_TIMESTAMP
operator|)
condition|?
name|System
operator|.
name|currentTimeMillis
argument_list|()
else|:
name|timestamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|deletes
operator|!=
literal|null
operator|&&
name|deletes
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// We have some LATEST_TIMESTAMP deletes to run.
name|HRegion
name|r
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
for|for
control|(
name|Text
name|column
range|:
name|deletes
control|)
block|{
name|r
operator|.
name|deleteMultiple
argument_list|(
name|b
operator|.
name|getRow
argument_list|()
argument_list|,
name|column
argument_list|,
name|LATEST_TIMESTAMP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkFileSystem
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|//
comment|// remote scanner interface
comment|//
comment|/** {@inheritDoc} */
specifier|public
name|long
name|openScanner
parameter_list|(
name|Text
name|regionName
parameter_list|,
name|Text
index|[]
name|cols
parameter_list|,
name|Text
name|firstRow
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|RowFilterInterface
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|r
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|long
name|scannerId
init|=
operator|-
literal|1L
decl_stmt|;
name|HInternalScannerInterface
name|s
init|=
name|r
operator|.
name|getScanner
argument_list|(
name|cols
argument_list|,
name|firstRow
argument_list|,
name|timestamp
argument_list|,
name|filter
argument_list|)
decl_stmt|;
name|scannerId
operator|=
name|rand
operator|.
name|nextLong
argument_list|()
expr_stmt|;
name|String
name|scannerName
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|scanners
init|)
block|{
name|scanners
operator|.
name|put
argument_list|(
name|scannerName
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|leases
operator|.
name|createLease
argument_list|(
name|scannerId
argument_list|,
name|scannerId
argument_list|,
operator|new
name|ScannerListener
argument_list|(
name|scannerName
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|scannerId
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|RemoteException
condition|)
block|{
try|try
block|{
name|e
operator|=
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
operator|(
name|RemoteException
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
name|e
operator|=
name|x
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|""
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|checkFileSystem
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/** {@inheritDoc} */
specifier|public
name|void
name|close
parameter_list|(
specifier|final
name|long
name|scannerId
parameter_list|)
throws|throws
name|IOException
block|{
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|String
name|scannerName
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
name|HInternalScannerInterface
name|s
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|scanners
init|)
block|{
name|s
operator|=
name|scanners
operator|.
name|remove
argument_list|(
name|scannerName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownScannerException
argument_list|(
name|scannerName
argument_list|)
throw|;
block|}
name|s
operator|.
name|close
argument_list|()
expr_stmt|;
name|leases
operator|.
name|cancelLease
argument_list|(
name|scannerId
argument_list|,
name|scannerId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkFileSystem
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|HInternalScannerInterface
argument_list|>
name|scanners
init|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|HInternalScannerInterface
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|/**     * Instantiated as a scanner lease.    * If the lease times out, the scanner is closed    */
specifier|private
class|class
name|ScannerListener
implements|implements
name|LeaseListener
block|{
specifier|private
specifier|final
name|String
name|scannerName
decl_stmt|;
name|ScannerListener
parameter_list|(
specifier|final
name|String
name|n
parameter_list|)
block|{
name|this
operator|.
name|scannerName
operator|=
name|n
expr_stmt|;
block|}
comment|/** {@inheritDoc} */
specifier|public
name|void
name|leaseExpired
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Scanner "
operator|+
name|this
operator|.
name|scannerName
operator|+
literal|" lease expired"
argument_list|)
expr_stmt|;
name|HInternalScannerInterface
name|s
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|scanners
init|)
block|{
name|s
operator|=
name|scanners
operator|.
name|remove
argument_list|(
name|this
operator|.
name|scannerName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|s
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Closing scanner"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|//
comment|// Methods that do the actual work for the remote API
comment|//
specifier|protected
name|long
name|startUpdate
parameter_list|(
name|Text
name|regionName
parameter_list|,
name|Text
name|row
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
return|return
name|region
operator|.
name|startUpdate
argument_list|(
name|row
argument_list|)
return|;
block|}
specifier|protected
name|void
name|put
parameter_list|(
specifier|final
name|Text
name|regionName
parameter_list|,
specifier|final
name|long
name|lockid
parameter_list|,
specifier|final
name|Text
name|column
parameter_list|,
specifier|final
name|byte
index|[]
name|val
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|region
operator|.
name|put
argument_list|(
name|lockid
argument_list|,
name|column
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|delete
parameter_list|(
name|Text
name|regionName
parameter_list|,
name|long
name|lockid
parameter_list|,
name|Text
name|column
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|region
operator|.
name|delete
argument_list|(
name|lockid
argument_list|,
name|column
argument_list|)
expr_stmt|;
block|}
comment|/** {@inheritDoc} */
specifier|public
name|void
name|deleteAll
parameter_list|(
specifier|final
name|Text
name|regionName
parameter_list|,
specifier|final
name|Text
name|row
parameter_list|,
specifier|final
name|Text
name|column
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|region
operator|.
name|deleteAll
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|commit
parameter_list|(
name|Text
name|regionName
parameter_list|,
specifier|final
name|long
name|lockid
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|region
operator|.
name|commit
argument_list|(
name|lockid
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
block|}
comment|/**     * Protected utility method for safely obtaining an HRegion handle.    * @param regionName Name of online {@link HRegion} to return    * @return {@link HRegion} for<code>regionName</code>    * @throws NotServingRegionException    */
specifier|protected
name|HRegion
name|getRegion
parameter_list|(
specifier|final
name|Text
name|regionName
parameter_list|)
throws|throws
name|NotServingRegionException
block|{
return|return
name|getRegion
argument_list|(
name|regionName
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**     * Protected utility method for safely obtaining an HRegion handle.    * @param regionName Name of online {@link HRegion} to return    * @param checkRetiringRegions Set true if we're to check retiring regions    * as well as online regions.    * @return {@link HRegion} for<code>regionName</code>    * @throws NotServingRegionException    */
specifier|protected
name|HRegion
name|getRegion
parameter_list|(
specifier|final
name|Text
name|regionName
parameter_list|,
specifier|final
name|boolean
name|checkRetiringRegions
parameter_list|)
throws|throws
name|NotServingRegionException
block|{
name|HRegion
name|region
init|=
literal|null
decl_stmt|;
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|region
operator|=
name|onlineRegions
operator|.
name|get
argument_list|(
name|regionName
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|==
literal|null
operator|&&
name|checkRetiringRegions
condition|)
block|{
name|region
operator|=
name|this
operator|.
name|retiringRegions
operator|.
name|get
argument_list|(
name|regionName
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|region
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found region "
operator|+
name|regionName
operator|+
literal|" in retiringRegions"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|region
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NotServingRegionException
argument_list|(
name|regionName
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|region
return|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Checks to see if the file system is still accessible.    * If not, sets abortRequested and stopRequested    *     * @return false if file system is not available    */
specifier|protected
name|boolean
name|checkFileSystem
parameter_list|()
block|{
if|if
condition|(
name|fsOk
condition|)
block|{
if|if
condition|(
operator|!
name|FSUtils
operator|.
name|isFileSystemAvailable
argument_list|(
name|fs
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Shutting down HRegionServer: file system not available"
argument_list|)
expr_stmt|;
name|abortRequested
operator|=
literal|true
expr_stmt|;
name|stopRequested
operator|=
literal|true
expr_stmt|;
name|fsOk
operator|=
literal|false
expr_stmt|;
block|}
block|}
return|return
name|fsOk
return|;
block|}
comment|//
comment|// Main program and support routines
comment|//
specifier|private
specifier|static
name|void
name|printUsageAndExit
parameter_list|()
block|{
name|printUsageAndExit
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|printUsageAndExit
parameter_list|(
specifier|final
name|String
name|message
parameter_list|)
block|{
if|if
condition|(
name|message
operator|!=
literal|null
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Usage: java "
operator|+
literal|"org.apache.hbase.HRegionServer [--bind=hostname:port] start"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param args    */
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
if|if
condition|(
name|args
operator|.
name|length
operator|<
literal|1
condition|)
block|{
name|printUsageAndExit
argument_list|()
expr_stmt|;
block|}
name|Configuration
name|conf
init|=
operator|new
name|HBaseConfiguration
argument_list|()
decl_stmt|;
comment|// Process command-line args. TODO: Better cmd-line processing
comment|// (but hopefully something not as painful as cli options).
specifier|final
name|String
name|addressArgKey
init|=
literal|"--bind="
decl_stmt|;
for|for
control|(
name|String
name|cmd
range|:
name|args
control|)
block|{
if|if
condition|(
name|cmd
operator|.
name|startsWith
argument_list|(
name|addressArgKey
argument_list|)
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|REGIONSERVER_ADDRESS
argument_list|,
name|cmd
operator|.
name|substring
argument_list|(
name|addressArgKey
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|cmd
operator|.
name|equals
argument_list|(
literal|"start"
argument_list|)
condition|)
block|{
try|try
block|{
operator|(
operator|new
name|Thread
argument_list|(
operator|new
name|HRegionServer
argument_list|(
name|conf
argument_list|)
argument_list|)
operator|)
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Can not start region server because "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|cmd
operator|.
name|equals
argument_list|(
literal|"stop"
argument_list|)
condition|)
block|{
name|printUsageAndExit
argument_list|(
literal|"There is no regionserver stop mechanism. To stop "
operator|+
literal|"regionservers, shutdown the hbase master"
argument_list|)
expr_stmt|;
block|}
comment|// Print out usage if we get to here.
name|printUsageAndExit
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

