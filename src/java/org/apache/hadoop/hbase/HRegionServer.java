begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2007 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|Thread
operator|.
name|UncaughtExceptionHandler
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ConcurrentModificationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Delayed
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|DelayQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|RowFilterInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|BatchUpdate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|ImmutableBytesWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HbaseRPC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|InfoServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Sleeper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Writables
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|HbaseMapWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|DNS
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_comment
comment|/**  * HRegionServer makes a set of HRegions available to clients.  It checks in with  * the HMaster. There are many HRegionServers in a single HBase deployment.  */
end_comment

begin_class
specifier|public
class|class
name|HRegionServer
implements|implements
name|HConstants
implements|,
name|HRegionInterface
implements|,
name|Runnable
block|{
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HRegionServer
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Set when a report to the master comes back with a message asking us to
comment|// shutdown.  Also set by call to stop when debugging or running unit tests
comment|// of HRegionServer in isolation. We use AtomicBoolean rather than
comment|// plain boolean so we can pass a reference to Chore threads.  Otherwise,
comment|// Chore threads need to know about the hosting class.
specifier|protected
specifier|volatile
name|AtomicBoolean
name|stopRequested
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|protected
specifier|volatile
name|AtomicBoolean
name|quiesced
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|// Go down hard.  Used if file system becomes unavailable and also in
comment|// debugging and unit tests.
specifier|protected
specifier|volatile
name|boolean
name|abortRequested
decl_stmt|;
comment|// If false, the file system has become unavailable
specifier|protected
specifier|volatile
name|boolean
name|fsOk
decl_stmt|;
specifier|protected
specifier|final
name|HServerInfo
name|serverInfo
decl_stmt|;
specifier|protected
specifier|final
name|HBaseConfiguration
name|conf
decl_stmt|;
specifier|private
name|FileSystem
name|fs
decl_stmt|;
specifier|private
name|Path
name|rootDir
decl_stmt|;
specifier|private
specifier|final
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
comment|// region name -> HRegion
specifier|protected
specifier|volatile
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|HRegion
argument_list|>
name|onlineRegions
init|=
name|Collections
operator|.
name|synchronizedSortedMap
argument_list|(
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|HRegion
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
specifier|protected
specifier|volatile
name|Map
argument_list|<
name|Text
argument_list|,
name|HRegion
argument_list|>
name|retiringRegions
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|Text
argument_list|,
name|HRegion
argument_list|>
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|ReentrantReadWriteLock
name|lock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
specifier|private
specifier|volatile
name|List
argument_list|<
name|HMsg
argument_list|>
name|outboundMsgs
init|=
name|Collections
operator|.
name|synchronizedList
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|HMsg
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numRetries
decl_stmt|;
specifier|protected
specifier|final
name|int
name|threadWakeFrequency
decl_stmt|;
specifier|private
specifier|final
name|int
name|msgInterval
decl_stmt|;
specifier|private
specifier|final
name|int
name|serverLeaseTimeout
decl_stmt|;
comment|// Remote HMaster
specifier|private
name|HMasterRegionInterface
name|hbaseMaster
decl_stmt|;
comment|// Server to handle client requests.  Default access so can be accessed by
comment|// unit tests.
specifier|final
name|Server
name|server
decl_stmt|;
comment|// Leases
specifier|private
specifier|final
name|Leases
name|leases
decl_stmt|;
comment|// Request counter
specifier|private
specifier|volatile
name|AtomicInteger
name|requestCount
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|// A sleeper that sleeps for msgInterval.
specifier|private
specifier|final
name|Sleeper
name|sleeper
decl_stmt|;
comment|// Info server.  Default access so can be used by unit tests.  REGIONSERVER
comment|// is name of the webapp and the attribute name used stuffing this instance
comment|// into web context.
name|InfoServer
name|infoServer
decl_stmt|;
comment|/** region server process name */
specifier|public
specifier|static
specifier|final
name|String
name|REGIONSERVER
init|=
literal|"regionserver"
decl_stmt|;
comment|/**    * Thread to shutdown the region server in an orderly manner.  This thread    * is registered as a shutdown hook in the HRegionServer constructor and is    * only called when the HRegionServer receives a kill signal.    */
class|class
name|ShutdownThread
extends|extends
name|Thread
block|{
specifier|private
specifier|final
name|HRegionServer
name|instance
decl_stmt|;
comment|/**      * @param instance      */
specifier|public
name|ShutdownThread
parameter_list|(
name|HRegionServer
name|instance
parameter_list|)
block|{
name|this
operator|.
name|instance
operator|=
name|instance
expr_stmt|;
block|}
comment|/** {@inheritDoc} */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|start
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting shutdown thread."
argument_list|)
expr_stmt|;
comment|// tell the region server to stop and wait for it to complete
name|instance
operator|.
name|stop
argument_list|()
expr_stmt|;
name|instance
operator|.
name|join
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Shutdown thread complete"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Queue entry passed to flusher, compactor and splitter threads */
class|class
name|QueueEntry
implements|implements
name|Delayed
block|{
specifier|private
specifier|final
name|HRegion
name|region
decl_stmt|;
specifier|private
name|long
name|expirationTime
decl_stmt|;
name|QueueEntry
parameter_list|(
name|HRegion
name|region
parameter_list|,
name|long
name|expirationTime
parameter_list|)
block|{
name|this
operator|.
name|region
operator|=
name|region
expr_stmt|;
name|this
operator|.
name|expirationTime
operator|=
name|expirationTime
expr_stmt|;
block|}
comment|/** {@inheritDoc} */
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|QueueEntry
name|other
init|=
operator|(
name|QueueEntry
operator|)
name|o
decl_stmt|;
return|return
name|this
operator|.
name|hashCode
argument_list|()
operator|==
name|other
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|/** {@inheritDoc} */
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|this
operator|.
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|/** {@inheritDoc} */
specifier|public
name|long
name|getDelay
parameter_list|(
name|TimeUnit
name|unit
parameter_list|)
block|{
return|return
name|unit
operator|.
name|convert
argument_list|(
name|this
operator|.
name|expirationTime
operator|-
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
return|;
block|}
comment|/** {@inheritDoc} */
specifier|public
name|int
name|compareTo
parameter_list|(
name|Delayed
name|o
parameter_list|)
block|{
name|long
name|delta
init|=
name|this
operator|.
name|getDelay
argument_list|(
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
operator|-
name|o
operator|.
name|getDelay
argument_list|(
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|delta
operator|>
literal|0
condition|)
block|{
name|value
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
block|{
name|value
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
comment|/** @return the region */
specifier|public
name|HRegion
name|getRegion
parameter_list|()
block|{
return|return
name|region
return|;
block|}
comment|/** @param expirationTime the expirationTime to set */
specifier|public
name|void
name|setExpirationTime
parameter_list|(
name|long
name|expirationTime
parameter_list|)
block|{
name|this
operator|.
name|expirationTime
operator|=
name|expirationTime
expr_stmt|;
block|}
block|}
comment|// Check to see if regions should be split
specifier|final
name|Splitter
name|splitter
decl_stmt|;
comment|// Needed at shutdown. On way out, if can get this lock then we are not in
comment|// middle of a split or compaction: i.e. splits/compactions cannot be
comment|// interrupted.
specifier|final
name|Integer
name|splitterLock
init|=
operator|new
name|Integer
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/** Split regions on request */
class|class
name|Splitter
extends|extends
name|Thread
implements|implements
name|RegionUnavailableListener
block|{
specifier|private
specifier|final
name|BlockingQueue
argument_list|<
name|QueueEntry
argument_list|>
name|splitQueue
init|=
operator|new
name|LinkedBlockingQueue
argument_list|<
name|QueueEntry
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|HTable
name|root
init|=
literal|null
decl_stmt|;
specifier|private
name|HTable
name|meta
init|=
literal|null
decl_stmt|;
comment|/** constructor */
specifier|public
name|Splitter
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
comment|/** {@inheritDoc} */
specifier|public
name|void
name|closing
parameter_list|(
specifier|final
name|Text
name|regionName
parameter_list|)
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Remove region from regions Map and add it to the Map of retiring
comment|// regions.
name|retiringRegions
operator|.
name|put
argument_list|(
name|regionName
argument_list|,
name|onlineRegions
operator|.
name|remove
argument_list|(
name|regionName
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|regionName
operator|.
name|toString
argument_list|()
operator|+
literal|" closing ("
operator|+
literal|"Adding to retiringRegions)"
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** {@inheritDoc} */
specifier|public
name|void
name|closed
parameter_list|(
specifier|final
name|Text
name|regionName
parameter_list|)
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|retiringRegions
operator|.
name|remove
argument_list|(
name|regionName
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|regionName
operator|.
name|toString
argument_list|()
operator|+
literal|" closed"
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Perform region splits if necessary      */
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
operator|!
name|stopRequested
operator|.
name|get
argument_list|()
condition|)
block|{
name|QueueEntry
name|e
init|=
literal|null
decl_stmt|;
try|try
block|{
name|e
operator|=
name|splitQueue
operator|.
name|poll
argument_list|(
name|threadWakeFrequency
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
continue|continue;
block|}
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
synchronized|synchronized
init|(
name|splitterLock
init|)
block|{
comment|// Don't interrupt us while we're working
try|try
block|{
name|split
argument_list|(
name|e
operator|.
name|getRegion
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Split failed for region "
operator|+
name|e
operator|.
name|getRegion
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|RemoteExceptionHandler
operator|.
name|checkIOException
argument_list|(
name|ex
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkFileSystem
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Split failed on region "
operator|+
name|e
operator|.
name|getRegion
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkFileSystem
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|" exiting"
argument_list|)
expr_stmt|;
block|}
comment|/**      * @param e entry indicating which region needs to be split      */
specifier|public
name|void
name|splitRequested
parameter_list|(
name|QueueEntry
name|e
parameter_list|)
block|{
name|splitQueue
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|split
parameter_list|(
specifier|final
name|HRegion
name|region
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|HRegionInfo
name|oldRegionInfo
init|=
name|region
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
specifier|final
name|HRegion
index|[]
name|newRegions
init|=
name|region
operator|.
name|splitRegion
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|newRegions
operator|==
literal|null
condition|)
block|{
return|return;
comment|// Didn't need to be split
block|}
comment|// When a region is split, the META table needs to updated if we're
comment|// splitting a 'normal' region, and the ROOT table needs to be
comment|// updated if we are splitting a META region.
name|HTable
name|t
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isMetaTable
argument_list|()
condition|)
block|{
comment|// We need to update the root region
if|if
condition|(
name|this
operator|.
name|root
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|root
operator|=
operator|new
name|HTable
argument_list|(
name|conf
argument_list|,
name|ROOT_TABLE_NAME
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|root
expr_stmt|;
block|}
else|else
block|{
comment|// For normal regions we need to update the meta region
if|if
condition|(
name|meta
operator|==
literal|null
condition|)
block|{
name|meta
operator|=
operator|new
name|HTable
argument_list|(
name|conf
argument_list|,
name|META_TABLE_NAME
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|meta
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Updating "
operator|+
name|t
operator|.
name|getTableName
argument_list|()
operator|+
literal|" with region split info"
argument_list|)
expr_stmt|;
comment|// Mark old region as offline and split in META.
comment|// NOTE: there is no need for retry logic here. HTable does it for us.
name|long
name|lockid
init|=
name|t
operator|.
name|startUpdate
argument_list|(
name|oldRegionInfo
operator|.
name|getRegionName
argument_list|()
argument_list|)
decl_stmt|;
name|oldRegionInfo
operator|.
name|setOffline
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|oldRegionInfo
operator|.
name|setSplit
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|t
operator|.
name|put
argument_list|(
name|lockid
argument_list|,
name|COL_REGIONINFO
argument_list|,
name|Writables
operator|.
name|getBytes
argument_list|(
name|oldRegionInfo
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|.
name|put
argument_list|(
name|lockid
argument_list|,
name|COL_SPLITA
argument_list|,
name|Writables
operator|.
name|getBytes
argument_list|(
name|newRegions
index|[
literal|0
index|]
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|.
name|put
argument_list|(
name|lockid
argument_list|,
name|COL_SPLITB
argument_list|,
name|Writables
operator|.
name|getBytes
argument_list|(
name|newRegions
index|[
literal|1
index|]
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|.
name|commit
argument_list|(
name|lockid
argument_list|)
expr_stmt|;
comment|// Add new regions to META
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newRegions
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|lockid
operator|=
name|t
operator|.
name|startUpdate
argument_list|(
name|newRegions
index|[
name|i
index|]
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|.
name|put
argument_list|(
name|lockid
argument_list|,
name|COL_REGIONINFO
argument_list|,
name|Writables
operator|.
name|getBytes
argument_list|(
name|newRegions
index|[
name|i
index|]
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|.
name|commit
argument_list|(
name|lockid
argument_list|)
expr_stmt|;
block|}
comment|// Now tell the master about the new regions
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reporting region split to master"
argument_list|)
expr_stmt|;
block|}
name|reportSplit
argument_list|(
name|oldRegionInfo
argument_list|,
name|newRegions
index|[
literal|0
index|]
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|newRegions
index|[
literal|1
index|]
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"region split, META update, and report to master all"
operator|+
literal|" successful. Old region="
operator|+
name|oldRegionInfo
operator|.
name|getRegionName
argument_list|()
operator|+
literal|", new regions: "
operator|+
name|newRegions
index|[
literal|0
index|]
operator|.
name|getRegionName
argument_list|()
operator|+
literal|", "
operator|+
name|newRegions
index|[
literal|1
index|]
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Do not serve the new regions. Let the Master assign them.
block|}
block|}
comment|// Compactions
specifier|final
name|Compactor
name|compactor
decl_stmt|;
comment|// Needed during shutdown so we send an interrupt after completion of a
comment|// compaction, not in the midst.
specifier|final
name|Integer
name|compactionLock
init|=
operator|new
name|Integer
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/** Compact region on request */
class|class
name|Compactor
extends|extends
name|Thread
block|{
specifier|private
specifier|final
name|BlockingQueue
argument_list|<
name|QueueEntry
argument_list|>
name|compactionQueue
init|=
operator|new
name|LinkedBlockingQueue
argument_list|<
name|QueueEntry
argument_list|>
argument_list|()
decl_stmt|;
comment|/** constructor */
specifier|public
name|Compactor
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
comment|/** {@inheritDoc} */
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
operator|!
name|stopRequested
operator|.
name|get
argument_list|()
condition|)
block|{
name|QueueEntry
name|e
init|=
literal|null
decl_stmt|;
try|try
block|{
name|e
operator|=
name|compactionQueue
operator|.
name|poll
argument_list|(
name|threadWakeFrequency
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
continue|continue;
block|}
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
try|try
block|{
if|if
condition|(
name|e
operator|.
name|getRegion
argument_list|()
operator|.
name|compactIfNeeded
argument_list|()
condition|)
block|{
name|splitter
operator|.
name|splitRequested
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Compaction failed for region "
operator|+
name|e
operator|.
name|getRegion
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|RemoteExceptionHandler
operator|.
name|checkIOException
argument_list|(
name|ex
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkFileSystem
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Compaction failed for region "
operator|+
name|e
operator|.
name|getRegion
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkFileSystem
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|" exiting"
argument_list|)
expr_stmt|;
block|}
comment|/**      * @param e QueueEntry for region to be compacted      */
specifier|public
name|void
name|compactionRequested
parameter_list|(
name|QueueEntry
name|e
parameter_list|)
block|{
name|compactionQueue
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Cache flushing
specifier|final
name|Flusher
name|cacheFlusher
decl_stmt|;
comment|// Needed during shutdown so we send an interrupt after completion of a
comment|// flush, not in the midst.
specifier|final
name|Integer
name|cacheFlusherLock
init|=
operator|new
name|Integer
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/** Flush cache upon request */
class|class
name|Flusher
extends|extends
name|Thread
implements|implements
name|CacheFlushListener
block|{
specifier|private
specifier|final
name|DelayQueue
argument_list|<
name|QueueEntry
argument_list|>
name|flushQueue
init|=
operator|new
name|DelayQueue
argument_list|<
name|QueueEntry
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|long
name|optionalFlushPeriod
decl_stmt|;
comment|/** constructor */
specifier|public
name|Flusher
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|optionalFlushPeriod
operator|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.regionserver.optionalcacheflushinterval"
argument_list|,
literal|60L
operator|*
literal|1000L
argument_list|)
expr_stmt|;
block|}
comment|/** {@inheritDoc} */
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
operator|!
name|stopRequested
operator|.
name|get
argument_list|()
condition|)
block|{
name|QueueEntry
name|e
init|=
literal|null
decl_stmt|;
try|try
block|{
name|e
operator|=
name|flushQueue
operator|.
name|poll
argument_list|(
name|threadWakeFrequency
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
continue|continue;
block|}
catch|catch
parameter_list|(
name|ConcurrentModificationException
name|ex
parameter_list|)
block|{
continue|continue;
block|}
synchronized|synchronized
init|(
name|cacheFlusherLock
init|)
block|{
comment|// Don't interrupt while we're working
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|.
name|getRegion
argument_list|()
operator|.
name|flushcache
argument_list|()
condition|)
block|{
name|compactor
operator|.
name|compactionRequested
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|DroppedSnapshotException
name|ex
parameter_list|)
block|{
comment|// Cache flush can fail in a few places.  If it fails in a critical
comment|// section, we get a DroppedSnapshotException and a replay of hlog
comment|// is required. Currently the only way to do this is a restart of
comment|// the server.
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Replay of hlog required. Forcing server restart"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkFileSystem
argument_list|()
condition|)
block|{
break|break;
block|}
name|HRegionServer
operator|.
name|this
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cache flush failed for region "
operator|+
name|e
operator|.
name|getRegion
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|RemoteExceptionHandler
operator|.
name|checkIOException
argument_list|(
name|ex
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkFileSystem
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cache flush failed for region "
operator|+
name|e
operator|.
name|getRegion
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkFileSystem
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
name|e
operator|.
name|setExpirationTime
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|optionalFlushPeriod
argument_list|)
expr_stmt|;
name|flushQueue
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|// Now insure that all the active regions are in the queue
name|Set
argument_list|<
name|HRegion
argument_list|>
name|regions
init|=
name|getRegionsToCheck
argument_list|()
decl_stmt|;
for|for
control|(
name|HRegion
name|r
range|:
name|regions
control|)
block|{
name|e
operator|=
operator|new
name|QueueEntry
argument_list|(
name|r
argument_list|,
name|r
operator|.
name|getLastFlushTime
argument_list|()
operator|+
name|optionalFlushPeriod
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|flushQueue
init|)
block|{
if|if
condition|(
operator|!
name|flushQueue
operator|.
name|contains
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|flushQueue
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Now make sure that the queue only contains active regions
synchronized|synchronized
init|(
name|flushQueue
init|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|QueueEntry
argument_list|>
name|i
init|=
name|flushQueue
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|e
operator|=
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|regions
operator|.
name|contains
argument_list|(
name|e
operator|.
name|getRegion
argument_list|()
argument_list|)
condition|)
block|{
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|flushQueue
operator|.
name|clear
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|" exiting"
argument_list|)
expr_stmt|;
block|}
comment|/** {@inheritDoc} */
specifier|public
name|void
name|flushRequested
parameter_list|(
name|HRegion
name|region
parameter_list|)
block|{
name|QueueEntry
name|e
init|=
operator|new
name|QueueEntry
argument_list|(
name|region
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|flushQueue
init|)
block|{
if|if
condition|(
name|flushQueue
operator|.
name|contains
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|flushQueue
operator|.
name|remove
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|flushQueue
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// HLog and HLog roller.  log is protected rather than private to avoid
comment|// eclipse warning when accessed by inner classes
specifier|protected
name|HLog
name|log
decl_stmt|;
specifier|final
name|LogRoller
name|logRoller
decl_stmt|;
specifier|final
name|Integer
name|logRollerLock
init|=
operator|new
name|Integer
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/** Runs periodically to determine if the HLog should be rolled */
class|class
name|LogRoller
extends|extends
name|Thread
implements|implements
name|LogRollListener
block|{
specifier|private
specifier|final
name|Integer
name|rollLock
init|=
operator|new
name|Integer
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|rollLog
decl_stmt|;
comment|/** constructor */
specifier|public
name|LogRoller
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|rollLog
operator|=
literal|false
expr_stmt|;
block|}
comment|/** {@inheritDoc} */
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
operator|!
name|stopRequested
operator|.
name|get
argument_list|()
condition|)
block|{
while|while
condition|(
operator|!
name|rollLog
operator|&&
operator|!
name|stopRequested
operator|.
name|get
argument_list|()
condition|)
block|{
synchronized|synchronized
init|(
name|rollLock
init|)
block|{
try|try
block|{
name|rollLock
operator|.
name|wait
argument_list|(
name|threadWakeFrequency
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
continue|continue;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|rollLog
condition|)
block|{
comment|// There's only two reasons to break out of the while loop.
comment|// 1. Log roll requested
comment|// 2. Stop requested
comment|// so if a log roll was not requested, continue and break out of loop
continue|continue;
block|}
synchronized|synchronized
init|(
name|logRollerLock
init|)
block|{
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Rolling hlog. Number of entries: "
operator|+
name|log
operator|.
name|getNumEntries
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|rollWriter
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Log rolling failed"
argument_list|,
name|RemoteExceptionHandler
operator|.
name|checkIOException
argument_list|(
name|ex
argument_list|)
argument_list|)
expr_stmt|;
name|checkFileSystem
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Log rolling failed"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|checkFileSystem
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|rollLog
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/** {@inheritDoc} */
specifier|public
name|void
name|logRollRequested
parameter_list|()
block|{
synchronized|synchronized
init|(
name|rollLock
init|)
block|{
name|rollLog
operator|=
literal|true
expr_stmt|;
name|rollLock
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Starts a HRegionServer at the default location    * @param conf    * @throws IOException    */
specifier|public
name|HRegionServer
parameter_list|(
name|HBaseConfiguration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
operator|new
name|HServerAddress
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|REGIONSERVER_ADDRESS
argument_list|,
name|DEFAULT_REGIONSERVER_ADDRESS
argument_list|)
argument_list|)
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Starts a HRegionServer at the specified location    * @param address    * @param conf    * @throws IOException    */
specifier|public
name|HRegionServer
parameter_list|(
name|HServerAddress
name|address
parameter_list|,
name|HBaseConfiguration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|abortRequested
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|fsOk
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
comment|// Config'ed params
name|this
operator|.
name|numRetries
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.client.retries.number"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|this
operator|.
name|threadWakeFrequency
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|THREAD_WAKE_FREQUENCY
argument_list|,
literal|10
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|this
operator|.
name|msgInterval
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.msginterval"
argument_list|,
literal|3
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|this
operator|.
name|serverLeaseTimeout
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.lease.period"
argument_list|,
literal|30
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|// Cache flushing thread.
name|this
operator|.
name|cacheFlusher
operator|=
operator|new
name|Flusher
argument_list|()
expr_stmt|;
comment|// Compaction thread
name|this
operator|.
name|compactor
operator|=
operator|new
name|Compactor
argument_list|()
expr_stmt|;
comment|// Region split thread
name|this
operator|.
name|splitter
operator|=
operator|new
name|Splitter
argument_list|()
expr_stmt|;
comment|// Log rolling thread
name|this
operator|.
name|logRoller
operator|=
operator|new
name|LogRoller
argument_list|()
expr_stmt|;
comment|// Task thread to process requests from Master
name|this
operator|.
name|worker
operator|=
operator|new
name|Worker
argument_list|()
expr_stmt|;
name|this
operator|.
name|workerThread
operator|=
operator|new
name|Thread
argument_list|(
name|worker
argument_list|)
expr_stmt|;
name|this
operator|.
name|sleeper
operator|=
operator|new
name|Sleeper
argument_list|(
name|this
operator|.
name|msgInterval
argument_list|,
name|this
operator|.
name|stopRequested
argument_list|)
expr_stmt|;
comment|// Server to handle client requests
name|this
operator|.
name|server
operator|=
name|HbaseRPC
operator|.
name|getServer
argument_list|(
name|this
argument_list|,
name|address
operator|.
name|getBindAddress
argument_list|()
argument_list|,
name|address
operator|.
name|getPort
argument_list|()
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.handler.count"
argument_list|,
literal|10
argument_list|)
argument_list|,
literal|false
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|serverInfo
operator|=
operator|new
name|HServerInfo
argument_list|(
operator|new
name|HServerAddress
argument_list|(
operator|new
name|InetSocketAddress
argument_list|(
name|getThisIP
argument_list|()
argument_list|,
name|this
operator|.
name|server
operator|.
name|getListenerAddress
argument_list|()
operator|.
name|getPort
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|,
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.info.port"
argument_list|,
literal|60030
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|leases
operator|=
operator|new
name|Leases
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.lease.period"
argument_list|,
literal|3
operator|*
literal|60
operator|*
literal|1000
argument_list|)
argument_list|,
name|this
operator|.
name|threadWakeFrequency
argument_list|)
expr_stmt|;
comment|// Register shutdown hook for HRegionServer, runs an orderly shutdown
comment|// when a kill signal is recieved
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|addShutdownHook
argument_list|(
operator|new
name|ShutdownThread
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * The HRegionServer sticks in this loop until closed. It repeatedly checks    * in with the HMaster, sending heartbeats& reports, and receiving HRegion     * load/unload instructions.    */
specifier|public
name|void
name|run
parameter_list|()
block|{
name|boolean
name|quiesceRequested
init|=
literal|false
decl_stmt|;
try|try
block|{
name|init
argument_list|(
name|reportForDuty
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|lastMsg
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|stopRequested
operator|.
name|get
argument_list|()
condition|)
block|{
comment|// Now ask master what it wants us to do and tell it what we have done
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
operator|!
name|stopRequested
operator|.
name|get
argument_list|()
condition|;
control|)
block|{
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastMsg
operator|!=
literal|0
operator|&&
operator|(
name|now
operator|-
name|lastMsg
operator|)
operator|>=
name|serverLeaseTimeout
condition|)
block|{
comment|// It has been way too long since we last reported to the master.
comment|// Commit suicide.
name|LOG
operator|.
name|fatal
argument_list|(
literal|"unable to report to master for "
operator|+
operator|(
name|now
operator|-
name|lastMsg
operator|)
operator|+
literal|" milliseconds - aborting server"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|now
operator|-
name|lastMsg
operator|)
operator|>=
name|msgInterval
condition|)
block|{
name|HMsg
name|outboundArray
index|[]
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|outboundMsgs
init|)
block|{
name|outboundArray
operator|=
name|this
operator|.
name|outboundMsgs
operator|.
name|toArray
argument_list|(
operator|new
name|HMsg
index|[
name|outboundMsgs
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|outboundMsgs
operator|.
name|clear
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|serverInfo
operator|.
name|setLoad
argument_list|(
operator|new
name|HServerLoad
argument_list|(
name|requestCount
operator|.
name|get
argument_list|()
argument_list|,
name|onlineRegions
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|requestCount
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|HMsg
name|msgs
index|[]
init|=
name|this
operator|.
name|hbaseMaster
operator|.
name|regionServerReport
argument_list|(
name|serverInfo
argument_list|,
name|outboundArray
argument_list|)
decl_stmt|;
name|lastMsg
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|quiesced
operator|.
name|get
argument_list|()
operator|&&
name|onlineRegions
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// We've just told the master we're exiting because we aren't
comment|// serving any regions. So set the stop bit and exit.
name|LOG
operator|.
name|info
argument_list|(
literal|"Server quiesced and not serving any regions. "
operator|+
literal|"Starting shutdown"
argument_list|)
expr_stmt|;
name|stopRequested
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// Queue up the HMaster's instruction stream for processing
name|boolean
name|restart
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|msgs
operator|.
name|length
operator|&&
operator|!
name|stopRequested
operator|.
name|get
argument_list|()
operator|&&
operator|!
name|restart
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|msgs
index|[
name|i
index|]
operator|.
name|getMsg
argument_list|()
condition|)
block|{
case|case
name|HMsg
operator|.
name|MSG_CALL_SERVER_STARTUP
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Got call server startup message"
argument_list|)
expr_stmt|;
comment|// We the MSG_CALL_SERVER_STARTUP on startup but we can also
comment|// get it when the master is panicing because for instance
comment|// the HDFS has been yanked out from under it.  Be wary of
comment|// this message.
if|if
condition|(
name|checkFileSystem
argument_list|()
condition|)
block|{
name|closeAllRegions
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|logRollerLock
init|)
block|{
try|try
block|{
name|log
operator|.
name|closeAndDelete
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"error closing and deleting HLog"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|serverInfo
operator|.
name|setStartCode
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|=
name|setupHLog
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|this
operator|.
name|abortRequested
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|stopRequested
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|e
operator|=
name|RemoteExceptionHandler
operator|.
name|checkIOException
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|fatal
argument_list|(
literal|"error restarting server"
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|reportForDuty
argument_list|()
expr_stmt|;
name|restart
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"file system available check failed. "
operator|+
literal|"Shutting down server."
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HMsg
operator|.
name|MSG_REGIONSERVER_STOP
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Got regionserver stop message"
argument_list|)
expr_stmt|;
name|stopRequested
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|HMsg
operator|.
name|MSG_REGIONSERVER_QUIESCE
case|:
if|if
condition|(
operator|!
name|quiesceRequested
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Got quiesce server message"
argument_list|)
expr_stmt|;
try|try
block|{
name|toDo
operator|.
name|put
argument_list|(
operator|new
name|ToDoEntry
argument_list|(
name|msgs
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Putting into msgQueue was "
operator|+
literal|"interrupted."
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|quiesceRequested
operator|=
literal|true
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|fsOk
condition|)
block|{
try|try
block|{
name|toDo
operator|.
name|put
argument_list|(
operator|new
name|ToDoEntry
argument_list|(
name|msgs
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Putting into msgQueue was "
operator|+
literal|"interrupted."
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|msgs
index|[
name|i
index|]
operator|.
name|getMsg
argument_list|()
operator|==
name|HMsg
operator|.
name|MSG_REGION_OPEN
condition|)
block|{
name|outboundMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|MSG_REPORT_PROCESS_OPEN
argument_list|,
name|msgs
index|[
name|i
index|]
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|restart
operator|||
name|this
operator|.
name|stopRequested
operator|.
name|get
argument_list|()
condition|)
block|{
name|toDo
operator|.
name|clear
argument_list|()
expr_stmt|;
break|break;
block|}
comment|// Reset tries count if we had a successful transaction.
name|tries
operator|=
literal|0
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|=
name|RemoteExceptionHandler
operator|.
name|checkIOException
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|tries
operator|<
name|this
operator|.
name|numRetries
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Processing message (Retry: "
operator|+
name|tries
operator|+
literal|")"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|tries
operator|++
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exceeded max retries: "
operator|+
name|this
operator|.
name|numRetries
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkFileSystem
argument_list|()
condition|)
block|{
continue|continue;
block|}
comment|// Something seriously wrong. Shutdown.
name|stop
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|this
operator|.
name|sleeper
operator|.
name|sleep
argument_list|(
name|lastMsg
argument_list|)
expr_stmt|;
block|}
comment|// while (!stopRequested.get())
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Unhandled exception. Aborting..."
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|leases
operator|.
name|closeAfterLeasesExpire
argument_list|()
expr_stmt|;
name|this
operator|.
name|worker
operator|.
name|stop
argument_list|()
expr_stmt|;
name|this
operator|.
name|server
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|infoServer
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping infoServer"
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|infoServer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Send interrupts to wake up threads if sleeping so they notice shutdown.
comment|// TODO: Should we check they are alive?  If OOME could have exited already
synchronized|synchronized
init|(
name|cacheFlusherLock
init|)
block|{
name|this
operator|.
name|cacheFlusher
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|compactionLock
init|)
block|{
name|this
operator|.
name|compactor
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|splitterLock
init|)
block|{
name|this
operator|.
name|splitter
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|logRollerLock
init|)
block|{
name|this
operator|.
name|logRoller
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|abortRequested
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|fsOk
condition|)
block|{
comment|// Only try to clean up if the file system is available
try|try
block|{
name|this
operator|.
name|log
operator|.
name|close
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"On abort, closed hlog"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to close log in abort"
argument_list|,
name|RemoteExceptionHandler
operator|.
name|checkIOException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|closeAllRegions
argument_list|()
expr_stmt|;
comment|// Don't leave any open file handles
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"aborting server at: "
operator|+
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ArrayList
argument_list|<
name|HRegion
argument_list|>
name|closedRegions
init|=
name|closeAllRegions
argument_list|()
decl_stmt|;
try|try
block|{
name|log
operator|.
name|closeAndDelete
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Close and delete failed"
argument_list|,
name|RemoteExceptionHandler
operator|.
name|checkIOException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|HMsg
index|[]
name|exitMsg
init|=
operator|new
name|HMsg
index|[
name|closedRegions
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
decl_stmt|;
name|exitMsg
index|[
literal|0
index|]
operator|=
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|MSG_REPORT_EXITING
argument_list|)
expr_stmt|;
comment|// Tell the master what regions we are/were serving
name|int
name|i
init|=
literal|1
decl_stmt|;
for|for
control|(
name|HRegion
name|region
range|:
name|closedRegions
control|)
block|{
name|exitMsg
index|[
name|i
operator|++
index|]
operator|=
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|MSG_REPORT_CLOSE
argument_list|,
name|region
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"telling master that region server is shutting down at: "
operator|+
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|hbaseMaster
operator|.
name|regionServerReport
argument_list|(
name|serverInfo
argument_list|,
name|exitMsg
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to send exiting message to master: "
argument_list|,
name|RemoteExceptionHandler
operator|.
name|checkIOException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"stopping server at: "
operator|+
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|join
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" exiting"
argument_list|)
expr_stmt|;
block|}
comment|/*    * Run init. Sets up hlog and starts up all server threads.    * @param c Extra configuration.    */
specifier|private
name|void
name|init
parameter_list|(
specifier|final
name|HbaseMapWritable
name|c
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Writable
argument_list|,
name|Writable
argument_list|>
name|e
range|:
name|c
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|value
init|=
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Config from master: "
operator|+
name|key
operator|+
literal|"="
operator|+
name|value
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|conf
operator|.
name|set
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|fs
operator|=
name|FileSystem
operator|.
name|get
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|rootDir
operator|=
operator|new
name|Path
argument_list|(
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|HBASE_DIR
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|log
operator|=
name|setupHLog
argument_list|()
expr_stmt|;
name|startServiceThreads
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|this
operator|.
name|stopRequested
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|e
operator|=
name|RemoteExceptionHandler
operator|.
name|checkIOException
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Failed init"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|IOException
name|ex
init|=
operator|new
name|IOException
argument_list|(
literal|"region server startup failed"
argument_list|)
decl_stmt|;
name|ex
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|ex
throw|;
block|}
block|}
specifier|private
name|HLog
name|setupHLog
parameter_list|()
throws|throws
name|RegionServerRunningException
throws|,
name|IOException
block|{
name|Path
name|logdir
init|=
operator|new
name|Path
argument_list|(
name|rootDir
argument_list|,
literal|"log"
operator|+
literal|"_"
operator|+
name|getThisIP
argument_list|()
operator|+
literal|"_"
operator|+
name|this
operator|.
name|serverInfo
operator|.
name|getStartCode
argument_list|()
operator|+
literal|"_"
operator|+
name|this
operator|.
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|getPort
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Log dir "
operator|+
name|logdir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|logdir
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RegionServerRunningException
argument_list|(
literal|"region server already "
operator|+
literal|"running at "
operator|+
name|this
operator|.
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|" because logdir "
operator|+
name|logdir
operator|.
name|toString
argument_list|()
operator|+
literal|" exists"
argument_list|)
throw|;
block|}
return|return
operator|new
name|HLog
argument_list|(
name|fs
argument_list|,
name|logdir
argument_list|,
name|conf
argument_list|,
name|logRoller
argument_list|)
return|;
block|}
comment|/*    * Start Chore Threads, Server, Worker and lease checker threads. Install an    * UncaughtExceptionHandler that calls abort of RegionServer if we get    * an unhandled exception.  We cannot set the handler on all threads.    * Server's internal Listener thread is off limits.  For Server, if an OOME,    * it waits a while then retries.  Meantime, a flush or a compaction that    * tries to run should trigger same critical condition and the shutdown will    * run.  On its way out, this server will shut down Server.  Leases are sort    * of inbetween. It has an internal thread that while it inherits from    * Chore, it keeps its own internal stop mechanism so needs to be stopped    * by this hosting server.  Worker logs the exception and exits.    */
specifier|private
name|void
name|startServiceThreads
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|n
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|UncaughtExceptionHandler
name|handler
init|=
operator|new
name|UncaughtExceptionHandler
argument_list|()
block|{
specifier|public
name|void
name|uncaughtException
parameter_list|(
name|Thread
name|t
parameter_list|,
name|Throwable
name|e
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Set stop flag in "
operator|+
name|t
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|this
operator|.
name|logRoller
argument_list|,
name|n
operator|+
literal|".logRoller"
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|this
operator|.
name|cacheFlusher
argument_list|,
name|n
operator|+
literal|".cacheFlusher"
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|this
operator|.
name|compactor
argument_list|,
name|n
operator|+
literal|".compactor"
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|this
operator|.
name|splitter
argument_list|,
name|n
operator|+
literal|".splitter"
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|this
operator|.
name|workerThread
argument_list|,
name|n
operator|+
literal|".worker"
argument_list|,
name|handler
argument_list|)
expr_stmt|;
comment|// Leases is not a Thread. Internally it runs a daemon thread.  If it gets
comment|// an unhandled exception, it will just exit.
name|this
operator|.
name|leases
operator|.
name|setName
argument_list|(
name|n
operator|+
literal|".leaseChecker"
argument_list|)
expr_stmt|;
name|this
operator|.
name|leases
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Put up info server.
name|int
name|port
init|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.info.port"
argument_list|,
literal|60030
argument_list|)
decl_stmt|;
if|if
condition|(
name|port
operator|>=
literal|0
condition|)
block|{
name|String
name|a
init|=
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.master.info.bindAddress"
argument_list|,
literal|"0.0.0.0"
argument_list|)
decl_stmt|;
name|this
operator|.
name|infoServer
operator|=
operator|new
name|InfoServer
argument_list|(
literal|"regionserver"
argument_list|,
name|a
argument_list|,
name|port
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|setAttribute
argument_list|(
literal|"regionserver"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|// Start Server.  This service is like leases in that it internally runs
comment|// a thread.
name|this
operator|.
name|server
operator|.
name|start
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"HRegionServer started at: "
operator|+
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** @return the HLog */
name|HLog
name|getLog
parameter_list|()
block|{
return|return
name|this
operator|.
name|log
return|;
block|}
comment|/*    * Use interface to get the 'real' IP for this host. 'serverInfo' is sent to    * master.  Should have the real IP of this host rather than 'localhost' or    * 0.0.0.0 or 127.0.0.1 in it.    * @return This servers' IP.    */
specifier|private
name|String
name|getThisIP
parameter_list|()
throws|throws
name|UnknownHostException
block|{
return|return
name|DNS
operator|.
name|getDefaultIP
argument_list|(
name|conf
operator|.
name|get
argument_list|(
literal|"dfs.datanode.dns.interface"
argument_list|,
literal|"default"
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Sets a flag that will cause all the HRegionServer threads to shut down    * in an orderly fashion.  Used by unit tests and called by {@link Flusher}    * if it judges server needs to be restarted.    */
specifier|synchronized
name|void
name|stop
parameter_list|()
block|{
name|this
operator|.
name|stopRequested
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
comment|// Wakes run() if it is sleeping
block|}
comment|/**    * Cause the server to exit without closing the regions it is serving, the    * log it is using and without notifying the master.    * Used unit testing and on catastrophic events such as HDFS is yanked out    * from under hbase or we OOME.    */
specifier|synchronized
name|void
name|abort
parameter_list|()
block|{
name|this
operator|.
name|abortRequested
operator|=
literal|true
expr_stmt|;
name|stop
argument_list|()
expr_stmt|;
block|}
comment|/**     * Wait on all threads to finish.    * Presumption is that all closes and stops have already been called.    */
name|void
name|join
parameter_list|()
block|{
name|join
argument_list|(
name|this
operator|.
name|workerThread
argument_list|)
expr_stmt|;
name|join
argument_list|(
name|this
operator|.
name|cacheFlusher
argument_list|)
expr_stmt|;
name|join
argument_list|(
name|this
operator|.
name|compactor
argument_list|)
expr_stmt|;
name|join
argument_list|(
name|this
operator|.
name|splitter
argument_list|)
expr_stmt|;
name|join
argument_list|(
name|this
operator|.
name|logRoller
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|join
parameter_list|(
specifier|final
name|Thread
name|t
parameter_list|)
block|{
while|while
condition|(
name|t
operator|.
name|isAlive
argument_list|()
condition|)
block|{
try|try
block|{
name|t
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// continue
block|}
block|}
block|}
comment|/*    * Let the master know we're here    * Run initialization using parameters passed us by the master.    */
specifier|private
name|HbaseMapWritable
name|reportForDuty
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Telling master at "
operator|+
name|conf
operator|.
name|get
argument_list|(
name|MASTER_ADDRESS
argument_list|)
operator|+
literal|" that we are up"
argument_list|)
expr_stmt|;
block|}
comment|// Do initial RPC setup.
name|this
operator|.
name|hbaseMaster
operator|=
operator|(
name|HMasterRegionInterface
operator|)
name|HbaseRPC
operator|.
name|waitForProxy
argument_list|(
name|HMasterRegionInterface
operator|.
name|class
argument_list|,
name|HMasterRegionInterface
operator|.
name|versionID
argument_list|,
operator|new
name|HServerAddress
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|MASTER_ADDRESS
argument_list|)
argument_list|)
operator|.
name|getInetSocketAddress
argument_list|()
argument_list|,
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|HbaseMapWritable
name|result
init|=
literal|null
decl_stmt|;
name|long
name|lastMsg
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|stopRequested
operator|.
name|get
argument_list|()
condition|)
block|{
try|try
block|{
name|this
operator|.
name|requestCount
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|serverInfo
operator|.
name|setLoad
argument_list|(
operator|new
name|HServerLoad
argument_list|(
literal|0
argument_list|,
name|onlineRegions
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|this
operator|.
name|hbaseMaster
operator|.
name|regionServerStartup
argument_list|(
name|serverInfo
argument_list|)
expr_stmt|;
name|lastMsg
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Done telling master we are up"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"error telling master we are up"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|this
operator|.
name|sleeper
operator|.
name|sleep
argument_list|(
name|lastMsg
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/** Add to the outbound message buffer */
specifier|private
name|void
name|reportOpen
parameter_list|(
name|HRegionInfo
name|region
parameter_list|)
block|{
name|outboundMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|MSG_REPORT_OPEN
argument_list|,
name|region
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Add to the outbound message buffer */
specifier|private
name|void
name|reportClose
parameter_list|(
name|HRegionInfo
name|region
parameter_list|)
block|{
name|outboundMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|MSG_REPORT_CLOSE
argument_list|,
name|region
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add to the outbound message buffer    *     * When a region splits, we need to tell the master that there are two new     * regions that need to be assigned.    *     * We do not need to inform the master about the old region, because we've    * updated the meta or root regions, and the master will pick that up on its    * next rescan of the root or meta tables.    */
name|void
name|reportSplit
parameter_list|(
name|HRegionInfo
name|oldRegion
parameter_list|,
name|HRegionInfo
name|newRegionA
parameter_list|,
name|HRegionInfo
name|newRegionB
parameter_list|)
block|{
name|outboundMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|MSG_REPORT_SPLIT
argument_list|,
name|oldRegion
argument_list|)
argument_list|)
expr_stmt|;
name|outboundMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|MSG_REPORT_OPEN
argument_list|,
name|newRegionA
argument_list|)
argument_list|)
expr_stmt|;
name|outboundMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|MSG_REPORT_OPEN
argument_list|,
name|newRegionB
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//////////////////////////////////////////////////////////////////////////////
comment|// HMaster-given operations
comment|//////////////////////////////////////////////////////////////////////////////
specifier|private
specifier|static
class|class
name|ToDoEntry
block|{
name|int
name|tries
decl_stmt|;
name|HMsg
name|msg
decl_stmt|;
name|ToDoEntry
parameter_list|(
name|HMsg
name|msg
parameter_list|)
block|{
name|this
operator|.
name|tries
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|msg
operator|=
name|msg
expr_stmt|;
block|}
block|}
name|BlockingQueue
argument_list|<
name|ToDoEntry
argument_list|>
name|toDo
init|=
operator|new
name|LinkedBlockingQueue
argument_list|<
name|ToDoEntry
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Worker
name|worker
decl_stmt|;
specifier|private
name|Thread
name|workerThread
decl_stmt|;
comment|/** Thread that performs long running requests from the master */
class|class
name|Worker
implements|implements
name|Runnable
block|{
name|void
name|stop
parameter_list|()
block|{
synchronized|synchronized
init|(
name|toDo
init|)
block|{
name|toDo
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** {@inheritDoc} */
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
for|for
control|(
name|ToDoEntry
name|e
init|=
literal|null
init|;
operator|!
name|stopRequested
operator|.
name|get
argument_list|()
condition|;
control|)
block|{
try|try
block|{
name|e
operator|=
name|toDo
operator|.
name|poll
argument_list|(
name|threadWakeFrequency
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
comment|// continue
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|stopRequested
operator|.
name|get
argument_list|()
condition|)
block|{
continue|continue;
block|}
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
name|e
operator|.
name|msg
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|e
operator|.
name|msg
operator|.
name|getMsg
argument_list|()
condition|)
block|{
case|case
name|HMsg
operator|.
name|MSG_REGIONSERVER_QUIESCE
case|:
name|closeUserRegions
argument_list|()
expr_stmt|;
break|break;
case|case
name|HMsg
operator|.
name|MSG_REGION_OPEN
case|:
comment|// Open a region
name|openRegion
argument_list|(
name|e
operator|.
name|msg
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|HMsg
operator|.
name|MSG_REGION_CLOSE
case|:
comment|// Close a region
name|closeRegion
argument_list|(
name|e
operator|.
name|msg
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|HMsg
operator|.
name|MSG_REGION_CLOSE_WITHOUT_REPORT
case|:
comment|// Close a region, don't reply
name|closeRegion
argument_list|(
name|e
operator|.
name|msg
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Impossible state during msg processing.  Instruction: "
operator|+
name|e
operator|.
name|msg
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|ie
operator|=
name|RemoteExceptionHandler
operator|.
name|checkIOException
argument_list|(
name|ie
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|tries
operator|<
name|numRetries
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ie
argument_list|)
expr_stmt|;
name|e
operator|.
name|tries
operator|++
expr_stmt|;
try|try
block|{
name|toDo
operator|.
name|put
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Putting into msgQueue was "
operator|+
literal|"interrupted."
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"unable to process message: "
operator|+
name|e
operator|.
name|msg
operator|.
name|toString
argument_list|()
argument_list|,
name|ie
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkFileSystem
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Unhandled exception"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"worker thread exiting"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|void
name|openRegion
parameter_list|(
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
name|HRegion
name|region
init|=
name|onlineRegions
operator|.
name|get
argument_list|(
name|regionInfo
operator|.
name|getRegionName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|region
operator|=
operator|new
name|HRegion
argument_list|(
name|HTableDescriptor
operator|.
name|getTableDir
argument_list|(
name|rootDir
argument_list|,
name|regionInfo
operator|.
name|getTableDesc
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
name|this
operator|.
name|log
argument_list|,
name|this
operator|.
name|fs
argument_list|,
name|conf
argument_list|,
name|regionInfo
argument_list|,
literal|null
argument_list|,
name|this
operator|.
name|cacheFlusher
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"error opening region "
operator|+
name|regionInfo
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// Mark the region offline.
comment|// TODO: add an extra field in HRegionInfo to indicate that there is
comment|// an error. We can't do that now because that would be an incompatible
comment|// change that would require a migration
name|regionInfo
operator|.
name|setOffline
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|reportClose
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
return|return;
block|}
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|log
operator|.
name|setSequenceNumber
argument_list|(
name|region
operator|.
name|getMinSequenceId
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|onlineRegions
operator|.
name|put
argument_list|(
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|reportOpen
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|closeRegion
parameter_list|(
specifier|final
name|HRegionInfo
name|hri
parameter_list|,
specifier|final
name|boolean
name|reportWhenCompleted
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
name|HRegion
name|region
init|=
literal|null
decl_stmt|;
try|try
block|{
name|region
operator|=
name|onlineRegions
operator|.
name|remove
argument_list|(
name|hri
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|region
operator|!=
literal|null
condition|)
block|{
name|region
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|reportWhenCompleted
condition|)
block|{
name|reportClose
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Called either when the master tells us to restart or from stop() */
name|ArrayList
argument_list|<
name|HRegion
argument_list|>
name|closeAllRegions
parameter_list|()
block|{
name|ArrayList
argument_list|<
name|HRegion
argument_list|>
name|regionsToClose
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegion
argument_list|>
argument_list|()
decl_stmt|;
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|regionsToClose
operator|.
name|addAll
argument_list|(
name|onlineRegions
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|onlineRegions
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|HRegion
name|region
range|:
name|regionsToClose
control|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"closing region "
operator|+
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|region
operator|.
name|close
argument_list|(
name|abortRequested
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"error closing region "
operator|+
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|RemoteExceptionHandler
operator|.
name|checkIOException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|regionsToClose
return|;
block|}
comment|/** Called as the first stage of cluster shutdown. */
name|void
name|closeUserRegions
parameter_list|()
block|{
name|ArrayList
argument_list|<
name|HRegion
argument_list|>
name|regionsToClose
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegion
argument_list|>
argument_list|()
decl_stmt|;
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
synchronized|synchronized
init|(
name|onlineRegions
init|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Text
argument_list|,
name|HRegion
argument_list|>
argument_list|>
name|i
init|=
name|onlineRegions
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|Text
argument_list|,
name|HRegion
argument_list|>
name|e
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|HRegion
name|r
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|r
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
name|regionsToClose
operator|.
name|add
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|HRegion
name|region
range|:
name|regionsToClose
control|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"closing region "
operator|+
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|region
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"error closing region "
operator|+
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|RemoteExceptionHandler
operator|.
name|checkIOException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|quiesced
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|onlineRegions
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|outboundMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|MSG_REPORT_EXITING
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outboundMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|MSG_REPORT_QUIESCED
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//
comment|// HRegionInterface
comment|//
comment|/** {@inheritDoc} */
specifier|public
name|HRegionInfo
name|getRegionInfo
parameter_list|(
specifier|final
name|Text
name|regionName
parameter_list|)
throws|throws
name|NotServingRegionException
block|{
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return
name|getRegion
argument_list|(
name|regionName
argument_list|)
operator|.
name|getRegionInfo
argument_list|()
return|;
block|}
comment|/** {@inheritDoc} */
specifier|public
name|byte
index|[]
name|get
parameter_list|(
specifier|final
name|Text
name|regionName
parameter_list|,
specifier|final
name|Text
name|row
parameter_list|,
specifier|final
name|Text
name|column
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|getRegion
argument_list|(
name|regionName
argument_list|)
operator|.
name|get
argument_list|(
name|row
argument_list|,
name|column
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkFileSystem
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/** {@inheritDoc} */
specifier|public
name|byte
index|[]
index|[]
name|get
parameter_list|(
specifier|final
name|Text
name|regionName
parameter_list|,
specifier|final
name|Text
name|row
parameter_list|,
specifier|final
name|Text
name|column
parameter_list|,
specifier|final
name|int
name|numVersions
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|getRegion
argument_list|(
name|regionName
argument_list|)
operator|.
name|get
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|numVersions
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkFileSystem
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/** {@inheritDoc} */
specifier|public
name|byte
index|[]
index|[]
name|get
parameter_list|(
specifier|final
name|Text
name|regionName
parameter_list|,
specifier|final
name|Text
name|row
parameter_list|,
specifier|final
name|Text
name|column
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|int
name|numVersions
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|getRegion
argument_list|(
name|regionName
argument_list|)
operator|.
name|get
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|timestamp
argument_list|,
name|numVersions
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkFileSystem
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/** {@inheritDoc} */
specifier|public
name|HbaseMapWritable
name|getRow
parameter_list|(
specifier|final
name|Text
name|regionName
parameter_list|,
specifier|final
name|Text
name|row
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getRow
argument_list|(
name|regionName
argument_list|,
name|row
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|)
return|;
block|}
comment|/** {@inheritDoc} */
specifier|public
name|HbaseMapWritable
name|getRow
parameter_list|(
specifier|final
name|Text
name|regionName
parameter_list|,
specifier|final
name|Text
name|row
parameter_list|,
specifier|final
name|long
name|ts
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|HbaseMapWritable
name|result
init|=
operator|new
name|HbaseMapWritable
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
name|map
init|=
name|region
operator|.
name|getFull
argument_list|(
name|row
argument_list|,
name|ts
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
name|es
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|result
operator|.
name|put
argument_list|(
operator|new
name|HStoreKey
argument_list|(
name|row
argument_list|,
name|es
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|,
operator|new
name|ImmutableBytesWritable
argument_list|(
name|es
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkFileSystem
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/** {@inheritDoc} */
specifier|public
name|HbaseMapWritable
name|getClosestRowBefore
parameter_list|(
specifier|final
name|Text
name|regionName
parameter_list|,
specifier|final
name|Text
name|row
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getClosestRowBefore
argument_list|(
name|regionName
argument_list|,
name|row
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|)
return|;
block|}
comment|/** {@inheritDoc} */
specifier|public
name|HbaseMapWritable
name|getClosestRowBefore
parameter_list|(
specifier|final
name|Text
name|regionName
parameter_list|,
specifier|final
name|Text
name|row
parameter_list|,
specifier|final
name|long
name|ts
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
comment|// locate the region we're operating on
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|HbaseMapWritable
name|result
init|=
operator|new
name|HbaseMapWritable
argument_list|()
decl_stmt|;
comment|// ask the region for all the data
name|Map
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
name|map
init|=
name|region
operator|.
name|getClosestRowBefore
argument_list|(
name|row
argument_list|,
name|ts
argument_list|)
decl_stmt|;
comment|// convert to a MapWritable
if|if
condition|(
name|map
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
name|es
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|result
operator|.
name|put
argument_list|(
operator|new
name|HStoreKey
argument_list|(
name|row
argument_list|,
name|es
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|,
operator|new
name|ImmutableBytesWritable
argument_list|(
name|es
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkFileSystem
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/** {@inheritDoc} */
specifier|public
name|HbaseMapWritable
name|next
parameter_list|(
specifier|final
name|long
name|scannerId
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|String
name|scannerName
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
name|HScannerInterface
name|s
init|=
name|scanners
operator|.
name|get
argument_list|(
name|scannerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownScannerException
argument_list|(
literal|"Name: "
operator|+
name|scannerName
argument_list|)
throw|;
block|}
name|this
operator|.
name|leases
operator|.
name|renewLease
argument_list|(
name|scannerId
argument_list|,
name|scannerId
argument_list|)
expr_stmt|;
comment|// Collect values to be returned here
name|HbaseMapWritable
name|values
init|=
operator|new
name|HbaseMapWritable
argument_list|()
decl_stmt|;
name|HStoreKey
name|key
init|=
operator|new
name|HStoreKey
argument_list|()
decl_stmt|;
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
name|results
init|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|s
operator|.
name|next
argument_list|(
name|key
argument_list|,
name|results
argument_list|)
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
name|e
range|:
name|results
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|values
operator|.
name|put
argument_list|(
operator|new
name|HStoreKey
argument_list|(
name|key
operator|.
name|getRow
argument_list|()
argument_list|,
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|key
operator|.
name|getTimestamp
argument_list|()
argument_list|)
argument_list|,
operator|new
name|ImmutableBytesWritable
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|values
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Row has something in it. Return the value.
break|break;
block|}
comment|// No data for this row, go get another.
name|results
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
return|return
name|values
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkFileSystem
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/** {@inheritDoc} */
specifier|public
name|void
name|batchUpdate
parameter_list|(
name|Text
name|regionName
parameter_list|,
name|long
name|timestamp
parameter_list|,
name|BatchUpdate
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|this
operator|.
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
try|try
block|{
name|region
operator|.
name|batchUpdate
argument_list|(
name|timestamp
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkFileSystem
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|//
comment|// remote scanner interface
comment|//
comment|/** {@inheritDoc} */
specifier|public
name|long
name|openScanner
parameter_list|(
name|Text
name|regionName
parameter_list|,
name|Text
index|[]
name|cols
parameter_list|,
name|Text
name|firstRow
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|RowFilterInterface
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|r
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|long
name|scannerId
init|=
operator|-
literal|1L
decl_stmt|;
name|HScannerInterface
name|s
init|=
name|r
operator|.
name|getScanner
argument_list|(
name|cols
argument_list|,
name|firstRow
argument_list|,
name|timestamp
argument_list|,
name|filter
argument_list|)
decl_stmt|;
name|scannerId
operator|=
name|rand
operator|.
name|nextLong
argument_list|()
expr_stmt|;
name|String
name|scannerName
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|scanners
init|)
block|{
name|scanners
operator|.
name|put
argument_list|(
name|scannerName
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|leases
operator|.
name|createLease
argument_list|(
name|scannerId
argument_list|,
name|scannerId
argument_list|,
operator|new
name|ScannerListener
argument_list|(
name|scannerName
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|scannerId
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error opening scanner (fsOk: "
operator|+
name|this
operator|.
name|fsOk
operator|+
literal|")"
argument_list|,
name|RemoteExceptionHandler
operator|.
name|checkIOException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|checkFileSystem
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/** {@inheritDoc} */
specifier|public
name|void
name|close
parameter_list|(
specifier|final
name|long
name|scannerId
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|String
name|scannerName
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
name|HScannerInterface
name|s
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|scanners
init|)
block|{
name|s
operator|=
name|scanners
operator|.
name|remove
argument_list|(
name|scannerName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownScannerException
argument_list|(
name|scannerName
argument_list|)
throw|;
block|}
name|s
operator|.
name|close
argument_list|()
expr_stmt|;
name|this
operator|.
name|leases
operator|.
name|cancelLease
argument_list|(
name|scannerId
argument_list|,
name|scannerId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkFileSystem
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|HScannerInterface
argument_list|>
name|scanners
init|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|HScannerInterface
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|/**     * Instantiated as a scanner lease.    * If the lease times out, the scanner is closed    */
specifier|private
class|class
name|ScannerListener
implements|implements
name|LeaseListener
block|{
specifier|private
specifier|final
name|String
name|scannerName
decl_stmt|;
name|ScannerListener
parameter_list|(
specifier|final
name|String
name|n
parameter_list|)
block|{
name|this
operator|.
name|scannerName
operator|=
name|n
expr_stmt|;
block|}
comment|/** {@inheritDoc} */
specifier|public
name|void
name|leaseExpired
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Scanner "
operator|+
name|this
operator|.
name|scannerName
operator|+
literal|" lease expired"
argument_list|)
expr_stmt|;
name|HScannerInterface
name|s
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|scanners
init|)
block|{
name|s
operator|=
name|scanners
operator|.
name|remove
argument_list|(
name|this
operator|.
name|scannerName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|s
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Closing scanner"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|//
comment|// Methods that do the actual work for the remote API
comment|//
comment|/** {@inheritDoc} */
specifier|public
name|void
name|deleteAll
parameter_list|(
specifier|final
name|Text
name|regionName
parameter_list|,
specifier|final
name|Text
name|row
parameter_list|,
specifier|final
name|Text
name|column
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|region
operator|.
name|deleteAll
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
block|}
comment|/** {@inheritDoc} */
specifier|public
name|void
name|deleteAll
parameter_list|(
specifier|final
name|Text
name|regionName
parameter_list|,
specifier|final
name|Text
name|row
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|region
operator|.
name|deleteAll
argument_list|(
name|row
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
block|}
comment|/** {@inheritDoc} */
specifier|public
name|void
name|deleteFamily
parameter_list|(
name|Text
name|regionName
parameter_list|,
name|Text
name|row
parameter_list|,
name|Text
name|family
parameter_list|,
name|long
name|timestamp
parameter_list|)
throws|throws
name|IOException
block|{
name|getRegion
argument_list|(
name|regionName
argument_list|)
operator|.
name|deleteFamily
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return Info on this server.    */
specifier|public
name|HServerInfo
name|getServerInfo
parameter_list|()
block|{
return|return
name|this
operator|.
name|serverInfo
return|;
block|}
comment|/**    * @return Immutable list of this servers regions.    */
specifier|public
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|HRegion
argument_list|>
name|getOnlineRegions
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableSortedMap
argument_list|(
name|this
operator|.
name|onlineRegions
argument_list|)
return|;
block|}
comment|/** @return the request count */
specifier|public
name|AtomicInteger
name|getRequestCount
parameter_list|()
block|{
return|return
name|this
operator|.
name|requestCount
return|;
block|}
comment|/** @return reference to CacheFlushListener */
specifier|public
name|CacheFlushListener
name|getCacheFlushListener
parameter_list|()
block|{
return|return
name|this
operator|.
name|cacheFlusher
return|;
block|}
comment|/**     * Protected utility method for safely obtaining an HRegion handle.    * @param regionName Name of online {@link HRegion} to return    * @return {@link HRegion} for<code>regionName</code>    * @throws NotServingRegionException    */
specifier|protected
name|HRegion
name|getRegion
parameter_list|(
specifier|final
name|Text
name|regionName
parameter_list|)
throws|throws
name|NotServingRegionException
block|{
return|return
name|getRegion
argument_list|(
name|regionName
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**     * Protected utility method for safely obtaining an HRegion handle.    * @param regionName Name of online {@link HRegion} to return    * @param checkRetiringRegions Set true if we're to check retiring regions    * as well as online regions.    * @return {@link HRegion} for<code>regionName</code>    * @throws NotServingRegionException    */
specifier|protected
name|HRegion
name|getRegion
parameter_list|(
specifier|final
name|Text
name|regionName
parameter_list|,
specifier|final
name|boolean
name|checkRetiringRegions
parameter_list|)
throws|throws
name|NotServingRegionException
block|{
name|HRegion
name|region
init|=
literal|null
decl_stmt|;
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|region
operator|=
name|onlineRegions
operator|.
name|get
argument_list|(
name|regionName
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|==
literal|null
operator|&&
name|checkRetiringRegions
condition|)
block|{
name|region
operator|=
name|this
operator|.
name|retiringRegions
operator|.
name|get
argument_list|(
name|regionName
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|region
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found region "
operator|+
name|regionName
operator|+
literal|" in retiringRegions"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|region
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NotServingRegionException
argument_list|(
name|regionName
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|region
return|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Called to verify that this server is up and running.    *     * @throws IOException    */
specifier|private
name|void
name|checkOpen
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|stopRequested
operator|.
name|get
argument_list|()
operator|||
name|this
operator|.
name|abortRequested
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Server not running"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|fsOk
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"File system not available"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Checks to see if the file system is still accessible.    * If not, sets abortRequested and stopRequested    *     * @return false if file system is not available    */
specifier|protected
name|boolean
name|checkFileSystem
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|fsOk
condition|)
block|{
try|try
block|{
if|if
condition|(
name|fs
operator|!=
literal|null
operator|&&
operator|!
name|FSUtils
operator|.
name|isFileSystemAvailable
argument_list|(
name|fs
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Shutting down HRegionServer: file system not available"
argument_list|)
expr_stmt|;
name|this
operator|.
name|abortRequested
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|stopRequested
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|fsOk
operator|=
literal|false
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed get of filesystem"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Shutting down HRegionServer: file system not available"
argument_list|)
expr_stmt|;
name|this
operator|.
name|abortRequested
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|stopRequested
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|fsOk
operator|=
literal|false
expr_stmt|;
block|}
block|}
return|return
name|this
operator|.
name|fsOk
return|;
block|}
comment|/**    * @return Returns list of non-closed regions hosted on this server.  If no    * regions to check, returns an empty list.    */
specifier|protected
name|Set
argument_list|<
name|HRegion
argument_list|>
name|getRegionsToCheck
parameter_list|()
block|{
name|HashSet
argument_list|<
name|HRegion
argument_list|>
name|regionsToCheck
init|=
operator|new
name|HashSet
argument_list|<
name|HRegion
argument_list|>
argument_list|()
decl_stmt|;
comment|//TODO: is this locking necessary?
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|regionsToCheck
operator|.
name|addAll
argument_list|(
name|this
operator|.
name|onlineRegions
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// Purge closed regions.
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|HRegion
argument_list|>
name|i
init|=
name|regionsToCheck
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|HRegion
name|r
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|isClosed
argument_list|()
condition|)
block|{
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|regionsToCheck
return|;
block|}
comment|/** {@inheritDoc} */
specifier|public
name|long
name|getProtocolVersion
parameter_list|(
specifier|final
name|String
name|protocol
parameter_list|,
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|final
name|long
name|clientVersion
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|HRegionInterface
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|HRegionInterface
operator|.
name|versionID
return|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown protocol to name node: "
operator|+
name|protocol
argument_list|)
throw|;
block|}
comment|//
comment|// Main program and support routines
comment|//
specifier|private
specifier|static
name|void
name|printUsageAndExit
parameter_list|()
block|{
name|printUsageAndExit
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|printUsageAndExit
parameter_list|(
specifier|final
name|String
name|message
parameter_list|)
block|{
if|if
condition|(
name|message
operator|!=
literal|null
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Usage: java "
operator|+
literal|"org.apache.hbase.HRegionServer [--bind=hostname:port] start"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Do class main.    * @param args    * @param regionServerClass HRegionServer to instantiate.    */
specifier|protected
specifier|static
name|void
name|doMain
parameter_list|(
specifier|final
name|String
index|[]
name|args
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|HRegionServer
argument_list|>
name|regionServerClass
parameter_list|)
block|{
if|if
condition|(
name|args
operator|.
name|length
operator|<
literal|1
condition|)
block|{
name|printUsageAndExit
argument_list|()
expr_stmt|;
block|}
name|Configuration
name|conf
init|=
operator|new
name|HBaseConfiguration
argument_list|()
decl_stmt|;
comment|// Process command-line args. TODO: Better cmd-line processing
comment|// (but hopefully something not as painful as cli options).
specifier|final
name|String
name|addressArgKey
init|=
literal|"--bind="
decl_stmt|;
for|for
control|(
name|String
name|cmd
range|:
name|args
control|)
block|{
if|if
condition|(
name|cmd
operator|.
name|startsWith
argument_list|(
name|addressArgKey
argument_list|)
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|REGIONSERVER_ADDRESS
argument_list|,
name|cmd
operator|.
name|substring
argument_list|(
name|addressArgKey
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|cmd
operator|.
name|equals
argument_list|(
literal|"start"
argument_list|)
condition|)
block|{
try|try
block|{
comment|// If 'local', don't start a region server here.  Defer to
comment|// LocalHBaseCluster.  It manages 'local' clusters.
if|if
condition|(
name|LocalHBaseCluster
operator|.
name|isLocal
argument_list|(
name|conf
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Not starting a distinct region server because "
operator|+
literal|"hbase.master is set to 'local' mode"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Constructor
argument_list|<
name|?
extends|extends
name|HRegionServer
argument_list|>
name|c
init|=
name|regionServerClass
operator|.
name|getConstructor
argument_list|(
name|HBaseConfiguration
operator|.
name|class
argument_list|)
decl_stmt|;
name|HRegionServer
name|hrs
init|=
name|c
operator|.
name|newInstance
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Thread
name|t
init|=
operator|new
name|Thread
argument_list|(
name|hrs
argument_list|)
decl_stmt|;
name|t
operator|.
name|setName
argument_list|(
literal|"regionserver"
operator|+
name|hrs
operator|.
name|server
operator|.
name|getListenerAddress
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Can not start region server because "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|cmd
operator|.
name|equals
argument_list|(
literal|"stop"
argument_list|)
condition|)
block|{
name|printUsageAndExit
argument_list|(
literal|"To shutdown the regionserver run "
operator|+
literal|"bin/hbase-daemon.sh stop regionserver or send a kill signal to"
operator|+
literal|"the regionserver pid"
argument_list|)
expr_stmt|;
block|}
comment|// Print out usage if we get to here.
name|printUsageAndExit
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * @param args    */
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|doMain
argument_list|(
name|args
argument_list|,
name|HRegionServer
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

