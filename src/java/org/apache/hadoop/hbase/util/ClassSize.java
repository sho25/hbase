begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2009 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|HeapSize
import|;
end_import

begin_comment
comment|/**  * Class for determining the "size" of a class, an attempt to calculate the  * actual bytes that an object of this class will occupy in memory  *   * The core of this class is taken from the Derby project  */
end_comment

begin_class
specifier|public
class|class
name|ClassSize
block|{
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ClassSize
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|int
name|refSize
decl_stmt|;
specifier|private
name|int
name|minObjectSize
decl_stmt|;
comment|/**    * Constructor    * @throws Exception    */
specifier|public
name|ClassSize
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Figure out whether this is a 32 or 64 bit machine.
name|Runtime
name|runtime
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
decl_stmt|;
name|int
name|loops
init|=
literal|10
decl_stmt|;
name|int
name|sz
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|loops
condition|;
name|i
operator|++
control|)
block|{
name|cleaner
argument_list|(
name|runtime
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|long
name|memBase
init|=
name|runtime
operator|.
name|totalMemory
argument_list|()
operator|-
name|runtime
operator|.
name|freeMemory
argument_list|()
decl_stmt|;
name|Object
index|[]
name|junk
init|=
operator|new
name|Object
index|[
literal|10000
index|]
decl_stmt|;
name|cleaner
argument_list|(
name|runtime
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|long
name|memUsed
init|=
name|runtime
operator|.
name|totalMemory
argument_list|()
operator|-
name|runtime
operator|.
name|freeMemory
argument_list|()
operator|-
name|memBase
decl_stmt|;
name|sz
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|memUsed
operator|+
name|junk
operator|.
name|length
operator|/
literal|2
operator|)
operator|/
name|junk
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|>
literal|0
condition|)
block|{
break|break;
block|}
block|}
name|refSize
operator|=
operator|(
literal|4
operator|>
name|sz
operator|)
condition|?
literal|4
else|:
name|sz
expr_stmt|;
name|minObjectSize
operator|=
literal|4
operator|*
name|refSize
expr_stmt|;
block|}
comment|/**    * The estimate of the size of a class instance depends on whether the JVM     * uses 32 or 64 bit addresses, that is it depends on the size of an object     * reference. It is a linear function of the size of a reference, e.g.    * 24 + 5*r where r is the size of a reference (usually 4 or 8 bytes).    *    * This method returns the coefficients of the linear function, e.g. {24, 5}    * in the above example.    *    * @param cl A class whose instance size is to be estimated    * @return an array of 3 integers. The first integer is the size of the     * primitives, the second the number of arrays and the third the number of    * references.    */
specifier|private
name|int
index|[]
name|getSizeCoefficients
parameter_list|(
name|Class
name|cl
parameter_list|,
name|boolean
name|debug
parameter_list|)
block|{
name|int
name|primitives
init|=
literal|0
decl_stmt|;
name|int
name|arrays
init|=
literal|0
decl_stmt|;
name|int
name|references
init|=
name|HeapSize
operator|.
name|OBJECT
operator|/
name|HeapSize
operator|.
name|REFERENCE
decl_stmt|;
for|for
control|(
init|;
literal|null
operator|!=
name|cl
condition|;
name|cl
operator|=
name|cl
operator|.
name|getSuperclass
argument_list|()
control|)
block|{
name|Field
index|[]
name|field
init|=
name|cl
operator|.
name|getDeclaredFields
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|field
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|field
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|Modifier
operator|.
name|isStatic
argument_list|(
name|field
index|[
name|i
index|]
operator|.
name|getModifiers
argument_list|()
argument_list|)
condition|)
block|{
name|Class
name|fieldClass
init|=
name|field
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|fieldClass
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|arrays
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|fieldClass
operator|.
name|isPrimitive
argument_list|()
condition|)
block|{
name|references
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|// Is simple primitive
name|String
name|name
init|=
name|fieldClass
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"int"
argument_list|)
operator|||
name|name
operator|.
name|equals
argument_list|(
literal|"I"
argument_list|)
condition|)
name|primitives
operator|+=
name|Bytes
operator|.
name|SIZEOF_INT
expr_stmt|;
elseif|else
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"long"
argument_list|)
operator|||
name|name
operator|.
name|equals
argument_list|(
literal|"J"
argument_list|)
condition|)
name|primitives
operator|+=
name|Bytes
operator|.
name|SIZEOF_LONG
expr_stmt|;
elseif|else
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"boolean"
argument_list|)
operator|||
name|name
operator|.
name|equals
argument_list|(
literal|"Z"
argument_list|)
condition|)
name|primitives
operator|+=
name|Bytes
operator|.
name|SIZEOF_BOOLEAN
expr_stmt|;
elseif|else
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"short"
argument_list|)
operator|||
name|name
operator|.
name|equals
argument_list|(
literal|"S"
argument_list|)
condition|)
name|primitives
operator|+=
name|Bytes
operator|.
name|SIZEOF_SHORT
expr_stmt|;
elseif|else
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"byte"
argument_list|)
operator|||
name|name
operator|.
name|equals
argument_list|(
literal|"B"
argument_list|)
condition|)
name|primitives
operator|+=
name|Bytes
operator|.
name|SIZEOF_BYTE
expr_stmt|;
elseif|else
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"char"
argument_list|)
operator|||
name|name
operator|.
name|equals
argument_list|(
literal|"C"
argument_list|)
condition|)
name|primitives
operator|+=
name|Bytes
operator|.
name|SIZEOF_CHAR
expr_stmt|;
elseif|else
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"float"
argument_list|)
operator|||
name|name
operator|.
name|equals
argument_list|(
literal|"F"
argument_list|)
condition|)
name|primitives
operator|+=
name|Bytes
operator|.
name|SIZEOF_FLOAT
expr_stmt|;
elseif|else
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"double"
argument_list|)
operator|||
name|name
operator|.
name|equals
argument_list|(
literal|"D"
argument_list|)
condition|)
name|primitives
operator|+=
name|Bytes
operator|.
name|SIZEOF_DOUBLE
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
comment|// Write out region name as string and its encoded name.
name|LOG
operator|.
name|debug
argument_list|(
name|field
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
operator|+
literal|"\n\t"
operator|+
name|field
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
return|return
operator|new
name|int
index|[]
block|{
name|primitives
block|,
name|arrays
block|,
name|references
block|}
return|;
block|}
comment|/**    * Estimate the static space taken up by a class instance given the     * coefficients returned by getSizeCoefficients.    *    * @param coeff the coefficients    *    * @return the size estimate, in bytes    */
specifier|private
name|long
name|estimateBaseFromCoefficients
parameter_list|(
name|int
index|[]
name|coeff
parameter_list|,
name|boolean
name|debug
parameter_list|)
block|{
name|int
name|size
init|=
name|coeff
index|[
literal|0
index|]
operator|+
operator|(
name|coeff
index|[
literal|1
index|]
operator|*
literal|4
operator|+
name|coeff
index|[
literal|2
index|]
operator|)
operator|*
name|refSize
decl_stmt|;
comment|// Round up to a multiple of 8
name|size
operator|=
operator|(
name|int
operator|)
name|alignSize
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
comment|// Write out region name as string and its encoded name.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Primitives "
operator|+
name|coeff
index|[
literal|0
index|]
operator|+
literal|", arrays "
operator|+
name|coeff
index|[
literal|1
index|]
operator|+
literal|", references(inlcuding "
operator|+
name|HeapSize
operator|.
name|OBJECT
operator|+
literal|", for object overhead) "
operator|+
name|coeff
index|[
literal|2
index|]
operator|+
literal|", refSize "
operator|+
name|refSize
operator|+
literal|", size "
operator|+
name|size
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|size
operator|<
name|minObjectSize
operator|)
condition|?
name|minObjectSize
else|:
name|size
return|;
block|}
comment|/**    * Estimate the static space taken up by the fields of a class. This includes     * the space taken up by by references (the pointer) but not by the referenced     * object. So the estimated size of an array field does not depend on the size     * of the array. Similarly the size of an object (reference) field does not     * depend on the object.    *    * @return the size estimate in bytes.    */
specifier|public
name|long
name|estimateBase
parameter_list|(
name|Class
name|cl
parameter_list|,
name|boolean
name|debug
parameter_list|)
block|{
return|return
name|estimateBaseFromCoefficients
argument_list|(
name|getSizeCoefficients
argument_list|(
name|cl
argument_list|,
name|debug
argument_list|)
argument_list|,
name|debug
argument_list|)
return|;
block|}
comment|/**    * Tries to clear all the memory used to estimate the reference size for the    * current JVM    * @param runtime    * @param i    * @throws Exception    */
specifier|private
name|void
name|cleaner
parameter_list|(
name|Runtime
name|runtime
parameter_list|,
name|int
name|i
parameter_list|)
throws|throws
name|Exception
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|i
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|runtime
operator|.
name|gc
argument_list|()
expr_stmt|;
name|runtime
operator|.
name|gc
argument_list|()
expr_stmt|;
name|runtime
operator|.
name|gc
argument_list|()
expr_stmt|;
name|runtime
operator|.
name|gc
argument_list|()
expr_stmt|;
name|runtime
operator|.
name|gc
argument_list|()
expr_stmt|;
name|runtime
operator|.
name|runFinalization
argument_list|()
expr_stmt|;
block|}
comment|/**    * Aligns a number to 8.    * @param num number to align to 8    * @return smallest number>= input that is a multiple of 8    */
specifier|public
specifier|static
name|long
name|alignSize
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|int
name|aligned
init|=
operator|(
name|num
operator|+
literal|7
operator|)
operator|/
literal|8
decl_stmt|;
name|aligned
operator|*=
literal|8
expr_stmt|;
return|return
name|aligned
return|;
block|}
block|}
end_class

end_unit

