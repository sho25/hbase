begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2006 The Apache Software Foundation  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|DataInputBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|retry
operator|.
name|RetryPolicies
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|retry
operator|.
name|RetryPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|retry
operator|.
name|RetryProxy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RPC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_comment
comment|/**  * HClient manages a connection to a single HRegionServer.  */
end_comment

begin_class
specifier|public
class|class
name|HClient
implements|implements
name|HConstants
block|{
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Text
index|[]
name|META_COLUMNS
init|=
block|{
name|COLUMN_FAMILY
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Text
index|[]
name|REGIONINFO
init|=
block|{
name|COL_REGIONINFO
block|}
decl_stmt|;
specifier|static
specifier|final
name|Text
name|EMPTY_START_ROW
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
name|long
name|pause
decl_stmt|;
name|int
name|numRetries
decl_stmt|;
specifier|private
name|HMasterInterface
name|master
decl_stmt|;
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
comment|/*    * Data structure that holds current location for a region and its info.    */
specifier|static
class|class
name|RegionLocation
block|{
name|HRegionInfo
name|regionInfo
decl_stmt|;
name|HServerAddress
name|serverAddress
decl_stmt|;
name|RegionLocation
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|,
name|HServerAddress
name|serverAddress
parameter_list|)
block|{
name|this
operator|.
name|regionInfo
operator|=
name|regionInfo
expr_stmt|;
name|this
operator|.
name|serverAddress
operator|=
name|serverAddress
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"address: "
operator|+
name|this
operator|.
name|serverAddress
operator|.
name|toString
argument_list|()
operator|+
literal|", regioninfo: "
operator|+
name|this
operator|.
name|regionInfo
return|;
block|}
block|}
comment|// Map tableName -> (Map startRow -> (HRegionInfo, HServerAddress)
specifier|private
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|RegionLocation
argument_list|>
argument_list|>
name|tablesToServers
decl_stmt|;
comment|// For the "current" table: Map startRow -> (HRegionInfo, HServerAddress)
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|RegionLocation
argument_list|>
name|tableServers
decl_stmt|;
comment|// Known region HServerAddress.toString() -> HRegionInterface
specifier|private
name|TreeMap
argument_list|<
name|String
argument_list|,
name|HRegionInterface
argument_list|>
name|servers
decl_stmt|;
comment|// For row mutation operations
name|Text
name|currentRegion
decl_stmt|;
name|HRegionInterface
name|currentServer
decl_stmt|;
name|Random
name|rand
decl_stmt|;
name|long
name|clientid
decl_stmt|;
comment|/**     * Creates a new HClient    * @param conf - Configuration object    */
specifier|public
name|HClient
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|pause
operator|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.client.pause"
argument_list|,
literal|30
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|this
operator|.
name|numRetries
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.client.retries.number"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|this
operator|.
name|master
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|tablesToServers
operator|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|RegionLocation
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|tableServers
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|servers
operator|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|HRegionInterface
argument_list|>
argument_list|()
expr_stmt|;
comment|// For row mutation operations
name|this
operator|.
name|currentRegion
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|currentServer
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|rand
operator|=
operator|new
name|Random
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|handleRemoteException
parameter_list|(
name|RemoteException
name|e
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|msg
init|=
name|e
operator|.
name|getMessage
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getClassName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"org.apache.hadoop.hbase.InvalidColumnNameException"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InvalidColumnNameException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|e
operator|.
name|getClassName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"org.apache.hadoop.hbase.LockException"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|LockException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|e
operator|.
name|getClassName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"org.apache.hadoop.hbase.MasterNotRunningException"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|MasterNotRunningException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|e
operator|.
name|getClassName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"org.apache.hadoop.hbase.NoServerForRegionException"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|NoServerForRegionException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|e
operator|.
name|getClassName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"org.apache.hadoop.hbase.NotServingRegionException"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|NotServingRegionException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|e
operator|.
name|getClassName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"org.apache.hadoop.hbase.TableNotDisabledException"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TableNotDisabledException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
comment|/* Find the address of the master and connect to it    */
specifier|private
name|void
name|checkMaster
parameter_list|()
throws|throws
name|MasterNotRunningException
block|{
if|if
condition|(
name|this
operator|.
name|master
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|this
operator|.
name|master
operator|==
literal|null
operator|&&
name|tries
operator|<
name|numRetries
condition|;
name|tries
operator|++
control|)
block|{
name|HServerAddress
name|masterLocation
init|=
operator|new
name|HServerAddress
argument_list|(
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
name|MASTER_ADDRESS
argument_list|,
name|DEFAULT_MASTER_ADDRESS
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|HMasterInterface
name|tryMaster
init|=
operator|(
name|HMasterInterface
operator|)
name|RPC
operator|.
name|getProxy
argument_list|(
name|HMasterInterface
operator|.
name|class
argument_list|,
name|HMasterInterface
operator|.
name|versionID
argument_list|,
name|masterLocation
operator|.
name|getInetSocketAddress
argument_list|()
argument_list|,
name|this
operator|.
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|tryMaster
operator|.
name|isMasterRunning
argument_list|()
condition|)
block|{
name|this
operator|.
name|master
operator|=
name|tryMaster
expr_stmt|;
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
comment|// This was our last chance - don't bother sleeping
break|break;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Attempt "
operator|+
name|tries
operator|+
literal|" of "
operator|+
name|this
operator|.
name|numRetries
operator|+
literal|" failed with<"
operator|+
name|e
operator|+
literal|">. Retrying after sleep of "
operator|+
name|this
operator|.
name|pause
argument_list|)
expr_stmt|;
block|}
comment|// We either cannot connect to master or it is not running. Sleep& retry
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|this
operator|.
name|pause
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// continue
block|}
block|}
if|if
condition|(
name|this
operator|.
name|master
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|MasterNotRunningException
argument_list|()
throw|;
block|}
block|}
comment|//////////////////////////////////////////////////////////////////////////////
comment|// Administrative methods
comment|//////////////////////////////////////////////////////////////////////////////
comment|/**    * @return - true if the master server is running    */
specifier|public
name|boolean
name|isMasterRunning
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|master
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|checkMaster
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MasterNotRunningException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Creates a new table    *     * @param desc table descriptor for table    *     * @throws IllegalArgumentException if the table name is reserved    * @throws MasterNotRunningException if master is not running    * @throws NoServerForRegionException if root region is not being served    * @throws IOException    */
specifier|public
specifier|synchronized
name|void
name|createTable
parameter_list|(
name|HTableDescriptor
name|desc
parameter_list|)
throws|throws
name|IOException
block|{
name|createTableAsync
argument_list|(
name|desc
argument_list|)
expr_stmt|;
comment|// Save the current table
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|RegionLocation
argument_list|>
name|oldServers
init|=
name|this
operator|.
name|tableServers
decl_stmt|;
try|try
block|{
comment|// Wait for new table to come on-line
name|findServersForTable
argument_list|(
name|desc
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|oldServers
operator|!=
literal|null
operator|&&
name|oldServers
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|// Restore old current table if there was one
name|this
operator|.
name|tableServers
operator|=
name|oldServers
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Creates a new table but does not block and wait for it to come online.    *     * @param desc table descriptor for table    *     * @throws IllegalArgumentException if the table name is reserved    * @throws MasterNotRunningException if master is not running    * @throws NoServerForRegionException if root region is not being served    * @throws IOException    */
specifier|public
specifier|synchronized
name|void
name|createTableAsync
parameter_list|(
name|HTableDescriptor
name|desc
parameter_list|)
throws|throws
name|IOException
block|{
name|checkReservedTableName
argument_list|(
name|desc
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|checkMaster
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|master
operator|.
name|createTable
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
name|handleRemoteException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Deletes a table    *     * @param tableName           - name of table to delete    * @throws IOException    */
specifier|public
specifier|synchronized
name|void
name|deleteTable
parameter_list|(
name|Text
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|checkReservedTableName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|checkMaster
argument_list|()
expr_stmt|;
name|RegionLocation
name|firstMetaServer
init|=
name|getFirstMetaServerForTable
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
try|try
block|{
name|this
operator|.
name|master
operator|.
name|deleteTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
name|handleRemoteException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|// Wait until first region is deleted
name|HRegionInterface
name|server
init|=
name|getHRegionConnection
argument_list|(
name|firstMetaServer
operator|.
name|serverAddress
argument_list|)
decl_stmt|;
name|DataInputBuffer
name|inbuf
init|=
operator|new
name|DataInputBuffer
argument_list|()
decl_stmt|;
name|HRegionInfo
name|info
init|=
operator|new
name|HRegionInfo
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
name|numRetries
condition|;
name|tries
operator|++
control|)
block|{
name|long
name|scannerId
init|=
operator|-
literal|1L
decl_stmt|;
try|try
block|{
name|scannerId
operator|=
name|server
operator|.
name|openScanner
argument_list|(
name|firstMetaServer
operator|.
name|regionInfo
operator|.
name|regionName
argument_list|,
name|REGIONINFO
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
name|KeyedData
index|[]
name|values
init|=
name|server
operator|.
name|next
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
if|if
condition|(
name|values
operator|==
literal|null
operator|||
name|values
operator|.
name|length
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|boolean
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|values
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|values
index|[
name|j
index|]
operator|.
name|getKey
argument_list|()
operator|.
name|getColumn
argument_list|()
operator|.
name|equals
argument_list|(
name|COL_REGIONINFO
argument_list|)
condition|)
block|{
name|inbuf
operator|.
name|reset
argument_list|(
name|values
index|[
name|j
index|]
operator|.
name|getData
argument_list|()
argument_list|,
name|values
index|[
name|j
index|]
operator|.
name|getData
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|info
operator|.
name|readFields
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|tableDesc
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
break|break;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|scannerId
operator|!=
operator|-
literal|1L
condition|)
block|{
try|try
block|{
name|server
operator|.
name|close
argument_list|(
name|scannerId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|pause
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// continue
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"table "
operator|+
name|tableName
operator|+
literal|" deleted"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a column to an existing table    *     * @param tableName   - name of the table to add column to    * @param column      - column descriptor of column to be added    * @throws IOException    */
specifier|public
specifier|synchronized
name|void
name|addColumn
parameter_list|(
name|Text
name|tableName
parameter_list|,
name|HColumnDescriptor
name|column
parameter_list|)
throws|throws
name|IOException
block|{
name|checkReservedTableName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|checkMaster
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|master
operator|.
name|addColumn
argument_list|(
name|tableName
argument_list|,
name|column
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
name|handleRemoteException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Delete a column from a table    *     * @param tableName           - name of table    * @param columnName          - name of column to be deleted    * @throws IOException    */
specifier|public
specifier|synchronized
name|void
name|deleteColumn
parameter_list|(
name|Text
name|tableName
parameter_list|,
name|Text
name|columnName
parameter_list|)
throws|throws
name|IOException
block|{
name|checkReservedTableName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|checkMaster
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|master
operator|.
name|deleteColumn
argument_list|(
name|tableName
argument_list|,
name|columnName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
name|handleRemoteException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Brings a table on-line (enables it)    *     * @param tableName   - name of the table    * @throws IOException    */
specifier|public
specifier|synchronized
name|void
name|enableTable
parameter_list|(
name|Text
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|checkReservedTableName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|checkMaster
argument_list|()
expr_stmt|;
name|RegionLocation
name|firstMetaServer
init|=
name|getFirstMetaServerForTable
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
try|try
block|{
name|this
operator|.
name|master
operator|.
name|enableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
name|handleRemoteException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|// Wait until first region is enabled
name|HRegionInterface
name|server
init|=
name|getHRegionConnection
argument_list|(
name|firstMetaServer
operator|.
name|serverAddress
argument_list|)
decl_stmt|;
name|DataInputBuffer
name|inbuf
init|=
operator|new
name|DataInputBuffer
argument_list|()
decl_stmt|;
name|HRegionInfo
name|info
init|=
operator|new
name|HRegionInfo
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
name|numRetries
condition|;
name|tries
operator|++
control|)
block|{
name|int
name|valuesfound
init|=
literal|0
decl_stmt|;
name|long
name|scannerId
init|=
operator|-
literal|1L
decl_stmt|;
try|try
block|{
name|scannerId
operator|=
name|server
operator|.
name|openScanner
argument_list|(
name|firstMetaServer
operator|.
name|regionInfo
operator|.
name|regionName
argument_list|,
name|REGIONINFO
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
name|boolean
name|isenabled
init|=
literal|false
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|KeyedData
index|[]
name|values
init|=
name|server
operator|.
name|next
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
if|if
condition|(
name|values
operator|==
literal|null
operator|||
name|values
operator|.
name|length
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|valuesfound
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|(
literal|"table "
operator|+
name|tableName
operator|+
literal|" not found"
argument_list|)
throw|;
block|}
break|break;
block|}
name|valuesfound
operator|+=
literal|1
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|values
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|values
index|[
name|j
index|]
operator|.
name|getKey
argument_list|()
operator|.
name|getColumn
argument_list|()
operator|.
name|equals
argument_list|(
name|COL_REGIONINFO
argument_list|)
condition|)
block|{
name|inbuf
operator|.
name|reset
argument_list|(
name|values
index|[
name|j
index|]
operator|.
name|getData
argument_list|()
argument_list|,
name|values
index|[
name|j
index|]
operator|.
name|getData
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|info
operator|.
name|readFields
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
name|isenabled
operator|=
operator|!
name|info
operator|.
name|offLine
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|isenabled
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|isenabled
condition|)
block|{
break|break;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|scannerId
operator|!=
operator|-
literal|1L
condition|)
block|{
try|try
block|{
name|server
operator|.
name|close
argument_list|(
name|scannerId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sleep. Waiting for first region to be enabled from "
operator|+
name|tableName
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|pause
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// continue
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Wake. Waiting for first region to be enabled from "
operator|+
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Enabled table "
operator|+
name|tableName
argument_list|)
expr_stmt|;
block|}
comment|/**    * Disables a table (takes it off-line) If it is being served, the master    * will tell the servers to stop serving it.    *     * @param tableName           - name of table    * @throws IOException    */
specifier|public
specifier|synchronized
name|void
name|disableTable
parameter_list|(
name|Text
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|checkReservedTableName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|checkMaster
argument_list|()
expr_stmt|;
name|RegionLocation
name|firstMetaServer
init|=
name|getFirstMetaServerForTable
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
try|try
block|{
name|this
operator|.
name|master
operator|.
name|disableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
name|handleRemoteException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|// Wait until first region is disabled
name|HRegionInterface
name|server
init|=
name|getHRegionConnection
argument_list|(
name|firstMetaServer
operator|.
name|serverAddress
argument_list|)
decl_stmt|;
name|DataInputBuffer
name|inbuf
init|=
operator|new
name|DataInputBuffer
argument_list|()
decl_stmt|;
name|HRegionInfo
name|info
init|=
operator|new
name|HRegionInfo
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
name|numRetries
condition|;
name|tries
operator|++
control|)
block|{
name|int
name|valuesfound
init|=
literal|0
decl_stmt|;
name|long
name|scannerId
init|=
operator|-
literal|1L
decl_stmt|;
try|try
block|{
name|scannerId
operator|=
name|server
operator|.
name|openScanner
argument_list|(
name|firstMetaServer
operator|.
name|regionInfo
operator|.
name|regionName
argument_list|,
name|REGIONINFO
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
name|boolean
name|disabled
init|=
literal|false
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|KeyedData
index|[]
name|values
init|=
name|server
operator|.
name|next
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
if|if
condition|(
name|values
operator|==
literal|null
operator|||
name|values
operator|.
name|length
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|valuesfound
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|(
literal|"table "
operator|+
name|tableName
operator|+
literal|" not found"
argument_list|)
throw|;
block|}
break|break;
block|}
name|valuesfound
operator|+=
literal|1
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|values
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|values
index|[
name|j
index|]
operator|.
name|getKey
argument_list|()
operator|.
name|getColumn
argument_list|()
operator|.
name|equals
argument_list|(
name|COL_REGIONINFO
argument_list|)
condition|)
block|{
name|inbuf
operator|.
name|reset
argument_list|(
name|values
index|[
name|j
index|]
operator|.
name|getData
argument_list|()
argument_list|,
name|values
index|[
name|j
index|]
operator|.
name|getData
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|info
operator|.
name|readFields
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
name|disabled
operator|=
name|info
operator|.
name|offLine
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|disabled
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|disabled
condition|)
block|{
break|break;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|scannerId
operator|!=
operator|-
literal|1L
condition|)
block|{
try|try
block|{
name|server
operator|.
name|close
argument_list|(
name|scannerId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sleep. Waiting for first region to be disabled from "
operator|+
name|tableName
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|pause
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// continue
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Wake. Waiting for first region to be disabled from "
operator|+
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Disabled table "
operator|+
name|tableName
argument_list|)
expr_stmt|;
block|}
comment|/**     * Shuts down the HBase instance     * @throws IOException    */
specifier|public
specifier|synchronized
name|void
name|shutdown
parameter_list|()
throws|throws
name|IOException
block|{
name|checkMaster
argument_list|()
expr_stmt|;
name|this
operator|.
name|master
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
comment|/*    * Verifies that the specified table name is not a reserved name    * @param tableName - the table name to be checked    * @throws IllegalArgumentException - if the table name is reserved    */
specifier|private
name|void
name|checkReservedTableName
parameter_list|(
name|Text
name|tableName
parameter_list|)
block|{
if|if
condition|(
name|tableName
operator|.
name|equals
argument_list|(
name|ROOT_TABLE_NAME
argument_list|)
operator|||
name|tableName
operator|.
name|equals
argument_list|(
name|META_TABLE_NAME
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|tableName
operator|+
literal|" is a reserved table name"
argument_list|)
throw|;
block|}
block|}
specifier|private
name|RegionLocation
name|getFirstMetaServerForTable
parameter_list|(
name|Text
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|RegionLocation
argument_list|>
name|metaservers
init|=
name|findMetaServersForTable
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
return|return
name|metaservers
operator|.
name|get
argument_list|(
name|metaservers
operator|.
name|firstKey
argument_list|()
argument_list|)
return|;
block|}
comment|//////////////////////////////////////////////////////////////////////////////
comment|// Client API
comment|//////////////////////////////////////////////////////////////////////////////
comment|/**    * Loads information so that a table can be manipulated.    *     * @param tableName - the table to be located    * @throws IOException - if the table can not be located after retrying    */
specifier|public
specifier|synchronized
name|void
name|openTable
parameter_list|(
name|Text
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|tableName
operator|==
literal|null
operator|||
name|tableName
operator|.
name|getLength
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"table name cannot be null or zero length"
argument_list|)
throw|;
block|}
name|this
operator|.
name|tableServers
operator|=
name|tablesToServers
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|tableServers
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No servers for "
operator|+
name|tableName
operator|+
literal|". Doing a find..."
argument_list|)
expr_stmt|;
block|}
comment|// We don't know where the table is.
comment|// Load the information from meta.
name|this
operator|.
name|tableServers
operator|=
name|findServersForTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Locates a table by searching the META region    *     * @param tableName - name of table to find servers for    * @return - map of first row to table info for all regions in the table    * @throws IOException    */
specifier|private
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|RegionLocation
argument_list|>
name|findServersForTable
parameter_list|(
name|Text
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|RegionLocation
argument_list|>
name|servers
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|tableName
operator|.
name|equals
argument_list|(
name|ROOT_TABLE_NAME
argument_list|)
condition|)
block|{
name|servers
operator|=
name|locateRootRegion
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tableName
operator|.
name|equals
argument_list|(
name|META_TABLE_NAME
argument_list|)
condition|)
block|{
name|servers
operator|=
name|loadMetaFromRoot
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|servers
operator|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|RegionLocation
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|RegionLocation
name|t
range|:
name|findMetaServersForTable
argument_list|(
name|tableName
argument_list|)
operator|.
name|values
argument_list|()
control|)
block|{
name|servers
operator|.
name|putAll
argument_list|(
name|scanOneMetaRegion
argument_list|(
name|t
argument_list|,
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|tablesToServers
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|servers
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Text
argument_list|,
name|RegionLocation
argument_list|>
name|e
range|:
name|servers
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Server "
operator|+
name|e
operator|.
name|getKey
argument_list|()
operator|+
literal|" is serving: "
operator|+
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|servers
return|;
block|}
comment|/*    * Finds the meta servers that contain information about the specified table    * @param tableName - the name of the table to get information about    * @return - returns a SortedMap of the meta servers    * @throws IOException    */
specifier|private
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|RegionLocation
argument_list|>
name|findMetaServersForTable
parameter_list|(
specifier|final
name|Text
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|RegionLocation
argument_list|>
name|metaServers
init|=
name|this
operator|.
name|tablesToServers
operator|.
name|get
argument_list|(
name|META_TABLE_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|metaServers
operator|==
literal|null
condition|)
block|{
comment|// Don't know where the meta is
name|metaServers
operator|=
name|loadMetaFromRoot
argument_list|()
expr_stmt|;
block|}
name|Text
name|firstMetaRegion
init|=
operator|(
name|metaServers
operator|.
name|containsKey
argument_list|(
name|tableName
argument_list|)
operator|)
condition|?
name|tableName
else|:
name|metaServers
operator|.
name|headMap
argument_list|(
name|tableName
argument_list|)
operator|.
name|lastKey
argument_list|()
decl_stmt|;
return|return
name|metaServers
operator|.
name|tailMap
argument_list|(
name|firstMetaRegion
argument_list|)
return|;
block|}
comment|/*    * Load the meta table from the root table.    *     * @return map of first row to TableInfo for all meta regions    * @throws IOException    */
specifier|private
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|RegionLocation
argument_list|>
name|loadMetaFromRoot
parameter_list|()
throws|throws
name|IOException
block|{
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|RegionLocation
argument_list|>
name|rootRegion
init|=
name|this
operator|.
name|tablesToServers
operator|.
name|get
argument_list|(
name|ROOT_TABLE_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|rootRegion
operator|==
literal|null
condition|)
block|{
name|rootRegion
operator|=
name|locateRootRegion
argument_list|()
expr_stmt|;
block|}
return|return
name|scanRoot
argument_list|(
name|rootRegion
operator|.
name|get
argument_list|(
name|rootRegion
operator|.
name|firstKey
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/*    * Repeatedly try to find the root region by asking the master for where it is    * @return TreeMap<Text, TableInfo> for root regin if found    * @throws NoServerForRegionException - if the root region can not be located    * after retrying    * @throws IOException     */
specifier|private
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|RegionLocation
argument_list|>
name|locateRootRegion
parameter_list|()
throws|throws
name|IOException
block|{
name|checkMaster
argument_list|()
expr_stmt|;
name|HServerAddress
name|rootRegionLocation
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
name|numRetries
condition|;
name|tries
operator|++
control|)
block|{
name|int
name|localTimeouts
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|rootRegionLocation
operator|==
literal|null
operator|&&
name|localTimeouts
operator|<
name|numRetries
condition|)
block|{
name|rootRegionLocation
operator|=
name|master
operator|.
name|findRootRegion
argument_list|()
expr_stmt|;
if|if
condition|(
name|rootRegionLocation
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sleeping. Waiting for root region."
argument_list|)
expr_stmt|;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
name|this
operator|.
name|pause
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Wake. Retry finding root region."
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{
comment|// continue
block|}
name|localTimeouts
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rootRegionLocation
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoServerForRegionException
argument_list|(
literal|"Timed out trying to locate root region"
argument_list|)
throw|;
block|}
name|HRegionInterface
name|rootRegion
init|=
name|getHRegionConnection
argument_list|(
name|rootRegionLocation
argument_list|)
decl_stmt|;
try|try
block|{
name|rootRegion
operator|.
name|getRegionInfo
argument_list|(
name|HGlobals
operator|.
name|rootRegionInfo
operator|.
name|regionName
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|NotServingRegionException
name|e
parameter_list|)
block|{
if|if
condition|(
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
comment|// Don't bother sleeping. We've run out of retries.
break|break;
block|}
comment|// Sleep and retry finding root region.
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Root region location changed. Sleeping."
argument_list|)
expr_stmt|;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
name|this
operator|.
name|pause
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Wake. Retry finding root region."
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{
comment|// continue
block|}
block|}
name|rootRegionLocation
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|rootRegionLocation
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoServerForRegionException
argument_list|(
literal|"unable to locate root region server"
argument_list|)
throw|;
block|}
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|RegionLocation
argument_list|>
name|rootServer
init|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|RegionLocation
argument_list|>
argument_list|()
decl_stmt|;
name|rootServer
operator|.
name|put
argument_list|(
name|EMPTY_START_ROW
argument_list|,
operator|new
name|RegionLocation
argument_list|(
name|HGlobals
operator|.
name|rootRegionInfo
argument_list|,
name|rootRegionLocation
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|tablesToServers
operator|.
name|put
argument_list|(
name|ROOT_TABLE_NAME
argument_list|,
name|rootServer
argument_list|)
expr_stmt|;
return|return
name|rootServer
return|;
block|}
comment|/*     * Scans the root region to find all the meta regions    * @return - TreeMap of meta region servers    * @throws IOException    */
specifier|private
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|RegionLocation
argument_list|>
name|scanRoot
parameter_list|(
name|RegionLocation
name|rootRegion
parameter_list|)
throws|throws
name|IOException
block|{
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|RegionLocation
argument_list|>
name|metaservers
init|=
name|scanOneMetaRegion
argument_list|(
name|rootRegion
argument_list|,
name|META_TABLE_NAME
argument_list|)
decl_stmt|;
name|this
operator|.
name|tablesToServers
operator|.
name|put
argument_list|(
name|META_TABLE_NAME
argument_list|,
name|metaservers
argument_list|)
expr_stmt|;
return|return
name|metaservers
return|;
block|}
comment|/*    * Scans a single meta region    * @param t the meta region we're going to scan    * @param tableName the name of the table we're looking for    * @return returns a map of startingRow to TableInfo    * @throws RegionNotFoundException - if table does not exist    * @throws IllegalStateException - if table is offline    * @throws NoServerForRegionException - if table can not be found after retrying    * @throws IOException     */
specifier|private
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|RegionLocation
argument_list|>
name|scanOneMetaRegion
parameter_list|(
specifier|final
name|RegionLocation
name|t
parameter_list|,
specifier|final
name|Text
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegionInterface
name|server
init|=
name|getHRegionConnection
argument_list|(
name|t
operator|.
name|serverAddress
argument_list|)
decl_stmt|;
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|RegionLocation
argument_list|>
name|servers
init|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|RegionLocation
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|servers
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
name|tries
operator|<
name|this
operator|.
name|numRetries
condition|;
name|tries
operator|++
control|)
block|{
name|long
name|scannerId
init|=
operator|-
literal|1L
decl_stmt|;
try|try
block|{
name|scannerId
operator|=
name|server
operator|.
name|openScanner
argument_list|(
name|t
operator|.
name|regionInfo
operator|.
name|regionName
argument_list|,
name|META_COLUMNS
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
name|DataInputBuffer
name|inbuf
init|=
operator|new
name|DataInputBuffer
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|HRegionInfo
name|regionInfo
init|=
literal|null
decl_stmt|;
name|String
name|serverAddress
init|=
literal|null
decl_stmt|;
name|KeyedData
index|[]
name|values
init|=
name|server
operator|.
name|next
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
if|if
condition|(
name|values
operator|.
name|length
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|servers
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// If we didn't find any servers then the table does not exist
throw|throw
operator|new
name|RegionNotFoundException
argument_list|(
literal|"table '"
operator|+
name|tableName
operator|+
literal|"' does not exist in "
operator|+
name|t
argument_list|)
throw|;
block|}
comment|// We found at least one server for the table and now we're done.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found "
operator|+
name|servers
operator|.
name|size
argument_list|()
operator|+
literal|" server(s) for "
operator|+
literal|"location: "
operator|+
name|t
operator|+
literal|" for tablename "
operator|+
name|tableName
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|byte
index|[]
name|bytes
init|=
literal|null
decl_stmt|;
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
name|results
init|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|results
operator|.
name|put
argument_list|(
name|values
index|[
name|i
index|]
operator|.
name|getKey
argument_list|()
operator|.
name|getColumn
argument_list|()
argument_list|,
name|values
index|[
name|i
index|]
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|regionInfo
operator|=
operator|new
name|HRegionInfo
argument_list|()
expr_stmt|;
name|bytes
operator|=
name|results
operator|.
name|get
argument_list|(
name|COL_REGIONINFO
argument_list|)
expr_stmt|;
name|inbuf
operator|.
name|reset
argument_list|(
name|bytes
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|regionInfo
operator|.
name|readFields
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|regionInfo
operator|.
name|tableDesc
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
comment|// We're done
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found "
operator|+
name|tableName
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|regionInfo
operator|.
name|offLine
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"table offline: "
operator|+
name|tableName
argument_list|)
throw|;
block|}
name|bytes
operator|=
name|results
operator|.
name|get
argument_list|(
name|COL_SERVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|null
operator|||
name|bytes
operator|.
name|length
operator|==
literal|0
condition|)
block|{
comment|// We need to rescan because the table we want is unassigned.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"no server address for "
operator|+
name|regionInfo
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|servers
operator|.
name|clear
argument_list|()
expr_stmt|;
break|break;
block|}
name|serverAddress
operator|=
operator|new
name|String
argument_list|(
name|bytes
argument_list|,
name|UTF8_ENCODING
argument_list|)
expr_stmt|;
name|servers
operator|.
name|put
argument_list|(
name|regionInfo
operator|.
name|startKey
argument_list|,
operator|new
name|RegionLocation
argument_list|(
name|regionInfo
argument_list|,
operator|new
name|HServerAddress
argument_list|(
name|serverAddress
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|scannerId
operator|!=
operator|-
literal|1L
condition|)
block|{
try|try
block|{
name|server
operator|.
name|close
argument_list|(
name|scannerId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|servers
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
name|tries
operator|==
name|this
operator|.
name|numRetries
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|NoServerForRegionException
argument_list|(
literal|"failed to find server for "
operator|+
name|tableName
operator|+
literal|" after "
operator|+
name|this
operator|.
name|numRetries
operator|+
literal|" retries"
argument_list|)
throw|;
block|}
if|if
condition|(
name|servers
operator|.
name|size
argument_list|()
operator|<=
literal|0
condition|)
block|{
comment|// The table is not yet being served. Sleep and retry.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sleeping. Table "
operator|+
name|tableName
operator|+
literal|" not currently being served."
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|this
operator|.
name|pause
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// continue
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Wake. Retry finding table "
operator|+
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|servers
return|;
block|}
comment|/*     * Establishes a connection to the region server at the specified address    * @param regionServer - the server to connect to    * @throws IOException    */
specifier|synchronized
name|HRegionInterface
name|getHRegionConnection
parameter_list|(
name|HServerAddress
name|regionServer
parameter_list|)
throws|throws
name|IOException
block|{
comment|// See if we already have a connection
name|HRegionInterface
name|server
init|=
name|this
operator|.
name|servers
operator|.
name|get
argument_list|(
name|regionServer
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|server
operator|==
literal|null
condition|)
block|{
comment|// Get a connection
name|server
operator|=
operator|(
name|HRegionInterface
operator|)
name|RPC
operator|.
name|waitForProxy
argument_list|(
name|HRegionInterface
operator|.
name|class
argument_list|,
name|HRegionInterface
operator|.
name|versionID
argument_list|,
name|regionServer
operator|.
name|getInetSocketAddress
argument_list|()
argument_list|,
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|servers
operator|.
name|put
argument_list|(
name|regionServer
operator|.
name|toString
argument_list|()
argument_list|,
name|server
argument_list|)
expr_stmt|;
block|}
return|return
name|server
return|;
block|}
comment|/**    * List all the userspace tables.  In other words, scan the META table.    *    * If we wanted this to be really fast, we could implement a special    * catalog table that just contains table names and their descriptors.    * Right now, it only exists as part of the META table's region info.    *    * @return - returns an array of HTableDescriptors     * @throws IOException    */
specifier|public
specifier|synchronized
name|HTableDescriptor
index|[]
name|listTables
parameter_list|()
throws|throws
name|IOException
block|{
name|TreeSet
argument_list|<
name|HTableDescriptor
argument_list|>
name|uniqueTables
init|=
operator|new
name|TreeSet
argument_list|<
name|HTableDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|RegionLocation
argument_list|>
name|metaTables
init|=
name|this
operator|.
name|tablesToServers
operator|.
name|get
argument_list|(
name|META_TABLE_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|metaTables
operator|==
literal|null
condition|)
block|{
comment|// Meta is not loaded yet so go do that
name|metaTables
operator|=
name|loadMetaFromRoot
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|RegionLocation
name|t
range|:
name|metaTables
operator|.
name|values
argument_list|()
control|)
block|{
name|HRegionInterface
name|server
init|=
name|getHRegionConnection
argument_list|(
name|t
operator|.
name|serverAddress
argument_list|)
decl_stmt|;
name|long
name|scannerId
init|=
operator|-
literal|1L
decl_stmt|;
try|try
block|{
name|scannerId
operator|=
name|server
operator|.
name|openScanner
argument_list|(
name|t
operator|.
name|regionInfo
operator|.
name|regionName
argument_list|,
name|META_COLUMNS
argument_list|,
name|EMPTY_START_ROW
argument_list|)
expr_stmt|;
name|DataInputBuffer
name|inbuf
init|=
operator|new
name|DataInputBuffer
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|KeyedData
index|[]
name|values
init|=
name|server
operator|.
name|next
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
if|if
condition|(
name|values
operator|.
name|length
operator|==
literal|0
condition|)
block|{
break|break;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|values
index|[
name|i
index|]
operator|.
name|getKey
argument_list|()
operator|.
name|getColumn
argument_list|()
operator|.
name|equals
argument_list|(
name|COL_REGIONINFO
argument_list|)
condition|)
block|{
name|inbuf
operator|.
name|reset
argument_list|(
name|values
index|[
name|i
index|]
operator|.
name|getData
argument_list|()
argument_list|,
name|values
index|[
name|i
index|]
operator|.
name|getData
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|HRegionInfo
name|info
init|=
operator|new
name|HRegionInfo
argument_list|()
decl_stmt|;
name|info
operator|.
name|readFields
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
comment|// Only examine the rows where the startKey is zero length
if|if
condition|(
name|info
operator|.
name|startKey
operator|.
name|getLength
argument_list|()
operator|==
literal|0
condition|)
block|{
name|uniqueTables
operator|.
name|add
argument_list|(
name|info
operator|.
name|tableDesc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|scannerId
operator|!=
operator|-
literal|1L
condition|)
block|{
name|server
operator|.
name|close
argument_list|(
name|scannerId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|uniqueTables
operator|.
name|toArray
argument_list|(
operator|new
name|HTableDescriptor
index|[
name|uniqueTables
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/*    * Find region location hosting passed row using cached info    * @param row Row to find.    * @return Location of row.    */
specifier|synchronized
name|RegionLocation
name|getRegionLocation
parameter_list|(
name|Text
name|row
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|tableServers
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Must open table first"
argument_list|)
throw|;
block|}
comment|// Only one server will have the row we are looking for
name|Text
name|serverKey
init|=
operator|(
name|this
operator|.
name|tableServers
operator|.
name|containsKey
argument_list|(
name|row
argument_list|)
operator|)
condition|?
name|row
else|:
name|this
operator|.
name|tableServers
operator|.
name|headMap
argument_list|(
name|row
argument_list|)
operator|.
name|lastKey
argument_list|()
decl_stmt|;
return|return
name|this
operator|.
name|tableServers
operator|.
name|get
argument_list|(
name|serverKey
argument_list|)
return|;
block|}
comment|/*    * Clear caches of passed region location, reload servers for the passed    * region's table and then ensure region location can be found.    * @param info Region location to find.    * @throws IOException    */
specifier|synchronized
name|void
name|findRegion
parameter_list|(
specifier|final
name|RegionLocation
name|info
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Wipe out everything we know about this table
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Wiping out all we know of "
operator|+
name|info
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|tablesToServers
operator|.
name|remove
argument_list|(
name|info
operator|.
name|regionInfo
operator|.
name|tableDesc
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableServers
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Reload information for the whole table
name|this
operator|.
name|tableServers
operator|=
name|findServersForTable
argument_list|(
name|info
operator|.
name|regionInfo
operator|.
name|tableDesc
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Result of findRegion: "
operator|+
name|this
operator|.
name|tableServers
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|tableServers
operator|.
name|get
argument_list|(
name|info
operator|.
name|regionInfo
operator|.
name|startKey
argument_list|)
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RegionNotFoundException
argument_list|(
name|info
operator|.
name|regionInfo
operator|.
name|regionName
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**     * Get a single value for the specified row and column    *    * @param row row key    * @param column column name    * @return value for specified row/column    * @throws IOException    */
specifier|public
name|byte
index|[]
name|get
parameter_list|(
name|Text
name|row
parameter_list|,
name|Text
name|column
parameter_list|)
throws|throws
name|IOException
block|{
name|RegionLocation
name|info
init|=
literal|null
decl_stmt|;
name|byte
index|[]
name|value
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
name|numRetries
operator|&&
name|info
operator|==
literal|null
condition|;
name|tries
operator|++
control|)
block|{
name|info
operator|=
name|getRegionLocation
argument_list|(
name|row
argument_list|)
expr_stmt|;
try|try
block|{
name|value
operator|=
name|getHRegionConnection
argument_list|(
name|info
operator|.
name|serverAddress
argument_list|)
operator|.
name|get
argument_list|(
name|info
operator|.
name|regionInfo
operator|.
name|regionName
argument_list|,
name|row
argument_list|,
name|column
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotServingRegionException
name|e
parameter_list|)
block|{
if|if
condition|(
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
throw|throw
name|e
throw|;
block|}
name|findRegion
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|value
return|;
block|}
comment|/**     * Get the specified number of versions of the specified row and column    *     * @param row         - row key    * @param column      - column name    * @param numVersions - number of versions to retrieve    * @return            - array byte values    * @throws IOException    */
specifier|public
name|byte
index|[]
index|[]
name|get
parameter_list|(
name|Text
name|row
parameter_list|,
name|Text
name|column
parameter_list|,
name|int
name|numVersions
parameter_list|)
throws|throws
name|IOException
block|{
name|RegionLocation
name|info
init|=
literal|null
decl_stmt|;
name|byte
index|[]
index|[]
name|values
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
name|numRetries
operator|&&
name|info
operator|==
literal|null
condition|;
name|tries
operator|++
control|)
block|{
name|info
operator|=
name|getRegionLocation
argument_list|(
name|row
argument_list|)
expr_stmt|;
try|try
block|{
name|values
operator|=
name|getHRegionConnection
argument_list|(
name|info
operator|.
name|serverAddress
argument_list|)
operator|.
name|get
argument_list|(
name|info
operator|.
name|regionInfo
operator|.
name|regionName
argument_list|,
name|row
argument_list|,
name|column
argument_list|,
name|numVersions
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotServingRegionException
name|e
parameter_list|)
block|{
if|if
condition|(
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
comment|// No more tries
throw|throw
name|e
throw|;
block|}
name|findRegion
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|values
operator|!=
literal|null
condition|)
block|{
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
name|bytes
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|bytes
operator|.
name|add
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|bytes
operator|.
name|toArray
argument_list|(
operator|new
name|byte
index|[
name|values
operator|.
name|length
index|]
index|[]
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**     * Get the specified number of versions of the specified row and column with    * the specified timestamp.    *    * @param row         - row key    * @param column      - column name    * @param timestamp   - timestamp    * @param numVersions - number of versions to retrieve    * @return            - array of values that match the above criteria    * @throws IOException    */
specifier|public
name|byte
index|[]
index|[]
name|get
parameter_list|(
name|Text
name|row
parameter_list|,
name|Text
name|column
parameter_list|,
name|long
name|timestamp
parameter_list|,
name|int
name|numVersions
parameter_list|)
throws|throws
name|IOException
block|{
name|RegionLocation
name|info
init|=
literal|null
decl_stmt|;
name|byte
index|[]
index|[]
name|values
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
name|numRetries
operator|&&
name|info
operator|==
literal|null
condition|;
name|tries
operator|++
control|)
block|{
name|info
operator|=
name|getRegionLocation
argument_list|(
name|row
argument_list|)
expr_stmt|;
try|try
block|{
name|values
operator|=
name|getHRegionConnection
argument_list|(
name|info
operator|.
name|serverAddress
argument_list|)
operator|.
name|get
argument_list|(
name|info
operator|.
name|regionInfo
operator|.
name|regionName
argument_list|,
name|row
argument_list|,
name|column
argument_list|,
name|timestamp
argument_list|,
name|numVersions
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotServingRegionException
name|e
parameter_list|)
block|{
if|if
condition|(
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
comment|// No more tries
throw|throw
name|e
throw|;
block|}
name|findRegion
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|values
operator|!=
literal|null
condition|)
block|{
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
name|bytes
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|bytes
operator|.
name|add
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|bytes
operator|.
name|toArray
argument_list|(
operator|new
name|byte
index|[
name|values
operator|.
name|length
index|]
index|[]
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**     * Get all the data for the specified row    *     * @param row         - row key    * @return            - map of colums to values    * @throws IOException    */
specifier|public
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
name|getRow
parameter_list|(
name|Text
name|row
parameter_list|)
throws|throws
name|IOException
block|{
name|RegionLocation
name|info
init|=
literal|null
decl_stmt|;
name|KeyedData
index|[]
name|value
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
name|numRetries
operator|&&
name|info
operator|==
literal|null
condition|;
name|tries
operator|++
control|)
block|{
name|info
operator|=
name|getRegionLocation
argument_list|(
name|row
argument_list|)
expr_stmt|;
try|try
block|{
name|value
operator|=
name|getHRegionConnection
argument_list|(
name|info
operator|.
name|serverAddress
argument_list|)
operator|.
name|getRow
argument_list|(
name|info
operator|.
name|regionInfo
operator|.
name|regionName
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotServingRegionException
name|e
parameter_list|)
block|{
if|if
condition|(
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
comment|// No more tries
throw|throw
name|e
throw|;
block|}
name|findRegion
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
name|results
init|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
name|value
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|value
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|results
operator|.
name|put
argument_list|(
name|value
index|[
name|i
index|]
operator|.
name|getKey
argument_list|()
operator|.
name|getColumn
argument_list|()
argument_list|,
name|value
index|[
name|i
index|]
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|results
return|;
block|}
comment|/**     * Get a scanner on the current table starting at the specified row.    * Return the specified columns.    *    * @param columns     - array of columns to return    * @param startRow    - starting row in table to scan    * @return            - scanner    * @throws IOException    */
specifier|public
specifier|synchronized
name|HScannerInterface
name|obtainScanner
parameter_list|(
name|Text
index|[]
name|columns
parameter_list|,
name|Text
name|startRow
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|tableServers
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Must open table first"
argument_list|)
throw|;
block|}
return|return
operator|new
name|ClientScanner
argument_list|(
name|columns
argument_list|,
name|startRow
argument_list|)
return|;
block|}
comment|/*    * @return General HClient RetryPolicy instance.    */
name|RetryPolicy
name|getRetryPolicy
parameter_list|()
block|{
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Exception
argument_list|>
argument_list|,
name|RetryPolicy
argument_list|>
name|exceptionToPolicyMap
init|=
operator|new
name|HashMap
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Exception
argument_list|>
argument_list|,
name|RetryPolicy
argument_list|>
argument_list|()
decl_stmt|;
comment|// Pass numRetries - 1 because it does less-than-equal internally rather
comment|// than the less-than we do elsewhere where we use numRetries.
name|RetryPolicy
name|rp
init|=
name|RetryPolicies
operator|.
name|retryUpToMaximumCountWithProportionalSleep
argument_list|(
name|numRetries
argument_list|,
name|this
operator|.
name|pause
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
decl_stmt|;
name|exceptionToPolicyMap
operator|.
name|put
argument_list|(
name|NotServingRegionException
operator|.
name|class
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|exceptionToPolicyMap
operator|.
name|put
argument_list|(
name|WrongRegionException
operator|.
name|class
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|exceptionToPolicyMap
operator|.
name|put
argument_list|(
name|RegionNotFoundException
operator|.
name|class
argument_list|,
name|rp
argument_list|)
expr_stmt|;
return|return
name|RetryPolicies
operator|.
name|retryByRemoteException
argument_list|(
name|RetryPolicies
operator|.
name|TRY_ONCE_THEN_FAIL
argument_list|,
name|exceptionToPolicyMap
argument_list|)
return|;
block|}
comment|/*    * Interface for {@link #startUpate()} used by the    * {@link org.apache.hadoop.io.retry} mechanism.     */
specifier|private
interface|interface
name|StartUpdateInterface
block|{
comment|/**      * @return row lockid for the update      * @throws IOException      */
name|long
name|startUpdate
parameter_list|()
throws|throws
name|IOException
function_decl|;
block|}
comment|/**     * Start an atomic row insertion/update.  No changes are committed until the     * call to commit() returns. A call to abort() will abandon any updates in progress.    *    * Callers to this method are given a lease for each unique lockid; before the    * lease expires, either abort() or commit() must be called. If it is not     * called, the system will automatically call abort() on the client's behalf.    *    * The client can gain extra time with a call to renewLease().    * Start an atomic row insertion or update    *     * @param row Name of row to start update against.    * @return Row lockid.    * @throws IOException    */
specifier|public
name|long
name|startUpdate
parameter_list|(
specifier|final
name|Text
name|row
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Implemention of the StartUpdate interface.
name|StartUpdateInterface
name|implementation
init|=
operator|new
name|StartUpdateInterface
argument_list|()
block|{
specifier|private
name|RegionLocation
name|info
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|attempts
init|=
literal|0
decl_stmt|;
comment|/*        * Wrapped method.  Proxy wrapper is configured to judge whether        * exception merits retry.        * @return lockid        * @throws IOException        */
specifier|public
name|long
name|startUpdate
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|attempts
operator|++
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|info
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Retry of startUpdate.  Attempt "
operator|+
name|this
operator|.
name|attempts
operator|+
literal|" for row "
operator|+
name|row
argument_list|)
expr_stmt|;
comment|// If a retry. Something wrong w/ region we have. Refind.
try|try
block|{
name|findRegion
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RegionNotFoundException
name|e
parameter_list|)
block|{
comment|// continue.  If no longer exists, perhaps we just came through
comment|// a split and region is now gone. Below getRegionLocation should
comment|// recalibrate client.
block|}
block|}
name|this
operator|.
name|info
operator|=
name|getRegionLocation
argument_list|(
name|row
argument_list|)
expr_stmt|;
name|currentServer
operator|=
name|getHRegionConnection
argument_list|(
name|info
operator|.
name|serverAddress
argument_list|)
expr_stmt|;
name|currentRegion
operator|=
name|info
operator|.
name|regionInfo
operator|.
name|regionName
expr_stmt|;
name|clientid
operator|=
name|rand
operator|.
name|nextLong
argument_list|()
expr_stmt|;
return|return
name|currentServer
operator|.
name|startUpdate
argument_list|(
name|currentRegion
argument_list|,
name|clientid
argument_list|,
name|row
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|// Get retry proxy wrapper around 'implementation'.
name|StartUpdateInterface
name|retryProxy
init|=
operator|(
name|StartUpdateInterface
operator|)
name|RetryProxy
operator|.
name|create
argument_list|(
name|StartUpdateInterface
operator|.
name|class
argument_list|,
name|implementation
argument_list|,
name|getRetryPolicy
argument_list|()
argument_list|)
decl_stmt|;
comment|// Run retry.
return|return
name|retryProxy
operator|.
name|startUpdate
argument_list|()
return|;
block|}
comment|/**     * Change a value for the specified column    *    * @param lockid              - lock id returned from startUpdate    * @param column              - column whose value is being set    * @param val                 - new value for column    * @throws IOException    */
specifier|public
name|void
name|put
parameter_list|(
name|long
name|lockid
parameter_list|,
name|Text
name|column
parameter_list|,
name|byte
name|val
index|[]
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|this
operator|.
name|currentServer
operator|.
name|put
argument_list|(
name|this
operator|.
name|currentRegion
argument_list|,
name|this
operator|.
name|clientid
argument_list|,
name|lockid
argument_list|,
name|column
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
try|try
block|{
name|this
operator|.
name|currentServer
operator|.
name|abort
argument_list|(
name|this
operator|.
name|currentRegion
argument_list|,
name|this
operator|.
name|clientid
argument_list|,
name|lockid
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e2
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e2
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|currentServer
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|currentRegion
operator|=
literal|null
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**     * Delete the value for a column    *    * @param lockid              - lock id returned from startUpdate    * @param column              - name of column whose value is to be deleted    * @throws IOException    */
specifier|public
name|void
name|delete
parameter_list|(
name|long
name|lockid
parameter_list|,
name|Text
name|column
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|this
operator|.
name|currentServer
operator|.
name|delete
argument_list|(
name|this
operator|.
name|currentRegion
argument_list|,
name|this
operator|.
name|clientid
argument_list|,
name|lockid
argument_list|,
name|column
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
try|try
block|{
name|this
operator|.
name|currentServer
operator|.
name|abort
argument_list|(
name|this
operator|.
name|currentRegion
argument_list|,
name|this
operator|.
name|clientid
argument_list|,
name|lockid
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e2
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e2
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|currentServer
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|currentRegion
operator|=
literal|null
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**     * Abort a row mutation    *    * @param lockid              - lock id returned from startUpdate    * @throws IOException    */
specifier|public
name|void
name|abort
parameter_list|(
name|long
name|lockid
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|this
operator|.
name|currentServer
operator|.
name|abort
argument_list|(
name|this
operator|.
name|currentRegion
argument_list|,
name|this
operator|.
name|clientid
argument_list|,
name|lockid
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|this
operator|.
name|currentServer
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|currentRegion
operator|=
literal|null
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**     * Finalize a row mutation    *    * @param lockid              - lock id returned from startUpdate    * @throws IOException    */
specifier|public
name|void
name|commit
parameter_list|(
name|long
name|lockid
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|this
operator|.
name|currentServer
operator|.
name|commit
argument_list|(
name|this
operator|.
name|currentRegion
argument_list|,
name|this
operator|.
name|clientid
argument_list|,
name|lockid
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|currentServer
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|currentRegion
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**    * Renew lease on update    *     * @param lockid              - lock id returned from startUpdate    * @throws IOException    */
specifier|public
name|void
name|renewLease
parameter_list|(
name|long
name|lockid
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|this
operator|.
name|currentServer
operator|.
name|renewLease
argument_list|(
name|lockid
argument_list|,
name|this
operator|.
name|clientid
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
try|try
block|{
name|this
operator|.
name|currentServer
operator|.
name|abort
argument_list|(
name|this
operator|.
name|currentRegion
argument_list|,
name|this
operator|.
name|clientid
argument_list|,
name|lockid
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e2
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e2
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|currentServer
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|currentRegion
operator|=
literal|null
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Implements the scanner interface for the HBase client.    * If there are multiple regions in a table, this scanner will iterate    * through them all.    */
specifier|private
class|class
name|ClientScanner
implements|implements
name|HScannerInterface
block|{
specifier|private
specifier|final
name|Text
name|EMPTY_COLUMN
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
specifier|private
name|Text
index|[]
name|columns
decl_stmt|;
specifier|private
name|Text
name|startRow
decl_stmt|;
specifier|private
name|boolean
name|closed
decl_stmt|;
specifier|private
name|RegionLocation
index|[]
name|regions
decl_stmt|;
specifier|private
name|int
name|currentRegion
decl_stmt|;
specifier|private
name|HRegionInterface
name|server
decl_stmt|;
specifier|private
name|long
name|scannerId
decl_stmt|;
specifier|private
name|void
name|loadRegions
parameter_list|()
block|{
name|Text
name|firstServer
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|startRow
operator|==
literal|null
operator|||
name|this
operator|.
name|startRow
operator|.
name|getLength
argument_list|()
operator|==
literal|0
condition|)
block|{
name|firstServer
operator|=
name|tableServers
operator|.
name|firstKey
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tableServers
operator|.
name|containsKey
argument_list|(
name|startRow
argument_list|)
condition|)
block|{
name|firstServer
operator|=
name|startRow
expr_stmt|;
block|}
else|else
block|{
name|firstServer
operator|=
name|tableServers
operator|.
name|headMap
argument_list|(
name|startRow
argument_list|)
operator|.
name|lastKey
argument_list|()
expr_stmt|;
block|}
name|Collection
argument_list|<
name|RegionLocation
argument_list|>
name|info
init|=
name|tableServers
operator|.
name|tailMap
argument_list|(
name|firstServer
argument_list|)
operator|.
name|values
argument_list|()
decl_stmt|;
name|this
operator|.
name|regions
operator|=
name|info
operator|.
name|toArray
argument_list|(
operator|new
name|RegionLocation
index|[
name|info
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
name|ClientScanner
parameter_list|(
name|Text
index|[]
name|columns
parameter_list|,
name|Text
name|startRow
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|columns
operator|=
name|columns
expr_stmt|;
name|this
operator|.
name|startRow
operator|=
name|startRow
expr_stmt|;
name|this
operator|.
name|closed
operator|=
literal|false
expr_stmt|;
name|loadRegions
argument_list|()
expr_stmt|;
name|this
operator|.
name|currentRegion
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|server
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|scannerId
operator|=
operator|-
literal|1L
expr_stmt|;
name|nextScanner
argument_list|()
expr_stmt|;
block|}
comment|/*      * Gets a scanner for the next region.      * Returns false if there are no more scanners.      */
specifier|private
name|boolean
name|nextScanner
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|scannerId
operator|!=
operator|-
literal|1L
condition|)
block|{
name|this
operator|.
name|server
operator|.
name|close
argument_list|(
name|this
operator|.
name|scannerId
argument_list|)
expr_stmt|;
name|this
operator|.
name|scannerId
operator|=
operator|-
literal|1L
expr_stmt|;
block|}
name|this
operator|.
name|currentRegion
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|currentRegion
operator|==
name|this
operator|.
name|regions
operator|.
name|length
condition|)
block|{
name|close
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
try|try
block|{
name|this
operator|.
name|server
operator|=
name|getHRegionConnection
argument_list|(
name|this
operator|.
name|regions
index|[
name|currentRegion
index|]
operator|.
name|serverAddress
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
name|numRetries
condition|;
name|tries
operator|++
control|)
block|{
name|RegionLocation
name|info
init|=
name|this
operator|.
name|regions
index|[
name|currentRegion
index|]
decl_stmt|;
try|try
block|{
name|this
operator|.
name|scannerId
operator|=
name|this
operator|.
name|server
operator|.
name|openScanner
argument_list|(
name|info
operator|.
name|regionInfo
operator|.
name|regionName
argument_list|,
name|this
operator|.
name|columns
argument_list|,
name|currentRegion
operator|==
literal|0
condition|?
name|this
operator|.
name|startRow
else|:
name|EMPTY_START_ROW
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|NotServingRegionException
name|e
parameter_list|)
block|{
if|if
condition|(
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
comment|// No more tries
throw|throw
name|e
throw|;
block|}
name|findRegion
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|loadRegions
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|close
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
return|return
literal|true
return|;
block|}
comment|/* (non-Javadoc)      * @see org.apache.hadoop.hbase.HScannerInterface#next(org.apache.hadoop.hbase.HStoreKey, java.util.TreeMap)      */
specifier|public
name|boolean
name|next
parameter_list|(
name|HStoreKey
name|key
parameter_list|,
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
name|results
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|closed
condition|)
block|{
return|return
literal|false
return|;
block|}
name|KeyedData
index|[]
name|values
init|=
literal|null
decl_stmt|;
do|do
block|{
name|values
operator|=
name|this
operator|.
name|server
operator|.
name|next
argument_list|(
name|this
operator|.
name|scannerId
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|values
operator|!=
literal|null
operator|&&
name|values
operator|.
name|length
operator|==
literal|0
operator|&&
name|nextScanner
argument_list|()
condition|)
do|;
if|if
condition|(
name|values
operator|!=
literal|null
operator|&&
name|values
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|key
operator|.
name|setRow
argument_list|(
name|values
index|[
name|i
index|]
operator|.
name|getKey
argument_list|()
operator|.
name|getRow
argument_list|()
argument_list|)
expr_stmt|;
name|key
operator|.
name|setVersion
argument_list|(
name|values
index|[
name|i
index|]
operator|.
name|getKey
argument_list|()
operator|.
name|getTimestamp
argument_list|()
argument_list|)
expr_stmt|;
name|key
operator|.
name|setColumn
argument_list|(
name|EMPTY_COLUMN
argument_list|)
expr_stmt|;
name|results
operator|.
name|put
argument_list|(
name|values
index|[
name|i
index|]
operator|.
name|getKey
argument_list|()
operator|.
name|getColumn
argument_list|()
argument_list|,
name|values
index|[
name|i
index|]
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|values
operator|==
literal|null
condition|?
literal|false
else|:
name|values
operator|.
name|length
operator|!=
literal|0
return|;
block|}
comment|/* (non-Javadoc)      * @see org.apache.hadoop.hbase.HScannerInterface#close()      */
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|scannerId
operator|!=
operator|-
literal|1L
condition|)
block|{
name|this
operator|.
name|server
operator|.
name|close
argument_list|(
name|this
operator|.
name|scannerId
argument_list|)
expr_stmt|;
name|this
operator|.
name|scannerId
operator|=
operator|-
literal|1L
expr_stmt|;
block|}
name|this
operator|.
name|server
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|closed
operator|=
literal|true
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|printUsage
parameter_list|()
block|{
name|printUsage
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|printUsage
parameter_list|(
specifier|final
name|String
name|message
parameter_list|)
block|{
if|if
condition|(
name|message
operator|!=
literal|null
operator|&&
name|message
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Usage: java "
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" [--master=host:port]<command><args>"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Options:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" master       Specify host and port of HBase "
operator|+
literal|"cluster master. If not present,"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"              address is read from configuration."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Commands:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" shutdown     Shutdown the HBase cluster."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" createTable  Create named table."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" deleteTable  Delete named table."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" listTables   List all tables."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Example Usage:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" % java "
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" shutdown"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" % java "
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" createTable webcrawl contents: anchors: 10"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|printCreateTableUsage
parameter_list|(
specifier|final
name|String
name|message
parameter_list|)
block|{
if|if
condition|(
name|message
operator|!=
literal|null
operator|&&
name|message
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Usage: java "
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" [options] createTable<name><colfamily1> ...<max_versions>"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Example Usage:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" % java "
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" createTable testtable column_x column_y column_z 3"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|printDeleteTableUsage
parameter_list|(
specifier|final
name|String
name|message
parameter_list|)
block|{
if|if
condition|(
name|message
operator|!=
literal|null
operator|&&
name|message
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Usage: java "
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" [options] deleteTable<name>"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Example Usage:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" % java "
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" deleteTable testtable"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Process command-line args.    * @param args - command arguments    * @return 0 if successful -1 otherwise    */
specifier|public
name|int
name|doCommandLine
parameter_list|(
specifier|final
name|String
name|args
index|[]
parameter_list|)
block|{
comment|// TODO: Better cmd-line processing
comment|// (but hopefully something not as painful as cli options).
name|int
name|errCode
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|length
operator|<
literal|1
condition|)
block|{
name|printUsage
argument_list|()
expr_stmt|;
return|return
name|errCode
return|;
block|}
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|cmd
init|=
name|args
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|cmd
operator|.
name|equals
argument_list|(
literal|"-h"
argument_list|)
operator|||
name|cmd
operator|.
name|startsWith
argument_list|(
literal|"--h"
argument_list|)
condition|)
block|{
name|printUsage
argument_list|()
expr_stmt|;
name|errCode
operator|=
literal|0
expr_stmt|;
break|break;
block|}
specifier|final
name|String
name|masterArgKey
init|=
literal|"--master="
decl_stmt|;
if|if
condition|(
name|cmd
operator|.
name|startsWith
argument_list|(
name|masterArgKey
argument_list|)
condition|)
block|{
name|this
operator|.
name|conf
operator|.
name|set
argument_list|(
name|MASTER_ADDRESS
argument_list|,
name|cmd
operator|.
name|substring
argument_list|(
name|masterArgKey
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|cmd
operator|.
name|equals
argument_list|(
literal|"shutdown"
argument_list|)
condition|)
block|{
name|shutdown
argument_list|()
expr_stmt|;
name|errCode
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cmd
operator|.
name|equals
argument_list|(
literal|"listTables"
argument_list|)
condition|)
block|{
name|HTableDescriptor
index|[]
name|tables
init|=
name|listTables
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|ii
init|=
literal|0
init|;
name|ii
operator|<
name|tables
operator|.
name|length
condition|;
name|ii
operator|++
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|tables
index|[
name|ii
index|]
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|errCode
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cmd
operator|.
name|equals
argument_list|(
literal|"createTable"
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|2
operator|>
name|args
operator|.
name|length
condition|)
block|{
name|printCreateTableUsage
argument_list|(
literal|"Error: Supply a table name,"
operator|+
literal|" at least one column family, and maximum versions"
argument_list|)
expr_stmt|;
name|errCode
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|HTableDescriptor
name|desc
init|=
operator|new
name|HTableDescriptor
argument_list|(
name|args
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
name|boolean
name|addedFamily
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|ii
init|=
name|i
operator|+
literal|2
init|;
name|ii
operator|<
operator|(
name|args
operator|.
name|length
operator|-
literal|1
operator|)
condition|;
name|ii
operator|++
control|)
block|{
name|desc
operator|.
name|addFamily
argument_list|(
operator|new
name|HColumnDescriptor
argument_list|(
name|args
index|[
name|ii
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|addedFamily
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|addedFamily
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Must supply at least one "
operator|+
literal|"column family"
argument_list|)
throw|;
block|}
name|createTable
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|errCode
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cmd
operator|.
name|equals
argument_list|(
literal|"deleteTable"
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|>
name|args
operator|.
name|length
condition|)
block|{
name|printDeleteTableUsage
argument_list|(
literal|"Error: Must supply a table name"
argument_list|)
expr_stmt|;
name|errCode
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|deleteTable
argument_list|(
operator|new
name|Text
argument_list|(
name|args
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|errCode
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|printUsage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
return|return
name|errCode
return|;
block|}
comment|/**    * Main program    * @param args    */
specifier|public
specifier|static
name|void
name|main
parameter_list|(
specifier|final
name|String
name|args
index|[]
parameter_list|)
block|{
name|Configuration
name|c
init|=
operator|new
name|HBaseConfiguration
argument_list|()
decl_stmt|;
name|int
name|errCode
init|=
operator|(
operator|new
name|HClient
argument_list|(
name|c
argument_list|)
operator|)
operator|.
name|doCommandLine
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|System
operator|.
name|exit
argument_list|(
name|errCode
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

