begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2006 The Apache Software Foundation  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|BytesWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|DataInputBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RPC
import|;
end_import

begin_comment
comment|/**  * HClient manages a connection to a single HRegionServer.  */
end_comment

begin_class
specifier|public
class|class
name|HClient
implements|implements
name|HConstants
block|{
specifier|private
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Text
index|[]
name|META_COLUMNS
init|=
block|{
name|COLUMN_FAMILY
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Text
name|EMPTY_START_ROW
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
specifier|private
name|long
name|clientTimeout
decl_stmt|;
specifier|private
name|int
name|numTimeouts
decl_stmt|;
specifier|private
name|int
name|numRetries
decl_stmt|;
specifier|private
name|HMasterInterface
name|master
decl_stmt|;
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
specifier|private
class|class
name|TableInfo
block|{
specifier|public
name|HRegionInfo
name|regionInfo
decl_stmt|;
specifier|public
name|HServerAddress
name|serverAddress
decl_stmt|;
name|TableInfo
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|,
name|HServerAddress
name|serverAddress
parameter_list|)
block|{
name|this
operator|.
name|regionInfo
operator|=
name|regionInfo
expr_stmt|;
name|this
operator|.
name|serverAddress
operator|=
name|serverAddress
expr_stmt|;
block|}
block|}
comment|// Map tableName -> (Map startRow -> (HRegionInfo, HServerAddress)
specifier|private
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|TableInfo
argument_list|>
argument_list|>
name|tablesToServers
decl_stmt|;
comment|// For the "current" table: Map startRow -> (HRegionInfo, HServerAddress)
specifier|private
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|TableInfo
argument_list|>
name|tableServers
decl_stmt|;
comment|// Known region HServerAddress.toString() -> HRegionInterface
specifier|private
name|TreeMap
argument_list|<
name|String
argument_list|,
name|HRegionInterface
argument_list|>
name|servers
decl_stmt|;
comment|// For row mutation operations
specifier|private
name|Text
name|currentRegion
decl_stmt|;
specifier|private
name|HRegionInterface
name|currentServer
decl_stmt|;
specifier|private
name|Random
name|rand
decl_stmt|;
specifier|private
name|long
name|clientid
decl_stmt|;
comment|/** Creates a new HClient */
specifier|public
name|HClient
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|clientTimeout
operator|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.client.timeout.length"
argument_list|,
literal|30
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|this
operator|.
name|numTimeouts
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.client.timeout.number"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|this
operator|.
name|numRetries
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.client.retries.number"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|this
operator|.
name|master
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|tablesToServers
operator|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|TableInfo
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|tableServers
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|servers
operator|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|HRegionInterface
argument_list|>
argument_list|()
expr_stmt|;
comment|// For row mutation operations
name|this
operator|.
name|currentRegion
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|currentServer
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|rand
operator|=
operator|new
name|Random
argument_list|()
expr_stmt|;
block|}
comment|/**    * Find the address of the master and connect to it    */
specifier|private
name|void
name|checkMaster
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|master
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|this
operator|.
name|master
operator|==
literal|null
operator|&&
name|tries
operator|<
name|numRetries
condition|;
name|tries
operator|++
control|)
block|{
name|HServerAddress
name|masterLocation
init|=
operator|new
name|HServerAddress
argument_list|(
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
name|MASTER_ADDRESS
argument_list|,
name|DEFAULT_MASTER_ADDRESS
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|HMasterInterface
name|tryMaster
init|=
operator|(
name|HMasterInterface
operator|)
name|RPC
operator|.
name|getProxy
argument_list|(
name|HMasterInterface
operator|.
name|class
argument_list|,
name|HMasterInterface
operator|.
name|versionID
argument_list|,
name|masterLocation
operator|.
name|getInetSocketAddress
argument_list|()
argument_list|,
name|this
operator|.
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|tryMaster
operator|.
name|isMasterRunning
argument_list|()
condition|)
block|{
name|this
operator|.
name|master
operator|=
name|tryMaster
expr_stmt|;
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
comment|// This was our last chance - don't bother sleeping
break|break;
block|}
block|}
comment|// We either cannot connect to the master or it is not running.
comment|// Sleep and retry
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|this
operator|.
name|clientTimeout
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{       }
block|}
if|if
condition|(
name|this
operator|.
name|master
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Master is not running"
argument_list|)
throw|;
block|}
block|}
specifier|public
specifier|synchronized
name|void
name|createTable
parameter_list|(
name|HTableDescriptor
name|desc
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|desc
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|ROOT_TABLE_NAME
argument_list|)
operator|||
name|desc
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|META_TABLE_NAME
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|desc
operator|.
name|getName
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|" is a reserved table name"
argument_list|)
throw|;
block|}
name|checkMaster
argument_list|()
expr_stmt|;
name|locateRootRegion
argument_list|()
expr_stmt|;
name|this
operator|.
name|master
operator|.
name|createTable
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|synchronized
name|void
name|deleteTable
parameter_list|(
name|Text
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|checkMaster
argument_list|()
expr_stmt|;
name|locateRootRegion
argument_list|()
expr_stmt|;
name|this
operator|.
name|master
operator|.
name|deleteTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|synchronized
name|void
name|shutdown
parameter_list|()
throws|throws
name|IOException
block|{
name|checkMaster
argument_list|()
expr_stmt|;
name|this
operator|.
name|master
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
specifier|public
specifier|synchronized
name|void
name|openTable
parameter_list|(
name|Text
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|tableName
operator|==
literal|null
operator|||
name|tableName
operator|.
name|getLength
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"table name cannot be null or zero length"
argument_list|)
throw|;
block|}
name|this
operator|.
name|tableServers
operator|=
name|tablesToServers
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|tableServers
operator|==
literal|null
condition|)
block|{
comment|// We don't know where the table is
name|findTableInMeta
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
comment|// Load the information from meta
block|}
block|}
specifier|private
name|void
name|findTableInMeta
parameter_list|(
name|Text
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|TableInfo
argument_list|>
name|metaServers
init|=
name|this
operator|.
name|tablesToServers
operator|.
name|get
argument_list|(
name|META_TABLE_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|metaServers
operator|==
literal|null
condition|)
block|{
comment|// Don't know where the meta is
name|loadMetaFromRoot
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
if|if
condition|(
name|tableName
operator|.
name|equals
argument_list|(
name|META_TABLE_NAME
argument_list|)
operator|||
name|tableName
operator|.
name|equals
argument_list|(
name|ROOT_TABLE_NAME
argument_list|)
condition|)
block|{
comment|// All we really wanted was the meta or root table
return|return;
block|}
name|metaServers
operator|=
name|this
operator|.
name|tablesToServers
operator|.
name|get
argument_list|(
name|META_TABLE_NAME
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|tableServers
operator|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|TableInfo
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|this
operator|.
name|tableServers
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
name|tries
operator|<
name|this
operator|.
name|numRetries
condition|;
name|tries
operator|++
control|)
block|{
name|Text
name|firstMetaRegion
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|metaServers
operator|.
name|containsKey
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|firstMetaRegion
operator|=
name|tableName
expr_stmt|;
block|}
else|else
block|{
name|firstMetaRegion
operator|=
name|metaServers
operator|.
name|headMap
argument_list|(
name|tableName
argument_list|)
operator|.
name|lastKey
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Iterator
argument_list|<
name|TableInfo
argument_list|>
name|i
init|=
name|metaServers
operator|.
name|tailMap
argument_list|(
name|firstMetaRegion
argument_list|)
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|TableInfo
name|t
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|scanOneMetaRegion
argument_list|(
name|t
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|tableServers
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// Table not assigned. Sleep and try again
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sleeping. Table "
operator|+
name|tableName
operator|+
literal|" not currently being served."
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|this
operator|.
name|clientTimeout
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{         }
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Wake. Retry finding table "
operator|+
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|this
operator|.
name|tableServers
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"failed to scan "
operator|+
name|META_TABLE_NAME
operator|+
literal|" after "
operator|+
name|this
operator|.
name|numRetries
operator|+
literal|" retries"
argument_list|)
throw|;
block|}
name|this
operator|.
name|tablesToServers
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|this
operator|.
name|tableServers
argument_list|)
expr_stmt|;
block|}
comment|/*    * Load the meta table from the root table.    */
specifier|private
name|void
name|loadMetaFromRoot
parameter_list|(
name|Text
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|locateRootRegion
argument_list|()
expr_stmt|;
if|if
condition|(
name|tableName
operator|.
name|equals
argument_list|(
name|ROOT_TABLE_NAME
argument_list|)
condition|)
block|{
comment|// All we really wanted was the root
return|return;
block|}
name|scanRoot
argument_list|()
expr_stmt|;
block|}
comment|/*    * Repeatedly try to find the root region by asking the HMaster for where it    * could be.    */
specifier|private
name|void
name|locateRootRegion
parameter_list|()
throws|throws
name|IOException
block|{
name|checkMaster
argument_list|()
expr_stmt|;
name|HServerAddress
name|rootRegionLocation
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|rootRegionLocation
operator|==
literal|null
operator|&&
name|tries
operator|<
name|numRetries
condition|;
name|tries
operator|++
control|)
block|{
name|int
name|localTimeouts
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|rootRegionLocation
operator|==
literal|null
operator|&&
name|localTimeouts
operator|<
name|numTimeouts
condition|)
block|{
name|rootRegionLocation
operator|=
name|master
operator|.
name|findRootRegion
argument_list|()
expr_stmt|;
if|if
condition|(
name|rootRegionLocation
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sleeping. Waiting for root region."
argument_list|)
expr_stmt|;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
name|this
operator|.
name|clientTimeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Wake. Retry finding root region."
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{           }
name|localTimeouts
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rootRegionLocation
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Timed out trying to locate root region"
argument_list|)
throw|;
block|}
name|HRegionInterface
name|rootRegion
init|=
name|getHRegionConnection
argument_list|(
name|rootRegionLocation
argument_list|)
decl_stmt|;
try|try
block|{
name|rootRegion
operator|.
name|getRegionInfo
argument_list|(
name|HGlobals
operator|.
name|rootRegionInfo
operator|.
name|regionName
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableServers
operator|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|TableInfo
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|tableServers
operator|.
name|put
argument_list|(
name|EMPTY_START_ROW
argument_list|,
operator|new
name|TableInfo
argument_list|(
name|HGlobals
operator|.
name|rootRegionInfo
argument_list|,
name|rootRegionLocation
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|tablesToServers
operator|.
name|put
argument_list|(
name|ROOT_TABLE_NAME
argument_list|,
name|this
operator|.
name|tableServers
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|NotServingRegionException
name|e
parameter_list|)
block|{
if|if
condition|(
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
comment|// Don't bother sleeping. We've run out of retries.
break|break;
block|}
comment|// Sleep and retry finding root region.
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Root region location changed. Sleeping."
argument_list|)
expr_stmt|;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
name|this
operator|.
name|clientTimeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Wake. Retry finding root region."
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{         }
block|}
name|rootRegionLocation
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|rootRegionLocation
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"unable to locate root region server"
argument_list|)
throw|;
block|}
block|}
comment|/*    * Scans the root region to find all the meta regions    */
specifier|private
name|void
name|scanRoot
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|tableServers
operator|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|TableInfo
argument_list|>
argument_list|()
expr_stmt|;
name|TableInfo
name|t
init|=
name|this
operator|.
name|tablesToServers
operator|.
name|get
argument_list|(
name|ROOT_TABLE_NAME
argument_list|)
operator|.
name|get
argument_list|(
name|EMPTY_START_ROW
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|scanOneMetaRegion
argument_list|(
name|t
argument_list|,
name|META_TABLE_NAME
argument_list|)
operator|==
literal|0
operator|&&
name|tries
operator|<
name|this
operator|.
name|numRetries
condition|;
name|tries
operator|++
control|)
block|{
comment|// The table is not yet being served. Sleep and retry.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sleeping. Table "
operator|+
name|META_TABLE_NAME
operator|+
literal|" not currently being served."
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|this
operator|.
name|clientTimeout
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{       }
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Wake. Retry finding table "
operator|+
name|META_TABLE_NAME
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|this
operator|.
name|tableServers
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"failed to scan "
operator|+
name|ROOT_TABLE_NAME
operator|+
literal|" after "
operator|+
name|this
operator|.
name|numRetries
operator|+
literal|" retries"
argument_list|)
throw|;
block|}
name|this
operator|.
name|tablesToServers
operator|.
name|put
argument_list|(
name|META_TABLE_NAME
argument_list|,
name|this
operator|.
name|tableServers
argument_list|)
expr_stmt|;
block|}
comment|/*    * Scans a single meta region    * @param t the table we're going to scan    * @param tableName the name of the table we're looking for    * @return returns the number of servers that are serving the table    */
specifier|private
name|int
name|scanOneMetaRegion
parameter_list|(
name|TableInfo
name|t
parameter_list|,
name|Text
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegionInterface
name|server
init|=
name|getHRegionConnection
argument_list|(
name|t
operator|.
name|serverAddress
argument_list|)
decl_stmt|;
name|int
name|servers
init|=
literal|0
decl_stmt|;
name|long
name|scannerId
init|=
operator|-
literal|1L
decl_stmt|;
try|try
block|{
name|scannerId
operator|=
name|server
operator|.
name|openScanner
argument_list|(
name|t
operator|.
name|regionInfo
operator|.
name|regionName
argument_list|,
name|META_COLUMNS
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
name|DataInputBuffer
name|inbuf
init|=
operator|new
name|DataInputBuffer
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|HRegionInfo
name|regionInfo
init|=
literal|null
decl_stmt|;
name|String
name|serverAddress
init|=
literal|null
decl_stmt|;
name|HStoreKey
name|key
init|=
operator|new
name|HStoreKey
argument_list|()
decl_stmt|;
name|LabelledData
index|[]
name|values
init|=
name|server
operator|.
name|next
argument_list|(
name|scannerId
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|values
operator|.
name|length
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|servers
operator|==
literal|0
condition|)
block|{
comment|// If we didn't find any servers then the table does not exist
throw|throw
operator|new
name|NoSuchElementException
argument_list|(
literal|"table '"
operator|+
name|tableName
operator|+
literal|"' does not exist"
argument_list|)
throw|;
block|}
comment|// We found at least one server for the table and now we're done.
break|break;
block|}
name|byte
index|[]
name|bytes
init|=
literal|null
decl_stmt|;
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
name|results
init|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|bytes
operator|=
operator|new
name|byte
index|[
name|values
index|[
name|i
index|]
operator|.
name|getData
argument_list|()
operator|.
name|getSize
argument_list|()
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|values
index|[
name|i
index|]
operator|.
name|getData
argument_list|()
operator|.
name|get
argument_list|()
argument_list|,
literal|0
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|results
operator|.
name|put
argument_list|(
name|values
index|[
name|i
index|]
operator|.
name|getLabel
argument_list|()
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
name|regionInfo
operator|=
operator|new
name|HRegionInfo
argument_list|()
expr_stmt|;
name|bytes
operator|=
name|results
operator|.
name|get
argument_list|(
name|COL_REGIONINFO
argument_list|)
expr_stmt|;
name|inbuf
operator|.
name|reset
argument_list|(
name|bytes
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|regionInfo
operator|.
name|readFields
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|regionInfo
operator|.
name|tableDesc
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
comment|// We're done
break|break;
block|}
name|bytes
operator|=
name|results
operator|.
name|get
argument_list|(
name|COL_SERVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|null
operator|||
name|bytes
operator|.
name|length
operator|==
literal|0
condition|)
block|{
comment|// We need to rescan because the table we want is unassigned.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"no server address for "
operator|+
name|regionInfo
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|servers
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|tableServers
operator|.
name|clear
argument_list|()
expr_stmt|;
break|break;
block|}
name|servers
operator|+=
literal|1
expr_stmt|;
name|serverAddress
operator|=
operator|new
name|String
argument_list|(
name|bytes
argument_list|,
name|UTF8_ENCODING
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableServers
operator|.
name|put
argument_list|(
name|regionInfo
operator|.
name|startKey
argument_list|,
operator|new
name|TableInfo
argument_list|(
name|regionInfo
argument_list|,
operator|new
name|HServerAddress
argument_list|(
name|serverAddress
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|servers
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|scannerId
operator|!=
operator|-
literal|1L
condition|)
block|{
name|server
operator|.
name|close
argument_list|(
name|scannerId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|synchronized
name|HRegionInterface
name|getHRegionConnection
parameter_list|(
name|HServerAddress
name|regionServer
parameter_list|)
throws|throws
name|IOException
block|{
comment|// See if we already have a connection
name|HRegionInterface
name|server
init|=
name|this
operator|.
name|servers
operator|.
name|get
argument_list|(
name|regionServer
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|server
operator|==
literal|null
condition|)
block|{
comment|// Get a connection
name|server
operator|=
operator|(
name|HRegionInterface
operator|)
name|RPC
operator|.
name|waitForProxy
argument_list|(
name|HRegionInterface
operator|.
name|class
argument_list|,
name|HRegionInterface
operator|.
name|versionID
argument_list|,
name|regionServer
operator|.
name|getInetSocketAddress
argument_list|()
argument_list|,
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|servers
operator|.
name|put
argument_list|(
name|regionServer
operator|.
name|toString
argument_list|()
argument_list|,
name|server
argument_list|)
expr_stmt|;
block|}
return|return
name|server
return|;
block|}
comment|/**    * List all the userspace tables.  In other words, scan the META table.    *    * If we wanted this to be really fast, we could implement a special    * catalog table that just contains table names and their descriptors.    * Right now, it only exists as part of the META table's region info.    */
specifier|public
specifier|synchronized
name|HTableDescriptor
index|[]
name|listTables
parameter_list|()
throws|throws
name|IOException
block|{
name|TreeSet
argument_list|<
name|HTableDescriptor
argument_list|>
name|uniqueTables
init|=
operator|new
name|TreeSet
argument_list|<
name|HTableDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|TableInfo
argument_list|>
name|metaTables
init|=
name|this
operator|.
name|tablesToServers
operator|.
name|get
argument_list|(
name|META_TABLE_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|metaTables
operator|==
literal|null
condition|)
block|{
comment|// Meta is not loaded yet so go do that
name|loadMetaFromRoot
argument_list|(
name|META_TABLE_NAME
argument_list|)
expr_stmt|;
name|metaTables
operator|=
name|tablesToServers
operator|.
name|get
argument_list|(
name|META_TABLE_NAME
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|TableInfo
name|t
range|:
name|metaTables
operator|.
name|values
argument_list|()
control|)
block|{
name|HRegionInterface
name|server
init|=
name|getHRegionConnection
argument_list|(
name|t
operator|.
name|serverAddress
argument_list|)
decl_stmt|;
name|long
name|scannerId
init|=
operator|-
literal|1L
decl_stmt|;
try|try
block|{
name|scannerId
operator|=
name|server
operator|.
name|openScanner
argument_list|(
name|t
operator|.
name|regionInfo
operator|.
name|regionName
argument_list|,
name|META_COLUMNS
argument_list|,
name|EMPTY_START_ROW
argument_list|)
expr_stmt|;
name|HStoreKey
name|key
init|=
operator|new
name|HStoreKey
argument_list|()
decl_stmt|;
name|DataInputBuffer
name|inbuf
init|=
operator|new
name|DataInputBuffer
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|LabelledData
index|[]
name|values
init|=
name|server
operator|.
name|next
argument_list|(
name|scannerId
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|values
operator|.
name|length
operator|==
literal|0
condition|)
block|{
break|break;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|values
index|[
name|i
index|]
operator|.
name|getLabel
argument_list|()
operator|.
name|equals
argument_list|(
name|COL_REGIONINFO
argument_list|)
condition|)
block|{
name|byte
index|[]
name|bytes
init|=
name|values
index|[
name|i
index|]
operator|.
name|getData
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
name|inbuf
operator|.
name|reset
argument_list|(
name|bytes
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|HRegionInfo
name|info
init|=
operator|new
name|HRegionInfo
argument_list|()
decl_stmt|;
name|info
operator|.
name|readFields
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
comment|// Only examine the rows where the startKey is zero length
if|if
condition|(
name|info
operator|.
name|startKey
operator|.
name|getLength
argument_list|()
operator|==
literal|0
condition|)
block|{
name|uniqueTables
operator|.
name|add
argument_list|(
name|info
operator|.
name|tableDesc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|scannerId
operator|!=
operator|-
literal|1L
condition|)
block|{
name|server
operator|.
name|close
argument_list|(
name|scannerId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|HTableDescriptor
index|[]
operator|)
name|uniqueTables
operator|.
name|toArray
argument_list|(
operator|new
name|HTableDescriptor
index|[
name|uniqueTables
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
specifier|private
specifier|synchronized
name|TableInfo
name|getTableInfo
parameter_list|(
name|Text
name|row
parameter_list|)
block|{
if|if
condition|(
name|row
operator|==
literal|null
operator|||
name|row
operator|.
name|getLength
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"row key cannot be null or zero length"
argument_list|)
throw|;
block|}
if|if
condition|(
name|this
operator|.
name|tableServers
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Must open table first"
argument_list|)
throw|;
block|}
comment|// Only one server will have the row we are looking for
name|Text
name|serverKey
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|tableServers
operator|.
name|containsKey
argument_list|(
name|row
argument_list|)
condition|)
block|{
name|serverKey
operator|=
name|row
expr_stmt|;
block|}
else|else
block|{
name|serverKey
operator|=
name|this
operator|.
name|tableServers
operator|.
name|headMap
argument_list|(
name|row
argument_list|)
operator|.
name|lastKey
argument_list|()
expr_stmt|;
block|}
return|return
name|this
operator|.
name|tableServers
operator|.
name|get
argument_list|(
name|serverKey
argument_list|)
return|;
block|}
specifier|private
specifier|synchronized
name|void
name|findRegion
parameter_list|(
name|TableInfo
name|info
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Wipe out everything we know about this table
name|this
operator|.
name|tablesToServers
operator|.
name|remove
argument_list|(
name|info
operator|.
name|regionInfo
operator|.
name|tableDesc
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableServers
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Reload information for the whole table
name|findTableInMeta
argument_list|(
name|info
operator|.
name|regionInfo
operator|.
name|tableDesc
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|tableServers
operator|.
name|get
argument_list|(
name|info
operator|.
name|regionInfo
operator|.
name|startKey
argument_list|)
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"region "
operator|+
name|info
operator|.
name|regionInfo
operator|.
name|regionName
operator|+
literal|" does not exist"
argument_list|)
throw|;
block|}
block|}
comment|/** Get a single value for the specified row and column */
specifier|public
name|byte
index|[]
name|get
parameter_list|(
name|Text
name|row
parameter_list|,
name|Text
name|column
parameter_list|)
throws|throws
name|IOException
block|{
name|TableInfo
name|info
init|=
literal|null
decl_stmt|;
name|BytesWritable
name|value
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
name|numRetries
operator|&&
name|info
operator|==
literal|null
condition|;
name|tries
operator|++
control|)
block|{
name|info
operator|=
name|getTableInfo
argument_list|(
name|row
argument_list|)
expr_stmt|;
try|try
block|{
name|value
operator|=
name|getHRegionConnection
argument_list|(
name|info
operator|.
name|serverAddress
argument_list|)
operator|.
name|get
argument_list|(
name|info
operator|.
name|regionInfo
operator|.
name|regionName
argument_list|,
name|row
argument_list|,
name|column
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotServingRegionException
name|e
parameter_list|)
block|{
if|if
condition|(
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
comment|// No more tries
throw|throw
name|e
throw|;
block|}
name|findRegion
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|info
operator|=
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|value
operator|.
name|getSize
argument_list|()
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|value
operator|.
name|get
argument_list|()
argument_list|,
literal|0
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|bytes
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/** Get the specified number of versions of the specified row and column */
specifier|public
name|byte
index|[]
index|[]
name|get
parameter_list|(
name|Text
name|row
parameter_list|,
name|Text
name|column
parameter_list|,
name|int
name|numVersions
parameter_list|)
throws|throws
name|IOException
block|{
name|TableInfo
name|info
init|=
literal|null
decl_stmt|;
name|BytesWritable
index|[]
name|values
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
name|numRetries
operator|&&
name|info
operator|==
literal|null
condition|;
name|tries
operator|++
control|)
block|{
name|info
operator|=
name|getTableInfo
argument_list|(
name|row
argument_list|)
expr_stmt|;
try|try
block|{
name|values
operator|=
name|getHRegionConnection
argument_list|(
name|info
operator|.
name|serverAddress
argument_list|)
operator|.
name|get
argument_list|(
name|info
operator|.
name|regionInfo
operator|.
name|regionName
argument_list|,
name|row
argument_list|,
name|column
argument_list|,
name|numVersions
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotServingRegionException
name|e
parameter_list|)
block|{
if|if
condition|(
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
comment|// No more tries
throw|throw
name|e
throw|;
block|}
name|findRegion
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|info
operator|=
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|values
operator|!=
literal|null
condition|)
block|{
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
name|bytes
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|byte
index|[]
name|value
init|=
operator|new
name|byte
index|[
name|values
index|[
name|i
index|]
operator|.
name|getSize
argument_list|()
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|values
index|[
name|i
index|]
operator|.
name|get
argument_list|()
argument_list|,
literal|0
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|value
operator|.
name|length
argument_list|)
expr_stmt|;
name|bytes
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|bytes
operator|.
name|toArray
argument_list|(
operator|new
name|byte
index|[
name|values
operator|.
name|length
index|]
index|[]
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**     * Get the specified number of versions of the specified row and column with    * the specified timestamp.    */
specifier|public
name|byte
index|[]
index|[]
name|get
parameter_list|(
name|Text
name|row
parameter_list|,
name|Text
name|column
parameter_list|,
name|long
name|timestamp
parameter_list|,
name|int
name|numVersions
parameter_list|)
throws|throws
name|IOException
block|{
name|TableInfo
name|info
init|=
literal|null
decl_stmt|;
name|BytesWritable
index|[]
name|values
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
name|numRetries
operator|&&
name|info
operator|==
literal|null
condition|;
name|tries
operator|++
control|)
block|{
name|info
operator|=
name|getTableInfo
argument_list|(
name|row
argument_list|)
expr_stmt|;
try|try
block|{
name|values
operator|=
name|getHRegionConnection
argument_list|(
name|info
operator|.
name|serverAddress
argument_list|)
operator|.
name|get
argument_list|(
name|info
operator|.
name|regionInfo
operator|.
name|regionName
argument_list|,
name|row
argument_list|,
name|column
argument_list|,
name|timestamp
argument_list|,
name|numVersions
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotServingRegionException
name|e
parameter_list|)
block|{
if|if
condition|(
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
comment|// No more tries
throw|throw
name|e
throw|;
block|}
name|findRegion
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|info
operator|=
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|values
operator|!=
literal|null
condition|)
block|{
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
name|bytes
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|byte
index|[]
name|value
init|=
operator|new
name|byte
index|[
name|values
index|[
name|i
index|]
operator|.
name|getSize
argument_list|()
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|values
index|[
name|i
index|]
operator|.
name|get
argument_list|()
argument_list|,
literal|0
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|value
operator|.
name|length
argument_list|)
expr_stmt|;
name|bytes
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|bytes
operator|.
name|toArray
argument_list|(
operator|new
name|byte
index|[
name|values
operator|.
name|length
index|]
index|[]
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/** Get all the data for the specified row */
specifier|public
name|LabelledData
index|[]
name|getRow
parameter_list|(
name|Text
name|row
parameter_list|)
throws|throws
name|IOException
block|{
name|TableInfo
name|info
init|=
literal|null
decl_stmt|;
name|LabelledData
index|[]
name|value
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
name|numRetries
operator|&&
name|info
operator|==
literal|null
condition|;
name|tries
operator|++
control|)
block|{
name|info
operator|=
name|getTableInfo
argument_list|(
name|row
argument_list|)
expr_stmt|;
try|try
block|{
name|value
operator|=
name|getHRegionConnection
argument_list|(
name|info
operator|.
name|serverAddress
argument_list|)
operator|.
name|getRow
argument_list|(
name|info
operator|.
name|regionInfo
operator|.
name|regionName
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotServingRegionException
name|e
parameter_list|)
block|{
if|if
condition|(
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
comment|// No more tries
throw|throw
name|e
throw|;
block|}
name|findRegion
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|info
operator|=
literal|null
expr_stmt|;
block|}
block|}
return|return
name|value
return|;
block|}
comment|/**     * Get a scanner on the current table starting at the specified row.    * Return the specified columns.    */
specifier|public
specifier|synchronized
name|HScannerInterface
name|obtainScanner
parameter_list|(
name|Text
index|[]
name|columns
parameter_list|,
name|Text
name|startRow
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|tableServers
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Must open table first"
argument_list|)
throw|;
block|}
return|return
operator|new
name|ClientScanner
argument_list|(
name|columns
argument_list|,
name|startRow
argument_list|)
return|;
block|}
comment|/** Start an atomic row insertion or update */
specifier|public
name|long
name|startUpdate
parameter_list|(
name|Text
name|row
parameter_list|)
throws|throws
name|IOException
block|{
name|TableInfo
name|info
init|=
literal|null
decl_stmt|;
name|long
name|lockid
init|=
operator|-
literal|1L
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
name|numRetries
operator|&&
name|info
operator|==
literal|null
condition|;
name|tries
operator|++
control|)
block|{
name|info
operator|=
name|getTableInfo
argument_list|(
name|row
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|currentServer
operator|=
name|getHRegionConnection
argument_list|(
name|info
operator|.
name|serverAddress
argument_list|)
expr_stmt|;
name|this
operator|.
name|currentRegion
operator|=
name|info
operator|.
name|regionInfo
operator|.
name|regionName
expr_stmt|;
name|this
operator|.
name|clientid
operator|=
name|rand
operator|.
name|nextLong
argument_list|()
expr_stmt|;
name|lockid
operator|=
name|currentServer
operator|.
name|startUpdate
argument_list|(
name|this
operator|.
name|currentRegion
argument_list|,
name|this
operator|.
name|clientid
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotServingRegionException
name|e
parameter_list|)
block|{
if|if
condition|(
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
comment|// No more tries
throw|throw
name|e
throw|;
block|}
name|findRegion
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|info
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|this
operator|.
name|currentServer
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|currentRegion
operator|=
literal|null
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
return|return
name|lockid
return|;
block|}
comment|/** Change a value for the specified column */
specifier|public
name|void
name|put
parameter_list|(
name|long
name|lockid
parameter_list|,
name|Text
name|column
parameter_list|,
name|byte
name|val
index|[]
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|this
operator|.
name|currentServer
operator|.
name|put
argument_list|(
name|this
operator|.
name|currentRegion
argument_list|,
name|this
operator|.
name|clientid
argument_list|,
name|lockid
argument_list|,
name|column
argument_list|,
operator|new
name|BytesWritable
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
try|try
block|{
name|this
operator|.
name|currentServer
operator|.
name|abort
argument_list|(
name|this
operator|.
name|currentRegion
argument_list|,
name|this
operator|.
name|clientid
argument_list|,
name|lockid
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e2
parameter_list|)
block|{       }
name|this
operator|.
name|currentServer
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|currentRegion
operator|=
literal|null
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/** Delete the value for a column */
specifier|public
name|void
name|delete
parameter_list|(
name|long
name|lockid
parameter_list|,
name|Text
name|column
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|this
operator|.
name|currentServer
operator|.
name|delete
argument_list|(
name|this
operator|.
name|currentRegion
argument_list|,
name|this
operator|.
name|clientid
argument_list|,
name|lockid
argument_list|,
name|column
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
try|try
block|{
name|this
operator|.
name|currentServer
operator|.
name|abort
argument_list|(
name|this
operator|.
name|currentRegion
argument_list|,
name|this
operator|.
name|clientid
argument_list|,
name|lockid
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e2
parameter_list|)
block|{       }
name|this
operator|.
name|currentServer
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|currentRegion
operator|=
literal|null
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/** Abort a row mutation */
specifier|public
name|void
name|abort
parameter_list|(
name|long
name|lockid
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|this
operator|.
name|currentServer
operator|.
name|abort
argument_list|(
name|this
operator|.
name|currentRegion
argument_list|,
name|this
operator|.
name|clientid
argument_list|,
name|lockid
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|this
operator|.
name|currentServer
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|currentRegion
operator|=
literal|null
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/** Finalize a row mutation */
specifier|public
name|void
name|commit
parameter_list|(
name|long
name|lockid
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|this
operator|.
name|currentServer
operator|.
name|commit
argument_list|(
name|this
operator|.
name|currentRegion
argument_list|,
name|this
operator|.
name|clientid
argument_list|,
name|lockid
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|currentServer
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|currentRegion
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**    * Implements the scanner interface for the HBase client.    * If there are multiple regions in a table, this scanner will iterate    * through them all.    */
specifier|private
class|class
name|ClientScanner
implements|implements
name|HScannerInterface
block|{
specifier|private
name|Text
index|[]
name|columns
decl_stmt|;
specifier|private
name|Text
name|startRow
decl_stmt|;
specifier|private
name|boolean
name|closed
decl_stmt|;
specifier|private
name|TableInfo
index|[]
name|regions
decl_stmt|;
specifier|private
name|int
name|currentRegion
decl_stmt|;
specifier|private
name|HRegionInterface
name|server
decl_stmt|;
specifier|private
name|long
name|scannerId
decl_stmt|;
specifier|private
name|void
name|loadRegions
parameter_list|()
block|{
name|Text
name|firstServer
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|startRow
operator|==
literal|null
operator|||
name|this
operator|.
name|startRow
operator|.
name|getLength
argument_list|()
operator|==
literal|0
condition|)
block|{
name|firstServer
operator|=
name|tableServers
operator|.
name|firstKey
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tableServers
operator|.
name|containsKey
argument_list|(
name|startRow
argument_list|)
condition|)
block|{
name|firstServer
operator|=
name|startRow
expr_stmt|;
block|}
else|else
block|{
name|firstServer
operator|=
name|tableServers
operator|.
name|headMap
argument_list|(
name|startRow
argument_list|)
operator|.
name|lastKey
argument_list|()
expr_stmt|;
block|}
name|Collection
argument_list|<
name|TableInfo
argument_list|>
name|info
init|=
name|tableServers
operator|.
name|tailMap
argument_list|(
name|firstServer
argument_list|)
operator|.
name|values
argument_list|()
decl_stmt|;
name|this
operator|.
name|regions
operator|=
name|info
operator|.
name|toArray
argument_list|(
operator|new
name|TableInfo
index|[
name|info
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
specifier|public
name|ClientScanner
parameter_list|(
name|Text
index|[]
name|columns
parameter_list|,
name|Text
name|startRow
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|columns
operator|=
name|columns
expr_stmt|;
name|this
operator|.
name|startRow
operator|=
name|startRow
expr_stmt|;
name|this
operator|.
name|closed
operator|=
literal|false
expr_stmt|;
name|loadRegions
argument_list|()
expr_stmt|;
name|this
operator|.
name|currentRegion
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|server
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|scannerId
operator|=
operator|-
literal|1L
expr_stmt|;
name|nextScanner
argument_list|()
expr_stmt|;
block|}
comment|/*      * Gets a scanner for the next region.      * Returns false if there are no more scanners.      */
specifier|private
name|boolean
name|nextScanner
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|scannerId
operator|!=
operator|-
literal|1L
condition|)
block|{
name|this
operator|.
name|server
operator|.
name|close
argument_list|(
name|this
operator|.
name|scannerId
argument_list|)
expr_stmt|;
name|this
operator|.
name|scannerId
operator|=
operator|-
literal|1L
expr_stmt|;
block|}
name|this
operator|.
name|currentRegion
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|currentRegion
operator|==
name|this
operator|.
name|regions
operator|.
name|length
condition|)
block|{
name|close
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
try|try
block|{
name|this
operator|.
name|server
operator|=
name|getHRegionConnection
argument_list|(
name|this
operator|.
name|regions
index|[
name|currentRegion
index|]
operator|.
name|serverAddress
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
name|numRetries
condition|;
name|tries
operator|++
control|)
block|{
name|TableInfo
name|info
init|=
name|this
operator|.
name|regions
index|[
name|currentRegion
index|]
decl_stmt|;
try|try
block|{
name|this
operator|.
name|scannerId
operator|=
name|this
operator|.
name|server
operator|.
name|openScanner
argument_list|(
name|info
operator|.
name|regionInfo
operator|.
name|regionName
argument_list|,
name|this
operator|.
name|columns
argument_list|,
name|currentRegion
operator|==
literal|0
condition|?
name|this
operator|.
name|startRow
else|:
name|EMPTY_START_ROW
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|NotServingRegionException
name|e
parameter_list|)
block|{
if|if
condition|(
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
comment|// No more tries
throw|throw
name|e
throw|;
block|}
name|findRegion
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|loadRegions
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|close
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
return|return
literal|true
return|;
block|}
comment|/* (non-Javadoc)      * @see org.apache.hadoop.hbase.HScannerInterface#next(org.apache.hadoop.hbase.HStoreKey, java.util.TreeMap)      */
specifier|public
name|boolean
name|next
parameter_list|(
name|HStoreKey
name|key
parameter_list|,
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
name|results
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|closed
condition|)
block|{
return|return
literal|false
return|;
block|}
name|LabelledData
index|[]
name|values
init|=
literal|null
decl_stmt|;
do|do
block|{
name|values
operator|=
name|this
operator|.
name|server
operator|.
name|next
argument_list|(
name|this
operator|.
name|scannerId
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|values
operator|.
name|length
operator|==
literal|0
operator|&&
name|nextScanner
argument_list|()
condition|)
do|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|values
index|[
name|i
index|]
operator|.
name|getData
argument_list|()
operator|.
name|getSize
argument_list|()
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|values
index|[
name|i
index|]
operator|.
name|getData
argument_list|()
operator|.
name|get
argument_list|()
argument_list|,
literal|0
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|results
operator|.
name|put
argument_list|(
name|values
index|[
name|i
index|]
operator|.
name|getLabel
argument_list|()
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
return|return
name|values
operator|.
name|length
operator|!=
literal|0
return|;
block|}
comment|/* (non-Javadoc)      * @see org.apache.hadoop.hbase.HScannerInterface#close()      */
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|scannerId
operator|!=
operator|-
literal|1L
condition|)
block|{
name|this
operator|.
name|server
operator|.
name|close
argument_list|(
name|this
operator|.
name|scannerId
argument_list|)
expr_stmt|;
name|this
operator|.
name|scannerId
operator|=
operator|-
literal|1L
expr_stmt|;
block|}
name|this
operator|.
name|server
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|closed
operator|=
literal|true
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|printUsage
parameter_list|()
block|{
name|printUsage
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|printUsage
parameter_list|(
specifier|final
name|String
name|message
parameter_list|)
block|{
if|if
condition|(
name|message
operator|!=
literal|null
operator|&&
name|message
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Usage: java "
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" [--master=host:port]<command><args>"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Options:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" master       Specify host and port of HBase "
operator|+
literal|"cluster master. If not present,"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"              address is read from configuration."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Commands:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" shutdown     Shutdown the HBase cluster."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" createTable  Takes table name, column families, "
operator|+
literal|"and maximum versions."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" deleteTable  Takes a table name."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" iistTables   List all tables."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Example Usage:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" % java "
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" shutdown"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" % java "
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" createTable webcrawl contents: anchors: 10"
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
name|doCommandLine
parameter_list|(
specifier|final
name|String
name|args
index|[]
parameter_list|)
block|{
comment|// Process command-line args. TODO: Better cmd-line processing
comment|// (but hopefully something not as painful as cli options).
name|int
name|errCode
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|length
operator|<
literal|1
condition|)
block|{
name|printUsage
argument_list|()
expr_stmt|;
return|return
name|errCode
return|;
block|}
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|cmd
init|=
name|args
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|cmd
operator|.
name|equals
argument_list|(
literal|"-h"
argument_list|)
operator|||
name|cmd
operator|.
name|startsWith
argument_list|(
literal|"--h"
argument_list|)
condition|)
block|{
name|printUsage
argument_list|()
expr_stmt|;
name|errCode
operator|=
literal|0
expr_stmt|;
break|break;
block|}
specifier|final
name|String
name|masterArgKey
init|=
literal|"--master="
decl_stmt|;
if|if
condition|(
name|cmd
operator|.
name|startsWith
argument_list|(
name|masterArgKey
argument_list|)
condition|)
block|{
name|this
operator|.
name|conf
operator|.
name|set
argument_list|(
name|MASTER_ADDRESS
argument_list|,
name|cmd
operator|.
name|substring
argument_list|(
name|masterArgKey
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|cmd
operator|.
name|equals
argument_list|(
literal|"shutdown"
argument_list|)
condition|)
block|{
name|shutdown
argument_list|()
expr_stmt|;
name|errCode
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cmd
operator|.
name|equals
argument_list|(
literal|"listTables"
argument_list|)
condition|)
block|{
name|HTableDescriptor
index|[]
name|tables
init|=
name|listTables
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|ii
init|=
literal|0
init|;
name|ii
operator|<
name|tables
operator|.
name|length
condition|;
name|ii
operator|++
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|tables
index|[
name|ii
index|]
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|errCode
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cmd
operator|.
name|equals
argument_list|(
literal|"createTable"
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|3
operator|>
name|args
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Must supply a table name "
operator|+
literal|", at least one column family and maximum number of versions"
argument_list|)
throw|;
block|}
name|int
name|maxVersions
init|=
operator|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
name|args
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
operator|)
decl_stmt|;
name|HTableDescriptor
name|desc
init|=
operator|new
name|HTableDescriptor
argument_list|(
name|args
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|maxVersions
argument_list|)
decl_stmt|;
name|boolean
name|addedFamily
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|ii
init|=
name|i
operator|+
literal|2
init|;
name|ii
operator|<
operator|(
name|args
operator|.
name|length
operator|-
literal|1
operator|)
condition|;
name|ii
operator|++
control|)
block|{
name|desc
operator|.
name|addFamily
argument_list|(
operator|new
name|Text
argument_list|(
name|args
index|[
name|ii
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|addedFamily
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|addedFamily
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Must supply at least one "
operator|+
literal|"column family"
argument_list|)
throw|;
block|}
name|createTable
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|errCode
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cmd
operator|.
name|equals
argument_list|(
literal|"deleteTable"
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|>
name|args
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Must supply a table name"
argument_list|)
throw|;
block|}
name|deleteTable
argument_list|(
operator|new
name|Text
argument_list|(
name|args
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|errCode
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|printUsage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
return|return
name|errCode
return|;
block|}
specifier|public
specifier|static
name|void
name|main
parameter_list|(
specifier|final
name|String
name|args
index|[]
parameter_list|)
block|{
name|Configuration
name|c
init|=
operator|new
name|HBaseConfiguration
argument_list|()
decl_stmt|;
name|int
name|errCode
init|=
operator|(
operator|new
name|HClient
argument_list|(
name|c
argument_list|)
operator|)
operator|.
name|doCommandLine
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|System
operator|.
name|exit
argument_list|(
name|errCode
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

