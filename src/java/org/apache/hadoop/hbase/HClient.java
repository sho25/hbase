begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2006 The Apache Software Foundation  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/*******************************************************************************  * HClient manages a connection to a single HRegionServer.  ******************************************************************************/
end_comment

begin_class
specifier|public
class|class
name|HClient
extends|extends
name|HGlobals
implements|implements
name|HConstants
block|{
specifier|private
specifier|static
specifier|final
name|Text
index|[]
name|metaColumns
init|=
block|{
name|META_COLUMN_FAMILY
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Text
name|startRow
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|closed
decl_stmt|;
specifier|private
name|Configuration
name|conf
decl_stmt|;
specifier|private
name|HServerAddress
name|masterLocation
decl_stmt|;
specifier|private
name|long
name|clientTimeout
decl_stmt|;
specifier|private
name|int
name|numTimeouts
decl_stmt|;
specifier|private
name|int
name|numRetries
decl_stmt|;
specifier|private
name|HMasterInterface
name|master
decl_stmt|;
specifier|private
class|class
name|TableInfo
block|{
specifier|public
name|HRegionInfo
name|regionInfo
decl_stmt|;
specifier|public
name|HServerAddress
name|serverAddress
decl_stmt|;
name|TableInfo
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|,
name|HServerAddress
name|serverAddress
parameter_list|)
block|{
name|this
operator|.
name|regionInfo
operator|=
name|regionInfo
expr_stmt|;
name|this
operator|.
name|serverAddress
operator|=
name|serverAddress
expr_stmt|;
block|}
block|}
comment|// Map tableName -> (Map startRow -> (HRegionInfo, HServerAddress)
specifier|private
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|TableInfo
argument_list|>
argument_list|>
name|tablesToServers
decl_stmt|;
comment|// For the "current" table: Map startRow -> (HRegionInfo, HServerAddress)
specifier|private
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|TableInfo
argument_list|>
name|tableServers
decl_stmt|;
comment|// Known region HServerAddress.toString() -> HRegionInterface
specifier|private
name|TreeMap
argument_list|<
name|String
argument_list|,
name|HRegionInterface
argument_list|>
name|servers
decl_stmt|;
comment|// For row mutation operations
specifier|private
name|Text
name|currentRegion
decl_stmt|;
specifier|private
name|HRegionInterface
name|currentServer
decl_stmt|;
specifier|private
name|Random
name|rand
decl_stmt|;
specifier|private
name|long
name|clientid
decl_stmt|;
comment|/** Creates a new HClient */
specifier|public
name|HClient
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|closed
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
comment|// Load config settings
name|this
operator|.
name|masterLocation
operator|=
operator|new
name|HServerAddress
argument_list|(
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
name|MASTER_DEFAULT_NAME
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|clientTimeout
operator|=
name|this
operator|.
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.client.timeout.length"
argument_list|,
literal|10
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|this
operator|.
name|numTimeouts
operator|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.client.timeout.number"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|this
operator|.
name|numRetries
operator|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.client.retries.number"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|// Finish initialization
name|this
operator|.
name|master
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|tablesToServers
operator|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|TableInfo
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|tableServers
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|servers
operator|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|HRegionInterface
argument_list|>
argument_list|()
expr_stmt|;
comment|// For row mutation operations
name|this
operator|.
name|currentRegion
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|currentServer
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|rand
operator|=
operator|new
name|Random
argument_list|()
expr_stmt|;
block|}
specifier|public
specifier|synchronized
name|void
name|openTable
parameter_list|(
name|Text
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|closed
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"client is not open"
argument_list|)
throw|;
block|}
name|tableServers
operator|=
name|tablesToServers
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
if|if
condition|(
name|tableServers
operator|==
literal|null
condition|)
block|{
comment|// We don't know where the table is
name|findTableInMeta
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
comment|// Load the information from meta
block|}
block|}
specifier|private
name|void
name|findTableInMeta
parameter_list|(
name|Text
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|TableInfo
argument_list|>
name|metaServers
init|=
name|tablesToServers
operator|.
name|get
argument_list|(
name|META_TABLE_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|metaServers
operator|==
literal|null
condition|)
block|{
comment|// Don't know where the meta is
name|loadMetaFromRoot
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
if|if
condition|(
name|tableName
operator|.
name|equals
argument_list|(
name|META_TABLE_NAME
argument_list|)
operator|||
name|tableName
operator|.
name|equals
argument_list|(
name|ROOT_TABLE_NAME
argument_list|)
condition|)
block|{
comment|// All we really wanted was the meta or root table
return|return;
block|}
name|metaServers
operator|=
name|tablesToServers
operator|.
name|get
argument_list|(
name|META_TABLE_NAME
argument_list|)
expr_stmt|;
block|}
name|tableServers
operator|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|TableInfo
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|TableInfo
argument_list|>
name|i
init|=
name|metaServers
operator|.
name|tailMap
argument_list|(
name|tableName
argument_list|)
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|TableInfo
name|t
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|scanOneMetaRegion
argument_list|(
name|t
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
block|}
name|tablesToServers
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|tableServers
argument_list|)
expr_stmt|;
block|}
comment|/*    * Load the meta table from the root table.    */
specifier|private
name|void
name|loadMetaFromRoot
parameter_list|(
name|Text
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|locateRootRegion
argument_list|()
expr_stmt|;
if|if
condition|(
name|tableName
operator|.
name|equals
argument_list|(
name|ROOT_TABLE_NAME
argument_list|)
condition|)
block|{
comment|// All we really wanted was the root
return|return;
block|}
name|scanRoot
argument_list|()
expr_stmt|;
block|}
comment|/*    * Repeatedly try to find the root region by asking the HMaster for where it    * could be.    */
specifier|private
name|void
name|locateRootRegion
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|master
operator|==
literal|null
condition|)
block|{
name|master
operator|=
operator|(
name|HMasterInterface
operator|)
name|RPC
operator|.
name|getProxy
argument_list|(
name|HMasterInterface
operator|.
name|class
argument_list|,
name|HMasterInterface
operator|.
name|versionID
argument_list|,
name|masterLocation
operator|.
name|getInetSocketAddress
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
name|int
name|tries
init|=
literal|0
decl_stmt|;
name|HServerAddress
name|rootRegionLocation
init|=
literal|null
decl_stmt|;
do|do
block|{
name|int
name|localTimeouts
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|rootRegionLocation
operator|==
literal|null
operator|&&
name|localTimeouts
operator|<
name|numTimeouts
condition|)
block|{
name|rootRegionLocation
operator|=
name|master
operator|.
name|findRootRegion
argument_list|()
expr_stmt|;
if|if
condition|(
name|rootRegionLocation
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|clientTimeout
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{           }
name|localTimeouts
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rootRegionLocation
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Timed out trying to locate root region"
argument_list|)
throw|;
block|}
comment|// Verify that this server still serves the root region
name|HRegionInterface
name|rootRegion
init|=
name|getHRegionConnection
argument_list|(
name|rootRegionLocation
argument_list|)
decl_stmt|;
if|if
condition|(
name|rootRegion
operator|.
name|getRegionInfo
argument_list|(
name|rootRegionInfo
operator|.
name|regionName
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|tableServers
operator|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|TableInfo
argument_list|>
argument_list|()
expr_stmt|;
name|tableServers
operator|.
name|put
argument_list|(
name|startRow
argument_list|,
operator|new
name|TableInfo
argument_list|(
name|rootRegionInfo
argument_list|,
name|rootRegionLocation
argument_list|)
argument_list|)
expr_stmt|;
name|tablesToServers
operator|.
name|put
argument_list|(
name|ROOT_TABLE_NAME
argument_list|,
name|tableServers
argument_list|)
expr_stmt|;
break|break;
block|}
name|rootRegionLocation
operator|=
literal|null
expr_stmt|;
block|}
do|while
condition|(
name|rootRegionLocation
operator|==
literal|null
operator|&&
name|tries
operator|++
operator|<
name|numRetries
condition|)
do|;
if|if
condition|(
name|rootRegionLocation
operator|==
literal|null
condition|)
block|{
name|closed
operator|=
literal|true
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"unable to locate root region server"
argument_list|)
throw|;
block|}
block|}
comment|/*    * Scans the root region to find all the meta regions    */
specifier|private
name|void
name|scanRoot
parameter_list|()
throws|throws
name|IOException
block|{
name|tableServers
operator|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|TableInfo
argument_list|>
argument_list|()
expr_stmt|;
name|TableInfo
name|t
init|=
name|tablesToServers
operator|.
name|get
argument_list|(
name|ROOT_TABLE_NAME
argument_list|)
operator|.
name|get
argument_list|(
name|startRow
argument_list|)
decl_stmt|;
name|scanOneMetaRegion
argument_list|(
name|t
argument_list|,
name|META_TABLE_NAME
argument_list|)
expr_stmt|;
name|tablesToServers
operator|.
name|put
argument_list|(
name|META_TABLE_NAME
argument_list|,
name|tableServers
argument_list|)
expr_stmt|;
block|}
comment|/*    * Scans a single meta region    * @param t           - the table we're going to scan    * @param tableName   - the name of the table we're looking for    */
specifier|private
name|void
name|scanOneMetaRegion
parameter_list|(
name|TableInfo
name|t
parameter_list|,
name|Text
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegionInterface
name|server
init|=
name|getHRegionConnection
argument_list|(
name|t
operator|.
name|serverAddress
argument_list|)
decl_stmt|;
name|HScannerInterface
name|scanner
init|=
literal|null
decl_stmt|;
try|try
block|{
name|scanner
operator|=
name|server
operator|.
name|openScanner
argument_list|(
name|t
operator|.
name|regionInfo
operator|.
name|regionName
argument_list|,
name|metaColumns
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
name|HStoreKey
name|key
init|=
operator|new
name|HStoreKey
argument_list|()
decl_stmt|;
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
name|results
init|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
name|DataInputBuffer
name|inbuf
init|=
operator|new
name|DataInputBuffer
argument_list|()
decl_stmt|;
while|while
condition|(
name|scanner
operator|.
name|next
argument_list|(
name|key
argument_list|,
name|results
argument_list|)
condition|)
block|{
name|byte
name|hRegionInfoBytes
index|[]
init|=
name|results
operator|.
name|get
argument_list|(
name|META_COL_REGIONINFO
argument_list|)
decl_stmt|;
name|inbuf
operator|.
name|reset
argument_list|(
name|hRegionInfoBytes
argument_list|,
name|hRegionInfoBytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|HRegionInfo
name|regionInfo
init|=
operator|new
name|HRegionInfo
argument_list|()
decl_stmt|;
name|regionInfo
operator|.
name|readFields
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|regionInfo
operator|.
name|tableDesc
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
comment|// We're done
break|break;
block|}
name|byte
name|serverBytes
index|[]
init|=
name|results
operator|.
name|get
argument_list|(
name|META_COL_SERVER
argument_list|)
decl_stmt|;
name|String
name|serverName
init|=
operator|new
name|String
argument_list|(
name|serverBytes
argument_list|,
name|UTF8_ENCODING
argument_list|)
decl_stmt|;
name|tableServers
operator|.
name|put
argument_list|(
name|regionInfo
operator|.
name|startKey
argument_list|,
operator|new
name|TableInfo
argument_list|(
name|regionInfo
argument_list|,
operator|new
name|HServerAddress
argument_list|(
name|serverName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|results
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|scanner
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
specifier|synchronized
name|HRegionInterface
name|getHRegionConnection
parameter_list|(
name|HServerAddress
name|regionServer
parameter_list|)
throws|throws
name|IOException
block|{
comment|// See if we already have a connection
name|HRegionInterface
name|server
init|=
name|servers
operator|.
name|get
argument_list|(
name|regionServer
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|server
operator|==
literal|null
condition|)
block|{
comment|// Get a connection
name|server
operator|=
operator|(
name|HRegionInterface
operator|)
name|RPC
operator|.
name|waitForProxy
argument_list|(
name|HRegionInterface
operator|.
name|class
argument_list|,
name|HRegionInterface
operator|.
name|versionID
argument_list|,
name|regionServer
operator|.
name|getInetSocketAddress
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|servers
operator|.
name|put
argument_list|(
name|regionServer
operator|.
name|toString
argument_list|()
argument_list|,
name|server
argument_list|)
expr_stmt|;
block|}
return|return
name|server
return|;
block|}
comment|/** Close the connection to the HRegionServer */
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|closed
condition|)
block|{
name|RPC
operator|.
name|stopClient
argument_list|()
expr_stmt|;
name|closed
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/**    * List all the userspace tables.  In other words, scan the META table.    *    * If we wanted this to be really fast, we could implement a special    * catalog table that just contains table names and their descriptors.    * Right now, it only exists as part of the META table's region info.    */
specifier|public
name|HTableDescriptor
index|[]
name|listTables
parameter_list|()
throws|throws
name|IOException
block|{
name|TreeSet
argument_list|<
name|HTableDescriptor
argument_list|>
name|uniqueTables
init|=
operator|new
name|TreeSet
argument_list|<
name|HTableDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|TableInfo
argument_list|>
name|metaTables
init|=
name|tablesToServers
operator|.
name|get
argument_list|(
name|META_TABLE_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|metaTables
operator|==
literal|null
condition|)
block|{
comment|// Meta is not loaded yet so go do that
name|loadMetaFromRoot
argument_list|(
name|META_TABLE_NAME
argument_list|)
expr_stmt|;
name|metaTables
operator|=
name|tablesToServers
operator|.
name|get
argument_list|(
name|META_TABLE_NAME
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
argument_list|<
name|TableInfo
argument_list|>
name|i
init|=
name|metaTables
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|TableInfo
name|t
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|HRegionInterface
name|server
init|=
name|getHRegionConnection
argument_list|(
name|t
operator|.
name|serverAddress
argument_list|)
decl_stmt|;
name|HScannerInterface
name|scanner
init|=
literal|null
decl_stmt|;
try|try
block|{
name|scanner
operator|=
name|server
operator|.
name|openScanner
argument_list|(
name|t
operator|.
name|regionInfo
operator|.
name|regionName
argument_list|,
name|metaColumns
argument_list|,
name|startRow
argument_list|)
expr_stmt|;
name|HStoreKey
name|key
init|=
operator|new
name|HStoreKey
argument_list|()
decl_stmt|;
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
name|results
init|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
name|DataInputBuffer
name|inbuf
init|=
operator|new
name|DataInputBuffer
argument_list|()
decl_stmt|;
while|while
condition|(
name|scanner
operator|.
name|next
argument_list|(
name|key
argument_list|,
name|results
argument_list|)
condition|)
block|{
name|byte
name|infoBytes
index|[]
init|=
operator|(
name|byte
index|[]
operator|)
name|results
operator|.
name|get
argument_list|(
name|ROOT_COL_REGIONINFO
argument_list|)
decl_stmt|;
name|inbuf
operator|.
name|reset
argument_list|(
name|infoBytes
argument_list|,
name|infoBytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|HRegionInfo
name|info
init|=
operator|new
name|HRegionInfo
argument_list|()
decl_stmt|;
name|info
operator|.
name|readFields
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
comment|// Only examine the rows where the startKey is zero length
if|if
condition|(
name|info
operator|.
name|startKey
operator|.
name|getLength
argument_list|()
operator|==
literal|0
condition|)
block|{
name|uniqueTables
operator|.
name|add
argument_list|(
name|info
operator|.
name|tableDesc
argument_list|)
expr_stmt|;
block|}
name|results
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|scanner
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
operator|(
name|HTableDescriptor
index|[]
operator|)
name|uniqueTables
operator|.
name|toArray
argument_list|(
operator|new
name|HTableDescriptor
index|[
name|uniqueTables
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
specifier|private
name|TableInfo
name|getTableInfo
parameter_list|(
name|Text
name|row
parameter_list|)
block|{
if|if
condition|(
name|tableServers
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Must open table first"
argument_list|)
throw|;
block|}
comment|// Only one server will have the row we are looking for
name|Text
name|serverKey
init|=
name|tableServers
operator|.
name|tailMap
argument_list|(
name|row
argument_list|)
operator|.
name|firstKey
argument_list|()
decl_stmt|;
return|return
name|tableServers
operator|.
name|get
argument_list|(
name|serverKey
argument_list|)
return|;
block|}
comment|/** Get a single value for the specified row and column */
specifier|public
name|byte
index|[]
name|get
parameter_list|(
name|Text
name|row
parameter_list|,
name|Text
name|column
parameter_list|)
throws|throws
name|IOException
block|{
name|TableInfo
name|info
init|=
name|getTableInfo
argument_list|(
name|row
argument_list|)
decl_stmt|;
return|return
name|getHRegionConnection
argument_list|(
name|info
operator|.
name|serverAddress
argument_list|)
operator|.
name|get
argument_list|(
name|info
operator|.
name|regionInfo
operator|.
name|regionName
argument_list|,
name|row
argument_list|,
name|column
argument_list|)
operator|.
name|get
argument_list|()
return|;
block|}
comment|/** Get the specified number of versions of the specified row and column */
specifier|public
name|byte
index|[]
index|[]
name|get
parameter_list|(
name|Text
name|row
parameter_list|,
name|Text
name|column
parameter_list|,
name|int
name|numVersions
parameter_list|)
throws|throws
name|IOException
block|{
name|TableInfo
name|info
init|=
name|getTableInfo
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|BytesWritable
index|[]
name|values
init|=
name|getHRegionConnection
argument_list|(
name|info
operator|.
name|serverAddress
argument_list|)
operator|.
name|get
argument_list|(
name|info
operator|.
name|regionInfo
operator|.
name|regionName
argument_list|,
name|row
argument_list|,
name|column
argument_list|,
name|numVersions
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
name|bytes
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|bytes
operator|.
name|add
argument_list|(
name|values
index|[
name|i
index|]
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|bytes
operator|.
name|toArray
argument_list|(
operator|new
name|byte
index|[
name|values
operator|.
name|length
index|]
index|[]
argument_list|)
return|;
block|}
comment|/**     * Get the specified number of versions of the specified row and column with    * the specified timestamp.    */
specifier|public
name|byte
index|[]
index|[]
name|get
parameter_list|(
name|Text
name|row
parameter_list|,
name|Text
name|column
parameter_list|,
name|long
name|timestamp
parameter_list|,
name|int
name|numVersions
parameter_list|)
throws|throws
name|IOException
block|{
name|TableInfo
name|info
init|=
name|getTableInfo
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|BytesWritable
index|[]
name|values
init|=
name|getHRegionConnection
argument_list|(
name|info
operator|.
name|serverAddress
argument_list|)
operator|.
name|get
argument_list|(
name|info
operator|.
name|regionInfo
operator|.
name|regionName
argument_list|,
name|row
argument_list|,
name|column
argument_list|,
name|timestamp
argument_list|,
name|numVersions
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
name|bytes
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|bytes
operator|.
name|add
argument_list|(
name|values
index|[
name|i
index|]
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|bytes
operator|.
name|toArray
argument_list|(
operator|new
name|byte
index|[
name|values
operator|.
name|length
index|]
index|[]
argument_list|)
return|;
block|}
comment|/** Get all the data for the specified row */
specifier|public
name|LabelledData
index|[]
name|getRow
parameter_list|(
name|Text
name|row
parameter_list|)
throws|throws
name|IOException
block|{
name|TableInfo
name|info
init|=
name|getTableInfo
argument_list|(
name|row
argument_list|)
decl_stmt|;
return|return
name|getHRegionConnection
argument_list|(
name|info
operator|.
name|serverAddress
argument_list|)
operator|.
name|getRow
argument_list|(
name|info
operator|.
name|regionInfo
operator|.
name|regionName
argument_list|,
name|row
argument_list|)
return|;
block|}
comment|/**     * Get a scanner on the current table starting at the specified row.    * Return the specified columns.    */
specifier|public
name|HScannerInterface
name|obtainScanner
parameter_list|(
name|Text
index|[]
name|columns
parameter_list|,
name|Text
name|startRow
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|tableServers
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Must open table first"
argument_list|)
throw|;
block|}
return|return
operator|new
name|ClientScanner
argument_list|(
name|columns
argument_list|,
name|startRow
argument_list|)
return|;
block|}
comment|/** Start an atomic row insertion or update */
specifier|public
name|long
name|startUpdate
parameter_list|(
name|Text
name|row
parameter_list|)
throws|throws
name|IOException
block|{
name|TableInfo
name|info
init|=
name|getTableInfo
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|long
name|lockid
decl_stmt|;
try|try
block|{
name|currentServer
operator|=
name|getHRegionConnection
argument_list|(
name|info
operator|.
name|serverAddress
argument_list|)
expr_stmt|;
name|currentRegion
operator|=
name|info
operator|.
name|regionInfo
operator|.
name|regionName
expr_stmt|;
name|clientid
operator|=
name|rand
operator|.
name|nextLong
argument_list|()
expr_stmt|;
name|lockid
operator|=
name|currentServer
operator|.
name|startUpdate
argument_list|(
name|currentRegion
argument_list|,
name|clientid
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|currentServer
operator|=
literal|null
expr_stmt|;
name|currentRegion
operator|=
literal|null
expr_stmt|;
throw|throw
name|e
throw|;
block|}
return|return
name|lockid
return|;
block|}
comment|/** Change a value for the specified column */
specifier|public
name|void
name|put
parameter_list|(
name|long
name|lockid
parameter_list|,
name|Text
name|column
parameter_list|,
name|byte
name|val
index|[]
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|currentServer
operator|.
name|put
argument_list|(
name|currentRegion
argument_list|,
name|clientid
argument_list|,
name|lockid
argument_list|,
name|column
argument_list|,
operator|new
name|BytesWritable
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
try|try
block|{
name|currentServer
operator|.
name|abort
argument_list|(
name|currentRegion
argument_list|,
name|clientid
argument_list|,
name|lockid
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e2
parameter_list|)
block|{       }
name|currentServer
operator|=
literal|null
expr_stmt|;
name|currentRegion
operator|=
literal|null
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/** Delete the value for a column */
specifier|public
name|void
name|delete
parameter_list|(
name|long
name|lockid
parameter_list|,
name|Text
name|column
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|currentServer
operator|.
name|delete
argument_list|(
name|currentRegion
argument_list|,
name|clientid
argument_list|,
name|lockid
argument_list|,
name|column
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
try|try
block|{
name|currentServer
operator|.
name|abort
argument_list|(
name|currentRegion
argument_list|,
name|clientid
argument_list|,
name|lockid
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e2
parameter_list|)
block|{       }
name|currentServer
operator|=
literal|null
expr_stmt|;
name|currentRegion
operator|=
literal|null
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/** Abort a row mutation */
specifier|public
name|void
name|abort
parameter_list|(
name|long
name|lockid
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|currentServer
operator|.
name|abort
argument_list|(
name|currentRegion
argument_list|,
name|clientid
argument_list|,
name|lockid
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|currentServer
operator|=
literal|null
expr_stmt|;
name|currentRegion
operator|=
literal|null
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/** Finalize a row mutation */
specifier|public
name|void
name|commit
parameter_list|(
name|long
name|lockid
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|currentServer
operator|.
name|commit
argument_list|(
name|currentRegion
argument_list|,
name|clientid
argument_list|,
name|lockid
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|currentServer
operator|=
literal|null
expr_stmt|;
name|currentRegion
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**    * Implements the scanner interface for the HBase client.    * If there are multiple regions in a table, this scanner will iterate    * through them all.    */
specifier|private
class|class
name|ClientScanner
implements|implements
name|HScannerInterface
block|{
specifier|private
name|Text
index|[]
name|columns
decl_stmt|;
specifier|private
name|Text
name|startRow
decl_stmt|;
specifier|private
name|boolean
name|closed
decl_stmt|;
specifier|private
name|TableInfo
index|[]
name|regions
decl_stmt|;
specifier|private
name|int
name|currentRegion
decl_stmt|;
specifier|private
name|HRegionInterface
name|server
decl_stmt|;
specifier|private
name|HScannerInterface
name|scanner
decl_stmt|;
specifier|public
name|ClientScanner
parameter_list|(
name|Text
index|[]
name|columns
parameter_list|,
name|Text
name|startRow
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|columns
operator|=
name|columns
expr_stmt|;
name|this
operator|.
name|startRow
operator|=
name|startRow
expr_stmt|;
name|this
operator|.
name|closed
operator|=
literal|false
expr_stmt|;
name|Collection
argument_list|<
name|TableInfo
argument_list|>
name|info
init|=
name|tableServers
operator|.
name|tailMap
argument_list|(
name|startRow
argument_list|)
operator|.
name|values
argument_list|()
decl_stmt|;
name|this
operator|.
name|regions
operator|=
name|info
operator|.
name|toArray
argument_list|(
operator|new
name|TableInfo
index|[
name|info
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
name|this
operator|.
name|currentRegion
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|server
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|scanner
operator|=
literal|null
expr_stmt|;
name|nextScanner
argument_list|()
expr_stmt|;
block|}
comment|/*      * Gets a scanner for the next region.      * Returns false if there are no more scanners.      */
specifier|private
name|boolean
name|nextScanner
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|scanner
operator|!=
literal|null
condition|)
block|{
name|scanner
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|currentRegion
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|currentRegion
operator|==
name|regions
operator|.
name|length
condition|)
block|{
name|close
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
try|try
block|{
name|server
operator|=
name|getHRegionConnection
argument_list|(
name|regions
index|[
name|currentRegion
index|]
operator|.
name|serverAddress
argument_list|)
expr_stmt|;
name|scanner
operator|=
name|server
operator|.
name|openScanner
argument_list|(
name|regions
index|[
name|currentRegion
index|]
operator|.
name|regionInfo
operator|.
name|regionName
argument_list|,
name|columns
argument_list|,
name|startRow
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|close
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
return|return
literal|true
return|;
block|}
comment|/* (non-Javadoc)      * @see org.apache.hadoop.hbase.HScannerInterface#next(org.apache.hadoop.hbase.HStoreKey, java.util.TreeMap)      */
specifier|public
name|boolean
name|next
parameter_list|(
name|HStoreKey
name|key
parameter_list|,
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
name|results
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|closed
condition|)
block|{
return|return
literal|false
return|;
block|}
name|boolean
name|status
init|=
name|scanner
operator|.
name|next
argument_list|(
name|key
argument_list|,
name|results
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
block|{
name|status
operator|=
name|nextScanner
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|status
operator|=
name|scanner
operator|.
name|next
argument_list|(
name|key
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
comment|/* (non-Javadoc)      * @see org.apache.hadoop.hbase.HScannerInterface#close()      */
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|scanner
operator|!=
literal|null
condition|)
block|{
name|scanner
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|server
operator|=
literal|null
expr_stmt|;
name|closed
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

