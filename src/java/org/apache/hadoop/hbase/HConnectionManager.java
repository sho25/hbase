begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2007 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RPC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|MapWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|ImmutableBytesWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Writables
import|;
end_import

begin_comment
comment|/**  * A non-instantiable class that manages connections to multiple tables in  * multiple HBase instances  */
end_comment

begin_class
specifier|public
class|class
name|HConnectionManager
implements|implements
name|HConstants
block|{
comment|/*    * Private. Not instantiable.    */
specifier|private
name|HConnectionManager
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
comment|// A Map of master HServerAddress -> connection information for that instance
comment|// Note that although the Map is synchronized, the objects it contains
comment|// are mutable and hence require synchronized access to them
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|HConnection
argument_list|>
name|HBASE_INSTANCES
init|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|HConnection
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Get the connection object for the instance specified by the configuration    * If no current connection exists, create a new connection for that instance    * @param conf    * @return HConnection object for the instance specified by the configuration    */
specifier|public
specifier|static
name|HConnection
name|getConnection
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|HConnection
name|connection
decl_stmt|;
synchronized|synchronized
init|(
name|HBASE_INSTANCES
init|)
block|{
name|String
name|instanceName
init|=
name|conf
operator|.
name|get
argument_list|(
name|HBASE_DIR
argument_list|,
name|DEFAULT_HBASE_DIR
argument_list|)
decl_stmt|;
name|connection
operator|=
name|HBASE_INSTANCES
operator|.
name|get
argument_list|(
name|instanceName
argument_list|)
expr_stmt|;
if|if
condition|(
name|connection
operator|==
literal|null
condition|)
block|{
name|connection
operator|=
operator|new
name|TableServers
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|HBASE_INSTANCES
operator|.
name|put
argument_list|(
name|instanceName
argument_list|,
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|connection
return|;
block|}
comment|/**    * Delete connection information for the instance specified by the configuration    * @param conf    */
specifier|public
specifier|static
name|void
name|deleteConnection
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
synchronized|synchronized
init|(
name|HBASE_INSTANCES
init|)
block|{
name|HBASE_INSTANCES
operator|.
name|remove
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|HBASE_DIR
argument_list|,
name|DEFAULT_HBASE_DIR
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* encapsulates finding the servers for an HBase instance */
specifier|private
specifier|static
class|class
name|TableServers
implements|implements
name|HConnection
implements|,
name|HConstants
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TableServers
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|HRegionInterface
argument_list|>
name|serverInterfaceClass
decl_stmt|;
specifier|private
specifier|final
name|long
name|threadWakeFrequency
decl_stmt|;
specifier|private
specifier|final
name|long
name|pause
decl_stmt|;
specifier|private
specifier|final
name|int
name|numRetries
decl_stmt|;
specifier|private
specifier|final
name|Integer
name|masterLock
init|=
operator|new
name|Integer
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|private
specifier|volatile
name|HMasterInterface
name|master
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|masterChecked
decl_stmt|;
specifier|private
specifier|final
name|Integer
name|rootRegionLock
init|=
operator|new
name|Integer
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|Integer
name|metaRegionLock
init|=
operator|new
name|Integer
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|private
specifier|volatile
name|Configuration
name|conf
decl_stmt|;
comment|// Map tableName -> (Map startRow -> (HRegionInfo, HServerAddress)
specifier|private
name|Map
argument_list|<
name|Text
argument_list|,
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|HRegionLocation
argument_list|>
argument_list|>
name|tablesToServers
decl_stmt|;
comment|// Set of closed tables
specifier|private
name|Set
argument_list|<
name|Text
argument_list|>
name|closedTables
decl_stmt|;
comment|// Set of tables currently being located
specifier|private
name|HashSet
argument_list|<
name|Text
argument_list|>
name|tablesBeingLocated
decl_stmt|;
comment|// Known region HServerAddress.toString() -> HRegionInterface
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|HRegionInterface
argument_list|>
name|servers
decl_stmt|;
comment|/**       * constructor      * @param conf Configuration object      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|TableServers
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|String
name|serverClassName
init|=
name|conf
operator|.
name|get
argument_list|(
name|REGION_SERVER_CLASS
argument_list|,
name|DEFAULT_REGION_SERVER_CLASS
argument_list|)
decl_stmt|;
try|try
block|{
name|this
operator|.
name|serverInterfaceClass
operator|=
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|HRegionInterface
argument_list|>
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|serverClassName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Unable to find region server interface "
operator|+
name|serverClassName
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|this
operator|.
name|threadWakeFrequency
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|THREAD_WAKE_FREQUENCY
argument_list|,
literal|10
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|this
operator|.
name|pause
operator|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.client.pause"
argument_list|,
literal|30
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|this
operator|.
name|numRetries
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.client.retries.number"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|this
operator|.
name|master
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|masterChecked
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|tablesToServers
operator|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|HashMap
argument_list|<
name|Text
argument_list|,
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|HRegionLocation
argument_list|>
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|closedTables
operator|=
name|Collections
operator|.
name|synchronizedSet
argument_list|(
operator|new
name|HashSet
argument_list|<
name|Text
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|tablesBeingLocated
operator|=
operator|new
name|HashSet
argument_list|<
name|Text
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|servers
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|HRegionInterface
argument_list|>
argument_list|()
expr_stmt|;
block|}
comment|/** {@inheritDoc} */
specifier|public
name|HMasterInterface
name|getMaster
parameter_list|()
throws|throws
name|MasterNotRunningException
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|masterLock
init|)
block|{
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
operator|!
name|this
operator|.
name|masterChecked
operator|&&
name|this
operator|.
name|master
operator|==
literal|null
operator|&&
name|tries
operator|<
name|numRetries
condition|;
name|tries
operator|++
control|)
block|{
name|HServerAddress
name|masterLocation
init|=
operator|new
name|HServerAddress
argument_list|(
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
name|MASTER_ADDRESS
argument_list|,
name|DEFAULT_MASTER_ADDRESS
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|HMasterInterface
name|tryMaster
init|=
operator|(
name|HMasterInterface
operator|)
name|RPC
operator|.
name|getProxy
argument_list|(
name|HMasterInterface
operator|.
name|class
argument_list|,
name|HMasterInterface
operator|.
name|versionID
argument_list|,
name|masterLocation
operator|.
name|getInetSocketAddress
argument_list|()
argument_list|,
name|this
operator|.
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|tryMaster
operator|.
name|isMasterRunning
argument_list|()
condition|)
block|{
name|this
operator|.
name|master
operator|=
name|tryMaster
expr_stmt|;
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
comment|// This was our last chance - don't bother sleeping
break|break;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Attempt "
operator|+
name|tries
operator|+
literal|" of "
operator|+
name|this
operator|.
name|numRetries
operator|+
literal|" failed with<"
operator|+
name|e
operator|+
literal|">. Retrying after sleep of "
operator|+
name|this
operator|.
name|pause
argument_list|)
expr_stmt|;
block|}
comment|// We either cannot connect to master or it is not running. Sleep& retry
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|this
operator|.
name|pause
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// continue
block|}
block|}
name|this
operator|.
name|masterChecked
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|master
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|MasterNotRunningException
argument_list|()
throw|;
block|}
return|return
name|this
operator|.
name|master
return|;
block|}
comment|/** {@inheritDoc} */
specifier|public
name|boolean
name|isMasterRunning
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|master
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|getMaster
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MasterNotRunningException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/** {@inheritDoc} */
specifier|public
name|boolean
name|tableExists
parameter_list|(
specifier|final
name|Text
name|tableName
parameter_list|)
block|{
if|if
condition|(
name|tableName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Table name cannot be null"
argument_list|)
throw|;
block|}
name|boolean
name|exists
init|=
literal|false
decl_stmt|;
try|try
block|{
name|HTableDescriptor
index|[]
name|tables
init|=
name|listTables
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tables
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tables
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|exists
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Testing for table existence threw exception"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|exists
return|;
block|}
comment|/** {@inheritDoc} */
specifier|public
name|HTableDescriptor
index|[]
name|listTables
parameter_list|()
throws|throws
name|IOException
block|{
name|HashSet
argument_list|<
name|HTableDescriptor
argument_list|>
name|uniqueTables
init|=
operator|new
name|HashSet
argument_list|<
name|HTableDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|HRegionLocation
argument_list|>
name|metaTables
init|=
name|getTableServers
argument_list|(
name|META_TABLE_NAME
argument_list|)
decl_stmt|;
for|for
control|(
name|HRegionLocation
name|t
range|:
name|metaTables
operator|.
name|values
argument_list|()
control|)
block|{
name|HRegionInterface
name|server
init|=
name|getHRegionConnection
argument_list|(
name|t
operator|.
name|getServerAddress
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|scannerId
init|=
operator|-
literal|1L
decl_stmt|;
try|try
block|{
name|scannerId
operator|=
name|server
operator|.
name|openScanner
argument_list|(
name|t
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|COLUMN_FAMILY_ARRAY
argument_list|,
name|EMPTY_START_ROW
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|MapWritable
name|values
init|=
name|server
operator|.
name|next
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
if|if
condition|(
name|values
operator|==
literal|null
operator|||
name|values
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
break|break;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Writable
argument_list|,
name|Writable
argument_list|>
name|e
range|:
name|values
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|HStoreKey
name|key
init|=
operator|(
name|HStoreKey
operator|)
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|.
name|getColumn
argument_list|()
operator|.
name|equals
argument_list|(
name|COL_REGIONINFO
argument_list|)
condition|)
block|{
name|HRegionInfo
name|info
init|=
operator|new
name|HRegionInfo
argument_list|()
decl_stmt|;
name|info
operator|=
operator|(
name|HRegionInfo
operator|)
name|Writables
operator|.
name|getWritable
argument_list|(
operator|(
operator|(
name|ImmutableBytesWritable
operator|)
name|e
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|get
argument_list|()
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|// Only examine the rows where the startKey is zero length
if|if
condition|(
name|info
operator|.
name|getStartKey
argument_list|()
operator|.
name|getLength
argument_list|()
operator|==
literal|0
condition|)
block|{
name|uniqueTables
operator|.
name|add
argument_list|(
name|info
operator|.
name|getTableDesc
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|RemoteException
name|ex
parameter_list|)
block|{
throw|throw
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|scannerId
operator|!=
operator|-
literal|1L
condition|)
block|{
name|server
operator|.
name|close
argument_list|(
name|scannerId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|uniqueTables
operator|.
name|toArray
argument_list|(
operator|new
name|HTableDescriptor
index|[
name|uniqueTables
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/** {@inheritDoc} */
specifier|public
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|HRegionLocation
argument_list|>
name|getTableServers
parameter_list|(
name|Text
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|tableName
operator|==
literal|null
operator|||
name|tableName
operator|.
name|getLength
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"table name cannot be null or zero length"
argument_list|)
throw|;
block|}
name|closedTables
operator|.
name|remove
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|HRegionLocation
argument_list|>
name|tableServers
init|=
name|tablesToServers
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|tableServers
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No servers for "
operator|+
name|tableName
operator|+
literal|". Doing a find..."
argument_list|)
expr_stmt|;
block|}
comment|// We don't know where the table is.
comment|// Load the information from meta.
name|tableServers
operator|=
name|findServersForTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|HRegionLocation
argument_list|>
name|servers
init|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|HRegionLocation
argument_list|>
argument_list|()
decl_stmt|;
name|servers
operator|.
name|putAll
argument_list|(
name|tableServers
argument_list|)
expr_stmt|;
return|return
name|servers
return|;
block|}
comment|/** {@inheritDoc} */
specifier|public
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|HRegionLocation
argument_list|>
name|reloadTableServers
parameter_list|(
specifier|final
name|Text
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|closedTables
operator|.
name|remove
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|HRegionLocation
argument_list|>
name|tableServers
init|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|HRegionLocation
argument_list|>
argument_list|()
decl_stmt|;
comment|// Reload information for the whole table
name|tableServers
operator|.
name|putAll
argument_list|(
name|findServersForTable
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|HRegionLocation
name|location
range|:
name|tableServers
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|count
operator|++
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|". "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"address="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|location
operator|.
name|getServerAddress
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|location
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Result of findTable on "
operator|+
name|tableName
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|tableServers
return|;
block|}
comment|/** {@inheritDoc} */
specifier|public
name|HRegionInterface
name|getHRegionConnection
parameter_list|(
name|HServerAddress
name|regionServer
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegionInterface
name|server
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|servers
init|)
block|{
comment|// See if we already have a connection
name|server
operator|=
name|this
operator|.
name|servers
operator|.
name|get
argument_list|(
name|regionServer
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
operator|==
literal|null
condition|)
block|{
comment|// Get a connection
name|long
name|versionId
init|=
literal|0
decl_stmt|;
try|try
block|{
name|versionId
operator|=
name|serverInterfaceClass
operator|.
name|getDeclaredField
argument_list|(
literal|"versionID"
argument_list|)
operator|.
name|getLong
argument_list|(
name|server
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
comment|// Should never happen unless visibility of versionID changes
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Unable to open a connection to a "
operator|+
name|serverInterfaceClass
operator|.
name|getName
argument_list|()
operator|+
literal|" server."
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|NoSuchFieldException
name|e
parameter_list|)
block|{
comment|// Should never happen unless versionID field name changes in HRegionInterface
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Unable to open a connection to a "
operator|+
name|serverInterfaceClass
operator|.
name|getName
argument_list|()
operator|+
literal|" server."
argument_list|,
name|e
argument_list|)
throw|;
block|}
try|try
block|{
name|server
operator|=
operator|(
name|HRegionInterface
operator|)
name|RPC
operator|.
name|waitForProxy
argument_list|(
name|serverInterfaceClass
argument_list|,
name|versionId
argument_list|,
name|regionServer
operator|.
name|getInetSocketAddress
argument_list|()
argument_list|,
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
throw|throw
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|this
operator|.
name|servers
operator|.
name|put
argument_list|(
name|regionServer
operator|.
name|toString
argument_list|()
argument_list|,
name|server
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|server
return|;
block|}
comment|/** {@inheritDoc} */
specifier|public
name|void
name|close
parameter_list|(
name|Text
name|tableName
parameter_list|)
block|{
if|if
condition|(
name|tableName
operator|==
literal|null
operator|||
name|tableName
operator|.
name|getLength
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"table name cannot be null or zero length"
argument_list|)
throw|;
block|}
if|if
condition|(
name|closedTables
operator|.
name|contains
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"table already closed: "
operator|+
name|tableName
argument_list|)
throw|;
block|}
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|HRegionLocation
argument_list|>
name|tableServers
init|=
name|tablesToServers
operator|.
name|remove
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|tableServers
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"table not open: "
operator|+
name|tableName
argument_list|)
throw|;
block|}
name|closedTables
operator|.
name|add
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
comment|// Shut down connections to the HRegionServers
synchronized|synchronized
init|(
name|this
operator|.
name|servers
init|)
block|{
for|for
control|(
name|HRegionLocation
name|r
range|:
name|tableServers
operator|.
name|values
argument_list|()
control|)
block|{
name|this
operator|.
name|servers
operator|.
name|remove
argument_list|(
name|r
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*      * Clears the cache of all known information about the specified table and      * locates a table by searching the META or ROOT region (as appropriate) or      * by querying the master for the location of the root region if that is the      * table requested.      *       * @param tableName - name of table to find servers for      * @return - map of first row to table info for all regions in the table      * @throws IOException      */
specifier|private
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|HRegionLocation
argument_list|>
name|findServersForTable
parameter_list|(
name|Text
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Wipe out everything we know about this table
if|if
condition|(
name|this
operator|.
name|tablesToServers
operator|.
name|remove
argument_list|(
name|tableName
argument_list|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Wiping out all we know of "
operator|+
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|HRegionLocation
argument_list|>
name|srvrs
init|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|HRegionLocation
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|tableName
operator|.
name|equals
argument_list|(
name|ROOT_TABLE_NAME
argument_list|)
condition|)
block|{
synchronized|synchronized
init|(
name|rootRegionLock
init|)
block|{
comment|// This block guards against two threads trying to find the root
comment|// region at the same time. One will go do the find while the
comment|// second waits. The second thread will not do find.
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|HRegionLocation
argument_list|>
name|tableServers
init|=
name|this
operator|.
name|tablesToServers
operator|.
name|get
argument_list|(
name|ROOT_TABLE_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|tableServers
operator|==
literal|null
condition|)
block|{
name|tableServers
operator|=
name|locateRootRegion
argument_list|()
expr_stmt|;
block|}
name|srvrs
operator|.
name|putAll
argument_list|(
name|tableServers
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tableName
operator|.
name|equals
argument_list|(
name|META_TABLE_NAME
argument_list|)
condition|)
block|{
synchronized|synchronized
init|(
name|metaRegionLock
init|)
block|{
comment|// This block guards against two threads trying to load the meta
comment|// region at the same time. The first will load the meta region and
comment|// the second will use the value that the first one found.
if|if
condition|(
name|tablesToServers
operator|.
name|get
argument_list|(
name|ROOT_TABLE_NAME
argument_list|)
operator|==
literal|null
condition|)
block|{
name|findServersForTable
argument_list|(
name|ROOT_TABLE_NAME
argument_list|)
expr_stmt|;
block|}
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|HRegionLocation
argument_list|>
name|tableServers
init|=
name|this
operator|.
name|tablesToServers
operator|.
name|get
argument_list|(
name|META_TABLE_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|tableServers
operator|==
literal|null
condition|)
block|{
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
name|numRetries
condition|;
name|tries
operator|++
control|)
block|{
try|try
block|{
name|tableServers
operator|=
name|loadMetaFromRoot
argument_list|()
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|tries
operator|<
name|numRetries
operator|-
literal|1
condition|)
block|{
name|findServersForTable
argument_list|(
name|ROOT_TABLE_NAME
argument_list|)
expr_stmt|;
continue|continue;
block|}
throw|throw
name|e
throw|;
block|}
block|}
block|}
name|srvrs
operator|.
name|putAll
argument_list|(
name|tableServers
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|boolean
name|waited
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|tablesBeingLocated
init|)
block|{
comment|// This block ensures that only one thread will actually try to
comment|// find a table. If a second thread comes along it will wait
comment|// until the first thread finishes finding the table.
while|while
condition|(
name|this
operator|.
name|tablesBeingLocated
operator|.
name|contains
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|waited
operator|=
literal|true
expr_stmt|;
try|try
block|{
name|this
operator|.
name|tablesBeingLocated
operator|.
name|wait
argument_list|(
name|threadWakeFrequency
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// continue
block|}
block|}
if|if
condition|(
operator|!
name|waited
condition|)
block|{
name|this
operator|.
name|tablesBeingLocated
operator|.
name|add
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|HRegionLocation
argument_list|>
name|tableServers
init|=
name|this
operator|.
name|tablesToServers
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|tableServers
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|TableNotFoundException
argument_list|(
literal|"table not found: "
operator|+
name|tableName
argument_list|)
throw|;
block|}
name|srvrs
operator|.
name|putAll
argument_list|(
name|tableServers
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|waited
condition|)
block|{
try|try
block|{
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
name|numRetries
condition|;
name|tries
operator|++
control|)
block|{
name|boolean
name|success
init|=
literal|true
decl_stmt|;
comment|// assume this works
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|HRegionLocation
argument_list|>
name|metaServers
init|=
name|this
operator|.
name|tablesToServers
operator|.
name|get
argument_list|(
name|META_TABLE_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|metaServers
operator|==
literal|null
condition|)
block|{
name|metaServers
operator|=
name|findServersForTable
argument_list|(
name|META_TABLE_NAME
argument_list|)
expr_stmt|;
block|}
name|Text
name|firstMetaRegion
init|=
name|metaServers
operator|.
name|headMap
argument_list|(
name|tableName
argument_list|)
operator|.
name|lastKey
argument_list|()
decl_stmt|;
name|metaServers
operator|=
name|metaServers
operator|.
name|tailMap
argument_list|(
name|firstMetaRegion
argument_list|)
expr_stmt|;
for|for
control|(
name|HRegionLocation
name|t
range|:
name|metaServers
operator|.
name|values
argument_list|()
control|)
block|{
try|try
block|{
name|srvrs
operator|.
name|putAll
argument_list|(
name|scanOneMetaRegion
argument_list|(
name|t
argument_list|,
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|tries
operator|<
name|numRetries
operator|-
literal|1
condition|)
block|{
name|metaServers
operator|=
name|findServersForTable
argument_list|(
name|META_TABLE_NAME
argument_list|)
expr_stmt|;
name|success
operator|=
literal|false
expr_stmt|;
break|break;
block|}
throw|throw
name|e
throw|;
block|}
block|}
if|if
condition|(
name|success
condition|)
block|{
break|break;
block|}
block|}
block|}
finally|finally
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|tablesBeingLocated
init|)
block|{
comment|// Wake up the threads waiting for us to find the table
name|this
operator|.
name|tablesBeingLocated
operator|.
name|remove
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|this
operator|.
name|tablesBeingLocated
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
name|this
operator|.
name|tablesToServers
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|srvrs
argument_list|)
expr_stmt|;
return|return
name|srvrs
return|;
block|}
comment|/*      * Load the meta table from the root table.      *       * @return map of first row to TableInfo for all meta regions      * @throws IOException      */
specifier|private
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|HRegionLocation
argument_list|>
name|loadMetaFromRoot
parameter_list|()
throws|throws
name|IOException
block|{
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|HRegionLocation
argument_list|>
name|rootRegion
init|=
name|this
operator|.
name|tablesToServers
operator|.
name|get
argument_list|(
name|ROOT_TABLE_NAME
argument_list|)
decl_stmt|;
return|return
name|scanOneMetaRegion
argument_list|(
name|rootRegion
operator|.
name|get
argument_list|(
name|rootRegion
operator|.
name|firstKey
argument_list|()
argument_list|)
argument_list|,
name|META_TABLE_NAME
argument_list|)
return|;
block|}
comment|/*      * Repeatedly try to find the root region by asking the master for where it is      * @return TreeMap<Text, TableInfo> for root regin if found      * @throws NoServerForRegionException - if the root region can not be located      * after retrying      * @throws IOException       */
specifier|private
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|HRegionLocation
argument_list|>
name|locateRootRegion
parameter_list|()
throws|throws
name|IOException
block|{
name|getMaster
argument_list|()
expr_stmt|;
name|HServerAddress
name|rootRegionLocation
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
name|numRetries
condition|;
name|tries
operator|++
control|)
block|{
name|int
name|localTimeouts
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|rootRegionLocation
operator|==
literal|null
operator|&&
name|localTimeouts
operator|<
name|numRetries
condition|)
block|{
name|rootRegionLocation
operator|=
name|master
operator|.
name|findRootRegion
argument_list|()
expr_stmt|;
if|if
condition|(
name|rootRegionLocation
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sleeping. Waiting for root region."
argument_list|)
expr_stmt|;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
name|pause
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Wake. Retry finding root region."
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{
comment|// continue
block|}
name|localTimeouts
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rootRegionLocation
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoServerForRegionException
argument_list|(
literal|"Timed out trying to locate root region"
argument_list|)
throw|;
block|}
name|HRegionInterface
name|rootRegion
init|=
name|getHRegionConnection
argument_list|(
name|rootRegionLocation
argument_list|)
decl_stmt|;
try|try
block|{
name|rootRegion
operator|.
name|getRegionInfo
argument_list|(
name|HRegionInfo
operator|.
name|rootRegionInfo
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
comment|// Don't bother sleeping. We've run out of retries.
if|if
condition|(
name|e
operator|instanceof
name|RemoteException
condition|)
block|{
name|e
operator|=
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
operator|(
name|RemoteException
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
comment|// Sleep and retry finding root region.
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Root region location changed. Sleeping."
argument_list|)
expr_stmt|;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
name|pause
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Wake. Retry finding root region."
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{
comment|// continue
block|}
block|}
name|rootRegionLocation
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|rootRegionLocation
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoServerForRegionException
argument_list|(
literal|"unable to locate root region server"
argument_list|)
throw|;
block|}
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|HRegionLocation
argument_list|>
name|rootServer
init|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|HRegionLocation
argument_list|>
argument_list|()
decl_stmt|;
name|rootServer
operator|.
name|put
argument_list|(
name|EMPTY_START_ROW
argument_list|,
operator|new
name|HRegionLocation
argument_list|(
name|HRegionInfo
operator|.
name|rootRegionInfo
argument_list|,
name|rootRegionLocation
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rootServer
return|;
block|}
comment|/*      * Scans a single meta region      * @param t the meta region we're going to scan      * @param tableName the name of the table we're looking for      * @return returns a map of startingRow to TableInfo      * @throws TableNotFoundException - if table does not exist      * @throws IllegalStateException - if table is offline      * @throws NoServerForRegionException - if table can not be found after retrying      * @throws IOException       */
specifier|private
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|HRegionLocation
argument_list|>
name|scanOneMetaRegion
parameter_list|(
specifier|final
name|HRegionLocation
name|t
parameter_list|,
specifier|final
name|Text
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegionInterface
name|server
init|=
name|getHRegionConnection
argument_list|(
name|t
operator|.
name|getServerAddress
argument_list|()
argument_list|)
decl_stmt|;
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|HRegionLocation
argument_list|>
name|servers
init|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|HRegionLocation
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|servers
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
name|tries
operator|<
name|numRetries
condition|;
name|tries
operator|++
control|)
block|{
name|long
name|scannerId
init|=
operator|-
literal|1L
decl_stmt|;
try|try
block|{
name|scannerId
operator|=
name|server
operator|.
name|openScanner
argument_list|(
name|t
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|COLUMN_FAMILY_ARRAY
argument_list|,
name|tableName
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|MapWritable
name|values
init|=
name|server
operator|.
name|next
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
if|if
condition|(
name|values
operator|==
literal|null
operator|||
name|values
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|servers
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// If we didn't find any servers then the table does not exist
throw|throw
operator|new
name|TableNotFoundException
argument_list|(
literal|"table '"
operator|+
name|tableName
operator|+
literal|"' does not exist in "
operator|+
name|t
argument_list|)
throw|;
block|}
comment|// We found at least one server for the table and now we're done.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found "
operator|+
name|servers
operator|.
name|size
argument_list|()
operator|+
literal|" region(s) for "
operator|+
name|tableName
operator|+
literal|" at "
operator|+
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|SortedMap
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
name|results
init|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Writable
argument_list|,
name|Writable
argument_list|>
name|e
range|:
name|values
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|HStoreKey
name|key
init|=
operator|(
name|HStoreKey
operator|)
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|results
operator|.
name|put
argument_list|(
name|key
operator|.
name|getColumn
argument_list|()
argument_list|,
operator|(
operator|(
name|ImmutableBytesWritable
operator|)
name|e
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|bytes
init|=
name|results
operator|.
name|get
argument_list|(
name|COL_REGIONINFO
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|null
operator|||
name|bytes
operator|.
name|length
operator|==
literal|0
condition|)
block|{
comment|// This can be null.  Looks like an info:splitA or info:splitB
comment|// is only item in the row.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|COL_REGIONINFO
operator|.
name|toString
argument_list|()
operator|+
literal|" came back empty: "
operator|+
name|results
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|servers
operator|.
name|clear
argument_list|()
expr_stmt|;
break|break;
block|}
name|HRegionInfo
name|regionInfo
init|=
operator|(
name|HRegionInfo
operator|)
name|Writables
operator|.
name|getWritable
argument_list|(
name|results
operator|.
name|get
argument_list|(
name|COL_REGIONINFO
argument_list|)
argument_list|,
operator|new
name|HRegionInfo
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|regionInfo
operator|.
name|getTableDesc
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
comment|// We're done
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found "
operator|+
name|servers
operator|.
name|size
argument_list|()
operator|+
literal|" servers for table "
operator|+
name|tableName
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|regionInfo
operator|.
name|isSplit
argument_list|()
condition|)
block|{
comment|// Region is a split parent. Skip it.
continue|continue;
block|}
if|if
condition|(
name|regionInfo
operator|.
name|isOffline
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"table offline: "
operator|+
name|tableName
argument_list|)
throw|;
block|}
name|bytes
operator|=
name|results
operator|.
name|get
argument_list|(
name|COL_SERVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|null
operator|||
name|bytes
operator|.
name|length
operator|==
literal|0
condition|)
block|{
comment|// We need to rescan because the table we want is unassigned.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"no server address for "
operator|+
name|regionInfo
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|servers
operator|.
name|clear
argument_list|()
expr_stmt|;
break|break;
block|}
name|String
name|serverAddress
init|=
name|Writables
operator|.
name|bytesToString
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
name|servers
operator|.
name|put
argument_list|(
name|regionInfo
operator|.
name|getStartKey
argument_list|()
argument_list|,
operator|new
name|HRegionLocation
argument_list|(
name|regionInfo
argument_list|,
operator|new
name|HServerAddress
argument_list|(
name|serverAddress
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
comment|// no retries left
if|if
condition|(
name|e
operator|instanceof
name|RemoteException
condition|)
block|{
name|e
operator|=
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
operator|(
name|RemoteException
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|scannerId
operator|!=
operator|-
literal|1L
condition|)
block|{
try|try
block|{
name|server
operator|.
name|close
argument_list|(
name|scannerId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|servers
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|NoServerForRegionException
argument_list|(
literal|"failed to find server for "
operator|+
name|tableName
operator|+
literal|" after "
operator|+
name|numRetries
operator|+
literal|" retries"
argument_list|)
throw|;
block|}
if|if
condition|(
name|servers
operator|.
name|size
argument_list|()
operator|<=
literal|0
condition|)
block|{
comment|// The table is not yet being served. Sleep and retry.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sleeping. Table "
operator|+
name|tableName
operator|+
literal|" not currently being served."
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|pause
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
comment|// continue
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Wake. Retry finding table "
operator|+
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|servers
return|;
block|}
block|}
block|}
end_class

end_unit

