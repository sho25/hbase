begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2009 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|Thread
operator|.
name|UncaughtExceptionHandler
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|ManagementFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|MemoryUsage
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|RuntimeMXBean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|BindException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Chore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HMsg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerAddress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerLoad
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|LeaseListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Leases
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|LocalHBaseCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NotServingRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|RegionHistorian
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|RemoteExceptionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|UnknownRowLockException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|UnknownScannerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HMsg
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Leases
operator|.
name|LeaseStillHeldException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Delete
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Get
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Put
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Scan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ServerConnection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ServerConnectionManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|LruBlockCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HBaseRPC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HBaseRPCErrorHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HBaseRPCProtocolVersion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HBaseServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HMasterRegionInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HRegionInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|metrics
operator|.
name|RegionServerMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|InfoServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Sleeper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperWrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|MapWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|DNS
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Progressable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|WatchedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|Watcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|Watcher
operator|.
name|Event
operator|.
name|EventType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|Watcher
operator|.
name|Event
operator|.
name|KeeperState
import|;
end_import

begin_comment
comment|/**  * HRegionServer makes a set of HRegions available to clients.  It checks in with  * the HMaster. There are many HRegionServers in a single HBase deployment.  */
end_comment

begin_class
specifier|public
class|class
name|HRegionServer
implements|implements
name|HConstants
implements|,
name|HRegionInterface
implements|,
name|HBaseRPCErrorHandler
implements|,
name|Runnable
implements|,
name|Watcher
block|{
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HRegionServer
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|HMsg
name|REPORT_EXITING
init|=
operator|new
name|HMsg
argument_list|(
name|Type
operator|.
name|MSG_REPORT_EXITING
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|HMsg
name|REPORT_QUIESCED
init|=
operator|new
name|HMsg
argument_list|(
name|Type
operator|.
name|MSG_REPORT_QUIESCED
argument_list|)
decl_stmt|;
comment|// Set when a report to the master comes back with a message asking us to
comment|// shutdown.  Also set by call to stop when debugging or running unit tests
comment|// of HRegionServer in isolation. We use AtomicBoolean rather than
comment|// plain boolean so we can pass a reference to Chore threads.  Otherwise,
comment|// Chore threads need to know about the hosting class.
specifier|protected
specifier|final
name|AtomicBoolean
name|stopRequested
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|protected
specifier|final
name|AtomicBoolean
name|quiesced
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|protected
specifier|final
name|AtomicBoolean
name|safeMode
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|// Go down hard.  Used if file system becomes unavailable and also in
comment|// debugging and unit tests.
specifier|protected
specifier|volatile
name|boolean
name|abortRequested
decl_stmt|;
comment|// If false, the file system has become unavailable
specifier|protected
specifier|volatile
name|boolean
name|fsOk
decl_stmt|;
specifier|protected
name|HServerInfo
name|serverInfo
decl_stmt|;
specifier|protected
specifier|final
name|HBaseConfiguration
name|conf
decl_stmt|;
specifier|private
specifier|final
name|ServerConnection
name|connection
decl_stmt|;
specifier|protected
specifier|final
name|AtomicBoolean
name|haveRootRegion
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|private
name|FileSystem
name|fs
decl_stmt|;
specifier|private
name|Path
name|rootDir
decl_stmt|;
specifier|private
specifier|final
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
comment|// Key is Bytes.hashCode of region name byte array and the value is HRegion
comment|// in both of the maps below.  Use Bytes.mapKey(byte []) generating key for
comment|// below maps.
specifier|protected
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|HRegion
argument_list|>
name|onlineRegions
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|Integer
argument_list|,
name|HRegion
argument_list|>
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|ReentrantReadWriteLock
name|lock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|HMsg
argument_list|>
name|outboundMsgs
init|=
name|Collections
operator|.
name|synchronizedList
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|HMsg
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numRetries
decl_stmt|;
specifier|protected
specifier|final
name|int
name|threadWakeFrequency
decl_stmt|;
specifier|private
specifier|final
name|int
name|msgInterval
decl_stmt|;
specifier|private
specifier|final
name|int
name|serverLeaseTimeout
decl_stmt|;
specifier|protected
specifier|final
name|int
name|numRegionsToReport
decl_stmt|;
comment|// Remote HMaster
specifier|private
name|HMasterRegionInterface
name|hbaseMaster
decl_stmt|;
comment|// Server to handle client requests.  Default access so can be accessed by
comment|// unit tests.
name|HBaseServer
name|server
decl_stmt|;
comment|// Leases
specifier|private
name|Leases
name|leases
decl_stmt|;
comment|// Request counter
specifier|private
specifier|volatile
name|AtomicInteger
name|requestCount
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|// Info server.  Default access so can be used by unit tests.  REGIONSERVER
comment|// is name of the webapp and the attribute name used stuffing this instance
comment|// into web context.
name|InfoServer
name|infoServer
decl_stmt|;
comment|/** region server process name */
specifier|public
specifier|static
specifier|final
name|String
name|REGIONSERVER
init|=
literal|"regionserver"
decl_stmt|;
comment|/*    * Space is reserved in HRS constructor and then released when aborting    * to recover from an OOME. See HBASE-706.  TODO: Make this percentage of the    * heap or a minimum.    */
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|byte
index|[]
argument_list|>
name|reservedSpace
init|=
operator|new
name|LinkedList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|RegionServerMetrics
name|metrics
decl_stmt|;
comment|// Compactions
name|CompactSplitThread
name|compactSplitThread
decl_stmt|;
comment|// Cache flushing
name|MemStoreFlusher
name|cacheFlusher
decl_stmt|;
comment|/* Check for major compactions.    */
name|Chore
name|majorCompactionChecker
decl_stmt|;
comment|// HLog and HLog roller.  log is protected rather than private to avoid
comment|// eclipse warning when accessed by inner classes
specifier|protected
specifier|volatile
name|HLog
name|hlog
decl_stmt|;
name|LogRoller
name|hlogRoller
decl_stmt|;
name|LogFlusher
name|hlogFlusher
decl_stmt|;
comment|// limit compactions while starting up
name|CompactionLimitThread
name|compactionLimitThread
decl_stmt|;
comment|// flag set after we're done setting up server threads (used for testing)
specifier|protected
specifier|volatile
name|boolean
name|isOnline
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|InternalScanner
argument_list|>
name|scanners
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|InternalScanner
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|ZooKeeperWrapper
name|zooKeeperWrapper
decl_stmt|;
comment|// A sleeper that sleeps for msgInterval.
specifier|private
specifier|final
name|Sleeper
name|sleeper
decl_stmt|;
specifier|private
specifier|final
name|long
name|rpcTimeout
decl_stmt|;
comment|// Address passed in to constructor.
specifier|private
specifier|final
name|HServerAddress
name|address
decl_stmt|;
comment|// The main region server thread.
specifier|private
name|Thread
name|regionServerThread
decl_stmt|;
comment|// Run HDFS shutdown thread on exit if this is set. We clear this out when
comment|// doing a restart() to prevent closing of HDFS.
specifier|private
specifier|final
name|AtomicBoolean
name|shutdownHDFS
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|String
name|machineName
decl_stmt|;
comment|/**    * Starts a HRegionServer at the default location    * @param conf    * @throws IOException    */
specifier|public
name|HRegionServer
parameter_list|(
name|HBaseConfiguration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|machineName
operator|=
name|DNS
operator|.
name|getDefaultHost
argument_list|(
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.regionserver.dns.interface"
argument_list|,
literal|"default"
argument_list|)
argument_list|,
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.regionserver.dns.nameserver"
argument_list|,
literal|"default"
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|addressStr
init|=
name|machineName
operator|+
literal|":"
operator|+
name|conf
operator|.
name|get
argument_list|(
name|REGIONSERVER_PORT
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|DEFAULT_REGIONSERVER_PORT
argument_list|)
argument_list|)
decl_stmt|;
name|this
operator|.
name|address
operator|=
operator|new
name|HServerAddress
argument_list|(
name|addressStr
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"My address is "
operator|+
name|address
argument_list|)
expr_stmt|;
name|this
operator|.
name|abortRequested
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|fsOk
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|connection
operator|=
name|ServerConnectionManager
operator|.
name|getConnection
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|isOnline
operator|=
literal|false
expr_stmt|;
comment|// Config'ed params
name|this
operator|.
name|numRetries
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.client.retries.number"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|this
operator|.
name|threadWakeFrequency
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|THREAD_WAKE_FREQUENCY
argument_list|,
literal|10
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|this
operator|.
name|msgInterval
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.msginterval"
argument_list|,
literal|3
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|this
operator|.
name|serverLeaseTimeout
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.lease.period"
argument_list|,
literal|120
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|sleeper
operator|=
operator|new
name|Sleeper
argument_list|(
name|this
operator|.
name|msgInterval
argument_list|,
name|this
operator|.
name|stopRequested
argument_list|)
expr_stmt|;
comment|// Task thread to process requests from Master
name|this
operator|.
name|worker
operator|=
operator|new
name|Worker
argument_list|()
expr_stmt|;
name|this
operator|.
name|numRegionsToReport
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.numregionstoreport"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|this
operator|.
name|rpcTimeout
operator|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.regionserver.lease.period"
argument_list|,
literal|60000
argument_list|)
expr_stmt|;
name|reinitialize
argument_list|()
expr_stmt|;
block|}
comment|/**    * Creates all of the state that needs to be reconstructed in case we are    * doing a restart. This is shared between the constructor and restart().    * @throws IOException    */
specifier|private
name|void
name|reinitialize
parameter_list|()
throws|throws
name|IOException
block|{
name|abortRequested
operator|=
literal|false
expr_stmt|;
name|stopRequested
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|shutdownHDFS
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Server to handle client requests
name|this
operator|.
name|server
operator|=
name|HBaseRPC
operator|.
name|getServer
argument_list|(
name|this
argument_list|,
name|address
operator|.
name|getBindAddress
argument_list|()
argument_list|,
name|address
operator|.
name|getPort
argument_list|()
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.handler.count"
argument_list|,
literal|10
argument_list|)
argument_list|,
literal|false
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|server
operator|.
name|setErrorHandler
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Address is givin a default IP for the moment. Will be changed after
comment|// calling the master.
name|this
operator|.
name|serverInfo
operator|=
operator|new
name|HServerInfo
argument_list|(
operator|new
name|HServerAddress
argument_list|(
operator|new
name|InetSocketAddress
argument_list|(
name|address
operator|.
name|getBindAddress
argument_list|()
argument_list|,
name|this
operator|.
name|server
operator|.
name|getListenerAddress
argument_list|()
operator|.
name|getPort
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|,
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.info.port"
argument_list|,
literal|60030
argument_list|)
argument_list|,
name|machineName
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Server address cannot be null; "
operator|+
literal|"hbase-958 debugging"
argument_list|)
throw|;
block|}
name|reinitializeThreads
argument_list|()
expr_stmt|;
name|reinitializeZooKeeper
argument_list|()
expr_stmt|;
name|int
name|nbBlocks
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.nbreservationblocks"
argument_list|,
literal|4
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nbBlocks
condition|;
name|i
operator|++
control|)
block|{
name|reservedSpace
operator|.
name|add
argument_list|(
operator|new
name|byte
index|[
name|DEFAULT_SIZE_RESERVATION_BLOCK
index|]
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|reinitializeZooKeeper
parameter_list|()
throws|throws
name|IOException
block|{
name|zooKeeperWrapper
operator|=
operator|new
name|ZooKeeperWrapper
argument_list|(
name|conf
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|watchMasterAddress
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|reinitializeThreads
parameter_list|()
block|{
name|this
operator|.
name|workerThread
operator|=
operator|new
name|Thread
argument_list|(
name|worker
argument_list|)
expr_stmt|;
comment|// Cache flushing thread.
name|this
operator|.
name|cacheFlusher
operator|=
operator|new
name|MemStoreFlusher
argument_list|(
name|conf
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|// Compaction thread
name|this
operator|.
name|compactSplitThread
operator|=
operator|new
name|CompactSplitThread
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Log rolling thread
name|this
operator|.
name|hlogRoller
operator|=
operator|new
name|LogRoller
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Log flushing thread
name|this
operator|.
name|hlogFlusher
operator|=
operator|new
name|LogFlusher
argument_list|(
name|this
operator|.
name|threadWakeFrequency
argument_list|,
name|this
operator|.
name|stopRequested
argument_list|)
expr_stmt|;
comment|// Background thread to check for major compactions; needed if region
comment|// has not gotten updates in a while.  Make it run at a lesser frequency.
name|int
name|multiplier
init|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
name|THREAD_WAKE_FREQUENCY
operator|+
literal|".multiplier"
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
name|this
operator|.
name|majorCompactionChecker
operator|=
operator|new
name|MajorCompactionChecker
argument_list|(
name|this
argument_list|,
name|this
operator|.
name|threadWakeFrequency
operator|*
name|multiplier
argument_list|,
name|this
operator|.
name|stopRequested
argument_list|)
expr_stmt|;
name|this
operator|.
name|leases
operator|=
operator|new
name|Leases
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.lease.period"
argument_list|,
literal|60
operator|*
literal|1000
argument_list|)
argument_list|,
name|this
operator|.
name|threadWakeFrequency
argument_list|)
expr_stmt|;
block|}
comment|/**    * We register ourselves as a watcher on the master address ZNode. This is    * called by ZooKeeper when we get an event on that ZNode. When this method    * is called it means either our master has died, or a new one has come up.    * Either way we need to update our knowledge of the master.    * @param event WatchedEvent from ZooKeeper.    */
specifier|public
name|void
name|process
parameter_list|(
name|WatchedEvent
name|event
parameter_list|)
block|{
name|EventType
name|type
init|=
name|event
operator|.
name|getType
argument_list|()
decl_stmt|;
name|KeeperState
name|state
init|=
name|event
operator|.
name|getState
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Got ZooKeeper event, state: "
operator|+
name|state
operator|+
literal|", type: "
operator|+
name|type
operator|+
literal|", path: "
operator|+
name|event
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
comment|// Ignore events if we're shutting down.
if|if
condition|(
name|stopRequested
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ignoring ZooKeeper event while shutting down"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|state
operator|==
name|KeeperState
operator|.
name|Expired
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"ZooKeeper session expired"
argument_list|)
expr_stmt|;
name|restart
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|EventType
operator|.
name|NodeDeleted
condition|)
block|{
name|watchMasterAddress
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|EventType
operator|.
name|NodeCreated
condition|)
block|{
name|getMaster
argument_list|()
expr_stmt|;
comment|// ZooKeeper watches are one time only, so we need to re-register our watch.
name|watchMasterAddress
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|watchMasterAddress
parameter_list|()
block|{
while|while
condition|(
operator|!
name|stopRequested
operator|.
name|get
argument_list|()
operator|&&
operator|!
name|zooKeeperWrapper
operator|.
name|watchMasterAddress
argument_list|(
name|this
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to set watcher on ZooKeeper master address. Retrying."
argument_list|)
expr_stmt|;
name|sleeper
operator|.
name|sleep
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|restart
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Restarting Region Server"
argument_list|)
expr_stmt|;
name|shutdownHDFS
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
name|Threads
operator|.
name|shutdown
argument_list|(
name|regionServerThread
argument_list|)
expr_stmt|;
name|boolean
name|done
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
try|try
block|{
name|reinitialize
argument_list|()
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Error trying to reinitialize ZooKeeper"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|Thread
name|t
init|=
operator|new
name|Thread
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|String
name|name
init|=
name|regionServerThread
operator|.
name|getName
argument_list|()
decl_stmt|;
name|t
operator|.
name|setName
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|/** @return ZooKeeperWrapper used by RegionServer. */
specifier|public
name|ZooKeeperWrapper
name|getZooKeeperWrapper
parameter_list|()
block|{
return|return
name|zooKeeperWrapper
return|;
block|}
comment|/**    * The HRegionServer sticks in this loop until closed. It repeatedly checks    * in with the HMaster, sending heartbeats& reports, and receiving HRegion     * load/unload instructions.    */
specifier|public
name|void
name|run
parameter_list|()
block|{
name|regionServerThread
operator|=
name|Thread
operator|.
name|currentThread
argument_list|()
expr_stmt|;
name|boolean
name|quiesceRequested
init|=
literal|false
decl_stmt|;
try|try
block|{
name|init
argument_list|(
name|reportForDuty
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|lastMsg
init|=
literal|0
decl_stmt|;
comment|// Now ask master what it wants us to do and tell it what we have done
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
operator|!
name|stopRequested
operator|.
name|get
argument_list|()
operator|&&
name|isHealthy
argument_list|()
condition|;
control|)
block|{
comment|// Try to get the root region location from the master.
if|if
condition|(
operator|!
name|haveRootRegion
operator|.
name|get
argument_list|()
condition|)
block|{
name|HServerAddress
name|rootServer
init|=
name|zooKeeperWrapper
operator|.
name|readRootRegionLocation
argument_list|()
decl_stmt|;
if|if
condition|(
name|rootServer
operator|!=
literal|null
condition|)
block|{
comment|// By setting the root region location, we bypass the wait imposed on
comment|// HTable for all regions being assigned.
name|this
operator|.
name|connection
operator|.
name|setRootRegionLocation
argument_list|(
operator|new
name|HRegionLocation
argument_list|(
name|HRegionInfo
operator|.
name|ROOT_REGIONINFO
argument_list|,
name|rootServer
argument_list|)
argument_list|)
expr_stmt|;
name|haveRootRegion
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastMsg
operator|!=
literal|0
operator|&&
operator|(
name|now
operator|-
name|lastMsg
operator|)
operator|>=
name|serverLeaseTimeout
condition|)
block|{
comment|// It has been way too long since we last reported to the master.
name|LOG
operator|.
name|warn
argument_list|(
literal|"unable to report to master for "
operator|+
operator|(
name|now
operator|-
name|lastMsg
operator|)
operator|+
literal|" milliseconds - retrying"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|now
operator|-
name|lastMsg
operator|)
operator|>=
name|msgInterval
condition|)
block|{
name|HMsg
name|outboundArray
index|[]
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|outboundMsgs
init|)
block|{
name|outboundArray
operator|=
name|this
operator|.
name|outboundMsgs
operator|.
name|toArray
argument_list|(
operator|new
name|HMsg
index|[
name|outboundMsgs
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
name|this
operator|.
name|outboundMsgs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|doMetrics
argument_list|()
expr_stmt|;
name|MemoryUsage
name|memory
init|=
name|ManagementFactory
operator|.
name|getMemoryMXBean
argument_list|()
operator|.
name|getHeapMemoryUsage
argument_list|()
decl_stmt|;
name|HServerLoad
name|hsl
init|=
operator|new
name|HServerLoad
argument_list|(
name|requestCount
operator|.
name|get
argument_list|()
argument_list|,
call|(
name|int
call|)
argument_list|(
name|memory
operator|.
name|getUsed
argument_list|()
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|memory
operator|.
name|getMax
argument_list|()
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|HRegion
name|r
range|:
name|onlineRegions
operator|.
name|values
argument_list|()
control|)
block|{
name|hsl
operator|.
name|addRegionInfo
argument_list|(
name|createRegionLoad
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|serverInfo
operator|.
name|setLoad
argument_list|(
name|hsl
argument_list|)
expr_stmt|;
name|this
operator|.
name|requestCount
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|HMsg
name|msgs
index|[]
init|=
name|hbaseMaster
operator|.
name|regionServerReport
argument_list|(
name|serverInfo
argument_list|,
name|outboundArray
argument_list|,
name|getMostLoadedRegions
argument_list|()
argument_list|)
decl_stmt|;
name|lastMsg
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|quiesced
operator|.
name|get
argument_list|()
operator|&&
name|onlineRegions
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// We've just told the master we're exiting because we aren't
comment|// serving any regions. So set the stop bit and exit.
name|LOG
operator|.
name|info
argument_list|(
literal|"Server quiesced and not serving any regions. "
operator|+
literal|"Starting shutdown"
argument_list|)
expr_stmt|;
name|stopRequested
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|outboundMsgs
operator|.
name|clear
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|// Queue up the HMaster's instruction stream for processing
name|boolean
name|restart
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
operator|!
name|restart
operator|&&
operator|!
name|stopRequested
operator|.
name|get
argument_list|()
operator|&&
name|i
operator|<
name|msgs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|msgs
index|[
name|i
index|]
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|safeMode
operator|.
name|get
argument_list|()
condition|)
block|{
if|if
condition|(
name|zooKeeperWrapper
operator|.
name|checkOutOfSafeMode
argument_list|()
condition|)
block|{
name|this
operator|.
name|connection
operator|.
name|unsetRootRegionLocation
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|safeMode
init|)
block|{
name|safeMode
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|safeMode
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
switch|switch
condition|(
name|msgs
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|MSG_CALL_SERVER_STARTUP
case|:
comment|// We the MSG_CALL_SERVER_STARTUP on startup but we can also
comment|// get it when the master is panicking because for instance
comment|// the HDFS has been yanked out from under it.  Be wary of
comment|// this message.
if|if
condition|(
name|checkFileSystem
argument_list|()
condition|)
block|{
name|closeAllRegions
argument_list|()
expr_stmt|;
try|try
block|{
name|hlog
operator|.
name|closeAndDelete
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"error closing and deleting HLog"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|serverInfo
operator|.
name|setStartCode
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|hlog
operator|=
name|setupHLog
argument_list|()
expr_stmt|;
name|this
operator|.
name|hlogFlusher
operator|.
name|setHLog
argument_list|(
name|hlog
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|this
operator|.
name|abortRequested
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|stopRequested
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|e
operator|=
name|RemoteExceptionHandler
operator|.
name|checkIOException
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|fatal
argument_list|(
literal|"error restarting server"
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
name|reportForDuty
argument_list|()
expr_stmt|;
name|restart
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"file system available check failed. "
operator|+
literal|"Shutting down server."
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MSG_REGIONSERVER_STOP
case|:
name|stopRequested
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_REGIONSERVER_QUIESCE
case|:
if|if
condition|(
operator|!
name|quiesceRequested
condition|)
block|{
try|try
block|{
name|toDo
operator|.
name|put
argument_list|(
operator|new
name|ToDoEntry
argument_list|(
name|msgs
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Putting into msgQueue was "
operator|+
literal|"interrupted."
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|quiesceRequested
operator|=
literal|true
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|fsOk
condition|)
block|{
try|try
block|{
name|toDo
operator|.
name|put
argument_list|(
operator|new
name|ToDoEntry
argument_list|(
name|msgs
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Putting into msgQueue was "
operator|+
literal|"interrupted."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|// Reset tries count if we had a successful transaction.
name|tries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|restart
operator|||
name|this
operator|.
name|stopRequested
operator|.
name|get
argument_list|()
condition|)
block|{
name|toDo
operator|.
name|clear
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|IOException
condition|)
block|{
name|e
operator|=
name|RemoteExceptionHandler
operator|.
name|checkIOException
argument_list|(
operator|(
name|IOException
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tries
operator|<
name|this
operator|.
name|numRetries
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Processing message (Retry: "
operator|+
name|tries
operator|+
literal|")"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|tries
operator|++
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exceeded max retries: "
operator|+
name|this
operator|.
name|numRetries
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|checkFileSystem
argument_list|()
condition|)
block|{
comment|// Filesystem is OK.  Something is up w/ ZK or master.  Sleep
comment|// a little while if only to stop our logging many times a
comment|// millisecond.
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|this
operator|.
name|stopRequested
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stop was requested, clearing the toDo "
operator|+
literal|"despite of the exception"
argument_list|)
expr_stmt|;
name|toDo
operator|.
name|clear
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
block|}
comment|// Do some housekeeping before going to sleep
name|housekeeping
argument_list|()
expr_stmt|;
name|sleeper
operator|.
name|sleep
argument_list|(
name|lastMsg
argument_list|)
expr_stmt|;
block|}
comment|// for
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|checkOOME
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Unhandled exception. Aborting..."
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|RegionHistorian
operator|.
name|getInstance
argument_list|()
operator|.
name|offline
argument_list|()
expr_stmt|;
name|this
operator|.
name|leases
operator|.
name|closeAfterLeasesExpire
argument_list|()
expr_stmt|;
name|this
operator|.
name|worker
operator|.
name|stop
argument_list|()
expr_stmt|;
name|this
operator|.
name|server
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|infoServer
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping infoServer"
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|infoServer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Send cache a shutdown.
name|LruBlockCache
name|c
init|=
operator|(
name|LruBlockCache
operator|)
name|StoreFile
operator|.
name|getBlockCache
argument_list|(
name|this
operator|.
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
name|c
operator|.
name|shutdown
argument_list|()
expr_stmt|;
comment|// Send interrupts to wake up threads if sleeping so they notice shutdown.
comment|// TODO: Should we check they are alive?  If OOME could have exited already
name|cacheFlusher
operator|.
name|interruptIfNecessary
argument_list|()
expr_stmt|;
name|hlogFlusher
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|compactSplitThread
operator|.
name|interruptIfNecessary
argument_list|()
expr_stmt|;
name|hlogRoller
operator|.
name|interruptIfNecessary
argument_list|()
expr_stmt|;
name|this
operator|.
name|majorCompactionChecker
operator|.
name|interrupt
argument_list|()
expr_stmt|;
if|if
condition|(
name|abortRequested
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|fsOk
condition|)
block|{
comment|// Only try to clean up if the file system is available
try|try
block|{
if|if
condition|(
name|this
operator|.
name|hlog
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|hlog
operator|.
name|close
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"On abort, closed hlog"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to close log in abort"
argument_list|,
name|RemoteExceptionHandler
operator|.
name|checkThrowable
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|closeAllRegions
argument_list|()
expr_stmt|;
comment|// Don't leave any open file handles
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"aborting server at: "
operator|+
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ArrayList
argument_list|<
name|HRegion
argument_list|>
name|closedRegions
init|=
name|closeAllRegions
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|this
operator|.
name|hlog
operator|!=
literal|null
condition|)
block|{
name|hlog
operator|.
name|closeAndDelete
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Close and delete failed"
argument_list|,
name|RemoteExceptionHandler
operator|.
name|checkThrowable
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|HMsg
index|[]
name|exitMsg
init|=
operator|new
name|HMsg
index|[
name|closedRegions
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
decl_stmt|;
name|exitMsg
index|[
literal|0
index|]
operator|=
name|REPORT_EXITING
expr_stmt|;
comment|// Tell the master what regions we are/were serving
name|int
name|i
init|=
literal|1
decl_stmt|;
for|for
control|(
name|HRegion
name|region
range|:
name|closedRegions
control|)
block|{
name|exitMsg
index|[
name|i
operator|++
index|]
operator|=
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|Type
operator|.
name|MSG_REPORT_CLOSE
argument_list|,
name|region
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"telling master that region server is shutting down at: "
operator|+
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|hbaseMaster
operator|.
name|regionServerReport
argument_list|(
name|serverInfo
argument_list|,
name|exitMsg
argument_list|,
operator|(
name|HRegionInfo
index|[]
operator|)
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to send exiting message to master: "
argument_list|,
name|RemoteExceptionHandler
operator|.
name|checkThrowable
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"stopping server at: "
operator|+
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|hbaseMaster
operator|!=
literal|null
condition|)
block|{
name|HBaseRPC
operator|.
name|stopProxy
argument_list|(
name|this
operator|.
name|hbaseMaster
argument_list|)
expr_stmt|;
name|this
operator|.
name|hbaseMaster
operator|=
literal|null
expr_stmt|;
block|}
name|join
argument_list|()
expr_stmt|;
name|zooKeeperWrapper
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|shutdownHDFS
operator|.
name|get
argument_list|()
condition|)
block|{
name|runThread
argument_list|(
name|this
operator|.
name|hdfsShutdownThread
argument_list|,
name|this
operator|.
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.dfs.shutdown.wait"
argument_list|,
literal|30000
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" exiting"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Run and wait on passed thread in HRS context.    * @param t    * @param dfsShutdownWait    */
specifier|public
name|void
name|runThread
parameter_list|(
specifier|final
name|Thread
name|t
parameter_list|,
specifier|final
name|long
name|dfsShutdownWait
parameter_list|)
block|{
if|if
condition|(
name|t
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
name|Threads
operator|.
name|shutdown
argument_list|(
name|t
argument_list|,
name|dfsShutdownWait
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the hdfs shutdown thread to run on exit.  Pass null to disable    * running of the shutdown test.  Needed by tests.    * @param t Thread to run.  Pass null to disable tests.    * @return Previous occupant of the shutdown thread position.    */
specifier|public
name|Thread
name|setHDFSShutdownThreadOnExit
parameter_list|(
specifier|final
name|Thread
name|t
parameter_list|)
block|{
name|Thread
name|old
init|=
name|this
operator|.
name|hdfsShutdownThread
decl_stmt|;
name|this
operator|.
name|hdfsShutdownThread
operator|=
name|t
expr_stmt|;
return|return
name|old
return|;
block|}
comment|/*    * Run init. Sets up hlog and starts up all server threads.    * @param c Extra configuration.    */
specifier|protected
name|void
name|init
parameter_list|(
specifier|final
name|MapWritable
name|c
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Writable
argument_list|,
name|Writable
argument_list|>
name|e
range|:
name|c
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|value
init|=
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Config from master: "
operator|+
name|key
operator|+
literal|"="
operator|+
name|value
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|conf
operator|.
name|set
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|// Master may have sent us a new address with the other configs.
comment|// Update our address in this case. See HBASE-719
if|if
condition|(
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.regionserver.address"
argument_list|)
operator|!=
literal|null
condition|)
name|serverInfo
operator|.
name|setServerAddress
argument_list|(
operator|new
name|HServerAddress
argument_list|(
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.regionserver.address"
argument_list|)
argument_list|,
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|getPort
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Master sent us hbase.rootdir to use. Should be fully qualified
comment|// path with file system specification included.  Set 'fs.default.name'
comment|// to match the filesystem on hbase.rootdir else underlying hadoop hdfs
comment|// accessors will be going against wrong filesystem (unless all is set
comment|// to defaults).
name|this
operator|.
name|conf
operator|.
name|set
argument_list|(
literal|"fs.default.name"
argument_list|,
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.rootdir"
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|fs
operator|=
name|FileSystem
operator|.
name|get
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
comment|// Register shutdown hook for HRegionServer, runs an orderly shutdown
comment|// when a kill signal is recieved
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|addShutdownHook
argument_list|(
operator|new
name|ShutdownThread
argument_list|(
name|this
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|hdfsShutdownThread
operator|=
name|suppressHdfsShutdownHook
argument_list|()
expr_stmt|;
name|this
operator|.
name|rootDir
operator|=
operator|new
name|Path
argument_list|(
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|HBASE_DIR
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|hlog
operator|=
name|setupHLog
argument_list|()
expr_stmt|;
name|this
operator|.
name|hlogFlusher
operator|.
name|setHLog
argument_list|(
name|hlog
argument_list|)
expr_stmt|;
comment|// Init in here rather than in constructor after thread name has been set
name|this
operator|.
name|metrics
operator|=
operator|new
name|RegionServerMetrics
argument_list|()
expr_stmt|;
name|startServiceThreads
argument_list|()
expr_stmt|;
name|isOnline
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|this
operator|.
name|isOnline
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|stopRequested
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|e
argument_list|,
literal|"Failed init"
argument_list|)
argument_list|,
literal|"Region server startup failed"
argument_list|)
throw|;
block|}
block|}
comment|/*    * @param r Region to get RegionLoad for.    * @return RegionLoad instance.    * @throws IOException    */
specifier|private
name|HServerLoad
operator|.
name|RegionLoad
name|createRegionLoad
parameter_list|(
specifier|final
name|HRegion
name|r
parameter_list|)
block|{
name|byte
index|[]
name|name
init|=
name|r
operator|.
name|getRegionName
argument_list|()
decl_stmt|;
name|int
name|stores
init|=
literal|0
decl_stmt|;
name|int
name|storefiles
init|=
literal|0
decl_stmt|;
name|int
name|storefileSizeMB
init|=
literal|0
decl_stmt|;
name|int
name|memstoreSizeMB
init|=
call|(
name|int
call|)
argument_list|(
name|r
operator|.
name|memstoreSize
operator|.
name|get
argument_list|()
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
decl_stmt|;
name|int
name|storefileIndexSizeMB
init|=
literal|0
decl_stmt|;
synchronized|synchronized
init|(
name|r
operator|.
name|stores
init|)
block|{
name|stores
operator|+=
name|r
operator|.
name|stores
operator|.
name|size
argument_list|()
expr_stmt|;
for|for
control|(
name|Store
name|store
range|:
name|r
operator|.
name|stores
operator|.
name|values
argument_list|()
control|)
block|{
name|storefiles
operator|+=
name|store
operator|.
name|getStorefilesCount
argument_list|()
expr_stmt|;
name|storefileSizeMB
operator|+=
call|(
name|int
call|)
argument_list|(
name|store
operator|.
name|getStorefilesSize
argument_list|()
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|storefileIndexSizeMB
operator|+=
call|(
name|int
call|)
argument_list|(
name|store
operator|.
name|getStorefilesIndexSize
argument_list|()
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|HServerLoad
operator|.
name|RegionLoad
argument_list|(
name|name
argument_list|,
name|stores
argument_list|,
name|storefiles
argument_list|,
name|storefileSizeMB
argument_list|,
name|memstoreSizeMB
argument_list|,
name|storefileIndexSizeMB
argument_list|)
return|;
block|}
comment|/**    * @param regionName    * @return An instance of RegionLoad.    * @throws IOException    */
specifier|public
name|HServerLoad
operator|.
name|RegionLoad
name|createRegionLoad
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
block|{
return|return
name|createRegionLoad
argument_list|(
name|this
operator|.
name|onlineRegions
operator|.
name|get
argument_list|(
name|Bytes
operator|.
name|mapKey
argument_list|(
name|regionName
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/*    * Cleanup after Throwable caught invoking method.  Converts<code>t</code>    * to IOE if it isn't already.    * @param t Throwable    * @return Throwable converted to an IOE; methods can only let out IOEs.    */
specifier|private
name|Throwable
name|cleanup
parameter_list|(
specifier|final
name|Throwable
name|t
parameter_list|)
block|{
return|return
name|cleanup
argument_list|(
name|t
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/*    * Cleanup after Throwable caught invoking method.  Converts<code>t</code>    * to IOE if it isn't already.    * @param t Throwable    * @param msg Message to log in error.  Can be null.    * @return Throwable converted to an IOE; methods can only let out IOEs.    */
specifier|private
name|Throwable
name|cleanup
parameter_list|(
specifier|final
name|Throwable
name|t
parameter_list|,
specifier|final
name|String
name|msg
parameter_list|)
block|{
if|if
condition|(
name|msg
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|RemoteExceptionHandler
operator|.
name|checkThrowable
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|,
name|RemoteExceptionHandler
operator|.
name|checkThrowable
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|checkOOME
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|checkFileSystem
argument_list|()
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
comment|/*    * @param t    * @return Make<code>t</code> an IOE if it isn't already.    */
specifier|private
name|IOException
name|convertThrowableToIOE
parameter_list|(
specifier|final
name|Throwable
name|t
parameter_list|)
block|{
return|return
name|convertThrowableToIOE
argument_list|(
name|t
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/*    * @param t    * @param msg Message to put in new IOE if passed<code>t</code> is not an IOE    * @return Make<code>t</code> an IOE if it isn't already.    */
specifier|private
name|IOException
name|convertThrowableToIOE
parameter_list|(
specifier|final
name|Throwable
name|t
parameter_list|,
specifier|final
name|String
name|msg
parameter_list|)
block|{
return|return
operator|(
name|t
operator|instanceof
name|IOException
condition|?
operator|(
name|IOException
operator|)
name|t
else|:
name|msg
operator|==
literal|null
operator|||
name|msg
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|?
operator|new
name|IOException
argument_list|(
name|t
argument_list|)
else|:
operator|new
name|IOException
argument_list|(
name|msg
argument_list|,
name|t
argument_list|)
operator|)
return|;
block|}
comment|/*    * Check if an OOME and if so, call abort.    * @param e    * @return True if we OOME'd and are aborting.    */
specifier|public
name|boolean
name|checkOOME
parameter_list|(
specifier|final
name|Throwable
name|e
parameter_list|)
block|{
name|boolean
name|stop
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|OutOfMemoryError
operator|||
operator|(
name|e
operator|.
name|getCause
argument_list|()
operator|!=
literal|null
operator|&&
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|OutOfMemoryError
operator|)
operator|||
operator|(
name|e
operator|.
name|getMessage
argument_list|()
operator|!=
literal|null
operator|&&
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"java.lang.OutOfMemoryError"
argument_list|)
operator|)
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"OutOfMemoryError, aborting."
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
name|stop
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|stop
return|;
block|}
comment|/**    * Checks to see if the file system is still accessible.    * If not, sets abortRequested and stopRequested    *     * @return false if file system is not available    */
specifier|protected
name|boolean
name|checkFileSystem
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|fsOk
operator|&&
name|this
operator|.
name|fs
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|FSUtils
operator|.
name|checkFileSystemAvailable
argument_list|(
name|this
operator|.
name|fs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Shutting down HRegionServer: file system not available"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
name|this
operator|.
name|fsOk
operator|=
literal|false
expr_stmt|;
block|}
block|}
return|return
name|this
operator|.
name|fsOk
return|;
block|}
comment|/**    * Thread for toggling safemode after some configurable interval.    */
specifier|private
class|class
name|CompactionLimitThread
extends|extends
name|Thread
block|{
specifier|protected
name|CompactionLimitThread
parameter_list|()
block|{}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// First wait until we exit safe mode
synchronized|synchronized
init|(
name|safeMode
init|)
block|{
while|while
condition|(
name|safeMode
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting to exit safe mode"
argument_list|)
expr_stmt|;
try|try
block|{
name|safeMode
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
block|}
comment|// now that safemode is off, slowly increase the per-cycle compaction
comment|// limit, finally setting it to unlimited (-1)
name|int
name|compactionCheckInterval
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.thread.splitcompactcheckfrequency"
argument_list|,
literal|20
operator|*
literal|1000
argument_list|)
decl_stmt|;
specifier|final
name|int
name|limitSteps
index|[]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
operator|-
literal|1
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|limitSteps
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// Just log changes.
if|if
condition|(
name|compactSplitThread
operator|.
name|getLimit
argument_list|()
operator|!=
name|limitSteps
index|[
name|i
index|]
operator|&&
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"setting compaction limit to "
operator|+
name|limitSteps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|compactSplitThread
operator|.
name|setLimit
argument_list|(
name|limitSteps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|compactionCheckInterval
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
comment|// unlimit compactions before exiting
name|compactSplitThread
operator|.
name|setLimit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|this
operator|.
name|getName
argument_list|()
operator|+
literal|" exiting on interrupt"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"compactions no longer limited"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Thread to shutdown the region server in an orderly manner.  This thread    * is registered as a shutdown hook in the HRegionServer constructor and is    * only called when the HRegionServer receives a kill signal.    */
specifier|private
specifier|static
class|class
name|ShutdownThread
extends|extends
name|Thread
block|{
specifier|private
specifier|final
name|HRegionServer
name|instance
decl_stmt|;
specifier|private
specifier|final
name|Thread
name|mainThread
decl_stmt|;
comment|/**      * @param instance      * @param mainThread      */
specifier|public
name|ShutdownThread
parameter_list|(
name|HRegionServer
name|instance
parameter_list|,
name|Thread
name|mainThread
parameter_list|)
block|{
name|this
operator|.
name|instance
operator|=
name|instance
expr_stmt|;
name|this
operator|.
name|mainThread
operator|=
name|mainThread
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting shutdown thread."
argument_list|)
expr_stmt|;
comment|// tell the region server to stop
name|instance
operator|.
name|stop
argument_list|()
expr_stmt|;
comment|// Wait for main thread to exit.
name|Threads
operator|.
name|shutdown
argument_list|(
name|mainThread
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Shutdown thread complete"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// We need to call HDFS shutdown when we are done shutting down
specifier|private
name|Thread
name|hdfsShutdownThread
decl_stmt|;
comment|/*    * Inner class that runs on a long period checking if regions need major    * compaction.    */
specifier|private
specifier|static
class|class
name|MajorCompactionChecker
extends|extends
name|Chore
block|{
specifier|private
specifier|final
name|HRegionServer
name|instance
decl_stmt|;
name|MajorCompactionChecker
parameter_list|(
specifier|final
name|HRegionServer
name|h
parameter_list|,
specifier|final
name|int
name|sleepTime
parameter_list|,
specifier|final
name|AtomicBoolean
name|stopper
parameter_list|)
block|{
name|super
argument_list|(
name|sleepTime
argument_list|,
name|stopper
argument_list|)
expr_stmt|;
name|this
operator|.
name|instance
operator|=
name|h
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Runs every "
operator|+
name|sleepTime
operator|+
literal|"ms"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|chore
parameter_list|()
block|{
name|Set
argument_list|<
name|Integer
argument_list|>
name|keys
init|=
name|this
operator|.
name|instance
operator|.
name|onlineRegions
operator|.
name|keySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Integer
name|i
range|:
name|keys
control|)
block|{
name|HRegion
name|r
init|=
name|this
operator|.
name|instance
operator|.
name|onlineRegions
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
name|r
operator|.
name|isMajorCompaction
argument_list|()
condition|)
block|{
comment|// Queue a compaction.  Will recognize if major is needed.
name|this
operator|.
name|instance
operator|.
name|compactSplitThread
operator|.
name|compactionRequested
argument_list|(
name|r
argument_list|,
name|getName
argument_list|()
operator|+
literal|" requests major compaction"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed major compaction check on "
operator|+
name|r
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * So, HDFS caches FileSystems so when you call FileSystem.get it's fast. In    * order to make sure things are cleaned up, it also creates a shutdown hook    * so that all filesystems can be closed when the process is terminated. This    * conveniently runs concurrently with our own shutdown handler, and    * therefore causes all the filesystems to be closed before the server can do    * all its necessary cleanup.    *    * The crazy dirty reflection in this method sneaks into the FileSystem cache    * and grabs the shutdown hook, removes it from the list of active shutdown    * hooks, and hangs onto it until later. Then, after we're properly done with    * our graceful shutdown, we can execute the hdfs hook manually to make sure    * loose ends are tied up.    *    * This seems quite fragile and susceptible to breaking if Hadoop changes    * anything about the way this cleanup is managed. Keep an eye on things.    */
specifier|private
name|Thread
name|suppressHdfsShutdownHook
parameter_list|()
block|{
try|try
block|{
name|Field
name|field
init|=
name|FileSystem
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"clientFinalizer"
argument_list|)
decl_stmt|;
name|field
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Thread
name|hdfsClientFinalizer
init|=
operator|(
name|Thread
operator|)
name|field
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|hdfsClientFinalizer
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"client finalizer is null, can't suppress!"
argument_list|)
throw|;
block|}
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|removeShutdownHook
argument_list|(
name|hdfsClientFinalizer
argument_list|)
expr_stmt|;
return|return
name|hdfsClientFinalizer
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchFieldException
name|nsfe
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Couldn't find field 'clientFinalizer' in FileSystem!"
argument_list|,
name|nsfe
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Failed to suppress HDFS shutdown hook"
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|iae
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Couldn't access field 'clientFinalizer' in FileSystem!"
argument_list|,
name|iae
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Failed to suppress HDFS shutdown hook"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Report the status of the server. A server is online once all the startup     * is completed (setting up filesystem, starting service threads, etc.). This    * method is designed mostly to be useful in tests.    * @return true if online, false if not.    */
specifier|public
name|boolean
name|isOnline
parameter_list|()
block|{
return|return
name|isOnline
return|;
block|}
specifier|private
name|HLog
name|setupHLog
parameter_list|()
throws|throws
name|RegionServerRunningException
throws|,
name|IOException
block|{
name|Path
name|logdir
init|=
operator|new
name|Path
argument_list|(
name|rootDir
argument_list|,
name|HLog
operator|.
name|getHLogDirectoryName
argument_list|(
name|serverInfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Log dir "
operator|+
name|logdir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|logdir
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RegionServerRunningException
argument_list|(
literal|"region server already "
operator|+
literal|"running at "
operator|+
name|this
operator|.
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|" because logdir "
operator|+
name|logdir
operator|.
name|toString
argument_list|()
operator|+
literal|" exists"
argument_list|)
throw|;
block|}
name|HLog
name|newlog
init|=
name|instantiateHLog
argument_list|(
name|logdir
argument_list|)
decl_stmt|;
return|return
name|newlog
return|;
block|}
comment|// instantiate
specifier|protected
name|HLog
name|instantiateHLog
parameter_list|(
name|Path
name|logdir
parameter_list|)
throws|throws
name|IOException
block|{
name|HLog
name|newlog
init|=
operator|new
name|HLog
argument_list|(
name|fs
argument_list|,
name|logdir
argument_list|,
name|conf
argument_list|,
name|hlogRoller
argument_list|)
decl_stmt|;
return|return
name|newlog
return|;
block|}
specifier|protected
name|LogRoller
name|getLogRoller
parameter_list|()
block|{
return|return
name|hlogRoller
return|;
block|}
comment|/*    * @param interval Interval since last time metrics were called.    */
specifier|protected
name|void
name|doMetrics
parameter_list|()
block|{
try|try
block|{
name|metrics
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed metrics"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|metrics
parameter_list|()
block|{
name|this
operator|.
name|metrics
operator|.
name|regions
operator|.
name|set
argument_list|(
name|this
operator|.
name|onlineRegions
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|incrementRequests
argument_list|(
name|this
operator|.
name|requestCount
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
comment|// Is this too expensive every three seconds getting a lock on onlineRegions
comment|// and then per store carried?  Can I make metrics be sloppier and avoid
comment|// the synchronizations?
name|int
name|stores
init|=
literal|0
decl_stmt|;
name|int
name|storefiles
init|=
literal|0
decl_stmt|;
name|long
name|memstoreSize
init|=
literal|0
decl_stmt|;
name|long
name|storefileIndexSize
init|=
literal|0
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|onlineRegions
init|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|HRegion
argument_list|>
name|e
range|:
name|this
operator|.
name|onlineRegions
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|HRegion
name|r
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|memstoreSize
operator|+=
name|r
operator|.
name|memstoreSize
operator|.
name|get
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|r
operator|.
name|stores
init|)
block|{
name|stores
operator|+=
name|r
operator|.
name|stores
operator|.
name|size
argument_list|()
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|Store
argument_list|>
name|ee
range|:
name|r
operator|.
name|stores
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Store
name|store
init|=
name|ee
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|storefiles
operator|+=
name|store
operator|.
name|getStorefilesCount
argument_list|()
expr_stmt|;
name|storefileIndexSize
operator|+=
name|store
operator|.
name|getStorefilesIndexSize
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
name|this
operator|.
name|metrics
operator|.
name|stores
operator|.
name|set
argument_list|(
name|stores
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|storefiles
operator|.
name|set
argument_list|(
name|storefiles
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|memstoreSizeMB
operator|.
name|set
argument_list|(
call|(
name|int
call|)
argument_list|(
name|memstoreSize
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|storefileIndexSizeMB
operator|.
name|set
argument_list|(
call|(
name|int
call|)
argument_list|(
name|storefileIndexSize
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|LruBlockCache
name|lruBlockCache
init|=
operator|(
name|LruBlockCache
operator|)
name|StoreFile
operator|.
name|getBlockCache
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|lruBlockCache
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|metrics
operator|.
name|blockCacheCount
operator|.
name|set
argument_list|(
name|lruBlockCache
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|blockCacheFree
operator|.
name|set
argument_list|(
name|lruBlockCache
operator|.
name|getFreeSize
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|blockCacheSize
operator|.
name|set
argument_list|(
name|lruBlockCache
operator|.
name|getCurrentSize
argument_list|()
argument_list|)
expr_stmt|;
name|double
name|ratio
init|=
name|lruBlockCache
operator|.
name|getStats
argument_list|()
operator|.
name|getHitRatio
argument_list|()
decl_stmt|;
name|int
name|percent
init|=
call|(
name|int
call|)
argument_list|(
name|ratio
operator|*
literal|100
argument_list|)
decl_stmt|;
name|this
operator|.
name|metrics
operator|.
name|blockCacheHitRatio
operator|.
name|set
argument_list|(
name|percent
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @return Region server metrics instance.    */
specifier|public
name|RegionServerMetrics
name|getMetrics
parameter_list|()
block|{
return|return
name|this
operator|.
name|metrics
return|;
block|}
comment|/*    * Start maintanence Threads, Server, Worker and lease checker threads.    * Install an UncaughtExceptionHandler that calls abort of RegionServer if we    * get an unhandled exception.  We cannot set the handler on all threads.    * Server's internal Listener thread is off limits.  For Server, if an OOME,    * it waits a while then retries.  Meantime, a flush or a compaction that    * tries to run should trigger same critical condition and the shutdown will    * run.  On its way out, this server will shut down Server.  Leases are sort    * of inbetween. It has an internal thread that while it inherits from    * Chore, it keeps its own internal stop mechanism so needs to be stopped    * by this hosting server.  Worker logs the exception and exits.    */
specifier|private
name|void
name|startServiceThreads
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|n
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|UncaughtExceptionHandler
name|handler
init|=
operator|new
name|UncaughtExceptionHandler
argument_list|()
block|{
specifier|public
name|void
name|uncaughtException
parameter_list|(
name|Thread
name|t
parameter_list|,
name|Throwable
name|e
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Set stop flag in "
operator|+
name|t
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|this
operator|.
name|hlogRoller
argument_list|,
name|n
operator|+
literal|".logRoller"
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|this
operator|.
name|hlogFlusher
argument_list|,
name|n
operator|+
literal|".logFlusher"
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|this
operator|.
name|cacheFlusher
argument_list|,
name|n
operator|+
literal|".cacheFlusher"
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|this
operator|.
name|compactSplitThread
argument_list|,
name|n
operator|+
literal|".compactor"
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|this
operator|.
name|workerThread
argument_list|,
name|n
operator|+
literal|".worker"
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|this
operator|.
name|majorCompactionChecker
argument_list|,
name|n
operator|+
literal|".majorCompactionChecker"
argument_list|,
name|handler
argument_list|)
expr_stmt|;
comment|// Leases is not a Thread. Internally it runs a daemon thread.  If it gets
comment|// an unhandled exception, it will just exit.
name|this
operator|.
name|leases
operator|.
name|setName
argument_list|(
name|n
operator|+
literal|".leaseChecker"
argument_list|)
expr_stmt|;
name|this
operator|.
name|leases
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Put up info server.
name|int
name|port
init|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.info.port"
argument_list|,
literal|60030
argument_list|)
decl_stmt|;
comment|// -1 is for disabling info server
if|if
condition|(
name|port
operator|>=
literal|0
condition|)
block|{
name|String
name|addr
init|=
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.regionserver.info.bindAddress"
argument_list|,
literal|"0.0.0.0"
argument_list|)
decl_stmt|;
comment|// check if auto port bind enabled
name|boolean
name|auto
init|=
name|this
operator|.
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.regionserver.info.port.auto"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|this
operator|.
name|infoServer
operator|=
operator|new
name|InfoServer
argument_list|(
literal|"regionserver"
argument_list|,
name|addr
argument_list|,
name|port
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|setAttribute
argument_list|(
literal|"regionserver"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|start
argument_list|()
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|BindException
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|auto
condition|)
block|{
comment|// auto bind disabled throw BindException
throw|throw
name|e
throw|;
block|}
comment|// auto bind enabled, try to use another port
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed binding http info server to port: "
operator|+
name|port
argument_list|)
expr_stmt|;
name|port
operator|++
expr_stmt|;
comment|// update HRS server info
name|serverInfo
operator|.
name|setInfoPort
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Set up the safe mode handler if safe mode has been configured.
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.regionserver.safemode"
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|safeMode
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|compactSplitThread
operator|.
name|setLimit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"skipping safe mode"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|compactionLimitThread
operator|=
operator|new
name|CompactionLimitThread
argument_list|()
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|this
operator|.
name|compactionLimitThread
argument_list|,
name|n
operator|+
literal|".safeMode"
argument_list|,
name|handler
argument_list|)
expr_stmt|;
block|}
comment|// Start Server.  This service is like leases in that it internally runs
comment|// a thread.
name|this
operator|.
name|server
operator|.
name|start
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"HRegionServer started at: "
operator|+
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/*    * Verify that server is healthy    */
specifier|private
name|boolean
name|isHealthy
parameter_list|()
block|{
if|if
condition|(
operator|!
name|fsOk
condition|)
block|{
comment|// File system problem
return|return
literal|false
return|;
block|}
comment|// Verify that all threads are alive
if|if
condition|(
operator|!
operator|(
name|leases
operator|.
name|isAlive
argument_list|()
operator|&&
name|compactSplitThread
operator|.
name|isAlive
argument_list|()
operator|&&
name|cacheFlusher
operator|.
name|isAlive
argument_list|()
operator|&&
name|hlogRoller
operator|.
name|isAlive
argument_list|()
operator|&&
name|workerThread
operator|.
name|isAlive
argument_list|()
operator|&&
name|this
operator|.
name|majorCompactionChecker
operator|.
name|isAlive
argument_list|()
operator|)
condition|)
block|{
comment|// One or more threads are no longer alive - shut down
name|stop
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/*    * Run some housekeeping tasks before we go into 'hibernation' sleeping at    * the end of the main HRegionServer run loop.    */
specifier|private
name|void
name|housekeeping
parameter_list|()
block|{
comment|// If the todo list has> 0 messages, iterate looking for open region
comment|// messages. Send the master a message that we're working on its
comment|// processing so it doesn't assign the region elsewhere.
if|if
condition|(
name|this
operator|.
name|toDo
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// This iterator is 'safe'.  We are guaranteed a view on state of the
comment|// queue at time iterator was taken out.  Apparently goes from oldest.
for|for
control|(
name|ToDoEntry
name|e
range|:
name|this
operator|.
name|toDo
control|)
block|{
name|HMsg
name|msg
init|=
name|e
operator|.
name|msg
decl_stmt|;
if|if
condition|(
name|msg
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Message is empty: "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|.
name|msg
operator|.
name|isType
argument_list|(
name|HMsg
operator|.
name|Type
operator|.
name|MSG_REGION_OPEN
argument_list|)
condition|)
block|{
name|addProcessingMessage
argument_list|(
name|e
operator|.
name|msg
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** @return the HLog */
name|HLog
name|getLog
parameter_list|()
block|{
return|return
name|this
operator|.
name|hlog
return|;
block|}
comment|/**    * Sets a flag that will cause all the HRegionServer threads to shut down    * in an orderly fashion.  Used by unit tests.    */
specifier|public
name|void
name|stop
parameter_list|()
block|{
name|this
operator|.
name|stopRequested
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|notifyAll
argument_list|()
expr_stmt|;
comment|// Wakes run() if it is sleeping
block|}
block|}
comment|/**    * Cause the server to exit without closing the regions it is serving, the    * log it is using and without notifying the master.    * Used unit testing and on catastrophic events such as HDFS is yanked out    * from under hbase or we OOME.    */
specifier|public
name|void
name|abort
parameter_list|()
block|{
name|this
operator|.
name|abortRequested
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|reservedSpace
operator|.
name|clear
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Dump of metrics: "
operator|+
name|this
operator|.
name|metrics
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|stop
argument_list|()
expr_stmt|;
block|}
comment|/**     * Wait on all threads to finish.    * Presumption is that all closes and stops have already been called.    */
name|void
name|join
parameter_list|()
block|{
name|Threads
operator|.
name|shutdown
argument_list|(
name|this
operator|.
name|majorCompactionChecker
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|shutdown
argument_list|(
name|this
operator|.
name|workerThread
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|shutdown
argument_list|(
name|this
operator|.
name|cacheFlusher
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|shutdown
argument_list|(
name|this
operator|.
name|compactSplitThread
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|shutdown
argument_list|(
name|this
operator|.
name|hlogRoller
argument_list|)
expr_stmt|;
block|}
specifier|private
name|boolean
name|getMaster
parameter_list|()
block|{
name|HServerAddress
name|masterAddress
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|masterAddress
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|stopRequested
operator|.
name|get
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
try|try
block|{
name|masterAddress
operator|=
name|zooKeeperWrapper
operator|.
name|readMasterAddressOrThrow
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to read master address from ZooKeeper. Retrying."
operator|+
literal|" Error was:"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|sleeper
operator|.
name|sleep
argument_list|()
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Telling master at "
operator|+
name|masterAddress
operator|+
literal|" that we are up"
argument_list|)
expr_stmt|;
name|HMasterRegionInterface
name|master
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|!
name|stopRequested
operator|.
name|get
argument_list|()
operator|&&
name|master
operator|==
literal|null
condition|)
block|{
try|try
block|{
comment|// Do initial RPC setup.  The final argument indicates that the RPC
comment|// should retry indefinitely.
name|master
operator|=
operator|(
name|HMasterRegionInterface
operator|)
name|HBaseRPC
operator|.
name|waitForProxy
argument_list|(
name|HMasterRegionInterface
operator|.
name|class
argument_list|,
name|HBaseRPCProtocolVersion
operator|.
name|versionID
argument_list|,
name|masterAddress
operator|.
name|getInetSocketAddress
argument_list|()
argument_list|,
name|this
operator|.
name|conf
argument_list|,
operator|-
literal|1
argument_list|,
name|this
operator|.
name|rpcTimeout
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to connect to master. Retrying. Error was:"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|sleeper
operator|.
name|sleep
argument_list|()
expr_stmt|;
block|}
block|}
name|this
operator|.
name|hbaseMaster
operator|=
name|master
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/*    * Let the master know we're here    * Run initialization using parameters passed us by the master.    */
specifier|private
name|MapWritable
name|reportForDuty
parameter_list|()
block|{
while|while
condition|(
operator|!
name|stopRequested
operator|.
name|get
argument_list|()
operator|&&
operator|!
name|getMaster
argument_list|()
condition|)
block|{
name|sleeper
operator|.
name|sleep
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to get master for initialization"
argument_list|)
expr_stmt|;
block|}
name|MapWritable
name|result
init|=
literal|null
decl_stmt|;
name|long
name|lastMsg
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|stopRequested
operator|.
name|get
argument_list|()
condition|)
block|{
try|try
block|{
name|this
operator|.
name|requestCount
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MemoryUsage
name|memory
init|=
name|ManagementFactory
operator|.
name|getMemoryMXBean
argument_list|()
operator|.
name|getHeapMemoryUsage
argument_list|()
decl_stmt|;
name|HServerLoad
name|hsl
init|=
operator|new
name|HServerLoad
argument_list|(
literal|0
argument_list|,
operator|(
name|int
operator|)
name|memory
operator|.
name|getUsed
argument_list|()
operator|/
literal|1024
operator|/
literal|1024
argument_list|,
operator|(
name|int
operator|)
name|memory
operator|.
name|getMax
argument_list|()
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
decl_stmt|;
name|this
operator|.
name|serverInfo
operator|.
name|setLoad
argument_list|(
name|hsl
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"sending initial server load: "
operator|+
name|hsl
argument_list|)
expr_stmt|;
name|lastMsg
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|boolean
name|startCodeOk
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|startCodeOk
condition|)
block|{
name|serverInfo
operator|.
name|setStartCode
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|startCodeOk
operator|=
name|zooKeeperWrapper
operator|.
name|writeRSLocation
argument_list|(
name|serverInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|startCodeOk
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Start code already taken, trying another one"
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|=
name|this
operator|.
name|hbaseMaster
operator|.
name|regionServerStartup
argument_list|(
name|serverInfo
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|Leases
operator|.
name|LeaseStillHeldException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Lease "
operator|+
name|e
operator|.
name|getName
argument_list|()
operator|+
literal|" already held on master. Check "
operator|+
literal|"DNS configuration so that all region servers are"
operator|+
literal|"reporting their true IPs and not 127.0.0.1. Otherwise, this"
operator|+
literal|"problem should resolve itself after the lease period of "
operator|+
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.master.lease.period"
argument_list|)
operator|+
literal|" seconds expires over on the master"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"error telling master we are up"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|sleeper
operator|.
name|sleep
argument_list|(
name|lastMsg
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/* Add to the outbound message buffer */
specifier|private
name|void
name|reportOpen
parameter_list|(
name|HRegionInfo
name|region
parameter_list|)
block|{
name|outboundMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|Type
operator|.
name|MSG_REPORT_OPEN
argument_list|,
name|region
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add to the outbound message buffer */
specifier|private
name|void
name|reportClose
parameter_list|(
name|HRegionInfo
name|region
parameter_list|)
block|{
name|reportClose
argument_list|(
name|region
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/* Add to the outbound message buffer */
specifier|private
name|void
name|reportClose
parameter_list|(
specifier|final
name|HRegionInfo
name|region
parameter_list|,
specifier|final
name|byte
index|[]
name|message
parameter_list|)
block|{
name|outboundMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|Type
operator|.
name|MSG_REPORT_CLOSE
argument_list|,
name|region
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add to the outbound message buffer    *     * When a region splits, we need to tell the master that there are two new     * regions that need to be assigned.    *     * We do not need to inform the master about the old region, because we've    * updated the meta or root regions, and the master will pick that up on its    * next rescan of the root or meta tables.    */
name|void
name|reportSplit
parameter_list|(
name|HRegionInfo
name|oldRegion
parameter_list|,
name|HRegionInfo
name|newRegionA
parameter_list|,
name|HRegionInfo
name|newRegionB
parameter_list|)
block|{
name|outboundMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|Type
operator|.
name|MSG_REPORT_SPLIT
argument_list|,
name|oldRegion
argument_list|,
operator|(
literal|"Daughters; "
operator|+
name|newRegionA
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", "
operator|+
name|newRegionB
operator|.
name|getRegionNameAsString
argument_list|()
operator|)
operator|.
name|getBytes
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|outboundMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|Type
operator|.
name|MSG_REPORT_OPEN
argument_list|,
name|newRegionA
argument_list|)
argument_list|)
expr_stmt|;
name|outboundMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|Type
operator|.
name|MSG_REPORT_OPEN
argument_list|,
name|newRegionB
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//////////////////////////////////////////////////////////////////////////////
comment|// HMaster-given operations
comment|//////////////////////////////////////////////////////////////////////////////
comment|/*    * Data structure to hold a HMsg and retries count.    */
specifier|private
specifier|static
specifier|final
class|class
name|ToDoEntry
block|{
specifier|protected
specifier|final
name|AtomicInteger
name|tries
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|protected
specifier|final
name|HMsg
name|msg
decl_stmt|;
name|ToDoEntry
parameter_list|(
specifier|final
name|HMsg
name|msg
parameter_list|)
block|{
name|this
operator|.
name|msg
operator|=
name|msg
expr_stmt|;
block|}
block|}
specifier|final
name|BlockingQueue
argument_list|<
name|ToDoEntry
argument_list|>
name|toDo
init|=
operator|new
name|LinkedBlockingQueue
argument_list|<
name|ToDoEntry
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Worker
name|worker
decl_stmt|;
specifier|private
name|Thread
name|workerThread
decl_stmt|;
comment|/** Thread that performs long running requests from the master */
class|class
name|Worker
implements|implements
name|Runnable
block|{
name|void
name|stop
parameter_list|()
block|{
synchronized|synchronized
init|(
name|toDo
init|)
block|{
name|toDo
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
while|while
condition|(
operator|!
name|stopRequested
operator|.
name|get
argument_list|()
condition|)
block|{
name|ToDoEntry
name|e
init|=
literal|null
decl_stmt|;
try|try
block|{
name|e
operator|=
name|toDo
operator|.
name|poll
argument_list|(
name|threadWakeFrequency
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|stopRequested
operator|.
name|get
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Worker: "
operator|+
name|e
operator|.
name|msg
argument_list|)
expr_stmt|;
name|HRegion
name|region
init|=
literal|null
decl_stmt|;
name|HRegionInfo
name|info
init|=
name|e
operator|.
name|msg
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|e
operator|.
name|msg
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|MSG_REGIONSERVER_QUIESCE
case|:
name|closeUserRegions
argument_list|()
expr_stmt|;
break|break;
case|case
name|MSG_REGION_OPEN
case|:
comment|// Open a region
if|if
condition|(
operator|!
name|haveRootRegion
operator|.
name|get
argument_list|()
operator|&&
operator|!
name|info
operator|.
name|isRootRegion
argument_list|()
condition|)
block|{
comment|// root region is not online yet. requeue this task
name|LOG
operator|.
name|info
argument_list|(
literal|"putting region open request back into queue because"
operator|+
literal|" root region is not yet available"
argument_list|)
expr_stmt|;
try|try
block|{
name|toDo
operator|.
name|put
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"insertion into toDo queue was interrupted"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|openRegion
argument_list|(
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_REGION_CLOSE
case|:
comment|// Close a region
name|closeRegion
argument_list|(
name|e
operator|.
name|msg
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_REGION_CLOSE_WITHOUT_REPORT
case|:
comment|// Close a region, don't reply
name|closeRegion
argument_list|(
name|e
operator|.
name|msg
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_REGION_SPLIT
case|:
name|region
operator|=
name|getRegion
argument_list|(
name|info
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
name|region
operator|.
name|flushcache
argument_list|()
expr_stmt|;
name|region
operator|.
name|regionInfo
operator|.
name|shouldSplit
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// force a compaction; split will be side-effect.
name|compactSplitThread
operator|.
name|compactionRequested
argument_list|(
name|region
argument_list|,
name|e
operator|.
name|msg
operator|.
name|getType
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_REGION_MAJOR_COMPACT
case|:
case|case
name|MSG_REGION_COMPACT
case|:
comment|// Compact a region
name|region
operator|=
name|getRegion
argument_list|(
name|info
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
name|compactSplitThread
operator|.
name|compactionRequested
argument_list|(
name|region
argument_list|,
name|e
operator|.
name|msg
operator|.
name|isType
argument_list|(
name|Type
operator|.
name|MSG_REGION_MAJOR_COMPACT
argument_list|)
argument_list|,
name|e
operator|.
name|msg
operator|.
name|getType
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_REGION_FLUSH
case|:
name|region
operator|=
name|getRegion
argument_list|(
name|info
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
name|region
operator|.
name|flushcache
argument_list|()
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Impossible state during msg processing.  Instruction: "
operator|+
name|e
operator|.
name|msg
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
comment|// continue
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
if|if
condition|(
name|ex
operator|instanceof
name|IOException
condition|)
block|{
name|ex
operator|=
name|RemoteExceptionHandler
operator|.
name|checkIOException
argument_list|(
operator|(
name|IOException
operator|)
name|ex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|!=
literal|null
operator|&&
name|e
operator|.
name|tries
operator|.
name|get
argument_list|()
operator|<
name|numRetries
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ex
argument_list|)
expr_stmt|;
name|e
operator|.
name|tries
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|toDo
operator|.
name|put
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Putting into msgQueue was "
operator|+
literal|"interrupted."
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"unable to process message"
operator|+
operator|(
name|e
operator|!=
literal|null
condition|?
operator|(
literal|": "
operator|+
name|e
operator|.
name|msg
operator|.
name|toString
argument_list|()
operator|)
else|:
literal|""
operator|)
argument_list|,
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkFileSystem
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|checkOOME
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Unhandled exception"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"worker thread exiting"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|void
name|openRegion
parameter_list|(
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
comment|// If historian is not online and this is not a meta region, online it.
if|if
condition|(
operator|!
name|regionInfo
operator|.
name|isMetaRegion
argument_list|()
operator|&&
operator|!
name|RegionHistorian
operator|.
name|getInstance
argument_list|()
operator|.
name|isOnline
argument_list|()
condition|)
block|{
name|RegionHistorian
operator|.
name|getInstance
argument_list|()
operator|.
name|online
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
block|}
name|Integer
name|mapKey
init|=
name|Bytes
operator|.
name|mapKey
argument_list|(
name|regionInfo
operator|.
name|getRegionName
argument_list|()
argument_list|)
decl_stmt|;
name|HRegion
name|region
init|=
name|this
operator|.
name|onlineRegions
operator|.
name|get
argument_list|(
name|mapKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|region
operator|=
name|instantiateRegion
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
comment|// Startup a compaction early if one is needed.
name|this
operator|.
name|compactSplitThread
operator|.
name|compactionRequested
argument_list|(
name|region
argument_list|,
literal|"Region open check"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|Throwable
name|t
init|=
name|cleanup
argument_list|(
name|e
argument_list|,
literal|"Error opening "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
decl_stmt|;
comment|// TODO: add an extra field in HRegionInfo to indicate that there is
comment|// an error. We can't do that now because that would be an incompatible
comment|// change that would require a migration
name|reportClose
argument_list|(
name|regionInfo
argument_list|,
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|t
argument_list|)
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|hlog
operator|.
name|setSequenceNumber
argument_list|(
name|region
operator|.
name|getMinSequenceId
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|onlineRegions
operator|.
name|put
argument_list|(
name|mapKey
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
name|reportOpen
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|HRegion
name|instantiateRegion
parameter_list|(
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegion
name|r
init|=
operator|new
name|HRegion
argument_list|(
name|HTableDescriptor
operator|.
name|getTableDir
argument_list|(
name|rootDir
argument_list|,
name|regionInfo
operator|.
name|getTableDesc
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
name|this
operator|.
name|hlog
argument_list|,
name|this
operator|.
name|fs
argument_list|,
name|conf
argument_list|,
name|regionInfo
argument_list|,
name|this
operator|.
name|cacheFlusher
argument_list|)
decl_stmt|;
name|r
operator|.
name|initialize
argument_list|(
literal|null
argument_list|,
operator|new
name|Progressable
argument_list|()
block|{
specifier|public
name|void
name|progress
parameter_list|()
block|{
name|addProcessingMessage
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
comment|/**    * Add a MSG_REPORT_PROCESS_OPEN to the outbound queue.    * This method is called while region is in the queue of regions to process    * and then while the region is being opened, it is called from the Worker    * thread that is running the region open.    * @param hri Region to add the message for    */
specifier|public
name|void
name|addProcessingMessage
parameter_list|(
specifier|final
name|HRegionInfo
name|hri
parameter_list|)
block|{
name|getOutboundMsgs
argument_list|()
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|Type
operator|.
name|MSG_REPORT_PROCESS_OPEN
argument_list|,
name|hri
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|closeRegion
parameter_list|(
specifier|final
name|HRegionInfo
name|hri
parameter_list|,
specifier|final
name|boolean
name|reportWhenCompleted
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegion
name|region
init|=
name|this
operator|.
name|removeFromOnlineRegions
argument_list|(
name|hri
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|!=
literal|null
condition|)
block|{
name|region
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|reportWhenCompleted
condition|)
block|{
name|reportClose
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Called either when the master tells us to restart or from stop() */
name|ArrayList
argument_list|<
name|HRegion
argument_list|>
name|closeAllRegions
parameter_list|()
block|{
name|ArrayList
argument_list|<
name|HRegion
argument_list|>
name|regionsToClose
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegion
argument_list|>
argument_list|()
decl_stmt|;
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|regionsToClose
operator|.
name|addAll
argument_list|(
name|onlineRegions
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|onlineRegions
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|HRegion
name|region
range|:
name|regionsToClose
control|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"closing region "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|region
operator|.
name|close
argument_list|(
name|abortRequested
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|cleanup
argument_list|(
name|e
argument_list|,
literal|"Error closing "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|regionsToClose
return|;
block|}
comment|/*    * Thread to run close of a region.    */
specifier|private
specifier|static
class|class
name|RegionCloserThread
extends|extends
name|Thread
block|{
specifier|private
specifier|final
name|HRegion
name|r
decl_stmt|;
specifier|protected
name|RegionCloserThread
parameter_list|(
specifier|final
name|HRegion
name|r
parameter_list|)
block|{
name|super
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|".regionCloser."
operator|+
name|r
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|r
operator|=
name|r
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Closing region "
operator|+
name|r
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|r
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error closing region "
operator|+
name|r
operator|.
name|toString
argument_list|()
argument_list|,
name|RemoteExceptionHandler
operator|.
name|checkThrowable
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Called as the first stage of cluster shutdown. */
name|void
name|closeUserRegions
parameter_list|()
block|{
name|ArrayList
argument_list|<
name|HRegion
argument_list|>
name|regionsToClose
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegion
argument_list|>
argument_list|()
decl_stmt|;
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
synchronized|synchronized
init|(
name|onlineRegions
init|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|HRegion
argument_list|>
argument_list|>
name|i
init|=
name|onlineRegions
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|HRegion
argument_list|>
name|e
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|HRegion
name|r
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|r
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
name|regionsToClose
operator|.
name|add
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// Run region closes in parallel.
name|Set
argument_list|<
name|Thread
argument_list|>
name|threads
init|=
operator|new
name|HashSet
argument_list|<
name|Thread
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
for|for
control|(
specifier|final
name|HRegion
name|r
range|:
name|regionsToClose
control|)
block|{
name|RegionCloserThread
name|t
init|=
operator|new
name|RegionCloserThread
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
name|threads
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
for|for
control|(
name|Thread
name|t
range|:
name|threads
control|)
block|{
while|while
condition|(
name|t
operator|.
name|isAlive
argument_list|()
condition|)
block|{
try|try
block|{
name|t
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
name|this
operator|.
name|quiesced
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|onlineRegions
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|outboundMsgs
operator|.
name|add
argument_list|(
name|REPORT_EXITING
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outboundMsgs
operator|.
name|add
argument_list|(
name|REPORT_QUIESCED
argument_list|)
expr_stmt|;
block|}
block|}
comment|//
comment|// HRegionInterface
comment|//
specifier|public
name|HRegionInfo
name|getRegionInfo
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|NotServingRegionException
block|{
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return
name|getRegion
argument_list|(
name|regionName
argument_list|)
operator|.
name|getRegionInfo
argument_list|()
return|;
block|}
specifier|public
name|Result
name|getClosestRowBefore
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
comment|// locate the region we're operating on
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
comment|// ask the region for all the data
name|Result
name|r
init|=
name|region
operator|.
name|getClosestRowBefore
argument_list|(
name|row
argument_list|,
name|family
argument_list|)
decl_stmt|;
return|return
name|r
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|/** {@inheritDoc} */
specifier|public
name|Result
name|get
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|,
name|Get
name|get
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
return|return
name|region
operator|.
name|get
argument_list|(
name|get
argument_list|,
name|getLockFromId
argument_list|(
name|get
operator|.
name|getLockId
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
specifier|public
name|boolean
name|exists
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|,
name|Get
name|get
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|Result
name|r
init|=
name|region
operator|.
name|get
argument_list|(
name|get
argument_list|,
name|getLockFromId
argument_list|(
name|get
operator|.
name|getLockId
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|r
operator|!=
literal|null
operator|&&
operator|!
name|r
operator|.
name|isEmpty
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
specifier|public
name|void
name|put
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|Put
name|put
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|put
operator|.
name|getRow
argument_list|()
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"update has null row"
argument_list|)
throw|;
name|checkOpen
argument_list|()
expr_stmt|;
name|this
operator|.
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
try|try
block|{
name|cacheFlusher
operator|.
name|reclaimMemStoreMemory
argument_list|()
expr_stmt|;
name|region
operator|.
name|put
argument_list|(
name|put
argument_list|,
name|getLockFromId
argument_list|(
name|put
operator|.
name|getLockId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
specifier|public
name|int
name|put
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|Put
index|[]
name|puts
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Count of Puts processed.
name|int
name|i
init|=
literal|0
decl_stmt|;
name|checkOpen
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|this
operator|.
name|cacheFlusher
operator|.
name|reclaimMemStoreMemory
argument_list|()
expr_stmt|;
name|Integer
index|[]
name|locks
init|=
operator|new
name|Integer
index|[
name|puts
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|puts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|this
operator|.
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|locks
index|[
name|i
index|]
operator|=
name|getLockFromId
argument_list|(
name|puts
index|[
name|i
index|]
operator|.
name|getLockId
argument_list|()
argument_list|)
expr_stmt|;
name|region
operator|.
name|put
argument_list|(
name|puts
index|[
name|i
index|]
argument_list|,
name|locks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|WrongRegionException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Batch puts: "
operator|+
name|i
argument_list|,
name|ex
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
catch|catch
parameter_list|(
name|NotServingRegionException
name|ex
parameter_list|)
block|{
return|return
name|i
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
comment|// All have been processed successfully.
return|return
operator|-
literal|1
return|;
block|}
comment|/**    *     * @param regionName    * @param row    * @param family    * @param qualifier    * @param value the expected value    * @param put    * @throws IOException    * @return true if the new put was execute, false otherwise    */
specifier|public
name|boolean
name|checkAndPut
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|Put
name|put
parameter_list|)
throws|throws
name|IOException
block|{
comment|//Getting actual value
name|Get
name|get
init|=
operator|new
name|Get
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|get
operator|.
name|addColumn
argument_list|(
name|family
argument_list|,
name|qualifier
argument_list|)
expr_stmt|;
name|checkOpen
argument_list|()
expr_stmt|;
name|this
operator|.
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
try|try
block|{
name|cacheFlusher
operator|.
name|reclaimMemStoreMemory
argument_list|()
expr_stmt|;
return|return
name|region
operator|.
name|checkAndPut
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|value
argument_list|,
name|put
argument_list|,
name|getLockFromId
argument_list|(
name|put
operator|.
name|getLockId
argument_list|()
argument_list|)
argument_list|,
literal|true
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|//
comment|// remote scanner interface
comment|//
specifier|public
name|long
name|openScanner
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|,
name|Scan
name|scan
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|NullPointerException
name|npe
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|regionName
operator|==
literal|null
condition|)
block|{
name|npe
operator|=
operator|new
name|NullPointerException
argument_list|(
literal|"regionName is null"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scan
operator|==
literal|null
condition|)
block|{
name|npe
operator|=
operator|new
name|NullPointerException
argument_list|(
literal|"scan is null"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|npe
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid arguments to openScanner"
argument_list|,
name|npe
argument_list|)
throw|;
block|}
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|r
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|InternalScanner
name|s
init|=
name|r
operator|.
name|getScanner
argument_list|(
name|scan
argument_list|)
decl_stmt|;
name|long
name|scannerId
init|=
name|addScanner
argument_list|(
name|s
argument_list|)
decl_stmt|;
return|return
name|scannerId
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|,
literal|"Failed openScanner"
argument_list|)
argument_list|)
throw|;
block|}
block|}
specifier|protected
name|long
name|addScanner
parameter_list|(
name|InternalScanner
name|s
parameter_list|)
throws|throws
name|LeaseStillHeldException
block|{
name|long
name|scannerId
init|=
operator|-
literal|1L
decl_stmt|;
name|scannerId
operator|=
name|rand
operator|.
name|nextLong
argument_list|()
expr_stmt|;
name|String
name|scannerName
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|scanners
init|)
block|{
name|scanners
operator|.
name|put
argument_list|(
name|scannerName
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|leases
operator|.
name|createLease
argument_list|(
name|scannerName
argument_list|,
operator|new
name|ScannerListener
argument_list|(
name|scannerName
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|scannerId
return|;
block|}
specifier|public
name|Result
name|next
parameter_list|(
specifier|final
name|long
name|scannerId
parameter_list|)
throws|throws
name|IOException
block|{
name|Result
index|[]
name|res
init|=
name|next
argument_list|(
name|scannerId
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
literal|null
operator|||
name|res
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|res
index|[
literal|0
index|]
return|;
block|}
specifier|public
name|Result
index|[]
name|next
parameter_list|(
specifier|final
name|long
name|scannerId
parameter_list|,
name|int
name|nbRows
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|Result
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|Result
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|String
name|scannerName
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
name|InternalScanner
name|s
init|=
name|scanners
operator|.
name|get
argument_list|(
name|scannerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownScannerException
argument_list|(
literal|"Name: "
operator|+
name|scannerName
argument_list|)
throw|;
block|}
name|this
operator|.
name|leases
operator|.
name|renewLease
argument_list|(
name|scannerName
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nbRows
condition|;
name|i
operator|++
control|)
block|{
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
comment|// Collect values to be returned here
name|List
argument_list|<
name|KeyValue
argument_list|>
name|values
init|=
operator|new
name|ArrayList
argument_list|<
name|KeyValue
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|moreRows
init|=
name|s
operator|.
name|next
argument_list|(
name|values
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|values
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|results
operator|.
name|add
argument_list|(
operator|new
name|Result
argument_list|(
name|values
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|moreRows
condition|)
block|{
break|break;
block|}
block|}
return|return
name|results
operator|.
name|toArray
argument_list|(
operator|new
name|Result
index|[
literal|0
index|]
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
specifier|public
name|void
name|close
parameter_list|(
specifier|final
name|long
name|scannerId
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|String
name|scannerName
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
name|InternalScanner
name|s
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|scanners
init|)
block|{
name|s
operator|=
name|scanners
operator|.
name|remove
argument_list|(
name|scannerName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownScannerException
argument_list|(
name|scannerName
argument_list|)
throw|;
block|}
name|s
operator|.
name|close
argument_list|()
expr_stmt|;
name|this
operator|.
name|leases
operator|.
name|cancelLease
argument_list|(
name|scannerName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|/**     * Instantiated as a scanner lease.    * If the lease times out, the scanner is closed    */
specifier|private
class|class
name|ScannerListener
implements|implements
name|LeaseListener
block|{
specifier|private
specifier|final
name|String
name|scannerName
decl_stmt|;
name|ScannerListener
parameter_list|(
specifier|final
name|String
name|n
parameter_list|)
block|{
name|this
operator|.
name|scannerName
operator|=
name|n
expr_stmt|;
block|}
specifier|public
name|void
name|leaseExpired
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Scanner "
operator|+
name|this
operator|.
name|scannerName
operator|+
literal|" lease expired"
argument_list|)
expr_stmt|;
name|InternalScanner
name|s
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|scanners
init|)
block|{
name|s
operator|=
name|scanners
operator|.
name|remove
argument_list|(
name|this
operator|.
name|scannerName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|s
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Closing scanner"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|//
comment|// Methods that do the actual work for the remote API
comment|//
specifier|public
name|void
name|delete
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|Delete
name|delete
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
try|try
block|{
name|boolean
name|writeToWAL
init|=
literal|true
decl_stmt|;
name|this
operator|.
name|cacheFlusher
operator|.
name|reclaimMemStoreMemory
argument_list|()
expr_stmt|;
name|this
operator|.
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|Integer
name|lock
init|=
name|getLockFromId
argument_list|(
name|delete
operator|.
name|getLockId
argument_list|()
argument_list|)
decl_stmt|;
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|region
operator|.
name|delete
argument_list|(
name|delete
argument_list|,
name|lock
argument_list|,
name|writeToWAL
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|WrongRegionException
name|ex
parameter_list|)
block|{     }
catch|catch
parameter_list|(
name|NotServingRegionException
name|ex
parameter_list|)
block|{     }
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
specifier|public
name|long
name|lockRow
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|,
name|byte
index|[]
name|row
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|NullPointerException
name|npe
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|regionName
operator|==
literal|null
condition|)
block|{
name|npe
operator|=
operator|new
name|NullPointerException
argument_list|(
literal|"regionName is null"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|row
operator|==
literal|null
condition|)
block|{
name|npe
operator|=
operator|new
name|NullPointerException
argument_list|(
literal|"row to lock is null"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|npe
operator|!=
literal|null
condition|)
block|{
name|IOException
name|io
init|=
operator|new
name|IOException
argument_list|(
literal|"Invalid arguments to lockRow"
argument_list|)
decl_stmt|;
name|io
operator|.
name|initCause
argument_list|(
name|npe
argument_list|)
expr_stmt|;
throw|throw
name|io
throw|;
block|}
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|Integer
name|r
init|=
name|region
operator|.
name|obtainRowLock
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|long
name|lockId
init|=
name|addRowLock
argument_list|(
name|r
argument_list|,
name|region
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Row lock "
operator|+
name|lockId
operator|+
literal|" explicitly acquired by client"
argument_list|)
expr_stmt|;
return|return
name|lockId
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|,
literal|"Error obtaining row lock (fsOk: "
operator|+
name|this
operator|.
name|fsOk
operator|+
literal|")"
argument_list|)
argument_list|)
throw|;
block|}
block|}
specifier|protected
name|long
name|addRowLock
parameter_list|(
name|Integer
name|r
parameter_list|,
name|HRegion
name|region
parameter_list|)
throws|throws
name|LeaseStillHeldException
block|{
name|long
name|lockId
init|=
operator|-
literal|1L
decl_stmt|;
name|lockId
operator|=
name|rand
operator|.
name|nextLong
argument_list|()
expr_stmt|;
name|String
name|lockName
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|lockId
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|rowlocks
init|)
block|{
name|rowlocks
operator|.
name|put
argument_list|(
name|lockName
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|leases
operator|.
name|createLease
argument_list|(
name|lockName
argument_list|,
operator|new
name|RowLockListener
argument_list|(
name|lockName
argument_list|,
name|region
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|lockId
return|;
block|}
comment|/**    * Method to get the Integer lock identifier used internally    * from the long lock identifier used by the client.    * @param lockId long row lock identifier from client    * @return intId Integer row lock used internally in HRegion    * @throws IOException Thrown if this is not a valid client lock id.    */
name|Integer
name|getLockFromId
parameter_list|(
name|long
name|lockId
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|lockId
operator|==
operator|-
literal|1L
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|lockName
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|lockId
argument_list|)
decl_stmt|;
name|Integer
name|rl
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|rowlocks
init|)
block|{
name|rl
operator|=
name|rowlocks
operator|.
name|get
argument_list|(
name|lockName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rl
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid row lock"
argument_list|)
throw|;
block|}
name|this
operator|.
name|leases
operator|.
name|renewLease
argument_list|(
name|lockName
argument_list|)
expr_stmt|;
return|return
name|rl
return|;
block|}
specifier|public
name|void
name|unlockRow
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|,
name|long
name|lockId
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|NullPointerException
name|npe
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|regionName
operator|==
literal|null
condition|)
block|{
name|npe
operator|=
operator|new
name|NullPointerException
argument_list|(
literal|"regionName is null"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lockId
operator|==
operator|-
literal|1L
condition|)
block|{
name|npe
operator|=
operator|new
name|NullPointerException
argument_list|(
literal|"lockId is null"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|npe
operator|!=
literal|null
condition|)
block|{
name|IOException
name|io
init|=
operator|new
name|IOException
argument_list|(
literal|"Invalid arguments to unlockRow"
argument_list|)
decl_stmt|;
name|io
operator|.
name|initCause
argument_list|(
name|npe
argument_list|)
expr_stmt|;
throw|throw
name|io
throw|;
block|}
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|String
name|lockName
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|lockId
argument_list|)
decl_stmt|;
name|Integer
name|r
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|rowlocks
init|)
block|{
name|r
operator|=
name|rowlocks
operator|.
name|remove
argument_list|(
name|lockName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownRowLockException
argument_list|(
name|lockName
argument_list|)
throw|;
block|}
name|region
operator|.
name|releaseRowLock
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|this
operator|.
name|leases
operator|.
name|cancelLease
argument_list|(
name|lockName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Row lock "
operator|+
name|lockId
operator|+
literal|" has been explicitly released by client"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|rowlocks
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Instantiated as a row lock lease.    * If the lease times out, the row lock is released    */
specifier|private
class|class
name|RowLockListener
implements|implements
name|LeaseListener
block|{
specifier|private
specifier|final
name|String
name|lockName
decl_stmt|;
specifier|private
specifier|final
name|HRegion
name|region
decl_stmt|;
name|RowLockListener
parameter_list|(
specifier|final
name|String
name|lockName
parameter_list|,
specifier|final
name|HRegion
name|region
parameter_list|)
block|{
name|this
operator|.
name|lockName
operator|=
name|lockName
expr_stmt|;
name|this
operator|.
name|region
operator|=
name|region
expr_stmt|;
block|}
specifier|public
name|void
name|leaseExpired
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Row Lock "
operator|+
name|this
operator|.
name|lockName
operator|+
literal|" lease expired"
argument_list|)
expr_stmt|;
name|Integer
name|r
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|rowlocks
init|)
block|{
name|r
operator|=
name|rowlocks
operator|.
name|remove
argument_list|(
name|this
operator|.
name|lockName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|!=
literal|null
condition|)
block|{
name|region
operator|.
name|releaseRowLock
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * @return Info on this server.    */
specifier|public
name|HServerInfo
name|getServerInfo
parameter_list|()
block|{
return|return
name|this
operator|.
name|serverInfo
return|;
block|}
comment|/** @return the info server */
specifier|public
name|InfoServer
name|getInfoServer
parameter_list|()
block|{
return|return
name|infoServer
return|;
block|}
comment|/**    * @return true if a stop has been requested.    */
specifier|public
name|boolean
name|isStopRequested
parameter_list|()
block|{
return|return
name|stopRequested
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * @return true if the region server is in safe mode    */
specifier|public
name|boolean
name|isInSafeMode
parameter_list|()
block|{
return|return
name|safeMode
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    *     * @return the configuration    */
specifier|public
name|HBaseConfiguration
name|getConfiguration
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
comment|/** @return the write lock for the server */
name|ReentrantReadWriteLock
operator|.
name|WriteLock
name|getWriteLock
parameter_list|()
block|{
return|return
name|lock
operator|.
name|writeLock
argument_list|()
return|;
block|}
comment|/**    * @return Immutable list of this servers regions.    */
specifier|public
name|Collection
argument_list|<
name|HRegion
argument_list|>
name|getOnlineRegions
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|onlineRegions
operator|.
name|values
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|HRegion
index|[]
name|getOnlineRegionsAsArray
parameter_list|()
block|{
return|return
name|getOnlineRegions
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|HRegion
index|[
literal|0
index|]
argument_list|)
return|;
block|}
comment|/**    * @return The HRegionInfos from online regions sorted    */
specifier|public
name|SortedSet
argument_list|<
name|HRegionInfo
argument_list|>
name|getSortedOnlineRegionInfos
parameter_list|()
block|{
name|SortedSet
argument_list|<
name|HRegionInfo
argument_list|>
name|result
init|=
operator|new
name|TreeSet
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|onlineRegions
init|)
block|{
for|for
control|(
name|HRegion
name|r
range|:
name|this
operator|.
name|onlineRegions
operator|.
name|values
argument_list|()
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|r
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**    * This method removes HRegion corresponding to hri from the Map of onlineRegions.      *     * @param hri the HRegionInfo corresponding to the HRegion to-be-removed.    * @return the removed HRegion, or null if the HRegion was not in onlineRegions.    */
name|HRegion
name|removeFromOnlineRegions
parameter_list|(
name|HRegionInfo
name|hri
parameter_list|)
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
name|HRegion
name|toReturn
init|=
literal|null
decl_stmt|;
try|try
block|{
name|toReturn
operator|=
name|onlineRegions
operator|.
name|remove
argument_list|(
name|Bytes
operator|.
name|mapKey
argument_list|(
name|hri
operator|.
name|getRegionName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|toReturn
return|;
block|}
comment|/**    * @return A new Map of online regions sorted by region size with the first    * entry being the biggest.    */
specifier|public
name|SortedMap
argument_list|<
name|Long
argument_list|,
name|HRegion
argument_list|>
name|getCopyOfOnlineRegionsSortedBySize
parameter_list|()
block|{
comment|// we'll sort the regions in reverse
name|SortedMap
argument_list|<
name|Long
argument_list|,
name|HRegion
argument_list|>
name|sortedRegions
init|=
operator|new
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|HRegion
argument_list|>
argument_list|(
operator|new
name|Comparator
argument_list|<
name|Long
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|Long
name|a
parameter_list|,
name|Long
name|b
parameter_list|)
block|{
return|return
operator|-
literal|1
operator|*
name|a
operator|.
name|compareTo
argument_list|(
name|b
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
comment|// Copy over all regions. Regions are sorted by size with biggest first.
synchronized|synchronized
init|(
name|this
operator|.
name|onlineRegions
init|)
block|{
for|for
control|(
name|HRegion
name|region
range|:
name|this
operator|.
name|onlineRegions
operator|.
name|values
argument_list|()
control|)
block|{
name|sortedRegions
operator|.
name|put
argument_list|(
name|Long
operator|.
name|valueOf
argument_list|(
name|region
operator|.
name|memstoreSize
operator|.
name|get
argument_list|()
argument_list|)
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sortedRegions
return|;
block|}
comment|/**    * @param regionName    * @return HRegion for the passed<code>regionName</code> or null if named    * region is not member of the online regions.    */
specifier|public
name|HRegion
name|getOnlineRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
block|{
return|return
name|onlineRegions
operator|.
name|get
argument_list|(
name|Bytes
operator|.
name|mapKey
argument_list|(
name|regionName
argument_list|)
argument_list|)
return|;
block|}
comment|/** @return the request count */
specifier|public
name|AtomicInteger
name|getRequestCount
parameter_list|()
block|{
return|return
name|this
operator|.
name|requestCount
return|;
block|}
comment|/** @return reference to FlushRequester */
specifier|public
name|FlushRequester
name|getFlushRequester
parameter_list|()
block|{
return|return
name|this
operator|.
name|cacheFlusher
return|;
block|}
comment|/**     * Protected utility method for safely obtaining an HRegion handle.    * @param regionName Name of online {@link HRegion} to return    * @return {@link HRegion} for<code>regionName</code>    * @throws NotServingRegionException    */
specifier|protected
name|HRegion
name|getRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|NotServingRegionException
block|{
name|HRegion
name|region
init|=
literal|null
decl_stmt|;
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|region
operator|=
name|onlineRegions
operator|.
name|get
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|Bytes
operator|.
name|hashCode
argument_list|(
name|regionName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NotServingRegionException
argument_list|(
name|regionName
argument_list|)
throw|;
block|}
return|return
name|region
return|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get the top N most loaded regions this server is serving so we can    * tell the master which regions it can reallocate if we're overloaded.    * TODO: actually calculate which regions are most loaded. (Right now, we're    * just grabbing the first N regions being served regardless of load.)    */
specifier|protected
name|HRegionInfo
index|[]
name|getMostLoadedRegions
parameter_list|()
block|{
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|onlineRegions
init|)
block|{
for|for
control|(
name|HRegion
name|r
range|:
name|onlineRegions
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|r
operator|.
name|isClosed
argument_list|()
operator|||
name|r
operator|.
name|isClosing
argument_list|()
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|regions
operator|.
name|size
argument_list|()
operator|<
name|numRegionsToReport
condition|)
block|{
name|regions
operator|.
name|add
argument_list|(
name|r
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
return|return
name|regions
operator|.
name|toArray
argument_list|(
operator|new
name|HRegionInfo
index|[
name|regions
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**      * Called to verify that this server is up and running.    *     * @throws IOException    */
specifier|protected
name|void
name|checkOpen
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|stopRequested
operator|.
name|get
argument_list|()
operator|||
name|this
operator|.
name|abortRequested
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Server not running"
operator|+
operator|(
name|this
operator|.
name|abortRequested
condition|?
literal|", aborting"
else|:
literal|""
operator|)
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|fsOk
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"File system not available"
argument_list|)
throw|;
block|}
block|}
comment|/**    * @return Returns list of non-closed regions hosted on this server.  If no    * regions to check, returns an empty list.    */
specifier|protected
name|Set
argument_list|<
name|HRegion
argument_list|>
name|getRegionsToCheck
parameter_list|()
block|{
name|HashSet
argument_list|<
name|HRegion
argument_list|>
name|regionsToCheck
init|=
operator|new
name|HashSet
argument_list|<
name|HRegion
argument_list|>
argument_list|()
decl_stmt|;
comment|//TODO: is this locking necessary?
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|regionsToCheck
operator|.
name|addAll
argument_list|(
name|this
operator|.
name|onlineRegions
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// Purge closed regions.
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|HRegion
argument_list|>
name|i
init|=
name|regionsToCheck
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|HRegion
name|r
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|isClosed
argument_list|()
condition|)
block|{
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|regionsToCheck
return|;
block|}
specifier|public
name|long
name|getProtocolVersion
parameter_list|(
specifier|final
name|String
name|protocol
parameter_list|,
specifier|final
name|long
name|clientVersion
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|HRegionInterface
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|HBaseRPCProtocolVersion
operator|.
name|versionID
return|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown protocol to name node: "
operator|+
name|protocol
argument_list|)
throw|;
block|}
comment|/**    * @return Queue to which you can add outbound messages.    */
specifier|protected
name|List
argument_list|<
name|HMsg
argument_list|>
name|getOutboundMsgs
parameter_list|()
block|{
return|return
name|this
operator|.
name|outboundMsgs
return|;
block|}
comment|/**    * Return the total size of all memstores in every region.    * @return memstore size in bytes    */
specifier|public
name|long
name|getGlobalMemStoreSize
parameter_list|()
block|{
name|long
name|total
init|=
literal|0
decl_stmt|;
synchronized|synchronized
init|(
name|onlineRegions
init|)
block|{
for|for
control|(
name|HRegion
name|region
range|:
name|onlineRegions
operator|.
name|values
argument_list|()
control|)
block|{
name|total
operator|+=
name|region
operator|.
name|memstoreSize
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|total
return|;
block|}
comment|/**    * @return Return the leases.    */
specifier|protected
name|Leases
name|getLeases
parameter_list|()
block|{
return|return
name|leases
return|;
block|}
comment|/**    * @return Return the rootDir.    */
specifier|protected
name|Path
name|getRootDir
parameter_list|()
block|{
return|return
name|rootDir
return|;
block|}
comment|/**    * @return Return the fs.    */
specifier|protected
name|FileSystem
name|getFileSystem
parameter_list|()
block|{
return|return
name|fs
return|;
block|}
comment|//
comment|// Main program and support routines
comment|//
specifier|private
specifier|static
name|void
name|printUsageAndExit
parameter_list|()
block|{
name|printUsageAndExit
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|printUsageAndExit
parameter_list|(
specifier|final
name|String
name|message
parameter_list|)
block|{
if|if
condition|(
name|message
operator|!=
literal|null
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Usage: java org.apache.hbase.HRegionServer start|stop"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Do class main.    * @param args    * @param regionServerClass HRegionServer to instantiate.    */
specifier|protected
specifier|static
name|void
name|doMain
parameter_list|(
specifier|final
name|String
index|[]
name|args
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|HRegionServer
argument_list|>
name|regionServerClass
parameter_list|)
block|{
if|if
condition|(
name|args
operator|.
name|length
operator|<
literal|1
condition|)
block|{
name|printUsageAndExit
argument_list|()
expr_stmt|;
block|}
name|Configuration
name|conf
init|=
operator|new
name|HBaseConfiguration
argument_list|()
decl_stmt|;
comment|// Process command-line args. TODO: Better cmd-line processing
comment|// (but hopefully something not as painful as cli options).
for|for
control|(
name|String
name|cmd
range|:
name|args
control|)
block|{
if|if
condition|(
name|cmd
operator|.
name|equals
argument_list|(
literal|"start"
argument_list|)
condition|)
block|{
try|try
block|{
comment|// If 'local', don't start a region server here.  Defer to
comment|// LocalHBaseCluster.  It manages 'local' clusters.
if|if
condition|(
name|LocalHBaseCluster
operator|.
name|isLocal
argument_list|(
name|conf
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Not starting a distinct region server because "
operator|+
name|HConstants
operator|.
name|CLUSTER_DISTRIBUTED
operator|+
literal|" is false"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RuntimeMXBean
name|runtime
init|=
name|ManagementFactory
operator|.
name|getRuntimeMXBean
argument_list|()
decl_stmt|;
if|if
condition|(
name|runtime
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"vmInputArguments="
operator|+
name|runtime
operator|.
name|getInputArguments
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Constructor
argument_list|<
name|?
extends|extends
name|HRegionServer
argument_list|>
name|c
init|=
name|regionServerClass
operator|.
name|getConstructor
argument_list|(
name|HBaseConfiguration
operator|.
name|class
argument_list|)
decl_stmt|;
name|HRegionServer
name|hrs
init|=
name|c
operator|.
name|newInstance
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Thread
name|t
init|=
operator|new
name|Thread
argument_list|(
name|hrs
argument_list|)
decl_stmt|;
name|t
operator|.
name|setName
argument_list|(
literal|"regionserver"
operator|+
name|hrs
operator|.
name|server
operator|.
name|getListenerAddress
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Can not start region server because "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|cmd
operator|.
name|equals
argument_list|(
literal|"stop"
argument_list|)
condition|)
block|{
name|printUsageAndExit
argument_list|(
literal|"To shutdown the regionserver run "
operator|+
literal|"bin/hbase-daemon.sh stop regionserver or send a kill signal to"
operator|+
literal|"the regionserver pid"
argument_list|)
expr_stmt|;
block|}
comment|// Print out usage if we get to here.
name|printUsageAndExit
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** {@inheritDoc} */
specifier|public
name|long
name|incrementColumnValue
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|,
name|byte
index|[]
name|row
parameter_list|,
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|long
name|amount
parameter_list|,
name|boolean
name|writeToWAL
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|regionName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid arguments to incrementColumnValue "
operator|+
literal|"regionName is null"
argument_list|)
throw|;
block|}
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
return|return
name|region
operator|.
name|incrementColumnValue
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|amount
argument_list|,
name|writeToWAL
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkFileSystem
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/** {@inheritDoc} */
specifier|public
name|HRegionInfo
index|[]
name|getRegionsAssignment
parameter_list|()
throws|throws
name|IOException
block|{
name|HRegionInfo
index|[]
name|regions
init|=
operator|new
name|HRegionInfo
index|[
name|onlineRegions
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|Iterator
argument_list|<
name|HRegion
argument_list|>
name|ite
init|=
name|onlineRegions
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|ite
operator|.
name|hasNext
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|regions
index|[
name|i
index|]
operator|=
name|ite
operator|.
name|next
argument_list|()
operator|.
name|getRegionInfo
argument_list|()
expr_stmt|;
block|}
return|return
name|regions
return|;
block|}
comment|/** {@inheritDoc} */
specifier|public
name|HServerInfo
name|getHServerInfo
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|serverInfo
return|;
block|}
comment|/**    * @param args    */
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|Configuration
name|conf
init|=
operator|new
name|HBaseConfiguration
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Class
argument_list|<
name|?
extends|extends
name|HRegionServer
argument_list|>
name|regionServerClass
init|=
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|HRegionServer
argument_list|>
operator|)
name|conf
operator|.
name|getClass
argument_list|(
name|HConstants
operator|.
name|REGION_SERVER_IMPL
argument_list|,
name|HRegionServer
operator|.
name|class
argument_list|)
decl_stmt|;
name|doMain
argument_list|(
name|args
argument_list|,
name|regionServerClass
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

