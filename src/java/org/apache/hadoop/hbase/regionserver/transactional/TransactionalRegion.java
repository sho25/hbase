begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2008 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|transactional
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HStoreKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|LeaseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|LeaseListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Leases
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Leases
operator|.
name|LeaseStillHeldException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|transactional
operator|.
name|UnknownTransactionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|RowFilterInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|BatchUpdate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|Cell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|FlushRequester
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HLog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|InternalScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|transactional
operator|.
name|TransactionState
operator|.
name|Status
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Progressable
import|;
end_import

begin_comment
comment|/**  * Regionserver which provides transactional support for atomic transactions.  * This is achieved with optimistic concurrency control (see  * http://www.seas.upenn.edu/~zives/cis650/papers/opt-cc.pdf). We keep track  * read and write sets for each transaction, and hold off on processing the  * writes. To decide to commit a transaction we check its read sets with all  * transactions that have committed while it was running for overlaps.  *<p>  * Because transactions can span multiple regions, all regions must agree to  * commit a transactions. The client side of this commit protocol is encoded in  * org.apache.hadoop.hbase.client.transactional.TransactionManger  *<p>  * In the event of an failure of the client mid-commit, (after we voted yes), we  * will have to consult the transaction log to determine the final decision of  * the transaction. This is not yet implemented.  */
end_comment

begin_class
class|class
name|TransactionalRegion
extends|extends
name|HRegion
block|{
specifier|private
specifier|static
specifier|final
name|String
name|LEASE_TIME
init|=
literal|"hbase.transaction.leaseTime"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_LEASE_TIME
init|=
literal|60
operator|*
literal|1000
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|LEASE_CHECK_FREQUENCY
init|=
literal|1000
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|OLD_TRANSACTION_FLUSH
init|=
literal|"hbase.transaction.flush"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_OLD_TRANSACTION_FLUSH
init|=
literal|100
decl_stmt|;
comment|// Do a flush if we have this many old transactions..
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TransactionalRegion
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Collection of active transactions (PENDING) keyed by id.
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|TransactionState
argument_list|>
name|transactionsById
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|TransactionState
argument_list|>
argument_list|()
decl_stmt|;
comment|// Map of recent transactions that are COMMIT_PENDING or COMMITED keyed by
comment|// their sequence number
specifier|private
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|TransactionState
argument_list|>
name|commitedTransactionsBySequenceNumber
init|=
name|Collections
operator|.
name|synchronizedSortedMap
argument_list|(
operator|new
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|TransactionState
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|// Collection of transactions that are COMMIT_PENDING
specifier|private
name|Set
argument_list|<
name|TransactionState
argument_list|>
name|commitPendingTransactions
init|=
name|Collections
operator|.
name|synchronizedSet
argument_list|(
operator|new
name|HashSet
argument_list|<
name|TransactionState
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|Leases
name|transactionLeases
decl_stmt|;
specifier|private
name|AtomicInteger
name|nextSequenceId
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|private
name|Object
name|commitCheckLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
name|TransactionalHLogManager
name|logManager
decl_stmt|;
specifier|private
specifier|final
name|int
name|oldTransactionFlushTrigger
decl_stmt|;
comment|/**    * @param basedir    * @param log    * @param fs    * @param conf    * @param regionInfo    * @param flushListener    */
specifier|public
name|TransactionalRegion
parameter_list|(
specifier|final
name|Path
name|basedir
parameter_list|,
specifier|final
name|HLog
name|log
parameter_list|,
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|HBaseConfiguration
name|conf
parameter_list|,
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|,
specifier|final
name|FlushRequester
name|flushListener
parameter_list|)
block|{
name|super
argument_list|(
name|basedir
argument_list|,
name|log
argument_list|,
name|fs
argument_list|,
name|conf
argument_list|,
name|regionInfo
argument_list|,
name|flushListener
argument_list|)
expr_stmt|;
name|transactionLeases
operator|=
operator|new
name|Leases
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
name|LEASE_TIME
argument_list|,
name|DEFAULT_LEASE_TIME
argument_list|)
argument_list|,
name|LEASE_CHECK_FREQUENCY
argument_list|)
expr_stmt|;
name|logManager
operator|=
operator|new
name|TransactionalHLogManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|oldTransactionFlushTrigger
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|OLD_TRANSACTION_FLUSH
argument_list|,
name|DEFAULT_OLD_TRANSACTION_FLUSH
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|doReconstructionLog
parameter_list|(
specifier|final
name|Path
name|oldLogFile
parameter_list|,
specifier|final
name|long
name|minSeqId
parameter_list|,
specifier|final
name|long
name|maxSeqId
parameter_list|,
specifier|final
name|Progressable
name|reporter
parameter_list|)
throws|throws
name|UnsupportedEncodingException
throws|,
name|IOException
block|{
name|super
operator|.
name|doReconstructionLog
argument_list|(
name|oldLogFile
argument_list|,
name|minSeqId
argument_list|,
name|maxSeqId
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|BatchUpdate
argument_list|>
argument_list|>
name|commitedTransactionsById
init|=
name|logManager
operator|.
name|getCommitsFromLog
argument_list|(
name|oldLogFile
argument_list|,
name|minSeqId
argument_list|,
name|reporter
argument_list|)
decl_stmt|;
if|if
condition|(
name|commitedTransactionsById
operator|!=
literal|null
operator|&&
name|commitedTransactionsById
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"found "
operator|+
name|commitedTransactionsById
operator|.
name|size
argument_list|()
operator|+
literal|" COMMITED transactions"
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|BatchUpdate
argument_list|>
argument_list|>
name|entry
range|:
name|commitedTransactionsById
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Writing "
operator|+
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|" updates for transaction "
operator|+
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|BatchUpdate
name|b
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
name|super
operator|.
name|batchUpdate
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// These are walled so they live forever
block|}
block|}
comment|// LOG.debug("Flushing cache"); // We must trigger a cache flush,
comment|// otherwise
comment|// we will would ignore the log on subsequent failure
comment|// if (!super.flushcache()) {
comment|// LOG.warn("Did not flush cache");
comment|// }
block|}
block|}
comment|/**    * We need to make sure that we don't complete a cache flush between running    * transactions. If we did, then we would not find all log messages needed to    * restore the transaction, as some of them would be before the last    * "complete" flush id.    */
annotation|@
name|Override
specifier|protected
name|long
name|getCompleteCacheFlushSequenceId
parameter_list|(
specifier|final
name|long
name|currentSequenceId
parameter_list|)
block|{
name|long
name|minPendingStartSequenceId
init|=
name|currentSequenceId
decl_stmt|;
for|for
control|(
name|TransactionState
name|transactionState
range|:
name|transactionsById
operator|.
name|values
argument_list|()
control|)
block|{
name|minPendingStartSequenceId
operator|=
name|Math
operator|.
name|min
argument_list|(
name|minPendingStartSequenceId
argument_list|,
name|transactionState
operator|.
name|getHLogStartSequenceId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|minPendingStartSequenceId
return|;
block|}
comment|/**    * @param transactionId    * @throws IOException    */
specifier|public
name|void
name|beginTransaction
parameter_list|(
specifier|final
name|long
name|transactionId
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|key
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|transactionId
argument_list|)
decl_stmt|;
if|if
condition|(
name|transactionsById
operator|.
name|get
argument_list|(
name|key
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|TransactionState
name|alias
init|=
name|getTransactionState
argument_list|(
name|transactionId
argument_list|)
decl_stmt|;
if|if
condition|(
name|alias
operator|!=
literal|null
condition|)
block|{
name|alias
operator|.
name|setStatus
argument_list|(
name|Status
operator|.
name|ABORTED
argument_list|)
expr_stmt|;
name|retireTransaction
argument_list|(
name|alias
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Already exiting transaction id: "
operator|+
name|key
argument_list|)
throw|;
block|}
name|TransactionState
name|state
init|=
operator|new
name|TransactionState
argument_list|(
name|transactionId
argument_list|,
name|super
operator|.
name|getLog
argument_list|()
operator|.
name|getSequenceNumber
argument_list|()
argument_list|)
decl_stmt|;
comment|// Order is important here
for|for
control|(
name|TransactionState
name|commitPending
range|:
name|commitPendingTransactions
control|)
block|{
name|state
operator|.
name|addTransactionToCheck
argument_list|(
name|commitPending
argument_list|)
expr_stmt|;
block|}
name|state
operator|.
name|setStartSequenceNumber
argument_list|(
name|nextSequenceId
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|transactionsById
operator|.
name|put
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|key
argument_list|)
argument_list|,
name|state
argument_list|)
expr_stmt|;
try|try
block|{
name|transactionLeases
operator|.
name|createLease
argument_list|(
name|key
argument_list|,
operator|new
name|TransactionLeaseListener
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LeaseStillHeldException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Begining transaction "
operator|+
name|key
operator|+
literal|" in region "
operator|+
name|super
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
name|logManager
operator|.
name|writeStartToLog
argument_list|(
name|transactionId
argument_list|)
expr_stmt|;
name|maybeTriggerOldTransactionFlush
argument_list|()
expr_stmt|;
block|}
comment|/**    * Fetch a single data item.    *     * @param transactionId    * @param row    * @param column    * @return column value    * @throws IOException    */
specifier|public
name|Cell
name|get
parameter_list|(
specifier|final
name|long
name|transactionId
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|column
parameter_list|)
throws|throws
name|IOException
block|{
name|Cell
index|[]
name|results
init|=
name|get
argument_list|(
name|transactionId
argument_list|,
name|row
argument_list|,
name|column
argument_list|,
literal|1
argument_list|)
decl_stmt|;
return|return
operator|(
name|results
operator|==
literal|null
operator|||
name|results
operator|.
name|length
operator|==
literal|0
operator|)
condition|?
literal|null
else|:
name|results
index|[
literal|0
index|]
return|;
block|}
comment|/**    * Fetch multiple versions of a single data item    *     * @param transactionId    * @param row    * @param column    * @param numVersions    * @return array of values one element per version    * @throws IOException    */
specifier|public
name|Cell
index|[]
name|get
parameter_list|(
specifier|final
name|long
name|transactionId
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|column
parameter_list|,
specifier|final
name|int
name|numVersions
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|get
argument_list|(
name|transactionId
argument_list|,
name|row
argument_list|,
name|column
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|,
name|numVersions
argument_list|)
return|;
block|}
comment|/**    * Fetch multiple versions of a single data item, with timestamp.    *     * @param transactionId    * @param row    * @param column    * @param timestamp    * @param numVersions    * @return array of values one element per version that matches the timestamp    * @throws IOException    */
specifier|public
name|Cell
index|[]
name|get
parameter_list|(
specifier|final
name|long
name|transactionId
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|column
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|int
name|numVersions
parameter_list|)
throws|throws
name|IOException
block|{
name|TransactionState
name|state
init|=
name|getTransactionState
argument_list|(
name|transactionId
argument_list|)
decl_stmt|;
name|state
operator|.
name|addRead
argument_list|(
name|row
argument_list|)
expr_stmt|;
name|Cell
index|[]
name|localCells
init|=
name|state
operator|.
name|localGet
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|timestamp
argument_list|)
decl_stmt|;
if|if
condition|(
name|localCells
operator|!=
literal|null
operator|&&
name|localCells
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Transactional get of something we've written in the same transaction "
operator|+
name|transactionId
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"row: "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|row
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"col: "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|column
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"numVersions: "
operator|+
name|numVersions
argument_list|)
expr_stmt|;
for|for
control|(
name|Cell
name|cell
range|:
name|localCells
control|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"cell: "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|cell
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numVersions
operator|>
literal|1
condition|)
block|{
name|Cell
index|[]
name|globalCells
init|=
name|get
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|timestamp
argument_list|,
name|numVersions
operator|-
literal|1
argument_list|)
decl_stmt|;
name|Cell
index|[]
name|result
init|=
operator|new
name|Cell
index|[
name|globalCells
operator|.
name|length
operator|+
name|localCells
operator|.
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|localCells
argument_list|,
literal|0
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
name|localCells
operator|.
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|globalCells
argument_list|,
literal|0
argument_list|,
name|result
argument_list|,
name|localCells
operator|.
name|length
argument_list|,
name|globalCells
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
return|return
name|localCells
return|;
block|}
return|return
name|get
argument_list|(
name|row
argument_list|,
name|column
argument_list|,
name|timestamp
argument_list|,
name|numVersions
argument_list|)
return|;
block|}
comment|/**    * Fetch all the columns for the indicated row at a specified timestamp.    * Returns a TreeMap that maps column names to values.    *     * @param transactionId    * @param row    * @param columns Array of columns you'd like to retrieve. When null, get all.    * @param ts    * @return Map<columnName, Cell> values    * @throws IOException    */
specifier|public
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|Cell
argument_list|>
name|getFull
parameter_list|(
specifier|final
name|long
name|transactionId
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|Set
argument_list|<
name|byte
index|[]
argument_list|>
name|columns
parameter_list|,
specifier|final
name|long
name|ts
parameter_list|)
throws|throws
name|IOException
block|{
name|TransactionState
name|state
init|=
name|getTransactionState
argument_list|(
name|transactionId
argument_list|)
decl_stmt|;
name|state
operator|.
name|addRead
argument_list|(
name|row
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|Cell
argument_list|>
name|localCells
init|=
name|state
operator|.
name|localGetFull
argument_list|(
name|row
argument_list|,
name|columns
argument_list|,
name|ts
argument_list|)
decl_stmt|;
if|if
condition|(
name|localCells
operator|!=
literal|null
operator|&&
name|localCells
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Transactional get of something we've written in the same transaction "
operator|+
name|transactionId
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"row: "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|row
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|Cell
argument_list|>
name|entry
range|:
name|localCells
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"col: "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"cell: "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|Cell
argument_list|>
name|internalResults
init|=
name|getFull
argument_list|(
name|row
argument_list|,
name|columns
argument_list|,
name|ts
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|internalResults
operator|.
name|putAll
argument_list|(
name|localCells
argument_list|)
expr_stmt|;
return|return
name|internalResults
return|;
block|}
return|return
name|getFull
argument_list|(
name|row
argument_list|,
name|columns
argument_list|,
name|ts
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Return an iterator that scans over the HRegion, returning the indicated    * columns for only the rows that match the data filter. This Iterator must be    * closed by the caller.    *     * @param transactionId    * @param cols columns to scan. If column name is a column family, all columns    * of the specified column family are returned. Its also possible to pass a    * regex in the column qualifier. A column qualifier is judged to be a regex    * if it contains at least one of the following characters:    *<code>\+|^&*$[]]}{)(</code>.    * @param firstRow row which is the starting point of the scan    * @param timestamp only return rows whose timestamp is<= this value    * @param filter row filter    * @return InternalScanner    * @throws IOException    */
specifier|public
name|InternalScanner
name|getScanner
parameter_list|(
specifier|final
name|long
name|transactionId
parameter_list|,
specifier|final
name|byte
index|[]
index|[]
name|cols
parameter_list|,
specifier|final
name|byte
index|[]
name|firstRow
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|,
specifier|final
name|RowFilterInterface
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|ScannerWrapper
argument_list|(
name|transactionId
argument_list|,
name|super
operator|.
name|getScanner
argument_list|(
name|cols
argument_list|,
name|firstRow
argument_list|,
name|timestamp
argument_list|,
name|filter
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Add a write to the transaction. Does not get applied until commit process.    *     * @param transactionId    * @param b    * @throws IOException    */
specifier|public
name|void
name|batchUpdate
parameter_list|(
specifier|final
name|long
name|transactionId
parameter_list|,
specifier|final
name|BatchUpdate
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|TransactionState
name|state
init|=
name|getTransactionState
argument_list|(
name|transactionId
argument_list|)
decl_stmt|;
name|state
operator|.
name|addWrite
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|logManager
operator|.
name|writeUpdateToLog
argument_list|(
name|transactionId
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a delete to the transaction. Does not get applied until commit process.    * FIXME, not sure about this approach    *     * @param transactionId    * @param row    * @param timestamp    * @throws IOException    */
specifier|public
name|void
name|deleteAll
parameter_list|(
specifier|final
name|long
name|transactionId
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|)
throws|throws
name|IOException
block|{
name|TransactionState
name|state
init|=
name|getTransactionState
argument_list|(
name|transactionId
argument_list|)
decl_stmt|;
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
for|for
control|(
name|HStore
name|store
range|:
name|super
operator|.
name|stores
operator|.
name|values
argument_list|()
control|)
block|{
name|List
argument_list|<
name|HStoreKey
argument_list|>
name|keys
init|=
name|store
operator|.
name|getKeys
argument_list|(
operator|new
name|HStoreKey
argument_list|(
name|row
argument_list|,
name|timestamp
argument_list|)
argument_list|,
name|ALL_VERSIONS
argument_list|,
name|now
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|BatchUpdate
name|deleteUpdate
init|=
operator|new
name|BatchUpdate
argument_list|(
name|row
argument_list|,
name|timestamp
argument_list|)
decl_stmt|;
for|for
control|(
name|HStoreKey
name|key
range|:
name|keys
control|)
block|{
name|deleteUpdate
operator|.
name|delete
argument_list|(
name|key
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|state
operator|.
name|addWrite
argument_list|(
name|deleteUpdate
argument_list|)
expr_stmt|;
name|logManager
operator|.
name|writeUpdateToLog
argument_list|(
name|transactionId
argument_list|,
name|deleteUpdate
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @param transactionId    * @return true if commit is successful    * @throws IOException    */
specifier|public
name|boolean
name|commitRequest
parameter_list|(
specifier|final
name|long
name|transactionId
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|commitCheckLock
init|)
block|{
name|TransactionState
name|state
init|=
name|getTransactionState
argument_list|(
name|transactionId
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|hasConflict
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|state
operator|.
name|setStatus
argument_list|(
name|Status
operator|.
name|ABORTED
argument_list|)
expr_stmt|;
name|retireTransaction
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// No conflicts, we can commit.
name|LOG
operator|.
name|trace
argument_list|(
literal|"No conflicts for transaction "
operator|+
name|transactionId
operator|+
literal|" found in region "
operator|+
name|super
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|". Voting for commit"
argument_list|)
expr_stmt|;
name|state
operator|.
name|setStatus
argument_list|(
name|Status
operator|.
name|COMMIT_PENDING
argument_list|)
expr_stmt|;
comment|// If there are writes we must keep record off the transaction
if|if
condition|(
name|state
operator|.
name|getWriteSet
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Order is important
name|commitPendingTransactions
operator|.
name|add
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|state
operator|.
name|setSequenceNumber
argument_list|(
name|nextSequenceId
operator|.
name|getAndIncrement
argument_list|()
argument_list|)
expr_stmt|;
name|commitedTransactionsBySequenceNumber
operator|.
name|put
argument_list|(
name|state
operator|.
name|getSequenceNumber
argument_list|()
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
specifier|private
name|boolean
name|hasConflict
parameter_list|(
specifier|final
name|TransactionState
name|state
parameter_list|)
block|{
comment|// Check transactions that were committed while we were running
for|for
control|(
name|int
name|i
init|=
name|state
operator|.
name|getStartSequenceNumber
argument_list|()
init|;
name|i
operator|<
name|nextSequenceId
operator|.
name|get
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|TransactionState
name|other
init|=
name|commitedTransactionsBySequenceNumber
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|other
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|state
operator|.
name|addTransactionToCheck
argument_list|(
name|other
argument_list|)
expr_stmt|;
block|}
return|return
name|state
operator|.
name|hasConflict
argument_list|()
return|;
block|}
comment|/**    * Commit the transaction.    *     * @param transactionId    * @throws IOException    */
specifier|public
name|void
name|commit
parameter_list|(
specifier|final
name|long
name|transactionId
parameter_list|)
throws|throws
name|IOException
block|{
name|TransactionState
name|state
decl_stmt|;
try|try
block|{
name|state
operator|=
name|getTransactionState
argument_list|(
name|transactionId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownTransactionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Asked to commit unknown transaction: "
operator|+
name|transactionId
operator|+
literal|" in region "
operator|+
name|super
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
comment|// FIXME Write to the transaction log that this transaction was corrupted
throw|throw
name|e
throw|;
block|}
if|if
condition|(
operator|!
name|state
operator|.
name|getStatus
argument_list|()
operator|.
name|equals
argument_list|(
name|Status
operator|.
name|COMMIT_PENDING
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Asked to commit a non pending transaction"
argument_list|)
expr_stmt|;
comment|// FIXME Write to the transaction log that this transaction was corrupted
throw|throw
operator|new
name|IOException
argument_list|(
literal|"commit failure"
argument_list|)
throw|;
block|}
name|commit
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
comment|/**    * Commit the transaction.    *     * @param transactionId    * @throws IOException    */
specifier|public
name|void
name|abort
parameter_list|(
specifier|final
name|long
name|transactionId
parameter_list|)
throws|throws
name|IOException
block|{
name|TransactionState
name|state
decl_stmt|;
try|try
block|{
name|state
operator|=
name|getTransactionState
argument_list|(
name|transactionId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownTransactionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Asked to abort unknown transaction: "
operator|+
name|transactionId
argument_list|)
expr_stmt|;
return|return;
block|}
name|state
operator|.
name|setStatus
argument_list|(
name|Status
operator|.
name|ABORTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|getWriteSet
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|logManager
operator|.
name|writeAbortToLog
argument_list|(
name|state
operator|.
name|getTransactionId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Following removes needed if we have voted
if|if
condition|(
name|state
operator|.
name|getSequenceNumber
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|commitedTransactionsBySequenceNumber
operator|.
name|remove
argument_list|(
name|state
operator|.
name|getSequenceNumber
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|commitPendingTransactions
operator|.
name|remove
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|retireTransaction
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|commit
parameter_list|(
specifier|final
name|TransactionState
name|state
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Commiting transaction: "
operator|+
name|state
operator|.
name|toString
argument_list|()
operator|+
literal|" to "
operator|+
name|super
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|getWriteSet
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|logManager
operator|.
name|writeCommitToLog
argument_list|(
name|state
operator|.
name|getTransactionId
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|BatchUpdate
name|update
range|:
name|state
operator|.
name|getWriteSet
argument_list|()
control|)
block|{
name|super
operator|.
name|batchUpdate
argument_list|(
name|update
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Don't need to WAL these
comment|// FIME, maybe should be walled so we don't need to look so far back.
block|}
name|state
operator|.
name|setStatus
argument_list|(
name|Status
operator|.
name|COMMITED
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|getWriteSet
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
operator|!
name|commitPendingTransactions
operator|.
name|remove
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Commiting a non-query transaction that is not in commitPendingTransactions"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"commit failure"
argument_list|)
throw|;
comment|// FIXME, how to handle?
block|}
name|retireTransaction
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
comment|// Cancel leases, and removed from lease lookup. This transaction may still
comment|// live in commitedTransactionsBySequenceNumber and commitPendingTransactions
specifier|private
name|void
name|retireTransaction
parameter_list|(
specifier|final
name|TransactionState
name|state
parameter_list|)
block|{
name|String
name|key
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|state
operator|.
name|getTransactionId
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|transactionLeases
operator|.
name|cancelLease
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LeaseException
name|e
parameter_list|)
block|{
comment|// Ignore
block|}
name|transactionsById
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
specifier|private
name|TransactionState
name|getTransactionState
parameter_list|(
specifier|final
name|long
name|transactionId
parameter_list|)
throws|throws
name|UnknownTransactionException
block|{
name|String
name|key
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|transactionId
argument_list|)
decl_stmt|;
name|TransactionState
name|state
init|=
literal|null
decl_stmt|;
name|state
operator|=
name|transactionsById
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Unknown transaction: "
operator|+
name|key
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|UnknownTransactionException
argument_list|(
name|key
argument_list|)
throw|;
block|}
try|try
block|{
name|transactionLeases
operator|.
name|renewLease
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LeaseException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|state
return|;
block|}
specifier|private
name|void
name|maybeTriggerOldTransactionFlush
parameter_list|()
block|{
if|if
condition|(
name|commitedTransactionsBySequenceNumber
operator|.
name|size
argument_list|()
operator|>
name|oldTransactionFlushTrigger
condition|)
block|{
name|removeUnNeededCommitedTransactions
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Cleanup references to committed transactions that are no longer needed.    *     */
specifier|synchronized
name|void
name|removeUnNeededCommitedTransactions
parameter_list|()
block|{
name|Integer
name|minStartSeqNumber
init|=
name|getMinStartSequenceNumber
argument_list|()
decl_stmt|;
if|if
condition|(
name|minStartSeqNumber
operator|==
literal|null
condition|)
block|{
name|minStartSeqNumber
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
comment|// Remove all
block|}
name|int
name|numRemoved
init|=
literal|0
decl_stmt|;
comment|// Copy list to avoid conc update exception
for|for
control|(
name|Entry
argument_list|<
name|Integer
argument_list|,
name|TransactionState
argument_list|>
name|entry
range|:
operator|new
name|LinkedList
argument_list|<
name|Entry
argument_list|<
name|Integer
argument_list|,
name|TransactionState
argument_list|>
argument_list|>
argument_list|(
name|commitedTransactionsBySequenceNumber
operator|.
name|entrySet
argument_list|()
argument_list|)
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getKey
argument_list|()
operator|>=
name|minStartSeqNumber
condition|)
block|{
break|break;
block|}
name|numRemoved
operator|=
name|numRemoved
operator|+
operator|(
name|commitedTransactionsBySequenceNumber
operator|.
name|remove
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|==
literal|null
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
name|numRemoved
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|numRemoved
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removed "
operator|+
name|numRemoved
operator|+
literal|" commited transactions with sequence lower than "
operator|+
name|minStartSeqNumber
operator|+
literal|". Still have "
operator|+
name|commitedTransactionsBySequenceNumber
operator|.
name|size
argument_list|()
operator|+
literal|" left"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|commitedTransactionsBySequenceNumber
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Could not remove any transactions, and still have "
operator|+
name|commitedTransactionsBySequenceNumber
operator|.
name|size
argument_list|()
operator|+
literal|" left"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|Integer
name|getMinStartSequenceNumber
parameter_list|()
block|{
name|Integer
name|min
init|=
literal|null
decl_stmt|;
for|for
control|(
name|TransactionState
name|transactionState
range|:
name|transactionsById
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|min
operator|==
literal|null
operator|||
name|transactionState
operator|.
name|getStartSequenceNumber
argument_list|()
operator|<
name|min
condition|)
block|{
name|min
operator|=
name|transactionState
operator|.
name|getStartSequenceNumber
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|min
return|;
block|}
comment|// TODO, resolve from the global transaction log
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|private
name|void
name|resolveTransactionFromLog
parameter_list|(
specifier|final
name|long
name|transactionId
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Globaql transaction log is not Implemented"
argument_list|)
throw|;
block|}
specifier|private
class|class
name|TransactionLeaseListener
implements|implements
name|LeaseListener
block|{
specifier|private
specifier|final
name|String
name|transactionName
decl_stmt|;
name|TransactionLeaseListener
parameter_list|(
specifier|final
name|String
name|n
parameter_list|)
block|{
name|this
operator|.
name|transactionName
operator|=
name|n
expr_stmt|;
block|}
specifier|public
name|void
name|leaseExpired
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Transaction "
operator|+
name|this
operator|.
name|transactionName
operator|+
literal|" lease expired"
argument_list|)
expr_stmt|;
name|TransactionState
name|s
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|transactionsById
init|)
block|{
name|s
operator|=
name|transactionsById
operator|.
name|remove
argument_list|(
name|transactionName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unknown transaction expired "
operator|+
name|this
operator|.
name|transactionName
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|s
operator|.
name|getStatus
argument_list|()
condition|)
block|{
case|case
name|PENDING
case|:
name|s
operator|.
name|setStatus
argument_list|(
name|Status
operator|.
name|ABORTED
argument_list|)
expr_stmt|;
comment|// Other transactions may have a ref
break|break;
case|case
name|COMMIT_PENDING
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Transaction "
operator|+
name|s
operator|.
name|getTransactionId
argument_list|()
operator|+
literal|" expired in COMMIT_PENDING state"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Checking transaction status in transaction log"
argument_list|)
expr_stmt|;
name|resolveTransactionFromLog
argument_list|(
name|s
operator|.
name|getTransactionId
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected status on expired lease"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Wrapper which keeps track of rows returned by scanner. */
specifier|private
class|class
name|ScannerWrapper
implements|implements
name|InternalScanner
block|{
specifier|private
name|long
name|transactionId
decl_stmt|;
specifier|private
name|InternalScanner
name|scanner
decl_stmt|;
comment|/**      * @param transactionId      * @param scanner      */
specifier|public
name|ScannerWrapper
parameter_list|(
specifier|final
name|long
name|transactionId
parameter_list|,
specifier|final
name|InternalScanner
name|scanner
parameter_list|)
block|{
name|this
operator|.
name|transactionId
operator|=
name|transactionId
expr_stmt|;
name|this
operator|.
name|scanner
operator|=
name|scanner
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|scanner
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
specifier|public
name|boolean
name|isMultipleMatchScanner
parameter_list|()
block|{
return|return
name|scanner
operator|.
name|isMultipleMatchScanner
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|isWildcardScanner
parameter_list|()
block|{
return|return
name|scanner
operator|.
name|isWildcardScanner
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|next
parameter_list|(
specifier|final
name|HStoreKey
name|key
parameter_list|,
specifier|final
name|SortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|Cell
argument_list|>
name|results
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|result
init|=
name|scanner
operator|.
name|next
argument_list|(
name|key
argument_list|,
name|results
argument_list|)
decl_stmt|;
name|TransactionState
name|state
init|=
name|getTransactionState
argument_list|(
name|transactionId
argument_list|)
decl_stmt|;
name|state
operator|.
name|setHasScan
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// FIXME, not using row, just claiming read over the whole region. We are
comment|// being very conservative on scans to avoid phantom reads.
name|state
operator|.
name|addRead
argument_list|(
name|key
operator|.
name|getRow
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|Cell
argument_list|>
name|localWrites
init|=
name|state
operator|.
name|localGetFull
argument_list|(
name|key
operator|.
name|getRow
argument_list|()
argument_list|,
literal|null
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
if|if
condition|(
name|localWrites
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Scanning over row that has been writen to "
operator|+
name|transactionId
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|Cell
argument_list|>
name|entry
range|:
name|localWrites
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|results
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
block|}
block|}
end_class

end_unit

