begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2008 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|transactional
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|RowFilterInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|RowFilterSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|StopRowFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|WhileMatchRowFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|BatchOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|BatchUpdate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|Cell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_comment
comment|/**  * Holds the state of a transaction.  */
end_comment

begin_class
class|class
name|TransactionState
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TransactionState
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** Current status. */
specifier|public
enum|enum
name|Status
block|{
comment|/** Initial status, still performing operations. */
name|PENDING
block|,
comment|/**      * Checked if we can commit, and said yes. Still need to determine the      * global decision.      */
name|COMMIT_PENDING
block|,
comment|/** Committed. */
name|COMMITED
block|,
comment|/** Aborted. */
name|ABORTED
block|}
comment|/**    * Simple container of the range of the scanners we've opened. Used to check    * for conflicting writes.    */
specifier|private
specifier|static
class|class
name|ScanRange
block|{
specifier|protected
name|byte
index|[]
name|startRow
decl_stmt|;
specifier|protected
name|byte
index|[]
name|endRow
decl_stmt|;
specifier|public
name|ScanRange
parameter_list|(
name|byte
index|[]
name|startRow
parameter_list|,
name|byte
index|[]
name|endRow
parameter_list|)
block|{
name|this
operator|.
name|startRow
operator|=
name|startRow
expr_stmt|;
name|this
operator|.
name|endRow
operator|=
name|endRow
expr_stmt|;
block|}
comment|/**      * Check if this scan range contains the given key.      *       * @param rowKey      * @return boolean      */
specifier|public
name|boolean
name|contains
parameter_list|(
name|byte
index|[]
name|rowKey
parameter_list|)
block|{
if|if
condition|(
name|startRow
operator|!=
literal|null
operator|&&
name|Bytes
operator|.
name|compareTo
argument_list|(
name|rowKey
argument_list|,
name|startRow
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|endRow
operator|!=
literal|null
operator|&&
name|Bytes
operator|.
name|compareTo
argument_list|(
name|endRow
argument_list|,
name|rowKey
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
specifier|private
specifier|final
name|HRegionInfo
name|regionInfo
decl_stmt|;
specifier|private
specifier|final
name|long
name|hLogStartSequenceId
decl_stmt|;
specifier|private
specifier|final
name|long
name|transactionId
decl_stmt|;
specifier|private
name|Status
name|status
decl_stmt|;
specifier|private
name|SortedSet
argument_list|<
name|byte
index|[]
argument_list|>
name|readSet
init|=
operator|new
name|TreeSet
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
specifier|private
name|List
argument_list|<
name|BatchUpdate
argument_list|>
name|writeSet
init|=
operator|new
name|LinkedList
argument_list|<
name|BatchUpdate
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|List
argument_list|<
name|ScanRange
argument_list|>
name|scanSet
init|=
operator|new
name|LinkedList
argument_list|<
name|ScanRange
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|TransactionState
argument_list|>
name|transactionsToCheck
init|=
operator|new
name|HashSet
argument_list|<
name|TransactionState
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|int
name|startSequenceNumber
decl_stmt|;
specifier|private
name|Integer
name|sequenceNumber
decl_stmt|;
name|TransactionState
parameter_list|(
specifier|final
name|long
name|transactionId
parameter_list|,
specifier|final
name|long
name|rLogStartSequenceId
parameter_list|,
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
name|this
operator|.
name|transactionId
operator|=
name|transactionId
expr_stmt|;
name|this
operator|.
name|hLogStartSequenceId
operator|=
name|rLogStartSequenceId
expr_stmt|;
name|this
operator|.
name|regionInfo
operator|=
name|regionInfo
expr_stmt|;
name|this
operator|.
name|status
operator|=
name|Status
operator|.
name|PENDING
expr_stmt|;
block|}
name|void
name|addRead
parameter_list|(
specifier|final
name|byte
index|[]
name|rowKey
parameter_list|)
block|{
name|readSet
operator|.
name|add
argument_list|(
name|rowKey
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|byte
index|[]
argument_list|>
name|getReadSet
parameter_list|()
block|{
return|return
name|readSet
return|;
block|}
name|void
name|addWrite
parameter_list|(
specifier|final
name|BatchUpdate
name|write
parameter_list|)
block|{
name|writeSet
operator|.
name|add
argument_list|(
name|write
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|BatchUpdate
argument_list|>
name|getWriteSet
parameter_list|()
block|{
return|return
name|writeSet
return|;
block|}
comment|/**    * GetFull from the writeSet.    *     * @param row    * @param columns    * @param timestamp    * @return    */
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|Cell
argument_list|>
name|localGetFull
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|Set
argument_list|<
name|byte
index|[]
argument_list|>
name|columns
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|)
block|{
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|Cell
argument_list|>
name|results
init|=
operator|new
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|Cell
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
comment|// Must use the Bytes Conparator because
for|for
control|(
name|BatchUpdate
name|b
range|:
name|writeSet
control|)
block|{
if|if
condition|(
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|row
argument_list|,
name|b
operator|.
name|getRow
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|b
operator|.
name|getTimestamp
argument_list|()
operator|>
name|timestamp
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|BatchOperation
name|op
range|:
name|b
control|)
block|{
if|if
condition|(
operator|!
name|op
operator|.
name|isPut
argument_list|()
operator|||
operator|(
name|columns
operator|!=
literal|null
operator|&&
operator|!
name|columns
operator|.
name|contains
argument_list|(
name|op
operator|.
name|getColumn
argument_list|()
argument_list|)
operator|)
condition|)
block|{
continue|continue;
block|}
name|results
operator|.
name|put
argument_list|(
name|op
operator|.
name|getColumn
argument_list|()
argument_list|,
operator|new
name|Cell
argument_list|(
name|op
operator|.
name|getValue
argument_list|()
argument_list|,
name|b
operator|.
name|getTimestamp
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|results
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|?
literal|null
else|:
name|results
return|;
block|}
comment|/**    * Get from the writeSet.    *     * @param row    * @param column    * @param timestamp    * @return    */
name|Cell
index|[]
name|localGet
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|column
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|Cell
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|Cell
argument_list|>
argument_list|()
decl_stmt|;
comment|// Go in reverse order to put newest updates first in list
for|for
control|(
name|int
name|i
init|=
name|writeSet
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|BatchUpdate
name|b
init|=
name|writeSet
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|row
argument_list|,
name|b
operator|.
name|getRow
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|b
operator|.
name|getTimestamp
argument_list|()
operator|>
name|timestamp
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|BatchOperation
name|op
range|:
name|b
control|)
block|{
if|if
condition|(
operator|!
name|op
operator|.
name|isPut
argument_list|()
operator|||
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|column
argument_list|,
name|op
operator|.
name|getColumn
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|results
operator|.
name|add
argument_list|(
operator|new
name|Cell
argument_list|(
name|op
operator|.
name|getValue
argument_list|()
argument_list|,
name|b
operator|.
name|getTimestamp
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|results
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|?
literal|null
else|:
name|results
operator|.
name|toArray
argument_list|(
operator|new
name|Cell
index|[
name|results
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
name|void
name|addTransactionToCheck
parameter_list|(
specifier|final
name|TransactionState
name|transaction
parameter_list|)
block|{
name|transactionsToCheck
operator|.
name|add
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
name|boolean
name|hasConflict
parameter_list|()
block|{
for|for
control|(
name|TransactionState
name|transactionState
range|:
name|transactionsToCheck
control|)
block|{
if|if
condition|(
name|hasConflict
argument_list|(
name|transactionState
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|hasConflict
parameter_list|(
specifier|final
name|TransactionState
name|checkAgainst
parameter_list|)
block|{
if|if
condition|(
name|checkAgainst
operator|.
name|getStatus
argument_list|()
operator|.
name|equals
argument_list|(
name|TransactionState
operator|.
name|Status
operator|.
name|ABORTED
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
comment|// Cannot conflict with aborted transactions
block|}
for|for
control|(
name|BatchUpdate
name|otherUpdate
range|:
name|checkAgainst
operator|.
name|getWriteSet
argument_list|()
control|)
block|{
if|if
condition|(
name|this
operator|.
name|getReadSet
argument_list|()
operator|.
name|contains
argument_list|(
name|otherUpdate
operator|.
name|getRow
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Transaction ["
operator|+
name|this
operator|.
name|toString
argument_list|()
operator|+
literal|"] has read which conflicts with ["
operator|+
name|checkAgainst
operator|.
name|toString
argument_list|()
operator|+
literal|"]: region ["
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|"], row["
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|otherUpdate
operator|.
name|getRow
argument_list|()
argument_list|)
operator|+
literal|"]"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
for|for
control|(
name|ScanRange
name|scanRange
range|:
name|this
operator|.
name|scanSet
control|)
block|{
if|if
condition|(
name|scanRange
operator|.
name|contains
argument_list|(
name|otherUpdate
operator|.
name|getRow
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Transaction ["
operator|+
name|this
operator|.
name|toString
argument_list|()
operator|+
literal|"] has scan which conflicts with ["
operator|+
name|checkAgainst
operator|.
name|toString
argument_list|()
operator|+
literal|"]: region ["
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|"], row["
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|otherUpdate
operator|.
name|getRow
argument_list|()
argument_list|)
operator|+
literal|"]"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Get the status.    *     * @return Return the status.    */
name|Status
name|getStatus
parameter_list|()
block|{
return|return
name|status
return|;
block|}
comment|/**    * Set the status.    *     * @param status The status to set.    */
name|void
name|setStatus
parameter_list|(
specifier|final
name|Status
name|status
parameter_list|)
block|{
name|this
operator|.
name|status
operator|=
name|status
expr_stmt|;
block|}
comment|/**    * Get the startSequenceNumber.    *     * @return Return the startSequenceNumber.    */
name|int
name|getStartSequenceNumber
parameter_list|()
block|{
return|return
name|startSequenceNumber
return|;
block|}
comment|/**    * Set the startSequenceNumber.    *     * @param startSequenceNumber    */
name|void
name|setStartSequenceNumber
parameter_list|(
specifier|final
name|int
name|startSequenceNumber
parameter_list|)
block|{
name|this
operator|.
name|startSequenceNumber
operator|=
name|startSequenceNumber
expr_stmt|;
block|}
comment|/**    * Get the sequenceNumber.    *     * @return Return the sequenceNumber.    */
name|Integer
name|getSequenceNumber
parameter_list|()
block|{
return|return
name|sequenceNumber
return|;
block|}
comment|/**    * Set the sequenceNumber.    *     * @param sequenceNumber The sequenceNumber to set.    */
name|void
name|setSequenceNumber
parameter_list|(
specifier|final
name|Integer
name|sequenceNumber
parameter_list|)
block|{
name|this
operator|.
name|sequenceNumber
operator|=
name|sequenceNumber
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|"[transactionId: "
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|transactionId
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|" status: "
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|status
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|" read Size: "
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|readSet
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|" scan Size: "
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|scanSet
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|" write Size: "
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|writeSet
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|" startSQ: "
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|startSequenceNumber
argument_list|)
expr_stmt|;
if|if
condition|(
name|sequenceNumber
operator|!=
literal|null
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|" commitedSQ:"
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|sequenceNumber
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Get the transactionId.    *     * @return Return the transactionId.    */
name|long
name|getTransactionId
parameter_list|()
block|{
return|return
name|transactionId
return|;
block|}
comment|/**    * Get the startSequenceId.    *     * @return Return the startSequenceId.    */
name|long
name|getHLogStartSequenceId
parameter_list|()
block|{
return|return
name|hLogStartSequenceId
return|;
block|}
name|void
name|addScan
parameter_list|(
name|byte
index|[]
name|firstRow
parameter_list|,
name|RowFilterInterface
name|filter
parameter_list|)
block|{
name|ScanRange
name|scanRange
init|=
operator|new
name|ScanRange
argument_list|(
name|firstRow
argument_list|,
name|getEndRow
argument_list|(
name|filter
argument_list|)
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Adding scan for transcaction [%s], from [%s] to [%s]"
argument_list|,
name|transactionId
argument_list|,
name|scanRange
operator|.
name|startRow
operator|==
literal|null
condition|?
literal|"null"
else|:
name|Bytes
operator|.
name|toString
argument_list|(
name|scanRange
operator|.
name|startRow
argument_list|)
argument_list|,
name|scanRange
operator|.
name|endRow
operator|==
literal|null
condition|?
literal|"null"
else|:
name|Bytes
operator|.
name|toString
argument_list|(
name|scanRange
operator|.
name|endRow
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|scanSet
operator|.
name|add
argument_list|(
name|scanRange
argument_list|)
expr_stmt|;
block|}
specifier|private
name|byte
index|[]
name|getEndRow
parameter_list|(
name|RowFilterInterface
name|filter
parameter_list|)
block|{
if|if
condition|(
name|filter
operator|instanceof
name|WhileMatchRowFilter
condition|)
block|{
name|WhileMatchRowFilter
name|wmrFilter
init|=
operator|(
name|WhileMatchRowFilter
operator|)
name|filter
decl_stmt|;
if|if
condition|(
name|wmrFilter
operator|.
name|getInternalFilter
argument_list|()
operator|instanceof
name|StopRowFilter
condition|)
block|{
name|StopRowFilter
name|stopFilter
init|=
operator|(
name|StopRowFilter
operator|)
name|wmrFilter
operator|.
name|getInternalFilter
argument_list|()
decl_stmt|;
return|return
name|stopFilter
operator|.
name|getStopRowKey
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|filter
operator|instanceof
name|RowFilterSet
condition|)
block|{
name|RowFilterSet
name|rowFilterSet
init|=
operator|(
name|RowFilterSet
operator|)
name|filter
decl_stmt|;
if|if
condition|(
name|rowFilterSet
operator|.
name|getOperator
argument_list|()
operator|.
name|equals
argument_list|(
name|RowFilterSet
operator|.
name|Operator
operator|.
name|MUST_PASS_ALL
argument_list|)
condition|)
block|{
for|for
control|(
name|RowFilterInterface
name|subFilter
range|:
name|rowFilterSet
operator|.
name|getFilters
argument_list|()
control|)
block|{
name|byte
index|[]
name|endRow
init|=
name|getEndRow
argument_list|(
name|subFilter
argument_list|)
decl_stmt|;
if|if
condition|(
name|endRow
operator|!=
literal|null
condition|)
block|{
return|return
name|endRow
return|;
block|}
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
end_class

end_unit

