begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2008 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|transactional
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|BatchOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|BatchUpdate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|Cell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_comment
comment|/**  * Holds the state of a transaction.  */
end_comment

begin_class
class|class
name|TransactionState
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TransactionState
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** Current status. */
specifier|public
enum|enum
name|Status
block|{
comment|/** Initial status, still performing operations. */
name|PENDING
block|,
comment|/**      * Checked if we can commit, and said yes. Still need to determine the      * global decision.      */
name|COMMIT_PENDING
block|,
comment|/** Committed. */
name|COMMITED
block|,
comment|/** Aborted. */
name|ABORTED
block|}
specifier|private
specifier|final
name|long
name|hLogStartSequenceId
decl_stmt|;
specifier|private
specifier|final
name|long
name|transactionId
decl_stmt|;
specifier|private
name|Status
name|status
decl_stmt|;
specifier|private
name|SortedSet
argument_list|<
name|byte
index|[]
argument_list|>
name|readSet
init|=
operator|new
name|TreeSet
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
specifier|private
name|List
argument_list|<
name|BatchUpdate
argument_list|>
name|writeSet
init|=
operator|new
name|LinkedList
argument_list|<
name|BatchUpdate
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|TransactionState
argument_list|>
name|transactionsToCheck
init|=
operator|new
name|HashSet
argument_list|<
name|TransactionState
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|int
name|startSequenceNumber
decl_stmt|;
specifier|private
name|Integer
name|sequenceNumber
decl_stmt|;
name|boolean
name|hasScan
init|=
literal|false
decl_stmt|;
comment|//TODO: Why don't these methods and the class itself use default access?
comment|//      They are only referenced from within this package.
specifier|public
name|TransactionState
parameter_list|(
specifier|final
name|long
name|transactionId
parameter_list|,
specifier|final
name|long
name|rLogStartSequenceId
parameter_list|)
block|{
name|this
operator|.
name|transactionId
operator|=
name|transactionId
expr_stmt|;
name|this
operator|.
name|hLogStartSequenceId
operator|=
name|rLogStartSequenceId
expr_stmt|;
name|this
operator|.
name|status
operator|=
name|Status
operator|.
name|PENDING
expr_stmt|;
block|}
specifier|public
name|void
name|addRead
parameter_list|(
specifier|final
name|byte
index|[]
name|rowKey
parameter_list|)
block|{
name|readSet
operator|.
name|add
argument_list|(
name|rowKey
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Set
argument_list|<
name|byte
index|[]
argument_list|>
name|getReadSet
parameter_list|()
block|{
return|return
name|readSet
return|;
block|}
specifier|public
name|void
name|addWrite
parameter_list|(
specifier|final
name|BatchUpdate
name|write
parameter_list|)
block|{
name|writeSet
operator|.
name|add
argument_list|(
name|write
argument_list|)
expr_stmt|;
block|}
specifier|public
name|List
argument_list|<
name|BatchUpdate
argument_list|>
name|getWriteSet
parameter_list|()
block|{
return|return
name|writeSet
return|;
block|}
comment|/**    * GetFull from the writeSet.    *     * @param row    * @param columns    * @param timestamp    * @return    */
specifier|public
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|Cell
argument_list|>
name|localGetFull
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|Set
argument_list|<
name|byte
index|[]
argument_list|>
name|columns
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|)
block|{
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|Cell
argument_list|>
name|results
init|=
operator|new
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|Cell
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
comment|// Must use the Bytes Conparator because
for|for
control|(
name|BatchUpdate
name|b
range|:
name|writeSet
control|)
block|{
if|if
condition|(
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|row
argument_list|,
name|b
operator|.
name|getRow
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|b
operator|.
name|getTimestamp
argument_list|()
operator|>
name|timestamp
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|BatchOperation
name|op
range|:
name|b
control|)
block|{
if|if
condition|(
operator|!
name|op
operator|.
name|isPut
argument_list|()
operator|||
operator|(
name|columns
operator|!=
literal|null
operator|&&
operator|!
name|columns
operator|.
name|contains
argument_list|(
name|op
operator|.
name|getColumn
argument_list|()
argument_list|)
operator|)
condition|)
block|{
continue|continue;
block|}
name|results
operator|.
name|put
argument_list|(
name|op
operator|.
name|getColumn
argument_list|()
argument_list|,
operator|new
name|Cell
argument_list|(
name|op
operator|.
name|getValue
argument_list|()
argument_list|,
name|b
operator|.
name|getTimestamp
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|results
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|?
literal|null
else|:
name|results
return|;
block|}
comment|/**    * Get from the writeSet.    *     * @param row    * @param column    * @param timestamp    * @return    */
specifier|public
name|Cell
index|[]
name|localGet
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|column
parameter_list|,
specifier|final
name|long
name|timestamp
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|Cell
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|Cell
argument_list|>
argument_list|()
decl_stmt|;
comment|// Go in reverse order to put newest updates first in list
for|for
control|(
name|int
name|i
init|=
name|writeSet
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|BatchUpdate
name|b
init|=
name|writeSet
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|row
argument_list|,
name|b
operator|.
name|getRow
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|b
operator|.
name|getTimestamp
argument_list|()
operator|>
name|timestamp
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|BatchOperation
name|op
range|:
name|b
control|)
block|{
if|if
condition|(
operator|!
name|op
operator|.
name|isPut
argument_list|()
operator|||
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|column
argument_list|,
name|op
operator|.
name|getColumn
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|results
operator|.
name|add
argument_list|(
operator|new
name|Cell
argument_list|(
name|op
operator|.
name|getValue
argument_list|()
argument_list|,
name|b
operator|.
name|getTimestamp
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|results
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|?
literal|null
else|:
name|results
operator|.
name|toArray
argument_list|(
operator|new
name|Cell
index|[
name|results
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
specifier|public
name|void
name|addTransactionToCheck
parameter_list|(
specifier|final
name|TransactionState
name|transaction
parameter_list|)
block|{
name|transactionsToCheck
operator|.
name|add
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|hasConflict
parameter_list|()
block|{
for|for
control|(
name|TransactionState
name|transactionState
range|:
name|transactionsToCheck
control|)
block|{
if|if
condition|(
name|hasConflict
argument_list|(
name|transactionState
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|hasConflict
parameter_list|(
specifier|final
name|TransactionState
name|checkAgainst
parameter_list|)
block|{
if|if
condition|(
name|checkAgainst
operator|.
name|getStatus
argument_list|()
operator|.
name|equals
argument_list|(
name|TransactionState
operator|.
name|Status
operator|.
name|ABORTED
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
comment|// Cannot conflict with aborted transactions
block|}
for|for
control|(
name|BatchUpdate
name|otherUpdate
range|:
name|checkAgainst
operator|.
name|getWriteSet
argument_list|()
control|)
block|{
if|if
condition|(
name|this
operator|.
name|hasScan
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Transaction"
operator|+
name|this
operator|.
name|toString
argument_list|()
operator|+
literal|" has a scan read. Meanwile a write occured. "
operator|+
literal|"Conservitivly reporting conflict"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|this
operator|.
name|getReadSet
argument_list|()
operator|.
name|contains
argument_list|(
name|otherUpdate
operator|.
name|getRow
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Transaction "
operator|+
name|this
operator|.
name|toString
argument_list|()
operator|+
literal|" conflicts with "
operator|+
name|checkAgainst
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Get the status.    *     * @return Return the status.    */
specifier|public
name|Status
name|getStatus
parameter_list|()
block|{
return|return
name|status
return|;
block|}
comment|/**    * Set the status.    *     * @param status The status to set.    */
specifier|public
name|void
name|setStatus
parameter_list|(
specifier|final
name|Status
name|status
parameter_list|)
block|{
name|this
operator|.
name|status
operator|=
name|status
expr_stmt|;
block|}
comment|/**    * Get the startSequenceNumber.    *     * @return Return the startSequenceNumber.    */
specifier|public
name|int
name|getStartSequenceNumber
parameter_list|()
block|{
return|return
name|startSequenceNumber
return|;
block|}
comment|/**    * Set the startSequenceNumber.    *     * @param startSequenceNumber.    */
specifier|public
name|void
name|setStartSequenceNumber
parameter_list|(
specifier|final
name|int
name|startSequenceNumber
parameter_list|)
block|{
name|this
operator|.
name|startSequenceNumber
operator|=
name|startSequenceNumber
expr_stmt|;
block|}
comment|/**    * Get the sequenceNumber.    *     * @return Return the sequenceNumber.    */
specifier|public
name|Integer
name|getSequenceNumber
parameter_list|()
block|{
return|return
name|sequenceNumber
return|;
block|}
comment|/**    * Set the sequenceNumber.    *     * @param sequenceNumber The sequenceNumber to set.    */
specifier|public
name|void
name|setSequenceNumber
parameter_list|(
specifier|final
name|Integer
name|sequenceNumber
parameter_list|)
block|{
name|this
operator|.
name|sequenceNumber
operator|=
name|sequenceNumber
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|"[transactionId: "
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|transactionId
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|" status: "
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|status
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|" read Size: "
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|readSet
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|" write Size: "
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|writeSet
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
literal|" startSQ: "
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|startSequenceNumber
argument_list|)
expr_stmt|;
if|if
condition|(
name|sequenceNumber
operator|!=
literal|null
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|" commitedSQ:"
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|sequenceNumber
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Get the transactionId.    *     * @return Return the transactionId.    */
specifier|public
name|long
name|getTransactionId
parameter_list|()
block|{
return|return
name|transactionId
return|;
block|}
comment|/**    * Get the startSequenceId.    *     * @return Return the startSequenceId.    */
specifier|public
name|long
name|getHLogStartSequenceId
parameter_list|()
block|{
return|return
name|hLogStartSequenceId
return|;
block|}
comment|/**    * Set the hasScan.    *     * @param hasScan The hasScan to set.    */
specifier|public
name|void
name|setHasScan
parameter_list|(
specifier|final
name|boolean
name|hasScan
parameter_list|)
block|{
name|this
operator|.
name|hasScan
operator|=
name|hasScan
expr_stmt|;
block|}
block|}
end_class

end_unit

