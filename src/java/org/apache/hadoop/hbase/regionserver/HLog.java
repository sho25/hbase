begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2007 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentSkipListMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Syncable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|RemoteExceptionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ClassSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|SequenceFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|SequenceFile
operator|.
name|CompressionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|SequenceFile
operator|.
name|Metadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|SequenceFile
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|DefaultCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_comment
comment|/**  * HLog stores all the edits to the HStore.  *  * It performs logfile-rolling, so external callers are not aware that the  * underlying file is being rolled.  *  *<p>  * A single HLog is used by several HRegions simultaneously.  *  *<p>  * Each HRegion is identified by a unique long<code>int</code>. HRegions do  * not need to declare themselves before using the HLog; they simply include  * their HRegion-id in the<code>append</code> or  *<code>completeCacheFlush</code> calls.  *  *<p>  * An HLog consists of multiple on-disk files, which have a chronological order.  * As data is flushed to other (better) on-disk structures, the log becomes  * obsolete. We can destroy all the log messages for a given HRegion-id up to  * the most-recent CACHEFLUSH message from that HRegion.  *  *<p>  * It's only practical to delete entire files. Thus, we delete an entire on-disk  * file F when all of the messages in F have a log-sequence-id that's older  * (smaller) than the most-recent CACHEFLUSH message for every HRegion that has  * a message in F.  *  *<p>  * Synchronized methods can never execute in parallel. However, between the  * start of a cache flush and the completion point, appends are allowed but log  * rolling is not. To prevent log rolling taking place during this period, a  * separate reentrant lock is used.  *  */
end_comment

begin_class
specifier|public
class|class
name|HLog
implements|implements
name|HConstants
implements|,
name|Syncable
block|{
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HLog
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|HLOG_DATFILE
init|=
literal|"hlog.dat."
decl_stmt|;
specifier|static
specifier|final
name|byte
index|[]
name|METAFAMILY
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"METAFAMILY"
argument_list|)
decl_stmt|;
specifier|static
specifier|final
name|byte
index|[]
name|METAROW
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"METAROW"
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|FileSystem
name|fs
decl_stmt|;
specifier|private
specifier|final
name|Path
name|dir
decl_stmt|;
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
specifier|private
specifier|final
name|LogRollListener
name|listener
decl_stmt|;
specifier|private
specifier|final
name|long
name|optionalFlushInterval
decl_stmt|;
specifier|private
specifier|final
name|long
name|blocksize
decl_stmt|;
specifier|private
specifier|final
name|int
name|flushlogentries
decl_stmt|;
specifier|private
specifier|final
name|AtomicInteger
name|unflushedEntries
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|private
specifier|volatile
name|long
name|lastLogFlushTime
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|append
decl_stmt|;
specifier|private
specifier|final
name|Method
name|syncfs
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|Object
index|[]
name|NO_ARGS
init|=
operator|new
name|Object
index|[]
block|{}
decl_stmt|;
comment|/*    * Current log file.    */
name|SequenceFile
operator|.
name|Writer
name|writer
decl_stmt|;
comment|/*    * Map of all log files but the current one.     */
specifier|final
name|SortedMap
argument_list|<
name|Long
argument_list|,
name|Path
argument_list|>
name|outputfiles
init|=
name|Collections
operator|.
name|synchronizedSortedMap
argument_list|(
operator|new
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Path
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|/*    * Map of region to last sequence/edit id.     */
specifier|private
specifier|final
name|ConcurrentSkipListMap
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
name|lastSeqWritten
init|=
operator|new
name|ConcurrentSkipListMap
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|closed
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
name|AtomicLong
name|logSeqNum
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|private
specifier|volatile
name|long
name|filenum
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|final
name|AtomicInteger
name|numEntries
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// Size of edits written so far. Used figuring when to rotate logs.
specifier|private
specifier|final
name|AtomicLong
name|editsSize
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// If> than this size, roll the log.
specifier|private
specifier|final
name|long
name|logrollsize
decl_stmt|;
comment|// This lock prevents starting a log roll during a cache flush.
comment|// synchronized is insufficient because a cache flush spans two method calls.
specifier|private
specifier|final
name|Lock
name|cacheFlushLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
comment|// We synchronize on updateLock to prevent updates and to prevent a log roll
comment|// during an update
specifier|private
specifier|final
name|Object
name|updateLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|enabled
decl_stmt|;
comment|/*    * If more than this many logs, force flush of oldest region to oldest edit    * goes to disk.  If too many and we crash, then will take forever replaying.    * Keep the number of logs tidy.    */
specifier|private
specifier|final
name|int
name|maxLogs
decl_stmt|;
specifier|static
name|byte
index|[]
name|COMPLETE_CACHE_FLUSH
decl_stmt|;
static|static
block|{
try|try
block|{
name|COMPLETE_CACHE_FLUSH
operator|=
literal|"HBASE::CACHEFLUSH"
operator|.
name|getBytes
argument_list|(
name|UTF8_ENCODING
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{
assert|assert
operator|(
literal|false
operator|)
assert|;
block|}
block|}
comment|/**    * Create an edit log at the given<code>dir</code> location.    *    * You should never have to load an existing log. If there is a log at    * startup, it should have already been processed and deleted by the time the    * HLog object is started up.    *    * @param fs    * @param dir    * @param conf    * @param listener    * @throws IOException    */
specifier|public
name|HLog
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|dir
parameter_list|,
specifier|final
name|HBaseConfiguration
name|conf
parameter_list|,
specifier|final
name|LogRollListener
name|listener
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|this
operator|.
name|dir
operator|=
name|dir
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|listener
operator|=
name|listener
expr_stmt|;
name|this
operator|.
name|flushlogentries
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.flushlogentries"
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|this
operator|.
name|blocksize
operator|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.regionserver.hlog.blocksize"
argument_list|,
name|this
operator|.
name|fs
operator|.
name|getDefaultBlockSize
argument_list|()
argument_list|)
expr_stmt|;
comment|// Roll at 95% of block size.
name|float
name|multi
init|=
name|conf
operator|.
name|getFloat
argument_list|(
literal|"hbase.regionserver.logroll.multiplier"
argument_list|,
literal|0.95f
argument_list|)
decl_stmt|;
name|this
operator|.
name|logrollsize
operator|=
call|(
name|long
call|)
argument_list|(
name|this
operator|.
name|blocksize
operator|*
name|multi
argument_list|)
expr_stmt|;
name|this
operator|.
name|optionalFlushInterval
operator|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.regionserver.optionallogflushinterval"
argument_list|,
literal|10
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|this
operator|.
name|lastLogFlushTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|dir
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Target HLog directory already exists: "
operator|+
name|dir
argument_list|)
throw|;
block|}
name|fs
operator|.
name|mkdirs
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxLogs
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.maxlogs"
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|this
operator|.
name|enabled
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.regionserver.hlog.enabled"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"HLog configuration: blocksize="
operator|+
name|this
operator|.
name|blocksize
operator|+
literal|", rollsize="
operator|+
name|this
operator|.
name|logrollsize
operator|+
literal|", enabled="
operator|+
name|this
operator|.
name|enabled
operator|+
literal|", flushlogentries="
operator|+
name|this
operator|.
name|flushlogentries
operator|+
literal|", optionallogflushinternal="
operator|+
name|this
operator|.
name|optionalFlushInterval
operator|+
literal|"ms"
argument_list|)
expr_stmt|;
name|rollWriter
argument_list|()
expr_stmt|;
comment|// Test if syncfs is available.
name|this
operator|.
name|append
operator|=
name|isAppend
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|Method
name|m
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|append
condition|)
block|{
try|try
block|{
name|m
operator|=
name|this
operator|.
name|writer
operator|.
name|getClass
argument_list|()
operator|.
name|getMethod
argument_list|(
literal|"syncFs"
argument_list|,
operator|new
name|Class
argument_list|<
name|?
argument_list|>
index|[]
block|{}
block|)
empty_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using syncFs--hadoop-4379"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed test for syncfs"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
comment|// This can happen
name|LOG
operator|.
name|info
argument_list|(
literal|"syncFs--hadoop-4379 not available"
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|syncfs
operator|=
name|m
expr_stmt|;
block|}
end_class

begin_comment
comment|/**    * @return Current state of the monotonically increasing file id.    */
end_comment

begin_function
specifier|public
name|long
name|getFilenum
parameter_list|()
block|{
return|return
name|this
operator|.
name|filenum
return|;
block|}
end_function

begin_comment
comment|/**    * Get the compression type for the hlog files    * @param c Configuration to use.    * @return the kind of compression to use    */
end_comment

begin_function
specifier|static
name|CompressionType
name|getCompressionType
parameter_list|(
specifier|final
name|Configuration
name|c
parameter_list|)
block|{
comment|// Compression makes no sense for commit log.  Always return NONE.
return|return
name|CompressionType
operator|.
name|NONE
return|;
block|}
end_function

begin_comment
comment|/**    * Called by HRegionServer when it opens a new region to ensure that log    * sequence numbers are always greater than the latest sequence number of the    * region being brought on-line.    *    * @param newvalue We'll set log edit/sequence number to this value if it    * is greater than the current value.    */
end_comment

begin_function
name|void
name|setSequenceNumber
parameter_list|(
specifier|final
name|long
name|newvalue
parameter_list|)
block|{
for|for
control|(
name|long
name|id
init|=
name|this
operator|.
name|logSeqNum
operator|.
name|get
argument_list|()
init|;
name|id
operator|<
name|newvalue
operator|&&
operator|!
name|this
operator|.
name|logSeqNum
operator|.
name|compareAndSet
argument_list|(
name|id
argument_list|,
name|newvalue
argument_list|)
condition|;
name|id
operator|=
name|this
operator|.
name|logSeqNum
operator|.
name|get
argument_list|()
control|)
block|{
comment|// This could spin on occasion but better the occasional spin than locking
comment|// every increment of sequence number.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Change sequence number from "
operator|+
name|logSeqNum
operator|+
literal|" to "
operator|+
name|newvalue
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * @return log sequence number    */
end_comment

begin_function
specifier|public
name|long
name|getSequenceNumber
parameter_list|()
block|{
return|return
name|logSeqNum
operator|.
name|get
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Roll the log writer. That is, start writing log messages to a new file.    *    * Because a log cannot be rolled during a cache flush, and a cache flush    * spans two method calls, a special lock needs to be obtained so that a cache    * flush cannot start when the log is being rolled and the log cannot be    * rolled during a cache flush.    *    *<p>Note that this method cannot be synchronized because it is possible that    * startCacheFlush runs, obtaining the cacheFlushLock, then this method could    * start which would obtain the lock on this but block on obtaining the    * cacheFlushLock and then completeCacheFlush could be called which would wait    * for the lock on this and consequently never release the cacheFlushLock    *    * @return If lots of logs, flush the returned region so next time through    * we can clean logs. Returns null if nothing to flush.    * @throws FailedLogCloseException    * @throws IOException    */
end_comment

begin_function
specifier|public
name|byte
index|[]
name|rollWriter
parameter_list|()
throws|throws
name|FailedLogCloseException
throws|,
name|IOException
block|{
comment|// Return if nothing to flush.
if|if
condition|(
name|this
operator|.
name|writer
operator|!=
literal|null
operator|&&
name|this
operator|.
name|numEntries
operator|.
name|get
argument_list|()
operator|<=
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|byte
index|[]
name|regionToFlush
init|=
literal|null
decl_stmt|;
name|this
operator|.
name|cacheFlushLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|closed
condition|)
block|{
return|return
name|regionToFlush
return|;
block|}
synchronized|synchronized
init|(
name|updateLock
init|)
block|{
comment|// Clean up current writer.
name|Path
name|oldFile
init|=
name|cleanupCurrentWriter
argument_list|(
name|this
operator|.
name|filenum
argument_list|)
decl_stmt|;
name|this
operator|.
name|filenum
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|Path
name|newPath
init|=
name|computeFilename
argument_list|(
name|this
operator|.
name|filenum
argument_list|)
decl_stmt|;
name|this
operator|.
name|writer
operator|=
name|createWriter
argument_list|(
name|newPath
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
operator|(
name|oldFile
operator|!=
literal|null
condition|?
literal|"Roll "
operator|+
name|FSUtils
operator|.
name|getPath
argument_list|(
name|oldFile
argument_list|)
operator|+
literal|", entries="
operator|+
name|this
operator|.
name|numEntries
operator|.
name|get
argument_list|()
operator|+
literal|", calcsize="
operator|+
name|this
operator|.
name|editsSize
operator|.
name|get
argument_list|()
operator|+
literal|", filesize="
operator|+
name|this
operator|.
name|fs
operator|.
name|getFileStatus
argument_list|(
name|oldFile
argument_list|)
operator|.
name|getLen
argument_list|()
operator|+
literal|". "
else|:
literal|""
operator|)
operator|+
literal|"New hlog "
operator|+
name|FSUtils
operator|.
name|getPath
argument_list|(
name|newPath
argument_list|)
argument_list|)
expr_stmt|;
comment|// Can we delete any of the old log files?
if|if
condition|(
name|this
operator|.
name|outputfiles
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|lastSeqWritten
operator|.
name|size
argument_list|()
operator|<=
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Last sequence written is empty. Deleting all old hlogs"
argument_list|)
expr_stmt|;
comment|// If so, then no new writes have come in since all regions were
comment|// flushed (and removed from the lastSeqWritten map). Means can
comment|// remove all but currently open log file.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|Path
argument_list|>
name|e
range|:
name|this
operator|.
name|outputfiles
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|deleteLogFile
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|,
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|outputfiles
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|regionToFlush
operator|=
name|cleanOldLogs
argument_list|()
expr_stmt|;
block|}
block|}
name|this
operator|.
name|numEntries
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|editsSize
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|updateLock
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|this
operator|.
name|cacheFlushLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|regionToFlush
return|;
block|}
end_function

begin_function
specifier|protected
name|SequenceFile
operator|.
name|Writer
name|createWriter
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createWriter
argument_list|(
name|path
argument_list|,
name|HLogKey
operator|.
name|class
argument_list|,
name|KeyValue
operator|.
name|class
argument_list|)
return|;
block|}
end_function

begin_function
specifier|protected
name|SequenceFile
operator|.
name|Writer
name|createWriter
parameter_list|(
name|Path
name|path
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|HLogKey
argument_list|>
name|keyClass
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|KeyValue
argument_list|>
name|valueClass
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|SequenceFile
operator|.
name|createWriter
argument_list|(
name|this
operator|.
name|fs
argument_list|,
name|this
operator|.
name|conf
argument_list|,
name|path
argument_list|,
name|keyClass
argument_list|,
name|valueClass
argument_list|,
name|fs
operator|.
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"io.file.buffer.size"
argument_list|,
literal|4096
argument_list|)
argument_list|,
name|fs
operator|.
name|getDefaultReplication
argument_list|()
argument_list|,
name|this
operator|.
name|blocksize
argument_list|,
name|SequenceFile
operator|.
name|CompressionType
operator|.
name|NONE
argument_list|,
operator|new
name|DefaultCodec
argument_list|()
argument_list|,
literal|null
argument_list|,
operator|new
name|Metadata
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*    * Clean up old commit logs.    * @return If lots of logs, flush the returned region so next time through    * we can clean logs. Returns null if nothing to flush.    * @throws IOException    */
end_comment

begin_function
specifier|private
name|byte
index|[]
name|cleanOldLogs
parameter_list|()
throws|throws
name|IOException
block|{
name|byte
index|[]
name|regionToFlush
init|=
literal|null
decl_stmt|;
name|Long
name|oldestOutstandingSeqNum
init|=
name|getOldestOutstandingSeqNum
argument_list|()
decl_stmt|;
comment|// Get the set of all log files whose final ID is older than or
comment|// equal to the oldest pending region operation
name|TreeSet
argument_list|<
name|Long
argument_list|>
name|sequenceNumbers
init|=
operator|new
name|TreeSet
argument_list|<
name|Long
argument_list|>
argument_list|(
name|this
operator|.
name|outputfiles
operator|.
name|headMap
argument_list|(
operator|(
name|Long
operator|.
name|valueOf
argument_list|(
name|oldestOutstandingSeqNum
operator|.
name|longValue
argument_list|()
operator|+
literal|1L
argument_list|)
operator|)
argument_list|)
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
comment|// Now remove old log files (if any)
name|byte
index|[]
name|oldestRegion
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
comment|// Find region associated with oldest key -- helps debugging.
name|oldestRegion
operator|=
name|getOldestRegion
argument_list|(
name|oldestOutstandingSeqNum
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found "
operator|+
name|sequenceNumbers
operator|.
name|size
argument_list|()
operator|+
literal|" hlogs to remove "
operator|+
literal|" out of total "
operator|+
name|this
operator|.
name|outputfiles
operator|.
name|size
argument_list|()
operator|+
literal|"; "
operator|+
literal|"oldest outstanding seqnum is "
operator|+
name|oldestOutstandingSeqNum
operator|+
literal|" from region "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|oldestRegion
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sequenceNumbers
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|Long
name|seq
range|:
name|sequenceNumbers
control|)
block|{
name|deleteLogFile
argument_list|(
name|this
operator|.
name|outputfiles
operator|.
name|remove
argument_list|(
name|seq
argument_list|)
argument_list|,
name|seq
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|countOfLogs
init|=
name|this
operator|.
name|outputfiles
operator|.
name|size
argument_list|()
operator|-
name|sequenceNumbers
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|countOfLogs
operator|>
name|this
operator|.
name|maxLogs
condition|)
block|{
name|regionToFlush
operator|=
name|oldestRegion
operator|!=
literal|null
condition|?
name|oldestRegion
else|:
name|getOldestRegion
argument_list|(
name|oldestOutstandingSeqNum
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Too many hlogs: logs="
operator|+
name|countOfLogs
operator|+
literal|", maxlogs="
operator|+
name|this
operator|.
name|maxLogs
operator|+
literal|"; forcing flush of region with oldest edits: "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|regionToFlush
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|regionToFlush
return|;
block|}
end_function

begin_comment
comment|/*    * @return Logs older than this id are safe to remove.    */
end_comment

begin_function
specifier|private
name|Long
name|getOldestOutstandingSeqNum
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|min
argument_list|(
name|this
operator|.
name|lastSeqWritten
operator|.
name|values
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
specifier|private
name|byte
index|[]
name|getOldestRegion
parameter_list|(
specifier|final
name|Long
name|oldestOutstandingSeqNum
parameter_list|)
block|{
name|byte
index|[]
name|oldestRegion
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
name|e
range|:
name|this
operator|.
name|lastSeqWritten
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|longValue
argument_list|()
operator|==
name|oldestOutstandingSeqNum
operator|.
name|longValue
argument_list|()
condition|)
block|{
name|oldestRegion
operator|=
name|e
operator|.
name|getKey
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
name|oldestRegion
return|;
block|}
end_function

begin_comment
comment|/*    * Cleans up current writer closing and adding to outputfiles.    * Presumes we're operating inside an updateLock scope.    * @return Path to current writer or null if none.    * @throws IOException    */
end_comment

begin_function
specifier|private
name|Path
name|cleanupCurrentWriter
parameter_list|(
specifier|final
name|long
name|currentfilenum
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|oldFile
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|writer
operator|!=
literal|null
condition|)
block|{
comment|// Close the current writer, get a new one.
try|try
block|{
name|this
operator|.
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Failed close of log file.  Means we're losing edits.  For now,
comment|// shut ourselves down to minimize loss.  Alternative is to try and
comment|// keep going.  See HBASE-930.
name|FailedLogCloseException
name|flce
init|=
operator|new
name|FailedLogCloseException
argument_list|(
literal|"#"
operator|+
name|currentfilenum
argument_list|)
decl_stmt|;
name|flce
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
if|if
condition|(
name|currentfilenum
operator|>=
literal|0
condition|)
block|{
name|oldFile
operator|=
name|computeFilename
argument_list|(
name|currentfilenum
argument_list|)
expr_stmt|;
name|this
operator|.
name|outputfiles
operator|.
name|put
argument_list|(
name|Long
operator|.
name|valueOf
argument_list|(
name|this
operator|.
name|logSeqNum
operator|.
name|get
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|,
name|oldFile
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|oldFile
return|;
block|}
end_function

begin_function
specifier|private
name|void
name|deleteLogFile
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|,
specifier|final
name|Long
name|seqno
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"removing old hlog file "
operator|+
name|FSUtils
operator|.
name|getPath
argument_list|(
name|p
argument_list|)
operator|+
literal|" whose highest sequence/edit id is "
operator|+
name|seqno
argument_list|)
expr_stmt|;
name|this
operator|.
name|fs
operator|.
name|delete
argument_list|(
name|p
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * This is a convenience method that computes a new filename with a given    * file-number.    * @param fn    * @return Path    */
end_comment

begin_function
specifier|public
name|Path
name|computeFilename
parameter_list|(
specifier|final
name|long
name|fn
parameter_list|)
block|{
if|if
condition|(
name|fn
operator|<
literal|0
condition|)
return|return
literal|null
return|;
return|return
operator|new
name|Path
argument_list|(
name|dir
argument_list|,
name|HLOG_DATFILE
operator|+
name|fn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Shut down the log and delete the log directory    *    * @throws IOException    */
end_comment

begin_function
specifier|public
name|void
name|closeAndDelete
parameter_list|()
throws|throws
name|IOException
block|{
name|close
argument_list|()
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|dir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Shut down the log.    *    * @throws IOException    */
end_comment

begin_function
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|cacheFlushLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
synchronized|synchronized
init|(
name|updateLock
init|)
block|{
name|this
operator|.
name|closed
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"closing hlog writer in "
operator|+
name|this
operator|.
name|dir
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
name|updateLock
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|cacheFlushLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** Append an entry to the log.    *     * @param regionInfo    * @param logEdit    * @param now Time of this edit write.    * @throws IOException    */
end_comment

begin_function
specifier|public
name|void
name|append
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|,
name|KeyValue
name|logEdit
parameter_list|,
specifier|final
name|long
name|now
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|regionName
init|=
name|regionInfo
operator|.
name|getRegionName
argument_list|()
decl_stmt|;
name|byte
index|[]
name|tableName
init|=
name|regionInfo
operator|.
name|getTableDesc
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|this
operator|.
name|append
argument_list|(
name|regionInfo
argument_list|,
name|makeKey
argument_list|(
name|regionName
argument_list|,
name|tableName
argument_list|,
operator|-
literal|1
argument_list|,
name|now
argument_list|)
argument_list|,
name|logEdit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * @param now    * @param regionName    * @param tableName    * @return New log key.    */
end_comment

begin_function
specifier|protected
name|HLogKey
name|makeKey
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|,
name|byte
index|[]
name|tableName
parameter_list|,
name|long
name|seqnum
parameter_list|,
name|long
name|now
parameter_list|)
block|{
return|return
operator|new
name|HLogKey
argument_list|(
name|regionName
argument_list|,
name|tableName
argument_list|,
name|seqnum
argument_list|,
name|now
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Append an entry to the log.    *     * @param regionInfo    * @param logEdit    * @param logKey    * @throws IOException    */
end_comment

begin_function
specifier|public
name|void
name|append
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|,
name|HLogKey
name|logKey
parameter_list|,
name|KeyValue
name|logEdit
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|closed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot append; log is closed"
argument_list|)
throw|;
block|}
name|byte
index|[]
name|regionName
init|=
name|regionInfo
operator|.
name|getRegionName
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|updateLock
init|)
block|{
name|long
name|seqNum
init|=
name|obtainSeqNum
argument_list|()
decl_stmt|;
name|logKey
operator|.
name|setLogSeqNum
argument_list|(
name|seqNum
argument_list|)
expr_stmt|;
comment|// The 'lastSeqWritten' map holds the sequence number of the oldest
comment|// write for each region. When the cache is flushed, the entry for the
comment|// region being flushed is removed if the sequence number of the flush
comment|// is greater than or equal to the value in lastSeqWritten.
name|this
operator|.
name|lastSeqWritten
operator|.
name|putIfAbsent
argument_list|(
name|regionName
argument_list|,
name|Long
operator|.
name|valueOf
argument_list|(
name|seqNum
argument_list|)
argument_list|)
expr_stmt|;
name|boolean
name|sync
init|=
name|regionInfo
operator|.
name|isMetaRegion
argument_list|()
operator|||
name|regionInfo
operator|.
name|isRootRegion
argument_list|()
decl_stmt|;
name|doWrite
argument_list|(
name|logKey
argument_list|,
name|logEdit
argument_list|,
name|sync
argument_list|,
name|logKey
operator|.
name|getWriteTime
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|numEntries
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|updateLock
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|editsSize
operator|.
name|get
argument_list|()
operator|>
name|this
operator|.
name|logrollsize
condition|)
block|{
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
name|listener
operator|.
name|logRollRequested
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**    * Append a set of edits to the log. Log edits are keyed by regionName,    * rowname, and log-sequence-id.    *    * Later, if we sort by these keys, we obtain all the relevant edits for a    * given key-range of the HRegion (TODO). Any edits that do not have a    * matching COMPLETE_CACHEFLUSH message can be discarded.    *    *<p>    * Logs cannot be restarted once closed, or once the HLog process dies. Each    * time the HLog starts, it must create a new log. This means that other    * systems should process the log appropriately upon each startup (and prior    * to initializing HLog).    *    * synchronized prevents appends during the completion of a cache flush or for    * the duration of a log roll.    *    * @param regionName    * @param tableName    * @param edits    * @param sync    * @param now    * @throws IOException    */
end_comment

begin_function
specifier|public
name|void
name|append
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|,
name|byte
index|[]
name|tableName
parameter_list|,
name|List
argument_list|<
name|KeyValue
argument_list|>
name|edits
parameter_list|,
name|boolean
name|sync
parameter_list|,
specifier|final
name|long
name|now
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|closed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot append; log is closed"
argument_list|)
throw|;
block|}
name|long
name|seqNum
index|[]
init|=
name|obtainSeqNum
argument_list|(
name|edits
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|updateLock
init|)
block|{
comment|// The 'lastSeqWritten' map holds the sequence number of the oldest
comment|// write for each region. When the cache is flushed, the entry for the
comment|// region being flushed is removed if the sequence number of the flush
comment|// is greater than or equal to the value in lastSeqWritten.
name|this
operator|.
name|lastSeqWritten
operator|.
name|putIfAbsent
argument_list|(
name|regionName
argument_list|,
name|Long
operator|.
name|valueOf
argument_list|(
name|seqNum
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|counter
init|=
literal|0
decl_stmt|;
for|for
control|(
name|KeyValue
name|kv
range|:
name|edits
control|)
block|{
name|HLogKey
name|logKey
init|=
name|makeKey
argument_list|(
name|regionName
argument_list|,
name|tableName
argument_list|,
name|seqNum
index|[
name|counter
operator|++
index|]
argument_list|,
name|now
argument_list|)
decl_stmt|;
name|doWrite
argument_list|(
name|logKey
argument_list|,
name|kv
argument_list|,
name|sync
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|this
operator|.
name|numEntries
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
name|updateLock
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|editsSize
operator|.
name|get
argument_list|()
operator|>
name|this
operator|.
name|logrollsize
condition|)
block|{
name|requestLogRoll
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|public
name|void
name|sync
parameter_list|()
throws|throws
name|IOException
block|{
name|lastLogFlushTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|append
operator|&&
name|syncfs
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|this
operator|.
name|syncfs
operator|.
name|invoke
argument_list|(
name|this
operator|.
name|writer
argument_list|,
name|NO_ARGS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Reflection"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|this
operator|.
name|writer
operator|.
name|sync
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|unflushedEntries
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|optionalSync
parameter_list|()
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|closed
condition|)
block|{
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|updateLock
init|)
block|{
if|if
condition|(
operator|(
operator|(
name|now
operator|-
name|this
operator|.
name|optionalFlushInterval
operator|)
operator|>
name|this
operator|.
name|lastLogFlushTime
operator|)
operator|&&
name|this
operator|.
name|unflushedEntries
operator|.
name|get
argument_list|()
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|sync
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error flushing hlog"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|long
name|took
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|now
decl_stmt|;
if|if
condition|(
name|took
operator|>
literal|1000
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" took "
operator|+
name|took
operator|+
literal|"ms optional sync'ing hlog; editcount="
operator|+
name|this
operator|.
name|numEntries
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|private
name|void
name|requestLogRoll
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|listener
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|listener
operator|.
name|logRollRequested
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|private
name|void
name|doWrite
parameter_list|(
name|HLogKey
name|logKey
parameter_list|,
name|KeyValue
name|logEdit
parameter_list|,
name|boolean
name|sync
parameter_list|,
specifier|final
name|long
name|now
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|enabled
condition|)
block|{
return|return;
block|}
try|try
block|{
name|this
operator|.
name|editsSize
operator|.
name|addAndGet
argument_list|(
name|logKey
operator|.
name|heapSize
argument_list|()
operator|+
name|logEdit
operator|.
name|heapSize
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|writer
operator|.
name|append
argument_list|(
name|logKey
argument_list|,
name|logEdit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sync
operator|||
name|this
operator|.
name|unflushedEntries
operator|.
name|incrementAndGet
argument_list|()
operator|>=
name|flushlogentries
condition|)
block|{
name|sync
argument_list|()
expr_stmt|;
block|}
name|long
name|took
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|now
decl_stmt|;
if|if
condition|(
name|took
operator|>
literal|1000
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" took "
operator|+
name|took
operator|+
literal|"ms appending an edit to hlog; editcount="
operator|+
name|this
operator|.
name|numEntries
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Could not append. Requesting close of hlog"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|requestLogRoll
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
end_function

begin_comment
comment|/** @return How many items have been added to the log */
end_comment

begin_function
name|int
name|getNumEntries
parameter_list|()
block|{
return|return
name|numEntries
operator|.
name|get
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Obtain a log sequence number.    */
end_comment

begin_function
specifier|private
name|long
name|obtainSeqNum
parameter_list|()
block|{
return|return
name|this
operator|.
name|logSeqNum
operator|.
name|incrementAndGet
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/** @return the number of log files in use */
end_comment

begin_function
name|int
name|getNumLogFiles
parameter_list|()
block|{
return|return
name|outputfiles
operator|.
name|size
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/*    * Obtain a specified number of sequence numbers    *    * @param num number of sequence numbers to obtain    * @return array of sequence numbers    */
end_comment

begin_function
specifier|private
name|long
index|[]
name|obtainSeqNum
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|long
index|[]
name|results
init|=
operator|new
name|long
index|[
name|num
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|results
index|[
name|i
index|]
operator|=
name|this
operator|.
name|logSeqNum
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
return|return
name|results
return|;
block|}
end_function

begin_comment
comment|/**    * By acquiring a log sequence ID, we can allow log messages to continue while    * we flush the cache.    *    * Acquire a lock so that we do not roll the log between the start and    * completion of a cache-flush. Otherwise the log-seq-id for the flush will    * not appear in the correct logfile.    *    * @return sequence ID to pass {@link #completeCacheFlush(Text, Text, long)}    * @see #completeCacheFlush(Text, Text, long)    * @see #abortCacheFlush()    */
end_comment

begin_function
name|long
name|startCacheFlush
parameter_list|()
block|{
name|this
operator|.
name|cacheFlushLock
operator|.
name|lock
argument_list|()
expr_stmt|;
return|return
name|obtainSeqNum
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Complete the cache flush    *    * Protected by cacheFlushLock    *    * @param regionName    * @param tableName    * @param logSeqId    * @throws IOException    */
end_comment

begin_function
name|void
name|completeCacheFlush
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|long
name|logSeqId
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
if|if
condition|(
name|this
operator|.
name|closed
condition|)
block|{
return|return;
block|}
synchronized|synchronized
init|(
name|updateLock
init|)
block|{
name|this
operator|.
name|writer
operator|.
name|append
argument_list|(
name|makeKey
argument_list|(
name|regionName
argument_list|,
name|tableName
argument_list|,
name|logSeqId
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
argument_list|,
name|completeCacheFlushLogEdit
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|numEntries
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|Long
name|seq
init|=
name|this
operator|.
name|lastSeqWritten
operator|.
name|get
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|seq
operator|!=
literal|null
operator|&&
name|logSeqId
operator|>=
name|seq
operator|.
name|longValue
argument_list|()
condition|)
block|{
name|this
operator|.
name|lastSeqWritten
operator|.
name|remove
argument_list|(
name|regionName
argument_list|)
expr_stmt|;
block|}
name|updateLock
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|this
operator|.
name|cacheFlushLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|private
name|KeyValue
name|completeCacheFlushLogEdit
parameter_list|()
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|METAROW
argument_list|,
name|METAFAMILY
argument_list|,
literal|null
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|,
name|COMPLETE_CACHE_FLUSH
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Abort a cache flush.    * Call if the flush fails. Note that the only recovery for an aborted flush    * currently is a restart of the regionserver so the snapshot content dropped    * by the failure gets restored to the memstore.    */
end_comment

begin_function
name|void
name|abortCacheFlush
parameter_list|()
block|{
name|this
operator|.
name|cacheFlushLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * @param family    * @return true if the column is a meta column    */
end_comment

begin_function
specifier|public
specifier|static
name|boolean
name|isMetaFamily
parameter_list|(
name|byte
index|[]
name|family
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|METAFAMILY
argument_list|,
name|family
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Split up a bunch of regionserver commit log files that are no longer    * being written to, into new files, one per region for region to replay on    * startup. Delete the old log files when finished.    *    * @param rootDir qualified root directory of the HBase instance    * @param srcDir Directory of log files to split: e.g.    *<code>${ROOTDIR}/log_HOST_PORT</code>    * @param fs FileSystem    * @param conf HBaseConfiguration    * @throws IOException    */
end_comment

begin_function
specifier|public
specifier|static
name|List
argument_list|<
name|Path
argument_list|>
name|splitLog
parameter_list|(
specifier|final
name|Path
name|rootDir
parameter_list|,
specifier|final
name|Path
name|srcDir
parameter_list|,
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|HBaseConfiguration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|millis
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|splits
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|srcDir
argument_list|)
condition|)
block|{
comment|// Nothing to do
return|return
name|splits
return|;
block|}
name|FileStatus
index|[]
name|logfiles
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|srcDir
argument_list|)
decl_stmt|;
if|if
condition|(
name|logfiles
operator|==
literal|null
operator|||
name|logfiles
operator|.
name|length
operator|==
literal|0
condition|)
block|{
comment|// Nothing to do
return|return
name|splits
return|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Splitting "
operator|+
name|logfiles
operator|.
name|length
operator|+
literal|" hlog(s) in "
operator|+
name|srcDir
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|splits
operator|=
name|splitLog
argument_list|(
name|rootDir
argument_list|,
name|logfiles
argument_list|,
name|fs
argument_list|,
name|conf
argument_list|)
expr_stmt|;
try|try
block|{
name|fs
operator|.
name|delete
argument_list|(
name|srcDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|=
name|RemoteExceptionHandler
operator|.
name|checkIOException
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|IOException
name|io
init|=
operator|new
name|IOException
argument_list|(
literal|"Cannot delete: "
operator|+
name|srcDir
argument_list|)
decl_stmt|;
name|io
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|io
throw|;
block|}
name|long
name|endMillis
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"hlog file splitting completed in "
operator|+
operator|(
name|endMillis
operator|-
name|millis
operator|)
operator|+
literal|" millis for "
operator|+
name|srcDir
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|splits
return|;
block|}
end_function

begin_comment
comment|// Private immutable datastructure to hold Writer and its Path.
end_comment

begin_class
specifier|private
specifier|final
specifier|static
class|class
name|WriterAndPath
block|{
specifier|final
name|Path
name|p
decl_stmt|;
specifier|final
name|SequenceFile
operator|.
name|Writer
name|w
decl_stmt|;
name|WriterAndPath
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|,
specifier|final
name|SequenceFile
operator|.
name|Writer
name|w
parameter_list|)
block|{
name|this
operator|.
name|p
operator|=
name|p
expr_stmt|;
name|this
operator|.
name|w
operator|=
name|w
expr_stmt|;
block|}
block|}
end_class

begin_comment
comment|/*    * @param rootDir    * @param logfiles    * @param fs    * @param conf    * @throws IOException    * @return List of splits made.    */
end_comment

begin_function
specifier|private
specifier|static
name|List
argument_list|<
name|Path
argument_list|>
name|splitLog
parameter_list|(
specifier|final
name|Path
name|rootDir
parameter_list|,
specifier|final
name|FileStatus
index|[]
name|logfiles
parameter_list|,
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|HBaseConfiguration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|WriterAndPath
argument_list|>
name|logWriters
init|=
operator|new
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|WriterAndPath
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|splits
init|=
literal|null
decl_stmt|;
comment|// Number of threads to use when log splitting to rewrite the logs.
comment|// More means faster but bigger mem consumption.
name|int
name|logWriterThreads
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.hlog.splitlog.writer.threads"
argument_list|,
literal|3
argument_list|)
decl_stmt|;
comment|// Number of logs to read concurrently when log splitting.
comment|// More means faster but bigger mem consumption  */
name|int
name|concurrentLogReads
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.hlog.splitlog.reader.threads"
argument_list|,
literal|3
argument_list|)
decl_stmt|;
comment|// Is append supported?
name|boolean
name|append
init|=
name|isAppend
argument_list|(
name|conf
argument_list|)
decl_stmt|;
try|try
block|{
name|int
name|maxSteps
init|=
name|Double
operator|.
name|valueOf
argument_list|(
name|Math
operator|.
name|ceil
argument_list|(
operator|(
name|logfiles
operator|.
name|length
operator|*
literal|1.0
operator|)
operator|/
name|concurrentLogReads
argument_list|)
argument_list|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|step
init|=
literal|0
init|;
name|step
operator|<
name|maxSteps
condition|;
name|step
operator|++
control|)
block|{
specifier|final
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|LinkedList
argument_list|<
name|HLogEntry
argument_list|>
argument_list|>
name|logEntries
init|=
operator|new
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|LinkedList
argument_list|<
name|HLogEntry
argument_list|>
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
comment|// Stop at logfiles.length when it's the last step
name|int
name|endIndex
init|=
name|step
operator|==
name|maxSteps
operator|-
literal|1
condition|?
name|logfiles
operator|.
name|length
else|:
name|step
operator|*
name|concurrentLogReads
operator|+
name|concurrentLogReads
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
operator|(
name|step
operator|*
literal|10
operator|)
init|;
name|i
operator|<
name|endIndex
condition|;
name|i
operator|++
control|)
block|{
comment|// Check for possibly empty file. With appends, currently Hadoop
comment|// reports a zero length even if the file has been sync'd. Revisit if
comment|// HADOOP-4751 is committed.
name|long
name|length
init|=
name|logfiles
index|[
name|i
index|]
operator|.
name|getLen
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Splitting hlog "
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|+
literal|" of "
operator|+
name|logfiles
operator|.
name|length
operator|+
literal|": "
operator|+
name|logfiles
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|+
literal|", length="
operator|+
name|logfiles
index|[
name|i
index|]
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|recoverLog
argument_list|(
name|fs
argument_list|,
name|logfiles
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|append
argument_list|)
expr_stmt|;
name|SequenceFile
operator|.
name|Reader
name|in
init|=
literal|null
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
try|try
block|{
name|in
operator|=
operator|new
name|SequenceFile
operator|.
name|Reader
argument_list|(
name|fs
argument_list|,
name|logfiles
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
try|try
block|{
name|HLogKey
name|key
init|=
operator|new
name|HLogKey
argument_list|()
decl_stmt|;
name|KeyValue
name|val
init|=
operator|new
name|KeyValue
argument_list|()
decl_stmt|;
while|while
condition|(
name|in
operator|.
name|next
argument_list|(
name|key
argument_list|,
name|val
argument_list|)
condition|)
block|{
name|byte
index|[]
name|regionName
init|=
name|key
operator|.
name|getRegionName
argument_list|()
decl_stmt|;
name|LinkedList
argument_list|<
name|HLogEntry
argument_list|>
name|queue
init|=
name|logEntries
operator|.
name|get
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
condition|)
block|{
name|queue
operator|=
operator|new
name|LinkedList
argument_list|<
name|HLogEntry
argument_list|>
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding queue for "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|regionName
argument_list|)
argument_list|)
expr_stmt|;
name|logEntries
operator|.
name|put
argument_list|(
name|regionName
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
name|HLogEntry
name|hle
init|=
operator|new
name|HLogEntry
argument_list|(
name|val
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|queue
operator|.
name|push
argument_list|(
name|hle
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
comment|// Make the key and value new each time; otherwise same instance
comment|// is used over and over.
name|key
operator|=
operator|new
name|HLogKey
argument_list|()
expr_stmt|;
name|val
operator|=
operator|new
name|KeyValue
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Pushed="
operator|+
name|count
operator|+
literal|" entries from "
operator|+
name|logfiles
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"IOE Pushed="
operator|+
name|count
operator|+
literal|" entries from "
operator|+
name|logfiles
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|=
name|RemoteExceptionHandler
operator|.
name|checkIOException
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|e
operator|instanceof
name|EOFException
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception processing "
operator|+
name|logfiles
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|+
literal|" -- continuing. Possible DATA LOSS!"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Empty hlog, continuing: "
operator|+
name|logfiles
index|[
name|i
index|]
operator|+
literal|" count="
operator|+
name|count
argument_list|,
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
try|try
block|{
if|if
condition|(
name|in
operator|!=
literal|null
condition|)
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Close in finally threw exception -- continuing"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// Delete the input file now so we do not replay edits. We could
comment|// have gotten here because of an exception. If so, probably
comment|// nothing we can do about it. Replaying it, it could work but we
comment|// could be stuck replaying for ever. Just continue though we
comment|// could have lost some edits.
name|fs
operator|.
name|delete
argument_list|(
name|logfiles
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
name|ExecutorService
name|threadPool
init|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
name|logWriterThreads
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|byte
index|[]
name|key
range|:
name|logEntries
operator|.
name|keySet
argument_list|()
control|)
block|{
name|Thread
name|thread
init|=
operator|new
name|Thread
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|key
argument_list|)
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LinkedList
argument_list|<
name|HLogEntry
argument_list|>
name|entries
init|=
name|logEntries
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Thread got "
operator|+
name|entries
operator|.
name|size
argument_list|()
operator|+
literal|" to process"
argument_list|)
expr_stmt|;
name|long
name|threadTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|// Items were added to the linkedlist oldest first. Pull them
comment|// out in that order.
for|for
control|(
name|ListIterator
argument_list|<
name|HLogEntry
argument_list|>
name|i
init|=
name|entries
operator|.
name|listIterator
argument_list|(
name|entries
operator|.
name|size
argument_list|()
argument_list|)
init|;
name|i
operator|.
name|hasPrevious
argument_list|()
condition|;
control|)
block|{
name|HLogEntry
name|logEntry
init|=
name|i
operator|.
name|previous
argument_list|()
decl_stmt|;
name|WriterAndPath
name|wap
init|=
name|logWriters
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|wap
operator|==
literal|null
condition|)
block|{
name|Path
name|logfile
init|=
operator|new
name|Path
argument_list|(
name|HRegion
operator|.
name|getRegionDir
argument_list|(
name|HTableDescriptor
operator|.
name|getTableDir
argument_list|(
name|rootDir
argument_list|,
name|logEntry
operator|.
name|getKey
argument_list|()
operator|.
name|getTablename
argument_list|()
argument_list|)
argument_list|,
name|HRegionInfo
operator|.
name|encodeRegionName
argument_list|(
name|key
argument_list|)
argument_list|)
argument_list|,
name|HREGION_OLDLOGFILE_NAME
argument_list|)
decl_stmt|;
name|Path
name|oldlogfile
init|=
literal|null
decl_stmt|;
name|SequenceFile
operator|.
name|Reader
name|old
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|logfile
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Old hlog file "
operator|+
name|logfile
operator|+
literal|" already exists. Copying existing file to new file"
argument_list|)
expr_stmt|;
name|oldlogfile
operator|=
operator|new
name|Path
argument_list|(
name|logfile
operator|.
name|toString
argument_list|()
operator|+
literal|".old"
argument_list|)
expr_stmt|;
name|fs
operator|.
name|rename
argument_list|(
name|logfile
argument_list|,
name|oldlogfile
argument_list|)
expr_stmt|;
name|old
operator|=
operator|new
name|SequenceFile
operator|.
name|Reader
argument_list|(
name|fs
argument_list|,
name|oldlogfile
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
name|SequenceFile
operator|.
name|Writer
name|w
init|=
name|SequenceFile
operator|.
name|createWriter
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|logfile
argument_list|,
name|HLogKey
operator|.
name|class
argument_list|,
name|KeyValue
operator|.
name|class
argument_list|,
name|getCompressionType
argument_list|(
name|conf
argument_list|)
argument_list|)
decl_stmt|;
name|wap
operator|=
operator|new
name|WriterAndPath
argument_list|(
name|logfile
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|logWriters
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|wap
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating new hlog file writer for path "
operator|+
name|logfile
operator|+
literal|" and region "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|old
operator|!=
literal|null
condition|)
block|{
comment|// Copy from existing log file
name|HLogKey
name|oldkey
init|=
operator|new
name|HLogKey
argument_list|()
decl_stmt|;
name|KeyValue
name|oldval
init|=
operator|new
name|KeyValue
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|old
operator|.
name|next
argument_list|(
name|oldkey
argument_list|,
name|oldval
argument_list|)
condition|;
name|count
operator|++
control|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
name|count
operator|>
literal|0
operator|&&
name|count
operator|%
literal|10000
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Copied "
operator|+
name|count
operator|+
literal|" edits"
argument_list|)
expr_stmt|;
block|}
name|w
operator|.
name|append
argument_list|(
name|oldkey
argument_list|,
name|oldval
argument_list|)
expr_stmt|;
block|}
name|old
operator|.
name|close
argument_list|()
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|oldlogfile
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
name|wap
operator|.
name|w
operator|.
name|append
argument_list|(
name|logEntry
operator|.
name|getKey
argument_list|()
argument_list|,
name|logEntry
operator|.
name|getEdit
argument_list|()
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Applied "
operator|+
name|count
operator|+
literal|" total edits to "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|key
argument_list|)
operator|+
literal|" in "
operator|+
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|threadTime
operator|)
operator|+
literal|"ms"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|=
name|RemoteExceptionHandler
operator|.
name|checkIOException
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Got while writing region "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|key
argument_list|)
operator|+
literal|" log "
operator|+
name|e
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
name|threadPool
operator|.
name|execute
argument_list|(
name|thread
argument_list|)
expr_stmt|;
block|}
name|threadPool
operator|.
name|shutdown
argument_list|()
expr_stmt|;
comment|// Wait for all threads to terminate
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
operator|!
name|threadPool
operator|.
name|awaitTermination
argument_list|(
literal|5
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting for hlog writers to terminate, iteration #"
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Hlog writers were interrupted, possible data loss!"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|splits
operator|=
operator|new
name|ArrayList
argument_list|<
name|Path
argument_list|>
argument_list|(
name|logWriters
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|WriterAndPath
name|wap
range|:
name|logWriters
operator|.
name|values
argument_list|()
control|)
block|{
name|wap
operator|.
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Closed "
operator|+
name|wap
operator|.
name|p
argument_list|)
expr_stmt|;
name|splits
operator|.
name|add
argument_list|(
name|wap
operator|.
name|p
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|splits
return|;
block|}
end_function

begin_comment
comment|/**    * @param conf    * @return True if append enabled and we have the syncFs in our path.    */
end_comment

begin_function
specifier|private
specifier|static
name|boolean
name|isAppend
parameter_list|(
specifier|final
name|HBaseConfiguration
name|conf
parameter_list|)
block|{
name|boolean
name|append
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"dfs.support.append"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|append
condition|)
block|{
try|try
block|{
name|SequenceFile
operator|.
name|Writer
operator|.
name|class
operator|.
name|getMethod
argument_list|(
literal|"syncFs"
argument_list|,
operator|new
name|Class
argument_list|<
name|?
argument_list|>
index|[]
block|{}
block|)
empty_stmt|;
name|append
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|e
parameter_list|)
block|{         }
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
name|append
operator|=
literal|false
expr_stmt|;
block|}
block|}
end_function

begin_return
return|return
name|append
return|;
end_return

begin_comment
unit|}
comment|/**    * Utility class that lets us keep track of the edit with it's key    * Only used when splitting logs    */
end_comment

begin_class
unit|public
specifier|static
class|class
name|HLogEntry
block|{
specifier|private
name|KeyValue
name|edit
decl_stmt|;
specifier|private
name|HLogKey
name|key
decl_stmt|;
comment|/**      * Constructor for both params      * @param edit log's edit      * @param key log's key      */
specifier|public
name|HLogEntry
parameter_list|(
name|KeyValue
name|edit
parameter_list|,
name|HLogKey
name|key
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|edit
operator|=
name|edit
expr_stmt|;
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
block|}
comment|/**      * Gets the edit      * @return edit      */
specifier|public
name|KeyValue
name|getEdit
parameter_list|()
block|{
return|return
name|edit
return|;
block|}
comment|/**      * Gets the key      * @return key      */
specifier|public
name|HLogKey
name|getKey
parameter_list|()
block|{
return|return
name|key
return|;
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|this
operator|.
name|key
operator|+
literal|"="
operator|+
name|this
operator|.
name|edit
return|;
block|}
block|}
end_class

begin_comment
comment|/**    * Construct the HLog directory name    *     * @param info HServerInfo for server    * @return the HLog directory name    */
end_comment

begin_function
specifier|public
specifier|static
name|String
name|getHLogDirectoryName
parameter_list|(
name|HServerInfo
name|info
parameter_list|)
block|{
return|return
name|getHLogDirectoryName
argument_list|(
name|HServerInfo
operator|.
name|getServerName
argument_list|(
name|info
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*    * Recover log.    * If append has been set, try and open log in append mode.    * Doing this, we get a hold of the file that crashed writer    * was writing to.  Once we have it, close it.  This will    * allow subsequent reader to see up to last sync.    * @param fs    * @param p    * @param append    */
end_comment

begin_function
specifier|private
specifier|static
name|void
name|recoverLog
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|,
specifier|final
name|boolean
name|append
parameter_list|)
block|{
if|if
condition|(
operator|!
name|append
condition|)
block|{
return|return;
block|}
comment|// Trying recovery
name|boolean
name|recovered
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|recovered
condition|)
block|{
try|try
block|{
name|FSDataOutputStream
name|out
init|=
name|fs
operator|.
name|append
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|recovered
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed open for append, waiting on lease recovery: "
operator|+
name|p
argument_list|,
name|e
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
comment|// ignore it and try again
block|}
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Past out lease recovery"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Construct the HLog directory name    *     * @param serverAddress    * @param startCode    * @return the HLog directory name    */
end_comment

begin_function
specifier|public
specifier|static
name|String
name|getHLogDirectoryName
parameter_list|(
name|String
name|serverAddress
parameter_list|,
name|long
name|startCode
parameter_list|)
block|{
if|if
condition|(
name|serverAddress
operator|==
literal|null
operator|||
name|serverAddress
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|getHLogDirectoryName
argument_list|(
name|HServerInfo
operator|.
name|getServerName
argument_list|(
name|serverAddress
argument_list|,
name|startCode
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Construct the HLog directory name    *     * @param serverName    * @return the HLog directory name    */
end_comment

begin_function
specifier|public
specifier|static
name|String
name|getHLogDirectoryName
parameter_list|(
name|String
name|serverName
parameter_list|)
block|{
name|StringBuilder
name|dirName
init|=
operator|new
name|StringBuilder
argument_list|(
name|HConstants
operator|.
name|HREGION_LOGDIR_NAME
argument_list|)
decl_stmt|;
name|dirName
operator|.
name|append
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
name|dirName
operator|.
name|append
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
return|return
name|dirName
operator|.
name|toString
argument_list|()
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Usage: java org.apache.hbase.HLog"
operator|+
literal|" {--dump<logfile>... | --split<logdir>...}"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Pass one or more log file names and it will either dump out a text version    * on<code>stdout</code> or split the specified log files.    *    * @param args    * @throws IOException    */
end_comment

begin_function
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|args
operator|.
name|length
operator|<
literal|2
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|boolean
name|dump
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|compareTo
argument_list|(
literal|"--dump"
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|.
name|compareTo
argument_list|(
literal|"--split"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dump
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|usage
argument_list|()
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|HBaseConfiguration
name|conf
init|=
operator|new
name|HBaseConfiguration
argument_list|()
decl_stmt|;
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Path
name|baseDir
init|=
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|HBASE_DIR
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Path
name|logPath
init|=
operator|new
name|Path
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|logPath
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|args
index|[
name|i
index|]
operator|+
literal|" does not exist"
argument_list|)
throw|;
block|}
if|if
condition|(
name|dump
condition|)
block|{
if|if
condition|(
operator|!
name|fs
operator|.
name|isFile
argument_list|(
name|logPath
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|args
index|[
name|i
index|]
operator|+
literal|" is not a file"
argument_list|)
throw|;
block|}
name|Reader
name|log
init|=
operator|new
name|SequenceFile
operator|.
name|Reader
argument_list|(
name|fs
argument_list|,
name|logPath
argument_list|,
name|conf
argument_list|)
decl_stmt|;
try|try
block|{
name|HLogKey
name|key
init|=
operator|new
name|HLogKey
argument_list|()
decl_stmt|;
name|KeyValue
name|val
init|=
operator|new
name|KeyValue
argument_list|()
decl_stmt|;
while|while
condition|(
name|log
operator|.
name|next
argument_list|(
name|key
argument_list|,
name|val
argument_list|)
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|key
operator|.
name|toString
argument_list|()
operator|+
literal|" "
operator|+
name|val
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|log
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|fs
operator|.
name|getFileStatus
argument_list|(
name|logPath
argument_list|)
operator|.
name|isDir
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|args
index|[
name|i
index|]
operator|+
literal|" is not a directory"
argument_list|)
throw|;
block|}
name|splitLog
argument_list|(
name|baseDir
argument_list|,
name|logPath
argument_list|,
name|fs
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|public
specifier|static
specifier|final
name|long
name|FIXED_OVERHEAD
init|=
name|ClassSize
operator|.
name|align
argument_list|(
name|ClassSize
operator|.
name|OBJECT
operator|+
operator|(
literal|5
operator|*
name|ClassSize
operator|.
name|REFERENCE
operator|)
operator|+
name|ClassSize
operator|.
name|ATOMIC_INTEGER
operator|+
name|Bytes
operator|.
name|SIZEOF_INT
operator|+
operator|(
literal|3
operator|*
name|Bytes
operator|.
name|SIZEOF_LONG
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

unit|}
end_unit

