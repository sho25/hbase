<?xml version="1.0" encoding="UTF-8"?>
<chapter
    xml:id="architecture"
    version="5.0"
    xmlns="http://docbook.org/ns/docbook"
    xmlns:xlink="http://www.w3.org/1999/xlink"
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:svg="http://www.w3.org/2000/svg"
    xmlns:m="http://www.w3.org/1998/Math/MathML"
    xmlns:html="http://www.w3.org/1999/xhtml"
    xmlns:db="http://docbook.org/ns/docbook">
    <!--/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
-->

    <title>Architecture</title>
	<section xml:id="arch.overview">
	<title>Overview</title>
	  <section xml:id="arch.overview.nosql">
	  <title>NoSQL?</title>
	  <para>HBase is a type of "NoSQL" database.  "NoSQL" is a general term meaning that the database isn't an RDBMS which
	  supports SQL as its primary access language, but there are many types of NoSQL databases:  BerkeleyDB is an
	  example of a local NoSQL database, whereas HBase is very much a distributed database.  Technically speaking,
	  HBase is really more a "Data Store" than "Data Base" because it lacks many of the features you find in an RDBMS,
	  such as typed columns, secondary indexes, triggers, and advanced query languages, etc.
	  </para>
	  <para>However, HBase has many features which supports both linear and modular scaling.  HBase clusters expand
	  by adding RegionServers that are hosted on commodity class servers. If a cluster expands from 10 to 20
	  RegionServers, for example, it doubles both in terms of storage and as well as processing capacity.
	  RDBMS can scale well, but only up to a point - specifically, the size of a single database server - and for the best
	  performance requires specialized hardware and storage devices.  HBase features of note are:
	        <itemizedlist>
              <listitem><para>Strongly consistent reads/writes:  HBase is not an "eventually consistent" DataStore.  This
              makes it very suitable for tasks such as high-speed counter aggregation.</para>  </listitem>
              <listitem><para>Automatic sharding:  HBase tables are distributed on the cluster via regions, and regions are
              automatically split and re-distributed as your data grows.</para></listitem>
              <listitem><para>Automatic RegionServer failover</para></listitem>
              <listitem><para>Hadoop/HDFS Integration:  HBase supports HDFS out of the box as its distributed file system.</para></listitem>
              <listitem><para>MapReduce:  HBase supports massively parallelized processing via MapReduce for using HBase as both
              source and sink.</para></listitem>
              <listitem><para>Java Client API:  HBase supports an easy to use Java API for programmatic access.</para></listitem>
              <listitem><para>Thrift/REST API:  HBase also supports Thrift and REST for non-Java front-ends.</para></listitem>
              <listitem><para>Block Cache and Bloom Filters:  HBase supports a Block Cache and Bloom Filters for high volume query optimization.</para></listitem>
              <listitem><para>Operational Management:  HBase provides build-in web-pages for operational insight as well as JMX metrics.</para></listitem>
            </itemizedlist>
	  </para>
      </section>

	  <section xml:id="arch.overview.when">
	    <title>When Should I Use HBase?</title>
	    	  <para>HBase isn't suitable for every problem.</para>
	          <para>First, make sure you have enough data.  If you have hundreds of millions or billions of rows, then
	            HBase is a good candidate.  If you only have a few thousand/million rows, then using a traditional RDBMS
	            might be a better choice due to the fact that all of your data might wind up on a single node (or two) and
	            the rest of the cluster may be sitting idle.
	          </para>
	          <para>Second, make sure you can live without all the extra features that an RDBMS provides (e.g., typed columns,
	          secondary indexes, transactions, advanced query languages, etc.)  An application built against an RDBMS cannot be
	          "ported" to HBase by simply changing a JDBC driver, for example.  Consider moving from an RDBMS to HBase as a
	          complete redesign as opposed to a port.
              </para>
	          <para>Third, make sure you have enough hardware.  Even HDFS doesn't do well with anything less than
                5 DataNodes (due to things such as HDFS block replication which has a default of 3), plus a NameNode.
                </para>
                <para>HBase can run quite well stand-alone on a laptop - but this should be considered a development
                configuration only.
                </para>
      </section>
      <section xml:id="arch.overview.hbasehdfs">
        <title>What Is The Difference Between HBase and Hadoop/HDFS?</title>
          <para><link xlink:href="http://hadoop.apache.org/hdfs/">HDFS</link> is a distributed file system that is well suited for the storage of large files.
          Its documentation states that it is not, however, a general purpose file system, and does not provide fast individual record lookups in files.
          HBase, on the other hand, is built on top of HDFS and provides fast record lookups (and updates) for large tables.
          This can sometimes be a point of conceptual confusion.  HBase internally puts your data in indexed "StoreFiles" that exist
          on HDFS for high-speed lookups.  See the <xref linkend="datamodel" /> and the rest of this chapter for more information on how HBase achieves its goals.
         </para>
      </section>
	</section>

    <section
      xml:id="arch.catalog">
      <title>Catalog Tables</title>
      <para>The catalog table <code>hbase:meta</code> exists as an HBase table and is filtered out of the HBase
        shell's <code>list</code> command, but is in fact a table just like any other. </para>
      <section
        xml:id="arch.catalog.root">
        <title>-ROOT-</title>
        <note>
          <para>The <code>-ROOT-</code> table was removed in HBase 0.96.0. Information here should
            be considered historical.</para>
        </note>
        <para>The <code>-ROOT-</code> table kept track of the location of the
            <code>.META</code> table (the previous name for the table now called <code>hbase:meta</code>) prior to HBase
          0.96. The <code>-ROOT-</code> table structure was as follows: </para>
        <itemizedlist>
          <title>Key</title>
          <listitem>
            <para>.META. region key (<code>.META.,,1</code>)</para>
          </listitem>
        </itemizedlist>

        <itemizedlist>
          <title>Values</title>
          <listitem>
            <para><code>info:regioninfo</code> (serialized <link
                xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HRegionInfo.html">HRegionInfo</link>
              instance of hbase:meta)</para>
          </listitem>
          <listitem>
            <para><code>info:server</code> (server:port of the RegionServer holding
              hbase:meta)</para>
          </listitem>
          <listitem>
            <para><code>info:serverstartcode</code> (start-time of the RegionServer process holding
              hbase:meta)</para>
          </listitem>
        </itemizedlist>
      </section>
      <section
        xml:id="arch.catalog.meta">
        <title>hbase:meta</title>
        <para>The <code>hbase:meta</code> table (previously called <code>.META.</code>) keeps a list
          of all regions in the system. The location of <code>hbase:meta</code> was previously
          tracked within the <code>-ROOT-</code> table, but is now stored in Zookeeper.</para>
        <para>The <code>hbase:meta</code> table structure is as follows: </para>
        <itemizedlist>
          <title>Key</title>
          <listitem>
            <para>Region key of the format (<code>[table],[region start key],[region
              id]</code>)</para>
          </listitem>
        </itemizedlist>
        <itemizedlist>
          <title>Values</title>
          <listitem>
            <para><code>info:regioninfo</code> (serialized <link
                xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HRegionInfo.html">
                HRegionInfo</link> instance for this region)</para>
          </listitem>
          <listitem>
            <para><code>info:server</code> (server:port of the RegionServer containing this
              region)</para>
          </listitem>
          <listitem>
            <para><code>info:serverstartcode</code> (start-time of the RegionServer process
              containing this region)</para>
          </listitem>
        </itemizedlist>
        <para>When a table is in the process of splitting, two other columns will be created, called
            <code>info:splitA</code> and <code>info:splitB</code>. These columns represent the two
          daughter regions. The values for these columns are also serialized HRegionInfo instances.
          After the region has been split, eventually this row will be deleted. </para>
        <note>
          <title>Note on HRegionInfo</title>
          <para>The empty key is used to denote table start and table end. A region with an empty
            start key is the first region in a table. If a region has both an empty start and an
            empty end key, it is the only region in the table </para>
        </note>
        <para>In the (hopefully unlikely) event that programmatic processing of catalog metadata is
          required, see the <link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/util/Writables.html#getHRegionInfo%28byte[]%29">Writables</link>
          utility. </para>
      </section>
      <section
        xml:id="arch.catalog.startup">
        <title>Startup Sequencing</title>
        <para>First, the location of <code>hbase:meta</code> is looked up in Zookeeper. Next,
          <code>hbase:meta</code> is updated with server and startcode values.</para>  
        <para>For information on region-RegionServer assignment, see <xref
            linkend="regions.arch.assignment" />. </para>
      </section>
    </section>  <!--  catalog -->

    <section
      xml:id="client">
      <title>Client</title>
      <para>The HBase client finds the RegionServers that are serving the particular row range of
        interest. It does this by querying the <code>hbase:meta</code> table. See <xref
          linkend="arch.catalog.meta" /> for details. After locating the required region(s), the
        client contacts the RegionServer serving that region, rather than going through the master,
        and issues the read or write request. This information is cached in the client so that
        subsequent requests need not go through the lookup process. Should a region be reassigned
        either by the master load balancer or because a RegionServer has died, the client will
        requery the catalog tables to determine the new location of the user region. </para>

      <para>See <xref
          linkend="master.runtime" /> for more information about the impact of the Master on HBase
        Client communication. </para>
      <para>Administrative functions are done via an instance of <link
          xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Admin.html">Admin</link>
      </para>

      <section
        xml:id="client.connections">
        <title>Cluster Connections</title>
        <para>The API changed in HBase 1.0. Its been cleaned up and users are returned
          Interfaces to work against rather than particular types. In HBase 1.0,
          obtain a cluster Connection from ConnectionFactory and thereafter, get from it
          instances of Table, Admin, and RegionLocator on an as-need basis. When done, close
          obtained instances.  Finally, be sure to cleanup your Connection instance before
          exiting.  Connections are heavyweight objects. Create once and keep an instance around.
          Table, Admin and RegionLocator instances are lightweight. Create as you go and then
          let go as soon as you are done by closing them. See the
          <link xlink:href="/Users/stack/checkouts/hbase.git/target/site/apidocs/org/apache/hadoop/hbase/client/package-summary.html">Client Package Javadoc Description</link> for example usage of the new HBase 1.0 API.</para>

        <para>For connection configuration information, see <xref linkend="client_dependencies" />. </para>

        <para><emphasis><link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Table.html">Table</link>
            instances are not thread-safe</emphasis>. Only one thread can use an instance of Table at
          any given time. When creating Table instances, it is advisable to use the same <link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HBaseConfiguration">HBaseConfiguration</link>
          instance. This will ensure sharing of ZooKeeper and socket instances to the RegionServers
          which is usually what you want. For example, this is preferred:</para>
          <programlisting language="java">HBaseConfiguration conf = HBaseConfiguration.create();
HTable table1 = new HTable(conf, "myTable");
HTable table2 = new HTable(conf, "myTable");</programlisting>
          <para>as opposed to this:</para>
          <programlisting language="java">HBaseConfiguration conf1 = HBaseConfiguration.create();
HTable table1 = new HTable(conf1, "myTable");
HBaseConfiguration conf2 = HBaseConfiguration.create();
HTable table2 = new HTable(conf2, "myTable");</programlisting>

        <para>For more information about how connections are handled in the HBase client,
        see <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HConnectionManager.html">HConnectionManager</link>.
          </para>
          <section xml:id="client.connection.pooling"><title>Connection Pooling</title>
            <para>For applications which require high-end multithreaded access (e.g., web-servers or application servers that may serve many application threads
            in a single JVM), you can pre-create an <classname>HConnection</classname>, as shown in
              the following example:</para>
            <example>
              <title>Pre-Creating a <code>HConnection</code></title>
              <programlisting language="java">// Create a connection to the cluster.
HConnection connection = HConnectionManager.createConnection(Configuration);
HTableInterface table = connection.getTable("myTable");
// use table as needed, the table returned is lightweight
table.close();
// use the connection for other access to the cluster
connection.close();</programlisting>
            </example>
          <para>Constructing HTableInterface implementation is very lightweight and resources are
            controlled.</para>
            <warning>
              <title><code>HTablePool</code> is Deprecated</title>
              <para>Previous versions of this guide discussed <code>HTablePool</code>, which was
                deprecated in HBase 0.94, 0.95, and 0.96, and removed in 0.98.1, by <link
                  xlink:href="https://issues.apache.org/jira/browse/HBASE-6580">HBASE-6500</link>.
                Please use <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HConnection.html"><code>HConnection</code></link> instead.</para>
            </warning>
          </section>
   	  </section>
	   <section xml:id="client.writebuffer"><title>WriteBuffer and Batch Methods</title>
           <para>If <xref linkend="perf.hbase.client.autoflush" /> is turned off on
               <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html">HTable</link>,
               <classname>Put</classname>s are sent to RegionServers when the writebuffer
               is filled.  The writebuffer is 2MB by default.  Before an HTable instance is
               discarded, either <methodname>close()</methodname> or
               <methodname>flushCommits()</methodname> should be invoked so Puts
               will not be lost.
	      </para>
	      <para>Note: <code>htable.delete(Delete);</code> does not go in the writebuffer!  This only applies to Puts.
	      </para>
	      <para>For additional information on write durability, review the <link xlink:href="../acid-semantics.html">ACID semantics</link> page.
	      </para>
       <para>For fine-grained control of batching of
           <classname>Put</classname>s or <classname>Delete</classname>s,
           see the <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#batch%28java.util.List%29">batch</link> methods on HTable.
	   </para>
	   </section>
	   <section xml:id="client.external"><title>External Clients</title>
           <para>Information on non-Java clients and custom protocols is covered in <xref linkend="external_apis" />
           </para>
		</section>
	</section>

    <section xml:id="client.filter"><title>Client Request Filters</title>
      <para><link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Get.html">Get</link> and <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html">Scan</link> instances can be
       optionally configured with <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/Filter.html">filters</link> which are applied on the RegionServer.
      </para>
      <para>Filters can be confusing because there are many different types, and it is best to approach them by understanding the groups
      of Filter functionality.
      </para>
      <section xml:id="client.filter.structural"><title>Structural</title>
        <para>Structural Filters contain other Filters.</para>
        <section xml:id="client.filter.structural.fl"><title>FilterList</title>
          <para><link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/FilterList.html">FilterList</link>
          represents a list of Filters with a relationship of <code>FilterList.Operator.MUST_PASS_ALL</code> or
          <code>FilterList.Operator.MUST_PASS_ONE</code> between the Filters.  The following example shows an 'or' between two
          Filters (checking for either 'my value' or 'my other value' on the same attribute).</para>
<programlisting language="java">
FilterList list = new FilterList(FilterList.Operator.MUST_PASS_ONE);
SingleColumnValueFilter filter1 = new SingleColumnValueFilter(
	cf,
	column,
	CompareOp.EQUAL,
	Bytes.toBytes("my value")
	);
list.add(filter1);
SingleColumnValueFilter filter2 = new SingleColumnValueFilter(
	cf,
	column,
	CompareOp.EQUAL,
	Bytes.toBytes("my other value")
	);
list.add(filter2);
scan.setFilter(list);
</programlisting>
        </section>
      </section>
      <section
        xml:id="client.filter.cv">
        <title>Column Value</title>
        <section
          xml:id="client.filter.cv.scvf">
          <title>SingleColumnValueFilter</title>
          <para><link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/SingleColumnValueFilter.html">SingleColumnValueFilter</link>
            can be used to test column values for equivalence (<code><link
                xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/CompareFilter.CompareOp.html">CompareOp.EQUAL</link>
            </code>), inequality (<code>CompareOp.NOT_EQUAL</code>), or ranges (e.g.,
              <code>CompareOp.GREATER</code>). The following is example of testing equivalence a
            column to a String value "my value"...</para>
          <programlisting language="java">
SingleColumnValueFilter filter = new SingleColumnValueFilter(
	cf,
	column,
	CompareOp.EQUAL,
	Bytes.toBytes("my value")
	);
scan.setFilter(filter);
</programlisting>
        </section>
      </section>
      <section
        xml:id="client.filter.cvp">
        <title>Column Value Comparators</title>
        <para>There are several Comparator classes in the Filter package that deserve special
          mention. These Comparators are used in concert with other Filters, such as <xref
            linkend="client.filter.cv.scvf" />. </para>
        <section
          xml:id="client.filter.cvp.rcs">
          <title>RegexStringComparator</title>
          <para><link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/RegexStringComparator.html">RegexStringComparator</link>
            supports regular expressions for value comparisons.</para>
          <programlisting language="java">
RegexStringComparator comp = new RegexStringComparator("my.");   // any value that starts with 'my'
SingleColumnValueFilter filter = new SingleColumnValueFilter(
	cf,
	column,
	CompareOp.EQUAL,
	comp
	);
scan.setFilter(filter);
</programlisting>
          <para>See the Oracle JavaDoc for <link
              xlink:href="http://download.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html">supported
              RegEx patterns in Java</link>. </para>
        </section>
        <section
          xml:id="client.filter.cvp.SubStringComparator">
          <title>SubstringComparator</title>
          <para><link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/SubstringComparator.html">SubstringComparator</link>
            can be used to determine if a given substring exists in a value. The comparison is
            case-insensitive. </para>
          <programlisting language="java">
SubstringComparator comp = new SubstringComparator("y val");   // looking for 'my value'
SingleColumnValueFilter filter = new SingleColumnValueFilter(
	cf,
	column,
	CompareOp.EQUAL,
	comp
	);
scan.setFilter(filter);
</programlisting>
        </section>
        <section
          xml:id="client.filter.cvp.bfp">
          <title>BinaryPrefixComparator</title>
          <para>See <link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/BinaryPrefixComparator.html">BinaryPrefixComparator</link>.</para>
        </section>
        <section
          xml:id="client.filter.cvp.bc">
          <title>BinaryComparator</title>
          <para>See <link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/BinaryComparator.html">BinaryComparator</link>.</para>
        </section>
      </section>
      <section
        xml:id="client.filter.kvm">
        <title>KeyValue Metadata</title>
        <para>As HBase stores data internally as KeyValue pairs, KeyValue Metadata Filters evaluate
          the existence of keys (i.e., ColumnFamily:Column qualifiers) for a row, as opposed to
          values the previous section. </para>
        <section
          xml:id="client.filter.kvm.ff">
          <title>FamilyFilter</title>
          <para><link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/FamilyFilter.html">FamilyFilter</link>
            can be used to filter on the ColumnFamily. It is generally a better idea to select
            ColumnFamilies in the Scan than to do it with a Filter.</para>
        </section>
        <section
          xml:id="client.filter.kvm.qf">
          <title>QualifierFilter</title>
          <para><link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/QualifierFilter.html">QualifierFilter</link>
            can be used to filter based on Column (aka Qualifier) name. </para>
        </section>
        <section
          xml:id="client.filter.kvm.cpf">
          <title>ColumnPrefixFilter</title>
          <para><link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/ColumnPrefixFilter.html">ColumnPrefixFilter</link>
            can be used to filter based on the lead portion of Column (aka Qualifier) names. </para>
          <para>A ColumnPrefixFilter seeks ahead to the first column matching the prefix in each row
            and for each involved column family. It can be used to efficiently get a subset of the
            columns in very wide rows. </para>
          <para>Note: The same column qualifier can be used in different column families. This
            filter returns all matching columns. </para>
          <para>Example: Find all columns in a row and family that start with "abc"</para>
          <programlisting language="java">
HTableInterface t = ...;
byte[] row = ...;
byte[] family = ...;
byte[] prefix = Bytes.toBytes("abc");
Scan scan = new Scan(row, row); // (optional) limit to one row
scan.addFamily(family); // (optional) limit to one family
Filter f = new ColumnPrefixFilter(prefix);
scan.setFilter(f);
scan.setBatch(10); // set this if there could be many columns returned
ResultScanner rs = t.getScanner(scan);
for (Result r = rs.next(); r != null; r = rs.next()) {
  for (KeyValue kv : r.raw()) {
    // each kv represents a column
  }
}
rs.close();
</programlisting>
        </section>
        <section
          xml:id="client.filter.kvm.mcpf">
          <title>MultipleColumnPrefixFilter</title>
          <para><link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/MultipleColumnPrefixFilter.html">MultipleColumnPrefixFilter</link>
            behaves like ColumnPrefixFilter but allows specifying multiple prefixes. </para>
          <para>Like ColumnPrefixFilter, MultipleColumnPrefixFilter efficiently seeks ahead to the
            first column matching the lowest prefix and also seeks past ranges of columns between
            prefixes. It can be used to efficiently get discontinuous sets of columns from very wide
            rows. </para>
          <para>Example: Find all columns in a row and family that start with "abc" or "xyz"</para>
          <programlisting language="java">
HTableInterface t = ...;
byte[] row = ...;
byte[] family = ...;
byte[][] prefixes = new byte[][] {Bytes.toBytes("abc"), Bytes.toBytes("xyz")};
Scan scan = new Scan(row, row); // (optional) limit to one row
scan.addFamily(family); // (optional) limit to one family
Filter f = new MultipleColumnPrefixFilter(prefixes);
scan.setFilter(f);
scan.setBatch(10); // set this if there could be many columns returned
ResultScanner rs = t.getScanner(scan);
for (Result r = rs.next(); r != null; r = rs.next()) {
  for (KeyValue kv : r.raw()) {
    // each kv represents a column
  }
}
rs.close();
</programlisting>
        </section>
        <section
          xml:id="client.filter.kvm.crf ">
          <title>ColumnRangeFilter</title>
          <para>A <link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/ColumnRangeFilter.html">ColumnRangeFilter</link>
            allows efficient intra row scanning. </para>
          <para>A ColumnRangeFilter can seek ahead to the first matching column for each involved
            column family. It can be used to efficiently get a 'slice' of the columns of a very wide
            row. i.e. you have a million columns in a row but you only want to look at columns
            bbbb-bbdd. </para>
          <para>Note: The same column qualifier can be used in different column families. This
            filter returns all matching columns. </para>
          <para>Example: Find all columns in a row and family between "bbbb" (inclusive) and "bbdd"
            (inclusive)</para>
          <programlisting language="java">
HTableInterface t = ...;
byte[] row = ...;
byte[] family = ...;
byte[] startColumn = Bytes.toBytes("bbbb");
byte[] endColumn = Bytes.toBytes("bbdd");
Scan scan = new Scan(row, row); // (optional) limit to one row
scan.addFamily(family); // (optional) limit to one family
Filter f = new ColumnRangeFilter(startColumn, true, endColumn, true);
scan.setFilter(f);
scan.setBatch(10); // set this if there could be many columns returned
ResultScanner rs = t.getScanner(scan);
for (Result r = rs.next(); r != null; r = rs.next()) {
  for (KeyValue kv : r.raw()) {
    // each kv represents a column
  }
}
rs.close();
</programlisting>
            <para>Note:  Introduced in HBase 0.92</para>
        </section>
      </section>
      <section xml:id="client.filter.row"><title>RowKey</title>
        <section xml:id="client.filter.row.rf"><title>RowFilter</title>
          <para>It is generally a better idea to use the startRow/stopRow methods on Scan for row selection, however
          <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/RowFilter.html">RowFilter</link> can also be used.</para>
        </section>
      </section>
      <section xml:id="client.filter.utility"><title>Utility</title>
        <section xml:id="client.filter.utility.fkof"><title>FirstKeyOnlyFilter</title>
          <para>This is primarily used for rowcount jobs.
          See <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/FirstKeyOnlyFilter.html">FirstKeyOnlyFilter</link>.</para>
        </section>
      </section>
	</section>  <!--  client.filter -->

    <section xml:id="master"><title>Master</title>
      <para><code>HMaster</code> is the implementation of the Master Server. The Master server is
        responsible for monitoring all RegionServer instances in the cluster, and is the interface
        for all metadata changes. In a distributed cluster, the Master typically runs on the <xref
          linkend="arch.hdfs.nn"/>. J Mohamed Zahoor goes into some more detail on the Master
        Architecture in this blog posting, <link
          xlink:href="http://blog.zahoor.in/2012/08/hbase-hmaster-architecture/">HBase HMaster
          Architecture </link>.</para>
       <section xml:id="master.startup"><title>Startup Behavior</title>
         <para>If run in a multi-Master environment, all Masters compete to run the cluster.  If the active
         Master loses its lease in ZooKeeper (or the Master shuts down), then then the remaining Masters jostle to
         take over the Master role.
         </para>
       </section>
      <section
        xml:id="master.runtime">
        <title>Runtime Impact</title>
        <para>A common dist-list question involves what happens to an HBase cluster when the Master
          goes down. Because the HBase client talks directly to the RegionServers, the cluster can
          still function in a "steady state." Additionally, per <xref
            linkend="arch.catalog" />, <code>hbase:meta</code> exists as an HBase table and is not
          resident in the Master. However, the Master controls critical functions such as
          RegionServer failover and completing region splits. So while the cluster can still run for
          a short time without the Master, the Master should be restarted as soon as possible.
        </para>
      </section>
       <section xml:id="master.api"><title>Interface</title>
         <para>The methods exposed by <code>HMasterInterface</code> are primarily metadata-oriented methods:
         <itemizedlist>
            <listitem><para>Table (createTable, modifyTable, removeTable, enable, disable)
            </para></listitem>
            <listitem><para>ColumnFamily (addColumn, modifyColumn, removeColumn)
            </para></listitem>
            <listitem><para>Region (move, assign, unassign)
            </para></listitem>
         </itemizedlist>
         For example, when the <code>HBaseAdmin</code> method <code>disableTable</code> is invoked, it is serviced by the Master server.
         </para>
       </section>
       <section xml:id="master.processes"><title>Processes</title>
         <para>The Master runs several background threads:
         </para>
         <section xml:id="master.processes.loadbalancer"><title>LoadBalancer</title>
           <para>Periodically, and when there are no regions in transition,
             a load balancer will run and move regions around to balance the cluster's load.
             See <xref linkend="balancer_config" /> for configuring this property.</para>
             <para>See <xref linkend="regions.arch.assignment"/> for more information on region assignment.
             </para>
         </section>
         <section xml:id="master.processes.catalog"><title>CatalogJanitor</title>
           <para>Periodically checks and cleans up the hbase:meta table.  See <xref linkend="arch.catalog.meta" /> for more information on META.</para>
         </section>
       </section>

     </section>
    <section
      xml:id="regionserver.arch">
      <title>RegionServer</title>
      <para><code>HRegionServer</code> is the RegionServer implementation. It is responsible for
        serving and managing regions. In a distributed cluster, a RegionServer runs on a <xref
          linkend="arch.hdfs.dn" />. </para>
      <section
        xml:id="regionserver.arch.api">
        <title>Interface</title>
        <para>The methods exposed by <code>HRegionRegionInterface</code> contain both data-oriented
          and region-maintenance methods: <itemizedlist>
            <listitem>
              <para>Data (get, put, delete, next, etc.)</para>
            </listitem>
            <listitem>
              <para>Region (splitRegion, compactRegion, etc.)</para>
            </listitem>
          </itemizedlist> For example, when the <code>HBaseAdmin</code> method
            <code>majorCompact</code> is invoked on a table, the client is actually iterating
          through all regions for the specified table and requesting a major compaction directly to
          each region. </para>
      </section>
      <section
        xml:id="regionserver.arch.processes">
        <title>Processes</title>
        <para>The RegionServer runs a variety of background threads:</para>
        <section
          xml:id="regionserver.arch.processes.compactsplit">
          <title>CompactSplitThread</title>
          <para>Checks for splits and handle minor compactions.</para>
        </section>
        <section
          xml:id="regionserver.arch.processes.majorcompact">
          <title>MajorCompactionChecker</title>
          <para>Checks for major compactions.</para>
        </section>
        <section
          xml:id="regionserver.arch.processes.memstore">
          <title>MemStoreFlusher</title>
          <para>Periodically flushes in-memory writes in the MemStore to StoreFiles.</para>
        </section>
        <section
          xml:id="regionserver.arch.processes.log">
          <title>LogRoller</title>
          <para>Periodically checks the RegionServer's WAL.</para>
        </section>
      </section>

      <section
        xml:id="coprocessors">
        <title>Coprocessors</title>
        <para>Coprocessors were added in 0.92. There is a thorough <link
            xlink:href="https://blogs.apache.org/hbase/entry/coprocessor_introduction">Blog Overview
            of CoProcessors</link> posted. Documentation will eventually move to this reference
          guide, but the blog is the most current information available at this time. </para>
      </section>

      <section
        xml:id="block.cache">
        <title>Block Cache</title>

        <para>HBase provides two different BlockCache implementations: the default onheap
          LruBlockCache and BucketCache, which is (usually) offheap. This section
          discusses benefits and drawbacks of each implementation, how to choose the appropriate
          option, and configuration options for each.</para>

      <note><title>Block Cache Reporting: UI</title>
      <para>See the RegionServer UI for detail on caching deploy.  Since HBase-0.98.4, the
          Block Cache detail has been significantly extended showing configurations,
          sizings, current usage, time-in-the-cache, and even detail on block counts and types.</para>
  </note>

        <section>

          <title>Cache Choices</title>
          <para><classname>LruBlockCache</classname> is the original implementation, and is
              entirely within the Java heap. <classname>BucketCache</classname> is mainly
              intended for keeping blockcache data offheap, although BucketCache can also
              keep data onheap and serve from a file-backed cache.
              <note><title>BucketCache is production ready as of hbase-0.98.6</title>
                <para>To run with BucketCache, you need HBASE-11678. This was included in
                  hbase-0.98.6.
                </para>
              </note>
          </para>

          <para>Fetching will always be slower when fetching from BucketCache,
              as compared to the native onheap LruBlockCache. However, latencies tend to be
              less erratic across time, because there is less garbage collection when you use
              BucketCache since it is managing BlockCache allocations, not the GC. If the
              BucketCache is deployed in offheap mode, this memory is not managed by the
              GC at all. This is why you'd use BucketCache, so your latencies are less erratic and to mitigate GCs
              and heap fragmentation.  See Nick Dimiduk's <link
              xlink:href="http://www.n10k.com/blog/blockcache-101/">BlockCache 101</link> for
            comparisons running onheap vs offheap tests. Also see
            <link xlink:href="http://people.apache.org/~stack/bc/">Comparing BlockCache Deploys</link>
            which finds that if your dataset fits inside your LruBlockCache deploy, use it otherwise
            if you are experiencing cache churn (or you want your cache to exist beyond the
            vagaries of java GC), use BucketCache.
              </para>

              <para>When you enable BucketCache, you are enabling a two tier caching
              system, an L1 cache which is implemented by an instance of LruBlockCache and
              an offheap L2 cache which is implemented by BucketCache.  Management of these
              two tiers and the policy that dictates how blocks move between them is done by
              <classname>CombinedBlockCache</classname>. It keeps all DATA blocks in the L2
              BucketCache and meta blocks -- INDEX and BLOOM blocks --
              onheap in the L1 <classname>LruBlockCache</classname>.
              See <xref linkend="offheap.blockcache" /> for more detail on going offheap.</para>
        </section>

        <section xml:id="cache.configurations">
            <title>General Cache Configurations</title>
          <para>Apart from the cache implementation itself, you can set some general configuration
            options to control how the cache performs. See <link
              xlink:href="http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/io/hfile/CacheConfig.html"
            />. After setting any of these options, restart or rolling restart your cluster for the
            configuration to take effect. Check logs for errors or unexpected behavior.</para>
          <para>See also <xref linkend="blockcache.prefetch"/>, which discusses a new option
            introduced in <link xlink:href="https://issues.apache.org/jira/browse/HBASE-9857"
              >HBASE-9857</link>.</para>
      </section>

        <section
          xml:id="block.cache.design">
          <title>LruBlockCache Design</title>
          <para>The LruBlockCache is an LRU cache that contains three levels of block priority to
            allow for scan-resistance and in-memory ColumnFamilies: </para>
          <itemizedlist>
            <listitem>
              <para>Single access priority: The first time a block is loaded from HDFS it normally
                has this priority and it will be part of the first group to be considered during
                evictions. The advantage is that scanned blocks are more likely to get evicted than
                blocks that are getting more usage.</para>
            </listitem>
            <listitem>
              <para>Mutli access priority: If a block in the previous priority group is accessed
                again, it upgrades to this priority. It is thus part of the second group considered
                during evictions.</para>
            </listitem>
            <listitem xml:id="hbase.cache.inmemory">
              <para>In-memory access priority: If the block's family was configured to be
                "in-memory", it will be part of this priority disregarding the number of times it
                was accessed. Catalog tables are configured like this. This group is the last one
                considered during evictions.</para>
            <para>To mark a column family as in-memory, call
                <programlisting language="java">HColumnDescriptor.setInMemory(true);</programlisting> if creating a table from java,
                or set <command>IN_MEMORY => true</command> when creating or altering a table in
                the shell: e.g.  <programlisting>hbase(main):003:0> create  't', {NAME => 'f', IN_MEMORY => 'true'}</programlisting></para>
            </listitem>
          </itemizedlist>
          <para> For more information, see the <link
              xlink:href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/io/hfile/LruBlockCache.html">LruBlockCache
              source</link>
          </para>
        </section>
        <section
          xml:id="block.cache.usage">
          <title>LruBlockCache Usage</title>
          <para>Block caching is enabled by default for all the user tables which means that any
            read operation will load the LRU cache. This might be good for a large number of use
            cases, but further tunings are usually required in order to achieve better performance.
            An important concept is the <link
              xlink:href="http://en.wikipedia.org/wiki/Working_set_size">working set size</link>, or
            WSS, which is: "the amount of memory needed to compute the answer to a problem". For a
            website, this would be the data that's needed to answer the queries over a short amount
            of time. </para>
          <para>The way to calculate how much memory is available in HBase for caching is: </para>
          <programlisting>
            number of region servers * heap size * hfile.block.cache.size * 0.99
        </programlisting>
          <para>The default value for the block cache is 0.25 which represents 25% of the available
            heap. The last value (99%) is the default acceptable loading factor in the LRU cache
            after which eviction is started. The reason it is included in this equation is that it
            would be unrealistic to say that it is possible to use 100% of the available memory
            since this would make the process blocking from the point where it loads new blocks.
            Here are some examples: </para>
          <itemizedlist>
            <listitem>
              <para>One region server with the default heap size (1 GB) and the default block cache
                size will have 253 MB of block cache available.</para>
            </listitem>
            <listitem>
              <para>20 region servers with the heap size set to 8 GB and a default block cache size
                will have 39.6 of block cache.</para>
            </listitem>
            <listitem>
              <para>100 region servers with the heap size set to 24 GB and a block cache size of 0.5
                will have about 1.16 TB of block cache.</para>
            </listitem>
        </itemizedlist>
        <para>Your data is not the only resident of the block cache. Here are others that you may have to take into account:
        </para>
          <variablelist>
            <varlistentry>
              <term>Catalog Tables</term>
              <listitem>
                <para>The <code>-ROOT-</code> (prior to HBase 0.96. See <xref
                    linkend="arch.catalog.root" />) and <code>hbase:meta</code> tables are forced
                  into the block cache and have the in-memory priority which means that they are
                  harder to evict. The former never uses more than a few hundreds of bytes while the
                  latter can occupy a few MBs (depending on the number of regions).</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>HFiles Indexes</term>
              <listitem>
                <para>An <firstterm>hfile</firstterm> is the file format that HBase uses to store
                  data in HDFS. It contains a multi-layered index which allows HBase to seek to the
                  data without having to read the whole file. The size of those indexes is a factor
                  of the block size (64KB by default), the size of your keys and the amount of data
                  you are storing. For big data sets it's not unusual to see numbers around 1GB per
                  region server, although not all of it will be in cache because the LRU will evict
                  indexes that aren't used.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Keys</term>
              <listitem>
                <para>The values that are stored are only half the picture, since each value is
                  stored along with its keys (row key, family qualifier, and timestamp). See <xref
                    linkend="keysize" />.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Bloom Filters</term>
              <listitem>
                <para>Just like the HFile indexes, those data structures (when enabled) are stored
                  in the LRU.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <para>Currently the recommended way to measure HFile indexes and bloom filters sizes is to
            look at the region server web UI and checkout the relevant metrics. For keys, sampling
            can be done by using the HFile command line tool and look for the average key size
            metric. Since HBase 0.98.3, you can view detail on BlockCache stats and metrics
            in a special Block Cache section in the UI.</para>
          <para>It's generally bad to use block caching when the WSS doesn't fit in memory. This is
            the case when you have for example 40GB available across all your region servers' block
            caches but you need to process 1TB of data. One of the reasons is that the churn
            generated by the evictions will trigger more garbage collections unnecessarily. Here are
            two use cases: </para>
        <itemizedlist>
            <listitem>
              <para>Fully random reading pattern: This is a case where you almost never access the
                same row twice within a short amount of time such that the chance of hitting a
                cached block is close to 0. Setting block caching on such a table is a waste of
                memory and CPU cycles, more so that it will generate more garbage to pick up by the
                JVM. For more information on monitoring GC, see <xref
                  linkend="trouble.log.gc" />.</para>
            </listitem>
            <listitem>
              <para>Mapping a table: In a typical MapReduce job that takes a table in input, every
                row will be read only once so there's no need to put them into the block cache. The
                Scan object has the option of turning this off via the setCaching method (set it to
                false). You can still keep block caching turned on on this table if you need fast
                random read access. An example would be counting the number of rows in a table that
                serves live traffic, caching every block of that table would create massive churn
                and would surely evict data that's currently in use. </para>
            </listitem>
          </itemizedlist>
          <section xml:id="data.blocks.in.fscache">
            <title>Caching META blocks only (DATA blocks in fscache)</title>
            <para>An interesting setup is one where we cache META blocks only and we read DATA
              blocks in on each access. If the DATA blocks fit inside fscache, this alternative
              may make sense when access is completely random across a very large dataset.
              To enable this setup, alter your table and for each column family
              set <varname>BLOCKCACHE => 'false'</varname>.  You are 'disabling' the
              BlockCache for this column family only you can never disable the caching of
              META blocks. Since
              <link xlink:href="https://issues.apache.org/jira/browse/HBASE-4683">HBASE-4683 Always cache index and bloom blocks</link>,
              we will cache META blocks even if the BlockCache is disabled.
            </para>
          </section>
        </section>
        <section
          xml:id="offheap.blockcache">
          <title>Offheap Block Cache</title>
          <section xml:id="enable.bucketcache">
            <title>How to Enable BucketCache</title>
                <para>The usual deploy of BucketCache is via a managing class that sets up two caching tiers: an L1 onheap cache
                    implemented by LruBlockCache and a second L2 cache implemented with BucketCache. The managing class is <link
                        xlink:href="http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/io/hfile/CombinedBlockCache.html">CombinedBlockCache</link> by default.
            The just-previous link describes the caching 'policy' implemented by CombinedBlockCache. In short, it works
            by keeping meta blocks -- INDEX and BLOOM in the L1, onheap LruBlockCache tier -- and DATA
            blocks are kept in the L2, BucketCache tier. It is possible to amend this behavior in
            HBase since version 1.0 and ask that a column family have both its meta and DATA blocks hosted onheap in the L1 tier by
            setting <varname>cacheDataInL1</varname> via
                  <code>(HColumnDescriptor.setCacheDataInL1(true)</code>
            or in the shell, creating or amending column families setting <varname>CACHE_DATA_IN_L1</varname>
            to true: e.g. <programlisting>hbase(main):003:0> create 't', {NAME => 't', CONFIGURATION => {CACHE_DATA_IN_L1 => 'true'}}</programlisting></para>

        <para>The BucketCache Block Cache can be deployed onheap, offheap, or file based.
            You set which via the
            <varname>hbase.bucketcache.ioengine</varname> setting.  Setting it to
            <varname>heap</varname> will have BucketCache deployed inside the 
            allocated java heap. Setting it to <varname>offheap</varname> will have
            BucketCache make its allocations offheap,
            and an ioengine setting of <varname>file:PATH_TO_FILE</varname> will direct
            BucketCache to use a file caching (Useful in particular if you have some fast i/o attached to the box such
            as SSDs).
        </para>
        <para xml:id="raw.l1.l2">It is possible to deploy an L1+L2 setup where we bypass the CombinedBlockCache
            policy and have BucketCache working as a strict L2 cache to the L1
              LruBlockCache. For such a setup, set <varname>CacheConfig.BUCKET_CACHE_COMBINED_KEY</varname> to
              <literal>false</literal>. In this mode, on eviction from L1, blocks go to L2.
              When a block is cached, it is cached first in L1. When we go to look for a cached block,
              we look first in L1 and if none found, then search L2.  Let us call this deploy format,
              <emphasis><indexterm><primary>Raw L1+L2</primary></indexterm></emphasis>.</para>
          <para>Other BucketCache configs include: specifying a location to persist cache to across
              restarts, how many threads to use writing the cache, etc.  See the
              <link xlink:href="https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/io/hfile/CacheConfig.html">CacheConfig.html</link>
              class for configuration options and descriptions.</para>

            <procedure>
              <title>BucketCache Example Configuration</title>
              <para>This sample provides a configuration for a 4 GB offheap BucketCache with a 1 GB
                  onheap cache. Configuration is performed on the RegionServer.  Setting
                  <varname>hbase.bucketcache.ioengine</varname> and 
                  <varname>hbase.bucketcache.size</varname> &gt; 0 enables CombinedBlockCache.
                  Let us presume that the RegionServer has been set to run with a 5G heap:
                  i.e. HBASE_HEAPSIZE=5g.
              </para>
              <step>
                <para>First, edit the RegionServer's <filename>hbase-env.sh</filename> and set
                  <varname>HBASE_OFFHEAPSIZE</varname> to a value greater than the offheap size wanted, in
                  this case, 4 GB (expressed as 4G).  Lets set it to 5G.  That'll be 4G
                  for our offheap cache and 1G for any other uses of offheap memory (there are
                  other users of offheap memory other than BlockCache; e.g. DFSClient 
                  in RegionServer can make use of offheap memory). See <xref linkend="direct.memory" />.</para>
                <programlisting>HBASE_OFFHEAPSIZE=5G</programlisting>
              </step>
              <step>
                <para>Next, add the following configuration to the RegionServer's
                    <filename>hbase-site.xml</filename>.</para>
                <programlisting language="xml">
<![CDATA[<property>
  <name>hbase.bucketcache.ioengine</name>
  <value>offheap</value>
</property>
<property>
  <name>hfile.block.cache.size</name>
  <value>0.2</value>
</property>
<property>
  <name>hbase.bucketcache.size</name>
  <value>4196</value>
</property>]]>
          </programlisting>
              </step>
              <step>
                <para>Restart or rolling restart your cluster, and check the logs for any
                  issues.</para>
              </step>
            </procedure>
            <para>In the above, we set bucketcache to be 4G.  The onheap lrublockcache we
                configured to have 0.2 of the RegionServer's heap size (0.2 * 5G = 1G).
                In other words, you configure the L1 LruBlockCache as you would normally,
                as you would when there is no L2 BucketCache present.
            </para>
            <para><link xlink:href="https://issues.apache.org/jira/browse/HBASE-10641"
                >HBASE-10641</link> introduced the ability to configure multiple sizes for the
              buckets of the bucketcache, in HBase 0.98 and newer. To configurable multiple bucket
              sizes, configure the new property <option>hfile.block.cache.sizes</option> (instead of
                <option>hfile.block.cache.size</option>) to a comma-separated list of block sizes,
              ordered from smallest to largest, with no spaces. The goal is to optimize the bucket
              sizes based on your data access patterns. The following example configures buckets of
              size 4096 and 8192.</para>
            <screen language="xml"><![CDATA[
<property>
  <name>hfile.block.cache.sizes</name>
  <value>4096,8192</value>
</property>
              ]]></screen>
            <note xml:id="direct.memory">
                <title>Direct Memory Usage In HBase</title>
                <para>The default maximum direct memory varies by JVM.  Traditionally it is 64M
                    or some relation to allocated heap size (-Xmx) or no limit at all (JDK7 apparently).
                    HBase servers use direct memory, in particular short-circuit reading, the hosted DFSClient will
                    allocate direct memory buffers.  If you do offheap block caching, you'll
                    be making use of direct memory.  Starting your JVM, make sure
                    the <varname>-XX:MaxDirectMemorySize</varname> setting in
                    <filename>conf/hbase-env.sh</filename> is set to some value that is
                    higher than what you have allocated to your offheap blockcache
                    (<varname>hbase.bucketcache.size</varname>).  It should be larger than your offheap block
                    cache and then some for DFSClient usage (How much the DFSClient uses is not
                    easy to quantify; it is the number of open hfiles * <varname>hbase.dfs.client.read.shortcircuit.buffer.size</varname>
                    where hbase.dfs.client.read.shortcircuit.buffer.size is set to 128k in HBase -- see <filename>hbase-default.xml</filename>
                    default configurations).
                        Direct memory, which is part of the Java process heap, is separate from the object
                        heap allocated by -Xmx. The value allocated by MaxDirectMemorySize must not exceed
                        physical RAM, and is likely to be less than the total available RAM due to other
                        memory requirements and system constraints.
                </para>
              <para>You can see how much memory -- onheap and offheap/direct -- a RegionServer is
                configured to use and how much it is using at any one time by looking at the
                  <emphasis>Server Metrics: Memory</emphasis> tab in the UI. It can also be gotten
                via JMX. In particular the direct memory currently used by the server can be found
                on the <varname>java.nio.type=BufferPool,name=direct</varname> bean. Terracotta has
                a <link
                  xlink:href="http://terracotta.org/documentation/4.0/bigmemorygo/configuration/storage-options"
                  >good write up</link> on using offheap memory in java. It is for their product
                BigMemory but alot of the issues noted apply in general to any attempt at going
                offheap. Check it out.</para>
            </note>
              <note xml:id="hbase.bucketcache.percentage.in.combinedcache"><title>hbase.bucketcache.percentage.in.combinedcache</title>
                  <para>This is a pre-HBase 1.0 configuration removed because it
                      was confusing. It was a float that you would set to some value
                      between 0.0 and 1.0.  Its default was 0.9. If the deploy was using
                      CombinedBlockCache, then the LruBlockCache L1 size was calculated to
                      be (1 - <varname>hbase.bucketcache.percentage.in.combinedcache</varname>) * <varname>size-of-bucketcache</varname> 
                      and the BucketCache size was <varname>hbase.bucketcache.percentage.in.combinedcache</varname> * size-of-bucket-cache.
                      where size-of-bucket-cache itself is EITHER the value of the configuration hbase.bucketcache.size
                      IF it was specified as megabytes OR <varname>hbase.bucketcache.size</varname> * <varname>-XX:MaxDirectMemorySize</varname> if
                      <varname>hbase.bucketcache.size</varname> between 0 and 1.0.
                  </para>
                  <para>In 1.0, it should be more straight-forward. L1 LruBlockCache size
                      is set as a fraction of java heap using hfile.block.cache.size setting
                      (not the best name) and L2 is set as above either in absolute
                      megabytes or as a fraction of allocated maximum direct memory.
                  </para>
              </note>
          </section>
        </section>
        <section>
          <title>Comprewssed Blockcache</title>
          <para><link xlink:href="https://issues.apache.org/jira/browse/HBASE-11331"
              >HBASE-11331</link> introduced lazy blockcache decompression, more simply referred to
            as compressed blockcache. When compressed blockcache is enabled. data and encoded data
            blocks are cached in the blockcache in their on-disk format, rather than being
            decompressed and decrypted before caching.</para>
          <para xlink:href="https://issues.apache.org/jira/browse/HBASE-11331">For a RegionServer
            hosting more data than can fit into cache, enabling this feature with SNAPPY compression
            has been shown to result in 50% increase in throughput and 30% improvement in mean
            latency while, increasing garbage collection by 80% and increasing overall CPU load by
            2%. See HBASE-11331 for more details about how performance was measured and achieved.
            For a RegionServer hosting data that can comfortably fit into cache, or if your workload
            is sensitive to extra CPU or garbage-collection load, you may receive less
            benefit.</para>
          <para>Compressed blockcache is disabled by default. To enable it, set
              <code>hbase.block.data.cachecompressed</code> to <code>true</code> in
              <filename>hbase-site.xml</filename> on all RegionServers.</para>
        </section>
      </section>

      <section
        xml:id="wal">
        <title>Write Ahead Log (WAL)</title>

        <section
          xml:id="purpose.wal">
          <title>Purpose</title>
          <para>The <firstterm>Write Ahead Log (WAL)</firstterm> records all changes to data in
            HBase, to file-based storage. Under normal operations, the WAL is not needed because
            data changes move from the MemStore to StoreFiles. However, if a RegionServer crashes or
          becomes unavailable before the MemStore is flushed, the WAL ensures that the changes to
          the data can be replayed. If writing to the WAL fails, the entire operation to modify the
          data fails.</para>
          <para>
            HBase uses an implementation of the <link xlink:href=
            "http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/wal/WAL.html"
            >WAL</link> interface. Usually, there is only one instance of a WAL per RegionServer.
            The RegionServer records Puts and Deletes to it, before recording them to the <xref
              linkend="store.memstore" /> for the affected <xref
              linkend="store" />.
          </para>
          <note>
            <title>The HLog</title>
            <para>
              Prior to 2.0, the interface for WALs in HBase was named <classname>HLog</classname>.
              In 0.94, HLog was the name of the implementation of the WAL. You will likely find
              references to the HLog in documentation tailored to these older versions.
            </para>
          </note>
          <para>The WAL resides in HDFS in the <filename>/hbase/WALs/</filename> directory (prior to
            HBase 0.94, they were stored in <filename>/hbase/.logs/</filename>), with subdirectories per
            region.</para>
          <para> For more general information about the concept of write ahead logs, see the
            Wikipedia <link
              xlink:href="http://en.wikipedia.org/wiki/Write-ahead_logging">Write-Ahead Log</link>
            article. </para>
        </section>
        <section
          xml:id="wal_flush">
          <title>WAL Flushing</title>
          <para>TODO (describe). </para>
        </section>

        <section
          xml:id="wal_splitting">
          <title>WAL Splitting</title>

          <para>A RegionServer serves many regions. All of the regions in a region server share the
            same active WAL file. Each edit in the WAL file includes information about which region
            it belongs to. When a region is opened, the edits in the WAL file which belong to that
            region need to be replayed. Therefore, edits in the WAL file must be grouped by region
            so that particular sets can be replayed to regenerate the data in a particular region.
            The process of grouping the WAL edits by region is called <firstterm>log
              splitting</firstterm>. It is a critical process for recovering data if a region server
            fails.</para>
          <para>Log splitting is done by the HMaster during cluster start-up or by the ServerShutdownHandler
            as a region server shuts down. So that consistency is guaranteed, affected regions
            are unavailable until data is restored. All WAL edits need to be recovered and replayed
            before a given region can become available again. As a result, regions affected by
            log splitting are unavailable until the process completes.</para>
          <procedure xml:id="log.splitting.step.by.step">
            <title>Log Splitting, Step by Step</title>
            <step>
              <title>The <filename>/hbase/WALs/&lt;host>,&lt;port>,&lt;startcode></filename> directory is renamed.</title>
              <para>Renaming the directory is important because a RegionServer may still be up and
                accepting requests even if the HMaster thinks it is down. If the RegionServer does
                not respond immediately and does not heartbeat its ZooKeeper session, the HMaster
                may interpret this as a RegionServer failure. Renaming the logs directory ensures
                that existing, valid WAL files which are still in use by an active but busy
                RegionServer are not written to by accident.</para>
              <para>The new directory is named according to the following pattern:</para>
              <screen><![CDATA[/hbase/WALs/<host>,<port>,<startcode>-splitting]]></screen>
              <para>An example of such a renamed directory might look like the following:</para>
              <screen>/hbase/WALs/srv.example.com,60020,1254173957298-splitting</screen>
            </step>
            <step>
              <title>Each log file is split, one at a time.</title>
              <para>The log splitter reads the log file one edit entry at a time and puts each edit
                entry into the buffer corresponding to the edit’s region. At the same time, the
                splitter starts several writer threads. Writer threads pick up a corresponding
                buffer and write the edit entries in the buffer to a temporary recovered edit
                file. The temporary edit file is stored to disk with the following naming pattern:</para>
              <screen><![CDATA[/hbase/<table_name>/<region_id>/recovered.edits/.temp]]></screen>
              <para>This file is used to store all the edits in the WAL log for this region. After
                log splitting completes, the <filename>.temp</filename> file is renamed to the
                sequence ID of the first log written to the file.</para>
              <para>To determine whether all edits have been written, the sequence ID is compared to
                the sequence of the last edit that was written to the HFile. If the sequence of the
                last edit is greater than or equal to the sequence ID included in the file name, it
                is clear that all writes from the edit file have been completed.</para>
            </step>
            <step>
              <title>After log splitting is complete, each affected region is assigned to a
                RegionServer.</title>
              <para> When the region is opened, the <filename>recovered.edits</filename> folder is checked for recovered
                edits files. If any such files are present, they are replayed by reading the edits
                and saving them to the MemStore. After all edit files are replayed, the contents of
                the MemStore are written to disk (HFile) and the edit files are deleted.</para>
            </step>
          </procedure>
  
          <section>
            <title>Handling of Errors During Log Splitting</title>

            <para>If you set the <varname>hbase.hlog.split.skip.errors</varname> option to
                <constant>true</constant>, errors are treated as follows:</para>
            <itemizedlist>
              <listitem>
                <para>Any error encountered during splitting will be logged.</para>
              </listitem>
              <listitem>
                <para>The problematic WAL log will be moved into the <filename>.corrupt</filename>
                  directory under the hbase <varname>rootdir</varname>,</para>
              </listitem>
              <listitem>
                <para>Processing of the WAL will continue</para>
              </listitem>
            </itemizedlist>
            <para>If the <varname>hbase.hlog.split.skip.errors</varname> optionset to
                <literal>false</literal>, the default, the exception will be propagated and the
              split will be logged as failed. See <link
                    xlink:href="https://issues.apache.org/jira/browse/HBASE-2958">HBASE-2958 When
                    hbase.hlog.split.skip.errors is set to false, we fail the split but thats
                    it</link>. We need to do more than just fail split if this flag is set.</para>
            
            <section>
              <title>How EOFExceptions are treated when splitting a crashed RegionServers'
                WALs</title>

              <para>If an EOFException occurs while splitting logs, the split proceeds even when
                  <varname>hbase.hlog.split.skip.errors</varname> is set to
                <literal>false</literal>. An EOFException while reading the last log in the set of
                files to split is likely, because the RegionServer is likely to be in the process of
                writing a record at the time of a crash. For background, see <link
                      xlink:href="https://issues.apache.org/jira/browse/HBASE-2643">HBASE-2643
                      Figure how to deal with eof splitting logs</link></para>
            </section>
          </section>
          
          <section>
            <title>Performance Improvements during Log Splitting</title>
            <para>
              WAL log splitting and recovery can be resource intensive and take a long time,
              depending on the number of RegionServers involved in the crash and the size of the
              regions. <xref linkend="distributed.log.splitting" /> and <xref
                linkend="distributed.log.replay" /> were developed to improve
              performance during log splitting.
            </para>
            <section xml:id="distributed.log.splitting">
              <title>Distributed Log Splitting</title>
              <para><firstterm>Distributed Log Splitting</firstterm> was added in HBase version 0.92
                (<link xlink:href="https://issues.apache.org/jira/browse/HBASE-1364">HBASE-1364</link>) 
                by Prakash Khemani from Facebook. It reduces the time to complete log splitting
                dramatically, improving the availability of regions and tables. For
                example, recovering a crashed cluster took around 9 hours with single-threaded log
                splitting, but only about six minutes with distributed log splitting.</para>
              <para>The information in this section is sourced from Jimmy Xiang's blog post at <link
              xlink:href="http://blog.cloudera.com/blog/2012/07/hbase-log-splitting/" />.</para>
              
              <formalpara>
                <title>Enabling or Disabling Distributed Log Splitting</title>
                <para>Distributed log processing is enabled by default since HBase 0.92. The setting
                  is controlled by the <property>hbase.master.distributed.log.splitting</property>
                  property, which can be set to <literal>true</literal> or <literal>false</literal>,
                  but defaults to <literal>true</literal>. </para>
              </formalpara>
              <procedure>
                <title>Distributed Log Splitting, Step by Step</title>
                <para>After configuring distributed log splitting, the HMaster controls the process.
                  The HMaster enrolls each RegionServer in the log splitting process, and the actual
                  work of splitting the logs is done by the RegionServers. The general process for
                  log splitting, as described in <xref
                    linkend="log.splitting.step.by.step" /> still applies here.</para>
                <step>
                  <para>If distributed log processing is enabled, the HMaster creates a
                    <firstterm>split log manager</firstterm> instance when the cluster is started.
                    The split log manager manages all log files which need
                    to be scanned and split. The split log manager places all the logs into the
                    ZooKeeper splitlog node (<filename>/hbase/splitlog</filename>) as tasks. You can
                  view the contents of the splitlog by issuing the following
                    <command>zkcli</command> command. Example output is shown.</para>
                  <screen language="bourne">ls /hbase/splitlog
[hdfs%3A%2F%2Fhost2.sample.com%3A56020%2Fhbase%2F.logs%2Fhost8.sample.com%2C57020%2C1340474893275-splitting%2Fhost8.sample.com%253A57020.1340474893900, 
hdfs%3A%2F%2Fhost2.sample.com%3A56020%2Fhbase%2F.logs%2Fhost3.sample.com%2C57020%2C1340474893299-splitting%2Fhost3.sample.com%253A57020.1340474893931, 
hdfs%3A%2F%2Fhost2.sample.com%3A56020%2Fhbase%2F.logs%2Fhost4.sample.com%2C57020%2C1340474893287-splitting%2Fhost4.sample.com%253A57020.1340474893946]                  
                  </screen>
                  <para>The output contains some non-ASCII characters. When decoded, it looks much
                    more simple:</para>
                  <screen>
[hdfs://host2.sample.com:56020/hbase/.logs
/host8.sample.com,57020,1340474893275-splitting
/host8.sample.com%3A57020.1340474893900, 
hdfs://host2.sample.com:56020/hbase/.logs
/host3.sample.com,57020,1340474893299-splitting
/host3.sample.com%3A57020.1340474893931, 
hdfs://host2.sample.com:56020/hbase/.logs
/host4.sample.com,57020,1340474893287-splitting
/host4.sample.com%3A57020.1340474893946]                    
                  </screen>
                  <para>The listing represents WAL file names to be scanned and split, which is a
                    list of log splitting tasks.</para>
                </step>
                <step>
                  <title>The split log manager monitors the log-splitting tasks and workers.</title>
                  <para>The split log manager is responsible for the following ongoing tasks:</para>
                  <itemizedlist>
                    <listitem>
                      <para>Once the split log manager publishes all the tasks to the splitlog
                        znode, it monitors these task nodes and waits for them to be
                        processed.</para>
                    </listitem>
                    <listitem>
                      <para>Checks to see if there are any dead split log
                        workers queued up. If it finds tasks claimed by unresponsive workers, it
                        will resubmit those tasks. If the resubmit fails due to some ZooKeeper
                        exception, the dead worker is queued up again for retry.</para>
                    </listitem>
                    <listitem>
                      <para>Checks to see if there are any unassigned
                        tasks. If it finds any, it create an ephemeral rescan node so that each
                        split log worker is notified to re-scan unassigned tasks via the
                          <code>nodeChildrenChanged</code> ZooKeeper event.</para>
                    </listitem>
                    <listitem>
                      <para>Checks for tasks which are assigned but expired. If any are found, they
                        are moved back to <code>TASK_UNASSIGNED</code> state again so that they can
                        be retried. It is possible that these tasks are assigned to slow workers, or
                        they may already be finished. This is not a problem, because log splitting
                        tasks have the property of idempotence. In other words, the same log
                        splitting task can be processed many times without causing any
                        problem.</para>
                    </listitem>
                    <listitem>
                      <para>The split log manager watches the HBase split log znodes constantly. If
                        any split log task node data is changed, the split log manager retrieves the
                        node data. The
                        node data contains the current state of the task. You can use the
                        <command>zkcli</command> <command>get</command> command to retrieve the
                        current state of a task. In the example output below, the first line of the
                        output shows that the task is currently unassigned.</para>
                      <screen>
<userinput>get /hbase/splitlog/hdfs%3A%2F%2Fhost2.sample.com%3A56020%2Fhbase%2F.logs%2Fhost6.sample.com%2C57020%2C1340474893287-splitting%2Fhost6.sample.com%253A57020.1340474893945
</userinput> 
<computeroutput>unassigned host2.sample.com:57000
cZxid = 0×7115
ctime = Sat Jun 23 11:13:40 PDT 2012
...</computeroutput>  
                      </screen>
                      <para>Based on the state of the task whose data is changed, the split log
                        manager does one of the following:</para>

                      <itemizedlist>
                        <listitem>
                          <para>Resubmit the task if it is unassigned</para>
                        </listitem>
                        <listitem>
                          <para>Heartbeat the task if it is assigned</para>
                        </listitem>
                        <listitem>
                          <para>Resubmit or fail the task if it is resigned (see <xref
                            linkend="distributed.log.replay.failure.reasons" />)</para>
                        </listitem>
                        <listitem>
                          <para>Resubmit or fail the task if it is completed with errors (see <xref
                            linkend="distributed.log.replay.failure.reasons" />)</para>
                        </listitem>
                        <listitem>
                          <para>Resubmit or fail the task if it could not complete due to
                            errors (see <xref
                            linkend="distributed.log.replay.failure.reasons" />)</para>
                        </listitem>
                        <listitem>
                          <para>Delete the task if it is successfully completed or failed</para>
                        </listitem>
                      </itemizedlist>
                      <itemizedlist xml:id="distributed.log.replay.failure.reasons">
                        <title>Reasons a Task Will Fail</title>
                        <listitem><para>The task has been deleted.</para></listitem>
                        <listitem><para>The node no longer exists.</para></listitem>
                        <listitem><para>The log status manager failed to move the state of the task
                          to TASK_UNASSIGNED.</para></listitem>
                        <listitem><para>The number of resubmits is over the resubmit
                          threshold.</para></listitem>
                      </itemizedlist>
                    </listitem>
                  </itemizedlist>
                </step>
                <step>
                  <title>Each RegionServer's split log worker performs the log-splitting tasks.</title>
                  <para>Each RegionServer runs a daemon thread called the <firstterm>split log
                      worker</firstterm>, which does the work to split the logs. The daemon thread
                    starts when the RegionServer starts, and registers itself to watch HBase znodes.
                    If any splitlog znode children change, it notifies a sleeping worker thread to
                    wake up and grab more tasks. If if a worker's current task’s node data is
                    changed, the worker checks to see if the task has been taken by another worker.
                    If so, the worker thread stops work on the current task.</para>
                  <para>The worker monitors
                    the splitlog znode constantly. When a new task appears, the split log worker
                    retrieves  the task paths and checks each one until it finds an unclaimed task,
                    which it attempts to claim. If the claim was successful, it attempts to perform
                    the task and updates the task's <property>state</property> property based on the
                    splitting outcome. At this point, the split log worker scans for another
                    unclaimed task.</para>
                  <itemizedlist>
                    <title>How the Split Log Worker Approaches a Task</title>

                    <listitem>
                      <para>It queries the task state and only takes action if the task is in
                          <literal>TASK_UNASSIGNED </literal>state.</para>
                    </listitem>
                    <listitem>
                      <para>If the task is is in <literal>TASK_UNASSIGNED</literal> state, the
                        worker attempts to set the state to <literal>TASK_OWNED</literal> by itself.
                        If it fails to set the state, another worker will try to grab it. The split
                        log manager will also ask all workers to rescan later if the task remains
                        unassigned.</para>
                    </listitem>
                    <listitem>
                      <para>If the worker succeeds in taking ownership of the task, it tries to get
                        the task state again to make sure it really gets it asynchronously. In the
                        meantime, it starts a split task executor to do the actual work: </para>
                      <itemizedlist>
                        <listitem>
                          <para>Get the HBase root folder, create a temp folder under the root, and
                            split the log file to the temp folder.</para>
                        </listitem>
                        <listitem>
                          <para>If the split was successful, the task executor sets the task to
                            state <literal>TASK_DONE</literal>.</para>
                        </listitem>
                        <listitem>
                          <para>If the worker catches an unexpected IOException, the task is set to
                            state <literal>TASK_ERR</literal>.</para>
                        </listitem>
                        <listitem>
                          <para>If the worker is shutting down, set the the task to state
                              <literal>TASK_RESIGNED</literal>.</para>
                        </listitem>
                        <listitem>
                          <para>If the task is taken by another worker, just log it.</para>
                        </listitem>
                      </itemizedlist>
                    </listitem>
                  </itemizedlist>
                </step>
                <step>
                  <title>The split log manager monitors for uncompleted tasks.</title>
                  <para>The split log manager returns when all tasks are completed successfully. If
                    all tasks are completed with some failures, the split log manager throws an
                    exception so that the log splitting can be retried. Due to an asynchronous
                    implementation, in very rare cases, the split log manager loses track of some
                    completed tasks. For that reason, it periodically checks for remaining
                    uncompleted task in its task map or ZooKeeper. If none are found, it throws an
                    exception so that the log splitting can be retried right away instead of hanging
                    there waiting for something that won’t happen.</para>
                </step>
              </procedure>
            </section>
            <section xml:id="distributed.log.replay">
              <title>Distributed Log Replay</title>
              <para>After a RegionServer fails, its failed region is assigned to another
                RegionServer, which is marked as "recovering" in ZooKeeper. A split log worker directly
                replays edits from the WAL of the failed region server to the region at its new
                location. When a region is in "recovering" state, it can accept writes but no reads
                (including Append and Increment), region splits or merges. </para>
              <para>Distributed Log Replay extends the <xref linkend="distributed.log.splitting" /> framework. It works by
                directly replaying WAL edits to another RegionServer instead of creating
                  <filename>recovered.edits</filename> files. It provides the following advantages
                over distributed log splitting alone:</para>
              <itemizedlist>
                <listitem><para>It eliminates the overhead of writing and reading a large number of
                  <filename>recovered.edits</filename> files. It is not unusual for thousands of
                  <filename>recovered.edits</filename> files to be created and written concurrently
                  during a RegionServer recovery. Many small random writes can degrade overall
                  system performance.</para></listitem>
                <listitem><para>It allows writes even when a region is in recovering state. It only takes seconds for a recovering region to accept writes again. 
</para></listitem>
              </itemizedlist>
              <formalpara>
                <title>Enabling Distributed Log Replay</title>
                <para>To enable distributed log replay, set <varname>hbase.master.distributed.log.replay</varname> to
                  true. This will be the default for HBase 0.99 (<link
                    xlink:href="https://issues.apache.org/jira/browse/HBASE-10888">HBASE-10888</link>).</para>
              </formalpara>
              <para>You must also enable HFile version 3 (which is the default HFile format starting
                in HBase 0.99. See <link
                  xlink:href="https://issues.apache.org/jira/browse/HBASE-10855">HBASE-10855</link>).
                Distributed log replay is unsafe for rolling upgrades.</para>
            </section>
          </section>
        </section>
        <section xml:id="wal.disable">
          <title>Disabling the WAL</title>
          <para>It is possible to disable the WAL, to improve performace in certain specific
            situations. However, disabling the WAL puts your data at risk. The only situation where
            this is recommended is during a bulk load. This is because, in the event of a problem,
            the bulk load can be re-run with no risk of data loss.</para>
          <para>The WAL is disabled by calling the HBase client field
              <code>Mutation.writeToWAL(false)</code>. Use the
              <code>Mutation.setDurability(Durability.SKIP_WAL)</code> and Mutation.getDurability()
            methods to set and get the field's value. There is no way to disable the WAL for only a
            specific table.</para>
          <warning>
            <para>If you disable the WAL for anything other than bulk loads, your data is at
              risk.</para></warning>
        </section>
      </section>

    </section>  <!--  regionserver -->

    <section xml:id="regions.arch">
    <title>Regions</title>
    <para>Regions are the basic element of availability and
     distribution for tables, and are comprised of a Store per Column Family. The heirarchy of objects
     is as follows:
<programlisting>
<filename>Table</filename>       (HBase table)
    <filename>Region</filename>       (Regions for the table)
         <filename>Store</filename>          (Store per ColumnFamily for each Region for the table)
              <filename>MemStore</filename>           (MemStore for each Store for each Region for the table)
              <filename>StoreFile</filename>          (StoreFiles for each Store for each Region for the table)
                    <filename>Block</filename>             (Blocks within a StoreFile within a Store for each Region for the table)
 </programlisting>
     For a description of what HBase files look like when written to HDFS, see <xref linkend="trouble.namenode.hbase.objects"/>.
            </para>
    <section xml:id="arch.regions.size">
      <title>Considerations for Number of Regions</title>
<para> In general, HBase is designed to run with a small (20-200) number of relatively large (5-20Gb) regions per server. The considerations for this are as follows:</para>
<section xml:id="too_many_regions">
          <title>Why cannot I have too many regions?</title>
          <para>
              Typically you want to keep your region count low on HBase for numerous reasons.
              Usually right around 100 regions per RegionServer has yielded the best results.
              Here are some of the reasons below for keeping region count low:</para>
              <orderedlist>
                  <listitem><para>
                          MSLAB requires 2mb per memstore (that's 2mb per family per region).
                          1000 regions that have 2 families each is 3.9GB of heap used, and it's not even storing data yet. NB: the 2MB value is configurable.
                  </para></listitem>
                  <listitem><para>If you fill all the regions at somewhat the same rate, the global memory usage makes it that it forces tiny
                          flushes when you have too many regions which in turn generates compactions.
                          Rewriting the same data tens of times is the last thing you want.
                          An example is filling 1000 regions (with one family) equally and let's consider a lower bound for global memstore
                          usage of 5GB (the region server would have a big heap).
                          Once it reaches 5GB it will force flush the biggest region,
                          at that point they should almost all have about 5MB of data so
                          it would flush that amount. 5MB inserted later, it would flush another
                          region that will now have a bit over 5MB of data, and so on.
                          This is currently the main limiting factor for the number of regions; see <xref linkend="ops.capacity.regions.count" />
                          for detailed formula.
                  </para></listitem>
                  <listitem><para>The master as is is allergic to tons of regions, and will
                          take a lot of time assigning them and moving them around in batches.
                          The reason is that it's heavy on ZK usage, and it's not very async
                          at the moment (could really be improved -- and has been imporoved a bunch
                          in 0.96 hbase).
                  </para></listitem>
                  <listitem><para>
                          In older versions of HBase (pre-v2 hfile, 0.90 and previous), tons of regions
                          on a few RS can cause the store file index to rise, increasing heap usage and potentially
                          creating memory pressure or OOME on the RSs
                  </para></listitem>
          </orderedlist>
            <para>Another issue is the effect of the number of regions on mapreduce jobs; it is typical to have one mapper per HBase region.
              Thus, hosting only 5 regions per RS may not be enough to get sufficient number of tasks for a mapreduce job, while 1000 regions will generate far too many tasks.
            </para>
            <para>See <xref linkend="ops.capacity.regions" /> for configuration guidelines.</para>

      </section>

    </section>

      <section xml:id="regions.arch.assignment">
        <title>Region-RegionServer Assignment</title>
        <para>This section describes how Regions are assigned to RegionServers.
         </para>

        <section xml:id="regions.arch.assignment.startup">
          <title>Startup</title>
          <para>When HBase starts regions are assigned as follows (short version):
            <orderedlist>
              <listitem><para>The Master invokes the <code>AssignmentManager</code> upon startup.</para>
              </listitem>
              <listitem><para>The <code>AssignmentManager</code> looks at the existing region assignments in META.</para>
              </listitem>
              <listitem><para>If the region assignment is still valid (i.e., if the RegionServer is still online)
                then the assignment is kept.</para>
              </listitem>
              <listitem><para>If the assignment is invalid, then the <code>LoadBalancerFactory</code> is invoked to assign the
                region.  The <code>DefaultLoadBalancer</code> will randomly assign the region to a RegionServer.</para>
              </listitem>
              <listitem><para>META is updated with the RegionServer assignment (if needed) and the RegionServer start codes
              (start time of the RegionServer process) upon region opening by the RegionServer.</para>
              </listitem>
           </orderedlist>
          </para>
        </section>

        <section
          xml:id="regions.arch.assignment.failover">
          <title>Failover</title>
          <para>When a RegionServer fails: <orderedlist>
              <listitem>
                <para>The regions immediately become unavailable because the RegionServer is
                  down.</para>
              </listitem>
              <listitem>
                <para>The Master will detect that the RegionServer has failed.</para>
              </listitem>
              <listitem>
                <para>The region assignments will be considered invalid and will be re-assigned just
                  like the startup sequence.</para>
              </listitem>
              <listitem>
                <para>In-flight queries are re-tried, and not lost.</para>
              </listitem>
              <listitem>
                <para>Operations are switched to a new RegionServer within the following amount of
                  time:</para>
                <programlisting>ZooKeeper session timeout + split time + assignment/replay time</programlisting>
              </listitem>
            </orderedlist>
          </para>
        </section>

        <section xml:id="regions.arch.balancer">
          <title>Region Load Balancing</title>
          <para>
          Regions can be periodically moved by the <xref linkend="master.processes.loadbalancer" />.
          </para>
        </section>

        <section xml:id="regions.arch.states">
          <title>Region State Transition</title>
          <para> HBase maintains a state for each region and persists the state in META. The state
            of the META region itself is persisted in ZooKeeper. You can see the states of regions
            in transition in the Master web UI. Following is the list of possible region
            states.</para>

          <itemizedlist>
            <title>Possible Region States</title>
            <listitem>
              <para>OFFLINE: the region is offline and not opening</para>
            </listitem>
            <listitem>
              <para>OPENING: the region is in the process of being opened</para>
            </listitem>
            <listitem>
              <para>OPEN: the region is open and the region server has notified the master</para>
            </listitem>
            <listitem>
              <para>FAILED_OPEN: the region server failed to open the region</para>
            </listitem>
            <listitem>
              <para>CLOSING: the region is in the process of being closed</para>
            </listitem>
            <listitem>
              <para>CLOSED: the region server has closed the region and notified the master</para>
            </listitem>
            <listitem>
              <para>FAILED_CLOSE: the region server failed to close the region</para>
            </listitem>
            <listitem>
              <para>SPLITTING: the region server notified the master that the region is
                splitting</para>
            </listitem>
            <listitem>
              <para>SPLIT: the region server notified the master that the region has finished
                splitting</para>
            </listitem>
            <listitem>
              <para>SPLITTING_NEW: this region is being created by a split which is in
                progress</para>
            </listitem>
            <listitem>
              <para>MERGING: the region server notified the master that this region is being merged
                with another region</para>
            </listitem>
            <listitem>
              <para>MERGED: the region server notified the master that this region has been
                merged</para>
            </listitem>
            <listitem>
              <para>MERGING_NEW: this region is being created by a merge of two regions</para>
            </listitem>
          </itemizedlist>

          <figure>
            <title>Region State Transitions</title>
            <mediaobject>
              <imageobject>
                <imagedata align="center" valign="middle" fileref="region_states.png"/>
              </imageobject>
              <caption>
                <para>This graph shows all allowed transitions a region can undergo. In the graph,
                  each node is a state. A node has a color based on the state type, for readability.
                  A directed line in the graph is a possible state transition.</para>
              </caption>
            </mediaobject>
          </figure>

          <itemizedlist>
            <title>Graph Legend</title>
             <listitem>
              <para>Brown: Offline state, a special state that can be transient (after closed before
                opening), terminal (regions of disabled tables), or initial (regions of newly
                created tables)</para></listitem>
             <listitem>
              <para>Palegreen: Online state that regions can serve requests</para></listitem>
             <listitem>
              <para>Lightblue: Transient states</para></listitem>
             <listitem>
              <para>Red: Failure states that need OPS attention</para></listitem>
             <listitem>
              <para>Gold: Terminal states of regions split/merged</para></listitem>
             <listitem>
              <para>Grey: Initial states of regions created through split/merge</para></listitem>
          </itemizedlist>

          <orderedlist>
            <title>Region State Transitions Explained</title>
             <listitem>
              <para>The master moves a region from <literal>OFFLINE</literal> to
                  <literal>OPENING</literal> state and tries to assign the region to a region
                server. The region server may or may not have received the open region request. The
                master retries sending the open region request to the region server until the RPC
                goes through or the master runs out of retries. After the region server receives the
                open region request, the region server begins opening the region.</para>
             </listitem>
             <listitem>
              <para>If the master is running out of retries, the master prevents the region server
                from opening the region by moving the region to <literal>CLOSING</literal> state and
                trying to close it, even if the region server is starting to open the region.</para>
             </listitem>
             <listitem>
              <para>After the region server opens the region, it continues to try to notify the
                master until the master moves the region to <literal>OPEN</literal> state and
                notifies the region server. The region is now open.</para>
             </listitem>
             <listitem>
              <para>If the region server cannot open the region, it notifies the master. The master
                moves the region to <literal>CLOSED</literal> state and tries to open the region on
                a different region server.</para>
             </listitem>
             <listitem>
              <para>If the master cannot open the region on any of a certain number of regions, it
                moves the region to <literal>FAILED_OPEN</literal> state, and takes no further
                action until an operator intervenes from the HBase shell, or the server is
                dead.</para>
             </listitem>
             <listitem>
              <para>The master moves a region from <literal>OPEN</literal> to
                  <literal>CLOSING</literal> state. The region server holding the region may or may
                not have received the close region request. The master retries sending the close
                request to the server until the RPC goes through or the master runs out of
                retries.</para>
             </listitem>
             <listitem>
              <para>If the region server is not online, or throws
                  <code>NotServingRegionException</code>, the master moves the region to
                  <literal>OFFLINE</literal> state and re-assigns it to a different region
                server.</para>
             </listitem>
             <listitem>
              <para>If the region server is online, but not reachable after the master runs out of
                retries, the master moves the region to <literal>FAILED_CLOSE</literal> state and
                takes no further action until an operator intervenes from the HBase shell, or the
                server is dead.</para>
             </listitem>
             <listitem>
              <para>If the region server gets the close region request, it closes the region and
                notifies the master. The master moves the region to <literal>CLOSED</literal> state
                and re-assigns it to a different region server.</para>
             </listitem>
             <listitem>
              <para>Before assigning a region, the master moves the region to
                  <literal>OFFLINE</literal> state automatically if it is in
                  <literal>CLOSED</literal> state.</para>
             </listitem>
             <listitem>
              <para>When a region server is about to split a region, it notifies the master. The
                master moves the region to be split from <literal>OPEN</literal> to
                  <literal>SPLITTING</literal> state and add the two new regions to be created to
                the region server. These two regions are in <literal>SPLITING_NEW</literal> state
                initially.</para>
             </listitem>
             <listitem>
              <para>After notifying the master, the region server starts to split the region. Once
                past the point of no return, the region server notifies the master again so the
                master can update the META. However, the master does not update the region states
                until it is notified by the server that the split is done. If the split is
                successful, the splitting region is moved from <literal>SPLITTING</literal> to
                  <literal>SPLIT</literal> state and the two new regions are moved from
                  <literal>SPLITTING_NEW</literal> to <literal>OPEN</literal> state.</para>
             </listitem>
             <listitem>
              <para>If the split fails, the splitting region is moved from
                  <literal>SPLITTING</literal> back to <literal>OPEN</literal> state, and the two
                new regions which were created are moved from <literal>SPLITTING_NEW</literal> to
                  <literal>OFFLINE</literal> state.</para>
             </listitem>
             <listitem>
              <para>When a region server is about to merge two regions, it notifies the master
                first. The master moves the two regions to be merged from <literal>OPEN</literal> to
                  <literal>MERGING</literal>state, and adds the new region which will hold the
                contents of the merged regions region to the region server. The new region is in
                  <literal>MERGING_NEW</literal> state initially.</para>
             </listitem>
             <listitem>
              <para>After notifying the master, the region server starts to merge the two regions.
                Once past the point of no return, the region server notifies the master again so the
                master can update the META. However, the master does not update the region states
                until it is notified by the region server that the merge has completed. If the merge
                is successful, the two merging regions are moved from <literal>MERGING</literal> to
                  <literal>MERGED</literal> state and the new region is moved from
                  <literal>MERGING_NEW</literal> to <literal>OPEN</literal> state.</para>
             </listitem>
             <listitem>
              <para>If the merge fails, the two merging regions are moved from
                  <literal>MERGING</literal> back to <literal>OPEN</literal> state, and the new
                region which was created to hold the contents of the merged regions is moved from
                  <literal>MERGING_NEW</literal> to <literal>OFFLINE</literal> state.</para>
             </listitem>
             <listitem>
              <para>For regions in <literal>FAILED_OPEN</literal> or <literal>FAILED_CLOSE</literal>
                states , the master tries to close them again when they are reassigned by an
                operator via HBase Shell. </para>
             </listitem>
          </orderedlist>
        </section>

      </section>  <!--  assignment -->

      <section xml:id="regions.arch.locality">
        <title>Region-RegionServer Locality</title>
        <para>Over time, Region-RegionServer locality is achieved via HDFS block replication.
          The HDFS client does the following by default when choosing locations to write replicas:</para>
           <orderedlist>
             <listitem><para>First replica is written to local node</para>
             </listitem>
             <listitem><para>Second replica is written to a random node on another rack</para>
             </listitem>
             <listitem><para>Third replica is written on the same rack as the second, but on a different node chosen randomly</para>
             </listitem>
             <listitem><para>Subsequent replicas are written on random nodes on the cluster. See <emphasis>Replica Placement: The First Baby Steps</emphasis> on this page: <link
                xlink:href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html"
                >HDFS Architecture</link></para></listitem>
           </orderedlist>
        <para>
          Thus, HBase eventually achieves locality for a region after a flush or a compaction.
          In a RegionServer failover situation a RegionServer may be assigned regions with non-local
          StoreFiles (because none of the replicas are local), however as new data is written
          in the region, or the table is compacted and StoreFiles are re-written, they will become "local"
          to the RegionServer.
        </para>
        <para>For more information, see <emphasis>Replica Placement: The First Baby Steps</emphasis> on this page: <link xlink:href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html">HDFS Architecture</link>
        and also Lars George's blog on <link xlink:href="http://www.larsgeorge.com/2010/05/hbase-file-locality-in-hdfs.html">HBase and HDFS locality</link>.
        </para>
      </section>

      <section xml:id="arch.region.splits">
        <title>Region Splits</title>
        <para>Regions split when they reach a configured threshold.
        Below we treat the topic in short.  For a longer exposition,
        see <link xlink:href="http://hortonworks.com/blog/apache-hbase-region-splitting-and-merging/">Apache HBase Region Splitting and Merging</link>
        by our Enis Soztutar.
        </para>

        <para>Splits run unaided on the RegionServer; i.e. the Master does not
        participate. The RegionServer splits a region, offlines the split
        region and then adds the daughter regions to META, opens daughters on
        the parent's hosting RegionServer and then reports the split to the
        Master. See <xref linkend="disable.splitting" /> for how to manually manage
        splits (and for why you might do this)</para>
        <section>
          <title>Custom Split Policies</title>
          <para>The default split policy can be overwritten using a custom <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/regionserver/RegionSplitPolicy.html">RegionSplitPolicy</link> (HBase 0.94+).
          Typically a custom split policy should extend HBase's default split policy: <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/regionserver/ConstantSizeRegionSplitPolicy.html">ConstantSizeRegionSplitPolicy</link>.
          </para>
          <para>The policy can set globally through the HBaseConfiguration used or on a per table basis:
<programlisting language="java">
HTableDescriptor myHtd = ...;
myHtd.setValue(HTableDescriptor.SPLIT_POLICY, MyCustomSplitPolicy.class.getName());
</programlisting>
          </para>
        </section>
      </section>

      <section xml:id="manual_region_splitting_decisions">
        <title>Manual Region Splitting</title>
        <para>It is possible to manually split your table, either at table creation (pre-splitting),
          or at a later time as an administrative action. You might choose to split your region for
          one or more of the following reasons. There may be other valid reasons, but the need to
          manually split your table might also point to problems with your schema design.</para>
        <itemizedlist>
          <title>Reasons to Manually Split Your Table</title>
          <listitem>
            <para>Your data is sorted by timeseries or another similar algorithm that sorts new data
              at the end of the table. This means that the Region Server holding the last region is
              always under load, and the other Region Servers are idle, or mostly idle. See also
                <xref linkend="timeseries"/>.</para>
          </listitem>
          <listitem>
            <para>You have developed an unexpected hotspot in one region of your table. For
              instance, an application which tracks web searches might be inundated by a lot of
              searches for a celebrity in the event of news about that celebrity. See <xref
                linkend="perf.one.region"/> for more discussion about this particular
              scenario.</para>
          </listitem>
          <listitem>
            <para>After a big increase to the number of Region Servers in your cluster, to get the
              load spread out quickly.</para>
          </listitem>
          <listitem>
            <para>Before a bulk-load which is likely to cause unusual and uneven load across
              regions.</para>
          </listitem>
        </itemizedlist>
        <para>See <xref linkend="disable.splitting"/> for a discussion about the dangers and
          possible benefits of managing splitting completely manually.</para>
        <section>
          <title>Determining Split Points</title>
          <para>The goal of splitting your table manually is to improve the chances of balancing the
            load across the cluster in situations where good rowkey design alone won't get you
            there. Keeping that in mind, the way you split your regions is very dependent upon the
            characteristics of your data. It may be that you already know the best way to split your
            table. If not, the way you split your table depends on what your keys are like.</para>
          <variablelist>
            <varlistentry>
              <term>Alphanumeric Rowkeys</term>
              <listitem>
                <para>If your rowkeys start with a letter or number, you can split your table at
                  letter or number boundaries. For instance, the following command creates a table
                  with regions that split at each vowel, so the first region has A-D, the second
                  region has E-H, the third region has I-N, the fourth region has O-V, and the fifth
                  region has U-Z.</para>
                  <screen>hbase> create 'test_table', 'f1', SPLITS=> ['a', 'e', 'i', 'o', 'u']</screen>
                <para>The following command splits an existing table at split point '2'.</para>
                <screen>hbase> split 'test_table', '2'</screen>
                <para>You can also split a specific region by referring to its ID. You can find the
                  region ID by looking at either the table or region in the Web UI. It will be a
                  long number such as
                    <literal>t2,1,1410227759524.829850c6eaba1acc689480acd8f081bd.</literal>. The
                  format is <replaceable>table_name,start_key,region_id</replaceable>To split that
                  region into two, as close to equally as possible (at the nearest row boundary),
                  issue the following command.</para>
                <screen>hbase> split 't2,1,1410227759524.829850c6eaba1acc689480acd8f081bd.'</screen>
                <para>The split key is optional. If it is omitted, the table or region is split in
                  half.</para>
                <para>The following example shows how to use the RegionSplitter to create 10
                  regions, split at hexadecimal values.</para>
                <screen>hbase org.apache.hadoop.hbase.util.RegionSplitter test_table HexStringSplit -c 10 -f f1</screen>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Using a Custom Algorithm</term>
              <listitem>
                <para>The RegionSplitter tool is provided with HBase, and uses a <firstterm><link
                      xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/util/RegionSplitter.SplitAlgorithm.html"
                      >SplitAlgorithm</link></firstterm> to determine split points for you. As
                  parameters, you give it the algorithm, desired number of regions, and column
                  families. It includes two split algorithms. The first is the <code><link
                      xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/util/RegionSplitter.HexStringSplit.html"
                      >HexStringSplit</link></code> algorithm, which assumes the row keys are
                  hexadecimal strings. The second, <link
                    xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/util/RegionSplitter.UniformSplit.html"
                    >UniformSplit</link>, assumes the row keys are random byte arrays. You will
                  probably need to develop your own SplitAlgorithm, using the provided ones as
                  models. </para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
      </section>
       <section>
        <title>Online Region Merges</title>

        <para>Both Master and Regionserver participate in the event of online region merges.
        Client sends merge RPC to master, then master moves the regions together to the
        same regionserver where the more heavily loaded region resided, finally master
        send merge request to this regionserver and regionserver run the region merges.
        Similar with process of region splits, region merges run as a local transaction
        on the regionserver, offlines the regions and then merges two regions on the file
        system, atomically delete merging regions from META and add merged region to the META,
        opens merged region on the regionserver and reports the merge to Master at last.
        </para>
        <para>An example of region merges in the hbase shell
          <programlisting language="bourne">$ hbase> merge_region 'ENCODED_REGIONNAME', 'ENCODED_REGIONNAME'
          hbase> merge_region 'ENCODED_REGIONNAME', 'ENCODED_REGIONNAME', true
          </programlisting>
          It's an asynchronous operation and call returns immediately without waiting merge completed.
          Passing 'true' as the optional third parameter will force a merge ('force' merges regardless
          else merge will fail unless passed adjacent regions. 'force' is for expert use only)
        </para>
      </section>

      <section xml:id="store">
          <title>Store</title>
          <para>A Store hosts a MemStore and 0 or more StoreFiles (HFiles). A Store corresponds to a column family for a table for a given region.
          </para>
      <section
          xml:id="store.memstore">
      <title>MemStore</title>
          <para>The MemStore holds in-memory modifications to the Store. Modifications are
            Cells/KeyValues. When a flush is requested, the current memstore is moved to a snapshot and is
            cleared. HBase continues to serve edits from the new memstore and backing snapshot until
            the flusher reports that the flush succeeded. At this point, the snapshot is discarded.
            Note that when the flush happens, Memstores that belong to the same region will all be
            flushed.</para>
      </section>
        <section>
          <title>MemStoreFlush</title>
          <para> A MemStore flush can be triggered under any of the conditions listed below. The
            minimum flush unit is per region, not at individual MemStore level.</para>
          <orderedlist>
            <listitem>
              <para>When a MemStore reaches the value specified by
                  <varname>hbase.hregion.memstore.flush.size</varname>, all MemStores that belong to
                its region will be flushed out to disk.</para>
            </listitem>
            <listitem>
              <para>When overall memstore usage reaches the value specified by
                  <varname>hbase.regionserver.global.memstore.upperLimit</varname>, MemStores from
                various regions will be flushed out to disk to reduce overall MemStore usage in a
                Region Server. The flush order is based on the descending order of a region's
                MemStore usage. Regions will have their MemStores flushed until the overall MemStore
                usage drops to or slightly below
                  <varname>hbase.regionserver.global.memstore.lowerLimit</varname>. </para>
            </listitem>
            <listitem>
              <para>When the number of WAL per region server reaches the value specified in
                  <varname>hbase.regionserver.max.logs</varname>, MemStores from various regions
                will be flushed out to disk to reduce WAL count. The flush order is based on time.
                Regions with the oldest MemStores are flushed first until WAL count drops below
                  <varname>hbase.regionserver.max.logs</varname>. </para>
            </listitem>
          </orderedlist>
        </section>
        <section xml:id="hregion.scans">
          <title>Scans</title>
          <itemizedlist>
            <listitem>
              <para> When a client issues a scan against a table, HBase generates
                  <code>RegionScanner</code> objects, one per region, to serve the scan request.
              </para>
            </listitem>
            <listitem>
              <para>The <code>RegionScanner</code> object contains a list of
                  <code>StoreScanner</code> objects, one per column family. </para>
            </listitem>
            <listitem>
              <para>Each <code>StoreScanner</code> object further contains a list of
                  <code>StoreFileScanner</code> objects, corresponding to each StoreFile and
                HFile of the corresponding column family, and a list of
                  <code>KeyValueScanner</code> objects for the MemStore. </para>
            </listitem>
            <listitem>
              <para>The two lists are merge into one, which is sorted in ascending order with the
                scan object for the MemStore at the end of the list.</para>
            </listitem>
            <listitem>
              <para>When a <code>StoreFileScanner</code> object is constructed, it is associated
                with a <code>MultiVersionConsistencyControl</code> read point, which is the
                current <code>memstoreTS</code>, filtering out any new updates beyond the read
                point. </para>
            </listitem>
          </itemizedlist>
      </section>
  <section xml:id="hfile">
      <title>StoreFile (HFile)</title>
      <para>StoreFiles are where your data lives.
      </para>
      <section><title>HFile Format</title>
          <para>The <emphasis>hfile</emphasis> file format is based on
              the SSTable file described in the <link xlink:href="http://research.google.com/archive/bigtable.html">BigTable [2006]</link> paper and on
              Hadoop's <link xlink:href="http://hadoop.apache.org/common/docs/current/api/org/apache/hadoop/io/file/tfile/TFile.html">tfile</link>
              (The unit test suite and the compression harness were taken directly from tfile).
              Schubert Zhang's blog post on <link xlink:href="http://cloudepr.blogspot.com/2009/09/hfile-block-indexed-file-format-to.html">HFile: A Block-Indexed File Format to Store Sorted Key-Value Pairs</link> makes for a thorough introduction to HBase's hfile.  Matteo Bertozzi has also put up a
              helpful description, <link xlink:href="http://th30z.blogspot.com/2011/02/hbase-io-hfile.html?spref=tw">HBase I/O: HFile</link>.
          </para>
          <para>For more information, see the <link xlink:href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/io/hfile/HFile.html">HFile source code</link>.
          Also see <xref linkend="hfilev2"/> for information about the HFile v2 format that was included in 0.92.
          </para>
      </section>
      <section xml:id="hfile_tool">
        <title>HFile Tool</title>

        <para>To view a textualized version of hfile content, you can do use
        the <classname>org.apache.hadoop.hbase.io.hfile.HFile
        </classname>tool. Type the following to see usage:<programlisting language="bourne"><code>$ ${HBASE_HOME}/bin/hbase org.apache.hadoop.hbase.io.hfile.HFile </code> </programlisting>For
        example, to view the content of the file
        <filename>hdfs://10.81.47.41:8020/hbase/TEST/1418428042/DSMP/4759508618286845475</filename>,
        type the following:<programlisting language="bourne"> <code>$ ${HBASE_HOME}/bin/hbase org.apache.hadoop.hbase.io.hfile.HFile -v -f hdfs://10.81.47.41:8020/hbase/TEST/1418428042/DSMP/4759508618286845475 </code> </programlisting>If
        you leave off the option -v to see just a summary on the hfile. See
        usage for other things to do with the <classname>HFile</classname>
        tool.</para>
      </section>
      <section xml:id="store.file.dir">
       <title>StoreFile Directory Structure on HDFS</title>
        <para>For more information of what StoreFiles look like on HDFS with respect to the directory structure, see <xref linkend="trouble.namenode.hbase.objects" />.
        </para>
      </section>
      </section> <!--  hfile -->

      <section xml:id="hfile.blocks">
        <title>Blocks</title>
        <para>StoreFiles are composed of blocks.  The blocksize is configured on a per-ColumnFamily basis.
        </para>
        <para>Compression happens at the block level within StoreFiles.  For more information on compression, see <xref linkend="compression"/>.
        </para>
        <para>For more information on blocks, see the <link xlink:href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/io/hfile/HFileBlock.html">HFileBlock source code</link>.
        </para>
      </section>
      <section xml:id="keyvalue">
        <title>KeyValue</title>
        <para>The KeyValue class is the heart of data storage in HBase.  KeyValue wraps a byte array and takes offsets and lengths into passed array
         at where to start interpreting the content as KeyValue.
        </para>
        <para>The KeyValue format inside a byte array is:
           <itemizedlist>
             <listitem><para>keylength</para></listitem>
             <listitem><para>valuelength</para></listitem>
             <listitem><para>key</para></listitem>
             <listitem><para>value</para></listitem>
           </itemizedlist>
        </para>
        <para>The Key is further decomposed as:
           <itemizedlist>
             <listitem><para>rowlength</para></listitem>
             <listitem><para>row (i.e., the rowkey)</para></listitem>
             <listitem><para>columnfamilylength</para></listitem>
             <listitem><para>columnfamily</para></listitem>
             <listitem><para>columnqualifier</para></listitem>
             <listitem><para>timestamp</para></listitem>
             <listitem><para>keytype (e.g., Put, Delete, DeleteColumn, DeleteFamily)</para></listitem>
           </itemizedlist>
        </para>
        <para>KeyValue instances are <emphasis>not</emphasis> split across blocks.
         For example, if there is an 8 MB KeyValue, even if the block-size is 64kb this KeyValue will be read
         in as a coherent block.  For more information, see the <link xlink:href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/KeyValue.html">KeyValue source code</link>.
        </para>
        <section xml:id="keyvalue.example"><title>Example</title>
          <para>To emphasize the points above, examine what happens with two Puts for two different columns for the same row:</para>
           <itemizedlist>
             <listitem><para>Put #1:  <code>rowkey=row1, cf:attr1=value1</code></para></listitem>
             <listitem><para>Put #2:  <code>rowkey=row1, cf:attr2=value2</code></para></listitem>
             </itemizedlist>
          <para>Even though these are for the same row, a KeyValue is created for each column:</para>
          <para>Key portion for Put #1:
           <itemizedlist>
             <listitem><para>rowlength <code>------------&gt; 4</code></para></listitem>
             <listitem><para>row <code>-----------------&gt; row1</code></para></listitem>
             <listitem><para>columnfamilylength <code>---&gt; 2</code></para></listitem>
             <listitem><para>columnfamily <code>--------&gt; cf</code></para></listitem>
             <listitem><para>columnqualifier <code>------&gt; attr1</code></para></listitem>
             <listitem><para>timestamp <code>-----------&gt; server time of Put</code></para></listitem>
             <listitem><para>keytype <code>-------------&gt; Put</code></para></listitem>
           </itemizedlist>
          </para>
          <para>Key portion for Put #2:
           <itemizedlist>
             <listitem><para>rowlength <code>------------&gt; 4</code></para></listitem>
             <listitem><para>row <code>-----------------&gt; row1</code></para></listitem>
             <listitem><para>columnfamilylength <code>---&gt; 2</code></para></listitem>
             <listitem><para>columnfamily <code>--------&gt; cf</code></para></listitem>
             <listitem><para>columnqualifier <code>------&gt; attr2</code></para></listitem>
             <listitem><para>timestamp <code>-----------&gt; server time of Put</code></para></listitem>
             <listitem><para>keytype <code>-------------&gt; Put</code></para></listitem>
           </itemizedlist>
           <!--  trying to get the above arrows to line up at the same horizontal position has proven
           harder than I thought -->
          </para>
          <para>It is critical to understand that the rowkey, ColumnFamily, and column (aka columnqualifier) are embedded within
            the KeyValue instance.  The longer these identifiers are, the bigger the KeyValue is.</para>
        </section>

      </section>
        <section
          xml:id="compaction">
          <title>Compaction</title>
          <itemizedlist>
            <title>Ambiguous Terminology</title>
            <listitem><para>A <firstterm>StoreFile</firstterm> is a facade of HFile. In terms of compaction, use of
              StoreFile seems to have prevailed in the past.</para></listitem>
            <listitem><para>A <firstterm>Store</firstterm> is the same thing as a ColumnFamily.
              StoreFiles are related to a Store, or ColumnFamily.</para></listitem>
            <listitem>
              <para>If you want to read more about StoreFiles versus HFiles and Stores versus
                ColumnFamilies, see <link
                  xlink:href="https://issues.apache.org/jira/browse/HBASE-11316">HBASE-11316</link>.</para>
            </listitem>
          </itemizedlist>
          <para>When the MemStore reaches a given size
              (<code>hbase.hregion.memstore.flush.size)</code>, it flushes its contents to a
            StoreFile. The number of StoreFiles in a Store increases over time.
              <firstterm>Compaction</firstterm> is an operation which reduces the number of
            StoreFiles in a Store, by merging them together, in order to increase performance on
            read operations. Compactions can be resource-intensive to perform, and can either help
            or hinder performance depending on many factors. </para>
          <para>Compactions fall into two categories: minor and major. Minor and major compactions
            differ in the following ways.</para>
          <para><firstterm>Minor compactions</firstterm> usually select a small number of small,
            adjacent StoreFiles and rewrite them as a single StoreFile. Minor compactions do not
            drop (filter out) deletes or expired versions, because of potential side effects. See <xref
              linkend="compaction.and.deletes" /> and <xref
              linkend="compaction.and.versions" /> for information on how deletes and versions are
            handled in relation to compactions. The end result of a minor compaction is fewer,
            larger StoreFiles for a given Store.</para>
          <para>The end result of a <firstterm>major compaction</firstterm> is a single StoreFile
            per Store. Major compactions also process delete markers and max versions. See <xref
              linkend="compaction.and.deletes" /> and <xref
              linkend="compaction.and.versions" /> for information on how deletes and versions are
            handled in relation to compactions.</para>

          <formalpara
            xml:id="compaction.and.deletes">
            <title>Compaction and Deletions</title>
            <para> When an explicit deletion occurs in HBase, the data is not actually deleted.
              Instead, a <firstterm>tombstone</firstterm> marker is written. The tombstone marker
              prevents the data from being returned with queries. During a major compaction, the
              data is actually deleted, and the tombstone marker is removed from the StoreFile. If
              the deletion happens because of an expired TTL, no tombstone is created. Instead, the
              expired data is filtered out and is not written back to the compacted
              StoreFile.</para>
          </formalpara>

          <formalpara
            xml:id="compaction.and.versions">
            <title>Compaction and Versions</title>
            <para> When you create a Column Family, you can specify the maximum number of versions
              to keep, by specifying <varname>HColumnDescriptor.setMaxVersions(int
                versions)</varname>. The default value is <literal>3</literal>. If more versions
              than the specified maximum exist, the excess versions are filtered out and not written
              back to the compacted StoreFile.</para>
          </formalpara>

          <note>
            <title>Major Compactions Can Impact Query Results</title>
            <para> In some situations, older versions can be inadvertently resurrected if a newer
              version is explicitly deleted. See <xref
                linkend="major.compactions.change.query.results" /> for a more in-depth explanation.
              This situation is only possible before the compaction finishes. </para>
          </note>

          <para>In theory, major compactions improve performance. However, on a highly loaded
            system, major compactions can require an inappropriate number of resources and adversely
            affect performance. In a default configuration, major compactions are scheduled
            automatically to run once in a 7-day period. This is sometimes inappropriate for systems
            in production. You can manage major compactions manually. See <xref
              linkend="managed.compactions" />. </para>
          <para>Compactions do not perform region merges. See <xref
              linkend="ops.regionmgt.merge" /> for more information on region merging. </para>
          <section
            xml:id="compaction.file.selection">
            <title>Compaction Policy - HBase 0.96.x and newer</title>
            <para>Compacting large StoreFiles, or too many StoreFiles at once, can cause more IO
              load than your cluster is able to handle without causing performance problems. The
              method by which HBase selects which StoreFiles to include in a compaction (and whether
              the compaction is a minor or major compaction) is called the <firstterm>compaction
                policy</firstterm>.</para>
            <para>Prior to HBase 0.96.x, there was only one compaction policy. That original
              compaction policy is still available as
                <systemitem>RatioBasedCompactionPolicy</systemitem> The new compaction default
              policy, called <systemitem>ExploringCompactionPolicy</systemitem>, was subsequently
              backported to HBase 0.94 and HBase 0.95, and is the default in HBase 0.96 and newer.
              It was implemented in <link
                xlink:href="https://issues.apache.org/jira/browse/HBASE-7842">HBASE-7842</link>. In
              short, <systemitem>ExploringCompactionPolicy</systemitem> attempts to select the best
              possible set of StoreFiles to compact with the least amount of work, while the
                <systemitem>RatioBasedCompactionPolicy</systemitem> selects the first set that meets
              the criteria.</para>
            <para>Regardless of the compaction policy used, file selection is controlled by several
              configurable parameters and happens in a multi-step approach. These parameters will be
              explained in context, and then will be given in a table which shows their
              descriptions, defaults, and implications of changing them.</para>

            <section
              xml:id="compaction.being.stuck">
              <title>Being Stuck</title>
              <para>When the MemStore gets too large, it needs to flush its contents to a StoreFile.
                However, a Store can only have <varname>hbase.hstore.blockingStoreFiles</varname>
                files, so the MemStore needs to wait for the number of StoreFiles to be reduced by
                one or more compactions. However, if the MemStore grows larger than
                  <varname>hbase.hregion.memstore.flush.size</varname>, it is not able to flush its
                contents to a StoreFile. If the MemStore is too large and the number of StpreFo;es
                is also too high, the algorithm is said to be "stuck". The compaction algorithm
                checks for this "stuck" situation and provides mechanisms to alleviate it.</para>
            </section>

            <section
              xml:id="exploringcompaction.policy">
              <title>The ExploringCompactionPolicy Algorithm</title>
              <para>The ExploringCompactionPolicy algorithm considers each possible set of
                adjacent StoreFiles before choosing the set where compaction will have the most
                benefit. </para>
              <para>One situation where the ExploringCompactionPolicy works especially well is when
                you are bulk-loading data and the bulk loads create larger StoreFiles than the
                StoreFiles which are holding data older than the bulk-loaded data. This can "trick"
                HBase into choosing to perform a major compaction each time a compaction is needed,
                and cause a lot of extra overhead. With the ExploringCompactionPolicy, major
                compactions happen much less frequently because minor compactions are more
                efficient.</para>
              <para>In general, ExploringCompactionPolicy is the right choice for most situations,
                and thus is the default compaction policy. You can also use
                ExploringCompactionPolicy along with <xref
                  linkend="ops.stripe" />.</para>
              <para>The logic of this policy can be examined in
                  <filename>hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/ExploringCompactionPolicy.java</filename>.
                The following is a walk-through of the logic of the
                ExploringCompactionPolicy.</para>
              <procedure>
                <step>
                  <para>Make a list of all existing StoreFiles in the Store. The rest of the
                    algorithm filters this list to come up with the subset of HFiles which will be
                    chosen for compaction.</para>
                </step>
                <step>
                  <para>If this was a user-requested compaction, attempt to perform the requested
                    compaction type, regardless of what would normally be chosen. Note that even if
                    the user requests a major compaction, it may not be possible to perform a major
                    compaction. This may be because not all StoreFiles in the Column Family are
                    available to compact or because there are too many Stores in the Column
                    Family.</para>
                </step>
                <step>
                  <para>Some StoreFiles are automatically excluded from consideration. These
                    include:</para>
                  <itemizedlist>
                    <listitem>
                      <para>StoreFiles that are larger than
                          <varname>hbase.hstore.compaction.max.size</varname></para>
                    </listitem>
                    <listitem>
                      <para>StoreFiles that were created by a bulk-load operation which explicitly
                        excluded compaction. You may decide to exclude StoreFiles resulting from
                        bulk loads, from compaction. To do this, specify the
                          <varname>hbase.mapreduce.hfileoutputformat.compaction.exclude</varname>
                        parameter during the bulk load operation.</para>
                    </listitem>
                  </itemizedlist>
                </step>
                <step>
                  <para>Iterate through the list from step 1, and make a list of all potential sets
                    of StoreFiles to compact together. A potential set is a grouping of
                      <varname>hbase.hstore.compaction.min</varname> contiguous StoreFiles in the
                    list. For each set, perform some sanity-checking and figure out whether this is
                    the best compaction that could be done:</para>
                  <itemizedlist>
                    <listitem>
                      <para>If the number of StoreFiles in this set (not the size of the StoreFiles)
                        is fewer than <varname>hbase.hstore.compaction.min</varname> or more than
                          <varname>hbase.hstore.compaction.max</varname>, take it out of
                        consideration.</para>
                    </listitem>
                    <listitem>
                      <para>Compare the size of this set of StoreFiles with the size of the smallest
                        possible compaction that has been found in the list so far. If the size of
                        this set of StoreFiles represents the smallest compaction that could be
                        done, store it to be used as a fall-back if the algorithm is "stuck" and no
                        StoreFiles would otherwise be chosen. See <xref
                          linkend="compaction.being.stuck" />.</para>
                    </listitem>
                    <listitem>
                      <para>Do size-based sanity checks against each StoreFile in this set of
                        StoreFiles.</para>
                      <itemizedlist>
                        <listitem>
                          <para>If the size of this StoreFile is larger than
                              <varname>hbase.hstore.compaction.max.size</varname>, take it out of
                            consideration.</para>
                        </listitem>
                        <listitem>
                          <para>If the size is greater than or equal to
                              <varname>hbase.hstore.compaction.min.size</varname>, sanity-check it
                            against the file-based ratio to see whether it is too large to be
                            considered. The sanity-checking is successful if:</para>
                          <itemizedlist>
                            <listitem>
                              <para>There is only one StoreFile in this set, or</para>
                            </listitem>
                            <listitem>
                              <para>For each StoreFile, its size multiplied by
                                  <varname>hbase.hstore.compaction.ratio</varname> (or
                                  <varname>hbase.hstore.compaction.ratio.offpeak</varname> if
                                off-peak hours are configured and it is during off-peak hours) is
                                less than the sum of the sizes of the other HFiles in the
                                set.</para>
                            </listitem>
                          </itemizedlist>
                        </listitem>
                      </itemizedlist>
                    </listitem>
                  </itemizedlist>
                </step>
                <step>
                  <para>If this set of StoreFiles is still in consideration, compare it to the
                    previously-selected best compaction. If it is better, replace the
                    previously-selected best compaction with this one.</para>
                </step>
                <step>
                  <para>When the entire list of potential compactions has been processed, perform
                    the best compaction that was found. If no StoreFiles were selected for
                    compaction, but there are multiple StoreFiles, assume the algorithm is stuck
                    (see <xref
                      linkend="compaction.being.stuck" />) and if so, perform the smallest
                    compaction that was found in step 3.</para>
                </step>
              </procedure>
            </section>

            <section
              xml:id="compaction.ratiobasedcompactionpolicy.algorithm">
              <title>RatioBasedCompactionPolicy Algorithm</title>
              <para>The RatioBasedCompactionPolicy was the only compaction policy prior to HBase
                0.96, though ExploringCompactionPolicy has now been backported to HBase 0.94 and
                0.95. To use the RatioBasedCompactionPolicy rather than the
                ExploringCompactionPolicy, set
                  <varname>hbase.hstore.defaultengine.compactionpolicy.class</varname> to
                  <literal>RatioBasedCompactionPolicy</literal> in the
                  <filename>hbase-site.xml</filename> file. To switch back to the
                ExploringCompactionPolicy, remove the setting from the
                  <filename>hbase-site.xml</filename>.</para>
              <para>The following section walks you through the algorithm used to select StoreFiles
                for compaction in the RatioBasedCompactionPolicy.</para>
              <procedure>
                <step>
                  <para>The first phase is to create a list of all candidates for compaction. A list
                    is created of all StoreFiles not already in the compaction queue, and all
                    StoreFiles newer than the newest file that is currently being compacted. This
                    list of StoreFiles is ordered by the sequence ID. The sequence ID is generated
                    when a Put is appended to the write-ahead log (WAL), and is stored in the
                    metadata of the HFile.</para>
                </step>
                <step>
                  <para>Check to see if the algorithm is stuck (see <xref
                      linkend="compaction.being.stuck" />, and if so, a major compaction is forced.
                    This is a key area where <xref
                      linkend="exploringcompaction.policy" /> is often a better choice than the
                    RatioBasedCompactionPolicy.</para>
                </step>
                <step>
                  <para>If the compaction was user-requested, try to perform the type of compaction
                    that was requested. Note that a major compaction may not be possible if all
                    HFiles are not available for compaction or if too may StoreFiles exist (more
                    than <varname>hbase.hstore.compaction.max</varname>).</para>
                </step>
                <step>
                  <para>Some StoreFiles are automatically excluded from consideration. These
                    include:</para>
                  <itemizedlist>
                    <listitem>
                      <para>StoreFiles that are larger than
                          <varname>hbase.hstore.compaction.max.size</varname></para>
                    </listitem>
                    <listitem>
                      <para>StoreFiles that were created by a bulk-load operation which explicitly
                        excluded compaction. You may decide to exclude StoreFiles resulting from
                        bulk loads, from compaction. To do this, specify the
                          <varname>hbase.mapreduce.hfileoutputformat.compaction.exclude</varname>
                        parameter during the bulk load operation.</para>
                    </listitem>
                  </itemizedlist>
                </step>
                <step>
                  <para>The maximum number of StoreFiles allowed in a major compaction is controlled
                    by the <varname>hbase.hstore.compaction.max</varname> parameter. If the list
                    contains more than this number of StoreFiles, a minor compaction is performed
                    even if a major compaction would otherwise have been done. However, a
                    user-requested major compaction still occurs even if there are more than
                      <varname>hbase.hstore.compaction.max</varname> StoreFiles to compact.</para>
                </step>
                <step>
                  <para>If the list contains fewer than
                      <varname>hbase.hstore.compaction.min</varname> StoreFiles to compact, a minor
                    compaction is aborted. Note that a major compaction can be performed on a single
                    HFile. Its function is to remove deletes and expired versions, and reset
                    locality on the StoreFile.</para>
                </step>
                <step>
                  <para>The value of the <varname>hbase.hstore.compaction.ratio</varname> parameter
                    is multiplied by the sum of StoreFiles smaller than a given file, to determine
                    whether that StoreFile is selected for compaction during a minor compaction. For
                    instance, if hbase.hstore.compaction.ratio is 1.2, FileX is 5 mb, FileY is 2 mb,
                    and FileZ is 3 mb:</para>
                  <screen>5 &lt;= 1.2 x (2 + 3)            or           5 &lt;= 6</screen>
                  <para>In this scenario, FileX is eligible for minor compaction. If FileX were 7
                    mb, it would not be eligible for minor compaction. This ratio favors smaller
                    StoreFile. You can configure a different ratio for use in off-peak hours, using
                    the parameter <varname>hbase.hstore.compaction.ratio.offpeak</varname>, if you
                    also configure <varname>hbase.offpeak.start.hour</varname> and
                      <varname>hbase.offpeak.end.hour</varname>.</para>
                </step>

                <step>
                  <para>If the last major compaction was too long ago and there is more than one
                    StoreFile to be compacted, a major compaction is run, even if it would otherwise
                    have been minor. By default, the maximum time between major compactions is 7
                    days, plus or minus a 4.8 hour period, and determined randomly within those
                    parameters. Prior to HBase 0.96, the major compaction period was 24 hours. See
                      <varname>hbase.hregion.majorcompaction</varname> in the table below to tune or
                    disable time-based major compactions.</para>
                </step>
              </procedure>
            </section>

            <section xml:id="compaction.parameters">

              <title>Parameters Used by Compaction Algorithm</title>
              <para>This table contains the main configuration parameters for compaction. This list
                is not exhaustive. To tune these parameters from the defaults, edit the
                  <filename>hbase-default.xml</filename> file. For a full list of all configuration
                parameters available, see <xref
                  linkend="config.files" /></para>
              <informaltable>
                <tgroup
                  cols="3">
                  <thead>
                    <row>
                      <entry>Parameter</entry>
                      <entry>Description</entry>
                      <entry>Default</entry>
                    </row>
                  </thead>
                  <tbody>
                    <row>
                      <entry>hbase.hstore.compaction.min</entry>
                      <entry><para>The minimum number of StoreFiles which must be eligible for
                          compaction before compaction can run.</para>
                        <para>The goal of tuning <varname>hbase.hstore.compaction.min</varname>
                          is to avoid ending up with too many tiny StoreFiles to compact. Setting
                          this value to <literal>2</literal> would cause a minor compaction each
                          time you have two StoreFiles in a Store, and this is probably not
                          appropriate. If you set this value too high, all the other values will
                          need to be adjusted accordingly. For most cases, the default value is
                          appropriate.</para>
                        <para>In previous versions of HBase, the parameter
                            <code>hbase.hstore.compaction.min</code> was called
                            <code>hbase.hstore.compactionThreshold</code>.</para>
                      </entry>
                      <entry>3</entry>
                    </row>
                    <row>
                      <entry>hbase.hstore.compaction.max</entry>
                      <entry><para>The maximum number of StoreFiles which will be selected for a
                          single minor compaction, regardless of the number of eligible
                          StoreFiles.</para>
                        <para>Effectively, the value of
                            <varname>hbase.hstore.compaction.max</varname> controls the length of
                          time it takes a single compaction to complete. Setting it larger means
                          that more StoreFiles are included in a compaction. For most cases, the
                          default value is appropriate.</para>
                      </entry>
                      <entry>10</entry>
                    </row>
                    <row>
                      <entry>hbase.hstore.compaction.min.size</entry>
                      <entry><para>A StoreFile smaller than this size will always be eligible for
                          minor compaction. StoreFiles this size or larger are evaluated by
                            <varname>hbase.hstore.compaction.ratio</varname> to determine if they are
                          eligible.</para>
                        <para>Because this limit represents the "automatic include" limit for
                          all StoreFiles smaller than this value, this value may need to be reduced
                          in write-heavy environments where many files in the 1-2 MB range are being
                          flushed, because every StoreFile will be targeted for compaction and the
                          resulting StoreFiles may still be under the minimum size and require
                          further compaction.</para>
                        <para>If this parameter is lowered, the ratio check is triggered more
                          quickly. This addressed some issues seen in earlier versions of HBase but
                          changing this parameter is no longer necessary in most situations.</para>
                      </entry>
                      <entry>128 MB</entry>
                    </row>
                    <row>
                      <entry>hbase.hstore.compaction.max.size</entry>
                      <entry><para>An StoreFile larger than this size will be excluded from
                          compaction. The effect of raising
                            <varname>hbase.hstore.compaction.max.size</varname> is fewer, larger
                          StoreFiles that do not get compacted often. If you feel that compaction is
                          happening too often without much benefit, you can try raising this
                          value.</para></entry>
                      <entry>Long.MAX_VALUE</entry>
                    </row>
                    <row>
                      <entry>hbase.hstore.compaction.ratio</entry>
                      <entry><para>For minor compaction, this ratio is used to determine whether a
                          given StoreFile which is larger than
                            <varname>hbase.hstore.compaction.min.size</varname> is eligible for
                          compaction. Its effect is to limit compaction of large StoreFile. The
                          value of <varname>hbase.hstore.compaction.ratio</varname> is expressed as
                          a floating-point decimal.</para>
                        <para>A large ratio, such as <literal>10</literal>, will produce a
                          single giant StoreFile. Conversely, a value of <literal>.25</literal>,
                          will produce behavior similar to the BigTable compaction algorithm,
                          producing four StoreFiles.</para>
                        <para>A moderate value of between 1.0 and 1.4 is recommended. When
                          tuning this value, you are balancing write costs with read costs. Raising
                          the value (to something like 1.4) will have more write costs, because you
                          will compact larger StoreFiles. However, during reads, HBase will need to seek
                          through fewer StpreFo;es to accomplish the read. Consider this approach if you
                          cannot take advantage of <xref
                            linkend="schema.bloom" />.</para>
                        <para>Alternatively, you can lower this value to something like 1.0 to
                          reduce the background cost of writes, and use <xref
                            linkend="schema.bloom" /> to limit the number of StoreFiles touched
                          during reads.</para>
                        <para>For most cases, the default value is appropriate.</para>
                      </entry>
                      <entry>1.2F</entry>
                    </row>
                    <row>
                      <entry>hbase.hstore.compaction.ratio.offpeak</entry>
                      <entry>The compaction ratio used during off-peak compactions, if off-peak
                        hours are also configured (see below). Expressed as a floating-point
                        decimal. This allows for more aggressive (or less aggressive, if you set it
                        lower than <varname>hbase.hstore.compaction.ratio</varname>) compaction
                        during a set time period. Ignored if off-peak is disabled (default). This
                        works the same as <varname>hbase.hstore.compaction.ratio</varname>.</entry>
                      <entry>5.0F</entry>
                    </row>
                    <row>
                      <entry>hbase.offpeak.start.hour</entry>
                      <entry>The start of off-peak hours, expressed as an integer between 0 and 23,
                        inclusive. Set to <literal>-1</literal> to disable off-peak.</entry>
                      <entry>-1 (disabled)</entry>
                    </row>
                    <row>
                      <entry>hbase.offpeak.end.hour</entry>
                      <entry>The end of off-peak hours, expressed as an integer between 0 and 23,
                        inclusive. Set to <literal>-1</literal> to disable off-peak.</entry>
                      <entry>-1 (disabled)</entry>
                    </row>
                    <row>
                      <entry>hbase.regionserver.thread.compaction.throttle</entry>
                      <entry><para>There are two different thread pools for compactions, one for
                          large compactions and the other for small compactions. This helps to keep
                          compaction of lean tables (such as <systemitem>hbase:meta</systemitem>)
                          fast. If a compaction is larger than this threshold, it goes into the
                          large compaction pool. In most cases, the default value is
                          appropriate.</para></entry>
                      <entry>2 x hbase.hstore.compaction.max x hbase.hregion.memstore.flush.size
                        (which defaults to 128)</entry>
                    </row>
                    <row>
                      <entry>hbase.hregion.majorcompaction</entry>
                      <entry><para>Time between major compactions, expressed in milliseconds. Set to
                          0 to disable time-based automatic major compactions. User-requested and
                          size-based major compactions will still run. This value is multiplied by
                            <varname>hbase.hregion.majorcompaction.jitter</varname> to cause
                          compaction to start at a somewhat-random time during a given window of
                          time.</para></entry>
                      <entry>7 days (604800000 milliseconds)</entry>
                    </row>
                    <row>
                      <entry>hbase.hregion.majorcompaction.jitter</entry>
                      <entry><para>A multiplier applied to
                            <varname>hbase.hregion.majorcompaction</varname> to cause compaction to
                          occur a given amount of time either side of
                            <varname>hbase.hregion.majorcompaction</varname>. The smaller the
                          number, the closer the compactions will happen to the
                            <varname>hbase.hregion.majorcompaction</varname> interval. Expressed as
                          a floating-point decimal.</para></entry>
                      <entry>.50F</entry>
                    </row>
                  </tbody>
                </tgroup>
              </informaltable>
            </section>
          </section>
          <section
            xml:id="compaction.file.selection.old">
            <title>Compaction File Selection</title>
            <note>
              <title>Legacy Information</title>
              <para>This section has been preserved for historical reasons and refers to the way
                compaction worked prior to HBase 0.96.x. You can still use this behavior if you
                enable <xref
                  linkend="compaction.ratiobasedcompactionpolicy.algorithm" /> For information on
                the way that compactions work in HBase 0.96.x and later, see <xref
                  linkend="compaction" />.</para>
            </note>
            <para>To understand the core algorithm for StoreFile selection, there is some ASCII-art
              in the <link
                xlink:href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/regionserver/Store.html#836">Store
                source code</link> that will serve as useful reference. It has been copied below:
              <programlisting>
/* normal skew:
 *
 *         older ----> newer
 *     _
 *    | |   _
 *    | |  | |   _
 *  --|-|- |-|- |-|---_-------_-------  minCompactSize
 *    | |  | |  | |  | |  _  | |
 *    | |  | |  | |  | | | | | |
 *    | |  | |  | |  | | | | | |
 */
</programlisting>
              Important knobs: <itemizedlist>
                <listitem>
                  <para><code>hbase.hstore.compaction.ratio</code> Ratio used in compaction file
                    selection algorithm (default 1.2f).</para>
                </listitem>
                <listitem>
                  <para><code>hbase.hstore.compaction.min</code> (.90
                    hbase.hstore.compactionThreshold) (files) Minimum number of StoreFiles per Store
                    to be selected for a compaction to occur (default 2).</para>
                </listitem>
                <listitem>
                  <para><code>hbase.hstore.compaction.max</code> (files) Maximum number of
                    StoreFiles to compact per minor compaction (default 10).</para>
                </listitem>
                <listitem>
                  <para><code>hbase.hstore.compaction.min.size</code> (bytes) Any StoreFile smaller
                    than this setting with automatically be a candidate for compaction. Defaults to
                      <code>hbase.hregion.memstore.flush.size</code> (128 mb). </para>
                </listitem>
                <listitem>
                  <para><code>hbase.hstore.compaction.max.size</code> (.92) (bytes) Any StoreFile
                    larger than this setting with automatically be excluded from compaction (default
                    Long.MAX_VALUE). </para>
                </listitem>
              </itemizedlist>
            </para>
            <para>The minor compaction StoreFile selection logic is size based, and selects a file
              for compaction when the file &lt;= sum(smaller_files) *
                <code>hbase.hstore.compaction.ratio</code>. </para>

          <section
            xml:id="compaction.file.selection.example1">
            <title>Minor Compaction File Selection - Example #1 (Basic Example)</title>
            <para>This example mirrors an example from the unit test
                <code>TestCompactSelection</code>.</para>
            <itemizedlist>
              <listitem>
                <para><code>hbase.hstore.compaction.ratio</code> = 1.0f </para>
              </listitem>
              <listitem>
                <para><code>hbase.hstore.compaction.min</code> = 3 (files) </para>
              </listitem>
              <listitem>
                <para><code>hbase.hstore.compaction.max</code> = 5 (files) </para>
              </listitem>
              <listitem>
                <para><code>hbase.hstore.compaction.min.size</code> = 10 (bytes) </para>
              </listitem>
              <listitem>
                <para><code>hbase.hstore.compaction.max.size</code> = 1000 (bytes) </para>
              </listitem>
            </itemizedlist>
            <para> The following StoreFiles exist: 100, 50, 23, 12, and 12 bytes apiece (oldest to
              newest). With the above parameters, the files that would be selected for minor
              compaction are 23, 12, and 12. </para>
            <para>Why? <itemizedlist>
                <listitem>
                  <para>100 --&gt; No, because sum(50, 23, 12, 12) * 1.0 = 97. </para>
                </listitem>
                <listitem>
                  <para>50 --&gt; No, because sum(23, 12, 12) * 1.0 = 47. </para>
                </listitem>
                <listitem>
                  <para>23 --&gt; Yes, because sum(12, 12) * 1.0 = 24. </para>
                </listitem>
                <listitem>
                  <para>12 --&gt; Yes, because the previous file has been included, and because this
                    does not exceed the the max-file limit of 5 </para>
                </listitem>
                <listitem>
                  <para>12 --&gt; Yes, because the previous file had been included, and because this
                    does not exceed the the max-file limit of 5.</para>
                </listitem>
              </itemizedlist>
            </para>
          </section>
          <section
            xml:id="compaction.file.selection.example2">
            <title>Minor Compaction File Selection - Example #2 (Not Enough Files To
              Compact)</title>
            <para>This example mirrors an example from the unit test
                <code>TestCompactSelection</code>. <itemizedlist>
                <listitem>
                  <para><code>hbase.hstore.compaction.ratio</code> = 1.0f </para>
                </listitem>
                <listitem>
                  <para><code>hbase.hstore.compaction.min</code> = 3 (files) </para>
                </listitem>
                <listitem>
                  <para><code>hbase.hstore.compaction.max</code> = 5 (files)</para>
                </listitem>
                <listitem>
                  <para><code>hbase.hstore.compaction.min.size</code> = 10 (bytes) </para>
                </listitem>
                <listitem>
                  <para><code>hbase.hstore.compaction.max.size</code> = 1000 (bytes) </para>
                </listitem>
              </itemizedlist>
            </para>
            <para>The following StoreFiles exist: 100, 25, 12, and 12 bytes apiece (oldest to
              newest). With the above parameters, no compaction will be started. </para>
            <para>Why? <itemizedlist>
                <listitem>
                  <para>100 --&gt; No, because sum(25, 12, 12) * 1.0 = 47</para>
                </listitem>
                <listitem>
                  <para>25 --&gt; No, because sum(12, 12) * 1.0 = 24</para>
                </listitem>
                <listitem>
                  <para>12 --&gt; No. Candidate because sum(12) * 1.0 = 12, there are only 2 files
                    to compact and that is less than the threshold of 3</para>
                </listitem>
                <listitem>
                  <para>12 --&gt; No. Candidate because the previous StoreFile was, but there are
                    not enough files to compact</para>
                </listitem>
              </itemizedlist>
            </para>
          </section>
          <section
            xml:id="compaction.file.selection.example3">
            <title>Minor Compaction File Selection - Example #3 (Limiting Files To Compact)</title>
            <para>This example mirrors an example from the unit test
                <code>TestCompactSelection</code>. <itemizedlist>
                <listitem>
                  <para><code>hbase.hstore.compaction.ratio</code> = 1.0f </para>
                </listitem>
                <listitem>
                  <para><code>hbase.hstore.compaction.min</code> = 3 (files) </para>
                </listitem>
                <listitem>
                  <para><code>hbase.hstore.compaction.max</code> = 5 (files)</para>
                </listitem>
                <listitem>
                  <para><code>hbase.hstore.compaction.min.size</code> = 10 (bytes) </para>
                </listitem>
                <listitem>
                  <para><code>hbase.hstore.compaction.max.size</code> = 1000 (bytes) </para>
                </listitem>
              </itemizedlist> The following StoreFiles exist: 7, 6, 5, 4, 3, 2, and 1 bytes apiece
              (oldest to newest). With the above parameters, the files that would be selected for
              minor compaction are 7, 6, 5, 4, 3. </para>
            <para>Why? <itemizedlist>
                <listitem>
                  <para>7 --&gt; Yes, because sum(6, 5, 4, 3, 2, 1) * 1.0 = 21. Also, 7 is less than
                    the min-size</para>
                </listitem>
                <listitem>
                  <para>6 --&gt; Yes, because sum(5, 4, 3, 2, 1) * 1.0 = 15. Also, 6 is less than
                    the min-size. </para>
                </listitem>
                <listitem>
                  <para>5 --&gt; Yes, because sum(4, 3, 2, 1) * 1.0 = 10. Also, 5 is less than the
                    min-size. </para>
                </listitem>
                <listitem>
                  <para>4 --&gt; Yes, because sum(3, 2, 1) * 1.0 = 6. Also, 4 is less than the
                    min-size. </para>
                </listitem>
                <listitem>
                  <para>3 --&gt; Yes, because sum(2, 1) * 1.0 = 3. Also, 3 is less than the
                    min-size. </para>
                </listitem>
                <listitem>
                  <para>2 --&gt; No. Candidate because previous file was selected and 2 is less than
                    the min-size, but the max-number of files to compact has been reached. </para>
                </listitem>
                <listitem>
                  <para>1 --&gt; No. Candidate because previous file was selected and 1 is less than
                    the min-size, but max-number of files to compact has been reached. </para>
                </listitem>
              </itemizedlist>
            </para>
            <section
              xml:id="compaction.config.impact">
              <title>Impact of Key Configuration Options</title>
              <note>
                <para>This information is now included in the configuration parameter table in <xref
                    linkend="compaction.configuration.parameters" />.</para>
              </note>
            </section>
          </section>
          </section>
          <section
            xml:id="ops.stripe">
            <title>Experimental: Stripe Compactions</title>
            <para> Stripe compactions is an experimental feature added in HBase 0.98 which aims to
              improve compactions for large regions or non-uniformly distributed row keys. In order
              to achieve smaller and/or more granular compactions, the StoreFiles within a region
              are maintained separately for several row-key sub-ranges, or "stripes", of the region.
              The stripes are transparent to the rest of HBase, so other operations on the HFiles or
              data work without modification.</para>
            <para>Stripe compactions change the HFile layout, creating sub-regions within regions.
              These sub-regions are easier to compact, and should result in fewer major compactions.
              This approach alleviates some of the challenges of larger regions.</para>
            <para>Stripe compaction is fully compatible with <xref
                linkend="compaction" /> and works in conjunction with either the
              ExploringCompactionPolicy or RatioBasedCompactionPolicy. It can be enabled for
              existing tables, and the table will continue to operate normally if it is disabled
              later. </para>
          </section>
          <section
            xml:id="ops.stripe.when">
            <title>When To Use Stripe Compactions</title>
            <para>Consider using stripe compaction if you have either of the following:</para>
            <itemizedlist>
              <listitem>
                <para>Large regions. You can get the positive effects of smaller regions without
                  additional overhead for MemStore and region management overhead.</para>
              </listitem>
              <listitem>
                <para>Non-uniform keys, such as time dimension in a key. Only the stripes receiving
                  the new keys will need to compact. Old data will not compact as often, if at
                  all</para>
              </listitem>
            </itemizedlist>
            <formalpara>
              <title>Performance Improvements</title>
              <para>Performance testing has shown that the performance of reads improves somewhat,
                and variability of performance of reads and writes is greatly reduced. An overall
                long-term performance improvement is seen on large non-uniform-row key regions, such
                as a hash-prefixed timestamp key. These performance gains are the most dramatic on a
                table which is already large. It is possible that the performance improvement might
                extend to region splits.</para>
            </formalpara>
            <section
              xml:id="ops.stripe.enable">
              <title>Enabling Stripe Compaction</title>
              <para>You can enable stripe compaction for a table or a column family, by setting its
                  <varname>hbase.hstore.engine.class</varname> to
                  <varname>org.apache.hadoop.hbase.regionserver.StripeStoreEngine</varname>. You
                also need to set the <varname>hbase.hstore.blockingStoreFiles</varname> to a high
                number, such as 100 (rather than the default value of 10).</para>
              <procedure>
                <title>Enable Stripe Compaction</title>
                <step>
                  <para>If the table already exists, disable the table.</para>
                </step>
                <step>
                  <para>Run one of following commands in the HBase shell. Replace the table name
                      <literal>orders_table</literal> with the name of your table.</para>
                  <screen language="sql">
<userinput>alter 'orders_table', CONFIGURATION => {'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.StripeStoreEngine', 'hbase.hstore.blockingStoreFiles' => '100'}</userinput>
<userinput>alter 'orders_table', {NAME => 'blobs_cf', CONFIGURATION => {'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.StripeStoreEngine', 'hbase.hstore.blockingStoreFiles' => '100'}}</userinput>
<userinput>create 'orders_table', 'blobs_cf', CONFIGURATION => {'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.StripeStoreEngine', 'hbase.hstore.blockingStoreFiles' => '100'}</userinput>                  
                </screen>
                </step>
                <step>
                  <para>Configure other options if needed. See <xref
                      linkend="ops.stripe.config" /> for more information.</para>
                </step>
                <step>
                  <para>Enable the table.</para>
                </step>
              </procedure>

              <procedure>
                <title>Disable Stripe Compaction</title>
                <step>
                  <para>Disable the table.</para>
                </step>
                <step>
                  <para>Set the <varname>hbase.hstore.engine.class</varname> option to either nil or
                      <literal>org.apache.hadoop.hbase.regionserver.DefaultStoreEngine</literal>.
                    Either option has the same effect.</para>
                  <screen language="sql">
<userinput>alter 'orders_table', CONFIGURATION => {'hbase.hstore.engine.class' => ''}</userinput>
                </screen>
                </step>
                <step>
                  <para>Enable the table.</para>
                </step>
              </procedure>
              <para> When you enable a large table after changing the store engine either way, a
                major compaction will likely be performed on most regions. This is not necessary on
                new tables.</para>
            </section>
            <section
              xml:id="ops.stripe.config">
              <title>Configuring Stripe Compaction</title>
              <para>Each of the settings for stripe compaction should be configured at the table or
                column family, after disabling the table. If you use HBase shell, the general
                command pattern is as follows:</para>

              <programlisting language="sql">
alter 'orders_table', CONFIGURATION => {'key' => 'value', ..., 'key' => 'value'}}
              </programlisting>
              <section
                xml:id="ops.stripe.config.sizing">
                <title>Region and stripe sizing</title>
                <para>You can configure your stripe sizing bsaed upon your region sizing. By
                  default, your new regions will start with one stripe. On the next compaction after
                  the stripe has grown too large (16 x MemStore flushes size), it is split into two
                  stripes. Stripe splitting continues as the region grows, until the region is large
                  enough to split.</para>
                <para>You can improve this pattern for your own data. A good rule is to aim for a
                  stripe size of at least 1 GB, and about 8-12 stripes for uniform row keys. For
                  example, if your regions are 30 GB, 12 x 2.5 GB stripes might be a good starting
                  point.</para>

                <table
                  frame="all">
                  <title>Stripe Sizing Settings</title>
                  <tgroup
                    cols="2"
                    align="left"
                    colsep="1"
                    rowsep="1">
                    <colspec
                      colname="c1" />
                    <colspec
                      colname="c2" />
                    <thead>
                      <row>
                        <entry>Setting</entry>
                        <entry>Notes</entry>
                      </row>
                    </thead>
                    <tbody>
                      <row>
                        <entry>
                          <varname>hbase.store.stripe.initialStripeCount</varname>
                        </entry>
                        <entry>
                          <para>The number of stripes to create when stripe compaction is enabled.
                            You can use it as follows: </para><itemizedlist>
                            <listitem>
                              <para>For relatively uniform row keys, if you know the approximate
                                target number of stripes from the above, you can avoid some
                                splitting overhead by starting with several stripes (2, 5, 10...).
                                If the early data is not representative of overall row key
                                distribution, this will not be as efficient.</para>
                            </listitem>
                            <listitem>
                              <para>For existing tables with a large amount of data, this setting
                                will effectively pre-split your stripes.</para>
                            </listitem>
                            <listitem>
                              <para>For keys such as hash-prefixed sequential keys, with more than
                                one hash prefix per region, pre-splitting may make sense. </para>
                            </listitem>
                          </itemizedlist>
                        </entry>
                      </row>
                      <row>
                        <entry>
                          <varname>hbase.store.stripe.sizeToSplit</varname>
                        </entry>
                        <entry>The maximum size a stripe grows before splitting. Use this in
                          conjunction with <varname>hbase.store.stripe.splitPartCount</varname> to
                          control the target stripe size (sizeToSplit = splitPartsCount * target
                          stripe size), according to the above sizing considerations. </entry>
                      </row>
                      <row>
                        <entry>
                          <varname>hbase.store.stripe.splitPartCount</varname>
                        </entry>
                        <entry>The number of new stripes to create when splitting a stripe. The
                          default is 2, which is appropriate for most cases. For non-uniform row
                          keys, you can experiment with increasing the number to 3 or 4, to isolate
                          the arriving updates into narrower slice of the region without additional
                          splits being required.</entry>
                      </row>
                    </tbody>
                  </tgroup>
                </table>
              </section>
              <section
                xml:id="ops.stripe.config.memstore">
                <title>MemStore Size Settings</title>
                <para> By default, the flush creates several files from one MemStore, according to
                  existing stripe boundaries and row keys to flush. This approach minimizes write
                  amplification, but can be undesirable if the MemStore is small and there are many
                  stripes, because the files will be too small. </para>
                <para>In this type of situation, you can set
                    <varname>hbase.store.stripe.compaction.flushToL0</varname> to
                    <literal>true</literal>. This will cause a MemStore flush to create a single
                  file instead. When at least
                    <varname>hbase.store.stripe.compaction.minFilesL0</varname> such files (by
                  default, 4) accumulate, they will be compacted into striped files.</para>
              </section>
              <section
                xml:id="ops.stripe.config.compact">
                <title>Normal Compaction Configuration and Stripe Compaction</title>
                <para> All the settings that apply to normal compactions (see <xref
                    linkend="compaction.configuration.parameters" />) apply to stripe compactions.
                  The exceptions are the minimum and maximum number of files, which are set to
                  higher values by default because the files in stripes are smaller. To control
                  these for stripe compactions, use
                    <varname>hbase.store.stripe.compaction.minFiles</varname> and
                    <varname>hbase.store.stripe.compaction.maxFiles</varname>, rather than
                    <varname>hbase.hstore.compaction.min</varname> and
                    <varname>hbase.hstore.compaction.max</varname>. </para>
              </section>
            </section>
          </section>
        </section>  <!--  compaction -->

     </section>  <!--  store -->

    </section>  <!--  regions -->

	<section xml:id="arch.bulk.load"><title>Bulk Loading</title>
      <section xml:id="arch.bulk.load.overview"><title>Overview</title>
      <para>
        HBase includes several methods of loading data into tables.
        The most straightforward method is to either use the <code>TableOutputFormat</code>
        class from a MapReduce job, or use the normal client APIs; however,
        these are not always the most efficient methods.
      </para>
      <para>
        The bulk load feature uses a MapReduce job to output table data in HBase's internal
        data format, and then directly loads the generated StoreFiles into a running
        cluster. Using bulk load will use less CPU and network resources than
        simply using the HBase API.
      </para>
    </section>
    <section xml:id="arch.bulk.load.limitations"><title>Bulk Load Limitations</title>
        <para>As bulk loading bypasses the write path, the WAL doesn’t get written to as part of the process.
            Replication works by reading the WAL files so it won’t see the bulk loaded data – and the same goes for the edits that use Put.setWriteToWAL(true).
            One way to handle that is to ship the raw files or the HFiles to the other cluster and do the other processing there.</para>
    </section>
    <section xml:id="arch.bulk.load.arch"><title>Bulk Load Architecture</title>
      <para>
        The HBase bulk load process consists of two main steps.
      </para>
      <section xml:id="arch.bulk.load.prep"><title>Preparing data via a MapReduce job</title>
        <para>
          The first step of a bulk load is to generate HBase data files (StoreFiles) from
          a MapReduce job using <code>HFileOutputFormat</code>. This output format writes
          out data in HBase's internal storage format so that they can be
          later loaded very efficiently into the cluster.
        </para>
        <para>
          In order to function efficiently, <code>HFileOutputFormat</code> must be
          configured such that each output HFile fits within a single region.
          In order to do this, jobs whose output will be bulk loaded into HBase
          use Hadoop's <code>TotalOrderPartitioner</code> class to partition the map output
          into disjoint ranges of the key space, corresponding to the key
          ranges of the regions in the table.
        </para>
        <para>
          <code>HFileOutputFormat</code> includes a convenience function,
          <code>configureIncrementalLoad()</code>, which automatically sets up
          a <code>TotalOrderPartitioner</code> based on the current region boundaries of a
          table.
        </para>
      </section>
      <section xml:id="arch.bulk.load.complete"><title>Completing the data load</title>
        <para>
          After the data has been prepared using
          <code>HFileOutputFormat</code>, it is loaded into the cluster using
          <code>completebulkload</code>. This command line tool iterates
          through the prepared data files, and for each one determines the
          region the file belongs to. It then contacts the appropriate Region
          Server which adopts the HFile, moving it into its storage directory
          and making the data available to clients.
        </para>
        <para>
          If the region boundaries have changed during the course of bulk load
          preparation, or between the preparation and completion steps, the
          <code>completebulkloads</code> utility will automatically split the
          data files into pieces corresponding to the new boundaries. This
          process is not optimally efficient, so users should take care to
          minimize the delay between preparing a bulk load and importing it
          into the cluster, especially if other clients are simultaneously
          loading data through other means.
        </para>
      </section>
    </section>
    <section xml:id="arch.bulk.load.import"><title>Importing the prepared data using the completebulkload tool</title>
      <para>
        After a data import has been prepared, either by using the
        <code>importtsv</code> tool with the
        "<code>importtsv.bulk.output</code>" option or by some other MapReduce
        job using the <code>HFileOutputFormat</code>, the
        <code>completebulkload</code> tool is used to import the data into the
        running cluster.
      </para>
      <para>
        The <code>completebulkload</code> tool simply takes the output path
        where <code>importtsv</code> or your MapReduce job put its results, and
        the table name to import into. For example:
      </para>
      <screen language="bourne">$ hadoop jar hbase-server-VERSION.jar completebulkload [-c /path/to/hbase/config/hbase-site.xml] /user/todd/myoutput mytable</screen>
      <para>
        The <code>-c config-file</code> option can be used to specify a file
        containing the appropriate hbase parameters (e.g., hbase-site.xml) if
        not supplied already on the CLASSPATH (In addition, the CLASSPATH must
        contain the directory that has the zookeeper configuration file if
        zookeeper is NOT managed by HBase).
      </para>
      <para>
        Note: If the target table does not already exist in HBase, this
        tool will create the table automatically.</para>
      <para>
        This tool will run quickly, after which point the new data will be visible in
        the cluster.
      </para>
    </section>
    <section xml:id="arch.bulk.load.also"><title>See Also</title>
      <para>For more information about the referenced utilities, see <xref linkend="importtsv"/> and  <xref linkend="completebulkload"/>.
      </para>
      <para>
          See <link xlink:href="http://blog.cloudera.com/blog/2013/09/how-to-use-hbase-bulk-loading-and-why/">How-to: Use HBase Bulk Loading, and Why</link>
          for a recent blog on current state of bulk loading.
      </para>
    </section>
    <section xml:id="arch.bulk.load.adv"><title>Advanced Usage</title>
      <para>
        Although the <code>importtsv</code> tool is useful in many cases, advanced users may
        want to generate data programatically, or import data from other formats. To get
        started doing so, dig into <code>ImportTsv.java</code> and check the JavaDoc for
        HFileOutputFormat.
      </para>
      <para>
        The import step of the bulk load can also be done programatically. See the
        <code>LoadIncrementalHFiles</code> class for more information.
      </para>
    </section>
	</section>  <!--  bulk loading -->

    <section xml:id="arch.hdfs"><title>HDFS</title>
       <para>As HBase runs on HDFS (and each StoreFile is written as a file on HDFS),
        it is important to have an understanding of the HDFS Architecture
         especially in terms of how it stores files, handles failovers, and replicates blocks.
       </para>
       <para>See the Hadoop documentation on <link xlink:href="http://hadoop.apache.org/common/docs/current/hdfs_design.html">HDFS Architecture</link>
       for more information.
       </para>
       <section xml:id="arch.hdfs.nn"><title>NameNode</title>
         <para>The NameNode is responsible for maintaining the filesystem metadata.  See the above HDFS Architecture link
         for more information.
         </para>
       </section>
       <section xml:id="arch.hdfs.dn"><title>DataNode</title>
         <para>The DataNodes are responsible for storing HDFS blocks.  See the above HDFS Architecture link
         for more information.
         </para>
       </section>
    </section>

		<section xml:id="arch.timelineconsistent.reads">
	      <title>Timeline-consistent High Available Reads</title>
			<section xml:id="casestudies.timelineconsistent.intro">
		      <title>Introduction</title>
		      <para> 
			HBase, architecturally, always had the strong consistency guarantee from the start. All reads and writes are routed through a single region server, which guarantees that all writes happen in an order, and all reads are seeing the most recent committed data. 
	          </para><para>
			However, because of this single homing of the reads to a single location, if the server becomes unavailable, the regions of the table that were hosted in the region server become unavailable for some time. There are three phases in the region recovery process - detection, assignment, and recovery. Of these, the detection is usually the longest and is presently in the order of 20-30 seconds depending on the zookeeper session timeout. During this time and before the recovery is complete, the clients will not be able to read the region data.
	          </para><para>
			However, for some use cases, either the data may be read-only, or doing reads againsts some stale data is acceptable. With timeline-consistent high available reads, HBase can be used for these kind of latency-sensitive use cases where the application can expect to have a time bound on the read completion. 
	          </para><para>
			For achieving high availability for reads, HBase provides a feature called “region replication”. In this model, for each region of a table, there will be multiple replicas that are opened in different region servers. By default, the region replication is set to 1, so only a single region replica is deployed and there will not be any changes from the original model. If region replication is set to 2 or more, than the master will assign replicas of the regions of the table. The Load Balancer ensures that the region replicas are not co-hosted in the same region servers and also in the same rack (if possible). 
	          </para><para>
			All of the replicas for a single region will have a unique replica_id, starting from 0. The region replica having replica_id==0 is called the primary region, and the others “secondary regions” or secondaries. Only the primary can accept writes from the client, and the primary will always contain the latest changes. Since all writes still have to go through the primary region, the writes are not highly-available (meaning they might block for some time if the region becomes unavailable). 
	          </para><para>
			The writes are asynchronously sent to the secondary region replicas using an “Async WAL replication” feature. This works similarly to HBase’s multi-datacenter replication, but instead the data from a region is replicated to the secondary regions. Each secondary replica always receives and observes the writes in the same order that the primary region committed them. This ensures that the secondaries won’t diverge from the primary regions data, but since the log replication is asnyc, the data might be stale in secondary regions. In some sense, this design can be thought of as “in-cluster replication”, where instead of replicating to a different datacenter, the data goes to a secondary region to keep secondary region’s in-memory state up to date. The data files are shared between the primary region and the other replicas, so that there is no extra storage overhead. However, the secondary regions will have recent non-flushed data in their memstores, which increases the memory overhead. 
	         </para><para>
	Async WAL replication feature is being implemented in Phase 2 of issue HBASE-10070. Before this, region replicas will only be updated with flushed data files from the primary (see hbase.regionserver.storefile.refresh.period below). It is also possible to use this without setting storefile.refresh.period for read only tables. 
		     </para>
	       </section>
	       <section>
	       <title>Timeline Consistency </title>
	         <para>
			With this feature, HBase introduces a Consistency definition, which can be provided per read operation (get or scan).
	<programlisting language="java">
public enum Consistency {
    STRONG,
    TIMELINE
}
	</programlisting>
			<code>Consistency.STRONG</code> is the default consistency model provided by HBase. In case the table has region replication = 1, or in a table with region replicas but the reads are done with this consistency, the read is always performed by the primary regions, so that there will not be any change from the previous behaviour, and the client always observes the latest data. 
	          </para><para>
			In case a read is performed with <code>Consistency.TIMELINE</code>, then the read RPC will be sent to the primary region server first. After a short interval (<code>hbase.client.primaryCallTimeout.get</code>, 10ms by default), parallel RPC for secondary region replicas will also be sent if the primary does not respond back. After this, the result is returned from whichever RPC is finished first. If the response came back from the primary region replica, we can always know that the data is latest. For this Result.isStale() API has been added to inspect the staleness. If the result is from a secondary region, then Result.isStale() will be set to true. The user can then inspect this field to possibly reason about the data. 
	          </para><para>
			In terms of semantics, TIMELINE consistency as implemented by HBase differs from pure eventual
			consistency in these respects: </para>
			  <itemizedlist>
            <listitem>
              <para> Single homed and ordered updates: Region replication or not, on the write side,
                there is still only 1 defined replica (primary) which can accept writes. This
                replica is responsible for ordering the edits and preventing conflicts. This
                guarantees that two different writes are not committed at the same time by different
                replicas and the data diverges. With this, there is no need to do read-repair or
                last-timestamp-wins kind of conflict resolution. </para>
            </listitem>
            <listitem>
              <para> The secondaries also apply the edits in the order that the primary committed
                them. This way the secondaries will contain a snapshot of the primaries data at any
                point in time. This is similar to RDBMS replications and even HBase’s own
                multi-datacenter replication, however in a single cluster. </para>
            </listitem>
            <listitem>
              <para> On the read side, the client can detect whether the read is coming from
                up-to-date data or is stale data. Also, the client can issue reads with different
                consistency requirements on a per-operation basis to ensure its own semantic
                guarantees. </para>
            </listitem>
            <listitem>
              <para> The client can still observe edits out-of-order, and can go back in time, if it
                observes reads from one secondary replica first, then another secondary replica.
                There is no stickiness to region replicas or a transaction-id based guarantee. If
                required, this can be implemented later though. </para>
            </listitem>
          </itemizedlist>

        <figure>
          <title>HFile Version 1</title>
          <mediaobject>
            <imageobject>
              <imagedata
                align="center"
                valign="middle"
                fileref="timeline_consistency.png" />
            </imageobject>
            <textobject>
              <phrase>HFile Version 1</phrase>
            </textobject>
          </mediaobject>
        </figure>
		<para>
			To better understand the TIMELINE semantics, lets look at the above diagram. Lets say that there are two clients, and the first one writes x=1 at first, then x=2 and x=3 later. As above, all writes are handled by the primary region replica. The writes are saved in the write ahead log (WAL), and replicated to the other replicas asynchronously. In the above diagram, notice that replica_id=1 received 2 updates, and it’s data shows that x=2, while the replica_id=2 only received a single update, and its data shows that x=1. 
		</para><para>
			If client1 reads with STRONG consistency, it will only talk with the replica_id=0, and thus is guaranteed to observe the latest value of x=3. In case of a client issuing TIMELINE consistency reads, the RPC will go to all replicas (after primary timeout) and the result from the first response will be returned back. Thus the client can see either 1, 2 or 3 as the value of x. Let’s say that the primary region has failed and log replication cannot continue for some time. If the client does multiple reads with TIMELINE consistency, she can observe x=2 first, then x=1, and so on. 

		</para>
	</section>
	<section>
		<title>Tradeoffs</title>
        <para> Having secondary regions hosted for read availability comes with some tradeoffs which
          should be carefully evaluated per use case. Following are advantages and
          disadvantages.</para>
        <itemizedlist>
          <title>Advantages</title>
          <listitem>
            <para>High availability for read-only tables.</para>
          </listitem>
          <listitem>
            <para>High availability for stale reads</para>
          </listitem>
          <listitem>
            <para>Ability to do very low latency reads with very high percentile (99.9%+) latencies
              for stale reads</para>
          </listitem>
        </itemizedlist>

        <itemizedlist>
          <title>Disadvantages</title>
          <listitem>
            <para>Double / Triple memstore usage (depending on region replication count) for tables
              with region replication &gt; 1</para>
          </listitem>
          <listitem>
            <para>Increased block cache usage</para>
          </listitem>
          <listitem>
            <para>Extra network traffic for log replication </para>
          </listitem>
          <listitem>
            <para>Extra backup RPCs for replicas</para>
          </listitem>
        </itemizedlist>
        <para>To serve the region data from multiple replicas, HBase opens the regions in secondary
          mode in the region servers. The regions opened in secondary mode will share the same data
          files with the primary region replica, however each secondary region replica will have its
          own memstore to keep the unflushed data (only primary region can do flushes). Also to
          serve reads from secondary regions, the blocks of data files may be also cached in the
          block caches for the secondary regions. </para>
		</section>
		<section>
			<title>Configuration properties</title>
			<para>
	To use highly available reads, you should set the following properties in hbase-site.xml file. There is no specific configuration to enable or disable region replicas. Instead you can change the number of region replicas per table to increase or decrease at the table creation or with alter table. 
		</para>
		<section>
			<title>Server side properties</title>
			<programlisting language="xml"><![CDATA[
<property>
    <name>hbase.regionserver.storefile.refresh.period</name>
    <value>0</value>
    <description>
      The period (in milliseconds) for refreshing the store files for the secondary regions. 0 means this feature is disabled. Secondary regions sees new files (from flushes and compactions) from primary once the secondary region refreshes the list of files in the region. But too frequent refreshes might cause extra Namenode pressure. If the files cannot be refreshed for longer than HFile TTL (hbase.master.hfilecleaner.ttl) the requests are rejected. Configuring HFile TTL to a larger value is also recommended with this setting.
    </description>
</property>
]]></programlisting>

          <para> One thing to keep in mind also is that, region replica placement policy is only
            enforced by the <code>StochasticLoadBalancer</code> which is the default balancer. If
            you are using a custom load balancer property in hbase-site.xml
              (<code>hbase.master.loadbalancer.class</code>) replicas of regions might end up being
            hosted in the same server.</para>
			</section>
			<section>
				<title>Client side properties</title>
          <para> Ensure to set the following for all clients (and servers) that will use region
            replicas. </para>			
			  <programlisting language="xml"><![CDATA[
<property>
    <name>hbase.ipc.client.allowsInterrupt</name>
    <value>true</value>
    <description>
      Whether to enable interruption of RPC threads at the client side. This is required for region replicas with fallback RPC’s to secondary regions.
    </description>
</property>
<property>
    <name>hbase.client.primaryCallTimeout.get</name>
    <value>10000</value>
    <description>
      The timeout (in microseconds), before secondary fallback RPC’s are submitted for get requests with Consistency.TIMELINE to the secondary replicas of the regions. Defaults to 10ms. Setting this lower will increase the number of RPC’s, but will lower the p99 latencies. 
    </description>
</property>
<property>
    <name>hbase.client.primaryCallTimeout.multiget</name>
    <value>10000</value>
    <description>
      The timeout (in microseconds), before secondary fallback RPC’s are submitted for multi-get requests (HTable.get(List<Get>)) with Consistency.TIMELINE to the secondary replicas of the regions. Defaults to 10ms. Setting this lower will increase the number of RPC’s, but will lower the p99 latencies. 
    </description>
</property>
<property>
    <name>hbase.client.replicaCallTimeout.scan</name>
    <value>1000000</value>
    <description>
      The timeout (in microseconds), before secondary fallback RPC’s are submitted for scan requests with Consistency.TIMELINE to the secondary replicas of the regions. Defaults to 1 sec. Setting this lower will increase the number of RPC’s, but will lower the p99 latencies. 
    </description>
</property>
]]></programlisting>

	</section>
	</section>
	<section>
		<title>Creating a table with region replication</title>
		<para>
		Region replication is a per-table property. All tables have REGION_REPLICATION = 1 by default, which means that there is only one replica per region. You can set and change the number of replicas per region of a table by supplying the REGION_REPLICATION property in the table descriptor. 
	    </para>
	<section><title>Shell</title>
	<programlisting><![CDATA[
create 't1', 'f1', {REGION_REPLICATION => 2}

describe 't1'
for i in 1..100
put 't1', "r#{i}", 'f1:c1', i
end
flush 't1'
]]></programlisting>

	</section>
	<section><title>Java</title>
	<programlisting language="java"><![CDATA[
HTableDescriptor htd = new HTableDesctiptor(TableName.valueOf(“test_table”)); 
htd.setRegionReplication(2);
...
admin.createTable(htd); 
]]></programlisting>

          <para>You can also use <code>setRegionReplication()</code> and alter table to increase, decrease the
            region replication for a table.</para> 
	</section>
	</section>
	<section>
		<title>Region splits and merges</title>
        <para>Region splits and merges are not compatible with regions with replicas yet. So you
          have to pre-split the table, and disable the region splits. Also you should not execute
          region merges on tables with region replicas. To disable region splits you can use
          DisabledRegionSplitPolicy as the split policy.</para>
	</section>
	<section>
		<title>User Interface</title>
        <para> In the masters user interface, the region replicas of a table are also shown together
          with the primary regions. You can notice that the replicas of a region will share the same
          start and end keys and the same region name prefix. The only difference would be the
          appended replica_id (which is encoded as hex), and the region encoded name will be
          different. You can also see the replica ids shown explicitly in the UI. </para>	
	</section>
			<section>
				<title>API and Usage</title>
				<section>
					<title>Shell</title>
          <para> You can do reads in shell using a the Consistency.TIMELINE semantics as follows
          </para>	
				  <programlisting><![CDATA[
hbase(main):001:0> get 't1','r6', {CONSISTENCY => "TIMELINE"}
]]></programlisting>
          <para> You can simulate a region server pausing or becoming unavailable and do a read from
            the secondary replica: </para>	
				  <programlisting language="bourne"><![CDATA[
$ kill -STOP <pid or primary region server>

hbase(main):001:0> get 't1','r6', {CONSISTENCY => "TIMELINE"}
]]></programlisting>
          <para> Using scans is also similar </para>	
				  <programlisting><![CDATA[
hbase> scan 't1', {CONSISTENCY => 'TIMELINE'}
]]></programlisting>
		</section>
		<section>
			<title>Java</title>
          <para>You can set set the consistency for Gets and Scans and do requests as
            follows.</para> 
	<programlisting language="java"><![CDATA[
Get get = new Get(row);
get.setConsistency(Consistency.TIMELINE);
...
Result result = table.get(get); 
]]></programlisting>
          <para>You can also pass multiple gets: </para>
	<programlisting language="java"><![CDATA[
Get get1 = new Get(row);
get1.setConsistency(Consistency.TIMELINE);
...
ArrayList<Get> gets = new ArrayList<Get>();
gets.add(get1);
...
Result[] results = table.get(gets); 
]]></programlisting>
          <para>And Scans: </para>
	<programlisting language="java"><![CDATA[
Scan scan = new Scan();
scan.setConsistency(Consistency.TIMELINE);
...
ResultScanner scanner = table.getScanner(scan);
]]></programlisting>
          <para>You can inspect whether the results are coming from primary region or not by calling
            the Result.isStale() method: </para>

	<programlisting language="java"><![CDATA[
Result result = table.get(get); 
if (result.isStale()) {
  ...
}
]]></programlisting>
		</section>
	</section>

	<section>
		<title>Resources</title>
        <orderedlist>
          <listitem>
            <para>More information about the design and implementation can be found at the jira
              issue: <link
                xlink:href="https://issues.apache.org/jira/browse/HBASE-10070">HBASE-10070</link></para>
          </listitem>

          <listitem>
            <para>HBaseCon 2014 <link
                xlink:href="http://hbasecon.com/sessions/#session15">talk</link> also contains some
              details and <link
                xlink:href="http://www.slideshare.net/enissoz/hbase-high-availability-for-reads-with-time">slides</link>.</para>
          </listitem>
        </orderedlist>
	    </section>
	</section>

  
</chapter>
