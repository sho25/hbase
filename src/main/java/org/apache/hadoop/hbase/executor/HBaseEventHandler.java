begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2010 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|HBaseExecutorService
operator|.
name|HBaseExecutorServiceType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|ServerManager
import|;
end_import

begin_comment
comment|/**  * Abstract base class for all HBase event handlers. Subclasses should   * implement the process() method where the actual handling of the event   * happens.  *   * HBaseEventType is a list of ALL events (which also corresponds to messages -   * either internal to one component or between components). The event type   * names specify the component from which the event originated, and the   * component which is supposed to handle it.  *   * Listeners can listen to all the events by implementing the interface   * HBaseEventHandlerListener, and by registering themselves as a listener. They   * will be called back before and after the process of every event.  *   * TODO: Rename HBaseEvent and HBaseEventType to EventHandler and EventType   * after ZK refactor as it currently would clash with EventType from ZK and   * make the code very confusing.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|HBaseEventHandler
implements|implements
name|Runnable
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HBaseEventHandler
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// type of event this object represents
specifier|protected
name|HBaseEventType
name|eventType
init|=
name|HBaseEventType
operator|.
name|NONE
decl_stmt|;
comment|// is this a region server or master?
specifier|protected
name|boolean
name|isRegionServer
decl_stmt|;
comment|// name of the server - this is needed for naming executors in case of tests
comment|// where region servers may be co-located.
specifier|protected
name|String
name|serverName
decl_stmt|;
comment|// listeners that are called before and after an event is processed
specifier|protected
specifier|static
name|List
argument_list|<
name|HBaseEventHandlerListener
argument_list|>
name|eventHandlerListeners
init|=
name|Collections
operator|.
name|synchronizedList
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|HBaseEventHandlerListener
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * This interface provides hooks to listen to various events received by the     * queue. A class implementing this can listen to the updates by calling     * registerListener and stop receiving updates by calling unregisterListener    */
specifier|public
interface|interface
name|HBaseEventHandlerListener
block|{
comment|/**      * Called before any event is processed      */
specifier|public
name|void
name|beforeProcess
parameter_list|(
name|HBaseEventHandler
name|event
parameter_list|)
function_decl|;
comment|/**      * Called after any event is processed      */
specifier|public
name|void
name|afterProcess
parameter_list|(
name|HBaseEventHandler
name|event
parameter_list|)
function_decl|;
block|}
comment|/**    * These are a list of HBase events that can be handled by the various    * HBaseExecutorService's. All the events are serialized as byte values.    */
specifier|public
enum|enum
name|HBaseEventType
block|{
name|NONE
argument_list|(
operator|-
literal|1
argument_list|)
block|,
comment|// Messages originating from RS (NOTE: there is NO direct communication from
comment|// RS to Master). These are a result of RS updates into ZK.
name|RS2ZK_REGION_CLOSING
argument_list|(
literal|1
argument_list|)
block|,
comment|// RS is in process of closing a region
name|RS2ZK_REGION_CLOSED
argument_list|(
literal|2
argument_list|)
block|,
comment|// RS has finished closing a region
name|RS2ZK_REGION_OPENING
argument_list|(
literal|3
argument_list|)
block|,
comment|// RS is in process of opening a region
name|RS2ZK_REGION_OPENED
argument_list|(
literal|4
argument_list|)
block|,
comment|// RS has finished opening a region
comment|// Updates from master to ZK. This is done by the master and there is
comment|// nothing to process by either Master or RS
name|M2ZK_REGION_OFFLINE
argument_list|(
literal|50
argument_list|)
block|;
comment|// Master adds this region as offline in ZK
specifier|private
specifier|final
name|byte
name|value
decl_stmt|;
comment|/**      * Called by the HMaster. Returns a name of the executor service given an       * event type. Every event type has en entry - if the event should not be       * handled just add the NONE executor.      * @return name of the executor service      */
specifier|public
name|HBaseExecutorServiceType
name|getMasterExecutorForEvent
parameter_list|()
block|{
name|HBaseExecutorServiceType
name|executorServiceType
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|this
condition|)
block|{
case|case
name|RS2ZK_REGION_CLOSING
case|:
case|case
name|RS2ZK_REGION_CLOSED
case|:
name|executorServiceType
operator|=
name|HBaseExecutorServiceType
operator|.
name|MASTER_CLOSEREGION
expr_stmt|;
break|break;
case|case
name|RS2ZK_REGION_OPENING
case|:
case|case
name|RS2ZK_REGION_OPENED
case|:
name|executorServiceType
operator|=
name|HBaseExecutorServiceType
operator|.
name|MASTER_OPENREGION
expr_stmt|;
break|break;
case|case
name|M2ZK_REGION_OFFLINE
case|:
name|executorServiceType
operator|=
name|HBaseExecutorServiceType
operator|.
name|NONE
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unhandled event type in the master."
argument_list|)
throw|;
block|}
return|return
name|executorServiceType
return|;
block|}
comment|/**      * Called by the RegionServer. Returns a name of the executor service given an       * event type. Every event type has en entry - if the event should not be       * handled just return a null executor name.      * @return name of the event service      */
specifier|public
specifier|static
name|String
name|getRSExecutorForEvent
parameter_list|(
name|String
name|serverName
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unsupported operation."
argument_list|)
throw|;
block|}
comment|/**      * Start the executor service that handles the passed in event type. The       * server that starts these event executor services wants to handle these       * event types.      */
specifier|public
name|void
name|startMasterExecutorService
parameter_list|(
name|String
name|serverName
parameter_list|)
block|{
name|HBaseExecutorServiceType
name|serviceType
init|=
name|getMasterExecutorForEvent
argument_list|()
decl_stmt|;
if|if
condition|(
name|serviceType
operator|==
name|HBaseExecutorServiceType
operator|.
name|NONE
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Event type "
operator|+
name|toString
argument_list|()
operator|+
literal|" not handled on master."
argument_list|)
throw|;
block|}
name|serviceType
operator|.
name|startExecutorService
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|startRSExecutorService
parameter_list|()
block|{            }
name|HBaseEventType
parameter_list|(
name|int
name|intValue
parameter_list|)
block|{
name|this
operator|.
name|value
operator|=
operator|(
name|byte
operator|)
name|intValue
expr_stmt|;
block|}
specifier|public
name|byte
name|getByteValue
parameter_list|()
block|{
return|return
name|value
return|;
block|}
specifier|public
specifier|static
name|HBaseEventType
name|fromByte
parameter_list|(
name|byte
name|value
parameter_list|)
block|{
switch|switch
condition|(
name|value
condition|)
block|{
case|case
operator|-
literal|1
case|:
return|return
name|HBaseEventType
operator|.
name|NONE
return|;
case|case
literal|1
case|:
return|return
name|HBaseEventType
operator|.
name|RS2ZK_REGION_CLOSING
return|;
case|case
literal|2
case|:
return|return
name|HBaseEventType
operator|.
name|RS2ZK_REGION_CLOSED
return|;
case|case
literal|3
case|:
return|return
name|HBaseEventType
operator|.
name|RS2ZK_REGION_OPENING
return|;
case|case
literal|4
case|:
return|return
name|HBaseEventType
operator|.
name|RS2ZK_REGION_OPENED
return|;
case|case
literal|50
case|:
return|return
name|HBaseEventType
operator|.
name|M2ZK_REGION_OFFLINE
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Invalid byte value for conversion to HBaseEventType"
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Default base class constructor.    *     * TODO: isRegionServer and serverName will go away once we do the HMaster     * refactor. We will end up passing a ServerStatus which should tell us both     * the name and if it is a RS or master.    */
specifier|public
name|HBaseEventHandler
parameter_list|(
name|boolean
name|isRegionServer
parameter_list|,
name|String
name|serverName
parameter_list|,
name|HBaseEventType
name|eventType
parameter_list|)
block|{
name|this
operator|.
name|isRegionServer
operator|=
name|isRegionServer
expr_stmt|;
name|this
operator|.
name|eventType
operator|=
name|eventType
expr_stmt|;
name|this
operator|.
name|serverName
operator|=
name|serverName
expr_stmt|;
block|}
comment|/**    * This is a wrapper around process, used to update listeners before and after     * events are processed.     */
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// fire all beforeProcess listeners
for|for
control|(
name|HBaseEventHandlerListener
name|listener
range|:
name|eventHandlerListeners
control|)
block|{
name|listener
operator|.
name|beforeProcess
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|// call the main process function
try|try
block|{
name|process
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Caught throwable while processing event "
operator|+
name|eventType
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|// fire all afterProcess listeners
for|for
control|(
name|HBaseEventHandlerListener
name|listener
range|:
name|eventHandlerListeners
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Firing "
operator|+
name|listener
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|".afterProcess event listener for event "
operator|+
name|eventType
argument_list|)
expr_stmt|;
name|listener
operator|.
name|afterProcess
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This method is the main processing loop to be implemented by the various     * subclasses.    */
specifier|public
specifier|abstract
name|void
name|process
parameter_list|()
function_decl|;
comment|/**    * Subscribe to updates before and after processing events    */
specifier|public
specifier|static
name|void
name|registerListener
parameter_list|(
name|HBaseEventHandlerListener
name|listener
parameter_list|)
block|{
name|eventHandlerListeners
operator|.
name|add
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
comment|/**    * Stop receiving updates before and after processing events    */
specifier|public
specifier|static
name|void
name|unregisterListener
parameter_list|(
name|HBaseEventHandlerListener
name|listener
parameter_list|)
block|{
name|eventHandlerListeners
operator|.
name|remove
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|isRegionServer
parameter_list|()
block|{
return|return
name|isRegionServer
return|;
block|}
comment|/**    * Return the name for this event type.    * @return    */
specifier|public
name|HBaseExecutorServiceType
name|getEventHandlerName
parameter_list|()
block|{
comment|// TODO: check for isRegionServer here
return|return
name|eventType
operator|.
name|getMasterExecutorForEvent
argument_list|()
return|;
block|}
comment|/**    * Return the event type    * @return    */
specifier|public
name|HBaseEventType
name|getHBEvent
parameter_list|()
block|{
return|return
name|eventType
return|;
block|}
comment|/**    * Submits this event object to the correct executor service. This is causes    * this object to get executed by the correct ExecutorService.    */
specifier|public
name|void
name|submit
parameter_list|()
block|{
name|HBaseExecutorServiceType
name|serviceType
init|=
name|getEventHandlerName
argument_list|()
decl_stmt|;
if|if
condition|(
name|serviceType
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Event "
operator|+
name|eventType
operator|+
literal|" not handled on this server "
operator|+
name|serverName
argument_list|)
throw|;
block|}
name|serviceType
operator|.
name|getExecutor
argument_list|(
name|serverName
argument_list|)
operator|.
name|submit
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**    * Executes this event object in the caller's thread. This is a synchronous     * way of executing the event.    */
specifier|public
name|void
name|execute
parameter_list|()
block|{
name|this
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

