begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2010 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|ConnectException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentNavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentSkipListMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Chore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerAddress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NotServingRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Stoppable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|CatalogTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|MetaReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|RootLocationEditor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|EventHandler
operator|.
name|EventType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|RegionTransitionData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|LoadBalancer
operator|.
name|RegionPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|ClosedRegionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|OpenedRegionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|ServerShutdownHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKAssign
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKUtil
operator|.
name|NodeAndData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|AsyncCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
operator|.
name|NoNodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|Stat
import|;
end_import

begin_comment
comment|/**  * Manages and performs region assignment.  *<p>  * Monitors ZooKeeper for events related to regions in transition.  *<p>  * Handles existing regions in transition during master failover.  */
end_comment

begin_class
specifier|public
class|class
name|AssignmentManager
extends|extends
name|ZooKeeperListener
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|AssignmentManager
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|protected
name|Server
name|master
decl_stmt|;
specifier|private
name|ServerManager
name|serverManager
decl_stmt|;
specifier|private
name|CatalogTracker
name|catalogTracker
decl_stmt|;
specifier|private
name|TimeoutMonitor
name|timeoutMonitor
decl_stmt|;
comment|/**    * Regions currently in transition.  Map of encoded region names to the master    * in-memory state for that region.    */
specifier|final
name|ConcurrentSkipListMap
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
name|regionsInTransition
init|=
operator|new
name|ConcurrentSkipListMap
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Plans for region movement. Key is the encoded version of a region name*/
comment|// TODO: When do plans get cleaned out?  Ever? In server open and in server
comment|// shutdown processing -- St.Ack
comment|// TODO: Better to just synchronize access around regionPlans?  I think that
comment|//       would be better than a concurrent structure since we do more than
comment|//       one operation at a time -- jgray
specifier|final
name|ConcurrentNavigableMap
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
name|regionPlans
init|=
operator|new
name|ConcurrentSkipListMap
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ZKTable
name|zkTable
decl_stmt|;
comment|/**    * Server to regions assignment map.    * Contains the set of regions currently assigned to a given server.    * This Map and {@link #regions} are tied.  Always update this in tandem    * with the other under a lock on {@link #regions}    * @see #regions    */
specifier|private
specifier|final
name|NavigableMap
argument_list|<
name|HServerInfo
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|servers
init|=
operator|new
name|TreeMap
argument_list|<
name|HServerInfo
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Region to server assignment map.    * Contains the server a given region is currently assigned to.    * This Map and {@link #servers} are tied.  Always update this in tandem    * with the other under a lock on {@link #regions}    * @see #servers    */
specifier|private
specifier|final
name|SortedMap
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerInfo
argument_list|>
name|regions
init|=
operator|new
name|TreeMap
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerInfo
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ExecutorService
name|executorService
decl_stmt|;
comment|/**    * Constructs a new assignment manager.    *    * @param master    * @param serverManager    * @param catalogTracker    * @param service    * @throws KeeperException     */
specifier|public
name|AssignmentManager
parameter_list|(
name|Server
name|master
parameter_list|,
name|ServerManager
name|serverManager
parameter_list|,
name|CatalogTracker
name|catalogTracker
parameter_list|,
specifier|final
name|ExecutorService
name|service
parameter_list|)
throws|throws
name|KeeperException
block|{
name|super
argument_list|(
name|master
operator|.
name|getZooKeeper
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|master
operator|=
name|master
expr_stmt|;
name|this
operator|.
name|serverManager
operator|=
name|serverManager
expr_stmt|;
name|this
operator|.
name|catalogTracker
operator|=
name|catalogTracker
expr_stmt|;
name|this
operator|.
name|executorService
operator|=
name|service
expr_stmt|;
name|Configuration
name|conf
init|=
name|master
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|this
operator|.
name|timeoutMonitor
operator|=
operator|new
name|TimeoutMonitor
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.assignment.timeoutmonitor.period"
argument_list|,
literal|10000
argument_list|)
argument_list|,
name|master
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.assignment.timeoutmonitor.timeout"
argument_list|,
literal|30000
argument_list|)
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|timeoutMonitor
argument_list|,
name|master
operator|.
name|getServerName
argument_list|()
operator|+
literal|".timeoutMonitor"
argument_list|)
expr_stmt|;
name|this
operator|.
name|zkTable
operator|=
operator|new
name|ZKTable
argument_list|(
name|this
operator|.
name|master
operator|.
name|getZooKeeper
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return Instance of ZKTable.    */
specifier|public
name|ZKTable
name|getZKTable
parameter_list|()
block|{
comment|// These are 'expensive' to make involving trip to zk ensemble so allow
comment|// sharing.
return|return
name|this
operator|.
name|zkTable
return|;
block|}
comment|/**    * Reset all unassigned znodes.  Called on startup of master.    * Call {@link #assignAllUserRegions()} after root and meta have been assigned.    * @throws IOException    * @throws KeeperException    */
name|void
name|cleanoutUnassigned
parameter_list|()
throws|throws
name|IOException
throws|,
name|KeeperException
block|{
comment|// Cleanup any existing ZK nodes and start watching
name|ZKAssign
operator|.
name|deleteAllNodes
argument_list|(
name|watcher
argument_list|)
expr_stmt|;
name|ZKUtil
operator|.
name|listChildrenAndWatchForNewChildren
argument_list|(
name|this
operator|.
name|watcher
argument_list|,
name|this
operator|.
name|watcher
operator|.
name|assignmentZNode
argument_list|)
expr_stmt|;
block|}
comment|/**    * Handle failover.  Restore state from META and ZK.  Handle any regions in    * transition.  Presumes<code>.META.</code> and<code>-ROOT-</code> deployed.    * @throws KeeperException    * @throws IOException    */
name|void
name|processFailover
parameter_list|()
throws|throws
name|KeeperException
throws|,
name|IOException
block|{
comment|// Concurrency note: In the below the accesses on regionsInTransition are
comment|// outside of a synchronization block where usually all accesses to RIT are
comment|// synchronized.  The presumption is that in this case it is safe since this
comment|// method is being played by a single thread on startup.
comment|// TODO: Check list of user regions and their assignments against regionservers.
comment|// TODO: Regions that have a null location and are not in regionsInTransitions
comment|// need to be handled.
comment|// Scan META to build list of existing regions, servers, and assignment
comment|// Returns servers who have not checked in (assumed dead) and their regions
name|Map
argument_list|<
name|HServerInfo
argument_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
argument_list|>
argument_list|>
name|deadServers
init|=
name|rebuildUserRegions
argument_list|()
decl_stmt|;
comment|// Process list of dead servers
name|processDeadServers
argument_list|(
name|deadServers
argument_list|)
expr_stmt|;
comment|// Check existing regions in transition
name|List
argument_list|<
name|String
argument_list|>
name|nodes
init|=
name|ZKUtil
operator|.
name|listChildrenAndWatchForNewChildren
argument_list|(
name|watcher
argument_list|,
name|watcher
operator|.
name|assignmentZNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No regions in transition in ZK to process on failover"
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed-over master needs to process "
operator|+
name|nodes
operator|.
name|size
argument_list|()
operator|+
literal|" regions in transition"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|encodedRegionName
range|:
name|nodes
control|)
block|{
name|processRegionInTransition
argument_list|(
name|encodedRegionName
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * If region is up in zk in transition, then do fixup and block and wait until    * the region is assigned and out of transition.  Used on startup for    * catalog regions.    * @param hri Region to look for.    * @return True if we processed a region in transition else false if region    * was not up in zk in transition.    * @throws InterruptedException    * @throws KeeperException    * @throws IOException    */
name|boolean
name|processRegionInTransitionAndBlockUntilAssigned
parameter_list|(
specifier|final
name|HRegionInfo
name|hri
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|KeeperException
throws|,
name|IOException
block|{
name|boolean
name|intransistion
init|=
name|processRegionInTransition
argument_list|(
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|,
name|hri
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|intransistion
condition|)
return|return
name|intransistion
return|;
synchronized|synchronized
init|(
name|this
operator|.
name|regionsInTransition
init|)
block|{
while|while
condition|(
operator|!
name|this
operator|.
name|master
operator|.
name|isStopped
argument_list|()
operator|&&
name|this
operator|.
name|regionsInTransition
operator|.
name|containsKey
argument_list|(
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|)
condition|)
block|{
name|this
operator|.
name|regionsInTransition
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|intransistion
return|;
block|}
comment|/**    * Process failover of<code>encodedName</code>.  Look in    * @param encodedRegionName Region to process failover for.    * @param encodedRegionName RegionInfo.  If null we'll go get it from meta table.    * @return    * @throws KeeperException    * @throws IOException    */
name|boolean
name|processRegionInTransition
parameter_list|(
specifier|final
name|String
name|encodedRegionName
parameter_list|,
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|IOException
block|{
name|RegionTransitionData
name|data
init|=
name|ZKAssign
operator|.
name|getData
argument_list|(
name|watcher
argument_list|,
name|encodedRegionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|HRegionInfo
name|hri
init|=
operator|(
name|regionInfo
operator|!=
literal|null
operator|)
condition|?
name|regionInfo
else|:
name|MetaReader
operator|.
name|getRegion
argument_list|(
name|catalogTracker
argument_list|,
name|data
operator|.
name|getRegionName
argument_list|()
argument_list|)
operator|.
name|getFirst
argument_list|()
decl_stmt|;
name|processRegionsInTransition
argument_list|(
name|data
argument_list|,
name|hri
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|void
name|processRegionsInTransition
parameter_list|(
specifier|final
name|RegionTransitionData
name|data
parameter_list|,
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|KeeperException
block|{
name|String
name|encodedRegionName
init|=
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing region "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" in state "
operator|+
name|data
operator|.
name|getEventType
argument_list|()
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
switch|switch
condition|(
name|data
operator|.
name|getEventType
argument_list|()
condition|)
block|{
case|case
name|RS_ZK_REGION_CLOSING
case|:
comment|// Just insert region into RIT.
comment|// If this never updates the timeout will trigger new assignment
name|regionsInTransition
operator|.
name|put
argument_list|(
name|encodedRegionName
argument_list|,
operator|new
name|RegionState
argument_list|(
name|regionInfo
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|CLOSING
argument_list|,
name|data
operator|.
name|getStamp
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_CLOSED
case|:
comment|// Region is closed, insert into RIT and handle it
name|regionsInTransition
operator|.
name|put
argument_list|(
name|encodedRegionName
argument_list|,
operator|new
name|RegionState
argument_list|(
name|regionInfo
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|CLOSED
argument_list|,
name|data
operator|.
name|getStamp
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
operator|new
name|ClosedRegionHandler
argument_list|(
name|master
argument_list|,
name|this
argument_list|,
name|regionInfo
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
break|break;
case|case
name|M_ZK_REGION_OFFLINE
case|:
comment|// Region is offline, insert into RIT and handle it like a closed
name|regionsInTransition
operator|.
name|put
argument_list|(
name|encodedRegionName
argument_list|,
operator|new
name|RegionState
argument_list|(
name|regionInfo
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|OFFLINE
argument_list|,
name|data
operator|.
name|getStamp
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
operator|new
name|ClosedRegionHandler
argument_list|(
name|master
argument_list|,
name|this
argument_list|,
name|regionInfo
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_OPENING
case|:
comment|// Just insert region into RIT
comment|// If this never updates the timeout will trigger new assignment
name|regionsInTransition
operator|.
name|put
argument_list|(
name|encodedRegionName
argument_list|,
operator|new
name|RegionState
argument_list|(
name|regionInfo
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|OPENING
argument_list|,
name|data
operator|.
name|getStamp
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_OPENED
case|:
comment|// Region is opened, insert into RIT and handle it
name|regionsInTransition
operator|.
name|put
argument_list|(
name|encodedRegionName
argument_list|,
operator|new
name|RegionState
argument_list|(
name|regionInfo
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|OPENING
argument_list|,
name|data
operator|.
name|getStamp
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|HServerInfo
name|hsi
init|=
name|serverManager
operator|.
name|getServerInfo
argument_list|(
name|data
operator|.
name|getServerName
argument_list|()
argument_list|)
decl_stmt|;
comment|// hsi could be null if this server is no longer online.  If
comment|// that the case, just let this RIT timeout; it'll be assigned
comment|// to new server then.
if|if
condition|(
name|hsi
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Region in transition "
operator|+
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" references a server no longer up "
operator|+
name|data
operator|.
name|getServerName
argument_list|()
operator|+
literal|"; letting RIT timeout so will be assigned elsewhere"
argument_list|)
expr_stmt|;
break|break;
block|}
operator|new
name|OpenedRegionHandler
argument_list|(
name|master
argument_list|,
name|this
argument_list|,
name|regionInfo
argument_list|,
name|hsi
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/**    * Handles various states an unassigned node can be in.    *<p>    * Method is called when a state change is suspected for an unassigned node.    *<p>    * This deals with skipped transitions (we got a CLOSED but didn't see CLOSING    * yet).    * @param data    */
specifier|private
name|void
name|handleRegion
parameter_list|(
specifier|final
name|RegionTransitionData
name|data
parameter_list|)
block|{
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
comment|// Verify this is a known server
if|if
condition|(
operator|!
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|data
operator|.
name|getServerName
argument_list|()
argument_list|)
operator|&&
operator|!
name|this
operator|.
name|master
operator|.
name|getServerName
argument_list|()
operator|.
name|equals
argument_list|(
name|data
operator|.
name|getServerName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Attempted to handle region transition for server but "
operator|+
literal|"server is not online: "
operator|+
name|data
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|String
name|encodedName
init|=
name|HRegionInfo
operator|.
name|encodeRegionName
argument_list|(
name|data
operator|.
name|getRegionName
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|prettyPrintedRegionName
init|=
name|HRegionInfo
operator|.
name|prettyPrint
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Handling transition="
operator|+
name|data
operator|.
name|getEventType
argument_list|()
operator|+
literal|", server="
operator|+
name|data
operator|.
name|getServerName
argument_list|()
operator|+
literal|", region="
operator|+
name|prettyPrintedRegionName
argument_list|)
expr_stmt|;
name|RegionState
name|regionState
init|=
name|regionsInTransition
operator|.
name|get
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|data
operator|.
name|getEventType
argument_list|()
condition|)
block|{
case|case
name|M_ZK_REGION_OFFLINE
case|:
comment|// Nothing to do.
break|break;
case|case
name|RS_ZK_REGION_CLOSING
case|:
comment|// Should see CLOSING after we have asked it to CLOSE or additional
comment|// times after already being in state of CLOSING
if|if
condition|(
name|regionState
operator|==
literal|null
operator|||
operator|(
operator|!
name|regionState
operator|.
name|isPendingClose
argument_list|()
operator|&&
operator|!
name|regionState
operator|.
name|isClosing
argument_list|()
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received CLOSING for region "
operator|+
name|prettyPrintedRegionName
operator|+
literal|" from server "
operator|+
name|data
operator|.
name|getServerName
argument_list|()
operator|+
literal|" but region was in "
operator|+
literal|" the state "
operator|+
name|regionState
operator|+
literal|" and not "
operator|+
literal|"in expected PENDING_CLOSE or CLOSING states"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Transition to CLOSING (or update stamp if already CLOSING)
name|regionState
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|CLOSING
argument_list|,
name|data
operator|.
name|getStamp
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_CLOSED
case|:
comment|// Should see CLOSED after CLOSING but possible after PENDING_CLOSE
if|if
condition|(
name|regionState
operator|==
literal|null
operator|||
operator|(
operator|!
name|regionState
operator|.
name|isPendingClose
argument_list|()
operator|&&
operator|!
name|regionState
operator|.
name|isClosing
argument_list|()
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received CLOSED for region "
operator|+
name|prettyPrintedRegionName
operator|+
literal|" from server "
operator|+
name|data
operator|.
name|getServerName
argument_list|()
operator|+
literal|" but region was in "
operator|+
literal|" the state "
operator|+
name|regionState
operator|+
literal|" and not "
operator|+
literal|"in expected PENDING_CLOSE or CLOSING states"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Handle CLOSED by assigning elsewhere or stopping if a disable
comment|// If we got here all is good.  Need to update RegionState -- else
comment|// what follows will fail because not in expected state.
name|regionState
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|CLOSED
argument_list|,
name|data
operator|.
name|getStamp
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|ClosedRegionHandler
argument_list|(
name|master
argument_list|,
name|this
argument_list|,
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_OPENING
case|:
comment|// Should see OPENING after we have asked it to OPEN or additional
comment|// times after already being in state of OPENING
if|if
condition|(
name|regionState
operator|==
literal|null
operator|||
operator|(
operator|!
name|regionState
operator|.
name|isPendingOpen
argument_list|()
operator|&&
operator|!
name|regionState
operator|.
name|isOpening
argument_list|()
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received OPENING for region "
operator|+
name|prettyPrintedRegionName
operator|+
literal|" from server "
operator|+
name|data
operator|.
name|getServerName
argument_list|()
operator|+
literal|" but region was in "
operator|+
literal|" the state "
operator|+
name|regionState
operator|+
literal|" and not "
operator|+
literal|"in expected PENDING_OPEN or OPENING states"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Transition to OPENING (or update stamp if already OPENING)
name|regionState
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|OPENING
argument_list|,
name|data
operator|.
name|getStamp
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_OPENED
case|:
comment|// Should see OPENED after OPENING but possible after PENDING_OPEN
if|if
condition|(
name|regionState
operator|==
literal|null
operator|||
operator|(
operator|!
name|regionState
operator|.
name|isPendingOpen
argument_list|()
operator|&&
operator|!
name|regionState
operator|.
name|isOpening
argument_list|()
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received OPENED for region "
operator|+
name|prettyPrintedRegionName
operator|+
literal|" from server "
operator|+
name|data
operator|.
name|getServerName
argument_list|()
operator|+
literal|" but region was in "
operator|+
literal|" the state "
operator|+
name|regionState
operator|+
literal|" and not "
operator|+
literal|"in expected PENDING_OPEN or OPENING states"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Handle OPENED by removing from transition and deleted zk node
name|regionState
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|OPEN
argument_list|,
name|data
operator|.
name|getStamp
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|OpenedRegionHandler
argument_list|(
name|master
argument_list|,
name|this
argument_list|,
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|,
name|this
operator|.
name|serverManager
operator|.
name|getServerInfo
argument_list|(
name|data
operator|.
name|getServerName
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|// ZooKeeper events
comment|/**    * New unassigned node has been created.    *    *<p>This happens when an RS begins the OPENING or CLOSING of a region by    * creating an unassigned node.    *    *<p>When this happens we must:    *<ol>    *<li>Watch the node for further events</li>    *<li>Read and handle the state in the node</li>    *</ol>    */
annotation|@
name|Override
specifier|public
name|void
name|nodeCreated
parameter_list|(
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|startsWith
argument_list|(
name|watcher
operator|.
name|assignmentZNode
argument_list|)
condition|)
block|{
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
try|try
block|{
name|RegionTransitionData
name|data
init|=
name|ZKAssign
operator|.
name|getData
argument_list|(
name|watcher
argument_list|,
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|handleRegion
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|master
operator|.
name|abort
argument_list|(
literal|"Unexpected ZK exception reading unassigned node data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Existing unassigned node has had data changed.    *    *<p>This happens when an RS transitions from OFFLINE to OPENING, or between    * OPENING/OPENED and CLOSING/CLOSED.    *    *<p>When this happens we must:    *<ol>    *<li>Watch the node for further events</li>    *<li>Read and handle the state in the node</li>    *</ol>    */
annotation|@
name|Override
specifier|public
name|void
name|nodeDataChanged
parameter_list|(
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|startsWith
argument_list|(
name|watcher
operator|.
name|assignmentZNode
argument_list|)
condition|)
block|{
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
try|try
block|{
name|RegionTransitionData
name|data
init|=
name|ZKAssign
operator|.
name|getData
argument_list|(
name|watcher
argument_list|,
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|handleRegion
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|master
operator|.
name|abort
argument_list|(
literal|"Unexpected ZK exception reading unassigned node data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * New unassigned node has been created.    *    *<p>This happens when an RS begins the OPENING or CLOSING of a region by    * creating an unassigned node.    *    *<p>When this happens we must:    *<ol>    *<li>Watch the node for further children changed events</li>    *<li>Watch all new children for changed events</li>    *<li>Read all children and handle them</li>    *</ol>    */
annotation|@
name|Override
specifier|public
name|void
name|nodeChildrenChanged
parameter_list|(
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|equals
argument_list|(
name|watcher
operator|.
name|assignmentZNode
argument_list|)
condition|)
block|{
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
try|try
block|{
name|List
argument_list|<
name|NodeAndData
argument_list|>
name|newNodes
init|=
name|ZKUtil
operator|.
name|watchAndGetNewChildren
argument_list|(
name|watcher
argument_list|,
name|watcher
operator|.
name|assignmentZNode
argument_list|)
decl_stmt|;
for|for
control|(
name|NodeAndData
name|newNode
range|:
name|newNodes
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Handling new unassigned node: "
operator|+
name|newNode
argument_list|)
expr_stmt|;
name|handleRegion
argument_list|(
name|RegionTransitionData
operator|.
name|fromBytes
argument_list|(
name|newNode
operator|.
name|getData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|master
operator|.
name|abort
argument_list|(
literal|"Unexpected ZK exception reading unassigned children"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Marks the region as online.  Removes it from regions in transition and    * updates the in-memory assignment information.    *<p>    * Used when a region has been successfully opened on a region server.    * @param regionInfo    * @param serverInfo    */
specifier|public
name|void
name|regionOnline
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|,
name|HServerInfo
name|serverInfo
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|regionsInTransition
init|)
block|{
name|RegionState
name|rs
init|=
name|this
operator|.
name|regionsInTransition
operator|.
name|remove
argument_list|(
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|regionsInTransition
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
synchronized|synchronized
init|(
name|this
operator|.
name|regions
init|)
block|{
comment|// Add check
name|HServerInfo
name|hsi
init|=
name|this
operator|.
name|regions
operator|.
name|get
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|hsi
operator|!=
literal|null
condition|)
name|LOG
operator|.
name|warn
argument_list|(
literal|"Overwriting "
operator|+
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" on "
operator|+
name|hsi
argument_list|)
expr_stmt|;
name|this
operator|.
name|regions
operator|.
name|put
argument_list|(
name|regionInfo
argument_list|,
name|serverInfo
argument_list|)
expr_stmt|;
name|addToServers
argument_list|(
name|serverInfo
argument_list|,
name|regionInfo
argument_list|)
expr_stmt|;
block|}
comment|// Remove plan if one.
name|this
operator|.
name|regionPlans
operator|.
name|remove
argument_list|(
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Update timers for all regions in transition going against this server.
name|updateTimers
argument_list|(
name|serverInfo
argument_list|)
expr_stmt|;
block|}
comment|/**    * Touch timers for all regions in transition that have the passed    *<code>hsi</code> in common.    * Call this method whenever a server checks in.  Doing so helps the case where    * a new regionserver has joined the cluster and its been given 1k regions to    * open.  If this method is tickled every time the region reports in a    * successful open then the 1k-th region won't be timed out just because its    * sitting behind the open of 999 other regions.  This method is NOT used    * as part of bulk assign -- there we have a different mechanism for extending    * the regions in transition timer (we turn it off temporarily -- because    * there is no regionplan involved when bulk assigning.    * @param hsi    */
specifier|private
name|void
name|updateTimers
parameter_list|(
specifier|final
name|HServerInfo
name|hsi
parameter_list|)
block|{
comment|// This loop could be expensive
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
name|e
range|:
name|this
operator|.
name|regionPlans
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getDestination
argument_list|()
operator|.
name|equals
argument_list|(
name|hsi
argument_list|)
condition|)
block|{
name|RegionState
name|rs
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|regionsInTransition
init|)
block|{
name|rs
operator|=
name|this
operator|.
name|regionsInTransition
operator|.
name|get
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rs
operator|!=
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|rs
init|)
block|{
name|rs
operator|.
name|update
argument_list|(
name|rs
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**    * Marks the region as offline.  Removes it from regions in transition and    * removes in-memory assignment information.    *<p>    * Used when a region has been closed and should remain closed.    * @param regionInfo    */
specifier|public
name|void
name|regionOffline
parameter_list|(
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|regionsInTransition
init|)
block|{
if|if
condition|(
name|this
operator|.
name|regionsInTransition
operator|.
name|remove
argument_list|(
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|regionsInTransition
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
name|setOffline
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
block|}
comment|/**    * Sets the region as offline by removing in-memory assignment information but    * retaining transition information.    *<p>    * Used when a region has been closed but should be reassigned.    * @param regionInfo    */
specifier|public
name|void
name|setOffline
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|regions
init|)
block|{
name|HServerInfo
name|serverInfo
init|=
name|this
operator|.
name|regions
operator|.
name|remove
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|serverInfo
operator|==
literal|null
condition|)
return|return;
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|serverRegions
init|=
name|this
operator|.
name|servers
operator|.
name|get
argument_list|(
name|serverInfo
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|serverRegions
operator|.
name|remove
argument_list|(
name|regionInfo
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No "
operator|+
name|regionInfo
operator|+
literal|" on "
operator|+
name|serverInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|offlineDisabledRegion
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
comment|// Disabling so should not be reassigned, just delete the CLOSED node
name|LOG
operator|.
name|debug
argument_list|(
literal|"Table being disabled so deleting ZK node and removing from "
operator|+
literal|"regions in transition, skipping assignment of region "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|ZKAssign
operator|.
name|deleteClosedNode
argument_list|(
name|watcher
argument_list|,
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
condition|)
block|{
comment|// Could also be in OFFLINE mode
name|ZKAssign
operator|.
name|deleteOfflineNode
argument_list|(
name|watcher
argument_list|,
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|nne
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Tried to delete closed node for "
operator|+
name|regionInfo
operator|+
literal|" but it "
operator|+
literal|"does not exist so just offlining"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|this
operator|.
name|master
operator|.
name|abort
argument_list|(
literal|"Error deleting CLOSED node in ZK"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|regionOffline
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
block|}
comment|// Assignment methods
comment|/**    * Assigns the specified region.    *<p>    * If a RegionPlan is available with a valid destination then it will be used    * to determine what server region is assigned to.  If no RegionPlan is    * available, region will be assigned to a random available server.    *<p>    * Updates the RegionState and sends the OPEN RPC.    *<p>    * This will only succeed if the region is in transition and in a CLOSED or    * OFFLINE state or not in transition (in-memory not zk), and of course, the    * chosen server is up and running (It may have just crashed!).  If the    * in-memory checks pass, the zk node is forced to OFFLINE before assigning.    *    * @param region server to be assigned    * @param setOfflineInZK whether ZK node should be created/transitioned to an    *                       OFFLINE state before assigning the region    */
specifier|public
name|void
name|assign
parameter_list|(
name|HRegionInfo
name|region
parameter_list|,
name|boolean
name|setOfflineInZK
parameter_list|)
block|{
name|assign
argument_list|(
name|region
argument_list|,
name|setOfflineInZK
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|assign
parameter_list|(
name|HRegionInfo
name|region
parameter_list|,
name|boolean
name|setOfflineInZK
parameter_list|,
name|boolean
name|forceNewPlan
parameter_list|)
block|{
name|String
name|tableName
init|=
name|region
operator|.
name|getTableDesc
argument_list|()
operator|.
name|getNameAsString
argument_list|()
decl_stmt|;
name|boolean
name|disabled
init|=
name|this
operator|.
name|zkTable
operator|.
name|isDisabledTable
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|disabled
operator|||
name|this
operator|.
name|zkTable
operator|.
name|isDisablingTable
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Table "
operator|+
name|tableName
operator|+
operator|(
name|disabled
condition|?
literal|" disabled;"
else|:
literal|" disabling;"
operator|)
operator|+
literal|" skipping assign of "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
name|offlineDisabledRegion
argument_list|(
name|region
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|this
operator|.
name|serverManager
operator|.
name|isClusterShutdown
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cluster shutdown is set; skipping assign of "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|RegionState
name|state
init|=
name|addToRegionsInTransition
argument_list|(
name|region
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|state
init|)
block|{
name|assign
argument_list|(
name|state
argument_list|,
name|setOfflineInZK
argument_list|,
name|forceNewPlan
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Bulk assign regions to<code>destination</code>.  If we fail in any way,    * we'll abort the server.    * @param destination    * @param regions Regions to assign.    */
name|void
name|assign
parameter_list|(
specifier|final
name|HServerInfo
name|destination
parameter_list|,
specifier|final
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Bulk assigning "
operator|+
name|regions
operator|.
name|size
argument_list|()
operator|+
literal|" region(s) to "
operator|+
name|destination
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RegionState
argument_list|>
name|states
init|=
operator|new
name|ArrayList
argument_list|<
name|RegionState
argument_list|>
argument_list|(
name|regions
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|regionsInTransition
init|)
block|{
for|for
control|(
name|HRegionInfo
name|region
range|:
name|regions
control|)
block|{
name|states
operator|.
name|add
argument_list|(
name|forceRegionStateToOffline
argument_list|(
name|region
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Presumption is that only this thread will be updating the state at this
comment|// time; i.e. handlers on backend won't be trying to set it to OPEN, etc.
name|AtomicInteger
name|counter
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|CreateUnassignedAsyncCallback
name|cb
init|=
operator|new
name|CreateUnassignedAsyncCallback
argument_list|(
name|this
operator|.
name|watcher
argument_list|,
name|destination
argument_list|,
name|counter
argument_list|)
decl_stmt|;
for|for
control|(
name|RegionState
name|state
range|:
name|states
control|)
block|{
if|if
condition|(
operator|!
name|asyncSetOfflineInZooKeeper
argument_list|(
name|state
argument_list|,
name|cb
argument_list|,
name|state
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
comment|// Wait until all unassigned nodes have been put up and watchers set.
name|int
name|total
init|=
name|regions
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|oldCounter
init|=
literal|0
init|;
literal|true
condition|;
control|)
block|{
name|int
name|count
init|=
name|counter
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldCounter
operator|!=
name|count
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|destination
operator|.
name|getServerName
argument_list|()
operator|+
literal|" unassigned znodes="
operator|+
name|count
operator|+
literal|" of total="
operator|+
name|total
argument_list|)
expr_stmt|;
name|oldCounter
operator|=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
name|total
condition|)
break|break;
name|Threads
operator|.
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// Move on to open regions.
try|try
block|{
comment|// Send OPEN RPC. This can fail if the server on other end is is not up.
name|this
operator|.
name|serverManager
operator|.
name|sendRegionOpen
argument_list|(
name|destination
argument_list|,
name|regions
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|this
operator|.
name|master
operator|.
name|abort
argument_list|(
literal|"Failed assignment of regions to "
operator|+
name|destination
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Bulk assigning done for "
operator|+
name|destination
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Callback handler for create unassigned znodes used during bulk assign.    */
specifier|static
class|class
name|CreateUnassignedAsyncCallback
implements|implements
name|AsyncCallback
operator|.
name|StringCallback
block|{
specifier|private
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|CreateUnassignedAsyncCallback
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|ZooKeeperWatcher
name|zkw
decl_stmt|;
specifier|private
specifier|final
name|HServerInfo
name|destination
decl_stmt|;
specifier|private
specifier|final
name|AtomicInteger
name|counter
decl_stmt|;
name|CreateUnassignedAsyncCallback
parameter_list|(
specifier|final
name|ZooKeeperWatcher
name|zkw
parameter_list|,
specifier|final
name|HServerInfo
name|destination
parameter_list|,
specifier|final
name|AtomicInteger
name|counter
parameter_list|)
block|{
name|this
operator|.
name|zkw
operator|=
name|zkw
expr_stmt|;
name|this
operator|.
name|destination
operator|=
name|destination
expr_stmt|;
name|this
operator|.
name|counter
operator|=
name|counter
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|processResult
parameter_list|(
name|int
name|rc
parameter_list|,
name|String
name|path
parameter_list|,
name|Object
name|ctx
parameter_list|,
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
comment|// Thisis resultcode.  If non-zero, need to resubmit.
name|LOG
operator|.
name|warn
argument_list|(
literal|"rc != 0 for "
operator|+
name|path
operator|+
literal|" -- retryable connectionloss -- "
operator|+
literal|"FIX see http://wiki.apache.org/hadoop/ZooKeeper/FAQ#A2"
argument_list|)
expr_stmt|;
name|this
operator|.
name|zkw
operator|.
name|abort
argument_list|(
literal|"Connectionloss writing unassigned at "
operator|+
name|path
operator|+
literal|", rc="
operator|+
name|rc
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"rs="
operator|+
operator|(
name|RegionState
operator|)
name|ctx
operator|+
literal|", server="
operator|+
name|this
operator|.
name|destination
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Async exists to set a watcher so we'll get triggered when
comment|// unassigned node changes.
name|this
operator|.
name|zkw
operator|.
name|getZooKeeper
argument_list|()
operator|.
name|exists
argument_list|(
name|path
argument_list|,
name|this
operator|.
name|zkw
argument_list|,
operator|new
name|ExistsUnassignedAsyncCallback
argument_list|(
name|this
operator|.
name|counter
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Callback handler for the exists call that sets watcher on unassigned znodes.    * Used during bulk assign on startup.    */
specifier|static
class|class
name|ExistsUnassignedAsyncCallback
implements|implements
name|AsyncCallback
operator|.
name|StatCallback
block|{
specifier|private
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ExistsUnassignedAsyncCallback
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|AtomicInteger
name|counter
decl_stmt|;
name|ExistsUnassignedAsyncCallback
parameter_list|(
specifier|final
name|AtomicInteger
name|counter
parameter_list|)
block|{
name|this
operator|.
name|counter
operator|=
name|counter
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|processResult
parameter_list|(
name|int
name|rc
parameter_list|,
name|String
name|path
parameter_list|,
name|Object
name|ctx
parameter_list|,
name|Stat
name|stat
parameter_list|)
block|{
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
comment|// Thisis resultcode.  If non-zero, need to resubmit.
name|LOG
operator|.
name|warn
argument_list|(
literal|"rc != 0 for "
operator|+
name|path
operator|+
literal|" -- retryable connectionloss -- "
operator|+
literal|"FIX see http://wiki.apache.org/hadoop/ZooKeeper/FAQ#A2"
argument_list|)
expr_stmt|;
return|return;
block|}
name|RegionState
name|state
init|=
operator|(
name|RegionState
operator|)
name|ctx
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"rs="
operator|+
name|state
argument_list|)
expr_stmt|;
comment|// Transition RegionState to PENDING_OPEN here in master; means we've
comment|// sent the open.  We're a little ahead of ourselves here since we've not
comment|// yet sent out the actual open but putting this state change after the
comment|// call to open risks our writing PENDING_OPEN after state has been moved
comment|// to OPENING by the regionserver.
name|state
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|PENDING_OPEN
argument_list|)
expr_stmt|;
name|this
operator|.
name|counter
operator|.
name|addAndGet
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @param region    * @return    */
specifier|private
name|RegionState
name|addToRegionsInTransition
parameter_list|(
specifier|final
name|HRegionInfo
name|region
parameter_list|)
block|{
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
return|return
name|forceRegionStateToOffline
argument_list|(
name|region
argument_list|)
return|;
block|}
block|}
comment|/**    * Sets regions {@link RegionState} to {@link RegionState.State#OFFLINE}.    * Caller must hold lock on this.regionsInTransition.    * @param region    * @return Amended RegionState.    */
specifier|private
name|RegionState
name|forceRegionStateToOffline
parameter_list|(
specifier|final
name|HRegionInfo
name|region
parameter_list|)
block|{
name|String
name|encodedName
init|=
name|region
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
name|RegionState
name|state
init|=
name|this
operator|.
name|regionsInTransition
operator|.
name|get
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
name|state
operator|=
operator|new
name|RegionState
argument_list|(
name|region
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|OFFLINE
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionsInTransition
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Forcing OFFLINE; was="
operator|+
name|state
argument_list|)
expr_stmt|;
name|state
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|OFFLINE
argument_list|)
expr_stmt|;
block|}
return|return
name|state
return|;
block|}
comment|/**    * Caller must hold lock on the passed<code>state</code> object.    * @param state    */
specifier|private
name|void
name|assign
parameter_list|(
specifier|final
name|RegionState
name|state
parameter_list|,
specifier|final
name|boolean
name|setOfflineInZK
parameter_list|,
specifier|final
name|boolean
name|forceNewPlan
parameter_list|)
block|{
if|if
condition|(
name|setOfflineInZK
operator|&&
operator|!
name|setOfflineInZooKeeper
argument_list|(
name|state
argument_list|)
condition|)
return|return;
if|if
condition|(
name|this
operator|.
name|master
operator|.
name|isStopped
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Server stopped; skipping assign of "
operator|+
name|state
argument_list|)
expr_stmt|;
return|return;
block|}
name|RegionPlan
name|plan
init|=
name|getRegionPlan
argument_list|(
name|state
argument_list|,
name|forceNewPlan
argument_list|)
decl_stmt|;
if|if
condition|(
name|plan
operator|==
literal|null
condition|)
return|return;
comment|// Should get reassigned later when RIT times out.
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Assigning region "
operator|+
name|state
operator|.
name|getRegion
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" to "
operator|+
name|plan
operator|.
name|getDestination
argument_list|()
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Transition RegionState to PENDING_OPEN
name|state
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|PENDING_OPEN
argument_list|)
expr_stmt|;
comment|// Send OPEN RPC. This can fail if the server on other end is is not up.
name|serverManager
operator|.
name|sendRegionOpen
argument_list|(
name|plan
operator|.
name|getDestination
argument_list|()
argument_list|,
name|state
operator|.
name|getRegion
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed assignment of "
operator|+
name|state
operator|.
name|getRegion
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" to "
operator|+
name|plan
operator|.
name|getDestination
argument_list|()
operator|+
literal|", trying to assign elsewhere instead"
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|// Clean out plan we failed execute and one that doesn't look like it'll
comment|// succeed anyways; we need a new plan!
comment|// Transition back to OFFLINE
name|state
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|OFFLINE
argument_list|)
expr_stmt|;
comment|// Force a new plan and reassign.
if|if
condition|(
name|getRegionPlan
argument_list|(
name|state
argument_list|,
name|plan
operator|.
name|getDestination
argument_list|()
argument_list|,
literal|true
argument_list|)
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to find a viable location to assign region "
operator|+
name|state
operator|.
name|getRegion
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|assign
argument_list|(
name|state
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Set region as OFFLINED up in zookeeper    * @param state    * @return True if we succeeded, false otherwise (State was incorrect or failed    * updating zk).    */
name|boolean
name|setOfflineInZooKeeper
parameter_list|(
specifier|final
name|RegionState
name|state
parameter_list|)
block|{
if|if
condition|(
operator|!
name|state
operator|.
name|isClosed
argument_list|()
operator|&&
operator|!
name|state
operator|.
name|isOffline
argument_list|()
condition|)
block|{
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected state trying to OFFLINE; "
operator|+
name|state
argument_list|)
expr_stmt|;
name|this
operator|.
name|master
operator|.
name|abort
argument_list|(
literal|"Unexpected state trying to OFFLINE; "
operator|+
name|state
argument_list|,
operator|new
name|IllegalStateException
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|state
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|OFFLINE
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|ZKAssign
operator|.
name|createOrForceNodeOffline
argument_list|(
name|master
operator|.
name|getZooKeeper
argument_list|()
argument_list|,
name|state
operator|.
name|getRegion
argument_list|()
argument_list|,
name|master
operator|.
name|getServerName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Attempted to create/force node into OFFLINE state before "
operator|+
literal|"completing assignment but failed to do so for "
operator|+
name|state
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|master
operator|.
name|abort
argument_list|(
literal|"Unexpected ZK exception creating/setting node OFFLINE"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Set region as OFFLINED up in zookeeper asynchronously.    * @param state    * @return True if we succeeded, false otherwise (State was incorrect or failed    * updating zk).    */
name|boolean
name|asyncSetOfflineInZooKeeper
parameter_list|(
specifier|final
name|RegionState
name|state
parameter_list|,
specifier|final
name|AsyncCallback
operator|.
name|StringCallback
name|cb
parameter_list|,
specifier|final
name|Object
name|ctx
parameter_list|)
block|{
if|if
condition|(
operator|!
name|state
operator|.
name|isClosed
argument_list|()
operator|&&
operator|!
name|state
operator|.
name|isOffline
argument_list|()
condition|)
block|{
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected state trying to OFFLINE; "
operator|+
name|state
argument_list|)
expr_stmt|;
name|this
operator|.
name|master
operator|.
name|abort
argument_list|(
literal|"Unexpected state trying to OFFLINE; "
operator|+
name|state
argument_list|,
operator|new
name|IllegalStateException
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|state
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|OFFLINE
argument_list|)
expr_stmt|;
try|try
block|{
name|ZKAssign
operator|.
name|asyncCreateNodeOffline
argument_list|(
name|master
operator|.
name|getZooKeeper
argument_list|()
argument_list|,
name|state
operator|.
name|getRegion
argument_list|()
argument_list|,
name|master
operator|.
name|getServerName
argument_list|()
argument_list|,
name|cb
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|master
operator|.
name|abort
argument_list|(
literal|"Unexpected ZK exception creating/setting node OFFLINE"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * @param state    * @return Plan for passed<code>state</code> (If none currently, it creates one or    * if no servers to assign, it returns null).    */
name|RegionPlan
name|getRegionPlan
parameter_list|(
specifier|final
name|RegionState
name|state
parameter_list|,
specifier|final
name|boolean
name|forceNewPlan
parameter_list|)
block|{
return|return
name|getRegionPlan
argument_list|(
name|state
argument_list|,
literal|null
argument_list|,
name|forceNewPlan
argument_list|)
return|;
block|}
comment|/**    * @param state    * @param serverToExclude Server to exclude (we know its bad). Pass null if    * all servers are thought to be assignable.    * @param forceNewPlan If true, then if an existing plan exists, a new plan    * will be generated.    * @return Plan for passed<code>state</code> (If none currently, it creates one or    * if no servers to assign, it returns null).    */
name|RegionPlan
name|getRegionPlan
parameter_list|(
specifier|final
name|RegionState
name|state
parameter_list|,
specifier|final
name|HServerInfo
name|serverToExclude
parameter_list|,
specifier|final
name|boolean
name|forceNewPlan
parameter_list|)
block|{
comment|// Pickup existing plan or make a new one
name|String
name|encodedName
init|=
name|state
operator|.
name|getRegion
argument_list|()
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|HServerInfo
argument_list|>
name|servers
init|=
name|this
operator|.
name|serverManager
operator|.
name|getOnlineServersList
argument_list|()
decl_stmt|;
comment|// The remove below hinges on the fact that the call to
comment|// serverManager.getOnlineServersList() returns a copy
if|if
condition|(
name|serverToExclude
operator|!=
literal|null
condition|)
name|servers
operator|.
name|remove
argument_list|(
name|serverToExclude
argument_list|)
expr_stmt|;
if|if
condition|(
name|servers
operator|.
name|size
argument_list|()
operator|<=
literal|0
condition|)
return|return
literal|null
return|;
name|RegionPlan
name|randomPlan
init|=
operator|new
name|RegionPlan
argument_list|(
name|state
operator|.
name|getRegion
argument_list|()
argument_list|,
literal|null
argument_list|,
name|LoadBalancer
operator|.
name|randomAssignment
argument_list|(
name|servers
argument_list|)
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|regionPlans
init|)
block|{
name|RegionPlan
name|existingPlan
init|=
name|this
operator|.
name|regionPlans
operator|.
name|get
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|existingPlan
operator|==
literal|null
operator|||
name|forceNewPlan
operator|||
name|existingPlan
operator|.
name|getDestination
argument_list|()
operator|.
name|equals
argument_list|(
name|serverToExclude
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No previous transition plan was found (or we are ignoring "
operator|+
literal|"an existing plan) for "
operator|+
name|state
operator|.
name|getRegion
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" so generated a random one; "
operator|+
name|randomPlan
operator|+
literal|"; "
operator|+
name|serverManager
operator|.
name|countOfRegionServers
argument_list|()
operator|+
literal|" (online="
operator|+
name|serverManager
operator|.
name|getOnlineServers
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|", exclude="
operator|+
name|serverToExclude
operator|+
literal|") available servers"
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionPlans
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|randomPlan
argument_list|)
expr_stmt|;
return|return
name|randomPlan
return|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using pre-exisitng plan for region "
operator|+
name|state
operator|.
name|getRegion
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|"; plan="
operator|+
name|existingPlan
argument_list|)
expr_stmt|;
return|return
name|existingPlan
return|;
block|}
block|}
comment|/**    * Unassigns the specified region.    *<p>    * Updates the RegionState and sends the CLOSE RPC.    *<p>    * If a RegionPlan is already set, it will remain.    *    * @param region server to be unassigned    */
specifier|public
name|void
name|unassign
parameter_list|(
name|HRegionInfo
name|region
parameter_list|)
block|{
name|unassign
argument_list|(
name|region
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Unassigns the specified region.    *<p>    * Updates the RegionState and sends the CLOSE RPC.    *<p>    * If a RegionPlan is already set, it will remain.    *    * @param region server to be unassigned    * @param force if region should be closed even if already closing    */
specifier|public
name|void
name|unassign
parameter_list|(
name|HRegionInfo
name|region
parameter_list|,
name|boolean
name|force
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Starting unassignment of region "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" (offlining)"
argument_list|)
expr_stmt|;
comment|// Check if this region is currently assigned
if|if
condition|(
operator|!
name|regions
operator|.
name|containsKey
argument_list|(
name|region
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempted to unassign region "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" but it is not "
operator|+
literal|"currently assigned anywhere"
argument_list|)
expr_stmt|;
return|return;
block|}
name|String
name|encodedName
init|=
name|region
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
comment|// Grab the state of this region and synchronize on it
name|RegionState
name|state
decl_stmt|;
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
name|state
operator|=
name|regionsInTransition
operator|.
name|get
argument_list|(
name|encodedName
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
name|state
operator|=
operator|new
name|RegionState
argument_list|(
name|region
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|PENDING_CLOSE
argument_list|)
expr_stmt|;
name|regionsInTransition
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|force
operator|&&
name|state
operator|.
name|isPendingClose
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempting to unassign region "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" which is already pending close "
operator|+
literal|"but forcing an additional close"
argument_list|)
expr_stmt|;
name|state
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|PENDING_CLOSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempting to unassign region "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" but it is "
operator|+
literal|"already in transition ("
operator|+
name|state
operator|.
name|getState
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// Send CLOSE RPC
name|HServerInfo
name|server
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|regions
init|)
block|{
name|server
operator|=
name|regions
operator|.
name|get
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
try|try
block|{
comment|// TODO: We should consider making this look more like it does for the
comment|//       region open where we catch all throwables and never abort
if|if
condition|(
name|serverManager
operator|.
name|sendRegionClose
argument_list|(
name|server
argument_list|,
name|state
operator|.
name|getRegion
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sent CLOSE to "
operator|+
name|server
operator|+
literal|" for region "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Server "
operator|+
name|server
operator|+
literal|" region CLOSE RPC returned false"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotServingRegionException
name|nsre
parameter_list|)
block|{
comment|// Failed to close, so pass through and reassign
name|LOG
operator|.
name|info
argument_list|(
literal|"Server "
operator|+
name|server
operator|+
literal|" returned NotServingRegionException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ConnectException
name|e
parameter_list|)
block|{
comment|// Failed to connect, so pass through and reassign
name|LOG
operator|.
name|info
argument_list|(
literal|"Server "
operator|+
name|server
operator|+
literal|" returned ConnectException "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
if|if
condition|(
name|re
operator|.
name|unwrapRemoteException
argument_list|()
operator|instanceof
name|NotServingRegionException
condition|)
block|{
comment|// Failed to close, so pass through and reassign
name|LOG
operator|.
name|debug
argument_list|(
literal|"Server "
operator|+
name|server
operator|+
literal|" returned NotServingRegionException"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|master
operator|.
name|abort
argument_list|(
literal|"Remote unexpected exception"
argument_list|,
name|re
operator|.
name|unwrapRemoteException
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// For now call abort if unexpected exception -- radical, but will get fellas attention.
comment|// St.Ack 20101012
name|this
operator|.
name|master
operator|.
name|abort
argument_list|(
literal|"Remote unexpected exception"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|// Did not CLOSE, so set region offline and assign it
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempted to send CLOSE to "
operator|+
name|server
operator|+
literal|" for region "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" but failed, "
operator|+
literal|"setting region as OFFLINE and reassigning"
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
name|forceRegionStateToOffline
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
name|assign
argument_list|(
name|region
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Waits until the specified region has completed assignment.    *<p>    * If the region is already assigned, returns immediately.  Otherwise, method    * blocks until the region is assigned.    * @param regionInfo region to wait on assignment for    * @throws InterruptedException    */
specifier|public
name|void
name|waitForAssignment
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|InterruptedException
block|{
synchronized|synchronized
init|(
name|regions
init|)
block|{
while|while
condition|(
operator|!
name|regions
operator|.
name|containsKey
argument_list|(
name|regionInfo
argument_list|)
condition|)
block|{
name|regions
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Assigns the ROOT region.    *<p>    * Assumes that ROOT is currently closed and is not being actively served by    * any RegionServer.    *<p>    * Forcibly unsets the current root region location in ZooKeeper and assigns    * ROOT to a random RegionServer.    * @throws KeeperException    */
specifier|public
name|void
name|assignRoot
parameter_list|()
throws|throws
name|KeeperException
block|{
name|RootLocationEditor
operator|.
name|deleteRootLocation
argument_list|(
name|this
operator|.
name|master
operator|.
name|getZooKeeper
argument_list|()
argument_list|)
expr_stmt|;
name|assign
argument_list|(
name|HRegionInfo
operator|.
name|ROOT_REGIONINFO
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assigns the META region.    *<p>    * Assumes that META is currently closed and is not being actively served by    * any RegionServer.    *<p>    * Forcibly assigns META to a random RegionServer.    */
specifier|public
name|void
name|assignMeta
parameter_list|()
block|{
comment|// Force assignment to a random server
name|assign
argument_list|(
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assigns all user regions, if any exist.  Used during cluster startup.    *<p>    * This is a synchronous call and will return once every region has been    * assigned.  If anything fails, an exception is thrown and the cluster    * should be shutdown.    * @throws InterruptedException    * @throws IOException    */
specifier|public
name|void
name|assignAllUserRegions
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
comment|// Get all available servers
name|List
argument_list|<
name|HServerInfo
argument_list|>
name|servers
init|=
name|serverManager
operator|.
name|getOnlineServersList
argument_list|()
decl_stmt|;
comment|// Scan META for all user regions, skipping any disabled tables
name|Map
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerAddress
argument_list|>
name|allRegions
init|=
name|MetaReader
operator|.
name|fullScan
argument_list|(
name|catalogTracker
argument_list|,
name|this
operator|.
name|zkTable
operator|.
name|getDisabledTables
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|allRegions
operator|==
literal|null
operator|||
name|allRegions
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|// Determine what type of assignment to do on startup
name|boolean
name|retainAssignment
init|=
name|master
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getBoolean
argument_list|(
literal|"hbase.master.startup.retainassign"
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|HServerInfo
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|bulkPlan
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|retainAssignment
condition|)
block|{
comment|// Reuse existing assignment info
name|bulkPlan
operator|=
name|LoadBalancer
operator|.
name|retainAssignment
argument_list|(
name|allRegions
argument_list|,
name|servers
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Generate a round-robin bulk assignment plan
name|bulkPlan
operator|=
name|LoadBalancer
operator|.
name|roundRobinAssignment
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|(
name|allRegions
operator|.
name|keySet
argument_list|()
argument_list|)
argument_list|,
name|servers
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Bulk assigning "
operator|+
name|allRegions
operator|.
name|size
argument_list|()
operator|+
literal|" region(s) across "
operator|+
name|servers
operator|.
name|size
argument_list|()
operator|+
literal|" server(s), retainAssignment="
operator|+
name|retainAssignment
argument_list|)
expr_stmt|;
comment|// Use fixed count thread pool assigning.
name|BulkAssigner
name|ba
init|=
operator|new
name|BulkStartupAssigner
argument_list|(
name|this
operator|.
name|master
argument_list|,
name|bulkPlan
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|ba
operator|.
name|bulkAssign
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Bulk assigning done"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Run bulk assign on startup.    */
specifier|static
class|class
name|BulkStartupAssigner
extends|extends
name|BulkAssigner
block|{
specifier|private
specifier|final
name|Map
argument_list|<
name|HServerInfo
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|bulkPlan
decl_stmt|;
specifier|private
specifier|final
name|AssignmentManager
name|assignmentManager
decl_stmt|;
name|BulkStartupAssigner
parameter_list|(
specifier|final
name|Server
name|server
parameter_list|,
specifier|final
name|Map
argument_list|<
name|HServerInfo
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|bulkPlan
parameter_list|,
specifier|final
name|AssignmentManager
name|am
parameter_list|)
block|{
name|super
argument_list|(
name|server
argument_list|)
expr_stmt|;
name|this
operator|.
name|bulkPlan
operator|=
name|bulkPlan
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|=
name|am
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|bulkAssign
parameter_list|()
throws|throws
name|InterruptedException
block|{
comment|// Disable timing out regions in transition up in zk while bulk assigning.
name|this
operator|.
name|assignmentManager
operator|.
name|timeoutMonitor
operator|.
name|bulkAssign
argument_list|(
literal|true
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|super
operator|.
name|bulkAssign
argument_list|()
return|;
block|}
finally|finally
block|{
comment|// Reenable timing out regions in transition up in zi.
name|this
operator|.
name|assignmentManager
operator|.
name|timeoutMonitor
operator|.
name|bulkAssign
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getThreadNamePrefix
parameter_list|()
block|{
return|return
name|super
operator|.
name|getThreadNamePrefix
argument_list|()
operator|+
literal|"-startup"
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|populatePool
parameter_list|(
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
name|pool
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|HServerInfo
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|e
range|:
name|this
operator|.
name|bulkPlan
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|pool
operator|.
name|execute
argument_list|(
operator|new
name|SingleServerBulkAssigner
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|,
name|this
operator|.
name|assignmentManager
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|boolean
name|waitUntilDone
parameter_list|(
specifier|final
name|long
name|timeout
parameter_list|)
throws|throws
name|InterruptedException
block|{
return|return
name|this
operator|.
name|assignmentManager
operator|.
name|waitUntilNoRegionsInTransition
argument_list|(
name|timeout
argument_list|)
return|;
block|}
block|}
comment|/**    * Manage bulk assigning to a server.    */
specifier|static
class|class
name|SingleServerBulkAssigner
implements|implements
name|Runnable
block|{
specifier|private
specifier|final
name|HServerInfo
name|regionserver
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
decl_stmt|;
specifier|private
specifier|final
name|AssignmentManager
name|assignmentManager
decl_stmt|;
name|SingleServerBulkAssigner
parameter_list|(
specifier|final
name|HServerInfo
name|regionserver
parameter_list|,
specifier|final
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
parameter_list|,
specifier|final
name|AssignmentManager
name|am
parameter_list|)
block|{
name|this
operator|.
name|regionserver
operator|=
name|regionserver
expr_stmt|;
name|this
operator|.
name|regions
operator|=
name|regions
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|=
name|am
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|this
operator|.
name|assignmentManager
operator|.
name|assign
argument_list|(
name|this
operator|.
name|regionserver
argument_list|,
name|this
operator|.
name|regions
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Wait until no regions in transition.    * @param timeout How long to wait.    * @return True if nothing in regions in transition.    * @throws InterruptedException    */
name|boolean
name|waitUntilNoRegionsInTransition
parameter_list|(
specifier|final
name|long
name|timeout
parameter_list|)
throws|throws
name|InterruptedException
block|{
comment|// Blocks until there are no regions in transition. It is possible that
comment|// there
comment|// are regions in transition immediately after this returns but guarantees
comment|// that if it returns without an exception that there was a period of time
comment|// with no regions in transition from the point-of-view of the in-memory
comment|// state of the Master.
name|long
name|startTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|long
name|remaining
init|=
name|timeout
decl_stmt|;
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
while|while
condition|(
name|regionsInTransition
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
operator|!
name|this
operator|.
name|master
operator|.
name|isStopped
argument_list|()
operator|&&
name|remaining
operator|>
literal|0
condition|)
block|{
name|regionsInTransition
operator|.
name|wait
argument_list|(
name|remaining
argument_list|)
expr_stmt|;
name|remaining
operator|=
name|timeout
operator|-
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
operator|)
expr_stmt|;
block|}
block|}
return|return
name|regionsInTransition
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/**    * Rebuild the list of user regions and assignment information.    *<p>    * Returns a map of servers that are not found to be online and the regions    * they were hosting.    * @return map of servers not online to their assigned regions, as stored    *         in META    * @throws IOException    */
specifier|private
name|Map
argument_list|<
name|HServerInfo
argument_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
argument_list|>
argument_list|>
name|rebuildUserRegions
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Region assignment from META
name|List
argument_list|<
name|Result
argument_list|>
name|results
init|=
name|MetaReader
operator|.
name|fullScanOfResults
argument_list|(
name|catalogTracker
argument_list|)
decl_stmt|;
comment|// Map of offline servers and their regions to be returned
name|Map
argument_list|<
name|HServerInfo
argument_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
argument_list|>
argument_list|>
name|offlineServers
init|=
operator|new
name|TreeMap
argument_list|<
name|HServerInfo
argument_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// Iterate regions in META
for|for
control|(
name|Result
name|result
range|:
name|results
control|)
block|{
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerInfo
argument_list|>
name|region
init|=
name|MetaReader
operator|.
name|metaRowToRegionPairWithInfo
argument_list|(
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|==
literal|null
condition|)
continue|continue;
name|HServerInfo
name|regionLocation
init|=
name|region
operator|.
name|getSecond
argument_list|()
decl_stmt|;
name|HRegionInfo
name|regionInfo
init|=
name|region
operator|.
name|getFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|regionLocation
operator|==
literal|null
condition|)
block|{
comment|// Region not being served, add to region map with no assignment
comment|// If this needs to be assigned out, it will also be in ZK as RIT
name|this
operator|.
name|regions
operator|.
name|put
argument_list|(
name|regionInfo
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|regionLocation
operator|.
name|getServerName
argument_list|()
argument_list|)
condition|)
block|{
comment|// Region is located on a server that isn't online
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
argument_list|>
name|offlineRegions
init|=
name|offlineServers
operator|.
name|get
argument_list|(
name|regionLocation
argument_list|)
decl_stmt|;
if|if
condition|(
name|offlineRegions
operator|==
literal|null
condition|)
block|{
name|offlineRegions
operator|=
operator|new
name|ArrayList
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|offlineServers
operator|.
name|put
argument_list|(
name|regionLocation
argument_list|,
name|offlineRegions
argument_list|)
expr_stmt|;
block|}
name|offlineRegions
operator|.
name|add
argument_list|(
operator|new
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
argument_list|(
name|regionInfo
argument_list|,
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Region is being served and on an active server
name|regions
operator|.
name|put
argument_list|(
name|regionInfo
argument_list|,
name|regionLocation
argument_list|)
expr_stmt|;
name|addToServers
argument_list|(
name|regionLocation
argument_list|,
name|regionInfo
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|offlineServers
return|;
block|}
comment|/**    * Processes list of dead servers from result of META scan.    *<p>    * This is used as part of failover to handle RegionServers which failed    * while there was no active master.    *<p>    * Method stubs in-memory data to be as expected by the normal server shutdown    * handler.    *    * @param deadServers    * @throws IOException    * @throws KeeperException    */
specifier|private
name|void
name|processDeadServers
parameter_list|(
name|Map
argument_list|<
name|HServerInfo
argument_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
argument_list|>
argument_list|>
name|deadServers
parameter_list|)
throws|throws
name|IOException
throws|,
name|KeeperException
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|HServerInfo
argument_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
argument_list|>
argument_list|>
name|deadServer
range|:
name|deadServers
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
argument_list|>
name|regions
init|=
name|deadServer
operator|.
name|getValue
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|Result
argument_list|>
name|region
range|:
name|regions
control|)
block|{
name|HRegionInfo
name|regionInfo
init|=
name|region
operator|.
name|getFirst
argument_list|()
decl_stmt|;
name|Result
name|result
init|=
name|region
operator|.
name|getSecond
argument_list|()
decl_stmt|;
comment|// If region was in transition (was in zk) force it offline for reassign
try|try
block|{
name|ZKAssign
operator|.
name|createOrForceNodeOffline
argument_list|(
name|watcher
argument_list|,
name|regionInfo
argument_list|,
name|master
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|nne
parameter_list|)
block|{
comment|// This is fine
block|}
comment|// Process with existing RS shutdown code
name|ServerShutdownHandler
operator|.
name|processDeadRegion
argument_list|(
name|regionInfo
argument_list|,
name|result
argument_list|,
name|this
argument_list|,
name|this
operator|.
name|catalogTracker
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*    * Presumes caller has taken care of necessary locking modifying servers Map.    * @param hsi    * @param hri    */
specifier|private
name|void
name|addToServers
parameter_list|(
specifier|final
name|HServerInfo
name|hsi
parameter_list|,
specifier|final
name|HRegionInfo
name|hri
parameter_list|)
block|{
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|hris
init|=
name|servers
operator|.
name|get
argument_list|(
name|hsi
argument_list|)
decl_stmt|;
if|if
condition|(
name|hris
operator|==
literal|null
condition|)
block|{
name|hris
operator|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
expr_stmt|;
name|servers
operator|.
name|put
argument_list|(
name|hsi
argument_list|,
name|hris
argument_list|)
expr_stmt|;
block|}
name|hris
operator|.
name|add
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return A copy of the Map of regions currently in transition.    */
specifier|public
name|NavigableMap
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
name|getRegionsInTransition
parameter_list|()
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|regionsInTransition
init|)
block|{
return|return
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
argument_list|(
name|this
operator|.
name|regionsInTransition
argument_list|)
return|;
block|}
block|}
comment|/**    * @return True if regions in transition.    */
specifier|public
name|boolean
name|isRegionsInTransition
parameter_list|()
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|regionsInTransition
init|)
block|{
return|return
operator|!
name|this
operator|.
name|regionsInTransition
operator|.
name|isEmpty
argument_list|()
return|;
block|}
block|}
comment|/**    * @param hri Region to check.    * @return Returns null if passed region is not in transition else the current    * RegionState    */
specifier|public
name|RegionState
name|isRegionInTransition
parameter_list|(
specifier|final
name|HRegionInfo
name|hri
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|regionsInTransition
init|)
block|{
return|return
name|this
operator|.
name|regionsInTransition
operator|.
name|get
argument_list|(
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * Clears the specified region from being in transition.    *<p>    * Used only by HBCK tool.    * @param hri    */
specifier|public
name|void
name|clearRegionFromTransition
parameter_list|(
name|HRegionInfo
name|hri
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|regionsInTransition
init|)
block|{
name|this
operator|.
name|regionsInTransition
operator|.
name|remove
argument_list|(
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|this
operator|.
name|regions
init|)
block|{
name|this
operator|.
name|regions
operator|.
name|remove
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
name|clearRegionPlan
argument_list|(
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|servers
init|)
block|{
for|for
control|(
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
range|:
name|this
operator|.
name|servers
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|regions
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regions
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|equals
argument_list|(
name|hri
argument_list|)
condition|)
block|{
name|regions
operator|.
name|remove
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
comment|/**    * @param encodedRegionName Region whose plan we are to clear.    */
name|void
name|clearRegionPlan
parameter_list|(
specifier|final
name|String
name|encodedRegionName
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|regionPlans
init|)
block|{
name|this
operator|.
name|regionPlans
operator|.
name|remove
argument_list|(
name|encodedRegionName
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Wait on region to clear regions-in-transition.    * @param hri Region to wait on.    * @throws IOException    */
specifier|public
name|void
name|waitOnRegionToClearRegionsInTransition
parameter_list|(
specifier|final
name|HRegionInfo
name|hri
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isRegionInTransition
argument_list|(
name|hri
argument_list|)
operator|==
literal|null
condition|)
return|return;
name|RegionState
name|rs
init|=
literal|null
decl_stmt|;
comment|// There is already a timeout monitor on regions in transition so I
comment|// should not have to have one here too?
while|while
condition|(
operator|!
name|this
operator|.
name|master
operator|.
name|isStopped
argument_list|()
operator|&&
operator|(
name|rs
operator|=
name|isRegionInTransition
argument_list|(
name|hri
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|Threads
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting on "
operator|+
name|rs
operator|+
literal|" to clear regions-in-transition"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|master
operator|.
name|isStopped
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Giving up wait on regions in "
operator|+
literal|"transition because stoppable.isStopped is set"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Gets the online regions of the specified table.    * This method looks at the in-memory state.  It does not go to<code>.META.</code>.    * Only returns<em>online</em> regions.  If a region on this table has been    * closed during a disable, etc., it will be included in the returned list.    * So, the returned list may not necessarily be ALL regions in this table, its    * all the ONLINE regions in the table.    * @param tableName    * @return Online regions from<code>tableName</code>    */
specifier|public
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|getRegionsOfTable
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|)
block|{
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|tableRegions
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
decl_stmt|;
name|HRegionInfo
name|boundary
init|=
operator|new
name|HRegionInfo
argument_list|(
operator|new
name|HTableDescriptor
argument_list|(
name|tableName
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
for|for
control|(
name|HRegionInfo
name|regionInfo
range|:
name|this
operator|.
name|regions
operator|.
name|tailMap
argument_list|(
name|boundary
argument_list|)
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|regionInfo
operator|.
name|getTableDesc
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|tableName
argument_list|)
condition|)
block|{
name|tableRegions
operator|.
name|add
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
return|return
name|tableRegions
return|;
block|}
comment|/**    * Monitor to check for time outs on region transition operations    */
specifier|public
class|class
name|TimeoutMonitor
extends|extends
name|Chore
block|{
specifier|private
specifier|final
name|int
name|timeout
decl_stmt|;
specifier|private
name|boolean
name|bulkAssign
init|=
literal|false
decl_stmt|;
comment|/**      * Creates a periodic monitor to check for time outs on region transition      * operations.  This will deal with retries if for some reason something      * doesn't happen within the specified timeout.      * @param period    * @param stopper When {@link Stoppable#isStopped()} is true, this thread will    * cleanup and exit cleanly.      * @param timeout      */
specifier|public
name|TimeoutMonitor
parameter_list|(
specifier|final
name|int
name|period
parameter_list|,
specifier|final
name|Stoppable
name|stopper
parameter_list|,
specifier|final
name|int
name|timeout
parameter_list|)
block|{
name|super
argument_list|(
literal|"AssignmentTimeoutMonitor"
argument_list|,
name|period
argument_list|,
name|stopper
argument_list|)
expr_stmt|;
name|this
operator|.
name|timeout
operator|=
name|timeout
expr_stmt|;
block|}
comment|/**      * @param bulkAssign If true, we'll suspend checking regions in transition      * up in zookeeper.  If false, will reenable check.      * @return Old setting for bulkAssign.      */
specifier|public
name|boolean
name|bulkAssign
parameter_list|(
specifier|final
name|boolean
name|bulkAssign
parameter_list|)
block|{
name|boolean
name|result
init|=
name|this
operator|.
name|bulkAssign
decl_stmt|;
name|this
operator|.
name|bulkAssign
operator|=
name|bulkAssign
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|chore
parameter_list|()
block|{
comment|// If bulkAssign in progress, suspend checks
if|if
condition|(
name|this
operator|.
name|bulkAssign
condition|)
return|return;
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
comment|// Iterate all regions in transition checking for time outs
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
for|for
control|(
name|RegionState
name|regionState
range|:
name|regionsInTransition
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|regionState
operator|.
name|getStamp
argument_list|()
operator|+
name|timeout
operator|<=
name|now
condition|)
block|{
name|HRegionInfo
name|regionInfo
init|=
name|regionState
operator|.
name|getRegion
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Regions in transition timed out:  "
operator|+
name|regionState
argument_list|)
expr_stmt|;
comment|// Expired!  Do a retry.
switch|switch
condition|(
name|regionState
operator|.
name|getState
argument_list|()
condition|)
block|{
case|case
name|CLOSED
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Region has been CLOSED for too long, "
operator|+
literal|"retriggering ClosedRegionHandler"
argument_list|)
expr_stmt|;
name|AssignmentManager
operator|.
name|this
operator|.
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|ClosedRegionHandler
argument_list|(
name|master
argument_list|,
name|AssignmentManager
operator|.
name|this
argument_list|,
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OFFLINE
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Region has been OFFLINE for too long, "
operator|+
literal|"reassigning "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" to a random server"
argument_list|)
expr_stmt|;
name|assign
argument_list|(
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|PENDING_OPEN
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Region has been PENDING_OPEN for too "
operator|+
literal|"long, reassigning region="
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
name|assign
argument_list|(
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPENING
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Region has been OPENING for too "
operator|+
literal|"long, reassigning region="
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Should have a ZK node in OPENING state
try|try
block|{
name|String
name|node
init|=
name|ZKAssign
operator|.
name|getNodeName
argument_list|(
name|watcher
argument_list|,
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
name|Stat
name|stat
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
name|RegionTransitionData
name|data
init|=
name|ZKAssign
operator|.
name|getDataNoWatch
argument_list|(
name|watcher
argument_list|,
name|node
argument_list|,
name|stat
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|.
name|getEventType
argument_list|()
operator|==
name|EventType
operator|.
name|RS_ZK_REGION_OPENED
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Region has transitioned to OPENED, allowing "
operator|+
literal|"watched event handlers to process"
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|data
operator|.
name|getEventType
argument_list|()
operator|!=
name|EventType
operator|.
name|RS_ZK_REGION_OPENING
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"While timing out a region in state OPENING, "
operator|+
literal|"found ZK node in unexpected state: "
operator|+
name|data
operator|.
name|getEventType
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// Attempt to transition node into OFFLINE
try|try
block|{
name|data
operator|=
operator|new
name|RegionTransitionData
argument_list|(
name|EventType
operator|.
name|M_ZK_REGION_OFFLINE
argument_list|,
name|regionInfo
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZKUtil
operator|.
name|setData
argument_list|(
name|watcher
argument_list|,
name|node
argument_list|,
name|data
operator|.
name|getBytes
argument_list|()
argument_list|,
name|stat
operator|.
name|getVersion
argument_list|()
argument_list|)
condition|)
block|{
comment|// Node is now OFFLINE, let's trigger another assignment
name|ZKUtil
operator|.
name|getDataAndWatch
argument_list|(
name|watcher
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|// re-set the watch
name|LOG
operator|.
name|info
argument_list|(
literal|"Successfully transitioned region="
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" into OFFLINE"
operator|+
literal|" and forcing a new assignment"
argument_list|)
expr_stmt|;
name|assign
argument_list|(
name|regionState
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|nne
parameter_list|)
block|{
comment|// Node did not exist, can't time this out
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|ke
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unexpected ZK exception timing out CLOSING region"
argument_list|,
name|ke
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|OPEN
case|:
name|LOG
operator|.
name|error
argument_list|(
literal|"Region has been OPEN for too long, "
operator|+
literal|"we don't know where region was opened so can't do anything"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PENDING_CLOSE
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Region has been PENDING_CLOSE for too "
operator|+
literal|"long, running forced unassign again on region="
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
comment|// If the server got the RPC, it will transition the node
comment|// to CLOSING, so only do something here if no node exists
if|if
condition|(
operator|!
name|ZKUtil
operator|.
name|watchAndCheckExists
argument_list|(
name|watcher
argument_list|,
name|ZKAssign
operator|.
name|getNodeName
argument_list|(
name|watcher
argument_list|,
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
name|unassign
argument_list|(
name|regionInfo
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NoNodeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Node no longer existed so not forcing another "
operator|+
literal|"unassignment"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected ZK exception timing out a region "
operator|+
literal|"close"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CLOSING
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Region has been CLOSING for too "
operator|+
literal|"long, this should eventually complete or the server will "
operator|+
literal|"expire, doing nothing"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/**    * Process shutdown server removing any assignments.    * @param hsi Server that went down.    * @return set of regions on this server that are not in transition    */
specifier|public
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|processServerShutdown
parameter_list|(
specifier|final
name|HServerInfo
name|hsi
parameter_list|)
block|{
comment|// Clean out any existing assignment plans for this server
synchronized|synchronized
init|(
name|this
operator|.
name|regionPlans
init|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
argument_list|>
name|i
init|=
name|this
operator|.
name|regionPlans
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
name|e
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getDestination
argument_list|()
operator|.
name|equals
argument_list|(
name|hsi
argument_list|)
condition|)
block|{
comment|// Use iterator's remove else we'll get CME
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// TODO: Do we want to sync on RIT here?
comment|// Remove this server from map of servers to regions, and remove all regions
comment|// of this server from online map of regions.
name|Set
argument_list|<
name|HRegionInfo
argument_list|>
name|deadRegions
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|regions
init|)
block|{
name|deadRegions
operator|=
operator|new
name|TreeSet
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|(
name|this
operator|.
name|servers
operator|.
name|remove
argument_list|(
name|hsi
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|HRegionInfo
name|region
range|:
name|deadRegions
control|)
block|{
name|this
operator|.
name|regions
operator|.
name|remove
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
block|}
comment|// See if any of the regions that were online on this server were in RIT
comment|// If they are, normal timeouts will deal with them appropriately so
comment|// let's skip a manual re-assignment.
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|rits
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
for|for
control|(
name|RegionState
name|region
range|:
name|this
operator|.
name|regionsInTransition
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|deadRegions
operator|.
name|remove
argument_list|(
name|region
operator|.
name|getRegion
argument_list|()
argument_list|)
condition|)
block|{
name|rits
operator|.
name|add
argument_list|(
name|region
operator|.
name|getRegion
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|rits
return|;
block|}
comment|/**    * Update inmemory structures.    * @param hsi Server that reported the split    * @param parent Parent region that was split    * @param a Daughter region A    * @param b Daughter region B    */
specifier|public
name|void
name|handleSplitReport
parameter_list|(
specifier|final
name|HServerInfo
name|hsi
parameter_list|,
specifier|final
name|HRegionInfo
name|parent
parameter_list|,
specifier|final
name|HRegionInfo
name|a
parameter_list|,
specifier|final
name|HRegionInfo
name|b
parameter_list|)
block|{
name|regionOffline
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|regionOnline
argument_list|(
name|a
argument_list|,
name|hsi
argument_list|)
expr_stmt|;
name|regionOnline
argument_list|(
name|b
argument_list|,
name|hsi
argument_list|)
expr_stmt|;
comment|// There's a possibility that the region was splitting while a user asked
comment|// the master to disable, we need to make sure we close those regions in
comment|// that case. This is not racing with the region server itself since RS
comment|// report is done after the split transaction completed.
if|if
condition|(
name|this
operator|.
name|zkTable
operator|.
name|isDisablingOrDisabledTable
argument_list|(
name|parent
operator|.
name|getTableDesc
argument_list|()
operator|.
name|getNameAsString
argument_list|()
argument_list|)
condition|)
block|{
name|unassign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|unassign
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @return A clone of current assignments. Note, this is assignments only.    * If a new server has come in and it has no regions, it will not be included    * in the returned Map.    */
name|Map
argument_list|<
name|HServerInfo
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|getAssignments
parameter_list|()
block|{
comment|// This is an EXPENSIVE clone.  Cloning though is the safest thing to do.
comment|// Can't let out original since it can change and at least the loadbalancer
comment|// wants to iterate this exported list.  We need to synchronize on regions
comment|// since all access to this.servers is under a lock on this.regions.
name|Map
argument_list|<
name|HServerInfo
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|result
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|regions
init|)
block|{
name|result
operator|=
operator|new
name|HashMap
argument_list|<
name|HServerInfo
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
argument_list|(
name|this
operator|.
name|servers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|HServerInfo
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|e
range|:
name|this
operator|.
name|servers
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|shallowCopy
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|HServerInfo
name|clone
init|=
operator|new
name|HServerInfo
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
comment|// Set into server load the number of regions this server is carrying
comment|// The load balancer calculation needs it at least and its handy.
name|clone
operator|.
name|getLoad
argument_list|()
operator|.
name|setNumberOfRegions
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|.
name|put
argument_list|(
name|clone
argument_list|,
name|shallowCopy
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**    * @param encodedRegionName Region encoded name.    * @return Null or a {@link Pair} instance that holds the full {@link HRegionInfo}    * and the hosting servers {@link HServerInfo}.    */
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerInfo
argument_list|>
name|getAssignment
parameter_list|(
specifier|final
name|byte
index|[]
name|encodedRegionName
parameter_list|)
block|{
name|String
name|name
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|encodedRegionName
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|regions
init|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerInfo
argument_list|>
name|e
range|:
name|this
operator|.
name|regions
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|getEncodedName
argument_list|()
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
operator|new
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerInfo
argument_list|>
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * @param plan Plan to execute.    */
name|void
name|balance
parameter_list|(
specifier|final
name|RegionPlan
name|plan
parameter_list|)
block|{
name|this
operator|.
name|regionPlans
operator|.
name|put
argument_list|(
name|plan
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|plan
argument_list|)
expr_stmt|;
name|unassign
argument_list|(
name|plan
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * State of a Region while undergoing transitions.    */
specifier|public
specifier|static
class|class
name|RegionState
implements|implements
name|Writable
block|{
specifier|private
name|HRegionInfo
name|region
decl_stmt|;
specifier|public
enum|enum
name|State
block|{
name|OFFLINE
block|,
comment|// region is in an offline state
name|PENDING_OPEN
block|,
comment|// sent rpc to server to open but has not begun
name|OPENING
block|,
comment|// server has begun to open but not yet done
name|OPEN
block|,
comment|// server opened region and updated meta
name|PENDING_CLOSE
block|,
comment|// sent rpc to server to close but has not begun
name|CLOSING
block|,
comment|// server has begun to close but not yet done
name|CLOSED
comment|// server closed region and updated meta
block|}
specifier|private
name|State
name|state
decl_stmt|;
specifier|private
name|long
name|stamp
decl_stmt|;
specifier|public
name|RegionState
parameter_list|()
block|{}
name|RegionState
parameter_list|(
name|HRegionInfo
name|region
parameter_list|,
name|State
name|state
parameter_list|)
block|{
name|this
argument_list|(
name|region
argument_list|,
name|state
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|RegionState
parameter_list|(
name|HRegionInfo
name|region
parameter_list|,
name|State
name|state
parameter_list|,
name|long
name|stamp
parameter_list|)
block|{
name|this
operator|.
name|region
operator|=
name|region
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
name|this
operator|.
name|stamp
operator|=
name|stamp
expr_stmt|;
block|}
specifier|public
name|void
name|update
parameter_list|(
name|State
name|state
parameter_list|,
name|long
name|stamp
parameter_list|)
block|{
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
name|this
operator|.
name|stamp
operator|=
name|stamp
expr_stmt|;
block|}
specifier|public
name|void
name|update
parameter_list|(
name|State
name|state
parameter_list|)
block|{
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
name|this
operator|.
name|stamp
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
specifier|public
name|State
name|getState
parameter_list|()
block|{
return|return
name|state
return|;
block|}
specifier|public
name|long
name|getStamp
parameter_list|()
block|{
return|return
name|stamp
return|;
block|}
specifier|public
name|HRegionInfo
name|getRegion
parameter_list|()
block|{
return|return
name|region
return|;
block|}
specifier|public
name|boolean
name|isClosing
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|CLOSING
return|;
block|}
specifier|public
name|boolean
name|isClosed
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|CLOSED
return|;
block|}
specifier|public
name|boolean
name|isPendingClose
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|PENDING_CLOSE
return|;
block|}
specifier|public
name|boolean
name|isOpening
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|OPENING
return|;
block|}
specifier|public
name|boolean
name|isOpened
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|OPEN
return|;
block|}
specifier|public
name|boolean
name|isPendingOpen
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|PENDING_OPEN
return|;
block|}
specifier|public
name|boolean
name|isOffline
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|OFFLINE
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" state="
operator|+
name|state
operator|+
literal|", ts="
operator|+
name|stamp
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|region
operator|=
operator|new
name|HRegionInfo
argument_list|()
expr_stmt|;
name|region
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|state
operator|=
name|State
operator|.
name|valueOf
argument_list|(
name|in
operator|.
name|readUTF
argument_list|()
argument_list|)
expr_stmt|;
name|stamp
operator|=
name|in
operator|.
name|readLong
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|region
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeUTF
argument_list|(
name|state
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeLong
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|stop
parameter_list|()
block|{
name|this
operator|.
name|timeoutMonitor
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

