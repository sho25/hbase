begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2010 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Chore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerAddress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NotServingRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Stoppable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|CatalogTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|MetaReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|RootLocationEditor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MetaScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|RegionTransitionData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|LoadBalancer
operator|.
name|RegionPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|ClosedRegionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|OpenedRegionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKAssign
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKTableDisable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKUtil
operator|.
name|NodeAndData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_comment
comment|/**  * Manages and performs region assignment.  *<p>  * Monitors ZooKeeper for events related to regions in transition.  *<p>  * Handles existing regions in transition during master failover.  */
end_comment

begin_class
specifier|public
class|class
name|AssignmentManager
extends|extends
name|ZooKeeperListener
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|AssignmentManager
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|protected
name|Server
name|master
decl_stmt|;
specifier|private
name|ServerManager
name|serverManager
decl_stmt|;
specifier|private
name|CatalogTracker
name|catalogTracker
decl_stmt|;
specifier|private
name|TimeoutMonitor
name|timeoutMonitor
decl_stmt|;
comment|/** Regions currently in transition. */
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
name|regionsInTransition
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Plans for region movement. Key is the encoded version of a region name*/
comment|// TODO: When do plans get cleaned out?  Ever?
comment|// Its cleaned on server shutdown processing -- St.Ack
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
name|regionPlans
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Set of tables that have been disabled. */
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|disabledTables
init|=
name|Collections
operator|.
name|synchronizedSet
argument_list|(
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Server to regions assignment map.    * Contains the set of regions currently assigned to a given server.    * This Map and {@link #regions} are tied.  Always update this in tandem    * with the other under a lock on {@link #regions}    * @see #regions    */
specifier|private
specifier|final
name|NavigableMap
argument_list|<
name|HServerInfo
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|servers
init|=
operator|new
name|TreeMap
argument_list|<
name|HServerInfo
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Region to server assignment map.    * Contains the server a given region is currently assigned to.    * This Map and {@link #servers} are tied.  Always update this in tandem    * with the other under a lock on {@link #regions}    * @see #servers    */
specifier|private
specifier|final
name|SortedMap
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerInfo
argument_list|>
name|regions
init|=
operator|new
name|TreeMap
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerInfo
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ExecutorService
name|executorService
decl_stmt|;
comment|/**    * Constructs a new assignment manager.    *    *<p>This manager must be started with {@link #start()}.    *    * @param status master status    * @param serverManager    * @param catalogTracker    * @param service    */
specifier|public
name|AssignmentManager
parameter_list|(
name|Server
name|master
parameter_list|,
name|ServerManager
name|serverManager
parameter_list|,
name|CatalogTracker
name|catalogTracker
parameter_list|,
specifier|final
name|ExecutorService
name|service
parameter_list|)
block|{
name|super
argument_list|(
name|master
operator|.
name|getZooKeeper
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|master
operator|=
name|master
expr_stmt|;
name|this
operator|.
name|serverManager
operator|=
name|serverManager
expr_stmt|;
name|this
operator|.
name|catalogTracker
operator|=
name|catalogTracker
expr_stmt|;
name|this
operator|.
name|executorService
operator|=
name|service
expr_stmt|;
name|Configuration
name|conf
init|=
name|master
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|this
operator|.
name|timeoutMonitor
operator|=
operator|new
name|TimeoutMonitor
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.assignment.timeoutmonitor.period"
argument_list|,
literal|30000
argument_list|)
argument_list|,
name|master
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.assignment.timeoutmonitor.timeout"
argument_list|,
literal|15000
argument_list|)
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|timeoutMonitor
argument_list|,
name|master
operator|.
name|getServerName
argument_list|()
operator|+
literal|".timeoutMonitor"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Reset all unassigned znodes.  Called on startup of master.    * Call {@link #assignAllUserRegions()} after root and meta have been assigned.    * @throws IOException    * @throws KeeperException    */
name|void
name|cleanoutUnassigned
parameter_list|()
throws|throws
name|IOException
throws|,
name|KeeperException
block|{
comment|// Cleanup any existing ZK nodes and start watching
name|ZKAssign
operator|.
name|deleteAllNodes
argument_list|(
name|watcher
argument_list|)
expr_stmt|;
name|ZKUtil
operator|.
name|listChildrenAndWatchForNewChildren
argument_list|(
name|this
operator|.
name|watcher
argument_list|,
name|this
operator|.
name|watcher
operator|.
name|assignmentZNode
argument_list|)
expr_stmt|;
block|}
comment|/**    * Handle failover.  Restore state from META and ZK.  Handle any regions in    * transition.  Presumes<code>.META.</code> and<code>-ROOT-</code> deployed.    * @throws KeeperException    * @throws IOException    */
name|void
name|processFailover
parameter_list|()
throws|throws
name|KeeperException
throws|,
name|IOException
block|{
comment|// Concurrency note: In the below the accesses on regionsInTransition are
comment|// outside of a synchronization block where usually all accesses to RIT are
comment|// synchronized.  The presumption is that in this case it is safe since this
comment|// method is being played by a single thread on startup.
comment|// TODO: Check list of user regions and their assignments against regionservers.
comment|// TODO: Regions that have a null location and are not in regionsInTransitions
comment|// need to be handled.
comment|// TODO: Regions that are on servers that are not in our online list need
comment|// reassigning.
comment|// Scan META to build list of existing regions, servers, and assignment
name|rebuildUserRegions
argument_list|()
expr_stmt|;
comment|// Pickup any disabled tables
name|rebuildDisabledTables
argument_list|()
expr_stmt|;
comment|// Check existing regions in transition
name|List
argument_list|<
name|String
argument_list|>
name|nodes
init|=
name|ZKUtil
operator|.
name|listChildrenAndWatchForNewChildren
argument_list|(
name|watcher
argument_list|,
name|watcher
operator|.
name|assignmentZNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No regions in transition in ZK to process on failover"
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed-over master needs to process "
operator|+
name|nodes
operator|.
name|size
argument_list|()
operator|+
literal|" regions in transition"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|encodedRegionName
range|:
name|nodes
control|)
block|{
name|processRegionInTransition
argument_list|(
name|encodedRegionName
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * If region is up in zk in transition, then do fixup and block and wait until    * the region is assigned and out of transition.  Used on startup for    * catalog regions.    * @param hri Region to look for.    * @return True if we processed a region in transition else false if region    * was not up in zk in transition.    * @throws InterruptedException    * @throws KeeperException    * @throws IOException    */
name|boolean
name|processRegionInTransitionAndBlockUntilAssigned
parameter_list|(
specifier|final
name|HRegionInfo
name|hri
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|KeeperException
throws|,
name|IOException
block|{
name|boolean
name|intransistion
init|=
name|processRegionInTransition
argument_list|(
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|,
name|hri
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|intransistion
condition|)
return|return
name|intransistion
return|;
synchronized|synchronized
init|(
name|this
operator|.
name|regionsInTransition
init|)
block|{
while|while
condition|(
operator|!
name|this
operator|.
name|master
operator|.
name|isStopped
argument_list|()
operator|&&
name|this
operator|.
name|regionsInTransition
operator|.
name|containsKey
argument_list|(
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|)
condition|)
block|{
name|this
operator|.
name|regionsInTransition
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|intransistion
return|;
block|}
comment|/**    * Process failover of<code>encodedName</code>.  Look in     * @param encodedRegionName Region to process failover for.    * @param encodedRegionName RegionInfo.  If null we'll go get it from meta table.    * @return    * @throws KeeperException     * @throws IOException     */
name|boolean
name|processRegionInTransition
parameter_list|(
specifier|final
name|String
name|encodedRegionName
parameter_list|,
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|IOException
block|{
name|RegionTransitionData
name|data
init|=
name|ZKAssign
operator|.
name|getData
argument_list|(
name|watcher
argument_list|,
name|encodedRegionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|HRegionInfo
name|hri
init|=
operator|(
name|regionInfo
operator|!=
literal|null
operator|)
condition|?
name|regionInfo
else|:
name|MetaReader
operator|.
name|getRegion
argument_list|(
name|catalogTracker
argument_list|,
name|data
operator|.
name|getRegionName
argument_list|()
argument_list|)
operator|.
name|getFirst
argument_list|()
decl_stmt|;
name|processRegionsInTransition
argument_list|(
name|data
argument_list|,
name|hri
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|void
name|processRegionsInTransition
parameter_list|(
specifier|final
name|RegionTransitionData
name|data
parameter_list|,
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|KeeperException
block|{
name|String
name|encodedRegionName
init|=
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing region "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" in state "
operator|+
name|data
operator|.
name|getEventType
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|data
operator|.
name|getEventType
argument_list|()
condition|)
block|{
case|case
name|RS_ZK_REGION_CLOSING
case|:
comment|// Just insert region into RIT.
comment|// If this never updates the timeout will trigger new assignment
name|regionsInTransition
operator|.
name|put
argument_list|(
name|encodedRegionName
argument_list|,
operator|new
name|RegionState
argument_list|(
name|regionInfo
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|CLOSING
argument_list|,
name|data
operator|.
name|getStamp
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_CLOSED
case|:
comment|// Region is closed, insert into RIT and handle it
name|regionsInTransition
operator|.
name|put
argument_list|(
name|encodedRegionName
argument_list|,
operator|new
name|RegionState
argument_list|(
name|regionInfo
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|CLOSED
argument_list|,
name|data
operator|.
name|getStamp
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
operator|new
name|ClosedRegionHandler
argument_list|(
name|master
argument_list|,
name|this
argument_list|,
name|data
argument_list|,
name|regionInfo
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_OPENING
case|:
comment|// Just insert region into RIT
comment|// If this never updates the timeout will trigger new assignment
name|regionsInTransition
operator|.
name|put
argument_list|(
name|encodedRegionName
argument_list|,
operator|new
name|RegionState
argument_list|(
name|regionInfo
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|OPENING
argument_list|,
name|data
operator|.
name|getStamp
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_OPENED
case|:
comment|// Region is opened, insert into RIT and handle it
name|regionsInTransition
operator|.
name|put
argument_list|(
name|encodedRegionName
argument_list|,
operator|new
name|RegionState
argument_list|(
name|regionInfo
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|OPENING
argument_list|,
name|data
operator|.
name|getStamp
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
operator|new
name|OpenedRegionHandler
argument_list|(
name|master
argument_list|,
name|this
argument_list|,
name|data
argument_list|,
name|regionInfo
argument_list|,
name|serverManager
operator|.
name|getServerInfo
argument_list|(
name|data
operator|.
name|getServerName
argument_list|()
argument_list|)
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
comment|/**    * Handles various states an unassigned node can be in.    *<p>    * Method is called when a state change is suspected for an unassigned node.    *<p>    * This deals with skipped transitions (we got a CLOSED but didn't see CLOSING    * yet).    * @param data    */
specifier|private
name|void
name|handleRegion
parameter_list|(
specifier|final
name|RegionTransitionData
name|data
parameter_list|)
block|{
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
comment|// Verify this is a known server
if|if
condition|(
operator|!
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|data
operator|.
name|getServerName
argument_list|()
argument_list|)
operator|&&
operator|!
name|this
operator|.
name|master
operator|.
name|getServerName
argument_list|()
operator|.
name|equals
argument_list|(
name|data
operator|.
name|getServerName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Attempted to handle region transition for server but "
operator|+
literal|"server is not online: "
operator|+
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
name|String
name|encodedName
init|=
name|HRegionInfo
operator|.
name|encodeRegionName
argument_list|(
name|data
operator|.
name|getRegionName
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|prettyPrintedRegionName
init|=
name|HRegionInfo
operator|.
name|prettyPrint
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Handling transition="
operator|+
name|data
operator|.
name|getEventType
argument_list|()
operator|+
literal|", server="
operator|+
name|data
operator|.
name|getServerName
argument_list|()
operator|+
literal|", region="
operator|+
name|prettyPrintedRegionName
argument_list|)
expr_stmt|;
name|RegionState
name|regionState
init|=
name|regionsInTransition
operator|.
name|get
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|data
operator|.
name|getEventType
argument_list|()
condition|)
block|{
case|case
name|M_ZK_REGION_OFFLINE
case|:
comment|// Nothing to do.
break|break;
case|case
name|RS_ZK_REGION_CLOSING
case|:
comment|// Should see CLOSING after we have asked it to CLOSE or additional
comment|// times after already being in state of CLOSING
if|if
condition|(
name|regionState
operator|==
literal|null
operator|||
operator|(
operator|!
name|regionState
operator|.
name|isPendingClose
argument_list|()
operator|&&
operator|!
name|regionState
operator|.
name|isClosing
argument_list|()
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received CLOSING for region "
operator|+
name|prettyPrintedRegionName
operator|+
literal|" from server "
operator|+
name|data
operator|.
name|getServerName
argument_list|()
operator|+
literal|" but region was in "
operator|+
literal|" the state "
operator|+
name|regionState
operator|+
literal|" and not "
operator|+
literal|"in expected PENDING_CLOSE or CLOSING states"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Transition to CLOSING (or update stamp if already CLOSING)
name|regionState
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|CLOSING
argument_list|,
name|data
operator|.
name|getStamp
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_CLOSED
case|:
comment|// Should see CLOSED after CLOSING but possible after PENDING_CLOSE
if|if
condition|(
name|regionState
operator|==
literal|null
operator|||
operator|(
operator|!
name|regionState
operator|.
name|isPendingClose
argument_list|()
operator|&&
operator|!
name|regionState
operator|.
name|isClosing
argument_list|()
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received CLOSED for region "
operator|+
name|prettyPrintedRegionName
operator|+
literal|" from server "
operator|+
name|data
operator|.
name|getServerName
argument_list|()
operator|+
literal|" but region was in "
operator|+
literal|" the state "
operator|+
name|regionState
operator|+
literal|" and not "
operator|+
literal|"in expected PENDING_CLOSE or CLOSING states"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Handle CLOSED by assigning elsewhere or stopping if a disable
comment|// If we got here all is good.  Need to update RegionState -- else
comment|// what follows will fail because not in expected state.
name|regionState
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|CLOSED
argument_list|,
name|data
operator|.
name|getStamp
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|ClosedRegionHandler
argument_list|(
name|master
argument_list|,
name|this
argument_list|,
name|data
argument_list|,
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_OPENING
case|:
comment|// Should see OPENING after we have asked it to OPEN or additional
comment|// times after already being in state of OPENING
if|if
condition|(
name|regionState
operator|==
literal|null
operator|||
operator|(
operator|!
name|regionState
operator|.
name|isPendingOpen
argument_list|()
operator|&&
operator|!
name|regionState
operator|.
name|isOpening
argument_list|()
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received OPENING for region "
operator|+
name|prettyPrintedRegionName
operator|+
literal|" from server "
operator|+
name|data
operator|.
name|getServerName
argument_list|()
operator|+
literal|" but region was in "
operator|+
literal|" the state "
operator|+
name|regionState
operator|+
literal|" and not "
operator|+
literal|"in expected PENDING_OPEN or OPENING states"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Transition to OPENING (or update stamp if already OPENING)
name|regionState
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|OPENING
argument_list|,
name|data
operator|.
name|getStamp
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|RS_ZK_REGION_OPENED
case|:
comment|// Should see OPENED after OPENING but possible after PENDING_OPEN
if|if
condition|(
name|regionState
operator|==
literal|null
operator|||
operator|(
operator|!
name|regionState
operator|.
name|isPendingOpen
argument_list|()
operator|&&
operator|!
name|regionState
operator|.
name|isOpening
argument_list|()
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received OPENED for region "
operator|+
name|prettyPrintedRegionName
operator|+
literal|" from server "
operator|+
name|data
operator|.
name|getServerName
argument_list|()
operator|+
literal|" but region was in "
operator|+
literal|" the state "
operator|+
name|regionState
operator|+
literal|" and not "
operator|+
literal|"in expected PENDING_OPEN or OPENING states"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Handle OPENED by removing from transition and deleted zk node
name|this
operator|.
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|OpenedRegionHandler
argument_list|(
name|master
argument_list|,
name|this
argument_list|,
name|data
argument_list|,
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|,
name|this
operator|.
name|serverManager
operator|.
name|getServerInfo
argument_list|(
name|data
operator|.
name|getServerName
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|// ZooKeeper events
comment|/**    * New unassigned node has been created.    *    *<p>This happens when an RS begins the OPENING or CLOSING of a region by    * creating an unassigned node.    *    *<p>When this happens we must:    *<ol>    *<li>Watch the node for further events</li>    *<li>Read and handle the state in the node</li>    *</ol>    */
annotation|@
name|Override
specifier|public
name|void
name|nodeCreated
parameter_list|(
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|startsWith
argument_list|(
name|watcher
operator|.
name|assignmentZNode
argument_list|)
condition|)
block|{
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
try|try
block|{
name|RegionTransitionData
name|data
init|=
name|ZKAssign
operator|.
name|getData
argument_list|(
name|watcher
argument_list|,
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|handleRegion
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|master
operator|.
name|abort
argument_list|(
literal|"Unexpected ZK exception reading unassigned node data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Existing unassigned node has had data changed.    *    *<p>This happens when an RS transitions from OFFLINE to OPENING, or between    * OPENING/OPENED and CLOSING/CLOSED.    *    *<p>When this happens we must:    *<ol>    *<li>Watch the node for further events</li>    *<li>Read and handle the state in the node</li>    *</ol>    */
annotation|@
name|Override
specifier|public
name|void
name|nodeDataChanged
parameter_list|(
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|startsWith
argument_list|(
name|watcher
operator|.
name|assignmentZNode
argument_list|)
condition|)
block|{
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
try|try
block|{
name|RegionTransitionData
name|data
init|=
name|ZKAssign
operator|.
name|getData
argument_list|(
name|watcher
argument_list|,
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|handleRegion
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|master
operator|.
name|abort
argument_list|(
literal|"Unexpected ZK exception reading unassigned node data"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * New unassigned node has been created.    *    *<p>This happens when an RS begins the OPENING or CLOSING of a region by    * creating an unassigned node.    *    *<p>When this happens we must:    *<ol>    *<li>Watch the node for further children changed events</li>    *<li>Watch all new children for changed events</li>    *<li>Read all children and handle them</li>    *</ol>    */
annotation|@
name|Override
specifier|public
name|void
name|nodeChildrenChanged
parameter_list|(
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|equals
argument_list|(
name|watcher
operator|.
name|assignmentZNode
argument_list|)
condition|)
block|{
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
try|try
block|{
name|List
argument_list|<
name|NodeAndData
argument_list|>
name|newNodes
init|=
name|ZKUtil
operator|.
name|watchAndGetNewChildren
argument_list|(
name|watcher
argument_list|,
name|watcher
operator|.
name|assignmentZNode
argument_list|)
decl_stmt|;
for|for
control|(
name|NodeAndData
name|newNode
range|:
name|newNodes
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Handling new unassigned node: "
operator|+
name|newNode
argument_list|)
expr_stmt|;
name|handleRegion
argument_list|(
name|RegionTransitionData
operator|.
name|fromBytes
argument_list|(
name|newNode
operator|.
name|getData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|master
operator|.
name|abort
argument_list|(
literal|"Unexpected ZK exception reading unassigned children"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Marks the region as online.  Removes it from regions in transition and    * updates the in-memory assignment information.    *<p>    * Used when a region has been successfully opened on a region server.    * @param regionInfo    * @param serverInfo    */
specifier|public
name|void
name|regionOnline
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|,
name|HServerInfo
name|serverInfo
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|regionsInTransition
init|)
block|{
name|RegionState
name|rs
init|=
name|this
operator|.
name|regionsInTransition
operator|.
name|remove
argument_list|(
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|regionsInTransition
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Asked online a region that was already in "
operator|+
literal|"regionsInTransition: "
operator|+
name|rs
argument_list|)
expr_stmt|;
block|}
block|}
synchronized|synchronized
init|(
name|this
operator|.
name|regions
init|)
block|{
comment|// Add check
name|HServerInfo
name|hsi
init|=
name|this
operator|.
name|regions
operator|.
name|get
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|hsi
operator|!=
literal|null
condition|)
name|LOG
operator|.
name|warn
argument_list|(
literal|"Overwriting "
operator|+
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" on "
operator|+
name|hsi
argument_list|)
expr_stmt|;
name|this
operator|.
name|regions
operator|.
name|put
argument_list|(
name|regionInfo
argument_list|,
name|serverInfo
argument_list|)
expr_stmt|;
name|addToServers
argument_list|(
name|serverInfo
argument_list|,
name|regionInfo
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Marks the region as offline.  Removes it from regions in transition and    * removes in-memory assignment information.    *<p>    * Used when a region has been closed and should remain closed.    * @param regionInfo    * @param serverInfo    */
specifier|public
name|void
name|regionOffline
parameter_list|(
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|regionsInTransition
init|)
block|{
if|if
condition|(
name|this
operator|.
name|regionsInTransition
operator|.
name|remove
argument_list|(
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|regionsInTransition
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
synchronized|synchronized
init|(
name|this
operator|.
name|regions
init|)
block|{
name|HServerInfo
name|serverInfo
init|=
name|this
operator|.
name|regions
operator|.
name|remove
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|serverInfo
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|serverRegions
init|=
name|this
operator|.
name|servers
operator|.
name|get
argument_list|(
name|serverInfo
argument_list|)
decl_stmt|;
name|serverRegions
operator|.
name|remove
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Asked offline a region that was not online: "
operator|+
name|regionInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Sets the region as offline by removing in-memory assignment information but    * retaining transition information.    *<p>    * Used when a region has been closed but should be reassigned.    * @param regionInfo    */
specifier|public
name|void
name|setOffline
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
synchronized|synchronized
init|(
name|regions
init|)
block|{
name|HServerInfo
name|serverInfo
init|=
name|regions
operator|.
name|remove
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|serverRegions
init|=
name|servers
operator|.
name|get
argument_list|(
name|serverInfo
argument_list|)
decl_stmt|;
name|serverRegions
operator|.
name|remove
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Assignment methods
comment|/**    * Assigns the specified region.    *<p>    * If a RegionPlan is available with a valid destination then it will be used    * to determine what server region is assigned to.  If no RegionPlan is    * available, region will be assigned to a random available server.    *<p>    * Updates the RegionState and sends the OPEN RPC.    *<p>    * This will only succeed if the region is in transition and in a CLOSED or    * OFFLINE state or not in transition (in-memory not zk), and of course, the    * chosen server is up and running (It may have just crashed!).  If the    * in-memory checks pass, the zk node is forced to OFFLINE before assigning.    *    * @param regionName server to be assigned    */
specifier|public
name|void
name|assign
parameter_list|(
name|HRegionInfo
name|region
parameter_list|)
block|{
comment|// Grab the state of this region and synchronize on it
name|String
name|encodedName
init|=
name|region
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
name|RegionState
name|state
decl_stmt|;
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
name|state
operator|=
name|regionsInTransition
operator|.
name|get
argument_list|(
name|encodedName
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
name|state
operator|=
operator|new
name|RegionState
argument_list|(
name|region
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|OFFLINE
argument_list|)
expr_stmt|;
name|regionsInTransition
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
block|}
comment|// This here gap between synchronizations looks like a hole but it should
comment|// be ok because the assign below would protect against being called with
comment|// a state instance that is not in the right 'state' -- St.Ack 20100920.
synchronized|synchronized
init|(
name|state
init|)
block|{
name|assign
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Caller must hold lock on the passed<code>state</code> object.    * @param state     */
specifier|private
name|void
name|assign
parameter_list|(
specifier|final
name|RegionState
name|state
parameter_list|)
block|{
if|if
condition|(
operator|!
name|state
operator|.
name|isClosed
argument_list|()
operator|&&
operator|!
name|state
operator|.
name|isOffline
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Attempting to assign region but it is in transition and in "
operator|+
literal|"an unexpected state:"
operator|+
name|state
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|state
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|OFFLINE
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
operator|!
name|ZKAssign
operator|.
name|createOrForceNodeOffline
argument_list|(
name|master
operator|.
name|getZooKeeper
argument_list|()
argument_list|,
name|state
operator|.
name|getRegion
argument_list|()
argument_list|,
name|master
operator|.
name|getServerName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Attempted to create/force node into OFFLINE state before "
operator|+
literal|"completing assignment but failed to do so"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|master
operator|.
name|abort
argument_list|(
literal|"Unexpected ZK exception creating/setting node OFFLINE"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Pickup existing plan or make a new one
name|String
name|encodedName
init|=
name|state
operator|.
name|getRegion
argument_list|()
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
name|RegionPlan
name|plan
decl_stmt|;
synchronized|synchronized
init|(
name|regionPlans
init|)
block|{
name|plan
operator|=
name|regionPlans
operator|.
name|get
argument_list|(
name|encodedName
argument_list|)
expr_stmt|;
if|if
condition|(
name|plan
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No previous transition plan for "
operator|+
name|state
operator|.
name|getRegion
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" so generating a random one; "
operator|+
name|serverManager
operator|.
name|countOfRegionServers
argument_list|()
operator|+
literal|" (online="
operator|+
name|serverManager
operator|.
name|getOnlineServers
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|") available servers"
argument_list|)
expr_stmt|;
name|plan
operator|=
operator|new
name|RegionPlan
argument_list|(
name|state
operator|.
name|getRegion
argument_list|()
argument_list|,
literal|null
argument_list|,
name|LoadBalancer
operator|.
name|randomAssignment
argument_list|(
name|serverManager
operator|.
name|getOnlineServersList
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|regionPlans
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|plan
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using preexisting plan="
operator|+
name|plan
argument_list|)
expr_stmt|;
block|}
block|}
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Assigning region "
operator|+
name|state
operator|.
name|getRegion
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" to "
operator|+
name|plan
operator|.
name|getDestination
argument_list|()
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Send OPEN RPC. This can fail if the server on other end is is not up.
name|serverManager
operator|.
name|sendRegionOpen
argument_list|(
name|plan
operator|.
name|getDestination
argument_list|()
argument_list|,
name|state
operator|.
name|getRegion
argument_list|()
argument_list|)
expr_stmt|;
comment|// Transition RegionState to PENDING_OPEN
name|state
operator|.
name|update
argument_list|(
name|RegionState
operator|.
name|State
operator|.
name|PENDING_OPEN
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed assignment of "
operator|+
name|state
operator|.
name|getRegion
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" to "
operator|+
name|plan
operator|.
name|getDestination
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|// Clean out plan we failed execute and one that doesn't look like it'll
comment|// succeed anyways; we need a new plan!
synchronized|synchronized
init|(
name|regionPlans
init|)
block|{
name|this
operator|.
name|regionPlans
operator|.
name|remove
argument_list|(
name|encodedName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Unassigns the specified region.    *<p>    * Updates the RegionState and sends the CLOSE RPC.    *<p>    * If a RegionPlan is already set, it will remain.  If this is being used    * to disable a table, be sure to use {@link #disableTable(String)} to ensure    * regions are not onlined after being closed.    *    * @param regionName server to be unassigned    */
specifier|public
name|void
name|unassign
parameter_list|(
name|HRegionInfo
name|region
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Starting unassignment of region "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" (offlining)"
argument_list|)
expr_stmt|;
comment|// Check if this region is currently assigned
if|if
condition|(
operator|!
name|regions
operator|.
name|containsKey
argument_list|(
name|region
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempted to unassign region "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" but it is not "
operator|+
literal|"currently assigned anywhere"
argument_list|)
expr_stmt|;
return|return;
block|}
name|String
name|encodedName
init|=
name|region
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
comment|// Grab the state of this region and synchronize on it
name|RegionState
name|state
decl_stmt|;
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
name|state
operator|=
name|regionsInTransition
operator|.
name|get
argument_list|(
name|encodedName
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
name|state
operator|=
operator|new
name|RegionState
argument_list|(
name|region
argument_list|,
name|RegionState
operator|.
name|State
operator|.
name|PENDING_CLOSE
argument_list|)
expr_stmt|;
name|regionsInTransition
operator|.
name|put
argument_list|(
name|encodedName
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempting to unassign region "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" but it is "
operator|+
literal|"already in transition ("
operator|+
name|state
operator|.
name|getState
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// Send CLOSE RPC
try|try
block|{
name|serverManager
operator|.
name|sendRegionClose
argument_list|(
name|regions
operator|.
name|get
argument_list|(
name|region
argument_list|)
argument_list|,
name|state
operator|.
name|getRegion
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotServingRegionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Attempted to close region "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" but got an NSRE"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Waits until the specified region has completed assignment.    *<p>    * If the region is already assigned, returns immediately.  Otherwise, method    * blocks until the region is assigned.    * @param regionInfo region to wait on assignment for    * @throws InterruptedException    */
specifier|public
name|void
name|waitForAssignment
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|InterruptedException
block|{
synchronized|synchronized
init|(
name|regions
init|)
block|{
while|while
condition|(
operator|!
name|regions
operator|.
name|containsKey
argument_list|(
name|regionInfo
argument_list|)
condition|)
block|{
name|regions
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Assigns the ROOT region.    *<p>    * Assumes that ROOT is currently closed and is not being actively served by    * any RegionServer.    *<p>    * Forcibly unsets the current root region location in ZooKeeper and assigns    * ROOT to a random RegionServer.    * @throws KeeperException     */
specifier|public
name|void
name|assignRoot
parameter_list|()
throws|throws
name|KeeperException
block|{
name|RootLocationEditor
operator|.
name|deleteRootLocation
argument_list|(
name|this
operator|.
name|master
operator|.
name|getZooKeeper
argument_list|()
argument_list|)
expr_stmt|;
name|assign
argument_list|(
name|HRegionInfo
operator|.
name|ROOT_REGIONINFO
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assigns the META region.    *<p>    * Assumes that META is currently closed and is not being actively served by    * any RegionServer.    *<p>    * Forcibly assigns META to a random RegionServer.    */
specifier|public
name|void
name|assignMeta
parameter_list|()
block|{
comment|// Force assignment to a random server
name|assign
argument_list|(
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assigns all user regions, if any exist.  Used during cluster startup.    *<p>    * This is a synchronous call and will return once every region has been    * assigned.  If anything fails, an exception is thrown and the cluster    * should be shutdown.    */
specifier|public
name|void
name|assignAllUserRegions
parameter_list|()
throws|throws
name|IOException
block|{
comment|// First experiment at synchronous assignment
comment|// Simpler because just wait for no regions in transition
comment|// Scan META for all user regions
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|allRegions
init|=
name|MetaScanner
operator|.
name|listAllRegions
argument_list|(
name|master
operator|.
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|allRegions
operator|==
literal|null
operator|||
name|allRegions
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|// Get all available servers
name|List
argument_list|<
name|HServerInfo
argument_list|>
name|servers
init|=
name|serverManager
operator|.
name|getOnlineServersList
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Assigning "
operator|+
name|allRegions
operator|.
name|size
argument_list|()
operator|+
literal|" region(s) across "
operator|+
name|servers
operator|.
name|size
argument_list|()
operator|+
literal|" server(s)"
argument_list|)
expr_stmt|;
comment|// Generate a cluster startup region placement plan
name|Map
argument_list|<
name|HServerInfo
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|bulkPlan
init|=
name|LoadBalancer
operator|.
name|bulkAssignment
argument_list|(
name|allRegions
argument_list|,
name|servers
argument_list|)
decl_stmt|;
comment|// Now start a thread per server to run assignment.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|HServerInfo
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|entry
range|:
name|bulkPlan
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Thread
name|t
init|=
operator|new
name|BulkAssignServer
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|this
operator|.
name|master
argument_list|)
decl_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|// Wait for no regions to be in transition
try|try
block|{
name|waitUntilNoRegionsInTransition
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Interrupted waiting for regions to be assigned"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"All user regions have been assigned"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Class to run bulk assign to a single server.    */
class|class
name|BulkAssignServer
extends|extends
name|Thread
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
decl_stmt|;
specifier|private
specifier|final
name|HServerInfo
name|server
decl_stmt|;
specifier|private
specifier|final
name|Stoppable
name|stopper
decl_stmt|;
name|BulkAssignServer
parameter_list|(
specifier|final
name|HServerInfo
name|server
parameter_list|,
specifier|final
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
parameter_list|,
specifier|final
name|Stoppable
name|stopper
parameter_list|)
block|{
name|super
argument_list|(
literal|"serverassign-"
operator|+
name|server
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|server
operator|=
name|server
expr_stmt|;
name|this
operator|.
name|regions
operator|=
name|regions
expr_stmt|;
name|this
operator|.
name|stopper
operator|=
name|stopper
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// Insert a plan for each region with 'server' as the target regionserver.
comment|// Below, we run through regions one at a time.  The call to assign will
comment|// move the region into the regionsInTransition which starts up a timer.
comment|// if the region is not out of the regionsInTransition by a certain time,
comment|// it will be reassigned.  We don't want that to happen.  So, do it this
comment|// way a region at a time for now.  Presumably the regionserver will put
comment|// up a back pressure if opening a region takes time which is good since
comment|// this will block our adding new regions to regionsInTransition.  Later
comment|// make it so we can send over a lump of regions in one rpc with the
comment|// regionserver on remote side tickling zk on a period to prevent our
comment|// regionsInTransition timing out.  Currently its not possible given the
comment|// Executor architecture on the regionserver side.  St.Ack 20100920.
for|for
control|(
name|HRegionInfo
name|region
range|:
name|regions
control|)
block|{
name|regionPlans
operator|.
name|put
argument_list|(
name|region
operator|.
name|getEncodedName
argument_list|()
argument_list|,
operator|new
name|RegionPlan
argument_list|(
name|region
argument_list|,
literal|null
argument_list|,
name|server
argument_list|)
argument_list|)
expr_stmt|;
name|assign
argument_list|(
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|stopper
operator|.
name|isStopped
argument_list|()
condition|)
break|break;
block|}
block|}
block|}
specifier|private
name|void
name|rebuildUserRegions
parameter_list|()
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerAddress
argument_list|>
name|allRegions
init|=
name|MetaReader
operator|.
name|fullScan
argument_list|(
name|catalogTracker
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerAddress
argument_list|>
name|region
range|:
name|allRegions
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|HServerAddress
name|regionLocation
init|=
name|region
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|HRegionInfo
name|regionInfo
init|=
name|region
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|regionLocation
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|regions
operator|.
name|put
argument_list|(
name|regionInfo
argument_list|,
literal|null
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|HServerInfo
name|serverInfo
init|=
name|serverManager
operator|.
name|getHServerInfo
argument_list|(
name|regionLocation
argument_list|)
decl_stmt|;
name|regions
operator|.
name|put
argument_list|(
name|regionInfo
argument_list|,
name|serverInfo
argument_list|)
expr_stmt|;
name|addToServers
argument_list|(
name|serverInfo
argument_list|,
name|regionInfo
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Presumes caller has taken care of necessary locking modifying servers Map.    * @param hsi    * @param hri    */
specifier|private
name|void
name|addToServers
parameter_list|(
specifier|final
name|HServerInfo
name|hsi
parameter_list|,
specifier|final
name|HRegionInfo
name|hri
parameter_list|)
block|{
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|hris
init|=
name|servers
operator|.
name|get
argument_list|(
name|hsi
argument_list|)
decl_stmt|;
if|if
condition|(
name|hris
operator|==
literal|null
condition|)
block|{
name|hris
operator|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
expr_stmt|;
name|servers
operator|.
name|put
argument_list|(
name|hsi
argument_list|,
name|hris
argument_list|)
expr_stmt|;
block|}
name|hris
operator|.
name|add
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
comment|/**    * Blocks until there are no regions in transition.  It is possible that there    * are regions in transition immediately after this returns but guarantees    * that if it returns without an exception that there was a period of time    * with no regions in transition from the point-of-view of the in-memory    * state of the Master.    * @throws InterruptedException    */
specifier|public
name|void
name|waitUntilNoRegionsInTransition
parameter_list|()
throws|throws
name|InterruptedException
block|{
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
while|while
condition|(
name|regionsInTransition
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|regionsInTransition
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * @return A copy of the Map of regions currently in transition.    */
specifier|public
name|NavigableMap
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
name|getRegionsInTransition
parameter_list|()
block|{
return|return
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
argument_list|(
name|this
operator|.
name|regionsInTransition
argument_list|)
return|;
block|}
comment|/**    * @return True if regions in transition.    */
specifier|public
name|boolean
name|isRegionsInTransition
parameter_list|()
block|{
return|return
operator|!
name|this
operator|.
name|regionsInTransition
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/**    * Checks if the specified table has been disabled by the user.    * @param tableName    * @return    */
specifier|public
name|boolean
name|isTableDisabled
parameter_list|(
name|String
name|tableName
parameter_list|)
block|{
synchronized|synchronized
init|(
name|disabledTables
init|)
block|{
return|return
name|disabledTables
operator|.
name|contains
argument_list|(
name|tableName
argument_list|)
return|;
block|}
block|}
comment|/**    * Checks if the table of the specified region has been disabled by the user.    * @param regionName    * @return    */
specifier|public
name|boolean
name|isTableOfRegionDisabled
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|)
block|{
return|return
name|isTableDisabled
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|HRegionInfo
operator|.
name|getTableName
argument_list|(
name|regionName
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Sets the specified table to be disabled.    * @param tableName table to be disabled    */
specifier|public
name|void
name|disableTable
parameter_list|(
name|String
name|tableName
parameter_list|)
block|{
synchronized|synchronized
init|(
name|disabledTables
init|)
block|{
if|if
condition|(
operator|!
name|isTableDisabled
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|disabledTables
operator|.
name|add
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
try|try
block|{
name|ZKTableDisable
operator|.
name|disableTable
argument_list|(
name|master
operator|.
name|getZooKeeper
argument_list|()
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"ZK error setting table as disabled"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Unsets the specified table from being disabled.    *<p>    * This operation only acts on the in-memory    * @param tableName table to be undisabled    */
specifier|public
name|void
name|undisableTable
parameter_list|(
name|String
name|tableName
parameter_list|)
block|{
synchronized|synchronized
init|(
name|disabledTables
init|)
block|{
if|if
condition|(
name|isTableDisabled
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|disabledTables
operator|.
name|remove
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
try|try
block|{
name|ZKTableDisable
operator|.
name|undisableTable
argument_list|(
name|master
operator|.
name|getZooKeeper
argument_list|()
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"ZK error setting table as disabled"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Rebuild the set of disabled tables from zookeeper.  Used during master    * failover.    */
specifier|private
name|void
name|rebuildDisabledTables
parameter_list|()
block|{
synchronized|synchronized
init|(
name|disabledTables
init|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|disabledTables
decl_stmt|;
try|try
block|{
name|disabledTables
operator|=
name|ZKTableDisable
operator|.
name|getDisabledTables
argument_list|(
name|master
operator|.
name|getZooKeeper
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"ZK error getting list of disabled tables"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|disabledTables
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Rebuilt list of "
operator|+
name|disabledTables
operator|.
name|size
argument_list|()
operator|+
literal|" disabled "
operator|+
literal|"tables from zookeeper"
argument_list|)
expr_stmt|;
name|disabledTables
operator|.
name|addAll
argument_list|(
name|disabledTables
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Gets the online regions of the specified table.    * @param tableName    * @return    */
specifier|public
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|getRegionsOfTable
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|)
block|{
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|tableRegions
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|HRegionInfo
name|regionInfo
range|:
name|regions
operator|.
name|tailMap
argument_list|(
operator|new
name|HRegionInfo
argument_list|(
operator|new
name|HTableDescriptor
argument_list|(
name|tableName
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|regionInfo
operator|.
name|getTableDesc
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|tableName
argument_list|)
condition|)
block|{
name|tableRegions
operator|.
name|add
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
return|return
name|tableRegions
return|;
block|}
comment|/**    * Unsets the specified table as disabled (enables it).    */
specifier|public
class|class
name|TimeoutMonitor
extends|extends
name|Chore
block|{
specifier|private
specifier|final
name|int
name|timeout
decl_stmt|;
comment|/**      * Creates a periodic monitor to check for time outs on region transition      * operations.  This will deal with retries if for some reason something      * doesn't happen within the specified timeout.      * @param period    * @param stopper When {@link Stoppable#isStopped()} is true, this thread will    * cleanup and exit cleanly.      * @param timeout      */
specifier|public
name|TimeoutMonitor
parameter_list|(
specifier|final
name|int
name|period
parameter_list|,
specifier|final
name|Stoppable
name|stopper
parameter_list|,
specifier|final
name|int
name|timeout
parameter_list|)
block|{
name|super
argument_list|(
literal|"AssignmentTimeoutMonitor"
argument_list|,
name|period
argument_list|,
name|stopper
argument_list|)
expr_stmt|;
name|this
operator|.
name|timeout
operator|=
name|timeout
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|chore
parameter_list|()
block|{
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
comment|// Iterate all regions in transition checking for time outs
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
for|for
control|(
name|RegionState
name|regionState
range|:
name|regionsInTransition
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|regionState
operator|.
name|getStamp
argument_list|()
operator|+
name|timeout
operator|<=
name|now
condition|)
block|{
name|HRegionInfo
name|regionInfo
init|=
name|regionState
operator|.
name|getRegion
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Regions in transition timed out:  "
operator|+
name|regionState
argument_list|)
expr_stmt|;
comment|// Expired!  Do a retry.
switch|switch
condition|(
name|regionState
operator|.
name|getState
argument_list|()
condition|)
block|{
case|case
name|OFFLINE
case|:
case|case
name|CLOSED
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Region has been OFFLINE or CLOSED for too long, "
operator|+
literal|"reassigning "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
name|assign
argument_list|(
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|PENDING_OPEN
case|:
case|case
name|OPENING
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Region has been PENDING_OPEN or OPENING for too "
operator|+
literal|"long, reassigning region="
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
name|assign
argument_list|(
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPEN
case|:
name|LOG
operator|.
name|warn
argument_list|(
literal|"Long-running region in OPEN state?  This should "
operator|+
literal|"not happen; region="
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|PENDING_CLOSE
case|:
case|case
name|CLOSING
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Region has been PENDING_CLOSE or CLOSING for too "
operator|+
literal|"long, running unassign again on region="
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
name|unassign
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/**    * Process shutdown server removing any assignments.    * @param hsi Server that went down.    */
specifier|public
name|void
name|processServerShutdown
parameter_list|(
specifier|final
name|HServerInfo
name|hsi
parameter_list|)
block|{
comment|// Clean out any exisiting assignment plans for this server
synchronized|synchronized
init|(
name|this
operator|.
name|regionPlans
init|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
argument_list|>
name|i
init|=
name|this
operator|.
name|regionPlans
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RegionPlan
argument_list|>
name|e
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getDestination
argument_list|()
operator|.
name|equals
argument_list|(
name|hsi
argument_list|)
condition|)
block|{
comment|// Use iterator's remove else we'll get CME
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// Remove assignment info related to the downed server.  Remove the downed
comment|// server from list of servers else it looks like a server w/ no load.
synchronized|synchronized
init|(
name|this
operator|.
name|regions
init|)
block|{
name|Set
argument_list|<
name|HRegionInfo
argument_list|>
name|hris
init|=
operator|new
name|HashSet
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerInfo
argument_list|>
name|e
range|:
name|this
operator|.
name|regions
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|// Add to a Set -- don't call setOffline in here else we get a CME.
if|if
condition|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
name|hsi
argument_list|)
condition|)
name|hris
operator|.
name|add
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|HRegionInfo
name|hri
range|:
name|hris
control|)
name|setOffline
argument_list|(
name|hri
argument_list|)
expr_stmt|;
name|this
operator|.
name|servers
operator|.
name|remove
argument_list|(
name|hsi
argument_list|)
expr_stmt|;
block|}
comment|// If anything in transition related to the server, clean it up.
synchronized|synchronized
init|(
name|regionsInTransition
init|)
block|{
comment|// Iterate all regions in transition checking if were on this server
specifier|final
name|String
name|serverName
init|=
name|hsi
operator|.
name|getServerName
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RegionState
argument_list|>
name|e
range|:
name|this
operator|.
name|regionsInTransition
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|equals
argument_list|(
name|serverName
argument_list|)
condition|)
continue|continue;
name|RegionState
name|regionState
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|regionState
operator|.
name|getState
argument_list|()
condition|)
block|{
case|case
name|PENDING_OPEN
case|:
case|case
name|OPENING
case|:
case|case
name|OFFLINE
case|:
case|case
name|CLOSED
case|:
case|case
name|PENDING_CLOSE
case|:
case|case
name|CLOSING
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Region "
operator|+
name|regionState
operator|.
name|getRegion
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" was in state="
operator|+
name|regionState
operator|.
name|getState
argument_list|()
operator|+
literal|" on shutdown server="
operator|+
name|serverName
operator|+
literal|", reassigning"
argument_list|)
expr_stmt|;
name|assign
argument_list|(
name|regionState
operator|.
name|getRegion
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPEN
case|:
name|LOG
operator|.
name|warn
argument_list|(
literal|"Long-running region in OPEN state?  Should not happen"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/**    * Update inmemory structures.    * @param hsi Server that reported the split    * @param parent Parent region that was split    * @param a Daughter region A    * @param b Daughter region B    */
specifier|public
name|void
name|handleSplitReport
parameter_list|(
specifier|final
name|HServerInfo
name|hsi
parameter_list|,
specifier|final
name|HRegionInfo
name|parent
parameter_list|,
specifier|final
name|HRegionInfo
name|a
parameter_list|,
specifier|final
name|HRegionInfo
name|b
parameter_list|)
block|{
name|regionOffline
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|regionOnline
argument_list|(
name|a
argument_list|,
name|hsi
argument_list|)
expr_stmt|;
name|regionOnline
argument_list|(
name|b
argument_list|,
name|hsi
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return A clone of current assignments. Note, this is assignments only.    * If a new server has come in and it has no regions, it will not be included    * in the returned Map.    */
name|Map
argument_list|<
name|HServerInfo
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|getAssignments
parameter_list|()
block|{
comment|// This is an EXPENSIVE clone.  Cloning though is the safest thing to do.
comment|// Can't let out original since it can change and at least the loadbalancer
comment|// wants to iterate this exported list.  We need to synchronize on regions
comment|// since all access to this.servers is under a lock on this.regions.
name|Map
argument_list|<
name|HServerInfo
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|result
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|regions
init|)
block|{
name|result
operator|=
operator|new
name|HashMap
argument_list|<
name|HServerInfo
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
argument_list|(
name|this
operator|.
name|servers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|HServerInfo
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|e
range|:
name|this
operator|.
name|servers
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|shallowCopy
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|HServerInfo
name|clone
init|=
operator|new
name|HServerInfo
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
comment|// Set into server load the number of regions this server is carrying
comment|// The load balancer calculation needs it at least and its handy.
name|clone
operator|.
name|getLoad
argument_list|()
operator|.
name|setNumberOfRegions
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|.
name|put
argument_list|(
name|clone
argument_list|,
name|shallowCopy
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**    * @param encodedRegionName Region encoded name.    * @return Null or a {@link Pair} instance that holds the full {@link HRegionInfo}    * and the hosting servers {@link HServerInfo}.    */
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerInfo
argument_list|>
name|getAssignment
parameter_list|(
specifier|final
name|byte
index|[]
name|encodedRegionName
parameter_list|)
block|{
name|String
name|name
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|encodedRegionName
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|regions
init|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerInfo
argument_list|>
name|e
range|:
name|this
operator|.
name|regions
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|getEncodedName
argument_list|()
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
operator|new
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerInfo
argument_list|>
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * @param plan Plan to execute.    */
name|void
name|balance
parameter_list|(
specifier|final
name|RegionPlan
name|plan
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|regionPlans
init|)
block|{
name|this
operator|.
name|regionPlans
operator|.
name|put
argument_list|(
name|plan
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|plan
argument_list|)
expr_stmt|;
block|}
name|unassign
argument_list|(
name|plan
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
class|class
name|RegionState
implements|implements
name|Writable
block|{
specifier|private
name|HRegionInfo
name|region
decl_stmt|;
specifier|public
enum|enum
name|State
block|{
name|OFFLINE
block|,
comment|// region is in an offline state
name|PENDING_OPEN
block|,
comment|// sent rpc to server to open but has not begun
name|OPENING
block|,
comment|// server has begun to open but not yet done
name|OPEN
block|,
comment|// server opened region and updated meta
name|PENDING_CLOSE
block|,
comment|// sent rpc to server to close but has not begun
name|CLOSING
block|,
comment|// server has begun to close but not yet done
name|CLOSED
comment|// server closed region and updated meta
block|}
specifier|private
name|State
name|state
decl_stmt|;
specifier|private
name|long
name|stamp
decl_stmt|;
specifier|public
name|RegionState
parameter_list|()
block|{}
name|RegionState
parameter_list|(
name|HRegionInfo
name|region
parameter_list|,
name|State
name|state
parameter_list|)
block|{
name|this
argument_list|(
name|region
argument_list|,
name|state
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|RegionState
parameter_list|(
name|HRegionInfo
name|region
parameter_list|,
name|State
name|state
parameter_list|,
name|long
name|stamp
parameter_list|)
block|{
name|this
operator|.
name|region
operator|=
name|region
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
name|this
operator|.
name|stamp
operator|=
name|stamp
expr_stmt|;
block|}
specifier|public
name|void
name|update
parameter_list|(
name|State
name|state
parameter_list|,
name|long
name|stamp
parameter_list|)
block|{
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
name|this
operator|.
name|stamp
operator|=
name|stamp
expr_stmt|;
block|}
specifier|public
name|void
name|update
parameter_list|(
name|State
name|state
parameter_list|)
block|{
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
name|this
operator|.
name|stamp
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
specifier|public
name|State
name|getState
parameter_list|()
block|{
return|return
name|state
return|;
block|}
specifier|public
name|long
name|getStamp
parameter_list|()
block|{
return|return
name|stamp
return|;
block|}
specifier|public
name|HRegionInfo
name|getRegion
parameter_list|()
block|{
return|return
name|region
return|;
block|}
specifier|public
name|boolean
name|isClosing
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|CLOSING
return|;
block|}
specifier|public
name|boolean
name|isClosed
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|CLOSED
return|;
block|}
specifier|public
name|boolean
name|isPendingClose
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|PENDING_CLOSE
return|;
block|}
specifier|public
name|boolean
name|isOpening
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|OPENING
return|;
block|}
specifier|public
name|boolean
name|isOpened
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|OPEN
return|;
block|}
specifier|public
name|boolean
name|isPendingOpen
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|PENDING_OPEN
return|;
block|}
specifier|public
name|boolean
name|isOffline
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|OFFLINE
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" state="
operator|+
name|state
operator|+
literal|", ts="
operator|+
name|stamp
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|region
operator|=
operator|new
name|HRegionInfo
argument_list|()
expr_stmt|;
name|region
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|state
operator|=
name|State
operator|.
name|valueOf
argument_list|(
name|in
operator|.
name|readUTF
argument_list|()
argument_list|)
expr_stmt|;
name|stamp
operator|=
name|in
operator|.
name|readLong
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|region
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeUTF
argument_list|(
name|state
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeLong
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

