begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2010 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Chore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ClusterStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HColumnDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HMsg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerAddress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MasterNotRunningException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NotAllMetaRegionsOnlineException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotDisabledException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|UnknownRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|CatalogTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|MetaEditor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|MetaReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|HConnection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|HConnectionManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MetaScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MetaScanner
operator|.
name|MetaScannerVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|ExecutorService
operator|.
name|ExecutorType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HBaseRPC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HBaseRPCProtocolVersion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HBaseServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HMasterInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HMasterRegionInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|RpcServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|LoadBalancer
operator|.
name|RegionPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|DeleteTableHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|DisableTableHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|EnableTableHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|ModifyTableHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|TableAddFamilyHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|TableDeleteFamilyHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|TableModifyFamilyHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|metrics
operator|.
name|MasterMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|InfoServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Sleeper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|VersionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ClusterStatusTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|RegionServerTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|MapWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|DNS
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|Watcher
import|;
end_import

begin_comment
comment|/**  * HMaster is the "master server" for HBase. An HBase cluster has one active  * master.  If many masters are started, all compete.  Whichever wins goes on to  * run the cluster.  All others park themselves in their constructor until  * master or cluster shutdown or until the active master loses its lease in  * zookeeper.  Thereafter, all running master jostle to take over master role.  *  *<p>The Master can be asked shutdown the cluster. See {@link #shutdown()}.  In  * this case it will tell all regionservers to go down and then wait on them  * all reporting in that they are down.  This master will then shut itself down.  *  *<p>You can also shutdown just this master.  Call {@link #stopMaster()}.  *  * @see HMasterInterface  * @see HMasterRegionInterface  * @see Watcher  */
end_comment

begin_class
specifier|public
class|class
name|HMaster
extends|extends
name|Thread
implements|implements
name|HMasterInterface
implements|,
name|HMasterRegionInterface
implements|,
name|MasterServices
implements|,
name|Server
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HMaster
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|// MASTER is name of the webapp and the attribute name used stuffing this
comment|//instance into web context.
specifier|public
specifier|static
specifier|final
name|String
name|MASTER
init|=
literal|"master"
decl_stmt|;
comment|// The configuration for the Master
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
comment|// server for the web ui
specifier|private
name|InfoServer
name|infoServer
decl_stmt|;
comment|// Our zk client.
specifier|private
name|ZooKeeperWatcher
name|zooKeeper
decl_stmt|;
comment|// Manager and zk listener for master election
specifier|private
name|ActiveMasterManager
name|activeMasterManager
decl_stmt|;
comment|// Region server tracker
specifier|private
name|RegionServerTracker
name|regionServerTracker
decl_stmt|;
comment|// RPC server for the HMaster
specifier|private
specifier|final
name|RpcServer
name|rpcServer
decl_stmt|;
comment|// Address of the HMaster
specifier|private
specifier|final
name|HServerAddress
name|address
decl_stmt|;
comment|// Metrics for the HMaster
specifier|private
specifier|final
name|MasterMetrics
name|metrics
decl_stmt|;
comment|// file system manager for the master FS operations
specifier|private
name|MasterFileSystem
name|fileSystemManager
decl_stmt|;
specifier|private
name|HConnection
name|connection
decl_stmt|;
comment|// server manager to deal with region server info
specifier|private
name|ServerManager
name|serverManager
decl_stmt|;
comment|// manager of assignment nodes in zookeeper
name|AssignmentManager
name|assignmentManager
decl_stmt|;
comment|// manager of catalog regions
specifier|private
name|CatalogTracker
name|catalogTracker
decl_stmt|;
comment|// Cluster status zk tracker and local setter
specifier|private
name|ClusterStatusTracker
name|clusterStatusTracker
decl_stmt|;
comment|// This flag is for stopping this Master instance.  Its set when we are
comment|// stopping or aborting
specifier|private
specifier|volatile
name|boolean
name|stopped
init|=
literal|false
decl_stmt|;
comment|// Set on abort -- usually failure of our zk session.
specifier|private
specifier|volatile
name|boolean
name|abort
init|=
literal|false
decl_stmt|;
comment|// flag set after we become the active master (used for testing)
specifier|private
specifier|volatile
name|boolean
name|isActiveMaster
init|=
literal|false
decl_stmt|;
comment|// flag set after we complete initialization once active (used for testing)
specifier|private
specifier|volatile
name|boolean
name|isInitialized
init|=
literal|false
decl_stmt|;
comment|// Instance of the hbase executor service.
name|ExecutorService
name|executorService
decl_stmt|;
specifier|private
name|LoadBalancer
name|balancer
init|=
operator|new
name|LoadBalancer
argument_list|()
decl_stmt|;
specifier|private
name|Thread
name|balancerChore
decl_stmt|;
comment|// If 'true', the balancer is 'on'.  If 'false', the balancer will not run.
specifier|private
specifier|volatile
name|boolean
name|balanceSwitch
init|=
literal|true
decl_stmt|;
specifier|private
name|Thread
name|catalogJanitorChore
decl_stmt|;
specifier|private
name|LogCleaner
name|logCleaner
decl_stmt|;
comment|/**    * Initializes the HMaster. The steps are as follows:    *<p>    *<ol>    *<li>Initialize HMaster RPC and address    *<li>Connect to ZooKeeper.    *</ol>    *<p>    * Remaining steps of initialization occur in {@link #run()} so that they    * run in their own thread rather than within the context of the constructor.    * @throws InterruptedException    */
specifier|public
name|HMaster
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
throws|,
name|KeeperException
throws|,
name|InterruptedException
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
comment|/*      * Determine address and initialize RPC server (but do not start).      * The RPC server ports can be ephemeral. Create a ZKW instance.      */
name|HServerAddress
name|a
init|=
operator|new
name|HServerAddress
argument_list|(
name|getMyAddress
argument_list|(
name|this
operator|.
name|conf
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|numHandlers
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.handler.count"
argument_list|,
literal|25
argument_list|)
decl_stmt|;
name|this
operator|.
name|rpcServer
operator|=
name|HBaseRPC
operator|.
name|getServer
argument_list|(
name|this
argument_list|,
operator|new
name|Class
argument_list|<
name|?
argument_list|>
index|[]
block|{
name|HMasterInterface
operator|.
name|class
operator|,
name|HMasterRegionInterface
operator|.
name|class
block|}
operator|,
name|a
operator|.
name|getBindAddress
argument_list|()
operator|,
name|a
operator|.
name|getPort
argument_list|()
operator|,
name|numHandlers
operator|,
literal|0
operator|,
comment|// we dont use high priority handlers in master
literal|false
operator|,
name|conf
operator|,
literal|0
block|)
empty_stmt|;
comment|// this is a DNC w/o high priority handlers
name|this
operator|.
name|address
operator|=
operator|new
name|HServerAddress
argument_list|(
name|rpcServer
operator|.
name|getListenerAddress
argument_list|()
argument_list|)
expr_stmt|;
comment|// set the thread name now we have an address
name|setName
argument_list|(
name|MASTER
operator|+
literal|"-"
operator|+
name|this
operator|.
name|address
argument_list|)
expr_stmt|;
name|this
operator|.
name|rpcServer
operator|.
name|startThreads
parameter_list|()
constructor_decl|;
comment|// Hack! Maps DFSClient => Master for logs.  HDFS made this
comment|// config param for task trackers, but we can piggyback off of it.
if|if
condition|(
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
literal|"mapred.task.id"
argument_list|)
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|conf
operator|.
name|set
argument_list|(
literal|"mapred.task.id"
argument_list|,
literal|"hb_m_"
operator|+
name|this
operator|.
name|address
operator|.
name|toString
argument_list|()
operator|+
literal|"_"
operator|+
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|zooKeeper
operator|=
operator|new
name|ZooKeeperWatcher
argument_list|(
name|conf
argument_list|,
name|MASTER
operator|+
literal|":"
operator|+
name|address
operator|.
name|getPort
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|=
operator|new
name|MasterMetrics
argument_list|(
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_class

begin_comment
comment|/**    * Stall startup if we are designated a backup master; i.e. we want someone    * else to become the master before proceeding.    * @param c    * @param amm    * @throws InterruptedException    */
end_comment

begin_function
specifier|private
specifier|static
name|void
name|stallIfBackupMaster
parameter_list|(
specifier|final
name|Configuration
name|c
parameter_list|,
specifier|final
name|ActiveMasterManager
name|amm
parameter_list|)
throws|throws
name|InterruptedException
block|{
comment|// If we're a backup master, stall until a primary to writes his address
if|if
condition|(
operator|!
name|c
operator|.
name|getBoolean
argument_list|(
name|HConstants
operator|.
name|MASTER_TYPE_BACKUP
argument_list|,
name|HConstants
operator|.
name|DEFAULT_MASTER_TYPE_BACKUP
argument_list|)
condition|)
block|{
return|return;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"HMaster started in backup mode.  "
operator|+
literal|"Stalling until master znode is written."
argument_list|)
expr_stmt|;
comment|// This will only be a minute or so while the cluster starts up,
comment|// so don't worry about setting watches on the parent znode
while|while
condition|(
operator|!
name|amm
operator|.
name|isActiveMaster
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting for master address ZNode to be written "
operator|+
literal|"(Also watching cluster state node)"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|c
operator|.
name|getInt
argument_list|(
literal|"zookeeper.session.timeout"
argument_list|,
literal|180
operator|*
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * Main processing loop for the HMaster.    *<ol>    *<li>Block until becoming active master    *<li>Finish initialization via {@link #finishInitialization()}    *<li>Enter loop until we are stopped    *<li>Stop services and perform cleanup once stopped    *</ol>    */
end_comment

begin_function
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
comment|/*        * Block on becoming the active master.        *        * We race with other masters to write our address into ZooKeeper.  If we        * succeed, we are the primary/active master and finish initialization.        *        * If we do not succeed, there is another active master and we should        * now wait until it dies to try and become the next active master.  If we        * do not succeed on our first attempt, this is no longer a cluster startup.        */
name|this
operator|.
name|activeMasterManager
operator|=
operator|new
name|ActiveMasterManager
argument_list|(
name|zooKeeper
argument_list|,
name|address
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|zooKeeper
operator|.
name|registerListener
argument_list|(
name|activeMasterManager
argument_list|)
expr_stmt|;
name|stallIfBackupMaster
argument_list|(
name|this
operator|.
name|conf
argument_list|,
name|this
operator|.
name|activeMasterManager
argument_list|)
expr_stmt|;
name|this
operator|.
name|activeMasterManager
operator|.
name|blockUntilBecomingActiveMaster
argument_list|()
expr_stmt|;
comment|// We are either the active master or we were asked to shutdown
if|if
condition|(
operator|!
name|this
operator|.
name|stopped
condition|)
block|{
name|finishInitialization
argument_list|()
expr_stmt|;
name|loop
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|abort
argument_list|(
literal|"Unhandled exception. Starting shutdown."
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|stopChores
argument_list|()
expr_stmt|;
comment|// Wait for all the remaining region servers to report in IFF we were
comment|// running a cluster shutdown AND we were NOT aborting.
if|if
condition|(
operator|!
name|this
operator|.
name|abort
operator|&&
name|this
operator|.
name|serverManager
operator|!=
literal|null
operator|&&
name|this
operator|.
name|serverManager
operator|.
name|isClusterShutdown
argument_list|()
condition|)
block|{
name|this
operator|.
name|serverManager
operator|.
name|letRegionServersShutdown
argument_list|()
expr_stmt|;
block|}
name|stopServiceThreads
argument_list|()
expr_stmt|;
comment|// Stop services started for both backup and active masters
if|if
condition|(
name|this
operator|.
name|activeMasterManager
operator|!=
literal|null
condition|)
name|this
operator|.
name|activeMasterManager
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|catalogTracker
operator|!=
literal|null
condition|)
name|this
operator|.
name|catalogTracker
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|serverManager
operator|!=
literal|null
condition|)
name|this
operator|.
name|serverManager
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|assignmentManager
operator|!=
literal|null
condition|)
name|this
operator|.
name|assignmentManager
operator|.
name|stop
argument_list|()
expr_stmt|;
name|HConnectionManager
operator|.
name|deleteConnection
argument_list|(
name|this
operator|.
name|conf
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|zooKeeper
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"HMaster main thread exiting"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|loop
parameter_list|()
block|{
comment|// Check if we should stop every second.
name|Sleeper
name|sleeper
init|=
operator|new
name|Sleeper
argument_list|(
literal|1000
argument_list|,
name|this
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|this
operator|.
name|stopped
condition|)
block|{
name|sleeper
operator|.
name|sleep
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * Finish initialization of HMaster after becoming the primary master.    *    *<ol>    *<li>Initialize master components - file system manager, server manager,    *     assignment manager, region server tracker, catalog tracker, etc</li>    *<li>Start necessary service threads - rpc server, info server,    *     executor services, etc</li>    *<li>Set cluster as UP in ZooKeeper</li>    *<li>Wait for RegionServers to check-in</li>    *<li>Split logs and perform data recovery, if necessary</li>    *<li>Ensure assignment of root and meta regions<li>    *<li>Handle either fresh cluster start or master failover</li>    *</ol>    *    * @throws IOException    * @throws InterruptedException    * @throws KeeperException    */
end_comment

begin_function
specifier|private
name|void
name|finishInitialization
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|KeeperException
block|{
name|isActiveMaster
operator|=
literal|true
expr_stmt|;
comment|/*      * We are active master now... go initialize components we need to run.      * Note, there may be dross in zk from previous runs; it'll get addressed      * below after we determine if cluster startup or failover.      */
comment|// TODO: Do this using Dependency Injection, using PicoContainer, Guice or Spring.
name|this
operator|.
name|fileSystemManager
operator|=
operator|new
name|MasterFileSystem
argument_list|(
name|this
argument_list|,
name|metrics
argument_list|)
expr_stmt|;
name|this
operator|.
name|connection
operator|=
name|HConnectionManager
operator|.
name|getConnection
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|=
operator|new
name|ExecutorService
argument_list|(
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|serverManager
operator|=
operator|new
name|ServerManager
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|metrics
argument_list|)
expr_stmt|;
name|this
operator|.
name|catalogTracker
operator|=
operator|new
name|CatalogTracker
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|this
operator|.
name|connection
argument_list|,
name|this
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.catalog.timeout"
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|catalogTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|=
operator|new
name|AssignmentManager
argument_list|(
name|this
argument_list|,
name|serverManager
argument_list|,
name|this
operator|.
name|catalogTracker
argument_list|,
name|this
operator|.
name|executorService
argument_list|)
expr_stmt|;
name|zooKeeper
operator|.
name|registerListenerFirst
argument_list|(
name|assignmentManager
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionServerTracker
operator|=
operator|new
name|RegionServerTracker
argument_list|(
name|zooKeeper
argument_list|,
name|this
argument_list|,
name|this
operator|.
name|serverManager
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionServerTracker
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Set the cluster as up.  If new RSs, they'll be waiting on this before
comment|// going ahead with their startup.
name|this
operator|.
name|clusterStatusTracker
operator|=
operator|new
name|ClusterStatusTracker
argument_list|(
name|getZooKeeper
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|clusterStatusTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|boolean
name|wasUp
init|=
name|this
operator|.
name|clusterStatusTracker
operator|.
name|isClusterUp
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|wasUp
condition|)
name|this
operator|.
name|clusterStatusTracker
operator|.
name|setClusterUp
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Server active/primary master; "
operator|+
name|this
operator|.
name|address
operator|+
literal|", sessionid=0x"
operator|+
name|Long
operator|.
name|toHexString
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|getZooKeeper
argument_list|()
operator|.
name|getSessionId
argument_list|()
argument_list|)
operator|+
literal|", cluster-up flag was="
operator|+
name|wasUp
argument_list|)
expr_stmt|;
comment|// start up all service threads.
name|startServiceThreads
argument_list|()
expr_stmt|;
comment|// Wait for region servers to report in.  Returns count of regions.
name|int
name|regionCount
init|=
name|this
operator|.
name|serverManager
operator|.
name|waitForRegionServers
argument_list|()
decl_stmt|;
comment|// TODO: Should do this in background rather than block master startup
name|this
operator|.
name|fileSystemManager
operator|.
name|splitLogAfterStartup
argument_list|(
name|this
operator|.
name|serverManager
operator|.
name|getOnlineServers
argument_list|()
argument_list|)
expr_stmt|;
comment|// Make sure root and meta assigned before proceeding.
name|assignRootAndMeta
argument_list|()
expr_stmt|;
comment|// Is this fresh start with no regions assigned or are we a master joining
comment|// an already-running cluster?  If regionsCount == 0, then for sure a
comment|// fresh start.  TOOD: Be fancier.  If regionsCount == 2, perhaps the
comment|// 2 are .META. and -ROOT- and we should fall into the fresh startup
comment|// branch below.  For now, do processFailover.
if|if
condition|(
name|regionCount
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Master startup proceeding: cluster startup"
argument_list|)
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|.
name|cleanoutUnassigned
argument_list|()
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|.
name|assignAllUserRegions
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Master startup proceeding: master failover"
argument_list|)
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|.
name|processFailover
argument_list|()
expr_stmt|;
block|}
comment|// Start balancer and meta catalog janitor after meta and regions have
comment|// been assigned.
name|this
operator|.
name|balancerChore
operator|=
name|getAndStartBalancerChore
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|catalogJanitorChore
operator|=
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
operator|new
name|CatalogJanitor
argument_list|(
name|this
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Master has completed initialization"
argument_list|)
expr_stmt|;
name|isInitialized
operator|=
literal|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Check<code>-ROOT-</code> and<code>.META.</code> are assigned.  If not,    * assign them.    * @throws InterruptedException    * @throws IOException    * @throws KeeperException    * @return Count of regions we assigned.    */
end_comment

begin_function
name|int
name|assignRootAndMeta
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|IOException
throws|,
name|KeeperException
block|{
name|int
name|assigned
init|=
literal|0
decl_stmt|;
name|long
name|timeout
init|=
name|this
operator|.
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.catalog.verification.timeout"
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
comment|// Work on ROOT region.  Is it in zk in transition?
name|boolean
name|rit
init|=
name|this
operator|.
name|assignmentManager
operator|.
name|processRegionInTransitionAndBlockUntilAssigned
argument_list|(
name|HRegionInfo
operator|.
name|ROOT_REGIONINFO
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|catalogTracker
operator|.
name|verifyRootRegionLocation
argument_list|(
name|timeout
argument_list|)
condition|)
block|{
name|this
operator|.
name|assignmentManager
operator|.
name|assignRoot
argument_list|()
expr_stmt|;
name|this
operator|.
name|catalogTracker
operator|.
name|waitForRoot
argument_list|()
expr_stmt|;
name|assigned
operator|++
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"-ROOT- assigned="
operator|+
name|assigned
operator|+
literal|", rit="
operator|+
name|rit
operator|+
literal|", location="
operator|+
name|catalogTracker
operator|.
name|getRootLocation
argument_list|()
argument_list|)
expr_stmt|;
comment|// Work on meta region
name|rit
operator|=
name|this
operator|.
name|assignmentManager
operator|.
name|processRegionInTransitionAndBlockUntilAssigned
argument_list|(
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|this
operator|.
name|catalogTracker
operator|.
name|verifyMetaRegionLocation
argument_list|(
name|timeout
argument_list|)
condition|)
block|{
name|this
operator|.
name|assignmentManager
operator|.
name|assignMeta
argument_list|()
expr_stmt|;
name|this
operator|.
name|catalogTracker
operator|.
name|waitForMeta
argument_list|()
expr_stmt|;
comment|// Above check waits for general meta availability but this does not
comment|// guarantee that the transition has completed
name|this
operator|.
name|assignmentManager
operator|.
name|waitForAssignment
argument_list|(
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
argument_list|)
expr_stmt|;
name|assigned
operator|++
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|".META. assigned="
operator|+
name|assigned
operator|+
literal|", rit="
operator|+
name|rit
operator|+
literal|", location="
operator|+
name|catalogTracker
operator|.
name|getMetaLocation
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|assigned
return|;
block|}
end_function

begin_comment
comment|/*    * @return This masters' address.    * @throws UnknownHostException    */
end_comment

begin_function
specifier|private
specifier|static
name|String
name|getMyAddress
parameter_list|(
specifier|final
name|Configuration
name|c
parameter_list|)
throws|throws
name|UnknownHostException
block|{
comment|// Find out our address up in DNS.
name|String
name|s
init|=
name|DNS
operator|.
name|getDefaultHost
argument_list|(
name|c
operator|.
name|get
argument_list|(
literal|"hbase.master.dns.interface"
argument_list|,
literal|"default"
argument_list|)
argument_list|,
name|c
operator|.
name|get
argument_list|(
literal|"hbase.master.dns.nameserver"
argument_list|,
literal|"default"
argument_list|)
argument_list|)
decl_stmt|;
name|s
operator|+=
literal|":"
operator|+
name|c
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|MASTER_PORT
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|HConstants
operator|.
name|DEFAULT_MASTER_PORT
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/** @return HServerAddress of the master server */
end_comment

begin_function
specifier|public
name|HServerAddress
name|getMasterAddress
parameter_list|()
block|{
return|return
name|this
operator|.
name|address
return|;
block|}
end_function

begin_function
specifier|public
name|long
name|getProtocolVersion
parameter_list|(
name|String
name|protocol
parameter_list|,
name|long
name|clientVersion
parameter_list|)
block|{
return|return
name|HBaseRPCProtocolVersion
operator|.
name|versionID
return|;
block|}
end_function

begin_comment
comment|/** @return InfoServer object. Maybe null.*/
end_comment

begin_function
specifier|public
name|InfoServer
name|getInfoServer
parameter_list|()
block|{
return|return
name|this
operator|.
name|infoServer
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|Configuration
name|getConfiguration
parameter_list|()
block|{
return|return
name|this
operator|.
name|conf
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|ServerManager
name|getServerManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|serverManager
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|ExecutorService
name|getExecutorService
parameter_list|()
block|{
return|return
name|this
operator|.
name|executorService
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|MasterFileSystem
name|getMasterFileSystem
parameter_list|()
block|{
return|return
name|this
operator|.
name|fileSystemManager
return|;
block|}
end_function

begin_comment
comment|/**    * Get the ZK wrapper object - needed by master_jsp.java    * @return the zookeeper wrapper    */
end_comment

begin_function
specifier|public
name|ZooKeeperWatcher
name|getZooKeeperWatcher
parameter_list|()
block|{
return|return
name|this
operator|.
name|zooKeeper
return|;
block|}
end_function

begin_comment
comment|/*    * Start up all services. If any of these threads gets an unhandled exception    * then they just die with a logged message.  This should be fine because    * in general, we do not expect the master to get such unhandled exceptions    *  as OOMEs; it should be lightly loaded. See what HRegionServer does if    *  need to install an unexpected exception handler.    */
end_comment

begin_function
specifier|private
name|void
name|startServiceThreads
parameter_list|()
block|{
try|try
block|{
comment|// Start the executor service pools
name|this
operator|.
name|executorService
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_OPEN_REGION
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.executor.openregion.threads"
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_CLOSE_REGION
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.executor.closeregion.threads"
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_SERVER_OPERATIONS
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.executor.serverops.threads"
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_META_SERVER_OPERATIONS
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.executor.serverops.threads"
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|// We depend on there being only one instance of this executor running
comment|// at a time.  To do concurrency, would need fencing of enable/disable of
comment|// tables.
name|this
operator|.
name|executorService
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_TABLE_OPERATIONS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// Start log cleaner thread
name|String
name|n
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|this
operator|.
name|logCleaner
operator|=
operator|new
name|LogCleaner
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.cleaner.interval"
argument_list|,
literal|60
operator|*
literal|1000
argument_list|)
argument_list|,
name|this
argument_list|,
name|conf
argument_list|,
name|getMasterFileSystem
argument_list|()
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|getMasterFileSystem
argument_list|()
operator|.
name|getOldLogDir
argument_list|()
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|logCleaner
argument_list|,
name|n
operator|+
literal|".oldLogCleaner"
argument_list|)
expr_stmt|;
comment|// Put up info server.
name|int
name|port
init|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.info.port"
argument_list|,
literal|60010
argument_list|)
decl_stmt|;
if|if
condition|(
name|port
operator|>=
literal|0
condition|)
block|{
name|String
name|a
init|=
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.master.info.bindAddress"
argument_list|,
literal|"0.0.0.0"
argument_list|)
decl_stmt|;
name|this
operator|.
name|infoServer
operator|=
operator|new
name|InfoServer
argument_list|(
name|MASTER
argument_list|,
name|a
argument_list|,
name|port
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|setAttribute
argument_list|(
name|MASTER
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|// Start allowing requests to happen.
name|this
operator|.
name|rpcServer
operator|.
name|openServer
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Started service threads"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|RemoteException
condition|)
block|{
name|e
operator|=
operator|(
operator|(
name|RemoteException
operator|)
name|e
operator|)
operator|.
name|unwrapRemoteException
argument_list|()
expr_stmt|;
block|}
comment|// Something happened during startup. Shut things down.
name|abort
argument_list|(
literal|"Failed startup"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|private
name|void
name|stopServiceThreads
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Stopping service threads"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|rpcServer
operator|!=
literal|null
condition|)
name|this
operator|.
name|rpcServer
operator|.
name|stop
argument_list|()
expr_stmt|;
comment|// Clean up and close up shop
if|if
condition|(
name|this
operator|.
name|logCleaner
operator|!=
literal|null
condition|)
name|this
operator|.
name|logCleaner
operator|.
name|interrupt
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|infoServer
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping infoServer"
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|infoServer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|this
operator|.
name|executorService
operator|!=
literal|null
condition|)
name|this
operator|.
name|executorService
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|Thread
name|getAndStartBalancerChore
parameter_list|(
specifier|final
name|HMaster
name|master
parameter_list|)
block|{
name|String
name|name
init|=
name|master
operator|.
name|getServerName
argument_list|()
operator|+
literal|"-BalancerChore"
decl_stmt|;
name|int
name|period
init|=
name|master
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"hbase.balancer.period"
argument_list|,
literal|300000
argument_list|)
decl_stmt|;
comment|// Start up the load balancer chore
name|Chore
name|chore
init|=
operator|new
name|Chore
argument_list|(
name|name
argument_list|,
name|period
argument_list|,
name|master
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|chore
parameter_list|()
block|{
name|master
operator|.
name|balance
argument_list|()
expr_stmt|;
block|}
block|}
decl_stmt|;
return|return
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|chore
argument_list|)
return|;
block|}
end_function

begin_function
specifier|private
name|void
name|stopChores
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|balancerChore
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|balancerChore
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|catalogJanitorChore
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|catalogJanitorChore
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|MapWritable
name|regionServerStartup
parameter_list|(
specifier|final
name|HServerInfo
name|serverInfo
parameter_list|,
specifier|final
name|long
name|serverCurrentTime
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Set the ip into the passed in serverInfo.  Its ip is more than likely
comment|// not the ip that the master sees here.  See at end of this method where
comment|// we pass it back to the regionserver by setting "hbase.regionserver.address"
comment|// Everafter, the HSI combination 'server name' is what uniquely identifies
comment|// the incoming RegionServer.  No more DNS meddling of this little messing
comment|// belose.
name|String
name|rsAddress
init|=
name|HBaseServer
operator|.
name|getRemoteAddress
argument_list|()
decl_stmt|;
name|serverInfo
operator|.
name|setServerAddress
argument_list|(
operator|new
name|HServerAddress
argument_list|(
name|rsAddress
argument_list|,
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|getPort
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Register with server manager
name|this
operator|.
name|serverManager
operator|.
name|regionServerStartup
argument_list|(
name|serverInfo
argument_list|,
name|serverCurrentTime
argument_list|)
expr_stmt|;
comment|// Send back some config info
name|MapWritable
name|mw
init|=
name|createConfigurationSubset
argument_list|()
decl_stmt|;
name|mw
operator|.
name|put
argument_list|(
operator|new
name|Text
argument_list|(
literal|"hbase.regionserver.address"
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
name|rsAddress
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mw
return|;
block|}
end_function

begin_comment
comment|/**    * @return Subset of configuration to pass initializing regionservers: e.g.    * the filesystem to use and root directory to use.    */
end_comment

begin_function
specifier|protected
name|MapWritable
name|createConfigurationSubset
parameter_list|()
block|{
name|MapWritable
name|mw
init|=
name|addConfig
argument_list|(
operator|new
name|MapWritable
argument_list|()
argument_list|,
name|HConstants
operator|.
name|HBASE_DIR
argument_list|)
decl_stmt|;
return|return
name|addConfig
argument_list|(
name|mw
argument_list|,
literal|"fs.default.name"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|private
name|MapWritable
name|addConfig
parameter_list|(
specifier|final
name|MapWritable
name|mw
parameter_list|,
specifier|final
name|String
name|key
parameter_list|)
block|{
name|mw
operator|.
name|put
argument_list|(
operator|new
name|Text
argument_list|(
name|key
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mw
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|HMsg
index|[]
name|regionServerReport
parameter_list|(
name|HServerInfo
name|serverInfo
parameter_list|,
name|HMsg
name|msgs
index|[]
parameter_list|,
name|HRegionInfo
index|[]
name|mostLoadedRegions
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|adornRegionServerAnswer
argument_list|(
name|serverInfo
argument_list|,
name|this
operator|.
name|serverManager
operator|.
name|regionServerReport
argument_list|(
name|serverInfo
argument_list|,
name|msgs
argument_list|,
name|mostLoadedRegions
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Override if you'd add messages to return to regionserver<code>hsi</code>    * or to send an exception.    * @param msgs Messages to add to    * @return Messages to return to    * @throws IOException exceptions that were injected for the region servers    */
end_comment

begin_function
specifier|protected
name|HMsg
index|[]
name|adornRegionServerAnswer
parameter_list|(
specifier|final
name|HServerInfo
name|hsi
parameter_list|,
specifier|final
name|HMsg
index|[]
name|msgs
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|msgs
return|;
block|}
end_function

begin_function
specifier|public
name|boolean
name|isMasterRunning
parameter_list|()
block|{
return|return
operator|!
name|isStopped
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|boolean
name|balance
parameter_list|()
block|{
comment|// If balance not true, don't run balancer.
if|if
condition|(
operator|!
name|this
operator|.
name|balanceSwitch
condition|)
return|return
literal|false
return|;
synchronized|synchronized
init|(
name|this
operator|.
name|balancer
init|)
block|{
comment|// Only allow one balance run at at time.
if|if
condition|(
name|this
operator|.
name|assignmentManager
operator|.
name|isRegionsInTransition
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Not running balancer because "
operator|+
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionsInTransition
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|" region(s) in transition: "
operator|+
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
operator|.
name|abbreviate
argument_list|(
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionsInTransition
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
literal|256
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|this
operator|.
name|serverManager
operator|.
name|areDeadServersInProgress
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Not running balancer because dead regionserver processing"
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|HServerInfo
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|assignments
init|=
name|this
operator|.
name|assignmentManager
operator|.
name|getAssignments
argument_list|()
decl_stmt|;
comment|// Returned Map from AM does not include mention of servers w/o assignments.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|HServerInfo
argument_list|>
name|e
range|:
name|this
operator|.
name|serverManager
operator|.
name|getOnlineServers
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|HServerInfo
name|hsi
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|assignments
operator|.
name|containsKey
argument_list|(
name|hsi
argument_list|)
condition|)
block|{
name|assignments
operator|.
name|put
argument_list|(
name|hsi
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|RegionPlan
argument_list|>
name|plans
init|=
name|this
operator|.
name|balancer
operator|.
name|balanceCluster
argument_list|(
name|assignments
argument_list|)
decl_stmt|;
if|if
condition|(
name|plans
operator|!=
literal|null
operator|&&
operator|!
name|plans
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|RegionPlan
name|plan
range|:
name|plans
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"balance "
operator|+
name|plan
argument_list|)
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|.
name|balance
argument_list|(
name|plan
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|boolean
name|balanceSwitch
parameter_list|(
specifier|final
name|boolean
name|b
parameter_list|)
block|{
name|boolean
name|oldValue
init|=
name|this
operator|.
name|balanceSwitch
decl_stmt|;
name|this
operator|.
name|balanceSwitch
operator|=
name|b
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Balance="
operator|+
name|b
argument_list|)
expr_stmt|;
return|return
name|oldValue
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|move
parameter_list|(
specifier|final
name|byte
index|[]
name|encodedRegionName
parameter_list|,
specifier|final
name|byte
index|[]
name|destServerName
parameter_list|)
throws|throws
name|UnknownRegionException
block|{
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerInfo
argument_list|>
name|p
init|=
name|this
operator|.
name|assignmentManager
operator|.
name|getAssignment
argument_list|(
name|encodedRegionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|null
condition|)
throw|throw
operator|new
name|UnknownRegionException
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|encodedRegionName
argument_list|)
argument_list|)
throw|;
name|HRegionInfo
name|hri
init|=
name|p
operator|.
name|getFirst
argument_list|()
decl_stmt|;
name|HServerInfo
name|dest
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|destServerName
operator|==
literal|null
operator|||
name|destServerName
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Passed destination servername is null/empty so "
operator|+
literal|"choosing a server at random"
argument_list|)
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|.
name|clearRegionPlan
argument_list|(
name|hri
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Unassign will reassign it elsewhere choosing random server.
name|this
operator|.
name|assignmentManager
operator|.
name|unassign
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dest
operator|=
name|this
operator|.
name|serverManager
operator|.
name|getServerInfo
argument_list|(
operator|new
name|String
argument_list|(
name|destServerName
argument_list|)
argument_list|)
expr_stmt|;
name|RegionPlan
name|rp
init|=
operator|new
name|RegionPlan
argument_list|(
name|p
operator|.
name|getFirst
argument_list|()
argument_list|,
name|p
operator|.
name|getSecond
argument_list|()
argument_list|,
name|dest
argument_list|)
decl_stmt|;
name|this
operator|.
name|assignmentManager
operator|.
name|balance
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|public
name|void
name|createTable
parameter_list|(
name|HTableDescriptor
name|desc
parameter_list|,
name|byte
index|[]
index|[]
name|splitKeys
parameter_list|)
throws|throws
name|IOException
block|{
name|createTable
argument_list|(
name|desc
argument_list|,
name|splitKeys
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|public
name|void
name|createTable
parameter_list|(
name|HTableDescriptor
name|desc
parameter_list|,
name|byte
index|[]
index|[]
name|splitKeys
parameter_list|,
name|boolean
name|sync
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isMasterRunning
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MasterNotRunningException
argument_list|()
throw|;
block|}
name|HRegionInfo
index|[]
name|newRegions
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|splitKeys
operator|==
literal|null
operator|||
name|splitKeys
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|newRegions
operator|=
operator|new
name|HRegionInfo
index|[]
block|{
operator|new
name|HRegionInfo
argument_list|(
name|desc
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
block|}
expr_stmt|;
block|}
else|else
block|{
name|int
name|numRegions
init|=
name|splitKeys
operator|.
name|length
operator|+
literal|1
decl_stmt|;
name|newRegions
operator|=
operator|new
name|HRegionInfo
index|[
name|numRegions
index|]
expr_stmt|;
name|byte
index|[]
name|startKey
init|=
literal|null
decl_stmt|;
name|byte
index|[]
name|endKey
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numRegions
condition|;
name|i
operator|++
control|)
block|{
name|endKey
operator|=
operator|(
name|i
operator|==
name|splitKeys
operator|.
name|length
operator|)
condition|?
literal|null
else|:
name|splitKeys
index|[
name|i
index|]
expr_stmt|;
name|newRegions
index|[
name|i
index|]
operator|=
operator|new
name|HRegionInfo
argument_list|(
name|desc
argument_list|,
name|startKey
argument_list|,
name|endKey
argument_list|)
expr_stmt|;
name|startKey
operator|=
name|endKey
expr_stmt|;
block|}
block|}
name|int
name|timeout
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.client.catalog.timeout"
argument_list|,
literal|10000
argument_list|)
decl_stmt|;
comment|// Need META availability to create a table
try|try
block|{
if|if
condition|(
name|catalogTracker
operator|.
name|waitForMeta
argument_list|(
name|timeout
argument_list|)
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NotAllMetaRegionsOnlineException
argument_list|()
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted waiting for meta availability"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|createTable
argument_list|(
name|newRegions
argument_list|,
name|sync
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
specifier|synchronized
name|void
name|createTable
parameter_list|(
specifier|final
name|HRegionInfo
index|[]
name|newRegions
parameter_list|,
name|boolean
name|sync
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|tableName
init|=
name|newRegions
index|[
literal|0
index|]
operator|.
name|getTableDesc
argument_list|()
operator|.
name|getNameAsString
argument_list|()
decl_stmt|;
if|if
condition|(
name|MetaReader
operator|.
name|tableExists
argument_list|(
name|catalogTracker
argument_list|,
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TableExistsException
argument_list|(
name|tableName
argument_list|)
throw|;
block|}
for|for
control|(
name|HRegionInfo
name|newRegion
range|:
name|newRegions
control|)
block|{
comment|// 1. Create HRegion
name|HRegion
name|region
init|=
name|HRegion
operator|.
name|createHRegion
argument_list|(
name|newRegion
argument_list|,
name|fileSystemManager
operator|.
name|getRootDir
argument_list|()
argument_list|,
name|conf
argument_list|)
decl_stmt|;
comment|// 2. Insert into META
name|MetaEditor
operator|.
name|addRegionToMeta
argument_list|(
name|catalogTracker
argument_list|,
name|region
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
comment|// 3. Close the new region to flush to disk.  Close log file too.
name|region
operator|.
name|close
argument_list|()
expr_stmt|;
name|region
operator|.
name|getLog
argument_list|()
operator|.
name|closeAndDelete
argument_list|()
expr_stmt|;
comment|// 4. Trigger immediate assignment of this region
name|assignmentManager
operator|.
name|assign
argument_list|(
name|region
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// 5. If sync, wait for assignment of regions
if|if
condition|(
name|sync
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting for "
operator|+
name|newRegions
operator|.
name|length
operator|+
literal|" region(s) to be "
operator|+
literal|"assigned before returning"
argument_list|)
expr_stmt|;
for|for
control|(
name|HRegionInfo
name|regionInfo
range|:
name|newRegions
control|)
block|{
try|try
block|{
name|assignmentManager
operator|.
name|waitForAssignment
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Interrupted waiting for region to be assigned during "
operator|+
literal|"create table call"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|private
specifier|static
name|boolean
name|isCatalogTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|tableName
argument_list|,
name|HConstants
operator|.
name|ROOT_TABLE_NAME
argument_list|)
operator|||
name|Bytes
operator|.
name|equals
argument_list|(
name|tableName
argument_list|,
name|HConstants
operator|.
name|META_TABLE_NAME
argument_list|)
return|;
block|}
end_function

begin_function
specifier|public
name|void
name|deleteTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
operator|new
name|DeleteTableHandler
argument_list|(
name|tableName
argument_list|,
name|this
argument_list|,
name|this
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|public
name|void
name|addColumn
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|,
name|HColumnDescriptor
name|column
parameter_list|)
throws|throws
name|IOException
block|{
operator|new
name|TableAddFamilyHandler
argument_list|(
name|tableName
argument_list|,
name|column
argument_list|,
name|this
argument_list|,
name|this
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|public
name|void
name|modifyColumn
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|,
name|HColumnDescriptor
name|descriptor
parameter_list|)
throws|throws
name|IOException
block|{
operator|new
name|TableModifyFamilyHandler
argument_list|(
name|tableName
argument_list|,
name|descriptor
argument_list|,
name|this
argument_list|,
name|this
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|public
name|void
name|deleteColumn
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|c
parameter_list|)
throws|throws
name|IOException
block|{
operator|new
name|TableDeleteFamilyHandler
argument_list|(
name|tableName
argument_list|,
name|c
argument_list|,
name|this
argument_list|,
name|this
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|public
name|void
name|enableTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|EnableTableHandler
argument_list|(
name|this
argument_list|,
name|tableName
argument_list|,
name|catalogTracker
argument_list|,
name|assignmentManager
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|public
name|void
name|disableTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|DisableTableHandler
argument_list|(
name|this
argument_list|,
name|tableName
argument_list|,
name|catalogTracker
argument_list|,
name|assignmentManager
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Return the region and current deployment for the region containing    * the given row. If the region cannot be found, returns null. If it    * is found, but not currently deployed, the second element of the pair    * may be null.    */
end_comment

begin_function
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerAddress
argument_list|>
name|getTableRegionForRow
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|rowKey
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|AtomicReference
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerAddress
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|AtomicReference
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerAddress
argument_list|>
argument_list|>
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|MetaScannerVisitor
name|visitor
init|=
operator|new
name|MetaScannerVisitor
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|processRow
parameter_list|(
name|Result
name|data
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|data
operator|==
literal|null
operator|||
name|data
operator|.
name|size
argument_list|()
operator|<=
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerAddress
argument_list|>
name|pair
init|=
name|MetaReader
operator|.
name|metaRowToRegionPair
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|pair
operator|.
name|getFirst
argument_list|()
operator|.
name|getTableDesc
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|tableName
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|result
operator|.
name|set
argument_list|(
name|pair
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
decl_stmt|;
name|MetaScanner
operator|.
name|metaScan
argument_list|(
name|conf
argument_list|,
name|visitor
argument_list|,
name|tableName
argument_list|,
name|rowKey
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|result
operator|.
name|get
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|modifyTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
name|HTableDescriptor
name|htd
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|ModifyTableHandler
argument_list|(
name|tableName
argument_list|,
name|htd
argument_list|,
name|this
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|checkTableModifiable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|tableNameStr
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|isCatalogTable
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can't modify catalog tables"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|MetaReader
operator|.
name|tableExists
argument_list|(
name|getCatalogTracker
argument_list|()
argument_list|,
name|tableNameStr
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TableNotFoundException
argument_list|(
name|tableNameStr
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|getAssignmentManager
argument_list|()
operator|.
name|getZKTable
argument_list|()
operator|.
name|isDisabledTable
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TableNotDisabledException
argument_list|(
name|tableName
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
specifier|public
name|void
name|clearFromTransition
parameter_list|(
name|HRegionInfo
name|hri
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|assignmentManager
operator|.
name|isRegionInTransition
argument_list|(
name|hri
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|assignmentManager
operator|.
name|clearRegionFromTransition
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * @return cluster status    */
end_comment

begin_function
specifier|public
name|ClusterStatus
name|getClusterStatus
parameter_list|()
block|{
name|ClusterStatus
name|status
init|=
operator|new
name|ClusterStatus
argument_list|()
decl_stmt|;
name|status
operator|.
name|setHBaseVersion
argument_list|(
name|VersionInfo
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
name|status
operator|.
name|setServerInfo
argument_list|(
name|serverManager
operator|.
name|getOnlineServers
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|status
operator|.
name|setDeadServers
argument_list|(
name|serverManager
operator|.
name|getDeadServers
argument_list|()
argument_list|)
expr_stmt|;
name|status
operator|.
name|setRegionsInTransition
argument_list|(
name|assignmentManager
operator|.
name|getRegionsInTransition
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|abort
parameter_list|(
specifier|final
name|String
name|msg
parameter_list|,
specifier|final
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
name|LOG
operator|.
name|fatal
argument_list|(
name|msg
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|LOG
operator|.
name|fatal
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|this
operator|.
name|abort
operator|=
literal|true
expr_stmt|;
name|stop
argument_list|(
literal|"Aborting"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|ZooKeeperWatcher
name|getZooKeeper
parameter_list|()
block|{
return|return
name|zooKeeper
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|String
name|getServerName
parameter_list|()
block|{
return|return
name|address
operator|.
name|toString
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|CatalogTracker
name|getCatalogTracker
parameter_list|()
block|{
return|return
name|catalogTracker
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|AssignmentManager
name|getAssignmentManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|assignmentManager
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|this
operator|.
name|serverManager
operator|.
name|shutdownCluster
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|clusterStatusTracker
operator|.
name|setClusterDown
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"ZooKeeper exception trying to set cluster as down in ZK"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|stopMaster
parameter_list|()
block|{
name|stop
argument_list|(
literal|"Stopped by "
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|stop
parameter_list|(
specifier|final
name|String
name|why
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|why
argument_list|)
expr_stmt|;
name|this
operator|.
name|stopped
operator|=
literal|true
expr_stmt|;
comment|// If we are a backup master, we need to interrupt wait
synchronized|synchronized
init|(
name|this
operator|.
name|activeMasterManager
operator|.
name|clusterHasActiveMaster
init|)
block|{
name|this
operator|.
name|activeMasterManager
operator|.
name|clusterHasActiveMaster
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|boolean
name|isStopped
parameter_list|()
block|{
return|return
name|this
operator|.
name|stopped
return|;
block|}
end_function

begin_comment
comment|/**    * Report whether this master is currently the active master or not.    * If not active master, we are parked on ZK waiting to become active.    *    * This method is used for testing.    *    * @return true if active master, false if not.    */
end_comment

begin_function
specifier|public
name|boolean
name|isActiveMaster
parameter_list|()
block|{
return|return
name|isActiveMaster
return|;
block|}
end_function

begin_comment
comment|/**    * Report whether this master has completed with its initialization and is    * ready.  If ready, the master is also the active master.  A standby master    * is never ready.    *    * This method is used for testing.    *    * @return true if master is ready to go, false if not.    */
end_comment

begin_function
specifier|public
name|boolean
name|isInitialized
parameter_list|()
block|{
return|return
name|isInitialized
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|assign
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerAddress
argument_list|>
name|pair
init|=
name|MetaReader
operator|.
name|getRegion
argument_list|(
name|this
operator|.
name|catalogTracker
argument_list|,
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
literal|null
condition|)
throw|throw
operator|new
name|UnknownRegionException
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|regionName
argument_list|)
argument_list|)
throw|;
name|assignRegion
argument_list|(
name|pair
operator|.
name|getFirst
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|public
name|void
name|assignRegion
parameter_list|(
name|HRegionInfo
name|hri
parameter_list|)
block|{
name|assignmentManager
operator|.
name|assign
argument_list|(
name|hri
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|unassign
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerAddress
argument_list|>
name|pair
init|=
name|MetaReader
operator|.
name|getRegion
argument_list|(
name|this
operator|.
name|catalogTracker
argument_list|,
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
literal|null
condition|)
throw|throw
operator|new
name|UnknownRegionException
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|regionName
argument_list|)
argument_list|)
throw|;
name|HRegionInfo
name|hri
init|=
name|pair
operator|.
name|getFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|force
condition|)
name|this
operator|.
name|assignmentManager
operator|.
name|clearRegionFromTransition
argument_list|(
name|hri
argument_list|)
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|.
name|unassign
argument_list|(
name|hri
argument_list|,
name|force
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Utility for constructing an instance of the passed HMaster class.    * @param masterClass    * @param conf    * @return HMaster instance.    */
end_comment

begin_function
specifier|public
specifier|static
name|HMaster
name|constructMaster
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|HMaster
argument_list|>
name|masterClass
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|)
block|{
try|try
block|{
name|Constructor
argument_list|<
name|?
extends|extends
name|HMaster
argument_list|>
name|c
init|=
name|masterClass
operator|.
name|getConstructor
argument_list|(
name|Configuration
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|c
operator|.
name|newInstance
argument_list|(
name|conf
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|ite
parameter_list|)
block|{
name|Throwable
name|target
init|=
name|ite
operator|.
name|getTargetException
argument_list|()
operator|!=
literal|null
condition|?
name|ite
operator|.
name|getTargetException
argument_list|()
else|:
name|ite
decl_stmt|;
if|if
condition|(
name|target
operator|.
name|getCause
argument_list|()
operator|!=
literal|null
condition|)
name|target
operator|=
name|target
operator|.
name|getCause
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Failed construction of Master: "
operator|+
name|masterClass
operator|.
name|toString
argument_list|()
argument_list|,
name|target
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Failed construction of Master: "
operator|+
name|masterClass
operator|.
name|toString
argument_list|()
operator|+
operator|(
operator|(
name|e
operator|.
name|getCause
argument_list|()
operator|!=
literal|null
operator|)
condition|?
name|e
operator|.
name|getCause
argument_list|()
operator|.
name|getMessage
argument_list|()
else|:
literal|""
operator|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
end_function

begin_comment
comment|/**    * @see org.apache.hadoop.hbase.master.HMasterCommandLine    */
end_comment

begin_function
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
operator|new
name|HMasterCommandLine
argument_list|(
name|HMaster
operator|.
name|class
argument_list|)
operator|.
name|doMain
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

unit|}
end_unit

