begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2010 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Chore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ClusterStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HColumnDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HMsg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerAddress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MasterNotRunningException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NotAllMetaRegionsOnlineException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|RemoteExceptionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotDisabledException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|UnknownRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|CatalogTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|MetaEditor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|MetaReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|HConnection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|HConnectionManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MetaScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MetaScanner
operator|.
name|MetaScannerVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|ExecutorService
operator|.
name|ExecutorType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HBaseRPC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HBaseRPCProtocolVersion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HBaseServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HMasterInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HMasterRegionInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|LoadBalancer
operator|.
name|RegionPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|DeleteTableHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|DisableTableHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|EnableTableHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|ModifyTableHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|TableAddFamilyHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|TableDeleteFamilyHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|TableModifyFamilyHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|InfoServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Sleeper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|VersionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ClusterStatusTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|RegionServerTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|MapWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|DNS
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|Watcher
import|;
end_import

begin_comment
comment|/**  * HMaster is the "master server" for HBase. An HBase cluster has one active  * master.  If many masters are started, all compete.  Whichever wins goes on to  * run the cluster.  All others park themselves in their constructor until  * master or cluster shutdown or until the active master loses its lease in  * zookeeper.  Thereafter, all running master jostle to take over master role.  *   *<p>The Master can be asked shutdown the cluster. See {@link #shutdown()}.  In  * this case it will tell all regionservers to go down and then wait on them  * all reporting in that they are down.  This master will then shut itself down.  *   *<p>You can also shutdown just this master.  Call {@link #stopMaster()}.  *   * @see HMasterInterface  * @see HMasterRegionInterface  * @see Watcher  */
end_comment

begin_class
specifier|public
class|class
name|HMaster
extends|extends
name|Thread
implements|implements
name|HMasterInterface
implements|,
name|HMasterRegionInterface
implements|,
name|MasterServices
implements|,
name|Server
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HMaster
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|// MASTER is name of the webapp and the attribute name used stuffing this
comment|//instance into web context.
specifier|public
specifier|static
specifier|final
name|String
name|MASTER
init|=
literal|"master"
decl_stmt|;
comment|// The configuration for the Master
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
comment|// server for the web ui
specifier|private
name|InfoServer
name|infoServer
decl_stmt|;
comment|// Our zk client.
specifier|private
name|ZooKeeperWatcher
name|zooKeeper
decl_stmt|;
comment|// Manager and zk listener for master election
specifier|private
name|ActiveMasterManager
name|activeMasterManager
decl_stmt|;
comment|// Region server tracker
specifier|private
name|RegionServerTracker
name|regionServerTracker
decl_stmt|;
comment|// RPC server for the HMaster
specifier|private
specifier|final
name|HBaseServer
name|rpcServer
decl_stmt|;
comment|// Address of the HMaster
specifier|private
specifier|final
name|HServerAddress
name|address
decl_stmt|;
comment|// file system manager for the master FS operations
specifier|private
specifier|final
name|MasterFileSystem
name|fileSystemManager
decl_stmt|;
specifier|private
specifier|final
name|HConnection
name|connection
decl_stmt|;
comment|// server manager to deal with region server info
specifier|private
specifier|final
name|ServerManager
name|serverManager
decl_stmt|;
comment|// manager of assignment nodes in zookeeper
specifier|final
name|AssignmentManager
name|assignmentManager
decl_stmt|;
comment|// manager of catalog regions
specifier|private
specifier|final
name|CatalogTracker
name|catalogTracker
decl_stmt|;
comment|// Cluster status zk tracker and local setter
specifier|private
name|ClusterStatusTracker
name|clusterStatusTracker
decl_stmt|;
comment|// True if this is the master that started the cluster.
name|boolean
name|clusterStarter
decl_stmt|;
comment|// This flag is for stopping this Master instance.
specifier|private
name|boolean
name|stopped
init|=
literal|false
decl_stmt|;
comment|// Set on abort -- usually failure of our zk session
specifier|private
specifier|volatile
name|boolean
name|abort
init|=
literal|false
decl_stmt|;
comment|// Instance of the hbase executor service.
name|ExecutorService
name|executorService
decl_stmt|;
specifier|private
name|LoadBalancer
name|balancer
init|=
operator|new
name|LoadBalancer
argument_list|()
decl_stmt|;
specifier|private
name|Chore
name|balancerChore
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|balance
init|=
literal|true
decl_stmt|;
comment|/**    * Initializes the HMaster. The steps are as follows:    *    *<ol>    *<li>Initialize HMaster RPC and address    *<li>Connect to ZooKeeper and figure out if this is a fresh cluster start or    *     a failed over master    *<li>Block until becoming active master    *<li>Initialize master components - server manager, region manager,    *     region server queue, file system manager, etc    *</ol>    * @throws InterruptedException     */
specifier|public
name|HMaster
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
throws|,
name|KeeperException
throws|,
name|InterruptedException
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
comment|/*      * 1. Determine address and initialize RPC server (but do not start).      * The RPC server ports can be ephemeral.      */
name|HServerAddress
name|a
init|=
operator|new
name|HServerAddress
argument_list|(
name|getMyAddress
argument_list|(
name|this
operator|.
name|conf
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|numHandlers
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.handler.count"
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|this
operator|.
name|rpcServer
operator|=
name|HBaseRPC
operator|.
name|getServer
argument_list|(
name|this
argument_list|,
name|a
operator|.
name|getBindAddress
argument_list|()
argument_list|,
name|a
operator|.
name|getPort
argument_list|()
argument_list|,
name|numHandlers
argument_list|,
literal|false
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|address
operator|=
operator|new
name|HServerAddress
argument_list|(
name|rpcServer
operator|.
name|getListenerAddress
argument_list|()
argument_list|)
expr_stmt|;
comment|// set the thread name now we have an address
name|setName
argument_list|(
name|MASTER
operator|+
literal|"-"
operator|+
name|this
operator|.
name|address
argument_list|)
expr_stmt|;
comment|// Hack! Maps DFSClient => Master for logs.  HDFS made this
comment|// config param for task trackers, but we can piggyback off of it.
if|if
condition|(
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
literal|"mapred.task.id"
argument_list|)
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|conf
operator|.
name|set
argument_list|(
literal|"mapred.task.id"
argument_list|,
literal|"hb_m_"
operator|+
name|this
operator|.
name|address
operator|.
name|toString
argument_list|()
operator|+
literal|"_"
operator|+
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/*      * 2. Determine if this is a fresh cluster startup or failed over master.      * This is done by checking for the existence of any ephemeral      * RegionServer nodes in ZooKeeper.  These nodes are created by RSs on      * their initialization but only after they find the primary master.  As      * long as this check is done before we write our address into ZK, this      * will work.  Note that multiple masters could find this to be true on      * startup (none have become active master yet), which is why there is an      * additional check if this master does not become primary on its first attempt.      */
name|this
operator|.
name|zooKeeper
operator|=
operator|new
name|ZooKeeperWatcher
argument_list|(
name|conf
argument_list|,
name|MASTER
operator|+
literal|"-"
operator|+
name|getMasterAddress
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|clusterStarter
operator|=
literal|0
operator|==
name|ZKUtil
operator|.
name|getNumberOfChildren
argument_list|(
name|zooKeeper
argument_list|,
name|zooKeeper
operator|.
name|rsZNode
argument_list|)
expr_stmt|;
comment|/*      * 3. Block on becoming the active master.      * We race with other masters to write our address into ZooKeeper.  If we      * succeed, we are the primary/active master and finish initialization.      *      * If we do not succeed, there is another active master and we should      * now wait until it dies to try and become the next active master.  If we      * do not succeed on our first attempt, this is no longer a cluster startup.      */
name|this
operator|.
name|activeMasterManager
operator|=
operator|new
name|ActiveMasterManager
argument_list|(
name|zooKeeper
argument_list|,
name|address
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|zooKeeper
operator|.
name|registerListener
argument_list|(
name|activeMasterManager
argument_list|)
expr_stmt|;
comment|// If we're a backup master, stall until a primary to writes his address
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|HConstants
operator|.
name|MASTER_TYPE_BACKUP
argument_list|,
name|HConstants
operator|.
name|DEFAULT_MASTER_TYPE_BACKUP
argument_list|)
condition|)
block|{
comment|// This will only be a minute or so while the cluster starts up,
comment|// so don't worry about setting watches on the parent znode
while|while
condition|(
operator|!
name|this
operator|.
name|activeMasterManager
operator|.
name|isActiveMaster
argument_list|()
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting for master address ZNode to be written "
operator|+
literal|"(Also watching cluster state node)"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
literal|"zookeeper.session.timeout"
argument_list|,
literal|60
operator|*
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// interrupted = user wants to kill us.  Don't continue
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Interrupted waiting for master address"
argument_list|)
throw|;
block|}
block|}
block|}
comment|// Wait here until we are the active master
name|clusterStarter
operator|=
name|activeMasterManager
operator|.
name|blockUntilBecomingActiveMaster
argument_list|()
expr_stmt|;
comment|/**      * 4. We are active master now... go initialize components we need to run.      */
comment|// TODO: Do this using Dependency Injection, using PicoContainer or Spring.
name|this
operator|.
name|fileSystemManager
operator|=
operator|new
name|MasterFileSystem
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|connection
operator|=
name|HConnectionManager
operator|.
name|getConnection
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|=
operator|new
name|ExecutorService
argument_list|(
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|serverManager
operator|=
operator|new
name|ServerManager
argument_list|(
name|this
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|catalogTracker
operator|=
operator|new
name|CatalogTracker
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|this
operator|.
name|connection
argument_list|,
name|this
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.catalog.timeout"
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|catalogTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|=
operator|new
name|AssignmentManager
argument_list|(
name|this
argument_list|,
name|serverManager
argument_list|,
name|this
operator|.
name|catalogTracker
argument_list|,
name|this
operator|.
name|executorService
argument_list|)
expr_stmt|;
name|zooKeeper
operator|.
name|registerListener
argument_list|(
name|assignmentManager
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionServerTracker
operator|=
operator|new
name|RegionServerTracker
argument_list|(
name|zooKeeper
argument_list|,
name|this
argument_list|,
name|this
operator|.
name|serverManager
argument_list|)
expr_stmt|;
name|regionServerTracker
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Set the cluster as up.
name|this
operator|.
name|clusterStatusTracker
operator|=
operator|new
name|ClusterStatusTracker
argument_list|(
name|getZooKeeper
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|clusterStatusTracker
operator|.
name|setClusterUp
argument_list|()
expr_stmt|;
name|this
operator|.
name|clusterStatusTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Server active/primary master; "
operator|+
name|this
operator|.
name|address
operator|+
literal|"; clusterStarter="
operator|+
name|this
operator|.
name|clusterStarter
operator|+
literal|", sessionid=0x"
operator|+
name|Long
operator|.
name|toHexString
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|getZooKeeper
argument_list|()
operator|.
name|getSessionId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Main processing loop for the HMaster.    * 1. Handle both fresh cluster start as well as failed over initialization of    *    the HMaster.    * 2. Start the necessary services    * 3. Reassign the root region    * 4. The master is no longer closed - set "closed" to false    */
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
comment|// start up all service threads.
name|startServiceThreads
argument_list|()
expr_stmt|;
comment|// wait for minimum number of region servers to be up
name|this
operator|.
name|serverManager
operator|.
name|waitForMinServers
argument_list|()
expr_stmt|;
comment|// start assignment of user regions, startup or failure
if|if
condition|(
name|this
operator|.
name|clusterStarter
condition|)
block|{
name|clusterStarterInitializations
argument_list|(
name|this
operator|.
name|fileSystemManager
argument_list|,
name|this
operator|.
name|serverManager
argument_list|,
name|this
operator|.
name|catalogTracker
argument_list|,
name|this
operator|.
name|assignmentManager
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Process existing unassigned nodes in ZK, read all regions from META,
comment|// rebuild in-memory state.
name|this
operator|.
name|assignmentManager
operator|.
name|processFailover
argument_list|()
expr_stmt|;
block|}
comment|// Check if we should stop every second.
name|Sleeper
name|sleeper
init|=
operator|new
name|Sleeper
argument_list|(
literal|1000
argument_list|,
name|this
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|this
operator|.
name|stopped
operator|&&
operator|!
name|this
operator|.
name|abort
condition|)
block|{
name|sleeper
operator|.
name|sleep
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|abort
argument_list|(
literal|"Unhandled exception. Starting shutdown."
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|// Wait for all the remaining region servers to report in IFF we were
comment|// running a cluster shutdown AND we were NOT aborting.
if|if
condition|(
operator|!
name|this
operator|.
name|abort
operator|&&
name|this
operator|.
name|serverManager
operator|.
name|isClusterShutdown
argument_list|()
condition|)
block|{
name|this
operator|.
name|serverManager
operator|.
name|letRegionServersShutdown
argument_list|()
expr_stmt|;
block|}
comment|// Clean up and close up shop
if|if
condition|(
name|this
operator|.
name|infoServer
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping infoServer"
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|infoServer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
name|this
operator|.
name|rpcServer
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|balancerChore
operator|!=
literal|null
condition|)
name|this
operator|.
name|balancerChore
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|this
operator|.
name|activeMasterManager
operator|.
name|stop
argument_list|()
expr_stmt|;
name|this
operator|.
name|executorService
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|HConnectionManager
operator|.
name|deleteConnection
argument_list|(
name|this
operator|.
name|conf
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|zooKeeper
operator|.
name|close
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"HMaster main thread exiting"
argument_list|)
expr_stmt|;
block|}
comment|/*    * Initializations we need to do if we are cluster starter.    * @param starter    * @param mfs    * @throws IOException     */
specifier|private
specifier|static
name|void
name|clusterStarterInitializations
parameter_list|(
specifier|final
name|MasterFileSystem
name|mfs
parameter_list|,
specifier|final
name|ServerManager
name|sm
parameter_list|,
specifier|final
name|CatalogTracker
name|ct
parameter_list|,
specifier|final
name|AssignmentManager
name|am
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|KeeperException
block|{
comment|// This master is starting the cluster (its not a preexisting cluster
comment|// that this master is joining).
comment|// Initialize the filesystem, which does the following:
comment|//   - Creates the root hbase directory in the FS if DNE
comment|//   - If fresh start, create first ROOT and META regions (bootstrap)
comment|//   - Checks the FS to make sure the root directory is readable
comment|//   - Creates the archive directory for logs
name|mfs
operator|.
name|initialize
argument_list|()
expr_stmt|;
comment|// Do any log splitting necessary
comment|// TODO: Should do this in background rather than block master startup
comment|// TODO: Do we want to do this before/while/after RSs check in?
comment|//       It seems that this method looks at active RSs but happens
comment|//       concurrently with when we expect them to be checking in
name|mfs
operator|.
name|splitLogAfterStartup
argument_list|(
name|sm
operator|.
name|getOnlineServers
argument_list|()
argument_list|)
expr_stmt|;
comment|// Clean out current state of unassigned
name|am
operator|.
name|cleanoutUnassigned
argument_list|()
expr_stmt|;
comment|// assign the root region
name|am
operator|.
name|assignRoot
argument_list|()
expr_stmt|;
name|ct
operator|.
name|waitForRoot
argument_list|()
expr_stmt|;
comment|// assign the meta region
name|am
operator|.
name|assignMeta
argument_list|()
expr_stmt|;
name|ct
operator|.
name|waitForMeta
argument_list|()
expr_stmt|;
comment|// above check waits for general meta availability but this does not
comment|// guarantee that the transition has completed
name|am
operator|.
name|waitForAssignment
argument_list|(
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
argument_list|)
expr_stmt|;
name|am
operator|.
name|assignAllUserRegions
argument_list|()
expr_stmt|;
block|}
comment|/*    * @return This masters' address.    * @throws UnknownHostException    */
specifier|private
specifier|static
name|String
name|getMyAddress
parameter_list|(
specifier|final
name|Configuration
name|c
parameter_list|)
throws|throws
name|UnknownHostException
block|{
comment|// Find out our address up in DNS.
name|String
name|s
init|=
name|DNS
operator|.
name|getDefaultHost
argument_list|(
name|c
operator|.
name|get
argument_list|(
literal|"hbase.master.dns.interface"
argument_list|,
literal|"default"
argument_list|)
argument_list|,
name|c
operator|.
name|get
argument_list|(
literal|"hbase.master.dns.nameserver"
argument_list|,
literal|"default"
argument_list|)
argument_list|)
decl_stmt|;
name|s
operator|+=
literal|":"
operator|+
name|c
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|MASTER_PORT
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|HConstants
operator|.
name|DEFAULT_MASTER_PORT
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
comment|/** @return HServerAddress of the master server */
specifier|public
name|HServerAddress
name|getMasterAddress
parameter_list|()
block|{
return|return
name|this
operator|.
name|address
return|;
block|}
specifier|public
name|long
name|getProtocolVersion
parameter_list|(
name|String
name|protocol
parameter_list|,
name|long
name|clientVersion
parameter_list|)
block|{
return|return
name|HBaseRPCProtocolVersion
operator|.
name|versionID
return|;
block|}
comment|/** @return InfoServer object. Maybe null.*/
specifier|public
name|InfoServer
name|getInfoServer
parameter_list|()
block|{
return|return
name|this
operator|.
name|infoServer
return|;
block|}
annotation|@
name|Override
specifier|public
name|Configuration
name|getConfiguration
parameter_list|()
block|{
return|return
name|this
operator|.
name|conf
return|;
block|}
annotation|@
name|Override
specifier|public
name|ServerManager
name|getServerManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|serverManager
return|;
block|}
annotation|@
name|Override
specifier|public
name|ExecutorService
name|getExecutorService
parameter_list|()
block|{
return|return
name|this
operator|.
name|executorService
return|;
block|}
annotation|@
name|Override
specifier|public
name|MasterFileSystem
name|getMasterFileSystem
parameter_list|()
block|{
return|return
name|this
operator|.
name|fileSystemManager
return|;
block|}
comment|/**    * Get the ZK wrapper object - needed by master_jsp.java    * @return the zookeeper wrapper    */
specifier|public
name|ZooKeeperWatcher
name|getZooKeeperWatcher
parameter_list|()
block|{
return|return
name|this
operator|.
name|zooKeeper
return|;
block|}
comment|/*    * Start up all services. If any of these threads gets an unhandled exception    * then they just die with a logged message.  This should be fine because    * in general, we do not expect the master to get such unhandled exceptions    *  as OOMEs; it should be lightly loaded. See what HRegionServer does if    *  need to install an unexpected exception handler.    */
specifier|private
name|void
name|startServiceThreads
parameter_list|()
block|{
try|try
block|{
comment|// Start the executor service pools
name|this
operator|.
name|executorService
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_OPEN_REGION
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.executor.openregion.threads"
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_CLOSE_REGION
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.executor.closeregion.threads"
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_SERVER_OPERATIONS
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.executor.serverops.threads"
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_TABLE_OPERATIONS
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.executor.tableops.threads"
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
comment|// Put up info server.
name|int
name|port
init|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.info.port"
argument_list|,
literal|60010
argument_list|)
decl_stmt|;
if|if
condition|(
name|port
operator|>=
literal|0
condition|)
block|{
name|String
name|a
init|=
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.master.info.bindAddress"
argument_list|,
literal|"0.0.0.0"
argument_list|)
decl_stmt|;
name|this
operator|.
name|infoServer
operator|=
operator|new
name|InfoServer
argument_list|(
name|MASTER
argument_list|,
name|a
argument_list|,
name|port
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|setAttribute
argument_list|(
name|MASTER
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|balancerChore
operator|=
name|getAndStartBalancerChore
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Start the server last so everything else is running before we start
comment|// receiving requests.
name|this
operator|.
name|rpcServer
operator|.
name|start
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Started service threads"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|RemoteException
condition|)
block|{
try|try
block|{
name|e
operator|=
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
operator|(
name|RemoteException
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"thread start"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Something happened during startup. Shut things down.
name|abort
argument_list|(
literal|"Failed startup"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|Chore
name|getAndStartBalancerChore
parameter_list|(
specifier|final
name|HMaster
name|master
parameter_list|)
block|{
name|String
name|name
init|=
name|master
operator|.
name|getServerName
argument_list|()
operator|+
literal|"-balancerChore"
decl_stmt|;
name|int
name|period
init|=
name|master
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"hbase.master.balancer.period"
argument_list|,
literal|3000000
argument_list|)
decl_stmt|;
comment|// Start up the load balancer chore
name|Chore
name|chore
init|=
operator|new
name|Chore
argument_list|(
name|name
argument_list|,
name|period
argument_list|,
name|master
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|chore
parameter_list|()
block|{
name|master
operator|.
name|balance
argument_list|()
expr_stmt|;
block|}
block|}
decl_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|chore
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|chore
return|;
block|}
specifier|public
name|MapWritable
name|regionServerStartup
parameter_list|(
specifier|final
name|HServerInfo
name|serverInfo
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Set the ip into the passed in serverInfo.  Its ip is more than likely
comment|// not the ip that the master sees here.  See at end of this method where
comment|// we pass it back to the regionserver by setting "hbase.regionserver.address"
comment|// Everafter, the HSI combination 'server name' is what uniquely identifies
comment|// the incoming RegionServer.  No more DNS meddling of this little messing
comment|// belose.
name|String
name|rsAddress
init|=
name|HBaseServer
operator|.
name|getRemoteAddress
argument_list|()
decl_stmt|;
name|serverInfo
operator|.
name|setServerAddress
argument_list|(
operator|new
name|HServerAddress
argument_list|(
name|rsAddress
argument_list|,
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|getPort
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Register with server manager
name|this
operator|.
name|serverManager
operator|.
name|regionServerStartup
argument_list|(
name|serverInfo
argument_list|)
expr_stmt|;
comment|// Send back some config info
name|MapWritable
name|mw
init|=
name|createConfigurationSubset
argument_list|()
decl_stmt|;
name|mw
operator|.
name|put
argument_list|(
operator|new
name|Text
argument_list|(
literal|"hbase.regionserver.address"
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
name|rsAddress
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mw
return|;
block|}
comment|/**    * @return Subset of configuration to pass initializing regionservers: e.g.    * the filesystem to use and root directory to use.    */
specifier|protected
name|MapWritable
name|createConfigurationSubset
parameter_list|()
block|{
name|MapWritable
name|mw
init|=
name|addConfig
argument_list|(
operator|new
name|MapWritable
argument_list|()
argument_list|,
name|HConstants
operator|.
name|HBASE_DIR
argument_list|)
decl_stmt|;
return|return
name|addConfig
argument_list|(
name|mw
argument_list|,
literal|"fs.default.name"
argument_list|)
return|;
block|}
specifier|private
name|MapWritable
name|addConfig
parameter_list|(
specifier|final
name|MapWritable
name|mw
parameter_list|,
specifier|final
name|String
name|key
parameter_list|)
block|{
name|mw
operator|.
name|put
argument_list|(
operator|new
name|Text
argument_list|(
name|key
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mw
return|;
block|}
annotation|@
name|Override
specifier|public
name|HMsg
index|[]
name|regionServerReport
parameter_list|(
name|HServerInfo
name|serverInfo
parameter_list|,
name|HMsg
name|msgs
index|[]
parameter_list|,
name|HRegionInfo
index|[]
name|mostLoadedRegions
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|adornRegionServerAnswer
argument_list|(
name|serverInfo
argument_list|,
name|this
operator|.
name|serverManager
operator|.
name|regionServerReport
argument_list|(
name|serverInfo
argument_list|,
name|msgs
argument_list|,
name|mostLoadedRegions
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Override if you'd add messages to return to regionserver<code>hsi</code>    * or to send an exception.    * @param msgs Messages to add to    * @return Messages to return to    * @throws IOException exceptions that were injected for the region servers    */
specifier|protected
name|HMsg
index|[]
name|adornRegionServerAnswer
parameter_list|(
specifier|final
name|HServerInfo
name|hsi
parameter_list|,
specifier|final
name|HMsg
index|[]
name|msgs
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|msgs
return|;
block|}
specifier|public
name|boolean
name|isMasterRunning
parameter_list|()
block|{
return|return
operator|!
name|isStopped
argument_list|()
return|;
block|}
comment|/**    * Run the balancer.    * @return True if balancer ran, false otherwise.    */
specifier|public
name|boolean
name|balance
parameter_list|()
block|{
comment|// If balance not true, don't run balancer.
if|if
condition|(
operator|!
name|this
operator|.
name|balance
condition|)
return|return
literal|false
return|;
synchronized|synchronized
init|(
name|this
operator|.
name|balancer
init|)
block|{
comment|// Only allow one balance run at at time.
if|if
condition|(
name|this
operator|.
name|assignmentManager
operator|.
name|isRegionsInTransition
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Not running balancer because regions in transition: "
operator|+
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionsInTransition
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|this
operator|.
name|serverManager
operator|.
name|getDeadServers
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Not running balancer because dead regionserver processing"
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|HServerInfo
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|assignments
init|=
name|this
operator|.
name|assignmentManager
operator|.
name|getAssignments
argument_list|()
decl_stmt|;
comment|// Returned Map from AM does not include mention of servers w/o assignments.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|HServerInfo
argument_list|>
name|e
range|:
name|this
operator|.
name|serverManager
operator|.
name|getOnlineServers
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|HServerInfo
name|hsi
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|assignments
operator|.
name|containsKey
argument_list|(
name|hsi
argument_list|)
condition|)
block|{
name|assignments
operator|.
name|put
argument_list|(
name|hsi
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|RegionPlan
argument_list|>
name|plans
init|=
name|this
operator|.
name|balancer
operator|.
name|balanceCluster
argument_list|(
name|assignments
argument_list|)
decl_stmt|;
if|if
condition|(
name|plans
operator|!=
literal|null
operator|&&
operator|!
name|plans
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|RegionPlan
name|plan
range|:
name|plans
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"balance="
operator|+
name|plan
argument_list|)
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|.
name|balance
argument_list|(
name|plan
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|balance
parameter_list|(
specifier|final
name|boolean
name|b
parameter_list|)
block|{
name|boolean
name|oldValue
init|=
name|this
operator|.
name|balance
decl_stmt|;
name|this
operator|.
name|balance
operator|=
name|b
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Balance="
operator|+
name|b
argument_list|)
expr_stmt|;
return|return
name|oldValue
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|move
parameter_list|(
specifier|final
name|byte
index|[]
name|encodedRegionName
parameter_list|,
specifier|final
name|byte
index|[]
name|destServerName
parameter_list|)
throws|throws
name|UnknownRegionException
block|{
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerInfo
argument_list|>
name|p
init|=
name|this
operator|.
name|assignmentManager
operator|.
name|getAssignment
argument_list|(
name|encodedRegionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|null
condition|)
throw|throw
operator|new
name|UnknownRegionException
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|encodedRegionName
argument_list|)
argument_list|)
throw|;
name|HServerInfo
name|dest
init|=
name|this
operator|.
name|serverManager
operator|.
name|getServerInfo
argument_list|(
operator|new
name|String
argument_list|(
name|destServerName
argument_list|)
argument_list|)
decl_stmt|;
name|RegionPlan
name|rp
init|=
operator|new
name|RegionPlan
argument_list|(
name|p
operator|.
name|getFirst
argument_list|()
argument_list|,
name|p
operator|.
name|getSecond
argument_list|()
argument_list|,
name|dest
argument_list|)
decl_stmt|;
name|this
operator|.
name|assignmentManager
operator|.
name|balance
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|createTable
parameter_list|(
name|HTableDescriptor
name|desc
parameter_list|,
name|byte
index|[]
index|[]
name|splitKeys
parameter_list|)
throws|throws
name|IOException
block|{
name|createTable
argument_list|(
name|desc
argument_list|,
name|splitKeys
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|createTable
parameter_list|(
name|HTableDescriptor
name|desc
parameter_list|,
name|byte
index|[]
index|[]
name|splitKeys
parameter_list|,
name|boolean
name|sync
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isMasterRunning
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MasterNotRunningException
argument_list|()
throw|;
block|}
name|HRegionInfo
index|[]
name|newRegions
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|splitKeys
operator|==
literal|null
operator|||
name|splitKeys
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|newRegions
operator|=
operator|new
name|HRegionInfo
index|[]
block|{
operator|new
name|HRegionInfo
argument_list|(
name|desc
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
block|}
expr_stmt|;
block|}
else|else
block|{
name|int
name|numRegions
init|=
name|splitKeys
operator|.
name|length
operator|+
literal|1
decl_stmt|;
name|newRegions
operator|=
operator|new
name|HRegionInfo
index|[
name|numRegions
index|]
expr_stmt|;
name|byte
index|[]
name|startKey
init|=
literal|null
decl_stmt|;
name|byte
index|[]
name|endKey
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numRegions
condition|;
name|i
operator|++
control|)
block|{
name|endKey
operator|=
operator|(
name|i
operator|==
name|splitKeys
operator|.
name|length
operator|)
condition|?
literal|null
else|:
name|splitKeys
index|[
name|i
index|]
expr_stmt|;
name|newRegions
index|[
name|i
index|]
operator|=
operator|new
name|HRegionInfo
argument_list|(
name|desc
argument_list|,
name|startKey
argument_list|,
name|endKey
argument_list|)
expr_stmt|;
name|startKey
operator|=
name|endKey
expr_stmt|;
block|}
block|}
name|int
name|timeout
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.client.catalog.timeout"
argument_list|,
literal|10000
argument_list|)
decl_stmt|;
comment|// Need META availability to create a table
try|try
block|{
if|if
condition|(
name|catalogTracker
operator|.
name|waitForMeta
argument_list|(
name|timeout
argument_list|)
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NotAllMetaRegionsOnlineException
argument_list|()
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted waiting for meta availability"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|createTable
argument_list|(
name|newRegions
argument_list|,
name|sync
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|synchronized
name|void
name|createTable
parameter_list|(
specifier|final
name|HRegionInfo
index|[]
name|newRegions
parameter_list|,
name|boolean
name|sync
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|tableName
init|=
name|newRegions
index|[
literal|0
index|]
operator|.
name|getTableDesc
argument_list|()
operator|.
name|getNameAsString
argument_list|()
decl_stmt|;
if|if
condition|(
name|MetaReader
operator|.
name|tableExists
argument_list|(
name|catalogTracker
argument_list|,
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TableExistsException
argument_list|(
name|tableName
argument_list|)
throw|;
block|}
for|for
control|(
name|HRegionInfo
name|newRegion
range|:
name|newRegions
control|)
block|{
comment|// 1. Create HRegion
name|HRegion
name|region
init|=
name|HRegion
operator|.
name|createHRegion
argument_list|(
name|newRegion
argument_list|,
name|fileSystemManager
operator|.
name|getRootDir
argument_list|()
argument_list|,
name|conf
argument_list|)
decl_stmt|;
comment|// 2. Insert into META
name|MetaEditor
operator|.
name|addRegionToMeta
argument_list|(
name|catalogTracker
argument_list|,
name|region
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
comment|// 3. Close the new region to flush to disk.  Close log file too.
name|region
operator|.
name|close
argument_list|()
expr_stmt|;
name|region
operator|.
name|getLog
argument_list|()
operator|.
name|closeAndDelete
argument_list|()
expr_stmt|;
comment|// 4. Trigger immediate assignment of this region
name|assignmentManager
operator|.
name|assign
argument_list|(
name|region
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// 5. If sync, wait for assignment of regions
if|if
condition|(
name|sync
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting for "
operator|+
name|newRegions
operator|.
name|length
operator|+
literal|" region(s) to be "
operator|+
literal|"assigned before returning"
argument_list|)
expr_stmt|;
for|for
control|(
name|HRegionInfo
name|regionInfo
range|:
name|newRegions
control|)
block|{
try|try
block|{
name|assignmentManager
operator|.
name|waitForAssignment
argument_list|(
name|regionInfo
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Interrupted waiting for region to be assigned during "
operator|+
literal|"create table call"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
specifier|private
specifier|static
name|boolean
name|isCatalogTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|tableName
argument_list|,
name|HConstants
operator|.
name|ROOT_TABLE_NAME
argument_list|)
operator|||
name|Bytes
operator|.
name|equals
argument_list|(
name|tableName
argument_list|,
name|HConstants
operator|.
name|META_TABLE_NAME
argument_list|)
return|;
block|}
specifier|public
name|void
name|deleteTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
operator|new
name|DeleteTableHandler
argument_list|(
name|tableName
argument_list|,
name|this
argument_list|,
name|this
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|addColumn
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|,
name|HColumnDescriptor
name|column
parameter_list|)
throws|throws
name|IOException
block|{
operator|new
name|TableAddFamilyHandler
argument_list|(
name|tableName
argument_list|,
name|column
argument_list|,
name|this
argument_list|,
name|this
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|modifyColumn
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|,
name|HColumnDescriptor
name|descriptor
parameter_list|)
throws|throws
name|IOException
block|{
operator|new
name|TableModifyFamilyHandler
argument_list|(
name|tableName
argument_list|,
name|descriptor
argument_list|,
name|this
argument_list|,
name|this
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|deleteColumn
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|c
parameter_list|)
throws|throws
name|IOException
block|{
operator|new
name|TableDeleteFamilyHandler
argument_list|(
name|tableName
argument_list|,
name|c
argument_list|,
name|this
argument_list|,
name|this
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|enableTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
operator|new
name|EnableTableHandler
argument_list|(
name|this
argument_list|,
name|tableName
argument_list|,
name|catalogTracker
argument_list|,
name|assignmentManager
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|disableTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
operator|new
name|DisableTableHandler
argument_list|(
name|this
argument_list|,
name|tableName
argument_list|,
name|catalogTracker
argument_list|,
name|assignmentManager
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
block|}
comment|/**    * Return the region and current deployment for the region containing    * the given row. If the region cannot be found, returns null. If it    * is found, but not currently deployed, the second element of the pair    * may be null.    */
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerAddress
argument_list|>
name|getTableRegionForRow
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|rowKey
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|AtomicReference
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerAddress
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|AtomicReference
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerAddress
argument_list|>
argument_list|>
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|MetaScannerVisitor
name|visitor
init|=
operator|new
name|MetaScannerVisitor
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|processRow
parameter_list|(
name|Result
name|data
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|data
operator|==
literal|null
operator|||
name|data
operator|.
name|size
argument_list|()
operator|<=
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerAddress
argument_list|>
name|pair
init|=
name|MetaReader
operator|.
name|metaRowToRegionPair
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|pair
operator|.
name|getFirst
argument_list|()
operator|.
name|getTableDesc
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|tableName
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|result
operator|.
name|set
argument_list|(
name|pair
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
decl_stmt|;
name|MetaScanner
operator|.
name|metaScan
argument_list|(
name|conf
argument_list|,
name|visitor
argument_list|,
name|tableName
argument_list|,
name|rowKey
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|result
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|modifyTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
name|HTableDescriptor
name|htd
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|ModifyTableHandler
argument_list|(
name|tableName
argument_list|,
name|htd
argument_list|,
name|this
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|checkTableModifiable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|tableNameStr
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|isCatalogTable
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can't modify catalog tables"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|MetaReader
operator|.
name|tableExists
argument_list|(
name|getCatalogTracker
argument_list|()
argument_list|,
name|tableNameStr
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TableNotFoundException
argument_list|(
name|tableNameStr
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|getAssignmentManager
argument_list|()
operator|.
name|isTableDisabled
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TableNotDisabledException
argument_list|(
name|tableName
argument_list|)
throw|;
block|}
block|}
comment|/**    * @return cluster status    */
specifier|public
name|ClusterStatus
name|getClusterStatus
parameter_list|()
block|{
name|ClusterStatus
name|status
init|=
operator|new
name|ClusterStatus
argument_list|()
decl_stmt|;
name|status
operator|.
name|setHBaseVersion
argument_list|(
name|VersionInfo
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
name|status
operator|.
name|setServerInfo
argument_list|(
name|serverManager
operator|.
name|getOnlineServers
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|status
operator|.
name|setDeadServers
argument_list|(
name|serverManager
operator|.
name|getDeadServers
argument_list|()
argument_list|)
expr_stmt|;
name|status
operator|.
name|setRegionsInTransition
argument_list|(
name|assignmentManager
operator|.
name|getRegionsInTransition
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|abort
parameter_list|(
specifier|final
name|String
name|msg
parameter_list|,
specifier|final
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
name|LOG
operator|.
name|fatal
argument_list|(
name|msg
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|LOG
operator|.
name|fatal
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|this
operator|.
name|abort
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|ZooKeeperWatcher
name|getZooKeeper
parameter_list|()
block|{
return|return
name|zooKeeper
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getServerName
parameter_list|()
block|{
return|return
name|address
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|CatalogTracker
name|getCatalogTracker
parameter_list|()
block|{
return|return
name|catalogTracker
return|;
block|}
annotation|@
name|Override
specifier|public
name|AssignmentManager
name|getAssignmentManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|assignmentManager
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|this
operator|.
name|serverManager
operator|.
name|shutdownCluster
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|clusterStatusTracker
operator|.
name|setClusterDown
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"ZooKeeper exception trying to set cluster as down in ZK"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|stopMaster
parameter_list|()
block|{
name|stop
argument_list|(
literal|"Stopped by "
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|stop
parameter_list|(
specifier|final
name|String
name|why
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|why
argument_list|)
expr_stmt|;
name|this
operator|.
name|stopped
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isStopped
parameter_list|()
block|{
return|return
name|this
operator|.
name|stopped
return|;
block|}
specifier|public
name|void
name|assignRegion
parameter_list|(
name|HRegionInfo
name|hri
parameter_list|)
block|{
name|assignmentManager
operator|.
name|assign
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
comment|/**    * Utility for constructing an instance of the passed HMaster class.    * @param masterClass    * @param conf    * @return HMaster instance.    */
specifier|public
specifier|static
name|HMaster
name|constructMaster
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|HMaster
argument_list|>
name|masterClass
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|)
block|{
try|try
block|{
name|Constructor
argument_list|<
name|?
extends|extends
name|HMaster
argument_list|>
name|c
init|=
name|masterClass
operator|.
name|getConstructor
argument_list|(
name|Configuration
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|c
operator|.
name|newInstance
argument_list|(
name|conf
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|ite
parameter_list|)
block|{
name|Throwable
name|target
init|=
name|ite
operator|.
name|getTargetException
argument_list|()
operator|!=
literal|null
condition|?
name|ite
operator|.
name|getTargetException
argument_list|()
else|:
name|ite
decl_stmt|;
if|if
condition|(
name|target
operator|.
name|getCause
argument_list|()
operator|!=
literal|null
condition|)
name|target
operator|=
name|target
operator|.
name|getCause
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Failed construction of Master: "
operator|+
name|masterClass
operator|.
name|toString
argument_list|()
argument_list|,
name|target
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Failed construction of Master: "
operator|+
name|masterClass
operator|.
name|toString
argument_list|()
operator|+
operator|(
operator|(
name|e
operator|.
name|getCause
argument_list|()
operator|!=
literal|null
operator|)
condition|?
name|e
operator|.
name|getCause
argument_list|()
operator|.
name|getMessage
argument_list|()
else|:
literal|""
operator|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * @see org.apache.hadoop.hbase.master.HMasterCommandLine    */
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
operator|new
name|HMasterCommandLine
argument_list|(
name|HMaster
operator|.
name|class
argument_list|)
operator|.
name|doMain
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

