begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2011 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Chore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ClusterStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HColumnDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerLoad
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MasterNotRunningException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NotAllMetaRegionsOnlineException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableDescriptors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotDisabledException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|UnknownRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|CatalogTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|MetaEditor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|MetaReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Get
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MetaScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MetaScanner
operator|.
name|MetaScannerVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|ExecutorService
operator|.
name|ExecutorType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HBaseRPC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HBaseServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HMasterInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HMasterRegionInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|RpcServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|RegionPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|DeleteTableHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|DisableTableHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|EnableTableHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|ModifyTableHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|TableAddFamilyHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|TableDeleteFamilyHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|TableModifyFamilyHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|handler
operator|.
name|CreateTableHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|metrics
operator|.
name|MasterMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|monitoring
operator|.
name|MemoryBoundedLogMessageBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|monitoring
operator|.
name|MonitoredTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|monitoring
operator|.
name|TaskMonitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|wal
operator|.
name|HLog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|regionserver
operator|.
name|Replication
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|User
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSTableDescriptors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|InfoServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Sleeper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|VersionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ClusterId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ClusterStatusTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|RegionServerTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|MapWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|DNS
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|Watcher
import|;
end_import

begin_comment
comment|/**  * HMaster is the "master server" for HBase. An HBase cluster has one active  * master.  If many masters are started, all compete.  Whichever wins goes on to  * run the cluster.  All others park themselves in their constructor until  * master or cluster shutdown or until the active master loses its lease in  * zookeeper.  Thereafter, all running master jostle to take over master role.  *  *<p>The Master can be asked shutdown the cluster. See {@link #shutdown()}.  In  * this case it will tell all regionservers to go down and then wait on them  * all reporting in that they are down.  This master will then shut itself down.  *  *<p>You can also shutdown just this master.  Call {@link #stopMaster()}.  *  * @see HMasterInterface  * @see HMasterRegionInterface  * @see Watcher  */
end_comment

begin_class
specifier|public
class|class
name|HMaster
extends|extends
name|Thread
implements|implements
name|HMasterInterface
implements|,
name|HMasterRegionInterface
implements|,
name|MasterServices
implements|,
name|Server
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HMaster
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|// MASTER is name of the webapp and the attribute name used stuffing this
comment|//instance into web context.
specifier|public
specifier|static
specifier|final
name|String
name|MASTER
init|=
literal|"master"
decl_stmt|;
comment|// The configuration for the Master
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
comment|// server for the web ui
specifier|private
name|InfoServer
name|infoServer
decl_stmt|;
comment|// Our zk client.
specifier|private
name|ZooKeeperWatcher
name|zooKeeper
decl_stmt|;
comment|// Manager and zk listener for master election
specifier|private
name|ActiveMasterManager
name|activeMasterManager
decl_stmt|;
comment|// Region server tracker
specifier|private
name|RegionServerTracker
name|regionServerTracker
decl_stmt|;
comment|// RPC server for the HMaster
specifier|private
specifier|final
name|RpcServer
name|rpcServer
decl_stmt|;
comment|/**    * This servers address.    */
specifier|private
specifier|final
name|InetSocketAddress
name|isa
decl_stmt|;
comment|// Metrics for the HMaster
specifier|private
specifier|final
name|MasterMetrics
name|metrics
decl_stmt|;
comment|// file system manager for the master FS operations
specifier|private
name|MasterFileSystem
name|fileSystemManager
decl_stmt|;
comment|// server manager to deal with region server info
specifier|private
name|ServerManager
name|serverManager
decl_stmt|;
comment|// manager of assignment nodes in zookeeper
name|AssignmentManager
name|assignmentManager
decl_stmt|;
comment|// manager of catalog regions
specifier|private
name|CatalogTracker
name|catalogTracker
decl_stmt|;
comment|// Cluster status zk tracker and local setter
specifier|private
name|ClusterStatusTracker
name|clusterStatusTracker
decl_stmt|;
comment|// buffer for "fatal error" notices from region servers
comment|// in the cluster. This is only used for assisting
comment|// operations/debugging.
specifier|private
name|MemoryBoundedLogMessageBuffer
name|rsFatals
decl_stmt|;
comment|// This flag is for stopping this Master instance.  Its set when we are
comment|// stopping or aborting
specifier|private
specifier|volatile
name|boolean
name|stopped
init|=
literal|false
decl_stmt|;
comment|// Set on abort -- usually failure of our zk session.
specifier|private
specifier|volatile
name|boolean
name|abort
init|=
literal|false
decl_stmt|;
comment|// flag set after we become the active master (used for testing)
specifier|private
specifier|volatile
name|boolean
name|isActiveMaster
init|=
literal|false
decl_stmt|;
comment|// flag set after we complete initialization once active (used for testing)
specifier|private
specifier|volatile
name|boolean
name|initialized
init|=
literal|false
decl_stmt|;
comment|// Instance of the hbase executor service.
name|ExecutorService
name|executorService
decl_stmt|;
specifier|private
name|LoadBalancer
name|balancer
decl_stmt|;
specifier|private
name|Thread
name|balancerChore
decl_stmt|;
comment|// If 'true', the balancer is 'on'.  If 'false', the balancer will not run.
specifier|private
specifier|volatile
name|boolean
name|balanceSwitch
init|=
literal|true
decl_stmt|;
specifier|private
name|Thread
name|catalogJanitorChore
decl_stmt|;
specifier|private
name|LogCleaner
name|logCleaner
decl_stmt|;
specifier|private
name|MasterCoprocessorHost
name|cpHost
decl_stmt|;
specifier|private
specifier|final
name|ServerName
name|serverName
decl_stmt|;
specifier|private
name|TableDescriptors
name|tableDescriptors
decl_stmt|;
comment|/**    * Initializes the HMaster. The steps are as follows:    *<p>    *<ol>    *<li>Initialize HMaster RPC and address    *<li>Connect to ZooKeeper.    *</ol>    *<p>    * Remaining steps of initialization occur in {@link #run()} so that they    * run in their own thread rather than within the context of the constructor.    * @throws InterruptedException    */
specifier|public
name|HMaster
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
throws|,
name|KeeperException
throws|,
name|InterruptedException
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
comment|// Server to handle client requests.
name|String
name|hostname
init|=
name|DNS
operator|.
name|getDefaultHost
argument_list|(
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.master.dns.interface"
argument_list|,
literal|"default"
argument_list|)
argument_list|,
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.master.dns.nameserver"
argument_list|,
literal|"default"
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|port
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|MASTER_PORT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_MASTER_PORT
argument_list|)
decl_stmt|;
comment|// Creation of a HSA will force a resolve.
name|InetSocketAddress
name|initialIsa
init|=
operator|new
name|InetSocketAddress
argument_list|(
name|hostname
argument_list|,
name|port
argument_list|)
decl_stmt|;
if|if
condition|(
name|initialIsa
operator|.
name|getAddress
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Failed resolve of "
operator|+
name|this
operator|.
name|isa
argument_list|)
throw|;
block|}
name|int
name|numHandlers
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.handler.count"
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.handler.count"
argument_list|,
literal|25
argument_list|)
argument_list|)
decl_stmt|;
name|this
operator|.
name|rpcServer
operator|=
name|HBaseRPC
operator|.
name|getServer
argument_list|(
name|this
argument_list|,
operator|new
name|Class
argument_list|<
name|?
argument_list|>
index|[]
block|{
name|HMasterInterface
operator|.
name|class
operator|,
name|HMasterRegionInterface
operator|.
name|class
block|}
operator|,
name|initialIsa
operator|.
name|getHostName
argument_list|()
operator|,
comment|// BindAddress is IP we got for this server.
name|initialIsa
operator|.
name|getPort
argument_list|()
operator|,
name|numHandlers
operator|,
literal|0
operator|,
comment|// we dont use high priority handlers in master
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.rpc.verbose"
argument_list|,
literal|false
argument_list|)
operator|,
name|conf
operator|,
literal|0
block|)
empty_stmt|;
comment|// this is a DNC w/o high priority handlers
comment|// Set our address.
name|this
operator|.
name|isa
operator|=
name|this
operator|.
name|rpcServer
operator|.
name|getListenerAddress
argument_list|()
expr_stmt|;
name|this
operator|.
name|serverName
operator|=
operator|new
name|ServerName
argument_list|(
name|this
operator|.
name|isa
operator|.
name|getHostName
argument_list|()
argument_list|,
name|this
operator|.
name|isa
operator|.
name|getPort
argument_list|()
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|rsFatals
operator|=
operator|new
name|MemoryBoundedLogMessageBuffer
argument_list|(
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.master.buffer.for.rs.fatals"
argument_list|,
literal|1
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
argument_list|)
expr_stmt|;
comment|// initialize server principal (if using secure Hadoop)
name|User
operator|.
name|login
argument_list|(
name|conf
argument_list|,
literal|"hbase.master.keytab.file"
argument_list|,
literal|"hbase.master.kerberos.principal"
argument_list|,
name|this
operator|.
name|isa
operator|.
name|getHostName
argument_list|()
argument_list|)
expr_stmt|;
comment|// set the thread name now we have an address
name|setName
argument_list|(
name|MASTER
operator|+
literal|"-"
operator|+
name|this
operator|.
name|serverName
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|Replication
operator|.
name|decorateMasterConfiguration
parameter_list|(
name|this
operator|.
name|conf
parameter_list|)
constructor_decl|;
name|this
operator|.
name|rpcServer
operator|.
name|startThreads
parameter_list|()
constructor_decl|;
comment|// Hack! Maps DFSClient => Master for logs.  HDFS made this
comment|// config param for task trackers, but we can piggyback off of it.
if|if
condition|(
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
literal|"mapred.task.id"
argument_list|)
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|conf
operator|.
name|set
argument_list|(
literal|"mapred.task.id"
argument_list|,
literal|"hb_m_"
operator|+
name|this
operator|.
name|serverName
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|zooKeeper
operator|=
operator|new
name|ZooKeeperWatcher
argument_list|(
name|conf
argument_list|,
name|MASTER
operator|+
literal|":"
operator|+
name|isa
operator|.
name|getPort
argument_list|()
argument_list|,
name|this
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|=
operator|new
name|MasterMetrics
argument_list|(
name|getServerName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_class

begin_comment
comment|/**    * Stall startup if we are designated a backup master; i.e. we want someone    * else to become the master before proceeding.    * @param c    * @param amm    * @throws InterruptedException    */
end_comment

begin_function
specifier|private
specifier|static
name|void
name|stallIfBackupMaster
parameter_list|(
specifier|final
name|Configuration
name|c
parameter_list|,
specifier|final
name|ActiveMasterManager
name|amm
parameter_list|)
throws|throws
name|InterruptedException
block|{
comment|// If we're a backup master, stall until a primary to writes his address
if|if
condition|(
operator|!
name|c
operator|.
name|getBoolean
argument_list|(
name|HConstants
operator|.
name|MASTER_TYPE_BACKUP
argument_list|,
name|HConstants
operator|.
name|DEFAULT_MASTER_TYPE_BACKUP
argument_list|)
condition|)
block|{
return|return;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"HMaster started in backup mode.  "
operator|+
literal|"Stalling until master znode is written."
argument_list|)
expr_stmt|;
comment|// This will only be a minute or so while the cluster starts up,
comment|// so don't worry about setting watches on the parent znode
while|while
condition|(
operator|!
name|amm
operator|.
name|isActiveMaster
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting for master address ZNode to be written "
operator|+
literal|"(Also watching cluster state node)"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|c
operator|.
name|getInt
argument_list|(
literal|"zookeeper.session.timeout"
argument_list|,
literal|180
operator|*
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * Main processing loop for the HMaster.    *<ol>    *<li>Block until becoming active master    *<li>Finish initialization via {@link #finishInitialization()}    *<li>Enter loop until we are stopped    *<li>Stop services and perform cleanup once stopped    *</ol>    */
end_comment

begin_function
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|MonitoredTask
name|startupStatus
init|=
name|TaskMonitor
operator|.
name|get
argument_list|()
operator|.
name|createStatus
argument_list|(
literal|"Master startup"
argument_list|)
decl_stmt|;
name|startupStatus
operator|.
name|setDescription
argument_list|(
literal|"Master startup"
argument_list|)
expr_stmt|;
try|try
block|{
comment|/*        * Block on becoming the active master.        *        * We race with other masters to write our address into ZooKeeper.  If we        * succeed, we are the primary/active master and finish initialization.        *        * If we do not succeed, there is another active master and we should        * now wait until it dies to try and become the next active master.  If we        * do not succeed on our first attempt, this is no longer a cluster startup.        */
name|becomeActiveMaster
argument_list|(
name|startupStatus
argument_list|)
expr_stmt|;
comment|// We are either the active master or we were asked to shutdown
if|if
condition|(
operator|!
name|this
operator|.
name|stopped
condition|)
block|{
name|finishInitialization
argument_list|(
name|startupStatus
argument_list|)
expr_stmt|;
name|loop
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|abort
argument_list|(
literal|"Unhandled exception. Starting shutdown."
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|startupStatus
operator|.
name|cleanup
argument_list|()
expr_stmt|;
name|stopChores
argument_list|()
expr_stmt|;
comment|// Wait for all the remaining region servers to report in IFF we were
comment|// running a cluster shutdown AND we were NOT aborting.
if|if
condition|(
operator|!
name|this
operator|.
name|abort
operator|&&
name|this
operator|.
name|serverManager
operator|!=
literal|null
operator|&&
name|this
operator|.
name|serverManager
operator|.
name|isClusterShutdown
argument_list|()
condition|)
block|{
name|this
operator|.
name|serverManager
operator|.
name|letRegionServersShutdown
argument_list|()
expr_stmt|;
block|}
name|stopServiceThreads
argument_list|()
expr_stmt|;
comment|// Stop services started for both backup and active masters
if|if
condition|(
name|this
operator|.
name|activeMasterManager
operator|!=
literal|null
condition|)
name|this
operator|.
name|activeMasterManager
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|catalogTracker
operator|!=
literal|null
condition|)
name|this
operator|.
name|catalogTracker
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|serverManager
operator|!=
literal|null
condition|)
name|this
operator|.
name|serverManager
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|assignmentManager
operator|!=
literal|null
condition|)
name|this
operator|.
name|assignmentManager
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|fileSystemManager
operator|!=
literal|null
condition|)
name|this
operator|.
name|fileSystemManager
operator|.
name|stop
argument_list|()
expr_stmt|;
name|this
operator|.
name|zooKeeper
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"HMaster main thread exiting"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Try becoming active master.    * @param startupStatus     * @return True if we could successfully become the active master.    * @throws InterruptedException    */
end_comment

begin_function
specifier|private
name|boolean
name|becomeActiveMaster
parameter_list|(
name|MonitoredTask
name|startupStatus
parameter_list|)
throws|throws
name|InterruptedException
block|{
comment|// TODO: This is wrong!!!! Should have new servername if we restart ourselves,
comment|// if we come back to life.
name|this
operator|.
name|activeMasterManager
operator|=
operator|new
name|ActiveMasterManager
argument_list|(
name|zooKeeper
argument_list|,
name|this
operator|.
name|serverName
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|zooKeeper
operator|.
name|registerListener
argument_list|(
name|activeMasterManager
argument_list|)
expr_stmt|;
name|stallIfBackupMaster
argument_list|(
name|this
operator|.
name|conf
argument_list|,
name|this
operator|.
name|activeMasterManager
argument_list|)
expr_stmt|;
return|return
name|this
operator|.
name|activeMasterManager
operator|.
name|blockUntilBecomingActiveMaster
argument_list|(
name|startupStatus
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Initilize all ZK based system trackers.    * @throws IOException    * @throws InterruptedException    */
end_comment

begin_function
specifier|private
name|void
name|initializeZKBasedSystemTrackers
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|KeeperException
block|{
name|this
operator|.
name|catalogTracker
operator|=
operator|new
name|CatalogTracker
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|this
operator|.
name|conf
argument_list|,
name|this
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.catalog.timeout"
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|catalogTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|=
operator|new
name|AssignmentManager
argument_list|(
name|this
argument_list|,
name|serverManager
argument_list|,
name|this
operator|.
name|catalogTracker
argument_list|,
name|this
operator|.
name|executorService
argument_list|)
expr_stmt|;
name|this
operator|.
name|balancer
operator|=
name|LoadBalancerFactory
operator|.
name|getLoadBalancer
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|zooKeeper
operator|.
name|registerListenerFirst
argument_list|(
name|assignmentManager
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionServerTracker
operator|=
operator|new
name|RegionServerTracker
argument_list|(
name|zooKeeper
argument_list|,
name|this
argument_list|,
name|this
operator|.
name|serverManager
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionServerTracker
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Set the cluster as up.  If new RSs, they'll be waiting on this before
comment|// going ahead with their startup.
name|this
operator|.
name|clusterStatusTracker
operator|=
operator|new
name|ClusterStatusTracker
argument_list|(
name|getZooKeeper
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|clusterStatusTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|boolean
name|wasUp
init|=
name|this
operator|.
name|clusterStatusTracker
operator|.
name|isClusterUp
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|wasUp
condition|)
name|this
operator|.
name|clusterStatusTracker
operator|.
name|setClusterUp
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Server active/primary master; "
operator|+
name|this
operator|.
name|serverName
operator|+
literal|", sessionid=0x"
operator|+
name|Long
operator|.
name|toHexString
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|getSessionId
argument_list|()
argument_list|)
operator|+
literal|", cluster-up flag was="
operator|+
name|wasUp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|loop
parameter_list|()
block|{
comment|// Check if we should stop every second.
name|Sleeper
name|sleeper
init|=
operator|new
name|Sleeper
argument_list|(
literal|1000
argument_list|,
name|this
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|this
operator|.
name|stopped
condition|)
block|{
name|sleeper
operator|.
name|sleep
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * Finish initialization of HMaster after becoming the primary master.    *    *<ol>    *<li>Initialize master components - file system manager, server manager,    *     assignment manager, region server tracker, catalog tracker, etc</li>    *<li>Start necessary service threads - rpc server, info server,    *     executor services, etc</li>    *<li>Set cluster as UP in ZooKeeper</li>    *<li>Wait for RegionServers to check-in</li>    *<li>Split logs and perform data recovery, if necessary</li>    *<li>Ensure assignment of root and meta regions<li>    *<li>Handle either fresh cluster start or master failover</li>    *</ol>    *    * @throws IOException    * @throws InterruptedException    * @throws KeeperException    */
end_comment

begin_function
specifier|private
name|void
name|finishInitialization
parameter_list|(
name|MonitoredTask
name|status
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|KeeperException
block|{
name|isActiveMaster
operator|=
literal|true
expr_stmt|;
comment|/*      * We are active master now... go initialize components we need to run.      * Note, there may be dross in zk from previous runs; it'll get addressed      * below after we determine if cluster startup or failover.      */
name|status
operator|.
name|setStatus
argument_list|(
literal|"Initializing Master file system"
argument_list|)
expr_stmt|;
comment|// TODO: Do this using Dependency Injection, using PicoContainer, Guice or Spring.
name|this
operator|.
name|fileSystemManager
operator|=
operator|new
name|MasterFileSystem
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|metrics
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableDescriptors
operator|=
operator|new
name|FSTableDescriptors
argument_list|(
name|this
operator|.
name|fileSystemManager
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|this
operator|.
name|fileSystemManager
operator|.
name|getRootDir
argument_list|()
argument_list|)
expr_stmt|;
comment|// publish cluster ID
name|status
operator|.
name|setStatus
argument_list|(
literal|"Publishing Cluster ID in ZooKeeper"
argument_list|)
expr_stmt|;
name|ClusterId
operator|.
name|setClusterId
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|fileSystemManager
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|=
operator|new
name|ExecutorService
argument_list|(
name|getServerName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|serverManager
operator|=
operator|new
name|ServerManager
argument_list|(
name|this
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Initializing ZK system trackers"
argument_list|)
expr_stmt|;
name|initializeZKBasedSystemTrackers
argument_list|()
expr_stmt|;
comment|// initialize master side coprocessors before we start handling requests
name|status
operator|.
name|setStatus
argument_list|(
literal|"Initializing master coprocessors"
argument_list|)
expr_stmt|;
name|this
operator|.
name|cpHost
operator|=
operator|new
name|MasterCoprocessorHost
argument_list|(
name|this
argument_list|,
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
comment|// start up all service threads.
name|status
operator|.
name|setStatus
argument_list|(
literal|"Initializing master service threads"
argument_list|)
expr_stmt|;
name|startServiceThreads
argument_list|()
expr_stmt|;
comment|// Wait for region servers to report in.
name|this
operator|.
name|serverManager
operator|.
name|waitForRegionServers
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|// Check zk for regionservers that are up but didn't register
for|for
control|(
name|ServerName
name|sn
range|:
name|this
operator|.
name|regionServerTracker
operator|.
name|getOnlineServers
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|sn
argument_list|)
condition|)
block|{
comment|// Not registered; add it.
name|LOG
operator|.
name|info
argument_list|(
literal|"Registering server found up in zk: "
operator|+
name|sn
argument_list|)
expr_stmt|;
name|this
operator|.
name|serverManager
operator|.
name|recordNewServer
argument_list|(
name|sn
argument_list|,
name|HServerLoad
operator|.
name|EMPTY_HSERVERLOAD
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO: Should do this in background rather than block master startup
name|status
operator|.
name|setStatus
argument_list|(
literal|"Splitting logs after master startup"
argument_list|)
expr_stmt|;
name|this
operator|.
name|fileSystemManager
operator|.
name|splitLogAfterStartup
argument_list|(
name|this
operator|.
name|serverManager
operator|.
name|getOnlineServers
argument_list|()
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
comment|// Make sure root and meta assigned before proceeding.
name|assignRootAndMeta
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|// Update meta with new HRI if required. i.e migrate all HRI with HTD to
comment|// HRI with out HTD in meta and update the status in ROOT. This must happen
comment|// before we assign all user regions or else the assignment will fail.
name|updateMetaWithNewHRI
argument_list|()
expr_stmt|;
comment|// Fixup assignment manager status
name|status
operator|.
name|setStatus
argument_list|(
literal|"Starting assignment manager"
argument_list|)
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|.
name|joinCluster
argument_list|()
expr_stmt|;
name|this
operator|.
name|balancer
operator|.
name|setClusterStatus
argument_list|(
name|getClusterStatus
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|balancer
operator|.
name|setMasterServices
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Start balancer and meta catalog janitor after meta and regions have
comment|// been assigned.
name|status
operator|.
name|setStatus
argument_list|(
literal|"Starting balancer and catalog janitor"
argument_list|)
expr_stmt|;
name|this
operator|.
name|balancerChore
operator|=
name|getAndStartBalancerChore
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|catalogJanitorChore
operator|=
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
operator|new
name|CatalogJanitor
argument_list|(
name|this
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|.
name|markComplete
argument_list|(
literal|"Initialization successful"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Master has completed initialization"
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
comment|// don't let cp initialization errors kill the master
try|try
block|{
name|this
operator|.
name|cpHost
operator|.
name|postStartMaster
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Coprocessor postStartMaster() hook failed"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|public
name|boolean
name|isMetaHRIUpdated
parameter_list|()
throws|throws
name|IOException
block|{
name|boolean
name|metaUpdated
init|=
literal|false
decl_stmt|;
name|Get
name|get
init|=
operator|new
name|Get
argument_list|(
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
operator|.
name|getRegionName
argument_list|()
argument_list|)
decl_stmt|;
name|get
operator|.
name|addColumn
argument_list|(
name|HConstants
operator|.
name|CATALOG_FAMILY
argument_list|,
name|HConstants
operator|.
name|META_MIGRATION_QUALIFIER
argument_list|)
expr_stmt|;
name|Result
name|r
init|=
name|catalogTracker
operator|.
name|waitForRootServerConnectionDefault
argument_list|()
operator|.
name|get
argument_list|(
name|HRegionInfo
operator|.
name|ROOT_REGIONINFO
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|get
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
name|r
operator|.
name|getBytes
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|metaMigrated
init|=
name|r
operator|.
name|getValue
argument_list|(
name|HConstants
operator|.
name|CATALOG_FAMILY
argument_list|,
name|HConstants
operator|.
name|META_MIGRATION_QUALIFIER
argument_list|)
decl_stmt|;
name|String
name|migrated
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|metaMigrated
argument_list|)
decl_stmt|;
name|metaUpdated
operator|=
operator|new
name|Boolean
argument_list|(
name|migrated
argument_list|)
operator|.
name|booleanValue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"metaUpdated = NULL."
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Meta updated status = "
operator|+
name|metaUpdated
argument_list|)
expr_stmt|;
return|return
name|metaUpdated
return|;
block|}
end_function

begin_function
name|boolean
name|updateMetaWithNewHRI
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isMetaHRIUpdated
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Meta has HRI with HTDs. Updating meta now."
argument_list|)
expr_stmt|;
try|try
block|{
name|MetaEditor
operator|.
name|migrateRootAndMeta
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"ROOT and Meta updated with new HRI."
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Update ROOT/Meta with new HRI failed."
operator|+
literal|"Master startup aborted."
argument_list|)
throw|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"ROOT/Meta already up-to date with new HRI."
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function

begin_comment
comment|/**    * Check<code>-ROOT-</code> and<code>.META.</code> are assigned.  If not,    * assign them.    * @throws InterruptedException    * @throws IOException    * @throws KeeperException    * @return Count of regions we assigned.    */
end_comment

begin_function
name|int
name|assignRootAndMeta
parameter_list|(
name|MonitoredTask
name|status
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|IOException
throws|,
name|KeeperException
block|{
name|int
name|assigned
init|=
literal|0
decl_stmt|;
name|long
name|timeout
init|=
name|this
operator|.
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.catalog.verification.timeout"
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
comment|// Work on ROOT region.  Is it in zk in transition?
name|status
operator|.
name|setStatus
argument_list|(
literal|"Assigning ROOT region"
argument_list|)
expr_stmt|;
name|boolean
name|rit
init|=
name|this
operator|.
name|assignmentManager
operator|.
name|processRegionInTransitionAndBlockUntilAssigned
argument_list|(
name|HRegionInfo
operator|.
name|ROOT_REGIONINFO
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|catalogTracker
operator|.
name|verifyRootRegionLocation
argument_list|(
name|timeout
argument_list|)
condition|)
block|{
name|this
operator|.
name|assignmentManager
operator|.
name|assignRoot
argument_list|()
expr_stmt|;
name|this
operator|.
name|catalogTracker
operator|.
name|waitForRoot
argument_list|()
expr_stmt|;
name|assigned
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|// Region already assigned.  We didnt' assign it.  Add to in-memory state.
name|this
operator|.
name|assignmentManager
operator|.
name|regionOnline
argument_list|(
name|HRegionInfo
operator|.
name|ROOT_REGIONINFO
argument_list|,
name|this
operator|.
name|catalogTracker
operator|.
name|getRootLocation
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"-ROOT- assigned="
operator|+
name|assigned
operator|+
literal|", rit="
operator|+
name|rit
operator|+
literal|", location="
operator|+
name|catalogTracker
operator|.
name|getRootLocation
argument_list|()
argument_list|)
expr_stmt|;
comment|// Work on meta region
name|status
operator|.
name|setStatus
argument_list|(
literal|"Assigning META region"
argument_list|)
expr_stmt|;
name|rit
operator|=
name|this
operator|.
name|assignmentManager
operator|.
name|processRegionInTransitionAndBlockUntilAssigned
argument_list|(
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|this
operator|.
name|catalogTracker
operator|.
name|verifyMetaRegionLocation
argument_list|(
name|timeout
argument_list|)
condition|)
block|{
name|this
operator|.
name|assignmentManager
operator|.
name|assignMeta
argument_list|()
expr_stmt|;
name|this
operator|.
name|catalogTracker
operator|.
name|waitForMeta
argument_list|()
expr_stmt|;
comment|// Above check waits for general meta availability but this does not
comment|// guarantee that the transition has completed
name|this
operator|.
name|assignmentManager
operator|.
name|waitForAssignment
argument_list|(
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
argument_list|)
expr_stmt|;
name|assigned
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|// Region already assigned.  We didnt' assign it.  Add to in-memory state.
name|this
operator|.
name|assignmentManager
operator|.
name|regionOnline
argument_list|(
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
argument_list|,
name|this
operator|.
name|catalogTracker
operator|.
name|getMetaLocation
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|".META. assigned="
operator|+
name|assigned
operator|+
literal|", rit="
operator|+
name|rit
operator|+
literal|", location="
operator|+
name|catalogTracker
operator|.
name|getMetaLocation
argument_list|()
argument_list|)
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"META and ROOT assigned."
argument_list|)
expr_stmt|;
return|return
name|assigned
return|;
block|}
end_function

begin_function
specifier|public
name|long
name|getProtocolVersion
parameter_list|(
name|String
name|protocol
parameter_list|,
name|long
name|clientVersion
parameter_list|)
block|{
if|if
condition|(
name|HMasterInterface
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|protocol
argument_list|)
condition|)
block|{
return|return
name|HMasterInterface
operator|.
name|VERSION
return|;
block|}
elseif|else
if|if
condition|(
name|HMasterRegionInterface
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|protocol
argument_list|)
condition|)
block|{
return|return
name|HMasterRegionInterface
operator|.
name|VERSION
return|;
block|}
comment|// unknown protocol
name|LOG
operator|.
name|warn
argument_list|(
literal|"Version requested for unimplemented protocol: "
operator|+
name|protocol
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|TableDescriptors
name|getTableDescriptors
parameter_list|()
block|{
return|return
name|this
operator|.
name|tableDescriptors
return|;
block|}
end_function

begin_comment
comment|/** @return InfoServer object. Maybe null.*/
end_comment

begin_function
specifier|public
name|InfoServer
name|getInfoServer
parameter_list|()
block|{
return|return
name|this
operator|.
name|infoServer
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|Configuration
name|getConfiguration
parameter_list|()
block|{
return|return
name|this
operator|.
name|conf
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|ServerManager
name|getServerManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|serverManager
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|ExecutorService
name|getExecutorService
parameter_list|()
block|{
return|return
name|this
operator|.
name|executorService
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|MasterFileSystem
name|getMasterFileSystem
parameter_list|()
block|{
return|return
name|this
operator|.
name|fileSystemManager
return|;
block|}
end_function

begin_comment
comment|/**    * Get the ZK wrapper object - needed by master_jsp.java    * @return the zookeeper wrapper    */
end_comment

begin_function
specifier|public
name|ZooKeeperWatcher
name|getZooKeeperWatcher
parameter_list|()
block|{
return|return
name|this
operator|.
name|zooKeeper
return|;
block|}
end_function

begin_comment
comment|/*    * Start up all services. If any of these threads gets an unhandled exception    * then they just die with a logged message.  This should be fine because    * in general, we do not expect the master to get such unhandled exceptions    *  as OOMEs; it should be lightly loaded. See what HRegionServer does if    *  need to install an unexpected exception handler.    */
end_comment

begin_function
specifier|private
name|void
name|startServiceThreads
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Start the executor service pools
name|this
operator|.
name|executorService
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_OPEN_REGION
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.executor.openregion.threads"
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_CLOSE_REGION
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.executor.closeregion.threads"
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_SERVER_OPERATIONS
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.executor.serverops.threads"
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|executorService
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_META_SERVER_OPERATIONS
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.executor.serverops.threads"
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
comment|// We depend on there being only one instance of this executor running
comment|// at a time.  To do concurrency, would need fencing of enable/disable of
comment|// tables.
name|this
operator|.
name|executorService
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_TABLE_OPERATIONS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// Start log cleaner thread
name|String
name|n
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|this
operator|.
name|logCleaner
operator|=
operator|new
name|LogCleaner
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.cleaner.interval"
argument_list|,
literal|60
operator|*
literal|1000
argument_list|)
argument_list|,
name|this
argument_list|,
name|conf
argument_list|,
name|getMasterFileSystem
argument_list|()
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|getMasterFileSystem
argument_list|()
operator|.
name|getOldLogDir
argument_list|()
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|logCleaner
argument_list|,
name|n
operator|+
literal|".oldLogCleaner"
argument_list|)
expr_stmt|;
comment|// Put up info server.
name|int
name|port
init|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.info.port"
argument_list|,
literal|60010
argument_list|)
decl_stmt|;
if|if
condition|(
name|port
operator|>=
literal|0
condition|)
block|{
name|String
name|a
init|=
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.master.info.bindAddress"
argument_list|,
literal|"0.0.0.0"
argument_list|)
decl_stmt|;
name|this
operator|.
name|infoServer
operator|=
operator|new
name|InfoServer
argument_list|(
name|MASTER
argument_list|,
name|a
argument_list|,
name|port
argument_list|,
literal|false
argument_list|,
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|addServlet
argument_list|(
literal|"status"
argument_list|,
literal|"/master-status"
argument_list|,
name|MasterStatusServlet
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|addServlet
argument_list|(
literal|"dump"
argument_list|,
literal|"/dump"
argument_list|,
name|MasterDumpServlet
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|setAttribute
argument_list|(
name|MASTER
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|// Start allowing requests to happen.
name|this
operator|.
name|rpcServer
operator|.
name|openServer
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Started service threads"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|private
name|void
name|stopServiceThreads
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Stopping service threads"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|rpcServer
operator|!=
literal|null
condition|)
name|this
operator|.
name|rpcServer
operator|.
name|stop
argument_list|()
expr_stmt|;
comment|// Clean up and close up shop
if|if
condition|(
name|this
operator|.
name|logCleaner
operator|!=
literal|null
condition|)
name|this
operator|.
name|logCleaner
operator|.
name|interrupt
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|infoServer
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping infoServer"
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|infoServer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|ex
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|this
operator|.
name|executorService
operator|!=
literal|null
condition|)
name|this
operator|.
name|executorService
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|Thread
name|getAndStartBalancerChore
parameter_list|(
specifier|final
name|HMaster
name|master
parameter_list|)
block|{
name|String
name|name
init|=
name|master
operator|.
name|getServerName
argument_list|()
operator|+
literal|"-BalancerChore"
decl_stmt|;
name|int
name|balancerPeriod
init|=
name|master
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"hbase.balancer.period"
argument_list|,
literal|300000
argument_list|)
decl_stmt|;
comment|// Start up the load balancer chore
name|Chore
name|chore
init|=
operator|new
name|Chore
argument_list|(
name|name
argument_list|,
name|balancerPeriod
argument_list|,
name|master
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|chore
parameter_list|()
block|{
name|master
operator|.
name|balance
argument_list|()
expr_stmt|;
block|}
block|}
decl_stmt|;
return|return
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|chore
argument_list|)
return|;
block|}
end_function

begin_function
specifier|private
name|void
name|stopChores
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|balancerChore
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|balancerChore
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|catalogJanitorChore
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|catalogJanitorChore
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|MapWritable
name|regionServerStartup
parameter_list|(
specifier|final
name|int
name|port
parameter_list|,
specifier|final
name|long
name|serverStartCode
parameter_list|,
specifier|final
name|long
name|serverCurrentTime
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Register with server manager
name|InetAddress
name|ia
init|=
name|HBaseServer
operator|.
name|getRemoteIp
argument_list|()
decl_stmt|;
name|ServerName
name|rs
init|=
name|this
operator|.
name|serverManager
operator|.
name|regionServerStartup
argument_list|(
name|ia
argument_list|,
name|port
argument_list|,
name|serverStartCode
argument_list|,
name|serverCurrentTime
argument_list|)
decl_stmt|;
comment|// Send back some config info
name|MapWritable
name|mw
init|=
name|createConfigurationSubset
argument_list|()
decl_stmt|;
name|mw
operator|.
name|put
argument_list|(
operator|new
name|Text
argument_list|(
name|HConstants
operator|.
name|KEY_FOR_HOSTNAME_SEEN_BY_MASTER
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
name|rs
operator|.
name|getHostname
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mw
return|;
block|}
end_function

begin_comment
comment|/**    * @return Subset of configuration to pass initializing regionservers: e.g.    * the filesystem to use and root directory to use.    */
end_comment

begin_function
specifier|protected
name|MapWritable
name|createConfigurationSubset
parameter_list|()
block|{
name|MapWritable
name|mw
init|=
name|addConfig
argument_list|(
operator|new
name|MapWritable
argument_list|()
argument_list|,
name|HConstants
operator|.
name|HBASE_DIR
argument_list|)
decl_stmt|;
return|return
name|addConfig
argument_list|(
name|mw
argument_list|,
literal|"fs.default.name"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|private
name|MapWritable
name|addConfig
parameter_list|(
specifier|final
name|MapWritable
name|mw
parameter_list|,
specifier|final
name|String
name|key
parameter_list|)
block|{
name|mw
operator|.
name|put
argument_list|(
operator|new
name|Text
argument_list|(
name|key
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mw
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|regionServerReport
parameter_list|(
specifier|final
name|byte
index|[]
name|sn
parameter_list|,
specifier|final
name|HServerLoad
name|hsl
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|serverManager
operator|.
name|regionServerReport
argument_list|(
operator|new
name|ServerName
argument_list|(
name|sn
argument_list|)
argument_list|,
name|hsl
argument_list|)
expr_stmt|;
if|if
condition|(
name|hsl
operator|!=
literal|null
operator|&&
name|this
operator|.
name|metrics
operator|!=
literal|null
condition|)
block|{
comment|// Up our metrics.
name|this
operator|.
name|metrics
operator|.
name|incrementRequests
argument_list|(
name|hsl
operator|.
name|getTotalNumberOfRequests
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|reportRSFatalError
parameter_list|(
name|byte
index|[]
name|sn
parameter_list|,
name|String
name|errorText
parameter_list|)
block|{
name|ServerName
name|serverName
init|=
operator|new
name|ServerName
argument_list|(
name|sn
argument_list|)
decl_stmt|;
name|String
name|msg
init|=
literal|"Region server "
operator|+
name|serverName
operator|+
literal|" reported a fatal error:\n"
operator|+
name|errorText
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|rsFatals
operator|.
name|add
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|public
name|boolean
name|isMasterRunning
parameter_list|()
block|{
return|return
operator|!
name|isStopped
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * @return Maximum time we should run balancer for    */
end_comment

begin_function
specifier|private
name|int
name|getBalancerCutoffTime
parameter_list|()
block|{
name|int
name|balancerCutoffTime
init|=
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"hbase.balancer.max.balancing"
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|balancerCutoffTime
operator|==
operator|-
literal|1
condition|)
block|{
comment|// No time period set so create one -- do half of balancer period.
name|int
name|balancerPeriod
init|=
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"hbase.balancer.period"
argument_list|,
literal|300000
argument_list|)
decl_stmt|;
name|balancerCutoffTime
operator|=
name|balancerPeriod
operator|/
literal|2
expr_stmt|;
comment|// If nonsense period, set it to balancerPeriod
if|if
condition|(
name|balancerCutoffTime
operator|<=
literal|0
condition|)
name|balancerCutoffTime
operator|=
name|balancerPeriod
expr_stmt|;
block|}
return|return
name|balancerCutoffTime
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|boolean
name|balance
parameter_list|()
block|{
comment|// If balance not true, don't run balancer.
if|if
condition|(
operator|!
name|this
operator|.
name|balanceSwitch
condition|)
return|return
literal|false
return|;
comment|// Do this call outside of synchronized block.
name|int
name|maximumBalanceTime
init|=
name|getBalancerCutoffTime
argument_list|()
decl_stmt|;
name|long
name|cutoffTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|maximumBalanceTime
decl_stmt|;
name|boolean
name|balancerRan
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|balancer
init|)
block|{
comment|// Only allow one balance run at at time.
if|if
condition|(
name|this
operator|.
name|assignmentManager
operator|.
name|isRegionsInTransition
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Not running balancer because "
operator|+
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionsInTransition
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|" region(s) in transition: "
operator|+
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
operator|.
name|abbreviate
argument_list|(
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionsInTransition
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
literal|256
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|this
operator|.
name|serverManager
operator|.
name|areDeadServersInProgress
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Not running balancer because processing dead regionserver(s): "
operator|+
name|this
operator|.
name|serverManager
operator|.
name|getDeadServers
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|this
operator|.
name|cpHost
operator|.
name|preBalance
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Coprocessor bypassing balancer request"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error invoking master coprocessor preBalance()"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
name|assignments
init|=
name|this
operator|.
name|assignmentManager
operator|.
name|getAssignments
argument_list|()
decl_stmt|;
comment|// Returned Map from AM does not include mention of servers w/o assignments.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ServerName
argument_list|,
name|HServerLoad
argument_list|>
name|e
range|:
name|this
operator|.
name|serverManager
operator|.
name|getOnlineServers
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|assignments
operator|.
name|containsKey
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|assignments
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|RegionPlan
argument_list|>
name|plans
init|=
name|this
operator|.
name|balancer
operator|.
name|balanceCluster
argument_list|(
name|assignments
argument_list|)
decl_stmt|;
name|int
name|rpCount
init|=
literal|0
decl_stmt|;
comment|// number of RegionPlans balanced so far
name|long
name|totalRegPlanExecTime
init|=
literal|0
decl_stmt|;
name|balancerRan
operator|=
name|plans
operator|!=
literal|null
expr_stmt|;
if|if
condition|(
name|plans
operator|!=
literal|null
operator|&&
operator|!
name|plans
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|RegionPlan
name|plan
range|:
name|plans
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"balance "
operator|+
name|plan
argument_list|)
expr_stmt|;
name|long
name|balStartTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|this
operator|.
name|assignmentManager
operator|.
name|balance
argument_list|(
name|plan
argument_list|)
expr_stmt|;
name|totalRegPlanExecTime
operator|+=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|balStartTime
expr_stmt|;
name|rpCount
operator|++
expr_stmt|;
if|if
condition|(
name|rpCount
operator|<
name|plans
operator|.
name|size
argument_list|()
operator|&&
comment|// if performing next balance exceeds cutoff time, exit the loop
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
operator|(
name|totalRegPlanExecTime
operator|/
name|rpCount
operator|)
operator|)
operator|>
name|cutoffTime
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No more balancing till next balance run; maximumBalanceTime="
operator|+
name|maximumBalanceTime
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|this
operator|.
name|cpHost
operator|.
name|postBalance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// balancing already succeeded so don't change the result
name|LOG
operator|.
name|error
argument_list|(
literal|"Error invoking master coprocessor postBalance()"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|balancerRan
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|boolean
name|balanceSwitch
parameter_list|(
specifier|final
name|boolean
name|b
parameter_list|)
block|{
name|boolean
name|oldValue
init|=
name|this
operator|.
name|balanceSwitch
decl_stmt|;
name|boolean
name|newValue
init|=
name|b
decl_stmt|;
try|try
block|{
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|newValue
operator|=
name|this
operator|.
name|cpHost
operator|.
name|preBalanceSwitch
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|balanceSwitch
operator|=
name|newValue
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Balance="
operator|+
name|newValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|cpHost
operator|.
name|postBalanceSwitch
argument_list|(
name|oldValue
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error flipping balance switch"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
return|return
name|oldValue
return|;
block|}
end_function

begin_comment
comment|/**    * Switch for the background {@link CatalogJanitor} thread.    * Used for testing.  The thread will continue to run.  It will just be a noop    * if disabled.    * @param b If false, the catalog janitor won't do anything.    */
end_comment

begin_function
specifier|public
name|void
name|setCatalogJanitorEnabled
parameter_list|(
specifier|final
name|boolean
name|b
parameter_list|)
block|{
operator|(
operator|(
name|CatalogJanitor
operator|)
name|this
operator|.
name|catalogJanitorChore
operator|)
operator|.
name|setEnabled
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|move
parameter_list|(
specifier|final
name|byte
index|[]
name|encodedRegionName
parameter_list|,
specifier|final
name|byte
index|[]
name|destServerName
parameter_list|)
throws|throws
name|UnknownRegionException
block|{
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|p
init|=
name|this
operator|.
name|assignmentManager
operator|.
name|getAssignment
argument_list|(
name|encodedRegionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|null
condition|)
throw|throw
operator|new
name|UnknownRegionException
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|encodedRegionName
argument_list|)
argument_list|)
throw|;
name|HRegionInfo
name|hri
init|=
name|p
operator|.
name|getFirst
argument_list|()
decl_stmt|;
name|ServerName
name|dest
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|destServerName
operator|==
literal|null
operator|||
name|destServerName
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Passed destination servername is null/empty so "
operator|+
literal|"choosing a server at random"
argument_list|)
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|.
name|clearRegionPlan
argument_list|(
name|hri
argument_list|)
expr_stmt|;
comment|// Unassign will reassign it elsewhere choosing random server.
name|this
operator|.
name|assignmentManager
operator|.
name|unassign
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dest
operator|=
operator|new
name|ServerName
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|destServerName
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|cpHost
operator|.
name|preMove
argument_list|(
name|p
operator|.
name|getFirst
argument_list|()
argument_list|,
name|p
operator|.
name|getSecond
argument_list|()
argument_list|,
name|dest
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
name|RegionPlan
name|rp
init|=
operator|new
name|RegionPlan
argument_list|(
name|p
operator|.
name|getFirst
argument_list|()
argument_list|,
name|p
operator|.
name|getSecond
argument_list|()
argument_list|,
name|dest
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Added move plan "
operator|+
name|rp
operator|+
literal|", running balancer"
argument_list|)
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|.
name|balance
argument_list|(
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|cpHost
operator|.
name|postMove
argument_list|(
name|p
operator|.
name|getFirst
argument_list|()
argument_list|,
name|p
operator|.
name|getSecond
argument_list|()
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|UnknownRegionException
name|ure
init|=
operator|new
name|UnknownRegionException
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|encodedRegionName
argument_list|)
argument_list|)
decl_stmt|;
name|ure
operator|.
name|initCause
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
throw|throw
name|ure
throw|;
block|}
block|}
block|}
end_function

begin_function
specifier|public
name|void
name|createTable
parameter_list|(
name|HTableDescriptor
name|hTableDescriptor
parameter_list|,
name|byte
index|[]
index|[]
name|splitKeys
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isMasterRunning
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MasterNotRunningException
argument_list|()
throw|;
block|}
name|HRegionInfo
index|[]
name|newRegions
init|=
name|getHRegionInfos
argument_list|(
name|hTableDescriptor
argument_list|,
name|splitKeys
argument_list|)
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preCreateTable
argument_list|(
name|hTableDescriptor
argument_list|,
name|newRegions
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|CreateTableHandler
argument_list|(
name|this
argument_list|,
name|this
operator|.
name|fileSystemManager
argument_list|,
name|this
operator|.
name|serverManager
argument_list|,
name|hTableDescriptor
argument_list|,
name|conf
argument_list|,
name|newRegions
argument_list|,
name|catalogTracker
argument_list|,
name|assignmentManager
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postCreateTable
argument_list|(
name|hTableDescriptor
argument_list|,
name|newRegions
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|private
name|HRegionInfo
index|[]
name|getHRegionInfos
parameter_list|(
name|HTableDescriptor
name|hTableDescriptor
parameter_list|,
name|byte
index|[]
index|[]
name|splitKeys
parameter_list|)
block|{
name|HRegionInfo
index|[]
name|hRegionInfos
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|splitKeys
operator|==
literal|null
operator|||
name|splitKeys
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|hRegionInfos
operator|=
operator|new
name|HRegionInfo
index|[]
block|{
operator|new
name|HRegionInfo
argument_list|(
name|hTableDescriptor
operator|.
name|getName
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
block|}
expr_stmt|;
block|}
else|else
block|{
name|int
name|numRegions
init|=
name|splitKeys
operator|.
name|length
operator|+
literal|1
decl_stmt|;
name|hRegionInfos
operator|=
operator|new
name|HRegionInfo
index|[
name|numRegions
index|]
expr_stmt|;
name|byte
index|[]
name|startKey
init|=
literal|null
decl_stmt|;
name|byte
index|[]
name|endKey
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numRegions
condition|;
name|i
operator|++
control|)
block|{
name|endKey
operator|=
operator|(
name|i
operator|==
name|splitKeys
operator|.
name|length
operator|)
condition|?
literal|null
else|:
name|splitKeys
index|[
name|i
index|]
expr_stmt|;
name|hRegionInfos
index|[
name|i
index|]
operator|=
operator|new
name|HRegionInfo
argument_list|(
name|hTableDescriptor
operator|.
name|getName
argument_list|()
argument_list|,
name|startKey
argument_list|,
name|endKey
argument_list|)
expr_stmt|;
name|startKey
operator|=
name|endKey
expr_stmt|;
block|}
block|}
return|return
name|hRegionInfos
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|boolean
name|isCatalogTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|tableName
argument_list|,
name|HConstants
operator|.
name|ROOT_TABLE_NAME
argument_list|)
operator|||
name|Bytes
operator|.
name|equals
argument_list|(
name|tableName
argument_list|,
name|HConstants
operator|.
name|META_TABLE_NAME
argument_list|)
return|;
block|}
end_function

begin_function
specifier|public
name|void
name|deleteTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preDeleteTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|DeleteTableHandler
argument_list|(
name|tableName
argument_list|,
name|this
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postDeleteTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * Get the number of regions of the table that have been updated by the alter.    *    * @return Pair indicating the number of regions updated Pair.getFirst is the    *         regions that are yet to be updated Pair.getSecond is the total number    *         of regions of the table    */
end_comment

begin_function
specifier|public
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|getAlterStatus
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|this
operator|.
name|assignmentManager
operator|.
name|getReopenStatus
argument_list|(
name|tableName
argument_list|)
return|;
block|}
end_function

begin_function
specifier|public
name|void
name|addColumn
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|,
name|HColumnDescriptor
name|column
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|cpHost
operator|.
name|preAddColumn
argument_list|(
name|tableName
argument_list|,
name|column
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
operator|new
name|TableAddFamilyHandler
argument_list|(
name|tableName
argument_list|,
name|column
argument_list|,
name|this
argument_list|,
name|this
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postAddColumn
argument_list|(
name|tableName
argument_list|,
name|column
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|public
name|void
name|modifyColumn
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|,
name|HColumnDescriptor
name|descriptor
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|cpHost
operator|.
name|preModifyColumn
argument_list|(
name|tableName
argument_list|,
name|descriptor
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
operator|new
name|TableModifyFamilyHandler
argument_list|(
name|tableName
argument_list|,
name|descriptor
argument_list|,
name|this
argument_list|,
name|this
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postModifyColumn
argument_list|(
name|tableName
argument_list|,
name|descriptor
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|public
name|void
name|deleteColumn
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|c
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|cpHost
operator|.
name|preDeleteColumn
argument_list|(
name|tableName
argument_list|,
name|c
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
operator|new
name|TableDeleteFamilyHandler
argument_list|(
name|tableName
argument_list|,
name|c
argument_list|,
name|this
argument_list|,
name|this
argument_list|)
operator|.
name|process
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postDeleteColumn
argument_list|(
name|tableName
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|public
name|void
name|enableTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preEnableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|EnableTableHandler
argument_list|(
name|this
argument_list|,
name|tableName
argument_list|,
name|catalogTracker
argument_list|,
name|assignmentManager
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postEnableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|public
name|void
name|disableTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preDisableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|DisableTableHandler
argument_list|(
name|this
argument_list|,
name|tableName
argument_list|,
name|catalogTracker
argument_list|,
name|assignmentManager
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postDisableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * Return the region and current deployment for the region containing    * the given row. If the region cannot be found, returns null. If it    * is found, but not currently deployed, the second element of the pair    * may be null.    */
end_comment

begin_function
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|getTableRegionForRow
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|rowKey
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|AtomicReference
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|AtomicReference
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|>
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|MetaScannerVisitor
name|visitor
init|=
operator|new
name|MetaScannerVisitor
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|processRow
parameter_list|(
name|Result
name|data
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|data
operator|==
literal|null
operator|||
name|data
operator|.
name|size
argument_list|()
operator|<=
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
init|=
name|MetaReader
operator|.
name|metaRowToRegionPair
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|pair
operator|.
name|getFirst
argument_list|()
operator|.
name|getTableName
argument_list|()
argument_list|,
name|tableName
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|result
operator|.
name|set
argument_list|(
name|pair
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
decl_stmt|;
name|MetaScanner
operator|.
name|metaScan
argument_list|(
name|conf
argument_list|,
name|visitor
argument_list|,
name|tableName
argument_list|,
name|rowKey
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|result
operator|.
name|get
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|modifyTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
name|HTableDescriptor
name|htd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preModifyTable
argument_list|(
name|tableName
argument_list|,
name|htd
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|executorService
operator|.
name|submit
argument_list|(
operator|new
name|ModifyTableHandler
argument_list|(
name|tableName
argument_list|,
name|htd
argument_list|,
name|this
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postModifyTable
argument_list|(
name|tableName
argument_list|,
name|htd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|checkTableModifiable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|tableNameStr
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|isCatalogTable
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can't modify catalog tables"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|MetaReader
operator|.
name|tableExists
argument_list|(
name|getCatalogTracker
argument_list|()
argument_list|,
name|tableNameStr
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TableNotFoundException
argument_list|(
name|tableNameStr
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|getAssignmentManager
argument_list|()
operator|.
name|getZKTable
argument_list|()
operator|.
name|isDisabledTable
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TableNotDisabledException
argument_list|(
name|tableName
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
specifier|public
name|void
name|clearFromTransition
parameter_list|(
name|HRegionInfo
name|hri
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|assignmentManager
operator|.
name|isRegionInTransition
argument_list|(
name|hri
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|assignmentManager
operator|.
name|clearRegionFromTransition
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * @return cluster status    */
end_comment

begin_function
specifier|public
name|ClusterStatus
name|getClusterStatus
parameter_list|()
block|{
return|return
operator|new
name|ClusterStatus
argument_list|(
name|VersionInfo
operator|.
name|getVersion
argument_list|()
argument_list|,
name|this
operator|.
name|fileSystemManager
operator|.
name|getClusterId
argument_list|()
argument_list|,
name|this
operator|.
name|serverManager
operator|.
name|getOnlineServers
argument_list|()
argument_list|,
name|this
operator|.
name|serverManager
operator|.
name|getDeadServers
argument_list|()
argument_list|,
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionsInTransition
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
specifier|public
name|String
name|getClusterId
parameter_list|()
block|{
return|return
name|fileSystemManager
operator|.
name|getClusterId
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|abort
parameter_list|(
specifier|final
name|String
name|msg
parameter_list|,
specifier|final
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|abortNow
argument_list|(
name|msg
argument_list|,
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
name|LOG
operator|.
name|fatal
argument_list|(
name|msg
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|LOG
operator|.
name|fatal
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|this
operator|.
name|abort
operator|=
literal|true
expr_stmt|;
name|stop
argument_list|(
literal|"Aborting"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * We do the following.    * 1. Create a new ZK session. (since our current one is expired)    * 2. Try to become a primary master again    * 3. Initialize all ZK based system trackers.    * 4. Assign root and meta. (they are already assigned, but we need to update our    * internal memory state to reflect it)    * 5. Process any RIT if any during the process of our recovery.    *    * @return True if we could successfully recover from ZK session expiry.    * @throws InterruptedException    * @throws IOException    */
end_comment

begin_function
specifier|private
name|boolean
name|tryRecoveringExpiredZKSession
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|IOException
throws|,
name|KeeperException
block|{
name|this
operator|.
name|zooKeeper
operator|=
operator|new
name|ZooKeeperWatcher
argument_list|(
name|conf
argument_list|,
name|MASTER
operator|+
literal|":"
operator|+
name|this
operator|.
name|serverName
operator|.
name|getPort
argument_list|()
argument_list|,
name|this
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|MonitoredTask
name|status
init|=
name|TaskMonitor
operator|.
name|get
argument_list|()
operator|.
name|createStatus
argument_list|(
literal|"Recovering expired ZK session"
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|becomeActiveMaster
argument_list|(
name|status
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|initializeZKBasedSystemTrackers
argument_list|()
expr_stmt|;
comment|// Update in-memory structures to reflect our earlier Root/Meta assignment.
name|assignRootAndMeta
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|// process RIT if any
comment|// TODO: Why does this not call AssignmentManager.joinCluster?  Otherwise
comment|// we are not processing dead servers if any.
name|this
operator|.
name|assignmentManager
operator|.
name|processRegionsInTransition
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
finally|finally
block|{
name|status
operator|.
name|cleanup
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * Check to see if the current trigger for abort is due to ZooKeeper session    * expiry, and If yes, whether we can recover from ZK session expiry.    *    * @param msg Original abort message    * @param t   The cause for current abort request    * @return true if we should proceed with abort operation, false other wise.    */
end_comment

begin_function
specifier|private
name|boolean
name|abortNow
parameter_list|(
specifier|final
name|String
name|msg
parameter_list|,
specifier|final
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|isActiveMaster
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|t
operator|!=
literal|null
operator|&&
name|t
operator|instanceof
name|KeeperException
operator|.
name|SessionExpiredException
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Primary Master trying to recover from ZooKeeper session "
operator|+
literal|"expiry."
argument_list|)
expr_stmt|;
return|return
operator|!
name|tryRecoveringExpiredZKSession
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|newT
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Primary master encountered unexpected exception while "
operator|+
literal|"trying to recover from ZooKeeper session"
operator|+
literal|" expiry. Proceeding with server abort."
argument_list|,
name|newT
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|ZooKeeperWatcher
name|getZooKeeper
parameter_list|()
block|{
return|return
name|zooKeeper
return|;
block|}
end_function

begin_function
specifier|public
name|MasterCoprocessorHost
name|getCoprocessorHost
parameter_list|()
block|{
return|return
name|cpHost
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|ServerName
name|getServerName
parameter_list|()
block|{
return|return
name|this
operator|.
name|serverName
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|CatalogTracker
name|getCatalogTracker
parameter_list|()
block|{
return|return
name|catalogTracker
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|AssignmentManager
name|getAssignmentManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|assignmentManager
return|;
block|}
end_function

begin_function
specifier|public
name|MemoryBoundedLogMessageBuffer
name|getRegionServerFatalLogBuffer
parameter_list|()
block|{
return|return
name|rsFatals
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|cpHost
operator|.
name|preShutdown
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error call master coprocessor preShutdown()"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|assignmentManager
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|this
operator|.
name|serverManager
operator|.
name|shutdownCluster
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|clusterStatusTracker
operator|.
name|setClusterDown
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"ZooKeeper exception trying to set cluster as down in ZK"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|stopMaster
parameter_list|()
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|cpHost
operator|.
name|preStopMaster
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error call master coprocessor preStopMaster()"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
name|stop
argument_list|(
literal|"Stopped by "
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|stop
parameter_list|(
specifier|final
name|String
name|why
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|why
argument_list|)
expr_stmt|;
name|this
operator|.
name|stopped
operator|=
literal|true
expr_stmt|;
comment|// If we are a backup master, we need to interrupt wait
synchronized|synchronized
init|(
name|this
operator|.
name|activeMasterManager
operator|.
name|clusterHasActiveMaster
init|)
block|{
name|this
operator|.
name|activeMasterManager
operator|.
name|clusterHasActiveMaster
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|boolean
name|isStopped
parameter_list|()
block|{
return|return
name|this
operator|.
name|stopped
return|;
block|}
end_function

begin_function
name|boolean
name|isAborted
parameter_list|()
block|{
return|return
name|this
operator|.
name|abort
return|;
block|}
end_function

begin_comment
comment|/**    * Report whether this master is currently the active master or not.    * If not active master, we are parked on ZK waiting to become active.    *    * This method is used for testing.    *    * @return true if active master, false if not.    */
end_comment

begin_function
specifier|public
name|boolean
name|isActiveMaster
parameter_list|()
block|{
return|return
name|isActiveMaster
return|;
block|}
end_function

begin_comment
comment|/**    * Report whether this master has completed with its initialization and is    * ready.  If ready, the master is also the active master.  A standby master    * is never ready.    *    * This method is used for testing.    *    * @return true if master is ready to go, false if not.    */
end_comment

begin_function
specifier|public
name|boolean
name|isInitialized
parameter_list|()
block|{
return|return
name|initialized
return|;
block|}
end_function

begin_function
annotation|@
name|Override
annotation|@
name|Deprecated
specifier|public
name|void
name|assign
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
name|assign
argument_list|(
name|regionName
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|assign
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|IOException
block|{
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
init|=
name|MetaReader
operator|.
name|getRegion
argument_list|(
name|this
operator|.
name|catalogTracker
argument_list|,
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
literal|null
condition|)
throw|throw
operator|new
name|UnknownRegionException
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|regionName
argument_list|)
argument_list|)
throw|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|cpHost
operator|.
name|preAssign
argument_list|(
name|pair
operator|.
name|getFirst
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
name|assignRegion
argument_list|(
name|pair
operator|.
name|getFirst
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postAssign
argument_list|(
name|pair
operator|.
name|getFirst
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|public
name|void
name|assignRegion
parameter_list|(
name|HRegionInfo
name|hri
parameter_list|)
block|{
name|assignmentManager
operator|.
name|assign
argument_list|(
name|hri
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|unassign
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
init|=
name|MetaReader
operator|.
name|getRegion
argument_list|(
name|this
operator|.
name|catalogTracker
argument_list|,
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
literal|null
condition|)
throw|throw
operator|new
name|UnknownRegionException
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|regionName
argument_list|)
argument_list|)
throw|;
name|HRegionInfo
name|hri
init|=
name|pair
operator|.
name|getFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|cpHost
operator|.
name|preUnassign
argument_list|(
name|hri
argument_list|,
name|force
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
if|if
condition|(
name|force
condition|)
block|{
name|this
operator|.
name|assignmentManager
operator|.
name|clearRegionFromTransition
argument_list|(
name|hri
argument_list|)
expr_stmt|;
name|assignRegion
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|assignmentManager
operator|.
name|unassign
argument_list|(
name|hri
argument_list|,
name|force
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postUnassign
argument_list|(
name|hri
argument_list|,
name|force
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * Get HTD array for given tables     * @param tableNames    * @return HTableDescriptor[]    */
end_comment

begin_function
specifier|public
name|HTableDescriptor
index|[]
name|getHTableDescriptors
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|tableNames
parameter_list|)
block|{
name|List
argument_list|<
name|HTableDescriptor
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|HTableDescriptor
argument_list|>
argument_list|(
name|tableNames
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|tableNames
control|)
block|{
name|HTableDescriptor
name|htd
init|=
literal|null
decl_stmt|;
try|try
block|{
name|htd
operator|=
name|this
operator|.
name|tableDescriptors
operator|.
name|get
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed getting descriptor for "
operator|+
name|s
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|htd
operator|==
literal|null
condition|)
continue|continue;
name|list
operator|.
name|add
argument_list|(
name|htd
argument_list|)
expr_stmt|;
block|}
return|return
name|list
operator|.
name|toArray
argument_list|(
operator|new
name|HTableDescriptor
index|[]
block|{}
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Get all table descriptors    * @return All descriptors or null if none.    */
end_comment

begin_function
specifier|public
name|HTableDescriptor
index|[]
name|getHTableDescriptors
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|HTableDescriptor
argument_list|>
name|descriptors
init|=
literal|null
decl_stmt|;
try|try
block|{
name|descriptors
operator|=
name|this
operator|.
name|tableDescriptors
operator|.
name|getAll
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed getting all descriptors"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|descriptors
operator|==
literal|null
condition|?
literal|null
else|:
name|descriptors
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|HTableDescriptor
index|[]
block|{}
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Compute the average load across all region servers.    * Currently, this uses a very naive computation - just uses the number of    * regions being served, ignoring stats about number of requests.    * @return the average load    */
end_comment

begin_function
specifier|public
name|double
name|getAverageLoad
parameter_list|()
block|{
return|return
name|this
operator|.
name|assignmentManager
operator|.
name|getAverageLoad
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Utility for constructing an instance of the passed HMaster class.    * @param masterClass    * @param conf    * @return HMaster instance.    */
end_comment

begin_function
specifier|public
specifier|static
name|HMaster
name|constructMaster
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|HMaster
argument_list|>
name|masterClass
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|)
block|{
try|try
block|{
name|Constructor
argument_list|<
name|?
extends|extends
name|HMaster
argument_list|>
name|c
init|=
name|masterClass
operator|.
name|getConstructor
argument_list|(
name|Configuration
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|c
operator|.
name|newInstance
argument_list|(
name|conf
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|ite
parameter_list|)
block|{
name|Throwable
name|target
init|=
name|ite
operator|.
name|getTargetException
argument_list|()
operator|!=
literal|null
condition|?
name|ite
operator|.
name|getTargetException
argument_list|()
else|:
name|ite
decl_stmt|;
if|if
condition|(
name|target
operator|.
name|getCause
argument_list|()
operator|!=
literal|null
condition|)
name|target
operator|=
name|target
operator|.
name|getCause
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Failed construction of Master: "
operator|+
name|masterClass
operator|.
name|toString
argument_list|()
argument_list|,
name|target
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Failed construction of Master: "
operator|+
name|masterClass
operator|.
name|toString
argument_list|()
operator|+
operator|(
operator|(
name|e
operator|.
name|getCause
argument_list|()
operator|!=
literal|null
operator|)
condition|?
name|e
operator|.
name|getCause
argument_list|()
operator|.
name|getMessage
argument_list|()
else|:
literal|""
operator|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
end_function

begin_comment
comment|/**    * @see org.apache.hadoop.hbase.master.HMasterCommandLine    */
end_comment

begin_function
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|VersionInfo
operator|.
name|logVersion
argument_list|()
expr_stmt|;
operator|new
name|HMasterCommandLine
argument_list|(
name|HMaster
operator|.
name|class
argument_list|)
operator|.
name|doMain
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

unit|}
end_unit

