begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2010 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|SynchronousQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Abortable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ClusterStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerAddress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MasterNotRunningException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ZooKeeperConnectionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|MetaReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|HBaseAdmin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|HConnection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|HConnectionManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|HConnectionManager
operator|.
name|HConnectable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MetaScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MetaScanner
operator|.
name|MetaScannerVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Put
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HRegionInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|MasterFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|wal
operator|.
name|HLog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|HBaseFsck
operator|.
name|ErrorReporter
operator|.
name|ERROR_CODE
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|RootRegionTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|MultipleIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|TreeMultimap
import|;
end_import

begin_comment
comment|/**  * Check consistency among the in-memory states of the master and the  * region server(s) and the state of data in HDFS.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
class|class
name|HBaseFsck
block|{
specifier|public
specifier|static
specifier|final
name|long
name|DEFAULT_TIME_LAG
init|=
literal|60000
decl_stmt|;
comment|// default value of 1 minute
specifier|public
specifier|static
specifier|final
name|long
name|DEFAULT_SLEEP_BEFORE_RERUN
init|=
literal|10000
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|THREADS_KEEP_ALIVE_SECONDS
init|=
literal|60
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HBaseFsck
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
name|Configuration
name|conf
decl_stmt|;
specifier|private
name|ClusterStatus
name|status
decl_stmt|;
specifier|private
name|HConnection
name|connection
decl_stmt|;
specifier|private
name|TreeMap
argument_list|<
name|String
argument_list|,
name|HbckInfo
argument_list|>
name|regionInfo
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|HbckInfo
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|TreeMap
argument_list|<
name|String
argument_list|,
name|TInfo
argument_list|>
name|tablesInfo
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|TInfo
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|TreeSet
argument_list|<
name|byte
index|[]
argument_list|>
name|disabledTables
init|=
operator|new
name|TreeSet
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
name|ErrorReporter
name|errors
init|=
operator|new
name|PrintingErrorReporter
argument_list|()
decl_stmt|;
specifier|private
specifier|static
name|boolean
name|details
init|=
literal|false
decl_stmt|;
comment|// do we display the full report
specifier|private
name|long
name|timelag
init|=
name|DEFAULT_TIME_LAG
decl_stmt|;
comment|// tables whose modtime is older
specifier|private
name|boolean
name|fix
init|=
literal|false
decl_stmt|;
comment|// do we want to try fixing the errors?
specifier|private
name|boolean
name|rerun
init|=
literal|false
decl_stmt|;
comment|// if we tried to fix something rerun hbck
specifier|private
specifier|static
name|boolean
name|summary
init|=
literal|false
decl_stmt|;
comment|// if we want to print less output
specifier|private
name|boolean
name|checkMetaOnly
init|=
literal|false
decl_stmt|;
comment|// Empty regioninfo qualifiers in .META.
specifier|private
name|Set
argument_list|<
name|Result
argument_list|>
name|emptyRegionInfoQualifiers
init|=
operator|new
name|HashSet
argument_list|<
name|Result
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|HBaseAdmin
name|admin
decl_stmt|;
name|ThreadPoolExecutor
name|executor
decl_stmt|;
comment|// threads to retrieve data from regionservers
comment|/**    * Constructor    *    * @param conf Configuration object    * @throws MasterNotRunningException if the master is not running    * @throws ZooKeeperConnectionException if unable to connect to zookeeper    */
specifier|public
name|HBaseFsck
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
throws|,
name|IOException
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|int
name|numThreads
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbasefsck.numthreads"
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
name|executor
operator|=
operator|new
name|ThreadPoolExecutor
argument_list|(
literal|1
argument_list|,
name|numThreads
argument_list|,
name|THREADS_KEEP_ALIVE_SECONDS
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
operator|new
name|SynchronousQueue
argument_list|<
name|Runnable
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|executor
operator|.
name|allowCoreThreadTimeOut
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|connect
parameter_list|()
throws|throws
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
block|{
name|admin
operator|=
operator|new
name|HBaseAdmin
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|status
operator|=
name|admin
operator|.
name|getMaster
argument_list|()
operator|.
name|getClusterStatus
argument_list|()
expr_stmt|;
name|connection
operator|=
name|admin
operator|.
name|getConnection
argument_list|()
expr_stmt|;
block|}
comment|/**    * Contacts the master and prints out cluster-wide information    * @throws IOException if a remote or network exception occurs    * @return 0 on success, non-zero on failure    * @throws KeeperException    * @throws InterruptedException    */
specifier|public
name|int
name|doWork
parameter_list|()
throws|throws
name|IOException
throws|,
name|KeeperException
throws|,
name|InterruptedException
block|{
comment|// print hbase server version
name|errors
operator|.
name|print
argument_list|(
literal|"Version: "
operator|+
name|status
operator|.
name|getHBaseVersion
argument_list|()
argument_list|)
expr_stmt|;
comment|// Make sure regionInfo is empty before starting
name|regionInfo
operator|.
name|clear
argument_list|()
expr_stmt|;
name|tablesInfo
operator|.
name|clear
argument_list|()
expr_stmt|;
name|emptyRegionInfoQualifiers
operator|.
name|clear
argument_list|()
expr_stmt|;
name|disabledTables
operator|.
name|clear
argument_list|()
expr_stmt|;
name|errors
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// get a list of all regions from the master. This involves
comment|// scanning the META table
if|if
condition|(
operator|!
name|recordRootRegion
argument_list|()
condition|)
block|{
comment|// Will remove later if we can fix it
name|errors
operator|.
name|reportError
argument_list|(
literal|"Encountered fatal error. Exiting..."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|getMetaEntries
argument_list|()
expr_stmt|;
comment|// Check if .META. is found only once and in the right place
if|if
condition|(
operator|!
name|checkMetaEntries
argument_list|()
condition|)
block|{
comment|// Will remove later if we can fix it
name|errors
operator|.
name|reportError
argument_list|(
literal|"Encountered fatal error. Exiting..."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|// get a list of all tables that have not changed recently.
if|if
condition|(
operator|!
name|checkMetaOnly
condition|)
block|{
name|AtomicInteger
name|numSkipped
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|HTableDescriptor
index|[]
name|allTables
init|=
name|getTables
argument_list|(
name|numSkipped
argument_list|)
decl_stmt|;
name|errors
operator|.
name|print
argument_list|(
literal|"Number of Tables: "
operator|+
operator|(
name|allTables
operator|==
literal|null
condition|?
literal|0
else|:
name|allTables
operator|.
name|length
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|details
condition|)
block|{
if|if
condition|(
name|numSkipped
operator|.
name|get
argument_list|()
operator|>
literal|0
condition|)
block|{
name|errors
operator|.
name|detail
argument_list|(
literal|"Number of Tables in flux: "
operator|+
name|numSkipped
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|allTables
operator|!=
literal|null
operator|&&
name|allTables
operator|.
name|length
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|HTableDescriptor
name|td
range|:
name|allTables
control|)
block|{
name|String
name|tableName
init|=
name|td
operator|.
name|getNameAsString
argument_list|()
decl_stmt|;
name|errors
operator|.
name|detail
argument_list|(
literal|"  Table: "
operator|+
name|tableName
operator|+
literal|"\t"
operator|+
operator|(
name|td
operator|.
name|isReadOnly
argument_list|()
condition|?
literal|"ro"
else|:
literal|"rw"
operator|)
operator|+
literal|"\t"
operator|+
operator|(
name|td
operator|.
name|isRootRegion
argument_list|()
condition|?
literal|"ROOT"
else|:
operator|(
name|td
operator|.
name|isMetaRegion
argument_list|()
condition|?
literal|"META"
else|:
literal|"    "
operator|)
operator|)
operator|+
literal|"\t"
operator|+
literal|" families: "
operator|+
name|td
operator|.
name|getFamilies
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// From the master, get a list of all known live region servers
name|Collection
argument_list|<
name|ServerName
argument_list|>
name|regionServers
init|=
name|status
operator|.
name|getServers
argument_list|()
decl_stmt|;
name|errors
operator|.
name|print
argument_list|(
literal|"Number of live region servers: "
operator|+
name|regionServers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|details
condition|)
block|{
for|for
control|(
name|ServerName
name|rsinfo
range|:
name|regionServers
control|)
block|{
name|errors
operator|.
name|print
argument_list|(
literal|"  "
operator|+
name|rsinfo
argument_list|)
expr_stmt|;
block|}
block|}
comment|// From the master, get a list of all dead region servers
name|Collection
argument_list|<
name|ServerName
argument_list|>
name|deadRegionServers
init|=
name|status
operator|.
name|getDeadServerNames
argument_list|()
decl_stmt|;
name|errors
operator|.
name|print
argument_list|(
literal|"Number of dead region servers: "
operator|+
name|deadRegionServers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|details
condition|)
block|{
for|for
control|(
name|ServerName
name|name
range|:
name|deadRegionServers
control|)
block|{
name|errors
operator|.
name|print
argument_list|(
literal|"  "
operator|+
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Print the current master name and state
name|errors
operator|.
name|print
argument_list|(
literal|"Master: "
operator|+
name|status
operator|.
name|getMaster
argument_list|()
argument_list|)
expr_stmt|;
comment|// Print the list of all backup masters
name|Collection
argument_list|<
name|ServerName
argument_list|>
name|backupMasters
init|=
name|status
operator|.
name|getBackupMasters
argument_list|()
decl_stmt|;
name|errors
operator|.
name|print
argument_list|(
literal|"Number of backup masters: "
operator|+
name|backupMasters
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|details
condition|)
block|{
for|for
control|(
name|ServerName
name|name
range|:
name|backupMasters
control|)
block|{
name|errors
operator|.
name|print
argument_list|(
literal|"  "
operator|+
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Determine what's deployed
name|processRegionServers
argument_list|(
name|regionServers
argument_list|)
expr_stmt|;
comment|// Determine what's on HDFS
name|checkHdfs
argument_list|()
expr_stmt|;
comment|// Empty cells in .META.?
name|errors
operator|.
name|print
argument_list|(
literal|"Number of empty REGIONINFO_QUALIFIER rows in .META.: "
operator|+
name|emptyRegionInfoQualifiers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|details
condition|)
block|{
for|for
control|(
name|Result
name|r
range|:
name|emptyRegionInfoQualifiers
control|)
block|{
name|errors
operator|.
name|print
argument_list|(
literal|"  "
operator|+
name|r
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Get disabled tables from ZooKeeper
name|loadDisabledTables
argument_list|()
expr_stmt|;
comment|// Check consistency
name|checkConsistency
argument_list|()
expr_stmt|;
comment|// Check integrity
name|checkIntegrity
argument_list|()
expr_stmt|;
comment|// Print table summary
name|printTableSummary
argument_list|()
expr_stmt|;
return|return
name|errors
operator|.
name|summarize
argument_list|()
return|;
block|}
specifier|public
name|ErrorReporter
name|getErrors
parameter_list|()
block|{
return|return
name|errors
return|;
block|}
comment|/**    * Populate a specific hbi from regioninfo on file system.    */
specifier|private
name|void
name|loadMetaEntry
parameter_list|(
name|HbckInfo
name|hbi
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|regionDir
init|=
name|hbi
operator|.
name|foundRegionDir
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|Path
name|regioninfo
init|=
operator|new
name|Path
argument_list|(
name|regionDir
argument_list|,
name|HRegion
operator|.
name|REGIONINFO_FILE
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FSDataInputStream
name|in
init|=
name|fs
operator|.
name|open
argument_list|(
name|regioninfo
argument_list|)
decl_stmt|;
name|byte
index|[]
name|tableName
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|hbi
operator|.
name|hdfsTableName
argument_list|)
decl_stmt|;
name|HRegionInfo
name|hri
init|=
operator|new
name|HRegionInfo
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|hri
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"HRegionInfo read: "
operator|+
name|hri
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|hbi
operator|.
name|metaEntry
operator|=
operator|new
name|MetaEntry
argument_list|(
name|hri
argument_list|,
literal|null
argument_list|,
name|hbi
operator|.
name|foundRegionDir
operator|.
name|getModificationTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
class|class
name|RegionInfoLoadException
extends|extends
name|IOException
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
specifier|final
name|IOException
name|ioe
decl_stmt|;
specifier|public
name|RegionInfoLoadException
parameter_list|(
name|String
name|s
parameter_list|,
name|IOException
name|ioe
parameter_list|)
block|{
name|super
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|this
operator|.
name|ioe
operator|=
name|ioe
expr_stmt|;
block|}
block|}
comment|/**    * Populate hbi's from regionInfos loaded from file system.     */
specifier|private
name|void
name|loadTableInfo
parameter_list|()
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|IOException
argument_list|>
name|ioes
init|=
operator|new
name|ArrayList
argument_list|<
name|IOException
argument_list|>
argument_list|()
decl_stmt|;
comment|// generate region split structure
for|for
control|(
name|HbckInfo
name|hbi
range|:
name|regionInfo
operator|.
name|values
argument_list|()
control|)
block|{
comment|// only load entries that haven't been loaded yet.
if|if
condition|(
name|hbi
operator|.
name|metaEntry
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|loadMetaEntry
argument_list|(
name|hbi
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"Unable to load region info for table "
operator|+
name|hbi
operator|.
name|hdfsTableName
operator|+
literal|"!  It may be an invalid format or version file.  You may want to "
operator|+
literal|"remove "
operator|+
name|hbi
operator|.
name|foundRegionDir
operator|.
name|getPath
argument_list|()
operator|+
literal|" region from hdfs and retry."
decl_stmt|;
name|errors
operator|.
name|report
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
name|ioes
operator|.
name|add
argument_list|(
operator|new
name|RegionInfoLoadException
argument_list|(
name|msg
argument_list|,
name|ioe
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|// get table name from hdfs, populate various HBaseFsck tables.
name|String
name|tableName
init|=
name|hbi
operator|.
name|hdfsTableName
decl_stmt|;
name|TInfo
name|modTInfo
init|=
name|tablesInfo
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|modTInfo
operator|==
literal|null
condition|)
block|{
name|modTInfo
operator|=
operator|new
name|TInfo
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
name|modTInfo
operator|.
name|addRegionInfo
argument_list|(
name|hbi
argument_list|)
expr_stmt|;
name|tablesInfo
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|modTInfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioes
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
throw|throw
name|MultipleIOException
operator|.
name|createIOException
argument_list|(
name|ioes
argument_list|)
throw|;
block|}
block|}
comment|/**    * This borrows code from MasterFileSystem.bootstrap()    *     * @return an open .META. HRegion    */
specifier|private
name|HRegion
name|createNewRootAndMeta
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|rootdir
init|=
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|HBASE_DIR
argument_list|)
argument_list|)
decl_stmt|;
name|Configuration
name|c
init|=
name|conf
decl_stmt|;
name|HRegionInfo
name|rootHRI
init|=
operator|new
name|HRegionInfo
argument_list|(
name|HRegionInfo
operator|.
name|ROOT_REGIONINFO
argument_list|)
decl_stmt|;
name|MasterFileSystem
operator|.
name|setInfoFamilyCachingForRoot
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|HRegionInfo
name|metaHRI
init|=
operator|new
name|HRegionInfo
argument_list|(
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
argument_list|)
decl_stmt|;
name|MasterFileSystem
operator|.
name|setInfoFamilyCachingForMeta
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|HRegion
name|root
init|=
name|HRegion
operator|.
name|createHRegion
argument_list|(
name|rootHRI
argument_list|,
name|rootdir
argument_list|,
name|c
argument_list|,
name|HTableDescriptor
operator|.
name|ROOT_TABLEDESC
argument_list|)
decl_stmt|;
name|HRegion
name|meta
init|=
name|HRegion
operator|.
name|createHRegion
argument_list|(
name|metaHRI
argument_list|,
name|rootdir
argument_list|,
name|c
argument_list|,
name|HTableDescriptor
operator|.
name|META_TABLEDESC
argument_list|)
decl_stmt|;
name|MasterFileSystem
operator|.
name|setInfoFamilyCachingForRoot
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|MasterFileSystem
operator|.
name|setInfoFamilyCachingForMeta
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Add first region from the META table to the ROOT region.
name|HRegion
operator|.
name|addRegionToMETA
argument_list|(
name|root
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|root
operator|.
name|close
argument_list|()
expr_stmt|;
name|root
operator|.
name|getLog
argument_list|()
operator|.
name|closeAndDelete
argument_list|()
expr_stmt|;
return|return
name|meta
return|;
block|}
comment|/**    * Generate set of puts to add to new meta.  This expects the tables to be     * clean with no overlaps or holes.  If there are any problems it returns null.    *     * @return An array list of puts to do in bulk, null if tables have problems    */
specifier|private
name|ArrayList
argument_list|<
name|Put
argument_list|>
name|generatePuts
parameter_list|()
throws|throws
name|IOException
block|{
name|ArrayList
argument_list|<
name|Put
argument_list|>
name|puts
init|=
operator|new
name|ArrayList
argument_list|<
name|Put
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|hasProblems
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|TInfo
argument_list|>
name|e
range|:
name|tablesInfo
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
comment|// skip "-ROOT-" and ".META."
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|name
argument_list|)
argument_list|,
name|HConstants
operator|.
name|ROOT_TABLE_NAME
argument_list|)
operator|==
literal|0
operator|||
name|Bytes
operator|.
name|compareTo
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|name
argument_list|)
argument_list|,
name|HConstants
operator|.
name|META_TABLE_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|TInfo
name|ti
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|Collection
argument_list|<
name|HbckInfo
argument_list|>
argument_list|>
name|spl
range|:
name|ti
operator|.
name|sc
operator|.
name|getStarts
argument_list|()
operator|.
name|asMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Collection
argument_list|<
name|HbckInfo
argument_list|>
name|his
init|=
name|spl
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|int
name|sz
init|=
name|his
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|sz
operator|!=
literal|1
condition|)
block|{
comment|// problem
name|LOG
operator|.
name|error
argument_list|(
literal|"Split starting at "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|spl
operator|.
name|getKey
argument_list|()
argument_list|)
operator|+
literal|" had "
operator|+
name|sz
operator|+
literal|" regions instead of exactly 1."
argument_list|)
expr_stmt|;
name|hasProblems
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
comment|// add the row directly to meta.
name|HbckInfo
name|hi
init|=
name|his
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|HRegionInfo
name|hri
init|=
name|hi
operator|.
name|metaEntry
decl_stmt|;
name|Put
name|p
init|=
operator|new
name|Put
argument_list|(
name|hri
operator|.
name|getRegionName
argument_list|()
argument_list|)
decl_stmt|;
name|p
operator|.
name|add
argument_list|(
name|HConstants
operator|.
name|CATALOG_FAMILY
argument_list|,
name|HConstants
operator|.
name|REGIONINFO_QUALIFIER
argument_list|,
name|Writables
operator|.
name|getBytes
argument_list|(
name|hri
argument_list|)
argument_list|)
expr_stmt|;
name|puts
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|hasProblems
condition|?
literal|null
else|:
name|puts
return|;
block|}
comment|/**    * Suggest fixes for each table    */
specifier|private
name|void
name|suggestFixes
parameter_list|(
name|TreeMap
argument_list|<
name|String
argument_list|,
name|TInfo
argument_list|>
name|tablesInfo
parameter_list|)
block|{
for|for
control|(
name|TInfo
name|tInfo
range|:
name|tablesInfo
operator|.
name|values
argument_list|()
control|)
block|{
name|tInfo
operator|.
name|checkRegionChain
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Rebuilds meta from information in hdfs/fs.  Depends on configuration    * settings passed into hbck constructor to point to a particular fs/dir.    *     * @return true if successful, false if attempt failed.    */
specifier|public
name|boolean
name|rebuildMeta
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
comment|// TODO check to make sure hbase is offline. (or at least the table
comment|// currently being worked on is off line)
comment|// Determine what's on HDFS
name|LOG
operator|.
name|info
argument_list|(
literal|"Loading HBase regioninfo from HDFS..."
argument_list|)
expr_stmt|;
name|checkHdfs
argument_list|()
expr_stmt|;
comment|// populating regioninfo table.
name|loadTableInfo
argument_list|()
expr_stmt|;
comment|// update tableInfos based on region info in fs.
name|LOG
operator|.
name|info
argument_list|(
literal|"Checking HBase region split map from HDFS data..."
argument_list|)
expr_stmt|;
name|int
name|errs
init|=
name|errors
operator|.
name|getErrorList
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|TInfo
name|tInfo
range|:
name|tablesInfo
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|tInfo
operator|.
name|checkRegionChain
argument_list|()
condition|)
block|{
comment|// should dump info as well.
name|errors
operator|.
name|report
argument_list|(
literal|"Found inconsistency in table "
operator|+
name|tInfo
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// make sure ok.
if|if
condition|(
name|errors
operator|.
name|getErrorList
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
name|errs
condition|)
block|{
name|suggestFixes
argument_list|(
name|tablesInfo
argument_list|)
expr_stmt|;
comment|// Not ok, bail out.
return|return
literal|false
return|;
block|}
comment|// we can rebuild, move old root and meta out of the way and start
name|LOG
operator|.
name|info
argument_list|(
literal|"HDFS regioninfo's seems good.  Sidelining old .META."
argument_list|)
expr_stmt|;
name|sidelineOldRootAndMeta
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Creating new .META."
argument_list|)
expr_stmt|;
name|HRegion
name|meta
init|=
name|createNewRootAndMeta
argument_list|()
decl_stmt|;
comment|// populate meta
name|List
argument_list|<
name|Put
argument_list|>
name|puts
init|=
name|generatePuts
argument_list|()
decl_stmt|;
if|if
condition|(
name|puts
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Problem encountered when creating new .META. entries.  "
operator|+
literal|"You may need to restore the previously sidlined -ROOT- and .META."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|meta
operator|.
name|put
argument_list|(
name|puts
operator|.
name|toArray
argument_list|(
operator|new
name|Put
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|meta
operator|.
name|close
argument_list|()
expr_stmt|;
name|meta
operator|.
name|getLog
argument_list|()
operator|.
name|closeAndDelete
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Success! .META. table rebuilt."
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|void
name|sidelineTable
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|byte
index|[]
name|table
parameter_list|,
name|Path
name|hbaseDir
parameter_list|,
name|Path
name|backupHbaseDir
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|tableName
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|table
argument_list|)
decl_stmt|;
name|Path
name|tableDir
init|=
operator|new
name|Path
argument_list|(
name|hbaseDir
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|tableDir
argument_list|)
condition|)
block|{
name|Path
name|backupTableDir
init|=
operator|new
name|Path
argument_list|(
name|backupHbaseDir
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
name|fs
operator|.
name|rename
argument_list|(
name|tableDir
argument_list|,
name|backupTableDir
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to move  "
operator|+
name|tableName
operator|+
literal|" from "
operator|+
name|tableDir
operator|.
name|getName
argument_list|()
operator|+
literal|" to "
operator|+
name|backupTableDir
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No previous "
operator|+
name|tableName
operator|+
literal|" exists.  Continuing."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @return Path to backup of original directory    * @throws IOException    */
name|Path
name|sidelineOldRootAndMeta
parameter_list|()
throws|throws
name|IOException
block|{
comment|// put current -ROOT- and .META. aside.
name|Path
name|hbaseDir
init|=
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|HBASE_DIR
argument_list|)
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|hbaseDir
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|Path
name|backupDir
init|=
operator|new
name|Path
argument_list|(
name|hbaseDir
operator|.
name|getParent
argument_list|()
argument_list|,
name|hbaseDir
operator|.
name|getName
argument_list|()
operator|+
literal|"-"
operator|+
name|now
argument_list|)
decl_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|backupDir
argument_list|)
expr_stmt|;
name|sidelineTable
argument_list|(
name|fs
argument_list|,
name|HConstants
operator|.
name|ROOT_TABLE_NAME
argument_list|,
name|hbaseDir
argument_list|,
name|backupDir
argument_list|)
expr_stmt|;
try|try
block|{
name|sidelineTable
argument_list|(
name|fs
argument_list|,
name|HConstants
operator|.
name|META_TABLE_NAME
argument_list|,
name|hbaseDir
argument_list|,
name|backupDir
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Attempt to sideline meta failed, attempt to revert..."
argument_list|,
name|e
argument_list|)
expr_stmt|;
try|try
block|{
comment|// move it back.
name|sidelineTable
argument_list|(
name|fs
argument_list|,
name|HConstants
operator|.
name|ROOT_TABLE_NAME
argument_list|,
name|backupDir
argument_list|,
name|hbaseDir
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"... revert succeed.  -ROOT- and .META. still in "
operator|+
literal|"original state."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"... failed to sideline root and meta and failed to restore "
operator|+
literal|"prevoius state.  Currently in inconsistent state.  To restore "
operator|+
literal|"try to rename -ROOT- in "
operator|+
name|backupDir
operator|.
name|getName
argument_list|()
operator|+
literal|" to "
operator|+
name|hbaseDir
operator|.
name|getName
argument_list|()
operator|+
literal|"."
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
comment|// throw original exception
block|}
return|return
name|backupDir
return|;
block|}
comment|/**    * Load the list of disabled tables in ZK into local set.    * @throws ZooKeeperConnectionException    * @throws IOException    */
specifier|private
name|void
name|loadDisabledTables
parameter_list|()
throws|throws
name|ZooKeeperConnectionException
throws|,
name|IOException
block|{
name|HConnectionManager
operator|.
name|execute
argument_list|(
operator|new
name|HConnectable
argument_list|<
name|Void
argument_list|>
argument_list|(
name|conf
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|connect
parameter_list|(
name|HConnection
name|connection
parameter_list|)
throws|throws
name|IOException
block|{
name|ZooKeeperWatcher
name|zkw
init|=
name|connection
operator|.
name|getZooKeeperWatcher
argument_list|()
decl_stmt|;
try|try
block|{
for|for
control|(
name|String
name|tableName
range|:
name|ZKTable
operator|.
name|getDisabledOrDisablingTables
argument_list|(
name|zkw
argument_list|)
control|)
block|{
name|disabledTables
operator|.
name|add
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|ke
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|ke
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check if the specified region's table is disabled.    * @throws ZooKeeperConnectionException    * @throws IOException    * @throws KeeperException    */
specifier|private
name|boolean
name|isTableDisabled
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
block|{
return|return
name|disabledTables
operator|.
name|contains
argument_list|(
name|regionInfo
operator|.
name|getTableName
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Scan HDFS for all regions, recording their information into    * regionInfo    */
specifier|public
name|void
name|checkHdfs
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|Path
name|rootDir
init|=
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|HBASE_DIR
argument_list|)
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|rootDir
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// list all tables from HDFS
name|List
argument_list|<
name|FileStatus
argument_list|>
name|tableDirs
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|boolean
name|foundVersionFile
init|=
literal|false
decl_stmt|;
name|FileStatus
index|[]
name|files
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|rootDir
argument_list|)
decl_stmt|;
for|for
control|(
name|FileStatus
name|file
range|:
name|files
control|)
block|{
name|String
name|dirName
init|=
name|file
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|dirName
operator|.
name|equals
argument_list|(
name|HConstants
operator|.
name|VERSION_FILE_NAME
argument_list|)
condition|)
block|{
name|foundVersionFile
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|checkMetaOnly
operator|||
name|dirName
operator|.
name|equals
argument_list|(
literal|"-ROOT-"
argument_list|)
operator|||
name|dirName
operator|.
name|equals
argument_list|(
literal|".META."
argument_list|)
condition|)
block|{
name|tableDirs
operator|.
name|add
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// verify that version file exists
if|if
condition|(
operator|!
name|foundVersionFile
condition|)
block|{
name|errors
operator|.
name|reportError
argument_list|(
name|ERROR_CODE
operator|.
name|NO_VERSION_FILE
argument_list|,
literal|"Version file does not exist in root dir "
operator|+
name|rootDir
argument_list|)
expr_stmt|;
block|}
comment|// level 1:<HBASE_DIR>/*
name|WorkItemHdfsDir
index|[]
name|dirs
init|=
operator|new
name|WorkItemHdfsDir
index|[
name|tableDirs
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FileStatus
name|tableDir
range|:
name|tableDirs
control|)
block|{
name|dirs
index|[
name|num
index|]
operator|=
operator|new
name|WorkItemHdfsDir
argument_list|(
name|this
argument_list|,
name|fs
argument_list|,
name|errors
argument_list|,
name|tableDir
argument_list|)
expr_stmt|;
name|executor
operator|.
name|execute
argument_list|(
name|dirs
index|[
name|num
index|]
argument_list|)
expr_stmt|;
name|num
operator|++
expr_stmt|;
block|}
comment|// wait for all directories to be done
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
synchronized|synchronized
init|(
name|dirs
index|[
name|i
index|]
init|)
block|{
while|while
condition|(
operator|!
name|dirs
index|[
name|i
index|]
operator|.
name|isDone
argument_list|()
condition|)
block|{
name|dirs
index|[
name|i
index|]
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Record the location of the ROOT region as found in ZooKeeper,    * as if it were in a META table. This is so that we can check    * deployment of ROOT.    */
name|boolean
name|recordRootRegion
parameter_list|()
throws|throws
name|IOException
block|{
name|HRegionLocation
name|rootLocation
init|=
name|connection
operator|.
name|locateRegion
argument_list|(
name|HConstants
operator|.
name|ROOT_TABLE_NAME
argument_list|,
name|HConstants
operator|.
name|EMPTY_START_ROW
argument_list|)
decl_stmt|;
comment|// Check if Root region is valid and existing
if|if
condition|(
name|rootLocation
operator|==
literal|null
operator|||
name|rootLocation
operator|.
name|getRegionInfo
argument_list|()
operator|==
literal|null
operator|||
name|rootLocation
operator|.
name|getHostname
argument_list|()
operator|==
literal|null
condition|)
block|{
name|errors
operator|.
name|reportError
argument_list|(
name|ERROR_CODE
operator|.
name|NULL_ROOT_REGION
argument_list|,
literal|"Root Region or some of its attributes are null."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|ServerName
name|sn
decl_stmt|;
try|try
block|{
name|sn
operator|=
name|getRootRegionServerName
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Interrupted"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|MetaEntry
name|m
init|=
operator|new
name|MetaEntry
argument_list|(
name|rootLocation
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|sn
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
decl_stmt|;
name|HbckInfo
name|hbInfo
init|=
operator|new
name|HbckInfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|regionInfo
operator|.
name|put
argument_list|(
name|rootLocation
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedName
argument_list|()
argument_list|,
name|hbInfo
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
name|ServerName
name|getRootRegionServerName
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|RootRegionTracker
name|rootRegionTracker
init|=
operator|new
name|RootRegionTracker
argument_list|(
name|this
operator|.
name|connection
operator|.
name|getZooKeeperWatcher
argument_list|()
argument_list|,
operator|new
name|Abortable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|abort
parameter_list|(
name|String
name|why
parameter_list|,
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|why
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isAborted
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|rootRegionTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|ServerName
name|sn
init|=
literal|null
decl_stmt|;
try|try
block|{
name|sn
operator|=
name|rootRegionTracker
operator|.
name|getRootRegionLocation
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|rootRegionTracker
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
return|return
name|sn
return|;
block|}
comment|/**    * Contacts each regionserver and fetches metadata about regions.    * @param regionServerList - the list of region servers to connect to    * @throws IOException if a remote or network exception occurs    */
name|void
name|processRegionServers
parameter_list|(
name|Collection
argument_list|<
name|ServerName
argument_list|>
name|regionServerList
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|WorkItemRegion
index|[]
name|work
init|=
operator|new
name|WorkItemRegion
index|[
name|regionServerList
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
comment|// loop to contact each region server in parallel
for|for
control|(
name|ServerName
name|rsinfo
range|:
name|regionServerList
control|)
block|{
name|work
index|[
name|num
index|]
operator|=
operator|new
name|WorkItemRegion
argument_list|(
name|this
argument_list|,
name|rsinfo
argument_list|,
name|errors
argument_list|,
name|connection
argument_list|)
expr_stmt|;
name|executor
operator|.
name|execute
argument_list|(
name|work
index|[
name|num
index|]
argument_list|)
expr_stmt|;
name|num
operator|++
expr_stmt|;
block|}
comment|// wait for all submitted tasks to be done
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
synchronized|synchronized
init|(
name|work
index|[
name|i
index|]
init|)
block|{
while|while
condition|(
operator|!
name|work
index|[
name|i
index|]
operator|.
name|isDone
argument_list|()
condition|)
block|{
name|work
index|[
name|i
index|]
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Check consistency of all regions that have been found in previous phases.    * @throws KeeperException    * @throws InterruptedException    */
name|void
name|checkConsistency
parameter_list|()
throws|throws
name|IOException
throws|,
name|KeeperException
throws|,
name|InterruptedException
block|{
for|for
control|(
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|HbckInfo
argument_list|>
name|e
range|:
name|regionInfo
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|doConsistencyCheck
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Check a single region for consistency and correct deployment.    * @throws KeeperException    * @throws InterruptedException    */
name|void
name|doConsistencyCheck
parameter_list|(
specifier|final
name|String
name|key
parameter_list|,
specifier|final
name|HbckInfo
name|hbi
parameter_list|)
throws|throws
name|IOException
throws|,
name|KeeperException
throws|,
name|InterruptedException
block|{
name|String
name|descriptiveName
init|=
name|hbi
operator|.
name|toString
argument_list|()
decl_stmt|;
name|boolean
name|inMeta
init|=
name|hbi
operator|.
name|metaEntry
operator|!=
literal|null
decl_stmt|;
name|boolean
name|inHdfs
init|=
name|hbi
operator|.
name|foundRegionDir
operator|!=
literal|null
decl_stmt|;
name|boolean
name|hasMetaAssignment
init|=
name|inMeta
operator|&&
name|hbi
operator|.
name|metaEntry
operator|.
name|regionServer
operator|!=
literal|null
decl_stmt|;
name|boolean
name|isDeployed
init|=
operator|!
name|hbi
operator|.
name|deployedOn
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
name|boolean
name|isMultiplyDeployed
init|=
name|hbi
operator|.
name|deployedOn
operator|.
name|size
argument_list|()
operator|>
literal|1
decl_stmt|;
name|boolean
name|deploymentMatchesMeta
init|=
name|hasMetaAssignment
operator|&&
name|isDeployed
operator|&&
operator|!
name|isMultiplyDeployed
operator|&&
name|hbi
operator|.
name|metaEntry
operator|.
name|regionServer
operator|.
name|equals
argument_list|(
name|hbi
operator|.
name|deployedOn
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|boolean
name|splitParent
init|=
operator|(
name|hbi
operator|.
name|metaEntry
operator|==
literal|null
operator|)
condition|?
literal|false
else|:
name|hbi
operator|.
name|metaEntry
operator|.
name|isSplit
argument_list|()
operator|&&
name|hbi
operator|.
name|metaEntry
operator|.
name|isOffline
argument_list|()
decl_stmt|;
name|boolean
name|shouldBeDeployed
init|=
name|inMeta
operator|&&
operator|!
name|isTableDisabled
argument_list|(
name|hbi
operator|.
name|metaEntry
argument_list|)
decl_stmt|;
name|boolean
name|recentlyModified
init|=
name|hbi
operator|.
name|foundRegionDir
operator|!=
literal|null
operator|&&
name|hbi
operator|.
name|foundRegionDir
operator|.
name|getModificationTime
argument_list|()
operator|+
name|timelag
operator|>
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|// ========== First the healthy cases =============
if|if
condition|(
name|hbi
operator|.
name|onlyEdits
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|inMeta
operator|&&
name|inHdfs
operator|&&
name|isDeployed
operator|&&
name|deploymentMatchesMeta
operator|&&
name|shouldBeDeployed
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|inMeta
operator|&&
operator|!
name|isDeployed
operator|&&
name|splitParent
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|inMeta
operator|&&
operator|!
name|shouldBeDeployed
operator|&&
operator|!
name|isDeployed
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|recentlyModified
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Region "
operator|+
name|descriptiveName
operator|+
literal|" was recently modified -- skipping"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// ========== Cases where the region is not in META =============
elseif|else
if|if
condition|(
operator|!
name|inMeta
operator|&&
operator|!
name|inHdfs
operator|&&
operator|!
name|isDeployed
condition|)
block|{
comment|// We shouldn't have record of this region at all then!
assert|assert
literal|false
operator|:
literal|"Entry for region with no data"
assert|;
block|}
elseif|else
if|if
condition|(
operator|!
name|inMeta
operator|&&
operator|!
name|inHdfs
operator|&&
name|isDeployed
condition|)
block|{
name|errors
operator|.
name|reportError
argument_list|(
name|ERROR_CODE
operator|.
name|NOT_IN_META_HDFS
argument_list|,
literal|"Region "
operator|+
name|descriptiveName
operator|+
literal|", key="
operator|+
name|key
operator|+
literal|", not on HDFS or in META but "
operator|+
literal|"deployed on "
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|", "
argument_list|)
operator|.
name|join
argument_list|(
name|hbi
operator|.
name|deployedOn
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|inMeta
operator|&&
name|inHdfs
operator|&&
operator|!
name|isDeployed
condition|)
block|{
name|errors
operator|.
name|reportError
argument_list|(
name|ERROR_CODE
operator|.
name|NOT_IN_META_OR_DEPLOYED
argument_list|,
literal|"Region "
operator|+
name|descriptiveName
operator|+
literal|" on HDFS, but not listed in META "
operator|+
literal|"or deployed on any region server"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|inMeta
operator|&&
name|inHdfs
operator|&&
name|isDeployed
condition|)
block|{
name|errors
operator|.
name|reportError
argument_list|(
name|ERROR_CODE
operator|.
name|NOT_IN_META
argument_list|,
literal|"Region "
operator|+
name|descriptiveName
operator|+
literal|" not in META, but deployed on "
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|", "
argument_list|)
operator|.
name|join
argument_list|(
name|hbi
operator|.
name|deployedOn
argument_list|)
argument_list|)
expr_stmt|;
comment|// ========== Cases where the region is in META =============
block|}
elseif|else
if|if
condition|(
name|inMeta
operator|&&
operator|!
name|inHdfs
operator|&&
operator|!
name|isDeployed
condition|)
block|{
name|errors
operator|.
name|reportError
argument_list|(
name|ERROR_CODE
operator|.
name|NOT_IN_HDFS_OR_DEPLOYED
argument_list|,
literal|"Region "
operator|+
name|descriptiveName
operator|+
literal|" found in META, but not in HDFS "
operator|+
literal|"or deployed on any region server."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inMeta
operator|&&
operator|!
name|inHdfs
operator|&&
name|isDeployed
condition|)
block|{
name|errors
operator|.
name|reportError
argument_list|(
name|ERROR_CODE
operator|.
name|NOT_IN_HDFS
argument_list|,
literal|"Region "
operator|+
name|descriptiveName
operator|+
literal|" found in META, but not in HDFS, "
operator|+
literal|"and deployed on "
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|", "
argument_list|)
operator|.
name|join
argument_list|(
name|hbi
operator|.
name|deployedOn
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inMeta
operator|&&
name|inHdfs
operator|&&
operator|!
name|isDeployed
operator|&&
name|shouldBeDeployed
condition|)
block|{
name|errors
operator|.
name|reportError
argument_list|(
name|ERROR_CODE
operator|.
name|NOT_DEPLOYED
argument_list|,
literal|"Region "
operator|+
name|descriptiveName
operator|+
literal|" not deployed on any region server."
argument_list|)
expr_stmt|;
comment|// If we are trying to fix the errors
if|if
condition|(
name|shouldFix
argument_list|()
condition|)
block|{
name|errors
operator|.
name|print
argument_list|(
literal|"Trying to fix unassigned region..."
argument_list|)
expr_stmt|;
name|setShouldRerun
argument_list|()
expr_stmt|;
name|HBaseFsckRepair
operator|.
name|fixUnassigned
argument_list|(
name|this
operator|.
name|admin
argument_list|,
name|hbi
operator|.
name|metaEntry
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|inMeta
operator|&&
name|inHdfs
operator|&&
name|isDeployed
operator|&&
operator|!
name|shouldBeDeployed
condition|)
block|{
name|errors
operator|.
name|reportError
argument_list|(
name|ERROR_CODE
operator|.
name|SHOULD_NOT_BE_DEPLOYED
argument_list|,
literal|"Region "
operator|+
name|descriptiveName
operator|+
literal|" should not be deployed according "
operator|+
literal|"to META, but is deployed on "
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|", "
argument_list|)
operator|.
name|join
argument_list|(
name|hbi
operator|.
name|deployedOn
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inMeta
operator|&&
name|inHdfs
operator|&&
name|isMultiplyDeployed
condition|)
block|{
name|errors
operator|.
name|reportError
argument_list|(
name|ERROR_CODE
operator|.
name|MULTI_DEPLOYED
argument_list|,
literal|"Region "
operator|+
name|descriptiveName
operator|+
literal|" is listed in META on region server "
operator|+
name|hbi
operator|.
name|metaEntry
operator|.
name|regionServer
operator|+
literal|" but is multiply assigned to region servers "
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|", "
argument_list|)
operator|.
name|join
argument_list|(
name|hbi
operator|.
name|deployedOn
argument_list|)
argument_list|)
expr_stmt|;
comment|// If we are trying to fix the errors
if|if
condition|(
name|shouldFix
argument_list|()
condition|)
block|{
name|errors
operator|.
name|print
argument_list|(
literal|"Trying to fix assignment error..."
argument_list|)
expr_stmt|;
name|setShouldRerun
argument_list|()
expr_stmt|;
name|HBaseFsckRepair
operator|.
name|fixDupeAssignment
argument_list|(
name|this
operator|.
name|admin
argument_list|,
name|hbi
operator|.
name|metaEntry
argument_list|,
name|hbi
operator|.
name|deployedOn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|inMeta
operator|&&
name|inHdfs
operator|&&
name|isDeployed
operator|&&
operator|!
name|deploymentMatchesMeta
condition|)
block|{
name|errors
operator|.
name|reportError
argument_list|(
name|ERROR_CODE
operator|.
name|SERVER_DOES_NOT_MATCH_META
argument_list|,
literal|"Region "
operator|+
name|descriptiveName
operator|+
literal|" listed in META on region server "
operator|+
name|hbi
operator|.
name|metaEntry
operator|.
name|regionServer
operator|+
literal|" but found on region server "
operator|+
name|hbi
operator|.
name|deployedOn
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// If we are trying to fix the errors
if|if
condition|(
name|shouldFix
argument_list|()
condition|)
block|{
name|errors
operator|.
name|print
argument_list|(
literal|"Trying to fix assignment error..."
argument_list|)
expr_stmt|;
name|setShouldRerun
argument_list|()
expr_stmt|;
name|HBaseFsckRepair
operator|.
name|fixDupeAssignment
argument_list|(
name|this
operator|.
name|admin
argument_list|,
name|hbi
operator|.
name|metaEntry
argument_list|,
name|hbi
operator|.
name|deployedOn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|errors
operator|.
name|reportError
argument_list|(
name|ERROR_CODE
operator|.
name|UNKNOWN
argument_list|,
literal|"Region "
operator|+
name|descriptiveName
operator|+
literal|" is in an unforeseen state:"
operator|+
literal|" inMeta="
operator|+
name|inMeta
operator|+
literal|" inHdfs="
operator|+
name|inHdfs
operator|+
literal|" isDeployed="
operator|+
name|isDeployed
operator|+
literal|" isMultiplyDeployed="
operator|+
name|isMultiplyDeployed
operator|+
literal|" deploymentMatchesMeta="
operator|+
name|deploymentMatchesMeta
operator|+
literal|" shouldBeDeployed="
operator|+
name|shouldBeDeployed
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Checks tables integrity. Goes over all regions and scans the tables.    * Collects all the pieces for each table and checks if there are missing,    * repeated or overlapping ones.    */
name|void
name|checkIntegrity
parameter_list|()
block|{
for|for
control|(
name|HbckInfo
name|hbi
range|:
name|regionInfo
operator|.
name|values
argument_list|()
control|)
block|{
comment|// Check only valid, working regions
if|if
condition|(
name|hbi
operator|.
name|metaEntry
operator|==
literal|null
condition|)
continue|continue;
if|if
condition|(
name|hbi
operator|.
name|metaEntry
operator|.
name|regionServer
operator|==
literal|null
condition|)
continue|continue;
if|if
condition|(
name|hbi
operator|.
name|onlyEdits
condition|)
continue|continue;
comment|// Missing regionDir or over-deployment is checked elsewhere. Include
comment|// these cases in modTInfo, so we can evaluate those regions as part of
comment|// the region chain in META
comment|//if (hbi.foundRegionDir == null) continue;
comment|//if (hbi.deployedOn.size() != 1) continue;
if|if
condition|(
name|hbi
operator|.
name|deployedOn
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
continue|continue;
comment|// We should be safe here
name|String
name|tableName
init|=
name|hbi
operator|.
name|metaEntry
operator|.
name|getTableNameAsString
argument_list|()
decl_stmt|;
name|TInfo
name|modTInfo
init|=
name|tablesInfo
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|modTInfo
operator|==
literal|null
condition|)
block|{
name|modTInfo
operator|=
operator|new
name|TInfo
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ServerName
name|server
range|:
name|hbi
operator|.
name|deployedOn
control|)
block|{
name|modTInfo
operator|.
name|addServer
argument_list|(
name|server
argument_list|)
expr_stmt|;
block|}
name|modTInfo
operator|.
name|addRegionInfo
argument_list|(
name|hbi
argument_list|)
expr_stmt|;
name|tablesInfo
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|modTInfo
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|TInfo
name|tInfo
range|:
name|tablesInfo
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|tInfo
operator|.
name|checkRegionChain
argument_list|()
condition|)
block|{
name|errors
operator|.
name|report
argument_list|(
literal|"Found inconsistency in table "
operator|+
name|tInfo
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Maintain information about a particular table.    */
specifier|private
class|class
name|TInfo
block|{
name|String
name|tableName
decl_stmt|;
name|TreeSet
argument_list|<
name|ServerName
argument_list|>
name|deployedOn
decl_stmt|;
specifier|final
name|List
argument_list|<
name|HbckInfo
argument_list|>
name|backwards
init|=
operator|new
name|ArrayList
argument_list|<
name|HbckInfo
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|RegionSplitCalculator
argument_list|<
name|HbckInfo
argument_list|>
name|sc
init|=
operator|new
name|RegionSplitCalculator
argument_list|<
name|HbckInfo
argument_list|>
argument_list|(
name|cmp
argument_list|)
decl_stmt|;
comment|// key = start split, values = set of splits in problem group
specifier|final
name|Multimap
argument_list|<
name|byte
index|[]
argument_list|,
name|HbckInfo
argument_list|>
name|overlapGroups
init|=
name|TreeMultimap
operator|.
name|create
argument_list|(
name|RegionSplitCalculator
operator|.
name|BYTES_COMPARATOR
argument_list|,
name|cmp
argument_list|)
decl_stmt|;
name|TInfo
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|tableName
operator|=
name|name
expr_stmt|;
name|deployedOn
operator|=
operator|new
name|TreeSet
argument_list|<
name|ServerName
argument_list|>
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|addRegionInfo
parameter_list|(
name|HbckInfo
name|hir
parameter_list|)
block|{
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|hir
operator|.
name|getEndKey
argument_list|()
argument_list|,
name|HConstants
operator|.
name|EMPTY_END_ROW
argument_list|)
condition|)
block|{
comment|// end key is absolute end key, just add it.
name|sc
operator|.
name|add
argument_list|(
name|hir
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// if not the absolute end key, check for cycle
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|hir
operator|.
name|getStartKey
argument_list|()
argument_list|,
name|hir
operator|.
name|getEndKey
argument_list|()
argument_list|)
operator|>
literal|0
condition|)
block|{
name|errors
operator|.
name|reportError
argument_list|(
name|ERROR_CODE
operator|.
name|REGION_CYCLE
argument_list|,
name|String
operator|.
name|format
argument_list|(
literal|"The endkey for this region comes before the "
operator|+
literal|"startkey, startkey=%s, endkey=%s"
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|hir
operator|.
name|getStartKey
argument_list|()
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|hir
operator|.
name|getEndKey
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|hir
argument_list|)
expr_stmt|;
name|backwards
operator|.
name|add
argument_list|(
name|hir
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// main case, add to split calculator
name|sc
operator|.
name|add
argument_list|(
name|hir
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|addServer
parameter_list|(
name|ServerName
name|server
parameter_list|)
block|{
name|this
operator|.
name|deployedOn
operator|.
name|add
argument_list|(
name|server
argument_list|)
expr_stmt|;
block|}
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|tableName
return|;
block|}
specifier|public
name|int
name|getNumRegions
parameter_list|()
block|{
return|return
name|sc
operator|.
name|getStarts
argument_list|()
operator|.
name|size
argument_list|()
operator|+
name|backwards
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Check the region chain (from META) of this table.  We are looking for      * holes, overlaps, and cycles.      * @return false if there are errors      */
specifier|public
name|boolean
name|checkRegionChain
parameter_list|()
block|{
name|int
name|originalErrorsCount
init|=
name|errors
operator|.
name|getErrorList
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|Multimap
argument_list|<
name|byte
index|[]
argument_list|,
name|HbckInfo
argument_list|>
name|regions
init|=
name|sc
operator|.
name|calcCoverage
argument_list|()
decl_stmt|;
name|SortedSet
argument_list|<
name|byte
index|[]
argument_list|>
name|splits
init|=
name|sc
operator|.
name|getSplits
argument_list|()
decl_stmt|;
name|byte
index|[]
name|prevKey
init|=
literal|null
decl_stmt|;
name|byte
index|[]
name|problemKey
init|=
literal|null
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|key
range|:
name|splits
control|)
block|{
name|Collection
argument_list|<
name|HbckInfo
argument_list|>
name|ranges
init|=
name|regions
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|prevKey
operator|==
literal|null
operator|&&
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|key
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|)
condition|)
block|{
for|for
control|(
name|HbckInfo
name|rng
range|:
name|ranges
control|)
block|{
comment|// TODO offline fix region hole.
name|errors
operator|.
name|reportError
argument_list|(
name|ERROR_CODE
operator|.
name|FIRST_REGION_STARTKEY_NOT_EMPTY
argument_list|,
literal|"First region should start with an empty key.  You need to "
operator|+
literal|" create a new region and regioninfo in HDFS to plug the hole."
argument_list|,
name|this
argument_list|,
name|rng
argument_list|)
expr_stmt|;
block|}
block|}
comment|// check for degenerate ranges
for|for
control|(
name|HbckInfo
name|rng
range|:
name|ranges
control|)
block|{
comment|// special endkey case converts '' to null
name|byte
index|[]
name|endKey
init|=
name|rng
operator|.
name|getEndKey
argument_list|()
decl_stmt|;
name|endKey
operator|=
operator|(
name|endKey
operator|.
name|length
operator|==
literal|0
operator|)
condition|?
literal|null
else|:
name|endKey
expr_stmt|;
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|rng
operator|.
name|getStartKey
argument_list|()
argument_list|,
name|endKey
argument_list|)
condition|)
block|{
name|errors
operator|.
name|reportError
argument_list|(
name|ERROR_CODE
operator|.
name|DEGENERATE_REGION
argument_list|,
literal|"Region has the same start and end key."
argument_list|,
name|this
argument_list|,
name|rng
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ranges
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// this split key is ok -- no overlap, not a hole.
if|if
condition|(
name|problemKey
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"reached end of problem group: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|problemKey
operator|=
literal|null
expr_stmt|;
comment|// fell through, no more problem.
block|}
elseif|else
if|if
condition|(
name|ranges
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// set the new problem key group name, if already have problem key, just
comment|// keep using it.
if|if
condition|(
name|problemKey
operator|==
literal|null
condition|)
block|{
comment|// only for overlap regions.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Naming new problem group: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|problemKey
operator|=
name|key
expr_stmt|;
block|}
name|overlapGroups
operator|.
name|putAll
argument_list|(
name|problemKey
argument_list|,
name|ranges
argument_list|)
expr_stmt|;
comment|// record errors
name|ArrayList
argument_list|<
name|HbckInfo
argument_list|>
name|subRange
init|=
operator|new
name|ArrayList
argument_list|<
name|HbckInfo
argument_list|>
argument_list|(
name|ranges
argument_list|)
decl_stmt|;
comment|//  this dumb and n^2 but this shouldn't happen often
for|for
control|(
name|HbckInfo
name|r1
range|:
name|ranges
control|)
block|{
name|subRange
operator|.
name|remove
argument_list|(
name|r1
argument_list|)
expr_stmt|;
for|for
control|(
name|HbckInfo
name|r2
range|:
name|subRange
control|)
block|{
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|r1
operator|.
name|getStartKey
argument_list|()
argument_list|,
name|r2
operator|.
name|getStartKey
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// dup start key
name|errors
operator|.
name|reportError
argument_list|(
name|ERROR_CODE
operator|.
name|DUPE_STARTKEYS
argument_list|,
literal|"Multiple regions have the same startkey: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|key
argument_list|)
argument_list|,
name|this
argument_list|,
name|r1
argument_list|)
expr_stmt|;
name|errors
operator|.
name|reportError
argument_list|(
name|ERROR_CODE
operator|.
name|DUPE_STARTKEYS
argument_list|,
literal|"Multiple regions have the same startkey: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|key
argument_list|)
argument_list|,
name|this
argument_list|,
name|r2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// overlap
name|errors
operator|.
name|reportError
argument_list|(
name|ERROR_CODE
operator|.
name|OVERLAP_IN_REGION_CHAIN
argument_list|,
literal|"There is an overlap in the region chain."
argument_list|,
name|this
argument_list|,
name|r1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ranges
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|problemKey
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"reached end of problem group: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|problemKey
operator|=
literal|null
expr_stmt|;
name|byte
index|[]
name|holeStopKey
init|=
name|sc
operator|.
name|getSplits
argument_list|()
operator|.
name|higher
argument_list|(
name|key
argument_list|)
decl_stmt|;
comment|// if higher key is null we reached the top.
if|if
condition|(
name|holeStopKey
operator|!=
literal|null
condition|)
block|{
comment|// hole
name|errors
operator|.
name|reportError
argument_list|(
name|ERROR_CODE
operator|.
name|HOLE_IN_REGION_CHAIN
argument_list|,
literal|"There is a hole in the region chain between "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|key
argument_list|)
operator|+
literal|" and "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|holeStopKey
argument_list|)
operator|+
literal|".  You need to create a new regioninfo and region "
operator|+
literal|"dir in hdfs to plug the hole."
argument_list|)
expr_stmt|;
block|}
block|}
name|prevKey
operator|=
name|key
expr_stmt|;
block|}
if|if
condition|(
name|details
condition|)
block|{
comment|// do full region split map dump
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"---- Table '"
operator|+
name|this
operator|.
name|tableName
operator|+
literal|"': region split map"
argument_list|)
expr_stmt|;
name|dump
argument_list|(
name|splits
argument_list|,
name|regions
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"---- Table '"
operator|+
name|this
operator|.
name|tableName
operator|+
literal|"': overlap groups"
argument_list|)
expr_stmt|;
name|dumpOverlapProblems
argument_list|(
name|overlapGroups
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"There are "
operator|+
name|overlapGroups
operator|.
name|keySet
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|" overlap groups with "
operator|+
name|overlapGroups
operator|.
name|size
argument_list|()
operator|+
literal|" overlapping regions"
argument_list|)
expr_stmt|;
block|}
return|return
name|errors
operator|.
name|getErrorList
argument_list|()
operator|.
name|size
argument_list|()
operator|==
name|originalErrorsCount
return|;
block|}
comment|/**      * This dumps data in a visually reasonable way for visual debugging      *       * @param splits      * @param regions      */
name|void
name|dump
parameter_list|(
name|SortedSet
argument_list|<
name|byte
index|[]
argument_list|>
name|splits
parameter_list|,
name|Multimap
argument_list|<
name|byte
index|[]
argument_list|,
name|HbckInfo
argument_list|>
name|regions
parameter_list|)
block|{
comment|// we display this way because the last end key should be displayed as well.
for|for
control|(
name|byte
index|[]
name|k
range|:
name|splits
control|)
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|k
argument_list|)
operator|+
literal|":\t"
argument_list|)
expr_stmt|;
for|for
control|(
name|HbckInfo
name|r
range|:
name|regions
operator|.
name|get
argument_list|(
name|k
argument_list|)
control|)
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|"[ "
operator|+
name|r
operator|.
name|toString
argument_list|()
operator|+
literal|", "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|r
operator|.
name|getEndKey
argument_list|()
argument_list|)
operator|+
literal|"]\t"
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|dumpOverlapProblems
parameter_list|(
name|Multimap
argument_list|<
name|byte
index|[]
argument_list|,
name|HbckInfo
argument_list|>
name|regions
parameter_list|)
block|{
comment|// we display this way because the last end key should be displayed as
comment|// well.
for|for
control|(
name|byte
index|[]
name|k
range|:
name|regions
operator|.
name|keySet
argument_list|()
control|)
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|k
argument_list|)
operator|+
literal|":\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|HbckInfo
name|r
range|:
name|regions
operator|.
name|get
argument_list|(
name|k
argument_list|)
control|)
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|"[ "
operator|+
name|r
operator|.
name|toString
argument_list|()
operator|+
literal|", "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|r
operator|.
name|getEndKey
argument_list|()
argument_list|)
operator|+
literal|"]\n"
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"----"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|Multimap
argument_list|<
name|byte
index|[]
argument_list|,
name|HbckInfo
argument_list|>
name|getOverlapGroups
parameter_list|(
name|String
name|table
parameter_list|)
block|{
return|return
name|tablesInfo
operator|.
name|get
argument_list|(
name|table
argument_list|)
operator|.
name|overlapGroups
return|;
block|}
comment|/**    * Return a list of user-space table names whose metadata have not been    * modified in the last few milliseconds specified by timelag    * if any of the REGIONINFO_QUALIFIER, SERVER_QUALIFIER, STARTCODE_QUALIFIER,    * SPLITA_QUALIFIER, SPLITB_QUALIFIER have not changed in the last    * milliseconds specified by timelag, then the table is a candidate to be returned.    * @return tables that have not been modified recently    * @throws IOException if an error is encountered    */
name|HTableDescriptor
index|[]
name|getTables
parameter_list|(
name|AtomicInteger
name|numSkipped
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|tableNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
for|for
control|(
name|HbckInfo
name|hbi
range|:
name|regionInfo
operator|.
name|values
argument_list|()
control|)
block|{
name|MetaEntry
name|info
init|=
name|hbi
operator|.
name|metaEntry
decl_stmt|;
comment|// if the start key is zero, then we have found the first region of a table.
comment|// pick only those tables that were not modified in the last few milliseconds.
if|if
condition|(
name|info
operator|!=
literal|null
operator|&&
name|info
operator|.
name|getStartKey
argument_list|()
operator|.
name|length
operator|==
literal|0
operator|&&
operator|!
name|info
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
if|if
condition|(
name|info
operator|.
name|modTime
operator|+
name|timelag
operator|<
name|now
condition|)
block|{
name|tableNames
operator|.
name|add
argument_list|(
name|info
operator|.
name|getTableNameAsString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|numSkipped
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
comment|// one more in-flux table
block|}
block|}
block|}
return|return
name|getHTableDescriptors
argument_list|(
name|tableNames
argument_list|)
return|;
block|}
name|HTableDescriptor
index|[]
name|getHTableDescriptors
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|tableNames
parameter_list|)
block|{
name|HTableDescriptor
index|[]
name|htd
init|=
literal|null
decl_stmt|;
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"getHTableDescriptors == tableNames => "
operator|+
name|tableNames
argument_list|)
expr_stmt|;
name|htd
operator|=
operator|new
name|HBaseAdmin
argument_list|(
name|conf
argument_list|)
operator|.
name|getTableDescriptors
argument_list|(
name|tableNames
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception getting table descriptors"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|htd
return|;
block|}
comment|/**    * Gets the entry in regionInfo corresponding to the the given encoded    * region name. If the region has not been seen yet, a new entry is added    * and returned.    */
specifier|private
specifier|synchronized
name|HbckInfo
name|getOrCreateInfo
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|HbckInfo
name|hbi
init|=
name|regionInfo
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|hbi
operator|==
literal|null
condition|)
block|{
name|hbi
operator|=
operator|new
name|HbckInfo
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|regionInfo
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|hbi
argument_list|)
expr_stmt|;
block|}
return|return
name|hbi
return|;
block|}
comment|/**     * Check values in regionInfo for .META.     * Check if zero or more than one regions with META are found.     * If there are inconsistencies (i.e. zero or more than one regions     * pretend to be holding the .META.) try to fix that and report an error.     * @throws IOException from HBaseFsckRepair functions    * @throws KeeperException    * @throws InterruptedException     */
name|boolean
name|checkMetaEntries
parameter_list|()
throws|throws
name|IOException
throws|,
name|KeeperException
throws|,
name|InterruptedException
block|{
name|List
argument_list|<
name|HbckInfo
argument_list|>
name|metaRegions
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|HbckInfo
name|value
range|:
name|regionInfo
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|value
operator|.
name|metaEntry
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
name|metaRegions
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If something is wrong
if|if
condition|(
name|metaRegions
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|HRegionLocation
name|rootLocation
init|=
name|connection
operator|.
name|locateRegion
argument_list|(
name|HConstants
operator|.
name|ROOT_TABLE_NAME
argument_list|,
name|HConstants
operator|.
name|EMPTY_START_ROW
argument_list|)
decl_stmt|;
name|HbckInfo
name|root
init|=
name|regionInfo
operator|.
name|get
argument_list|(
name|rootLocation
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
comment|// If there is no region holding .META.
if|if
condition|(
name|metaRegions
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|errors
operator|.
name|reportError
argument_list|(
name|ERROR_CODE
operator|.
name|NO_META_REGION
argument_list|,
literal|".META. is not found on any region."
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldFix
argument_list|()
condition|)
block|{
name|errors
operator|.
name|print
argument_list|(
literal|"Trying to fix a problem with .META..."
argument_list|)
expr_stmt|;
name|setShouldRerun
argument_list|()
expr_stmt|;
comment|// try to fix it (treat it as unassigned region)
name|HBaseFsckRepair
operator|.
name|fixUnassigned
argument_list|(
name|this
operator|.
name|admin
argument_list|,
name|root
operator|.
name|metaEntry
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If there are more than one regions pretending to hold the .META.
elseif|else
if|if
condition|(
name|metaRegions
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|errors
operator|.
name|reportError
argument_list|(
name|ERROR_CODE
operator|.
name|MULTI_META_REGION
argument_list|,
literal|".META. is found on more than one region."
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldFix
argument_list|()
condition|)
block|{
name|errors
operator|.
name|print
argument_list|(
literal|"Trying to fix a problem with .META..."
argument_list|)
expr_stmt|;
name|setShouldRerun
argument_list|()
expr_stmt|;
comment|// try fix it (treat is a dupe assignment)
name|List
argument_list|<
name|ServerName
argument_list|>
name|deployedOn
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|HbckInfo
name|mRegion
range|:
name|metaRegions
control|)
block|{
name|deployedOn
operator|.
name|add
argument_list|(
name|mRegion
operator|.
name|metaEntry
operator|.
name|regionServer
argument_list|)
expr_stmt|;
block|}
name|HBaseFsckRepair
operator|.
name|fixDupeAssignment
argument_list|(
name|this
operator|.
name|admin
argument_list|,
name|root
operator|.
name|metaEntry
argument_list|,
name|deployedOn
argument_list|)
expr_stmt|;
block|}
block|}
comment|// rerun hbck with hopefully fixed META
return|return
literal|false
return|;
block|}
comment|// no errors, so continue normally
return|return
literal|true
return|;
block|}
comment|/**    * Scan .META. and -ROOT-, adding all regions found to the regionInfo map.    * @throws IOException if an error is encountered    */
name|void
name|getMetaEntries
parameter_list|()
throws|throws
name|IOException
block|{
name|MetaScannerVisitor
name|visitor
init|=
operator|new
name|MetaScannerVisitor
argument_list|()
block|{
name|int
name|countRecord
init|=
literal|1
decl_stmt|;
comment|// comparator to sort KeyValues with latest modtime
specifier|final
name|Comparator
argument_list|<
name|KeyValue
argument_list|>
name|comp
init|=
operator|new
name|Comparator
argument_list|<
name|KeyValue
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|KeyValue
name|k1
parameter_list|,
name|KeyValue
name|k2
parameter_list|)
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|k1
operator|.
name|getTimestamp
argument_list|()
operator|-
name|k2
operator|.
name|getTimestamp
argument_list|()
argument_list|)
return|;
block|}
block|}
decl_stmt|;
specifier|public
name|boolean
name|processRow
parameter_list|(
name|Result
name|result
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
comment|// record the latest modification of this META record
name|long
name|ts
init|=
name|Collections
operator|.
name|max
argument_list|(
name|result
operator|.
name|list
argument_list|()
argument_list|,
name|comp
argument_list|)
operator|.
name|getTimestamp
argument_list|()
decl_stmt|;
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
init|=
name|MetaReader
operator|.
name|parseCatalogResult
argument_list|(
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
literal|null
operator|||
name|pair
operator|.
name|getFirst
argument_list|()
operator|==
literal|null
condition|)
block|{
name|emptyRegionInfoQualifiers
operator|.
name|add
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|ServerName
name|sn
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|pair
operator|.
name|getSecond
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|sn
operator|=
name|pair
operator|.
name|getSecond
argument_list|()
expr_stmt|;
block|}
name|MetaEntry
name|m
init|=
operator|new
name|MetaEntry
argument_list|(
name|pair
operator|.
name|getFirst
argument_list|()
argument_list|,
name|sn
argument_list|,
name|ts
argument_list|)
decl_stmt|;
name|HbckInfo
name|hbInfo
init|=
operator|new
name|HbckInfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|HbckInfo
name|previous
init|=
name|regionInfo
operator|.
name|put
argument_list|(
name|pair
operator|.
name|getFirst
argument_list|()
operator|.
name|getEncodedName
argument_list|()
argument_list|,
name|hbInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|previous
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Two entries in META are same "
operator|+
name|previous
argument_list|)
throw|;
block|}
comment|// show proof of progress to the user, once for every 100 records.
if|if
condition|(
name|countRecord
operator|%
literal|100
operator|==
literal|0
condition|)
block|{
name|errors
operator|.
name|progress
argument_list|()
expr_stmt|;
block|}
name|countRecord
operator|++
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Result="
operator|+
name|result
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
block|}
decl_stmt|;
comment|// Scan -ROOT- to pick up META regions
name|MetaScanner
operator|.
name|metaScan
argument_list|(
name|conf
argument_list|,
name|visitor
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|HConstants
operator|.
name|ROOT_TABLE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkMetaOnly
condition|)
block|{
comment|// Scan .META. to pick up user regions
name|MetaScanner
operator|.
name|metaScan
argument_list|(
name|conf
argument_list|,
name|visitor
argument_list|)
expr_stmt|;
block|}
name|errors
operator|.
name|print
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/**    * Stores the entries scanned from META    */
specifier|static
class|class
name|MetaEntry
extends|extends
name|HRegionInfo
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HRegionInfo
operator|.
name|class
argument_list|)
decl_stmt|;
name|ServerName
name|regionServer
decl_stmt|;
comment|// server hosting this region
name|long
name|modTime
decl_stmt|;
comment|// timestamp of most recent modification metadata
specifier|public
name|MetaEntry
parameter_list|(
name|HRegionInfo
name|rinfo
parameter_list|,
name|ServerName
name|regionServer
parameter_list|,
name|long
name|modTime
parameter_list|)
block|{
name|super
argument_list|(
name|rinfo
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionServer
operator|=
name|regionServer
expr_stmt|;
name|this
operator|.
name|modTime
operator|=
name|modTime
expr_stmt|;
block|}
block|}
comment|/**    * Maintain information about a particular region.    */
specifier|public
specifier|static
class|class
name|HbckInfo
implements|implements
name|KeyRange
block|{
name|boolean
name|onlyEdits
init|=
literal|false
decl_stmt|;
name|MetaEntry
name|metaEntry
init|=
literal|null
decl_stmt|;
name|FileStatus
name|foundRegionDir
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|ServerName
argument_list|>
name|deployedOn
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|String
name|hdfsTableName
init|=
literal|null
decl_stmt|;
comment|// This is set in the workitem loader.
name|HbckInfo
parameter_list|(
name|MetaEntry
name|metaEntry
parameter_list|)
block|{
name|this
operator|.
name|metaEntry
operator|=
name|metaEntry
expr_stmt|;
block|}
specifier|public
specifier|synchronized
name|void
name|addServer
parameter_list|(
name|ServerName
name|server
parameter_list|)
block|{
name|this
operator|.
name|deployedOn
operator|.
name|add
argument_list|(
name|server
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|synchronized
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
name|metaEntry
operator|!=
literal|null
condition|)
block|{
return|return
name|metaEntry
operator|.
name|getRegionNameAsString
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|foundRegionDir
operator|!=
literal|null
condition|)
block|{
return|return
name|foundRegionDir
operator|.
name|getPath
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|"UNKNOWN_REGION on "
operator|+
name|Joiner
operator|.
name|on
argument_list|(
literal|", "
argument_list|)
operator|.
name|join
argument_list|(
name|deployedOn
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|getStartKey
parameter_list|()
block|{
return|return
name|this
operator|.
name|metaEntry
operator|.
name|getStartKey
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|getEndKey
parameter_list|()
block|{
return|return
name|this
operator|.
name|metaEntry
operator|.
name|getEndKey
argument_list|()
return|;
block|}
block|}
specifier|final
specifier|static
name|Comparator
argument_list|<
name|HbckInfo
argument_list|>
name|cmp
init|=
operator|new
name|Comparator
argument_list|<
name|HbckInfo
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|HbckInfo
name|l
parameter_list|,
name|HbckInfo
name|r
parameter_list|)
block|{
if|if
condition|(
name|l
operator|==
name|r
condition|)
block|{
comment|// same instance
return|return
literal|0
return|;
block|}
name|int
name|tableCompare
init|=
name|RegionSplitCalculator
operator|.
name|BYTES_COMPARATOR
operator|.
name|compare
argument_list|(
name|l
operator|.
name|metaEntry
operator|.
name|getTableName
argument_list|()
argument_list|,
name|r
operator|.
name|metaEntry
operator|.
name|getTableName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|tableCompare
operator|!=
literal|0
condition|)
block|{
return|return
name|tableCompare
return|;
block|}
name|int
name|startComparison
init|=
name|RegionSplitCalculator
operator|.
name|BYTES_COMPARATOR
operator|.
name|compare
argument_list|(
name|l
operator|.
name|metaEntry
operator|.
name|getStartKey
argument_list|()
argument_list|,
name|r
operator|.
name|metaEntry
operator|.
name|getStartKey
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|startComparison
operator|!=
literal|0
condition|)
block|{
return|return
name|startComparison
return|;
block|}
comment|// Special case for absolute endkey
name|byte
index|[]
name|endKey
init|=
name|r
operator|.
name|metaEntry
operator|.
name|getEndKey
argument_list|()
decl_stmt|;
name|endKey
operator|=
operator|(
name|endKey
operator|.
name|length
operator|==
literal|0
operator|)
condition|?
literal|null
else|:
name|endKey
expr_stmt|;
name|byte
index|[]
name|endKey2
init|=
name|l
operator|.
name|metaEntry
operator|.
name|getEndKey
argument_list|()
decl_stmt|;
name|endKey2
operator|=
operator|(
name|endKey2
operator|.
name|length
operator|==
literal|0
operator|)
condition|?
literal|null
else|:
name|endKey2
expr_stmt|;
name|int
name|endComparison
init|=
name|RegionSplitCalculator
operator|.
name|BYTES_COMPARATOR
operator|.
name|compare
argument_list|(
name|endKey2
argument_list|,
name|endKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|endComparison
operator|!=
literal|0
condition|)
block|{
return|return
name|endComparison
return|;
block|}
comment|// use modTime as tiebreaker.
return|return
call|(
name|int
call|)
argument_list|(
name|l
operator|.
name|metaEntry
operator|.
name|modTime
operator|-
name|r
operator|.
name|metaEntry
operator|.
name|modTime
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Prints summary of all tables found on the system.    */
specifier|private
name|void
name|printTableSummary
parameter_list|()
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Summary:"
argument_list|)
expr_stmt|;
for|for
control|(
name|TInfo
name|tInfo
range|:
name|tablesInfo
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|errors
operator|.
name|tableHasErrors
argument_list|(
name|tInfo
argument_list|)
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Table "
operator|+
name|tInfo
operator|.
name|getName
argument_list|()
operator|+
literal|" is inconsistent."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  "
operator|+
name|tInfo
operator|.
name|getName
argument_list|()
operator|+
literal|" is okay."
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    Number of regions: "
operator|+
name|tInfo
operator|.
name|getNumRegions
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|"    Deployed on: "
argument_list|)
expr_stmt|;
for|for
control|(
name|ServerName
name|server
range|:
name|tInfo
operator|.
name|deployedOn
control|)
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|" "
operator|+
name|server
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
interface|interface
name|ErrorReporter
block|{
specifier|public
specifier|static
enum|enum
name|ERROR_CODE
block|{
name|UNKNOWN
block|,
name|NO_META_REGION
block|,
name|NULL_ROOT_REGION
block|,
name|NO_VERSION_FILE
block|,
name|NOT_IN_META_HDFS
block|,
name|NOT_IN_META
block|,
name|NOT_IN_META_OR_DEPLOYED
block|,
name|NOT_IN_HDFS_OR_DEPLOYED
block|,
name|NOT_IN_HDFS
block|,
name|SERVER_DOES_NOT_MATCH_META
block|,
name|NOT_DEPLOYED
block|,
name|MULTI_DEPLOYED
block|,
name|SHOULD_NOT_BE_DEPLOYED
block|,
name|MULTI_META_REGION
block|,
name|RS_CONNECT_FAILURE
block|,
name|FIRST_REGION_STARTKEY_NOT_EMPTY
block|,
name|DUPE_STARTKEYS
block|,
name|HOLE_IN_REGION_CHAIN
block|,
name|OVERLAP_IN_REGION_CHAIN
block|,
name|REGION_CYCLE
block|,
name|DEGENERATE_REGION
block|}
specifier|public
name|void
name|clear
parameter_list|()
function_decl|;
specifier|public
name|void
name|report
parameter_list|(
name|String
name|message
parameter_list|)
function_decl|;
specifier|public
name|void
name|reportError
parameter_list|(
name|String
name|message
parameter_list|)
function_decl|;
specifier|public
name|void
name|reportError
parameter_list|(
name|ERROR_CODE
name|errorCode
parameter_list|,
name|String
name|message
parameter_list|)
function_decl|;
specifier|public
name|void
name|reportError
parameter_list|(
name|ERROR_CODE
name|errorCode
parameter_list|,
name|String
name|message
parameter_list|,
name|TInfo
name|table
parameter_list|,
name|HbckInfo
name|info
parameter_list|)
function_decl|;
specifier|public
name|void
name|reportError
parameter_list|(
name|ERROR_CODE
name|errorCode
parameter_list|,
name|String
name|message
parameter_list|,
name|TInfo
name|table
parameter_list|,
name|HbckInfo
name|info1
parameter_list|,
name|HbckInfo
name|info2
parameter_list|)
function_decl|;
specifier|public
name|int
name|summarize
parameter_list|()
function_decl|;
specifier|public
name|void
name|detail
parameter_list|(
name|String
name|details
parameter_list|)
function_decl|;
specifier|public
name|ArrayList
argument_list|<
name|ERROR_CODE
argument_list|>
name|getErrorList
parameter_list|()
function_decl|;
specifier|public
name|void
name|progress
parameter_list|()
function_decl|;
specifier|public
name|void
name|print
parameter_list|(
name|String
name|message
parameter_list|)
function_decl|;
specifier|public
name|void
name|resetErrors
parameter_list|()
function_decl|;
specifier|public
name|boolean
name|tableHasErrors
parameter_list|(
name|TInfo
name|table
parameter_list|)
function_decl|;
block|}
specifier|private
specifier|static
class|class
name|PrintingErrorReporter
implements|implements
name|ErrorReporter
block|{
specifier|public
name|int
name|errorCount
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|showProgress
decl_stmt|;
name|Set
argument_list|<
name|TInfo
argument_list|>
name|errorTables
init|=
operator|new
name|HashSet
argument_list|<
name|TInfo
argument_list|>
argument_list|()
decl_stmt|;
comment|// for use by unit tests to verify which errors were discovered
specifier|private
name|ArrayList
argument_list|<
name|ERROR_CODE
argument_list|>
name|errorList
init|=
operator|new
name|ArrayList
argument_list|<
name|ERROR_CODE
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|errorTables
operator|.
name|clear
argument_list|()
expr_stmt|;
name|errorList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|errorCount
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
specifier|synchronized
name|void
name|reportError
parameter_list|(
name|ERROR_CODE
name|errorCode
parameter_list|,
name|String
name|message
parameter_list|)
block|{
name|errorList
operator|.
name|add
argument_list|(
name|errorCode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|summary
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"ERROR: "
operator|+
name|message
argument_list|)
expr_stmt|;
block|}
name|errorCount
operator|++
expr_stmt|;
name|showProgress
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
specifier|synchronized
name|void
name|reportError
parameter_list|(
name|ERROR_CODE
name|errorCode
parameter_list|,
name|String
name|message
parameter_list|,
name|TInfo
name|table
parameter_list|,
name|HbckInfo
name|info
parameter_list|)
block|{
name|errorTables
operator|.
name|add
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|String
name|reference
init|=
literal|"(region "
operator|+
name|info
operator|.
name|metaEntry
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|")"
decl_stmt|;
name|reportError
argument_list|(
name|errorCode
argument_list|,
name|reference
operator|+
literal|" "
operator|+
name|message
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|synchronized
name|void
name|reportError
parameter_list|(
name|ERROR_CODE
name|errorCode
parameter_list|,
name|String
name|message
parameter_list|,
name|TInfo
name|table
parameter_list|,
name|HbckInfo
name|info1
parameter_list|,
name|HbckInfo
name|info2
parameter_list|)
block|{
name|errorTables
operator|.
name|add
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|String
name|reference
init|=
literal|"(regions "
operator|+
name|info1
operator|.
name|metaEntry
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" and "
operator|+
name|info2
operator|.
name|metaEntry
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|")"
decl_stmt|;
name|reportError
argument_list|(
name|errorCode
argument_list|,
name|reference
operator|+
literal|" "
operator|+
name|message
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|synchronized
name|void
name|reportError
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|reportError
argument_list|(
name|ERROR_CODE
operator|.
name|UNKNOWN
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
comment|/**      * Report error information, but do not increment the error count.  Intended for cases      * where the actual error would have been reported previously.      * @param message      */
specifier|public
specifier|synchronized
name|void
name|report
parameter_list|(
name|String
name|message
parameter_list|)
block|{
if|if
condition|(
operator|!
name|summary
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"ERROR: "
operator|+
name|message
argument_list|)
expr_stmt|;
block|}
name|showProgress
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
specifier|synchronized
name|int
name|summarize
parameter_list|()
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|errorCount
argument_list|)
operator|+
literal|" inconsistencies detected."
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorCount
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Status: OK"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Status: INCONSISTENT"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
specifier|public
name|ArrayList
argument_list|<
name|ERROR_CODE
argument_list|>
name|getErrorList
parameter_list|()
block|{
return|return
name|errorList
return|;
block|}
specifier|public
specifier|synchronized
name|void
name|print
parameter_list|(
name|String
name|message
parameter_list|)
block|{
if|if
condition|(
operator|!
name|summary
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|tableHasErrors
parameter_list|(
name|TInfo
name|table
parameter_list|)
block|{
return|return
name|errorTables
operator|.
name|contains
argument_list|(
name|table
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|resetErrors
parameter_list|()
block|{
name|errorCount
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
specifier|synchronized
name|void
name|detail
parameter_list|(
name|String
name|message
parameter_list|)
block|{
if|if
condition|(
name|details
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
name|showProgress
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
specifier|synchronized
name|void
name|progress
parameter_list|()
block|{
if|if
condition|(
name|showProgress
operator|++
operator|==
literal|10
condition|)
block|{
if|if
condition|(
operator|!
name|summary
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
name|showProgress
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Contact a region server and get all information from it    */
specifier|static
class|class
name|WorkItemRegion
implements|implements
name|Runnable
block|{
specifier|private
name|HBaseFsck
name|hbck
decl_stmt|;
specifier|private
name|ServerName
name|rsinfo
decl_stmt|;
specifier|private
name|ErrorReporter
name|errors
decl_stmt|;
specifier|private
name|HConnection
name|connection
decl_stmt|;
specifier|private
name|boolean
name|done
decl_stmt|;
name|WorkItemRegion
parameter_list|(
name|HBaseFsck
name|hbck
parameter_list|,
name|ServerName
name|info
parameter_list|,
name|ErrorReporter
name|errors
parameter_list|,
name|HConnection
name|connection
parameter_list|)
block|{
name|this
operator|.
name|hbck
operator|=
name|hbck
expr_stmt|;
name|this
operator|.
name|rsinfo
operator|=
name|info
expr_stmt|;
name|this
operator|.
name|errors
operator|=
name|errors
expr_stmt|;
name|this
operator|.
name|connection
operator|=
name|connection
expr_stmt|;
name|this
operator|.
name|done
operator|=
literal|false
expr_stmt|;
block|}
comment|// is this task done?
specifier|synchronized
name|boolean
name|isDone
parameter_list|()
block|{
return|return
name|done
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|run
parameter_list|()
block|{
name|errors
operator|.
name|progress
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegionInterface
name|server
init|=
name|connection
operator|.
name|getHRegionConnection
argument_list|(
operator|new
name|HServerAddress
argument_list|(
name|rsinfo
operator|.
name|getHostname
argument_list|()
argument_list|,
name|rsinfo
operator|.
name|getPort
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// list all online regions from this region server
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
init|=
name|server
operator|.
name|getOnlineRegions
argument_list|()
decl_stmt|;
if|if
condition|(
name|hbck
operator|.
name|checkMetaOnly
condition|)
block|{
name|regions
operator|=
name|filterOnlyMetaRegions
argument_list|(
name|regions
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|details
condition|)
block|{
name|errors
operator|.
name|detail
argument_list|(
literal|"RegionServer: "
operator|+
name|rsinfo
operator|.
name|getServerName
argument_list|()
operator|+
literal|" number of regions: "
operator|+
name|regions
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|HRegionInfo
name|rinfo
range|:
name|regions
control|)
block|{
name|errors
operator|.
name|detail
argument_list|(
literal|"  "
operator|+
name|rinfo
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" id: "
operator|+
name|rinfo
operator|.
name|getRegionId
argument_list|()
operator|+
literal|" encoded_name: "
operator|+
name|rinfo
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" start: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|rinfo
operator|.
name|getStartKey
argument_list|()
argument_list|)
operator|+
literal|" end: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|rinfo
operator|.
name|getEndKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// check to see if the existence of this region matches the region in META
for|for
control|(
name|HRegionInfo
name|r
range|:
name|regions
control|)
block|{
name|HbckInfo
name|hbi
init|=
name|hbck
operator|.
name|getOrCreateInfo
argument_list|(
name|r
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
name|hbi
operator|.
name|addServer
argument_list|(
name|rsinfo
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// unable to connect to the region server.
name|errors
operator|.
name|reportError
argument_list|(
name|ERROR_CODE
operator|.
name|RS_CONNECT_FAILURE
argument_list|,
literal|"RegionServer: "
operator|+
name|rsinfo
operator|.
name|getServerName
argument_list|()
operator|+
literal|" Unable to fetch region information. "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|done
operator|=
literal|true
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
comment|// wakeup anybody waiting for this item to be done
block|}
block|}
specifier|private
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|filterOnlyMetaRegions
parameter_list|(
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
parameter_list|)
block|{
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|ret
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|HRegionInfo
name|hri
range|:
name|regions
control|)
block|{
if|if
condition|(
name|hri
operator|.
name|isMetaTable
argument_list|()
condition|)
block|{
name|ret
operator|.
name|add
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
block|}
comment|/**    * Contact hdfs and get all information about specified table directory.    */
specifier|static
class|class
name|WorkItemHdfsDir
implements|implements
name|Runnable
block|{
specifier|private
name|HBaseFsck
name|hbck
decl_stmt|;
specifier|private
name|FileStatus
name|tableDir
decl_stmt|;
specifier|private
name|ErrorReporter
name|errors
decl_stmt|;
specifier|private
name|FileSystem
name|fs
decl_stmt|;
specifier|private
name|boolean
name|done
decl_stmt|;
name|WorkItemHdfsDir
parameter_list|(
name|HBaseFsck
name|hbck
parameter_list|,
name|FileSystem
name|fs
parameter_list|,
name|ErrorReporter
name|errors
parameter_list|,
name|FileStatus
name|status
parameter_list|)
block|{
name|this
operator|.
name|hbck
operator|=
name|hbck
expr_stmt|;
name|this
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|this
operator|.
name|tableDir
operator|=
name|status
expr_stmt|;
name|this
operator|.
name|errors
operator|=
name|errors
expr_stmt|;
name|this
operator|.
name|done
operator|=
literal|false
expr_stmt|;
block|}
specifier|synchronized
name|boolean
name|isDone
parameter_list|()
block|{
return|return
name|done
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|String
name|tableName
init|=
name|tableDir
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// ignore hidden files
if|if
condition|(
name|tableName
operator|.
name|startsWith
argument_list|(
literal|"."
argument_list|)
operator|&&
operator|!
name|tableName
operator|.
name|equals
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|HConstants
operator|.
name|META_TABLE_NAME
argument_list|)
argument_list|)
condition|)
return|return;
comment|// level 2:<HBASE_DIR>/<table>/*
name|FileStatus
index|[]
name|regionDirs
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|tableDir
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|FileStatus
name|regionDir
range|:
name|regionDirs
control|)
block|{
name|String
name|encodedName
init|=
name|regionDir
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// ignore directories that aren't hexadecimal
if|if
condition|(
operator|!
name|encodedName
operator|.
name|toLowerCase
argument_list|()
operator|.
name|matches
argument_list|(
literal|"[0-9a-f]+"
argument_list|)
condition|)
continue|continue;
name|HbckInfo
name|hbi
init|=
name|hbck
operator|.
name|getOrCreateInfo
argument_list|(
name|encodedName
argument_list|)
decl_stmt|;
name|hbi
operator|.
name|hdfsTableName
operator|=
name|tableName
expr_stmt|;
synchronized|synchronized
init|(
name|hbi
init|)
block|{
if|if
condition|(
name|hbi
operator|.
name|foundRegionDir
operator|!=
literal|null
condition|)
block|{
name|errors
operator|.
name|print
argument_list|(
literal|"Directory "
operator|+
name|encodedName
operator|+
literal|" duplicate??"
operator|+
name|hbi
operator|.
name|foundRegionDir
argument_list|)
expr_stmt|;
block|}
name|hbi
operator|.
name|foundRegionDir
operator|=
name|regionDir
expr_stmt|;
comment|// Set a flag if this region contains only edits
comment|// This is special case if a region is left after split
name|hbi
operator|.
name|onlyEdits
operator|=
literal|true
expr_stmt|;
name|FileStatus
index|[]
name|subDirs
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|regionDir
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|ePath
init|=
name|HLog
operator|.
name|getRegionDirRecoveredEditsDir
argument_list|(
name|regionDir
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|FileStatus
name|subDir
range|:
name|subDirs
control|)
block|{
name|String
name|sdName
init|=
name|subDir
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|sdName
operator|.
name|startsWith
argument_list|(
literal|"."
argument_list|)
operator|&&
operator|!
name|sdName
operator|.
name|equals
argument_list|(
name|ePath
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|hbi
operator|.
name|onlyEdits
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// unable to connect to the region server.
name|errors
operator|.
name|reportError
argument_list|(
name|ERROR_CODE
operator|.
name|RS_CONNECT_FAILURE
argument_list|,
literal|"Table Directory: "
operator|+
name|tableDir
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" Unable to fetch region information. "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|done
operator|=
literal|true
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Display the full report from fsck. This displays all live and dead region    * servers, and all known regions.    */
specifier|public
name|void
name|displayFullReport
parameter_list|()
block|{
name|details
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * Set summary mode.    * Print only summary of the tables and status (OK or INCONSISTENT)    */
name|void
name|setSummary
parameter_list|()
block|{
name|summary
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * Set META check mode.    * Print only info about META table deployment/state    */
name|void
name|setCheckMetaOnly
parameter_list|()
block|{
name|checkMetaOnly
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * Check if we should rerun fsck again. This checks if we've tried to    * fix something and we should rerun fsck tool again.    * Display the full report from fsck. This displays all live and dead    * region servers, and all known regions.    */
name|void
name|setShouldRerun
parameter_list|()
block|{
name|rerun
operator|=
literal|true
expr_stmt|;
block|}
name|boolean
name|shouldRerun
parameter_list|()
block|{
return|return
name|rerun
return|;
block|}
comment|/**    * Fix inconsistencies found by fsck. This should try to fix errors (if any)    * found by fsck utility.    */
specifier|public
name|void
name|setFixErrors
parameter_list|(
name|boolean
name|shouldFix
parameter_list|)
block|{
name|fix
operator|=
name|shouldFix
expr_stmt|;
block|}
name|boolean
name|shouldFix
parameter_list|()
block|{
return|return
name|fix
return|;
block|}
comment|/**    * We are interested in only those tables that have not changed their state in    * META during the last few seconds specified by hbase.admin.fsck.timelag    * @param seconds - the time in seconds    */
specifier|public
name|void
name|setTimeLag
parameter_list|(
name|long
name|seconds
parameter_list|)
block|{
name|timelag
operator|=
name|seconds
operator|*
literal|1000
expr_stmt|;
comment|// convert to milliseconds
block|}
specifier|protected
specifier|static
name|void
name|printUsageAndExit
parameter_list|()
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Usage: fsck [opts] "
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|" where [opts] are:"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"   -details Display full report of all regions."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"   -timelag {timeInSeconds}  Process only regions that "
operator|+
literal|" have not experienced any metadata updates in the last "
operator|+
literal|" {{timeInSeconds} seconds."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"   -fix Try to fix some of the errors."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"   -sleepBeforeRerun {timeInSeconds} Sleep this many seconds"
operator|+
literal|" before checking if the fix worked if run with -fix"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"   -summary Print only summary of the tables and status."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"   -metaonly Only check the state of ROOT and META tables."
argument_list|)
expr_stmt|;
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exit
argument_list|(
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/**    * Main program    * @param args    * @throws Exception    */
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
comment|// create a fsck object
name|Configuration
name|conf
init|=
name|HBaseConfiguration
operator|.
name|create
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
literal|"fs.defaultFS"
argument_list|,
name|conf
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|HBASE_DIR
argument_list|)
argument_list|)
expr_stmt|;
name|HBaseFsck
name|fsck
init|=
operator|new
name|HBaseFsck
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|long
name|sleepBeforeRerun
init|=
name|DEFAULT_SLEEP_BEFORE_RERUN
decl_stmt|;
comment|// Process command-line args.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|cmd
init|=
name|args
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|cmd
operator|.
name|equals
argument_list|(
literal|"-details"
argument_list|)
condition|)
block|{
name|fsck
operator|.
name|displayFullReport
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|.
name|equals
argument_list|(
literal|"-timelag"
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|args
operator|.
name|length
operator|-
literal|1
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"HBaseFsck: -timelag needs a value."
argument_list|)
expr_stmt|;
name|printUsageAndExit
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|long
name|timelag
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|args
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
name|fsck
operator|.
name|setTimeLag
argument_list|(
name|timelag
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"-timelag needs a numeric value."
argument_list|)
expr_stmt|;
name|printUsageAndExit
argument_list|()
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|.
name|equals
argument_list|(
literal|"-sleepBeforeRerun"
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|args
operator|.
name|length
operator|-
literal|1
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"HBaseFsck: -sleepBeforeRerun needs a value."
argument_list|)
expr_stmt|;
name|printUsageAndExit
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|sleepBeforeRerun
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|args
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"-sleepBeforeRerun needs a numeric value."
argument_list|)
expr_stmt|;
name|printUsageAndExit
argument_list|()
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|.
name|equals
argument_list|(
literal|"-fix"
argument_list|)
condition|)
block|{
name|fsck
operator|.
name|setFixErrors
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|.
name|equals
argument_list|(
literal|"-summary"
argument_list|)
condition|)
block|{
name|fsck
operator|.
name|setSummary
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|.
name|equals
argument_list|(
literal|"-metaonly"
argument_list|)
condition|)
block|{
name|fsck
operator|.
name|setCheckMetaOnly
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|String
name|str
init|=
literal|"Unknown command line option : "
operator|+
name|cmd
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|printUsageAndExit
argument_list|()
expr_stmt|;
block|}
block|}
comment|// do the real work of fsck
name|fsck
operator|.
name|connect
argument_list|()
expr_stmt|;
name|int
name|code
init|=
name|fsck
operator|.
name|doWork
argument_list|()
decl_stmt|;
comment|// If we have changed the HBase state it is better to run fsck again
comment|// to see if we haven't broken something else in the process.
comment|// We run it only once more because otherwise we can easily fall into
comment|// an infinite loop.
if|if
condition|(
name|fsck
operator|.
name|shouldRerun
argument_list|()
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Sleeping "
operator|+
name|sleepBeforeRerun
operator|+
literal|"ms before re-checking after fix..."
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepBeforeRerun
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exit
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|// Just report
name|fsck
operator|.
name|setFixErrors
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|fsck
operator|.
name|errors
operator|.
name|resetErrors
argument_list|()
expr_stmt|;
name|code
operator|=
name|fsck
operator|.
name|doWork
argument_list|()
expr_stmt|;
block|}
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exit
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

