begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2010 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|ManagementFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|RuntimeMXBean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|rmi
operator|.
name|UnexpectedException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Scan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|HeapSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ClassSize
import|;
end_import

begin_comment
comment|/**  * The MemStore holds in-memory modifications to the Store.  Modifications  * are {@link KeyValue}s.  When asked to flush, current memstore is moved  * to snapshot and is cleared.  We continue to serve edits out of new memstore  * and backing snapshot until flusher reports in that the flush succeeded. At  * this point we let the snapshot go.  * TODO: Adjust size of the memstore when we remove items because they have  * been deleted.  * TODO: With new KVSLS, need to make sure we update HeapSize with difference  * in KV size.  */
end_comment

begin_class
specifier|public
class|class
name|MemStore
implements|implements
name|HeapSize
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|MemStore
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// MemStore.  Use a KeyValueSkipListSet rather than SkipListSet because of the
comment|// better semantics.  The Map will overwrite if passed a key it already had
comment|// whereas the Set will not add new KV if key is same though value might be
comment|// different.  Value is not important -- just make sure always same
comment|// reference passed.
specifier|volatile
name|KeyValueSkipListSet
name|kvset
decl_stmt|;
comment|// Snapshot of memstore.  Made for flusher.
specifier|volatile
name|KeyValueSkipListSet
name|snapshot
decl_stmt|;
specifier|final
name|ReentrantReadWriteLock
name|lock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
specifier|final
name|KeyValue
operator|.
name|KVComparator
name|comparator
decl_stmt|;
comment|// Used comparing versions -- same r/c and ts but different type.
specifier|final
name|KeyValue
operator|.
name|KVComparator
name|comparatorIgnoreType
decl_stmt|;
comment|// Used comparing versions -- same r/c and type but different timestamp.
specifier|final
name|KeyValue
operator|.
name|KVComparator
name|comparatorIgnoreTimestamp
decl_stmt|;
comment|// Used to track own heapSize
specifier|final
name|AtomicLong
name|size
decl_stmt|;
name|TimeRangeTracker
name|timeRangeTracker
decl_stmt|;
name|TimeRangeTracker
name|snapshotTimeRangeTracker
decl_stmt|;
comment|/**    * Default constructor. Used for tests.    */
specifier|public
name|MemStore
parameter_list|()
block|{
name|this
argument_list|(
name|KeyValue
operator|.
name|COMPARATOR
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructor.    * @param c Comparator    */
specifier|public
name|MemStore
parameter_list|(
specifier|final
name|KeyValue
operator|.
name|KVComparator
name|c
parameter_list|)
block|{
name|this
operator|.
name|comparator
operator|=
name|c
expr_stmt|;
name|this
operator|.
name|comparatorIgnoreTimestamp
operator|=
name|this
operator|.
name|comparator
operator|.
name|getComparatorIgnoringTimestamps
argument_list|()
expr_stmt|;
name|this
operator|.
name|comparatorIgnoreType
operator|=
name|this
operator|.
name|comparator
operator|.
name|getComparatorIgnoringType
argument_list|()
expr_stmt|;
name|this
operator|.
name|kvset
operator|=
operator|new
name|KeyValueSkipListSet
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|this
operator|.
name|snapshot
operator|=
operator|new
name|KeyValueSkipListSet
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|timeRangeTracker
operator|=
operator|new
name|TimeRangeTracker
argument_list|()
expr_stmt|;
name|snapshotTimeRangeTracker
operator|=
operator|new
name|TimeRangeTracker
argument_list|()
expr_stmt|;
name|this
operator|.
name|size
operator|=
operator|new
name|AtomicLong
argument_list|(
name|DEEP_OVERHEAD
argument_list|)
expr_stmt|;
block|}
name|void
name|dump
parameter_list|()
block|{
for|for
control|(
name|KeyValue
name|kv
range|:
name|this
operator|.
name|kvset
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|kv
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|KeyValue
name|kv
range|:
name|this
operator|.
name|snapshot
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|kv
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Creates a snapshot of the current memstore.    * Snapshot must be cleared by call to {@link #clearSnapshot(SortedSet<KeyValue>)}    * To get the snapshot made by this method, use {@link #getSnapshot()}    */
name|void
name|snapshot
parameter_list|()
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// If snapshot currently has entries, then flusher failed or didn't call
comment|// cleanup.  Log a warning.
if|if
condition|(
operator|!
name|this
operator|.
name|snapshot
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Snapshot called again without clearing previous. "
operator|+
literal|"Doing nothing. Another ongoing flush or did we fail last attempt?"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|kvset
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|this
operator|.
name|snapshot
operator|=
name|this
operator|.
name|kvset
expr_stmt|;
name|this
operator|.
name|kvset
operator|=
operator|new
name|KeyValueSkipListSet
argument_list|(
name|this
operator|.
name|comparator
argument_list|)
expr_stmt|;
name|this
operator|.
name|snapshotTimeRangeTracker
operator|=
name|this
operator|.
name|timeRangeTracker
expr_stmt|;
name|this
operator|.
name|timeRangeTracker
operator|=
operator|new
name|TimeRangeTracker
argument_list|()
expr_stmt|;
comment|// Reset heap to not include any keys
name|this
operator|.
name|size
operator|.
name|set
argument_list|(
name|DEEP_OVERHEAD
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Return the current snapshot.    * Called by flusher to get current snapshot made by a previous    * call to {@link #snapshot()}    * @return Return snapshot.    * @see {@link #snapshot()}    * @see {@link #clearSnapshot(SortedSet<KeyValue>)}    */
name|KeyValueSkipListSet
name|getSnapshot
parameter_list|()
block|{
return|return
name|this
operator|.
name|snapshot
return|;
block|}
comment|/**    * The passed snapshot was successfully persisted; it can be let go.    * @param ss The snapshot to clean out.    * @throws UnexpectedException    * @see {@link #snapshot()}    */
name|void
name|clearSnapshot
parameter_list|(
specifier|final
name|SortedSet
argument_list|<
name|KeyValue
argument_list|>
name|ss
parameter_list|)
throws|throws
name|UnexpectedException
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|this
operator|.
name|snapshot
operator|!=
name|ss
condition|)
block|{
throw|throw
operator|new
name|UnexpectedException
argument_list|(
literal|"Current snapshot is "
operator|+
name|this
operator|.
name|snapshot
operator|+
literal|", was passed "
operator|+
name|ss
argument_list|)
throw|;
block|}
comment|// OK. Passed in snapshot is same as current snapshot.  If not-empty,
comment|// create a new snapshot and let the old one go.
if|if
condition|(
operator|!
name|ss
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|this
operator|.
name|snapshot
operator|=
operator|new
name|KeyValueSkipListSet
argument_list|(
name|this
operator|.
name|comparator
argument_list|)
expr_stmt|;
name|this
operator|.
name|snapshotTimeRangeTracker
operator|=
operator|new
name|TimeRangeTracker
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Write an update    * @param kv    * @return approximate size of the passed key and value.    */
name|long
name|add
parameter_list|(
specifier|final
name|KeyValue
name|kv
parameter_list|)
block|{
name|long
name|s
init|=
operator|-
literal|1
decl_stmt|;
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|s
operator|=
name|heapSizeChange
argument_list|(
name|kv
argument_list|,
name|this
operator|.
name|kvset
operator|.
name|add
argument_list|(
name|kv
argument_list|)
argument_list|)
expr_stmt|;
name|timeRangeTracker
operator|.
name|includeTimestamp
argument_list|(
name|kv
argument_list|)
expr_stmt|;
name|this
operator|.
name|size
operator|.
name|addAndGet
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
comment|/**    * Write a delete    * @param delete    * @return approximate size of the passed key and value.    */
name|long
name|delete
parameter_list|(
specifier|final
name|KeyValue
name|delete
parameter_list|)
block|{
name|long
name|s
init|=
literal|0
decl_stmt|;
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|s
operator|+=
name|heapSizeChange
argument_list|(
name|delete
argument_list|,
name|this
operator|.
name|kvset
operator|.
name|add
argument_list|(
name|delete
argument_list|)
argument_list|)
expr_stmt|;
name|timeRangeTracker
operator|.
name|includeTimestamp
argument_list|(
name|delete
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|size
operator|.
name|addAndGet
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
comment|/**    * @param kv Find the row that comes after this one.  If null, we return the    * first.    * @return Next row or null if none found.    */
name|KeyValue
name|getNextRow
parameter_list|(
specifier|final
name|KeyValue
name|kv
parameter_list|)
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|getLowest
argument_list|(
name|getNextRow
argument_list|(
name|kv
argument_list|,
name|this
operator|.
name|kvset
argument_list|)
argument_list|,
name|getNextRow
argument_list|(
name|kv
argument_list|,
name|this
operator|.
name|snapshot
argument_list|)
argument_list|)
return|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*    * @param a    * @param b    * @return Return lowest of a or b or null if both a and b are null    */
specifier|private
name|KeyValue
name|getLowest
parameter_list|(
specifier|final
name|KeyValue
name|a
parameter_list|,
specifier|final
name|KeyValue
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|==
literal|null
condition|)
block|{
return|return
name|b
return|;
block|}
if|if
condition|(
name|b
operator|==
literal|null
condition|)
block|{
return|return
name|a
return|;
block|}
return|return
name|comparator
operator|.
name|compareRows
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|<=
literal|0
condition|?
name|a
else|:
name|b
return|;
block|}
comment|/*    * @param key Find row that follows this one.  If null, return first.    * @param map Set to look in for a row beyond<code>row</code>.    * @return Next row or null if none found.  If one found, will be a new    * KeyValue -- can be destroyed by subsequent calls to this method.    */
specifier|private
name|KeyValue
name|getNextRow
parameter_list|(
specifier|final
name|KeyValue
name|key
parameter_list|,
specifier|final
name|NavigableSet
argument_list|<
name|KeyValue
argument_list|>
name|set
parameter_list|)
block|{
name|KeyValue
name|result
init|=
literal|null
decl_stmt|;
name|SortedSet
argument_list|<
name|KeyValue
argument_list|>
name|tail
init|=
name|key
operator|==
literal|null
condition|?
name|set
else|:
name|set
operator|.
name|tailSet
argument_list|(
name|key
argument_list|)
decl_stmt|;
comment|// Iterate until we fall into the next row; i.e. move off current row
for|for
control|(
name|KeyValue
name|kv
range|:
name|tail
control|)
block|{
if|if
condition|(
name|comparator
operator|.
name|compareRows
argument_list|(
name|kv
argument_list|,
name|key
argument_list|)
operator|<=
literal|0
condition|)
continue|continue;
comment|// Note: Not suppressing deletes or expired cells.  Needs to be handled
comment|// by higher up functions.
name|result
operator|=
name|kv
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
comment|/**    * @param state column/delete tracking state    */
name|void
name|getRowKeyAtOrBefore
parameter_list|(
specifier|final
name|GetClosestRowBeforeTracker
name|state
parameter_list|)
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|getRowKeyAtOrBefore
argument_list|(
name|kvset
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|getRowKeyAtOrBefore
argument_list|(
name|snapshot
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*    * @param set    * @param state Accumulates deletes and candidates.    */
specifier|private
name|void
name|getRowKeyAtOrBefore
parameter_list|(
specifier|final
name|NavigableSet
argument_list|<
name|KeyValue
argument_list|>
name|set
parameter_list|,
specifier|final
name|GetClosestRowBeforeTracker
name|state
parameter_list|)
block|{
if|if
condition|(
name|set
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|walkForwardInSingleRow
argument_list|(
name|set
argument_list|,
name|state
operator|.
name|getTargetKey
argument_list|()
argument_list|,
name|state
argument_list|)
condition|)
block|{
comment|// Found nothing in row.  Try backing up.
name|getRowKeyBefore
argument_list|(
name|set
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Walk forward in a row from<code>firstOnRow</code>.  Presumption is that    * we have been passed the first possible key on a row.  As we walk forward    * we accumulate deletes until we hit a candidate on the row at which point    * we return.    * @param set    * @param firstOnRow First possible key on this row.    * @param state    * @return True if we found a candidate walking this row.    */
specifier|private
name|boolean
name|walkForwardInSingleRow
parameter_list|(
specifier|final
name|SortedSet
argument_list|<
name|KeyValue
argument_list|>
name|set
parameter_list|,
specifier|final
name|KeyValue
name|firstOnRow
parameter_list|,
specifier|final
name|GetClosestRowBeforeTracker
name|state
parameter_list|)
block|{
name|boolean
name|foundCandidate
init|=
literal|false
decl_stmt|;
name|SortedSet
argument_list|<
name|KeyValue
argument_list|>
name|tail
init|=
name|set
operator|.
name|tailSet
argument_list|(
name|firstOnRow
argument_list|)
decl_stmt|;
if|if
condition|(
name|tail
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|foundCandidate
return|;
for|for
control|(
name|Iterator
argument_list|<
name|KeyValue
argument_list|>
name|i
init|=
name|tail
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|KeyValue
name|kv
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// Did we go beyond the target row? If so break.
if|if
condition|(
name|state
operator|.
name|isTooFar
argument_list|(
name|kv
argument_list|,
name|firstOnRow
argument_list|)
condition|)
break|break;
if|if
condition|(
name|state
operator|.
name|isExpired
argument_list|(
name|kv
argument_list|)
condition|)
block|{
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|// If we added something, this row is a contender. break.
if|if
condition|(
name|state
operator|.
name|handle
argument_list|(
name|kv
argument_list|)
condition|)
block|{
name|foundCandidate
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
return|return
name|foundCandidate
return|;
block|}
comment|/*    * Walk backwards through the passed set a row at a time until we run out of    * set or until we get a candidate.    * @param set    * @param state    */
specifier|private
name|void
name|getRowKeyBefore
parameter_list|(
name|NavigableSet
argument_list|<
name|KeyValue
argument_list|>
name|set
parameter_list|,
specifier|final
name|GetClosestRowBeforeTracker
name|state
parameter_list|)
block|{
name|KeyValue
name|firstOnRow
init|=
name|state
operator|.
name|getTargetKey
argument_list|()
decl_stmt|;
for|for
control|(
name|Member
name|p
init|=
name|memberOfPreviousRow
argument_list|(
name|set
argument_list|,
name|state
argument_list|,
name|firstOnRow
argument_list|)
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|memberOfPreviousRow
argument_list|(
name|p
operator|.
name|set
argument_list|,
name|state
argument_list|,
name|firstOnRow
argument_list|)
control|)
block|{
comment|// Make sure we don't fall out of our table.
if|if
condition|(
operator|!
name|state
operator|.
name|isTargetTable
argument_list|(
name|p
operator|.
name|kv
argument_list|)
condition|)
break|break;
comment|// Stop looking if we've exited the better candidate range.
if|if
condition|(
operator|!
name|state
operator|.
name|isBetterCandidate
argument_list|(
name|p
operator|.
name|kv
argument_list|)
condition|)
break|break;
comment|// Make into firstOnRow
name|firstOnRow
operator|=
operator|new
name|KeyValue
argument_list|(
name|p
operator|.
name|kv
operator|.
name|getRow
argument_list|()
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|)
expr_stmt|;
comment|// If we find something, break;
if|if
condition|(
name|walkForwardInSingleRow
argument_list|(
name|p
operator|.
name|set
argument_list|,
name|firstOnRow
argument_list|,
name|state
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/**    * Given the specs of a column, update it, first by inserting a new record,    * then removing the old one.  Since there is only 1 KeyValue involved, the memstoreTS    * will be set to 0, thus ensuring that they instantly appear to anyone. The underlying    * store will ensure that the insert/delete each are atomic. A scanner/reader will either    * get the new value, or the old value and all readers will eventually only see the new    * value after the old was removed.    *    * @param row    * @param family    * @param qualifier    * @param newValue    * @param now    * @return  Timestamp    */
specifier|public
name|long
name|updateColumnValue
parameter_list|(
name|byte
index|[]
name|row
parameter_list|,
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|long
name|newValue
parameter_list|,
name|long
name|now
parameter_list|)
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|KeyValue
name|firstKv
init|=
name|KeyValue
operator|.
name|createFirstOnRow
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|)
decl_stmt|;
comment|// Is there a KeyValue in 'snapshot' with the same TS? If so, upgrade the timestamp a bit.
name|SortedSet
argument_list|<
name|KeyValue
argument_list|>
name|snSs
init|=
name|snapshot
operator|.
name|tailSet
argument_list|(
name|firstKv
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|snSs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|KeyValue
name|snKv
init|=
name|snSs
operator|.
name|first
argument_list|()
decl_stmt|;
comment|// is there a matching KV in the snapshot?
if|if
condition|(
name|snKv
operator|.
name|matchingRow
argument_list|(
name|firstKv
argument_list|)
operator|&&
name|snKv
operator|.
name|matchingQualifier
argument_list|(
name|firstKv
argument_list|)
condition|)
block|{
if|if
condition|(
name|snKv
operator|.
name|getTimestamp
argument_list|()
operator|==
name|now
condition|)
block|{
comment|// poop,
name|now
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|// logic here: the new ts MUST be at least 'now'. But it could be larger if necessary.
comment|// But the timestamp should also be max(now, mostRecentTsInMemstore)
comment|// so we cant add the new KV w/o knowing what's there already, but we also
comment|// want to take this chance to delete some kvs. So two loops (sad)
name|SortedSet
argument_list|<
name|KeyValue
argument_list|>
name|ss
init|=
name|kvset
operator|.
name|tailSet
argument_list|(
name|firstKv
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|KeyValue
argument_list|>
name|it
init|=
name|ss
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|KeyValue
name|kv
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// if this isnt the row we are interested in, then bail:
if|if
condition|(
operator|!
name|firstKv
operator|.
name|matchingColumn
argument_list|(
name|family
argument_list|,
name|qualifier
argument_list|)
operator|||
operator|!
name|firstKv
operator|.
name|matchingRow
argument_list|(
name|kv
argument_list|)
condition|)
block|{
break|break;
comment|// rows dont match, bail.
block|}
comment|// if the qualifier matches and it's a put, just RM it out of the kvset.
if|if
condition|(
name|firstKv
operator|.
name|matchingQualifier
argument_list|(
name|kv
argument_list|)
condition|)
block|{
comment|// to be extra safe we only remove Puts that have a memstoreTS==0
if|if
condition|(
name|kv
operator|.
name|getType
argument_list|()
operator|==
name|KeyValue
operator|.
name|Type
operator|.
name|Put
operator|.
name|getCode
argument_list|()
condition|)
block|{
name|now
operator|=
name|Math
operator|.
name|max
argument_list|(
name|now
argument_list|,
name|kv
operator|.
name|getTimestamp
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// create or update (upsert) a new KeyValue with
comment|// 'now' and a 0 memstoreTS == immediately visible
return|return
name|upsert
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|KeyValue
index|[]
block|{
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|now
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|newValue
argument_list|)
argument_list|)
block|}
argument_list|)
argument_list|)
return|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Update or insert the specified KeyValues.    *<p>    * For each KeyValue, insert into MemStore.  This will atomically upsert the    * value for that row/family/qualifier.  If a KeyValue did already exist,    * it will then be removed.    *<p>    * Currently the memstoreTS is kept at 0 so as each insert happens, it will    * be immediately visible.  May want to change this so it is atomic across    * all KeyValues.    *<p>    * This is called under row lock, so Get operations will still see updates    * atomically.  Scans will only see each KeyValue update as atomic.    *    * @param kvs    * @return change in memstore size    */
specifier|public
name|long
name|upsert
parameter_list|(
name|List
argument_list|<
name|KeyValue
argument_list|>
name|kvs
parameter_list|)
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|long
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|KeyValue
name|kv
range|:
name|kvs
control|)
block|{
name|kv
operator|.
name|setMemstoreTS
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|size
operator|+=
name|upsert
argument_list|(
name|kv
argument_list|)
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Inserts the specified KeyValue into MemStore and deletes any existing    * versions of the same row/family/qualifier as the specified KeyValue.    *<p>    * First, the specified KeyValue is inserted into the Memstore.    *<p>    * If there are any existing KeyValues in this MemStore with the same row,    * family, and qualifier, they are removed.    * @param kv    * @return change in size of MemStore    */
specifier|private
name|long
name|upsert
parameter_list|(
name|KeyValue
name|kv
parameter_list|)
block|{
comment|// Add the KeyValue to the MemStore
name|long
name|addedSize
init|=
name|add
argument_list|(
name|kv
argument_list|)
decl_stmt|;
comment|// Iterate the KeyValues after the one just inserted, cleaning up any
comment|// other KeyValues with the same row/family/qualifier
name|SortedSet
argument_list|<
name|KeyValue
argument_list|>
name|ss
init|=
name|kvset
operator|.
name|tailSet
argument_list|(
name|kv
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|KeyValue
argument_list|>
name|it
init|=
name|ss
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|KeyValue
name|cur
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|kv
operator|==
name|cur
condition|)
block|{
comment|// ignore the one just put in
continue|continue;
block|}
comment|// if this isn't the row we are interested in, then bail
if|if
condition|(
operator|!
name|kv
operator|.
name|matchingRow
argument_list|(
name|cur
argument_list|)
condition|)
block|{
break|break;
block|}
comment|// if the qualifier matches and it's a put, remove it
if|if
condition|(
name|kv
operator|.
name|matchingQualifier
argument_list|(
name|cur
argument_list|)
condition|)
block|{
comment|// to be extra safe we only remove Puts that have a memstoreTS==0
if|if
condition|(
name|kv
operator|.
name|getType
argument_list|()
operator|==
name|KeyValue
operator|.
name|Type
operator|.
name|Put
operator|.
name|getCode
argument_list|()
operator|&&
name|kv
operator|.
name|getMemstoreTS
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// false means there was a change, so give us the size.
name|addedSize
operator|-=
name|heapSizeChange
argument_list|(
name|kv
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// past the column, done
break|break;
block|}
block|}
return|return
name|addedSize
return|;
block|}
comment|/*    * Immutable data structure to hold member found in set and the set it was    * found in.  Include set because it is carrying context.    */
specifier|private
specifier|static
class|class
name|Member
block|{
specifier|final
name|KeyValue
name|kv
decl_stmt|;
specifier|final
name|NavigableSet
argument_list|<
name|KeyValue
argument_list|>
name|set
decl_stmt|;
name|Member
parameter_list|(
specifier|final
name|NavigableSet
argument_list|<
name|KeyValue
argument_list|>
name|s
parameter_list|,
specifier|final
name|KeyValue
name|kv
parameter_list|)
block|{
name|this
operator|.
name|kv
operator|=
name|kv
expr_stmt|;
name|this
operator|.
name|set
operator|=
name|s
expr_stmt|;
block|}
block|}
comment|/*    * @param set Set to walk back in.  Pass a first in row or we'll return    * same row (loop).    * @param state Utility and context.    * @param firstOnRow First item on the row after the one we want to find a    * member in.    * @return Null or member of row previous to<code>firstOnRow</code>    */
specifier|private
name|Member
name|memberOfPreviousRow
parameter_list|(
name|NavigableSet
argument_list|<
name|KeyValue
argument_list|>
name|set
parameter_list|,
specifier|final
name|GetClosestRowBeforeTracker
name|state
parameter_list|,
specifier|final
name|KeyValue
name|firstOnRow
parameter_list|)
block|{
name|NavigableSet
argument_list|<
name|KeyValue
argument_list|>
name|head
init|=
name|set
operator|.
name|headSet
argument_list|(
name|firstOnRow
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|head
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|null
return|;
for|for
control|(
name|Iterator
argument_list|<
name|KeyValue
argument_list|>
name|i
init|=
name|head
operator|.
name|descendingIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|KeyValue
name|found
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
operator|.
name|isExpired
argument_list|(
name|found
argument_list|)
condition|)
block|{
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
continue|continue;
block|}
return|return
operator|new
name|Member
argument_list|(
name|head
argument_list|,
name|found
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * @return scanner on memstore and snapshot in this order.    */
name|List
argument_list|<
name|KeyValueScanner
argument_list|>
name|getScanners
parameter_list|()
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|Collections
operator|.
expr|<
name|KeyValueScanner
operator|>
name|singletonList
argument_list|(
operator|new
name|MemStoreScanner
argument_list|()
argument_list|)
return|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Check if this memstore may contain the required keys    * @param scan    * @return False if the key definitely does not exist in this Memstore    */
specifier|public
name|boolean
name|shouldSeek
parameter_list|(
name|Scan
name|scan
parameter_list|)
block|{
return|return
name|timeRangeTracker
operator|.
name|includesTimeRange
argument_list|(
name|scan
operator|.
name|getTimeRange
argument_list|()
argument_list|)
operator|||
name|snapshotTimeRangeTracker
operator|.
name|includesTimeRange
argument_list|(
name|scan
operator|.
name|getTimeRange
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|TimeRangeTracker
name|getSnapshotTimeRangeTracker
parameter_list|()
block|{
return|return
name|this
operator|.
name|snapshotTimeRangeTracker
return|;
block|}
comment|/*    * MemStoreScanner implements the KeyValueScanner.    * It lets the caller scan the contents of a memstore -- both current    * map and snapshot.    * This behaves as if it were a real scanner but does not maintain position.    */
specifier|protected
class|class
name|MemStoreScanner
implements|implements
name|KeyValueScanner
block|{
comment|// Next row information for either kvset or snapshot
specifier|private
name|KeyValue
name|kvsetNextRow
init|=
literal|null
decl_stmt|;
specifier|private
name|KeyValue
name|snapshotNextRow
init|=
literal|null
decl_stmt|;
comment|// iterator based scanning.
name|Iterator
argument_list|<
name|KeyValue
argument_list|>
name|kvsetIt
decl_stmt|;
name|Iterator
argument_list|<
name|KeyValue
argument_list|>
name|snapshotIt
decl_stmt|;
comment|/*     Some notes...       So memstorescanner is fixed at creation time. this includes pointers/iterators into     existing kvset/snapshot.  during a snapshot creation, the kvset is null, and the     snapshot is moved.  since kvset is null there is no point on reseeking on both,       we can save us the trouble. During the snapshot->hfile transition, the memstore       scanner is re-created by StoreScanner#updateReaders().  StoreScanner should       potentially do something smarter by adjusting the existing memstore scanner.        But there is a greater problem here, that being once a scanner has progressed       during a snapshot scenario, we currently iterate past the kvset then 'finish' up.       if a scan lasts a little while, there is a chance for new entries in kvset to       become available but we will never see them.  This needs to be handled at the       StoreScanner level with coordination with MemStoreScanner.      */
name|MemStoreScanner
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
comment|//DebugPrint.println(" MS new@" + hashCode());
block|}
specifier|protected
name|KeyValue
name|getNext
parameter_list|(
name|Iterator
argument_list|<
name|KeyValue
argument_list|>
name|it
parameter_list|)
block|{
name|KeyValue
name|ret
init|=
literal|null
decl_stmt|;
name|long
name|readPoint
init|=
name|ReadWriteConsistencyControl
operator|.
name|getThreadReadPoint
argument_list|()
decl_stmt|;
comment|//DebugPrint.println( " MS@" + hashCode() + ": threadpoint = " + readPoint);
while|while
condition|(
name|ret
operator|==
literal|null
operator|&&
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|KeyValue
name|v
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|.
name|getMemstoreTS
argument_list|()
operator|<=
name|readPoint
condition|)
block|{
comment|// keep it.
name|ret
operator|=
name|v
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
specifier|public
specifier|synchronized
name|boolean
name|seek
parameter_list|(
name|KeyValue
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
name|close
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// kvset and snapshot will never be empty.
comment|// if tailSet cant find anything, SS is empty (not null).
name|SortedSet
argument_list|<
name|KeyValue
argument_list|>
name|kvTail
init|=
name|kvset
operator|.
name|tailSet
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|SortedSet
argument_list|<
name|KeyValue
argument_list|>
name|snapshotTail
init|=
name|snapshot
operator|.
name|tailSet
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|kvsetIt
operator|=
name|kvTail
operator|.
name|iterator
argument_list|()
expr_stmt|;
name|snapshotIt
operator|=
name|snapshotTail
operator|.
name|iterator
argument_list|()
expr_stmt|;
name|kvsetNextRow
operator|=
name|getNext
argument_list|(
name|kvsetIt
argument_list|)
expr_stmt|;
name|snapshotNextRow
operator|=
name|getNext
argument_list|(
name|snapshotIt
argument_list|)
expr_stmt|;
comment|//long readPoint = ReadWriteConsistencyControl.getThreadReadPoint();
comment|//DebugPrint.println( " MS@" + hashCode() + " kvset seek: " + kvsetNextRow + " with size = " +
comment|//    kvset.size() + " threadread = " + readPoint);
comment|//DebugPrint.println( " MS@" + hashCode() + " snapshot seek: " + snapshotNextRow + " with size = " +
comment|//    snapshot.size() + " threadread = " + readPoint);
name|KeyValue
name|lowest
init|=
name|getLowest
argument_list|()
decl_stmt|;
comment|// has data := (lowest != null)
return|return
name|lowest
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|reseek
parameter_list|(
name|KeyValue
name|key
parameter_list|)
block|{
while|while
condition|(
name|kvsetNextRow
operator|!=
literal|null
operator|&&
name|comparator
operator|.
name|compare
argument_list|(
name|kvsetNextRow
argument_list|,
name|key
argument_list|)
operator|<
literal|0
condition|)
block|{
name|kvsetNextRow
operator|=
name|getNext
argument_list|(
name|kvsetIt
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|snapshotNextRow
operator|!=
literal|null
operator|&&
name|comparator
operator|.
name|compare
argument_list|(
name|snapshotNextRow
argument_list|,
name|key
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snapshotNextRow
operator|=
name|getNext
argument_list|(
name|snapshotIt
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|kvsetNextRow
operator|!=
literal|null
operator|||
name|snapshotNextRow
operator|!=
literal|null
operator|)
return|;
block|}
specifier|public
specifier|synchronized
name|KeyValue
name|peek
parameter_list|()
block|{
comment|//DebugPrint.println(" MS@" + hashCode() + " peek = " + getLowest());
return|return
name|getLowest
argument_list|()
return|;
block|}
specifier|public
specifier|synchronized
name|KeyValue
name|next
parameter_list|()
block|{
name|KeyValue
name|theNext
init|=
name|getLowest
argument_list|()
decl_stmt|;
if|if
condition|(
name|theNext
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Advance one of the iterators
if|if
condition|(
name|theNext
operator|==
name|kvsetNextRow
condition|)
block|{
name|kvsetNextRow
operator|=
name|getNext
argument_list|(
name|kvsetIt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snapshotNextRow
operator|=
name|getNext
argument_list|(
name|snapshotIt
argument_list|)
expr_stmt|;
block|}
comment|//long readpoint = ReadWriteConsistencyControl.getThreadReadPoint();
comment|//DebugPrint.println(" MS@" + hashCode() + " next: " + theNext + " next_next: " +
comment|//    getLowest() + " threadpoint=" + readpoint);
return|return
name|theNext
return|;
block|}
specifier|protected
name|KeyValue
name|getLowest
parameter_list|()
block|{
return|return
name|getLower
argument_list|(
name|kvsetNextRow
argument_list|,
name|snapshotNextRow
argument_list|)
return|;
block|}
comment|/*      * Returns the lower of the two key values, or null if they are both null.      * This uses comparator.compare() to compare the KeyValue using the memstore      * comparator.      */
specifier|protected
name|KeyValue
name|getLower
parameter_list|(
name|KeyValue
name|first
parameter_list|,
name|KeyValue
name|second
parameter_list|)
block|{
if|if
condition|(
name|first
operator|==
literal|null
operator|&&
name|second
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|first
operator|!=
literal|null
operator|&&
name|second
operator|!=
literal|null
condition|)
block|{
name|int
name|compare
init|=
name|comparator
operator|.
name|compare
argument_list|(
name|first
argument_list|,
name|second
argument_list|)
decl_stmt|;
return|return
operator|(
name|compare
operator|<=
literal|0
condition|?
name|first
else|:
name|second
operator|)
return|;
block|}
return|return
operator|(
name|first
operator|!=
literal|null
condition|?
name|first
else|:
name|second
operator|)
return|;
block|}
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
block|{
name|this
operator|.
name|kvsetNextRow
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|snapshotNextRow
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|kvsetIt
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|snapshotIt
operator|=
literal|null
expr_stmt|;
block|}
comment|/**      * MemStoreScanner returns max value as sequence id because it will      * always have the latest data among all files.      */
annotation|@
name|Override
specifier|public
name|long
name|getSequenceID
parameter_list|()
block|{
return|return
name|Long
operator|.
name|MAX_VALUE
return|;
block|}
block|}
specifier|public
specifier|final
specifier|static
name|long
name|FIXED_OVERHEAD
init|=
name|ClassSize
operator|.
name|align
argument_list|(
name|ClassSize
operator|.
name|OBJECT
operator|+
operator|(
literal|9
operator|*
name|ClassSize
operator|.
name|REFERENCE
operator|)
argument_list|)
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|long
name|DEEP_OVERHEAD
init|=
name|ClassSize
operator|.
name|align
argument_list|(
name|FIXED_OVERHEAD
operator|+
name|ClassSize
operator|.
name|REENTRANT_LOCK
operator|+
name|ClassSize
operator|.
name|ATOMIC_LONG
operator|+
name|ClassSize
operator|.
name|COPYONWRITE_ARRAYSET
operator|+
name|ClassSize
operator|.
name|COPYONWRITE_ARRAYLIST
operator|+
operator|(
literal|2
operator|*
name|ClassSize
operator|.
name|CONCURRENT_SKIPLISTMAP
operator|)
argument_list|)
decl_stmt|;
comment|/*    * Calculate how the MemStore size has changed.  Includes overhead of the    * backing Map.    * @param kv    * @param notpresent True if the kv was NOT present in the set.    * @return Size    */
name|long
name|heapSizeChange
parameter_list|(
specifier|final
name|KeyValue
name|kv
parameter_list|,
specifier|final
name|boolean
name|notpresent
parameter_list|)
block|{
return|return
name|notpresent
condition|?
name|ClassSize
operator|.
name|align
argument_list|(
name|ClassSize
operator|.
name|CONCURRENT_SKIPLISTMAP_ENTRY
operator|+
name|kv
operator|.
name|heapSize
argument_list|()
argument_list|)
else|:
literal|0
return|;
block|}
comment|/**    * Get the entire heap usage for this MemStore not including keys in the    * snapshot.    */
annotation|@
name|Override
specifier|public
name|long
name|heapSize
parameter_list|()
block|{
return|return
name|size
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * Get the heap usage of KVs in this MemStore.    */
specifier|public
name|long
name|keySize
parameter_list|()
block|{
return|return
name|heapSize
argument_list|()
operator|-
name|DEEP_OVERHEAD
return|;
block|}
comment|/**    * Code to help figure if our approximation of object heap sizes is close    * enough.  See hbase-900.  Fills memstores then waits so user can heap    * dump and bring up resultant hprof in something like jprofiler which    * allows you get 'deep size' on objects.    * @param args main args    */
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|RuntimeMXBean
name|runtime
init|=
name|ManagementFactory
operator|.
name|getRuntimeMXBean
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"vmName="
operator|+
name|runtime
operator|.
name|getVmName
argument_list|()
operator|+
literal|", vmVendor="
operator|+
name|runtime
operator|.
name|getVmVendor
argument_list|()
operator|+
literal|", vmVersion="
operator|+
name|runtime
operator|.
name|getVmVersion
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"vmInputArguments="
operator|+
name|runtime
operator|.
name|getInputArguments
argument_list|()
argument_list|)
expr_stmt|;
name|MemStore
name|memstore1
init|=
operator|new
name|MemStore
argument_list|()
decl_stmt|;
comment|// TODO: x32 vs x64
name|long
name|size
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|count
init|=
literal|10000
decl_stmt|;
name|byte
index|[]
name|fam
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"col"
argument_list|)
decl_stmt|;
name|byte
index|[]
name|qf
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"umn"
argument_list|)
decl_stmt|;
name|byte
index|[]
name|empty
init|=
operator|new
name|byte
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|// Give each its own ts
name|size
operator|+=
name|memstore1
operator|.
name|add
argument_list|(
operator|new
name|KeyValue
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|i
argument_list|)
argument_list|,
name|fam
argument_list|,
name|qf
argument_list|,
name|i
argument_list|,
name|empty
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"memstore1 estimated size="
operator|+
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|+=
name|memstore1
operator|.
name|add
argument_list|(
operator|new
name|KeyValue
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|i
argument_list|)
argument_list|,
name|fam
argument_list|,
name|qf
argument_list|,
name|i
argument_list|,
name|empty
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"memstore1 estimated size (2nd loading of same data)="
operator|+
name|size
argument_list|)
expr_stmt|;
comment|// Make a variably sized memstore.
name|MemStore
name|memstore2
init|=
operator|new
name|MemStore
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|+=
name|memstore2
operator|.
name|add
argument_list|(
operator|new
name|KeyValue
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|i
argument_list|)
argument_list|,
name|fam
argument_list|,
name|qf
argument_list|,
name|i
argument_list|,
operator|new
name|byte
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"memstore2 estimated size="
operator|+
name|size
argument_list|)
expr_stmt|;
specifier|final
name|int
name|seconds
init|=
literal|30
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting "
operator|+
name|seconds
operator|+
literal|" seconds while heap dump is taken"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|seconds
condition|;
name|i
operator|++
control|)
block|{
comment|// Thread.sleep(1000);
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Exiting."
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

