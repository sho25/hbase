begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements. See the NOTICE file distributed with this  * work for additional information regarding copyright ownership. The ASF  * licenses this file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the  * License for the specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|metrics
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|mutable
operator|.
name|MutableDouble
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|BlockType
operator|.
name|BlockCategory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_comment
comment|/**  * A names in a given column family or a (table, column  * family) combination. The following "dimensions" are supported:  *<ul>  *<li>Table name (optional; enabled based on configuration)</li>  *<li>Per-column family vs. aggregated. The aggregated mode is only supported  * when table name is not included.</li>  *<li>Block category (data, index, bloom filter, etc.)</li>  *<li>Whether the request is part of a compaction</li>  *<li>Metric type (read time, block read count, cache hits/misses, etc.)</li>  *</ul>  *<p>  * An instance of this class does not store any metric values. It just allows  * to determine the correct metric name for each combination of the above  * dimensions.  *<p>  *<table>  *<tr>  *<th rowspan="2">Metric key</th>  *<th colspan="2">Per-table metrics conf setting</th>  *<th rowspan="2">Description</th>  *</tr>  *<tr>  *<th>On</th>  *<th>Off</th>  *</th>  *<tr>  *<td> tbl.T.cf.CF.M</td><td> Include</td><td> Skip</td>  *<td> A specific column family of a specific table</td>  *</tr>  *<tr>  *<td> tbl.T.M</td><td> Skip</td><td> Skip</td>  *<td> All column families in the given table</td>  *</tr>  *<tr>  *<td> cf.CF.M</td><td> Skip</td><td> Include</td>  *<td> A specific column family in all tables</td>  *</tr>  *<tr>  *<td> M</td><td> Include</td><td> Include</td>  *<td> All column families in all tables</td>  *</tr>  *</table>  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|SchemaMetrics
block|{
specifier|public
interface|interface
name|SchemaAware
block|{
specifier|public
name|String
name|getTableName
parameter_list|()
function_decl|;
specifier|public
name|String
name|getColumnFamilyName
parameter_list|()
function_decl|;
specifier|public
name|SchemaMetrics
name|getSchemaMetrics
parameter_list|()
function_decl|;
block|}
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|SchemaMetrics
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
enum|enum
name|BlockMetricType
block|{
comment|// Metric configuration: compactionAware, timeVarying
name|READ_TIME
argument_list|(
literal|"Read"
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
block|,
name|READ_COUNT
argument_list|(
literal|"BlockReadCnt"
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
block|,
name|CACHE_HIT
argument_list|(
literal|"BlockReadCacheHitCnt"
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
block|,
name|CACHE_MISS
argument_list|(
literal|"BlockReadCacheMissCnt"
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
block|,
name|CACHE_SIZE
argument_list|(
literal|"blockCacheSize"
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
block|,
name|CACHED
argument_list|(
literal|"blockCacheNumCached"
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
block|,
name|EVICTED
argument_list|(
literal|"blockCacheNumEvicted"
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
block|;
specifier|private
specifier|final
name|String
name|metricStr
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|compactionAware
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|timeVarying
decl_stmt|;
name|BlockMetricType
parameter_list|(
name|String
name|metricStr
parameter_list|,
name|boolean
name|compactionAware
parameter_list|,
name|boolean
name|timeVarying
parameter_list|)
block|{
name|this
operator|.
name|metricStr
operator|=
name|metricStr
expr_stmt|;
name|this
operator|.
name|compactionAware
operator|=
name|compactionAware
expr_stmt|;
name|this
operator|.
name|timeVarying
operator|=
name|timeVarying
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|metricStr
return|;
block|}
specifier|private
specifier|static
specifier|final
name|String
name|BLOCK_METRIC_TYPE_RE
decl_stmt|;
static|static
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|BlockMetricType
name|bmt
range|:
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|"|"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|bmt
argument_list|)
expr_stmt|;
block|}
name|BLOCK_METRIC_TYPE_RE
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
block|}
empty_stmt|;
specifier|public
specifier|static
enum|enum
name|StoreMetricType
block|{
name|STORE_FILE_COUNT
argument_list|(
literal|"storeFileCount"
argument_list|)
block|,
name|STORE_FILE_INDEX_SIZE
argument_list|(
literal|"storeFileIndexSizeMB"
argument_list|)
block|,
name|STORE_FILE_SIZE_MB
argument_list|(
literal|"storeFileSizeMB"
argument_list|)
block|,
name|STATIC_BLOOM_SIZE_KB
argument_list|(
literal|"staticBloomSizeKB"
argument_list|)
block|,
name|MEMSTORE_SIZE_MB
argument_list|(
literal|"memstoreSizeMB"
argument_list|)
block|,
name|STATIC_INDEX_SIZE_KB
argument_list|(
literal|"staticIndexSizeKB"
argument_list|)
block|,
name|FLUSH_SIZE
argument_list|(
literal|"flushSize"
argument_list|)
block|;
specifier|private
specifier|final
name|String
name|metricStr
decl_stmt|;
name|StoreMetricType
parameter_list|(
name|String
name|metricStr
parameter_list|)
block|{
name|this
operator|.
name|metricStr
operator|=
name|metricStr
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|metricStr
return|;
block|}
block|}
empty_stmt|;
comment|// Constants
comment|/**    * A string used when column family or table name is unknown, and in some    * unit tests. This should not normally show up in metric names but if it    * does it is better than creating a silent discrepancy in total vs.    * per-CF/table metrics.    */
specifier|public
specifier|static
specifier|final
name|String
name|UNKNOWN
init|=
literal|"__unknown"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|TABLE_PREFIX
init|=
literal|"tbl."
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|CF_PREFIX
init|=
literal|"cf."
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|BLOCK_TYPE_PREFIX
init|=
literal|"bt."
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|REGION_PREFIX
init|=
literal|"region."
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|CF_UNKNOWN_PREFIX
init|=
name|CF_PREFIX
operator|+
name|UNKNOWN
operator|+
literal|"."
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|CF_BAD_FAMILY_PREFIX
init|=
name|CF_PREFIX
operator|+
literal|"__badfamily."
decl_stmt|;
comment|/** Use for readability when obtaining non-compaction counters */
specifier|public
specifier|static
specifier|final
name|boolean
name|NO_COMPACTION
init|=
literal|false
decl_stmt|;
comment|/**    * A special schema metric value that means "all tables aggregated" or    * "all column families aggregated" when used as a table name or a column    * family name.    */
specifier|public
specifier|static
specifier|final
name|String
name|TOTAL_KEY
init|=
literal|""
decl_stmt|;
comment|/**    * Special handling for meta-block-specific metrics for    * backwards-compatibility.    */
specifier|private
specifier|static
specifier|final
name|String
name|META_BLOCK_CATEGORY_STR
init|=
literal|"Meta"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|NUM_BLOCK_CATEGORIES
init|=
name|BlockCategory
operator|.
name|values
argument_list|()
operator|.
name|length
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|NUM_METRIC_TYPES
init|=
name|BlockMetricType
operator|.
name|values
argument_list|()
operator|.
name|length
decl_stmt|;
specifier|static
specifier|final
name|boolean
index|[]
name|BOOL_VALUES
init|=
operator|new
name|boolean
index|[]
block|{
literal|false
block|,
literal|true
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|NUM_BLOCK_METRICS
init|=
name|NUM_BLOCK_CATEGORIES
operator|*
comment|// blockCategory
name|BOOL_VALUES
operator|.
name|length
operator|*
comment|// isCompaction
name|NUM_METRIC_TYPES
decl_stmt|;
comment|// metricType
specifier|private
specifier|static
specifier|final
name|int
name|NUM_STORE_METRIC_TYPES
init|=
name|StoreMetricType
operator|.
name|values
argument_list|()
operator|.
name|length
decl_stmt|;
comment|/** Conf key controlling whether we include table name in metric names */
specifier|private
specifier|static
specifier|final
name|String
name|SHOW_TABLE_NAME_CONF_KEY
init|=
literal|"hbase.metrics.showTableName"
decl_stmt|;
comment|/** We use this when too many column families are involved in a request. */
specifier|private
specifier|static
specifier|final
name|String
name|MORE_CFS_OMITTED_STR
init|=
literal|"__more"
decl_stmt|;
comment|/**    * Maximum length of a metric name prefix. Used when constructing metric    * names from a set of column families participating in a request.    */
specifier|private
specifier|static
specifier|final
name|int
name|MAX_METRIC_PREFIX_LENGTH
init|=
literal|256
operator|-
name|MORE_CFS_OMITTED_STR
operator|.
name|length
argument_list|()
decl_stmt|;
comment|// Global variables
comment|/**    * Maps a string key consisting of table name and column family name, with    * table name optionally replaced with {@link #TOTAL_KEY} if per-table    * metrics are disabled, to an instance of this class.    */
specifier|private
specifier|static
specifier|final
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|SchemaMetrics
argument_list|>
name|tableAndFamilyToMetrics
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|SchemaMetrics
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Metrics for all tables and column families. */
comment|// This has to be initialized after cfToMetrics.
specifier|public
specifier|static
specifier|final
name|SchemaMetrics
name|ALL_SCHEMA_METRICS
init|=
name|getInstance
argument_list|(
name|TOTAL_KEY
argument_list|,
name|TOTAL_KEY
argument_list|)
decl_stmt|;
comment|/**    * Whether to include table name in metric names. If this is null, it has not    * been initialized. This is a global instance, but we also have a copy of it    * per a {@link SchemaMetrics} object to avoid synchronization overhead.    */
specifier|private
specifier|static
specifier|volatile
name|Boolean
name|useTableNameGlobally
decl_stmt|;
comment|/** Whether we logged a message about configuration inconsistency */
specifier|private
specifier|static
specifier|volatile
name|boolean
name|loggedConfInconsistency
decl_stmt|;
comment|// Instance variables
specifier|private
specifier|final
name|String
index|[]
name|blockMetricNames
init|=
operator|new
name|String
index|[
name|NUM_BLOCK_METRICS
index|]
decl_stmt|;
specifier|private
specifier|final
name|boolean
index|[]
name|blockMetricTimeVarying
init|=
operator|new
name|boolean
index|[
name|NUM_BLOCK_METRICS
index|]
decl_stmt|;
specifier|private
specifier|final
name|String
index|[]
name|bloomMetricNames
init|=
operator|new
name|String
index|[
literal|2
index|]
decl_stmt|;
specifier|private
specifier|final
name|String
index|[]
name|storeMetricNames
init|=
operator|new
name|String
index|[
name|NUM_STORE_METRIC_TYPES
index|]
decl_stmt|;
specifier|private
specifier|final
name|String
index|[]
name|storeMetricNamesMax
init|=
operator|new
name|String
index|[
name|NUM_STORE_METRIC_TYPES
index|]
decl_stmt|;
specifier|private
name|SchemaMetrics
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|,
specifier|final
name|String
name|cfName
parameter_list|)
block|{
name|String
name|metricPrefix
init|=
name|SchemaMetrics
operator|.
name|generateSchemaMetricsPrefix
argument_list|(
name|tableName
argument_list|,
name|cfName
argument_list|)
decl_stmt|;
for|for
control|(
name|BlockCategory
name|blockCategory
range|:
name|BlockCategory
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|boolean
name|isCompaction
range|:
name|BOOL_VALUES
control|)
block|{
for|for
control|(
name|BlockMetricType
name|metricType
range|:
name|BlockMetricType
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|metricType
operator|.
name|compactionAware
operator|&&
name|isCompaction
condition|)
block|{
continue|continue;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|metricPrefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|blockCategory
operator|!=
name|BlockCategory
operator|.
name|ALL_CATEGORIES
operator|&&
name|blockCategory
operator|!=
name|BlockCategory
operator|.
name|META
condition|)
block|{
name|String
name|categoryStr
init|=
name|blockCategory
operator|.
name|toString
argument_list|()
decl_stmt|;
name|categoryStr
operator|=
name|categoryStr
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|+
name|categoryStr
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|BLOCK_TYPE_PREFIX
operator|+
name|categoryStr
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|metricType
operator|.
name|compactionAware
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|isCompaction
condition|?
literal|"compaction"
else|:
literal|"fs"
argument_list|)
expr_stmt|;
block|}
comment|// A special-case for meta blocks for backwards-compatibility.
if|if
condition|(
name|blockCategory
operator|==
name|BlockCategory
operator|.
name|META
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|META_BLOCK_CATEGORY_STR
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|metricType
argument_list|)
expr_stmt|;
name|int
name|i
init|=
name|getBlockMetricIndex
argument_list|(
name|blockCategory
argument_list|,
name|isCompaction
argument_list|,
name|metricType
argument_list|)
decl_stmt|;
name|blockMetricNames
index|[
name|i
index|]
operator|=
name|sb
operator|.
name|toString
argument_list|()
operator|.
name|intern
argument_list|()
expr_stmt|;
name|blockMetricTimeVarying
index|[
name|i
index|]
operator|=
name|metricType
operator|.
name|timeVarying
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|boolean
name|isInBloom
range|:
name|BOOL_VALUES
control|)
block|{
name|bloomMetricNames
index|[
name|isInBloom
condition|?
literal|1
else|:
literal|0
index|]
operator|=
name|metricPrefix
operator|+
operator|(
name|isInBloom
condition|?
literal|"keyMaybeInBloomCnt"
else|:
literal|"keyNotInBloomCnt"
operator|)
expr_stmt|;
block|}
for|for
control|(
name|StoreMetricType
name|storeMetric
range|:
name|StoreMetricType
operator|.
name|values
argument_list|()
control|)
block|{
name|String
name|coreName
init|=
name|metricPrefix
operator|+
name|storeMetric
operator|.
name|toString
argument_list|()
decl_stmt|;
name|storeMetricNames
index|[
name|storeMetric
operator|.
name|ordinal
argument_list|()
index|]
operator|=
name|coreName
expr_stmt|;
name|storeMetricNamesMax
index|[
name|storeMetric
operator|.
name|ordinal
argument_list|()
index|]
operator|=
name|coreName
operator|+
literal|".max"
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
specifier|final
name|String
name|METRIC_GETSIZE
init|=
literal|"getsize"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|METRIC_NEXTSIZE
init|=
literal|"nextsize"
decl_stmt|;
comment|/**    * Returns a {@link SchemaMetrics} object for the given table and column    * family, instantiating it if necessary.    *    * @param tableName table name (null is interpreted as "unknown"). This is    *          ignored    * @param cfName column family name (null is interpreted as "unknown")    */
specifier|public
specifier|static
name|SchemaMetrics
name|getInstance
parameter_list|(
name|String
name|tableName
parameter_list|,
name|String
name|cfName
parameter_list|)
block|{
if|if
condition|(
name|tableName
operator|==
literal|null
condition|)
block|{
name|tableName
operator|=
name|UNKNOWN
expr_stmt|;
block|}
if|if
condition|(
name|cfName
operator|==
literal|null
condition|)
block|{
name|cfName
operator|=
name|UNKNOWN
expr_stmt|;
block|}
name|tableName
operator|=
name|getEffectiveTableName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
specifier|final
name|String
name|instanceKey
init|=
name|tableName
operator|+
literal|"\t"
operator|+
name|cfName
decl_stmt|;
name|SchemaMetrics
name|schemaMetrics
init|=
name|tableAndFamilyToMetrics
operator|.
name|get
argument_list|(
name|instanceKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|schemaMetrics
operator|!=
literal|null
condition|)
block|{
return|return
name|schemaMetrics
return|;
block|}
name|schemaMetrics
operator|=
operator|new
name|SchemaMetrics
argument_list|(
name|tableName
argument_list|,
name|cfName
argument_list|)
expr_stmt|;
name|SchemaMetrics
name|existingMetrics
init|=
name|tableAndFamilyToMetrics
operator|.
name|putIfAbsent
argument_list|(
name|instanceKey
argument_list|,
name|schemaMetrics
argument_list|)
decl_stmt|;
return|return
name|existingMetrics
operator|!=
literal|null
condition|?
name|existingMetrics
else|:
name|schemaMetrics
return|;
block|}
specifier|private
specifier|static
specifier|final
name|int
name|getBlockMetricIndex
parameter_list|(
name|BlockCategory
name|blockCategory
parameter_list|,
name|boolean
name|isCompaction
parameter_list|,
name|BlockMetricType
name|metricType
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|i
operator|=
name|i
operator|*
name|NUM_BLOCK_CATEGORIES
operator|+
name|blockCategory
operator|.
name|ordinal
argument_list|()
expr_stmt|;
name|i
operator|=
name|i
operator|*
name|BOOL_VALUES
operator|.
name|length
operator|+
operator|(
name|isCompaction
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|i
operator|=
name|i
operator|*
name|NUM_METRIC_TYPES
operator|+
name|metricType
operator|.
name|ordinal
argument_list|()
expr_stmt|;
return|return
name|i
return|;
block|}
specifier|public
name|String
name|getBlockMetricName
parameter_list|(
name|BlockCategory
name|blockCategory
parameter_list|,
name|boolean
name|isCompaction
parameter_list|,
name|BlockMetricType
name|metricType
parameter_list|)
block|{
if|if
condition|(
name|isCompaction
operator|&&
operator|!
name|metricType
operator|.
name|compactionAware
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"isCompaction cannot be true for "
operator|+
name|metricType
argument_list|)
throw|;
block|}
return|return
name|blockMetricNames
index|[
name|getBlockMetricIndex
argument_list|(
name|blockCategory
argument_list|,
name|isCompaction
argument_list|,
name|metricType
argument_list|)
index|]
return|;
block|}
specifier|public
name|String
name|getBloomMetricName
parameter_list|(
name|boolean
name|isInBloom
parameter_list|)
block|{
return|return
name|bloomMetricNames
index|[
name|isInBloom
condition|?
literal|1
else|:
literal|0
index|]
return|;
block|}
comment|/**    * Increments the given metric, both per-CF and aggregate, for both the given    * category and all categories in aggregate (four counters total).    */
specifier|private
name|void
name|incrNumericMetric
parameter_list|(
name|BlockCategory
name|blockCategory
parameter_list|,
name|boolean
name|isCompaction
parameter_list|,
name|BlockMetricType
name|metricType
parameter_list|)
block|{
if|if
condition|(
name|blockCategory
operator|==
literal|null
condition|)
block|{
name|blockCategory
operator|=
name|BlockCategory
operator|.
name|UNKNOWN
expr_stmt|;
comment|// So that we see this in stats.
block|}
name|RegionMetricsStorage
operator|.
name|incrNumericMetric
argument_list|(
name|getBlockMetricName
argument_list|(
name|blockCategory
argument_list|,
name|isCompaction
argument_list|,
name|metricType
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|blockCategory
operator|!=
name|BlockCategory
operator|.
name|ALL_CATEGORIES
condition|)
block|{
name|incrNumericMetric
argument_list|(
name|BlockCategory
operator|.
name|ALL_CATEGORIES
argument_list|,
name|isCompaction
argument_list|,
name|metricType
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|addToReadTime
parameter_list|(
name|BlockCategory
name|blockCategory
parameter_list|,
name|boolean
name|isCompaction
parameter_list|,
name|long
name|timeMs
parameter_list|)
block|{
name|RegionMetricsStorage
operator|.
name|incrTimeVaryingMetric
argument_list|(
name|getBlockMetricName
argument_list|(
name|blockCategory
argument_list|,
name|isCompaction
argument_list|,
name|BlockMetricType
operator|.
name|READ_TIME
argument_list|)
argument_list|,
name|timeMs
argument_list|)
expr_stmt|;
comment|// Also update the read time aggregated across all block categories
if|if
condition|(
name|blockCategory
operator|!=
name|BlockCategory
operator|.
name|ALL_CATEGORIES
condition|)
block|{
name|addToReadTime
argument_list|(
name|BlockCategory
operator|.
name|ALL_CATEGORIES
argument_list|,
name|isCompaction
argument_list|,
name|timeMs
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Used to accumulate store metrics across multiple regions in a region    * server.  These metrics are not "persistent", i.e. we keep overriding them    * on every update instead of incrementing, so we need to accumulate them in    * a temporary map before pushing them to the global metric collection.    * @param tmpMap a temporary map for accumulating store metrics    * @param storeMetricType the store metric type to increment    * @param val the value to add to the metric    */
specifier|public
name|void
name|accumulateStoreMetric
parameter_list|(
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|MutableDouble
argument_list|>
name|tmpMap
parameter_list|,
name|StoreMetricType
name|storeMetricType
parameter_list|,
name|double
name|val
parameter_list|)
block|{
specifier|final
name|String
name|key
init|=
name|getStoreMetricName
argument_list|(
name|storeMetricType
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmpMap
operator|.
name|get
argument_list|(
name|key
argument_list|)
operator|==
literal|null
condition|)
block|{
name|tmpMap
operator|.
name|put
argument_list|(
name|key
argument_list|,
operator|new
name|MutableDouble
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmpMap
operator|.
name|get
argument_list|(
name|key
argument_list|)
operator|.
name|add
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|==
name|ALL_SCHEMA_METRICS
condition|)
block|{
comment|// also compute the max value across all Stores on this server
specifier|final
name|String
name|maxKey
init|=
name|getStoreMetricNameMax
argument_list|(
name|storeMetricType
argument_list|)
decl_stmt|;
name|MutableDouble
name|cur
init|=
name|tmpMap
operator|.
name|get
argument_list|(
name|maxKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|cur
operator|==
literal|null
condition|)
block|{
name|tmpMap
operator|.
name|put
argument_list|(
name|maxKey
argument_list|,
operator|new
name|MutableDouble
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cur
operator|.
name|doubleValue
argument_list|()
operator|<
name|val
condition|)
block|{
name|cur
operator|.
name|setValue
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ALL_SCHEMA_METRICS
operator|.
name|accumulateStoreMetric
argument_list|(
name|tmpMap
argument_list|,
name|storeMetricType
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|String
name|getStoreMetricName
parameter_list|(
name|StoreMetricType
name|storeMetricType
parameter_list|)
block|{
return|return
name|storeMetricNames
index|[
name|storeMetricType
operator|.
name|ordinal
argument_list|()
index|]
return|;
block|}
specifier|public
name|String
name|getStoreMetricNameMax
parameter_list|(
name|StoreMetricType
name|storeMetricType
parameter_list|)
block|{
return|return
name|storeMetricNamesMax
index|[
name|storeMetricType
operator|.
name|ordinal
argument_list|()
index|]
return|;
block|}
comment|/**    * Update a metric that does not get reset on every poll.    * @param storeMetricType the store metric to update    * @param value the value to update the metric to    */
specifier|public
name|void
name|updatePersistentStoreMetric
parameter_list|(
name|StoreMetricType
name|storeMetricType
parameter_list|,
name|long
name|value
parameter_list|)
block|{
name|RegionMetricsStorage
operator|.
name|incrNumericPersistentMetric
argument_list|(
name|storeMetricNames
index|[
name|storeMetricType
operator|.
name|ordinal
argument_list|()
index|]
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**    * Updates the number of hits and the total number of block reads on a block    * cache hit.    */
specifier|public
name|void
name|updateOnCacheHit
parameter_list|(
name|BlockCategory
name|blockCategory
parameter_list|,
name|boolean
name|isCompaction
parameter_list|)
block|{
name|blockCategory
operator|.
name|expectSpecific
argument_list|()
expr_stmt|;
name|incrNumericMetric
argument_list|(
name|blockCategory
argument_list|,
name|isCompaction
argument_list|,
name|BlockMetricType
operator|.
name|CACHE_HIT
argument_list|)
expr_stmt|;
name|incrNumericMetric
argument_list|(
name|blockCategory
argument_list|,
name|isCompaction
argument_list|,
name|BlockMetricType
operator|.
name|READ_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|!=
name|ALL_SCHEMA_METRICS
condition|)
block|{
name|ALL_SCHEMA_METRICS
operator|.
name|updateOnCacheHit
argument_list|(
name|blockCategory
argument_list|,
name|isCompaction
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Updates read time, the number of misses, and the total number of block    * reads on a block cache miss.    */
specifier|public
name|void
name|updateOnCacheMiss
parameter_list|(
name|BlockCategory
name|blockCategory
parameter_list|,
name|boolean
name|isCompaction
parameter_list|,
name|long
name|timeMs
parameter_list|)
block|{
name|blockCategory
operator|.
name|expectSpecific
argument_list|()
expr_stmt|;
name|addToReadTime
argument_list|(
name|blockCategory
argument_list|,
name|isCompaction
argument_list|,
name|timeMs
argument_list|)
expr_stmt|;
name|incrNumericMetric
argument_list|(
name|blockCategory
argument_list|,
name|isCompaction
argument_list|,
name|BlockMetricType
operator|.
name|CACHE_MISS
argument_list|)
expr_stmt|;
name|incrNumericMetric
argument_list|(
name|blockCategory
argument_list|,
name|isCompaction
argument_list|,
name|BlockMetricType
operator|.
name|READ_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|!=
name|ALL_SCHEMA_METRICS
condition|)
block|{
name|ALL_SCHEMA_METRICS
operator|.
name|updateOnCacheMiss
argument_list|(
name|blockCategory
argument_list|,
name|isCompaction
argument_list|,
name|timeMs
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Adds the given delta to the cache size for the given block category and    * the aggregate metric for all block categories. Updates both the per-CF    * counter and the counter for all CFs (four metrics total). The cache size    * metric is "persistent", i.e. it does not get reset when metrics are    * collected.    */
specifier|public
name|void
name|addToCacheSize
parameter_list|(
name|BlockCategory
name|category
parameter_list|,
name|long
name|cacheSizeDelta
parameter_list|)
block|{
if|if
condition|(
name|category
operator|==
literal|null
condition|)
block|{
name|category
operator|=
name|BlockCategory
operator|.
name|ALL_CATEGORIES
expr_stmt|;
block|}
name|RegionMetricsStorage
operator|.
name|incrNumericPersistentMetric
argument_list|(
name|getBlockMetricName
argument_list|(
name|category
argument_list|,
literal|false
argument_list|,
name|BlockMetricType
operator|.
name|CACHE_SIZE
argument_list|)
argument_list|,
name|cacheSizeDelta
argument_list|)
expr_stmt|;
if|if
condition|(
name|category
operator|!=
name|BlockCategory
operator|.
name|ALL_CATEGORIES
condition|)
block|{
name|addToCacheSize
argument_list|(
name|BlockCategory
operator|.
name|ALL_CATEGORIES
argument_list|,
name|cacheSizeDelta
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|updateOnCachePutOrEvict
parameter_list|(
name|BlockCategory
name|blockCategory
parameter_list|,
name|long
name|cacheSizeDelta
parameter_list|,
name|boolean
name|isEviction
parameter_list|)
block|{
name|addToCacheSize
argument_list|(
name|blockCategory
argument_list|,
name|cacheSizeDelta
argument_list|)
expr_stmt|;
name|incrNumericMetric
argument_list|(
name|blockCategory
argument_list|,
literal|false
argument_list|,
name|isEviction
condition|?
name|BlockMetricType
operator|.
name|EVICTED
else|:
name|BlockMetricType
operator|.
name|CACHED
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|!=
name|ALL_SCHEMA_METRICS
condition|)
block|{
name|ALL_SCHEMA_METRICS
operator|.
name|updateOnCachePutOrEvict
argument_list|(
name|blockCategory
argument_list|,
name|cacheSizeDelta
argument_list|,
name|isEviction
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Increments both the per-CF and the aggregate counter of bloom    * positives/negatives as specified by the argument.    */
specifier|public
name|void
name|updateBloomMetrics
parameter_list|(
name|boolean
name|isInBloom
parameter_list|)
block|{
name|RegionMetricsStorage
operator|.
name|incrNumericMetric
argument_list|(
name|getBloomMetricName
argument_list|(
name|isInBloom
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|!=
name|ALL_SCHEMA_METRICS
condition|)
block|{
name|ALL_SCHEMA_METRICS
operator|.
name|updateBloomMetrics
argument_list|(
name|isInBloom
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Sets the flag whether to use table name in metric names according to the    * given configuration. This must be called at least once before    * instantiating HFile readers/writers.    */
specifier|public
specifier|static
name|void
name|configureGlobally
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
specifier|final
name|boolean
name|useTableNameNew
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|SHOW_TABLE_NAME_CONF_KEY
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|setUseTableName
argument_list|(
name|useTableNameNew
argument_list|)
expr_stmt|;
block|}
comment|/**    * Determine the table name to be included in metric keys. If the global    * configuration says that we should not use table names in metrics,    * we always return {@link #TOTAL_KEY} even if nontrivial table name is    * provided.    *    * @param tableName a table name or {@link #TOTAL_KEY} when aggregating    * across all tables    * @return the table name to use in metric keys    */
specifier|private
specifier|static
name|String
name|getEffectiveTableName
parameter_list|(
name|String
name|tableName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|tableName
operator|.
name|equals
argument_list|(
name|TOTAL_KEY
argument_list|)
condition|)
block|{
comment|// We are provided with a non-trivial table name (including "unknown").
comment|// We need to know whether table name should be included into metrics.
if|if
condition|(
name|useTableNameGlobally
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"The value of the "
operator|+
name|SHOW_TABLE_NAME_CONF_KEY
operator|+
literal|" conf option has not been specified "
operator|+
literal|"in SchemaMetrics"
argument_list|)
throw|;
block|}
specifier|final
name|boolean
name|useTableName
init|=
name|useTableNameGlobally
decl_stmt|;
if|if
condition|(
operator|!
name|useTableName
condition|)
block|{
comment|// Don't include table name in metric keys.
name|tableName
operator|=
name|TOTAL_KEY
expr_stmt|;
block|}
block|}
return|return
name|tableName
return|;
block|}
comment|/**    * Method to transform a combination of a table name and a column family name    * into a metric key prefix. Tables/column family names equal to    * {@link #TOTAL_KEY} are omitted from the prefix.    *    * @param tableName the table name or {@link #TOTAL_KEY} for all tables    * @param cfName the column family name or {@link #TOTAL_KEY} for all CFs    * @return the metric name prefix, ending with a dot.    */
specifier|public
specifier|static
name|String
name|generateSchemaMetricsPrefix
parameter_list|(
name|String
name|tableName
parameter_list|,
specifier|final
name|String
name|cfName
parameter_list|)
block|{
name|tableName
operator|=
name|getEffectiveTableName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|String
name|schemaMetricPrefix
init|=
name|tableName
operator|.
name|equals
argument_list|(
name|TOTAL_KEY
argument_list|)
condition|?
literal|""
else|:
name|TABLE_PREFIX
operator|+
name|tableName
operator|+
literal|"."
decl_stmt|;
name|schemaMetricPrefix
operator|+=
name|cfName
operator|.
name|equals
argument_list|(
name|TOTAL_KEY
argument_list|)
condition|?
literal|""
else|:
name|CF_PREFIX
operator|+
name|cfName
operator|+
literal|"."
expr_stmt|;
return|return
name|schemaMetricPrefix
return|;
block|}
specifier|public
specifier|static
name|String
name|generateSchemaMetricsPrefix
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|,
name|byte
index|[]
name|cfName
parameter_list|)
block|{
return|return
name|generateSchemaMetricsPrefix
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toString
argument_list|(
name|cfName
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Method to transform a set of column families in byte[] format with table    * name into a metric key prefix.    *    * @param tableName the table name or {@link #TOTAL_KEY} for all tables    * @param families the ordered set of column families    * @return the metric name prefix, ending with a dot, or an empty string in    *         case of invalid arguments. This is OK since we always expect    *         some CFs to be included.    */
specifier|public
specifier|static
name|String
name|generateSchemaMetricsPrefix
parameter_list|(
name|String
name|tableName
parameter_list|,
name|Set
argument_list|<
name|byte
index|[]
argument_list|>
name|families
parameter_list|)
block|{
if|if
condition|(
name|families
operator|==
literal|null
operator|||
name|families
operator|.
name|isEmpty
argument_list|()
operator|||
name|tableName
operator|==
literal|null
operator|||
name|tableName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|""
return|;
block|}
if|if
condition|(
name|families
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
name|generateSchemaMetricsPrefix
argument_list|(
name|tableName
argument_list|,
name|Bytes
operator|.
name|toString
argument_list|(
name|families
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
name|tableName
operator|=
name|getEffectiveTableName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|sortedFamilies
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|(
name|families
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|sortedFamilies
argument_list|,
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
expr_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|numCFsLeft
init|=
name|families
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|family
range|:
name|sortedFamilies
control|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
name|MAX_METRIC_PREFIX_LENGTH
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|MORE_CFS_OMITTED_STR
argument_list|)
expr_stmt|;
break|break;
block|}
operator|--
name|numCFsLeft
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|family
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|numCFsLeft
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"~"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SchemaMetrics
operator|.
name|generateSchemaMetricsPrefix
argument_list|(
name|tableName
argument_list|,
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Get the prefix for metrics generated about a single region.    * @param tableName the table name or {@link #TOTAL_KEY} for all tables    * @param regionName regionName    * @return the prefix for this table/region combination.    */
specifier|static
name|String
name|generateRegionMetricsPrefix
parameter_list|(
name|String
name|tableName
parameter_list|,
name|String
name|regionName
parameter_list|)
block|{
name|tableName
operator|=
name|getEffectiveTableName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|String
name|schemaMetricPrefix
init|=
name|tableName
operator|.
name|equals
argument_list|(
name|TOTAL_KEY
argument_list|)
condition|?
literal|""
else|:
name|TABLE_PREFIX
operator|+
name|tableName
operator|+
literal|"."
decl_stmt|;
name|schemaMetricPrefix
operator|+=
name|regionName
operator|.
name|equals
argument_list|(
name|TOTAL_KEY
argument_list|)
condition|?
literal|""
else|:
name|REGION_PREFIX
operator|+
name|regionName
operator|+
literal|"."
expr_stmt|;
return|return
name|schemaMetricPrefix
return|;
block|}
comment|/**    * Sets the flag of whether to use table name in metric names. This flag    * is specified in configuration and is not expected to change at runtime,    * so we log an error message when it does change.    */
specifier|private
specifier|static
name|void
name|setUseTableName
parameter_list|(
specifier|final
name|boolean
name|useTableNameNew
parameter_list|)
block|{
if|if
condition|(
name|useTableNameGlobally
operator|==
literal|null
condition|)
block|{
comment|// This configuration option has not yet been set.
name|useTableNameGlobally
operator|=
name|useTableNameNew
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|useTableNameGlobally
operator|!=
name|useTableNameNew
operator|&&
operator|!
name|loggedConfInconsistency
condition|)
block|{
comment|// The configuration is inconsistent and we have not reported it
comment|// previously. Once we report it, just keep ignoring the new setting.
name|LOG
operator|.
name|error
argument_list|(
literal|"Inconsistent configuration. Previous configuration "
operator|+
literal|"for using table name in metrics: "
operator|+
name|useTableNameGlobally
operator|+
literal|", "
operator|+
literal|"new configuration: "
operator|+
name|useTableNameNew
argument_list|)
expr_stmt|;
name|loggedConfInconsistency
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// Methods used in testing
specifier|private
specifier|static
specifier|final
name|String
name|regexEscape
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
name|s
operator|.
name|replace
argument_list|(
literal|"."
argument_list|,
literal|"\\."
argument_list|)
return|;
block|}
comment|/**    * Assume that table names used in tests don't contain dots, except for the    * META table.    */
specifier|private
specifier|static
specifier|final
name|String
name|WORD_AND_DOT_RE_STR
init|=
literal|"([^.]+|"
operator|+
name|regexEscape
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|HConstants
operator|.
name|META_TABLE_NAME
argument_list|)
argument_list|)
operator|+
literal|")\\."
decl_stmt|;
comment|/** "tbl.<table_name>." */
specifier|private
specifier|static
specifier|final
name|String
name|TABLE_NAME_RE_STR
init|=
literal|"\\b"
operator|+
name|regexEscape
argument_list|(
name|TABLE_PREFIX
argument_list|)
operator|+
name|WORD_AND_DOT_RE_STR
decl_stmt|;
comment|/** "cf.<cf_name>." */
specifier|private
specifier|static
specifier|final
name|String
name|CF_NAME_RE_STR
init|=
literal|"\\b"
operator|+
name|regexEscape
argument_list|(
name|CF_PREFIX
argument_list|)
operator|+
name|WORD_AND_DOT_RE_STR
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Pattern
name|CF_NAME_RE
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|CF_NAME_RE_STR
argument_list|)
decl_stmt|;
comment|/** "tbl.<table_name>.cf.<cf_name>." */
specifier|private
specifier|static
specifier|final
name|Pattern
name|TABLE_AND_CF_NAME_RE
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|TABLE_NAME_RE_STR
operator|+
name|CF_NAME_RE_STR
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Pattern
name|BLOCK_CATEGORY_RE
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\b"
operator|+
name|regexEscape
argument_list|(
name|BLOCK_TYPE_PREFIX
argument_list|)
operator|+
literal|"[^.]+\\."
operator|+
comment|// Also remove the special-case block type marker for meta blocks
literal|"|"
operator|+
name|META_BLOCK_CATEGORY_STR
operator|+
literal|"(?="
operator|+
name|BlockMetricType
operator|.
name|BLOCK_METRIC_TYPE_RE
operator|+
literal|")"
argument_list|)
decl_stmt|;
comment|/**    * A suffix for the "number of operations" part of "time-varying metrics". We    * only use this for metric verification in unit testing. Time-varying    * metrics are handled by a different code path in production.    */
specifier|private
specifier|static
name|String
name|NUM_OPS_SUFFIX
init|=
literal|"numops"
decl_stmt|;
comment|/**    * A custom suffix that we use for verifying the second component of    * a "time-varying metric".    */
specifier|private
specifier|static
name|String
name|TOTAL_SUFFIX
init|=
literal|"_total"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Pattern
name|TIME_VARYING_SUFFIX_RE
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"("
operator|+
name|NUM_OPS_SUFFIX
operator|+
literal|"|"
operator|+
name|TOTAL_SUFFIX
operator|+
literal|")$"
argument_list|)
decl_stmt|;
name|void
name|printMetricNames
parameter_list|()
block|{
for|for
control|(
name|BlockCategory
name|blockCategory
range|:
name|BlockCategory
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|boolean
name|isCompaction
range|:
name|BOOL_VALUES
control|)
block|{
for|for
control|(
name|BlockMetricType
name|metricType
range|:
name|BlockMetricType
operator|.
name|values
argument_list|()
control|)
block|{
name|int
name|i
init|=
name|getBlockMetricIndex
argument_list|(
name|blockCategory
argument_list|,
name|isCompaction
argument_list|,
name|metricType
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"blockCategory="
operator|+
name|blockCategory
operator|+
literal|", "
operator|+
literal|"metricType="
operator|+
name|metricType
operator|+
literal|", isCompaction="
operator|+
name|isCompaction
operator|+
literal|", metricName="
operator|+
name|blockMetricNames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
name|Collection
argument_list|<
name|String
argument_list|>
name|getAllMetricNames
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|allMetricNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blockMetricNames
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|String
name|blockMetricName
init|=
name|blockMetricNames
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|boolean
name|timeVarying
init|=
name|blockMetricTimeVarying
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|blockMetricName
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|timeVarying
condition|)
block|{
name|allMetricNames
operator|.
name|add
argument_list|(
name|blockMetricName
operator|+
name|NUM_OPS_SUFFIX
argument_list|)
expr_stmt|;
name|allMetricNames
operator|.
name|add
argument_list|(
name|blockMetricName
operator|+
name|TOTAL_SUFFIX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|allMetricNames
operator|.
name|add
argument_list|(
name|blockMetricName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|allMetricNames
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|bloomMetricNames
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|allMetricNames
return|;
block|}
specifier|private
specifier|static
specifier|final
name|boolean
name|isTimeVaryingKey
parameter_list|(
name|String
name|metricKey
parameter_list|)
block|{
return|return
name|metricKey
operator|.
name|endsWith
argument_list|(
name|NUM_OPS_SUFFIX
argument_list|)
operator|||
name|metricKey
operator|.
name|endsWith
argument_list|(
name|TOTAL_SUFFIX
argument_list|)
return|;
block|}
specifier|private
specifier|static
specifier|final
name|String
name|stripTimeVaryingSuffix
parameter_list|(
name|String
name|metricKey
parameter_list|)
block|{
return|return
name|TIME_VARYING_SUFFIX_RE
operator|.
name|matcher
argument_list|(
name|metricKey
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|""
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|getMetricsSnapshot
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|metricsSnapshot
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|SchemaMetrics
name|cfm
range|:
name|tableAndFamilyToMetrics
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|String
name|metricName
range|:
name|cfm
operator|.
name|getAllMetricNames
argument_list|()
control|)
block|{
name|long
name|metricValue
decl_stmt|;
if|if
condition|(
name|isTimeVaryingKey
argument_list|(
name|metricName
argument_list|)
condition|)
block|{
name|Pair
argument_list|<
name|Long
argument_list|,
name|Integer
argument_list|>
name|totalAndCount
init|=
name|RegionMetricsStorage
operator|.
name|getTimeVaryingMetric
argument_list|(
name|stripTimeVaryingSuffix
argument_list|(
name|metricName
argument_list|)
argument_list|)
decl_stmt|;
name|metricValue
operator|=
name|metricName
operator|.
name|endsWith
argument_list|(
name|TOTAL_SUFFIX
argument_list|)
condition|?
name|totalAndCount
operator|.
name|getFirst
argument_list|()
else|:
name|totalAndCount
operator|.
name|getSecond
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|metricValue
operator|=
name|RegionMetricsStorage
operator|.
name|getNumericMetric
argument_list|(
name|metricName
argument_list|)
expr_stmt|;
block|}
name|metricsSnapshot
operator|.
name|put
argument_list|(
name|metricName
argument_list|,
name|metricValue
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|metricsSnapshot
return|;
block|}
specifier|public
specifier|static
name|long
name|getLong
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|m
parameter_list|,
name|String
name|k
parameter_list|)
block|{
name|Long
name|l
init|=
name|m
operator|.
name|get
argument_list|(
name|k
argument_list|)
decl_stmt|;
return|return
name|l
operator|!=
literal|null
condition|?
name|l
else|:
literal|0
return|;
block|}
specifier|private
specifier|static
name|void
name|putLong
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|m
parameter_list|,
name|String
name|k
parameter_list|,
name|long
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
operator|!=
literal|0
condition|)
block|{
name|m
operator|.
name|put
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m
operator|.
name|remove
argument_list|(
name|k
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @return the difference between two sets of metrics (second minus first).    *         Only includes keys that have nonzero difference.    */
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|diffMetrics
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|a
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|b
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|allKeys
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|a
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
name|allKeys
operator|.
name|addAll
argument_list|(
name|b
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|diff
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|k
range|:
name|allKeys
control|)
block|{
name|long
name|aVal
init|=
name|getLong
argument_list|(
name|a
argument_list|,
name|k
argument_list|)
decl_stmt|;
name|long
name|bVal
init|=
name|getLong
argument_list|(
name|b
argument_list|,
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|aVal
operator|!=
name|bVal
condition|)
block|{
name|diff
operator|.
name|put
argument_list|(
name|k
argument_list|,
name|bVal
operator|-
name|aVal
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|diff
return|;
block|}
specifier|public
specifier|static
name|void
name|validateMetricChanges
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|oldMetrics
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|newMetrics
init|=
name|getMetricsSnapshot
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|allCfDeltas
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|allBlockCategoryDeltas
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|deltas
init|=
name|diffMetrics
argument_list|(
name|oldMetrics
argument_list|,
name|newMetrics
argument_list|)
decl_stmt|;
specifier|final
name|Pattern
name|cfTableMetricRE
init|=
name|useTableNameGlobally
condition|?
name|TABLE_AND_CF_NAME_RE
else|:
name|CF_NAME_RE
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|allKeys
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|oldMetrics
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
name|allKeys
operator|.
name|addAll
argument_list|(
name|newMetrics
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|SchemaMetrics
name|cfm
range|:
name|tableAndFamilyToMetrics
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|String
name|metricName
range|:
name|cfm
operator|.
name|getAllMetricNames
argument_list|()
control|)
block|{
if|if
condition|(
name|metricName
operator|.
name|startsWith
argument_list|(
name|CF_PREFIX
operator|+
name|CF_PREFIX
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Column family prefix used twice: "
operator|+
name|metricName
argument_list|)
throw|;
block|}
specifier|final
name|long
name|oldValue
init|=
name|getLong
argument_list|(
name|oldMetrics
argument_list|,
name|metricName
argument_list|)
decl_stmt|;
specifier|final
name|long
name|newValue
init|=
name|getLong
argument_list|(
name|newMetrics
argument_list|,
name|metricName
argument_list|)
decl_stmt|;
specifier|final
name|long
name|delta
init|=
name|newValue
operator|-
name|oldValue
decl_stmt|;
comment|// Re-calculate values of metrics with no column family (or CF/table)
comment|// specified based on all metrics with CF (or CF/table) specified.
if|if
condition|(
name|delta
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cfm
operator|!=
name|ALL_SCHEMA_METRICS
condition|)
block|{
specifier|final
name|String
name|aggregateMetricName
init|=
name|cfTableMetricRE
operator|.
name|matcher
argument_list|(
name|metricName
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|""
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|aggregateMetricName
operator|.
name|equals
argument_list|(
name|metricName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Counting "
operator|+
name|delta
operator|+
literal|" units of "
operator|+
name|metricName
operator|+
literal|" towards "
operator|+
name|aggregateMetricName
argument_list|)
expr_stmt|;
name|putLong
argument_list|(
name|allCfDeltas
argument_list|,
name|aggregateMetricName
argument_list|,
name|getLong
argument_list|(
name|allCfDeltas
argument_list|,
name|aggregateMetricName
argument_list|)
operator|+
name|delta
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Metric="
operator|+
name|metricName
operator|+
literal|", delta="
operator|+
name|delta
argument_list|)
expr_stmt|;
block|}
block|}
name|Matcher
name|matcher
init|=
name|BLOCK_CATEGORY_RE
operator|.
name|matcher
argument_list|(
name|metricName
argument_list|)
decl_stmt|;
if|if
condition|(
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
comment|// Only process per-block-category metrics
name|String
name|metricNoBlockCategory
init|=
name|matcher
operator|.
name|replaceAll
argument_list|(
literal|""
argument_list|)
decl_stmt|;
name|putLong
argument_list|(
name|allBlockCategoryDeltas
argument_list|,
name|metricNoBlockCategory
argument_list|,
name|getLong
argument_list|(
name|allBlockCategoryDeltas
argument_list|,
name|metricNoBlockCategory
argument_list|)
operator|+
name|delta
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|StringBuilder
name|errors
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|key
range|:
name|ALL_SCHEMA_METRICS
operator|.
name|getAllMetricNames
argument_list|()
control|)
block|{
name|long
name|actual
init|=
name|getLong
argument_list|(
name|deltas
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|long
name|expected
init|=
name|getLong
argument_list|(
name|allCfDeltas
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|actual
operator|!=
name|expected
condition|)
block|{
if|if
condition|(
name|errors
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|errors
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|errors
operator|.
name|append
argument_list|(
literal|"The all-CF metric "
operator|+
name|key
operator|+
literal|" changed by "
operator|+
name|actual
operator|+
literal|" but the aggregation of per-CF/table metrics "
operator|+
literal|"yields "
operator|+
name|expected
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Verify metrics computed for all block types based on the aggregation
comment|// of per-block-type metrics.
for|for
control|(
name|String
name|key
range|:
name|allKeys
control|)
block|{
if|if
condition|(
name|BLOCK_CATEGORY_RE
operator|.
name|matcher
argument_list|(
name|key
argument_list|)
operator|.
name|find
argument_list|()
operator|||
name|key
operator|.
name|contains
argument_list|(
name|ALL_SCHEMA_METRICS
operator|.
name|getBloomMetricName
argument_list|(
literal|false
argument_list|)
argument_list|)
operator|||
name|key
operator|.
name|contains
argument_list|(
name|ALL_SCHEMA_METRICS
operator|.
name|getBloomMetricName
argument_list|(
literal|true
argument_list|)
argument_list|)
condition|)
block|{
comment|// Skip per-block-category metrics. Also skip bloom filters, because
comment|// they are not aggregated per block type.
continue|continue;
block|}
name|long
name|actual
init|=
name|getLong
argument_list|(
name|deltas
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|long
name|expected
init|=
name|getLong
argument_list|(
name|allBlockCategoryDeltas
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|actual
operator|!=
name|expected
condition|)
block|{
if|if
condition|(
name|errors
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|errors
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|errors
operator|.
name|append
argument_list|(
literal|"The all-block-category metric "
operator|+
name|key
operator|+
literal|" changed by "
operator|+
name|actual
operator|+
literal|" but the aggregation of "
operator|+
literal|"per-block-category metrics yields "
operator|+
name|expected
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errors
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|errors
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * Creates an instance pretending both the table and column family are    * unknown. Used in unit tests.    */
specifier|public
specifier|static
name|SchemaMetrics
name|getUnknownInstanceForTest
parameter_list|()
block|{
return|return
name|getInstance
argument_list|(
name|UNKNOWN
argument_list|,
name|UNKNOWN
argument_list|)
return|;
block|}
comment|/**    * Set the flag to use or not use table name in metric names. Used in unit    * tests, so the flag can be set arbitrarily.    */
specifier|public
specifier|static
name|void
name|setUseTableNameInTest
parameter_list|(
specifier|final
name|boolean
name|useTableNameNew
parameter_list|)
block|{
name|useTableNameGlobally
operator|=
name|useTableNameNew
expr_stmt|;
block|}
comment|/** Formats the given map of metrics in a human-readable way. */
specifier|public
specifier|static
name|String
name|formatMetrics
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|metrics
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|entry
range|:
name|metrics
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|+
literal|" : "
operator|+
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

end_unit

