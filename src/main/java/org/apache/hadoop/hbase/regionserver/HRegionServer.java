begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2010 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|Thread
operator|.
name|UncaughtExceptionHandler
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Retention
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|RetentionPolicy
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|ManagementFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|MemoryUsage
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|BindException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentSkipListSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Chore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ClockOutOfSyncException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|DoNotRetryIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
operator|.
name|OperationStatusCode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerAddress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerLoad
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MasterAddressTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NotServingRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|RemoteExceptionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Stoppable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableDescriptors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|UnknownRowLockException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|UnknownScannerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|YouAreDeadException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|CatalogTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|MetaEditor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|RootLocationEditor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Action
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Delete
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Get
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Increment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MultiAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MultiPut
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MultiPutResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MultiResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Put
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Row
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Scan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|coprocessor
operator|.
name|Exec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|coprocessor
operator|.
name|ExecResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|ExecutorService
operator|.
name|ExecutorType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|BinaryComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|CompareFilter
operator|.
name|CompareOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|WritableByteArrayComparable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|BlockCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|LruBlockCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|LruBlockCache
operator|.
name|CacheStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|CoprocessorProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HBaseRPC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HBaseRPCErrorHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HBaseRpcMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HMasterRegionInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HRegionInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|Invocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|RpcServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|ServerNotRunningYetException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|Leases
operator|.
name|LeaseStillHeldException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|handler
operator|.
name|CloseMetaHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|handler
operator|.
name|CloseRegionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|handler
operator|.
name|CloseRootHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|handler
operator|.
name|OpenMetaHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|handler
operator|.
name|OpenRegionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|handler
operator|.
name|OpenRootHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|metrics
operator|.
name|RegionServerMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|wal
operator|.
name|HLog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|wal
operator|.
name|WALObserver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RegionOpeningState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|regionserver
operator|.
name|Replication
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|User
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|CompressionTest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSTableDescriptors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|InfoServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Sleeper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|VersionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ClusterStatusTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperNodeTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|MapWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|DNS
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|map
operator|.
name|ObjectMapper
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  * HRegionServer makes a set of HRegions available to clients. It checks in with  * the HMaster. There are many HRegionServers in a single HBase deployment.  */
end_comment

begin_class
specifier|public
class|class
name|HRegionServer
implements|implements
name|HRegionInterface
implements|,
name|HBaseRPCErrorHandler
implements|,
name|Runnable
implements|,
name|RegionServerServices
block|{
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HRegionServer
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Set when a report to the master comes back with a message asking us to
comment|// shutdown. Also set by call to stop when debugging or running unit tests
comment|// of HRegionServer in isolation.
specifier|protected
specifier|volatile
name|boolean
name|stopped
init|=
literal|false
decl_stmt|;
comment|// A state before we go into stopped state.  At this stage we're closing user
comment|// space regions.
specifier|private
name|boolean
name|stopping
init|=
literal|false
decl_stmt|;
comment|// Go down hard. Used if file system becomes unavailable and also in
comment|// debugging and unit tests.
specifier|protected
specifier|volatile
name|boolean
name|abortRequested
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|killed
init|=
literal|false
decl_stmt|;
comment|// If false, the file system has become unavailable
specifier|protected
specifier|volatile
name|boolean
name|fsOk
decl_stmt|;
specifier|protected
specifier|final
name|Configuration
name|conf
decl_stmt|;
specifier|protected
specifier|final
name|AtomicBoolean
name|haveRootRegion
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|private
name|FileSystem
name|fs
decl_stmt|;
specifier|private
name|Path
name|rootDir
decl_stmt|;
specifier|private
specifier|final
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|byte
index|[]
argument_list|>
name|regionsInTransitionInRS
init|=
operator|new
name|ConcurrentSkipListSet
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
comment|/**    * Map of regions currently being served by this region server. Key is the    * encoded region name.  All access should be synchronized.    */
specifier|protected
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|HRegion
argument_list|>
name|onlineRegions
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|HRegion
argument_list|>
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|ReentrantReadWriteLock
name|lock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
specifier|final
name|int
name|numRetries
decl_stmt|;
specifier|protected
specifier|final
name|int
name|threadWakeFrequency
decl_stmt|;
specifier|private
specifier|final
name|int
name|msgInterval
decl_stmt|;
specifier|protected
specifier|final
name|int
name|numRegionsToReport
decl_stmt|;
specifier|private
specifier|final
name|long
name|maxScannerResultSize
decl_stmt|;
comment|// Remote HMaster
specifier|private
name|HMasterRegionInterface
name|hbaseMaster
decl_stmt|;
comment|// Server to handle client requests. Default access so can be accessed by
comment|// unit tests.
name|RpcServer
name|rpcServer
decl_stmt|;
specifier|private
specifier|final
name|InetSocketAddress
name|isa
decl_stmt|;
comment|// Leases
specifier|private
name|Leases
name|leases
decl_stmt|;
comment|// Request counter.
comment|// Do we need this?  Can't we just sum region counters?  St.Ack 20110412
specifier|private
name|AtomicInteger
name|requestCount
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|// Info server. Default access so can be used by unit tests. REGIONSERVER
comment|// is name of the webapp and the attribute name used stuffing this instance
comment|// into web context.
name|InfoServer
name|infoServer
decl_stmt|;
comment|/** region server process name */
specifier|public
specifier|static
specifier|final
name|String
name|REGIONSERVER
init|=
literal|"regionserver"
decl_stmt|;
comment|/*    * Space is reserved in HRS constructor and then released when aborting to    * recover from an OOME. See HBASE-706. TODO: Make this percentage of the heap    * or a minimum.    */
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|byte
index|[]
argument_list|>
name|reservedSpace
init|=
operator|new
name|LinkedList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|RegionServerMetrics
name|metrics
decl_stmt|;
comment|// Compactions
specifier|public
name|CompactSplitThread
name|compactSplitThread
decl_stmt|;
comment|// Cache flushing
name|MemStoreFlusher
name|cacheFlusher
decl_stmt|;
comment|/*    * Check for compactions requests.    */
name|Chore
name|compactionChecker
decl_stmt|;
comment|// HLog and HLog roller. log is protected rather than private to avoid
comment|// eclipse warning when accessed by inner classes
specifier|protected
specifier|volatile
name|HLog
name|hlog
decl_stmt|;
name|LogRoller
name|hlogRoller
decl_stmt|;
comment|// flag set after we're done setting up server threads (used for testing)
specifier|protected
specifier|volatile
name|boolean
name|isOnline
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|InternalScanner
argument_list|>
name|scanners
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|InternalScanner
argument_list|>
argument_list|()
decl_stmt|;
comment|// zookeeper connection and watcher
specifier|private
name|ZooKeeperWatcher
name|zooKeeper
decl_stmt|;
comment|// master address manager and watcher
specifier|private
name|MasterAddressTracker
name|masterAddressManager
decl_stmt|;
comment|// catalog tracker
specifier|private
name|CatalogTracker
name|catalogTracker
decl_stmt|;
comment|// Cluster Status Tracker
specifier|private
name|ClusterStatusTracker
name|clusterStatusTracker
decl_stmt|;
comment|// Log Splitting Worker
specifier|private
name|SplitLogWorker
name|splitLogWorker
decl_stmt|;
comment|// A sleeper that sleeps for msgInterval.
specifier|private
specifier|final
name|Sleeper
name|sleeper
decl_stmt|;
specifier|private
specifier|final
name|int
name|rpcTimeout
decl_stmt|;
comment|// Instance of the hbase executor service.
specifier|private
name|ExecutorService
name|service
decl_stmt|;
comment|// Replication services. If no replication, this handler will be null.
specifier|private
name|Replication
name|replicationHandler
decl_stmt|;
specifier|private
specifier|final
name|RegionServerAccounting
name|regionServerAccounting
decl_stmt|;
comment|/**    * The server name the Master sees us as.  Its made from the hostname the    * master passes us, port, and server startcode. Gets set after registration    * against  Master.  The hostname can differ from the hostname in {@link #isa}    * but usually doesn't if both servers resolve .    */
specifier|private
name|ServerName
name|serverNameFromMasterPOV
decl_stmt|;
comment|// Port we put up the webui on.
specifier|private
name|int
name|webuiport
init|=
operator|-
literal|1
decl_stmt|;
comment|/**    * This servers startcode.    */
specifier|private
specifier|final
name|long
name|startcode
decl_stmt|;
comment|/**    * Go here to get table descriptors.    */
specifier|private
name|TableDescriptors
name|tableDescriptors
decl_stmt|;
comment|/**    * Starts a HRegionServer at the default location    *    * @param conf    * @throws IOException    * @throws InterruptedException    */
specifier|public
name|HRegionServer
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|this
operator|.
name|fsOk
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|isOnline
operator|=
literal|false
expr_stmt|;
name|checkCodecs
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
comment|// Config'ed params
name|this
operator|.
name|numRetries
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.client.retries.number"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|this
operator|.
name|threadWakeFrequency
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|THREAD_WAKE_FREQUENCY
argument_list|,
literal|10
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|this
operator|.
name|msgInterval
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.msginterval"
argument_list|,
literal|3
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|this
operator|.
name|sleeper
operator|=
operator|new
name|Sleeper
argument_list|(
name|this
operator|.
name|msgInterval
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxScannerResultSize
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_SCANNER_MAX_RESULT_SIZE_KEY
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_SCANNER_MAX_RESULT_SIZE
argument_list|)
expr_stmt|;
name|this
operator|.
name|numRegionsToReport
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.numregionstoreport"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|this
operator|.
name|rpcTimeout
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_RPC_TIMEOUT_KEY
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_RPC_TIMEOUT
argument_list|)
expr_stmt|;
name|this
operator|.
name|abortRequested
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|stopped
operator|=
literal|false
expr_stmt|;
comment|// Server to handle client requests.
name|String
name|hostname
init|=
name|DNS
operator|.
name|getDefaultHost
argument_list|(
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.regionserver.dns.interface"
argument_list|,
literal|"default"
argument_list|)
argument_list|,
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.regionserver.dns.nameserver"
argument_list|,
literal|"default"
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|port
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|REGIONSERVER_PORT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_REGIONSERVER_PORT
argument_list|)
decl_stmt|;
comment|// Creation of a HSA will force a resolve.
name|InetSocketAddress
name|initialIsa
init|=
operator|new
name|InetSocketAddress
argument_list|(
name|hostname
argument_list|,
name|port
argument_list|)
decl_stmt|;
if|if
condition|(
name|initialIsa
operator|.
name|getAddress
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Failed resolve of "
operator|+
name|initialIsa
argument_list|)
throw|;
block|}
name|this
operator|.
name|rpcServer
operator|=
name|HBaseRPC
operator|.
name|getServer
argument_list|(
name|this
argument_list|,
operator|new
name|Class
argument_list|<
name|?
argument_list|>
index|[]
block|{
name|HRegionInterface
operator|.
name|class
operator|,
name|HBaseRPCErrorHandler
operator|.
name|class
operator|,
name|OnlineRegions
operator|.
name|class
block|}
operator|,
name|initialIsa
operator|.
name|getHostName
argument_list|()
operator|,
comment|// BindAddress is IP we got for this server.
name|initialIsa
operator|.
name|getPort
argument_list|()
operator|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.handler.count"
argument_list|,
literal|10
argument_list|)
operator|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.metahandler.count"
argument_list|,
literal|10
argument_list|)
operator|,
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.rpc.verbose"
argument_list|,
literal|false
argument_list|)
operator|,
name|conf
operator|,
name|QOS_THRESHOLD
block|)
empty_stmt|;
comment|// Set our address.
name|this
operator|.
name|isa
operator|=
name|this
operator|.
name|rpcServer
operator|.
name|getListenerAddress
argument_list|()
expr_stmt|;
name|this
operator|.
name|rpcServer
operator|.
name|setErrorHandler
parameter_list|(
name|this
parameter_list|)
constructor_decl|;
name|this
operator|.
name|rpcServer
operator|.
name|setQosFunction
argument_list|(
operator|new
name|QosFunction
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|startcode
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
comment|// login the server principal (if using secure Hadoop)
name|User
operator|.
name|login
argument_list|(
name|this
operator|.
name|conf
argument_list|,
literal|"hbase.regionserver.keytab.file"
argument_list|,
literal|"hbase.regionserver.kerberos.principal"
argument_list|,
name|this
operator|.
name|isa
operator|.
name|getHostName
argument_list|()
argument_list|)
expr_stmt|;
name|regionServerAccounting
operator|=
operator|new
name|RegionServerAccounting
argument_list|()
expr_stmt|;
block|}
end_class

begin_comment
comment|/**    * Run test on configured codecs to make sure supporting libs are in place.    * @param c    * @throws IOException    */
end_comment

begin_function
specifier|private
specifier|static
name|void
name|checkCodecs
parameter_list|(
specifier|final
name|Configuration
name|c
parameter_list|)
throws|throws
name|IOException
block|{
comment|// check to see if the codec list is available:
name|String
index|[]
name|codecs
init|=
name|c
operator|.
name|getStrings
argument_list|(
literal|"hbase.regionserver.codecs"
argument_list|,
operator|(
name|String
index|[]
operator|)
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|codecs
operator|==
literal|null
condition|)
return|return;
for|for
control|(
name|String
name|codec
range|:
name|codecs
control|)
block|{
if|if
condition|(
operator|!
name|CompressionTest
operator|.
name|testCompression
argument_list|(
name|codec
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Compression codec "
operator|+
name|codec
operator|+
literal|" not supported, aborting RS construction"
argument_list|)
throw|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|private
specifier|static
specifier|final
name|int
name|NORMAL_QOS
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|private
specifier|static
specifier|final
name|int
name|QOS_THRESHOLD
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|// the line between low and high qos
end_comment

begin_decl_stmt
specifier|private
specifier|static
specifier|final
name|int
name|HIGH_QOS
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_annotation_defn
annotation|@
name|Retention
argument_list|(
name|RetentionPolicy
operator|.
name|RUNTIME
argument_list|)
specifier|private
annotation_defn|@interface
name|QosPriority
block|{
name|int
name|priority
parameter_list|()
default|default
literal|0
function_decl|;
block|}
end_annotation_defn

begin_comment
comment|/**    * Utility used ensuring higher quality of service for priority rpcs; e.g.    * rpcs to .META. and -ROOT-, etc.    */
end_comment

begin_class
class|class
name|QosFunction
implements|implements
name|Function
argument_list|<
name|Writable
argument_list|,
name|Integer
argument_list|>
block|{
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|annotatedQos
decl_stmt|;
specifier|public
name|QosFunction
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|qosMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Method
name|m
range|:
name|HRegionServer
operator|.
name|class
operator|.
name|getMethods
argument_list|()
control|)
block|{
name|QosPriority
name|p
init|=
name|m
operator|.
name|getAnnotation
argument_list|(
name|QosPriority
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|qosMap
operator|.
name|put
argument_list|(
name|m
operator|.
name|getName
argument_list|()
argument_list|,
name|p
operator|.
name|priority
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|annotatedQos
operator|=
name|qosMap
expr_stmt|;
block|}
specifier|public
name|boolean
name|isMetaRegion
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|)
block|{
name|HRegion
name|region
decl_stmt|;
try|try
block|{
name|region
operator|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotServingRegionException
name|ignored
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isMetaRegion
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Integer
name|apply
parameter_list|(
name|Writable
name|from
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|from
operator|instanceof
name|Invocation
operator|)
condition|)
return|return
name|NORMAL_QOS
return|;
name|Invocation
name|inv
init|=
operator|(
name|Invocation
operator|)
name|from
decl_stmt|;
name|String
name|methodName
init|=
name|inv
operator|.
name|getMethodName
argument_list|()
decl_stmt|;
name|Integer
name|priorityByAnnotation
init|=
name|annotatedQos
operator|.
name|get
argument_list|(
name|methodName
argument_list|)
decl_stmt|;
if|if
condition|(
name|priorityByAnnotation
operator|!=
literal|null
condition|)
block|{
return|return
name|priorityByAnnotation
return|;
block|}
comment|// scanner methods...
if|if
condition|(
name|methodName
operator|.
name|equals
argument_list|(
literal|"next"
argument_list|)
operator|||
name|methodName
operator|.
name|equals
argument_list|(
literal|"close"
argument_list|)
condition|)
block|{
comment|// translate!
name|Long
name|scannerId
decl_stmt|;
try|try
block|{
name|scannerId
operator|=
operator|(
name|Long
operator|)
name|inv
operator|.
name|getParameters
argument_list|()
index|[
literal|0
index|]
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|ignored
parameter_list|)
block|{
comment|// LOG.debug("Low priority: " + from);
return|return
name|NORMAL_QOS
return|;
comment|// doh.
block|}
name|String
name|scannerIdString
init|=
name|Long
operator|.
name|toString
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
name|InternalScanner
name|scanner
init|=
name|scanners
operator|.
name|get
argument_list|(
name|scannerIdString
argument_list|)
decl_stmt|;
if|if
condition|(
name|scanner
operator|instanceof
name|HRegion
operator|.
name|RegionScanner
condition|)
block|{
name|HRegion
operator|.
name|RegionScanner
name|rs
init|=
operator|(
name|HRegion
operator|.
name|RegionScanner
operator|)
name|scanner
decl_stmt|;
name|HRegionInfo
name|regionName
init|=
name|rs
operator|.
name|getRegionName
argument_list|()
decl_stmt|;
if|if
condition|(
name|regionName
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
comment|// LOG.debug("High priority scanner request: " + scannerId);
return|return
name|HIGH_QOS
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|inv
operator|.
name|getParameterClasses
argument_list|()
operator|.
name|length
operator|==
literal|0
condition|)
block|{
comment|// Just let it through.  This is getOnlineRegions, etc.
block|}
elseif|else
if|if
condition|(
name|inv
operator|.
name|getParameterClasses
argument_list|()
index|[
literal|0
index|]
operator|==
name|byte
index|[]
operator|.
name|class
condition|)
block|{
comment|// first arg is byte array, so assume this is a regionname:
if|if
condition|(
name|isMetaRegion
argument_list|(
operator|(
name|byte
index|[]
operator|)
name|inv
operator|.
name|getParameters
argument_list|()
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|// LOG.debug("High priority with method: " + methodName +
comment|// " and region: "
comment|// + Bytes.toString((byte[]) inv.getParameters()[0]));
return|return
name|HIGH_QOS
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|inv
operator|.
name|getParameterClasses
argument_list|()
index|[
literal|0
index|]
operator|==
name|MultiAction
operator|.
name|class
condition|)
block|{
name|MultiAction
argument_list|<
name|?
argument_list|>
name|ma
init|=
operator|(
name|MultiAction
argument_list|<
name|?
argument_list|>
operator|)
name|inv
operator|.
name|getParameters
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
name|Set
argument_list|<
name|byte
index|[]
argument_list|>
name|regions
init|=
name|ma
operator|.
name|getRegions
argument_list|()
decl_stmt|;
comment|// ok this sucks, but if any single of the actions touches a meta, the
comment|// whole
comment|// thing gets pingged high priority. This is a dangerous hack because
comment|// people
comment|// can get their multi action tagged high QOS by tossing a Get(.META.)
comment|// AND this
comment|// regionserver hosts META/-ROOT-
for|for
control|(
name|byte
index|[]
name|region
range|:
name|regions
control|)
block|{
if|if
condition|(
name|isMetaRegion
argument_list|(
name|region
argument_list|)
condition|)
block|{
comment|// LOG.debug("High priority multi with region: " +
comment|// Bytes.toString(region));
return|return
name|HIGH_QOS
return|;
comment|// short circuit for the win.
block|}
block|}
block|}
comment|// LOG.debug("Low priority: " + from.toString());
return|return
name|NORMAL_QOS
return|;
block|}
block|}
end_class

begin_comment
comment|/**    * All initialization needed before we go register with Master.    *    * @throws IOException    * @throws InterruptedException    */
end_comment

begin_function
specifier|private
name|void
name|preRegistrationInitialization
parameter_list|()
block|{
try|try
block|{
name|initializeZooKeeper
argument_list|()
expr_stmt|;
name|initializeThreads
argument_list|()
expr_stmt|;
name|int
name|nbBlocks
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.nbreservationblocks"
argument_list|,
literal|4
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nbBlocks
condition|;
name|i
operator|++
control|)
block|{
name|reservedSpace
operator|.
name|add
argument_list|(
operator|new
name|byte
index|[
name|HConstants
operator|.
name|DEFAULT_SIZE_RESERVATION_BLOCK
index|]
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// Call stop if error or process will stick around for ever since server
comment|// puts up non-daemon threads.
name|this
operator|.
name|rpcServer
operator|.
name|stop
argument_list|()
expr_stmt|;
name|abort
argument_list|(
literal|"Initialization of RS failed.  Hence aborting RS."
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * Bring up connection to zk ensemble and then wait until a master for this    * cluster and then after that, wait until cluster 'up' flag has been set.    * This is the order in which master does things.    * Finally put up a catalog tracker.    * @throws IOException    * @throws InterruptedException    */
end_comment

begin_function
specifier|private
name|void
name|initializeZooKeeper
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
comment|// Open connection to zookeeper and set primary watcher
name|this
operator|.
name|zooKeeper
operator|=
operator|new
name|ZooKeeperWatcher
argument_list|(
name|conf
argument_list|,
name|REGIONSERVER
operator|+
literal|":"
operator|+
name|this
operator|.
name|isa
operator|.
name|getPort
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|// Create the master address manager, register with zk, and start it.  Then
comment|// block until a master is available.  No point in starting up if no master
comment|// running.
name|this
operator|.
name|masterAddressManager
operator|=
operator|new
name|MasterAddressTracker
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|masterAddressManager
operator|.
name|start
argument_list|()
expr_stmt|;
name|blockAndCheckIfStopped
argument_list|(
name|this
operator|.
name|masterAddressManager
argument_list|)
expr_stmt|;
comment|// Wait on cluster being up.  Master will set this flag up in zookeeper
comment|// when ready.
name|this
operator|.
name|clusterStatusTracker
operator|=
operator|new
name|ClusterStatusTracker
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|clusterStatusTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|blockAndCheckIfStopped
argument_list|(
name|this
operator|.
name|clusterStatusTracker
argument_list|)
expr_stmt|;
comment|// Create the catalog tracker and start it;
name|this
operator|.
name|catalogTracker
operator|=
operator|new
name|CatalogTracker
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|this
operator|.
name|conf
argument_list|,
name|this
argument_list|,
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.catalog.timeout"
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
expr_stmt|;
name|catalogTracker
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Utilty method to wait indefinitely on a znode availability while checking    * if the region server is shut down    * @param tracker znode tracker to use    * @throws IOException any IO exception, plus if the RS is stopped    * @throws InterruptedException    */
end_comment

begin_function
specifier|private
name|void
name|blockAndCheckIfStopped
parameter_list|(
name|ZooKeeperNodeTracker
name|tracker
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
literal|false
operator|==
name|tracker
operator|.
name|checkIfBaseNodeAvailable
argument_list|()
condition|)
block|{
name|String
name|errorMsg
init|=
literal|"Check the value configured in 'zookeeper.znode.parent'. "
operator|+
literal|"There could be a mismatch with the one configured in the master."
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|errorMsg
argument_list|)
expr_stmt|;
name|abort
argument_list|(
name|errorMsg
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|tracker
operator|.
name|blockUntilAvailable
argument_list|(
name|this
operator|.
name|msgInterval
argument_list|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|stopped
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Received the shutdown message while waiting."
argument_list|)
throw|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**    * @return False if cluster shutdown in progress    */
end_comment

begin_function
specifier|private
name|boolean
name|isClusterUp
parameter_list|()
block|{
return|return
name|this
operator|.
name|clusterStatusTracker
operator|.
name|isClusterUp
argument_list|()
return|;
block|}
end_function

begin_function
specifier|private
name|void
name|initializeThreads
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Cache flushing thread.
name|this
operator|.
name|cacheFlusher
operator|=
operator|new
name|MemStoreFlusher
argument_list|(
name|conf
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|// Compaction thread
name|this
operator|.
name|compactSplitThread
operator|=
operator|new
name|CompactSplitThread
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Background thread to check for compactions; needed if region
comment|// has not gotten updates in a while. Make it run at a lesser frequency.
name|int
name|multiplier
init|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|THREAD_WAKE_FREQUENCY
operator|+
literal|".multiplier"
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
name|this
operator|.
name|compactionChecker
operator|=
operator|new
name|CompactionChecker
argument_list|(
name|this
argument_list|,
name|this
operator|.
name|threadWakeFrequency
operator|*
name|multiplier
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|leases
operator|=
operator|new
name|Leases
argument_list|(
operator|(
name|int
operator|)
name|conf
operator|.
name|getLong
argument_list|(
name|HConstants
operator|.
name|HBASE_REGIONSERVER_LEASE_PERIOD_KEY
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_REGIONSERVER_LEASE_PERIOD
argument_list|)
argument_list|,
name|this
operator|.
name|threadWakeFrequency
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * The HRegionServer sticks in this loop until closed.    */
end_comment

begin_function
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
comment|// Do pre-registration initializations; zookeeper, lease threads, etc.
name|preRegistrationInitialization
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|abort
argument_list|(
literal|"Fatal exception during initialization"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
comment|// Try and register with the Master; tell it we are here.  Break if
comment|// server is stopped or the clusterup flag is down of hdfs went wacky.
while|while
condition|(
name|keepLooping
argument_list|()
condition|)
block|{
name|MapWritable
name|w
init|=
name|reportForDuty
argument_list|()
decl_stmt|;
if|if
condition|(
name|w
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"reportForDuty failed; sleeping and then retrying."
argument_list|)
expr_stmt|;
name|this
operator|.
name|sleeper
operator|.
name|sleep
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|handleReportForDutyResponse
argument_list|(
name|w
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|// We registered with the Master.  Go into run mode.
name|long
name|lastMsg
init|=
literal|0
decl_stmt|;
name|long
name|oldRequestCount
init|=
operator|-
literal|1
decl_stmt|;
comment|// The main run loop.
while|while
condition|(
operator|!
name|this
operator|.
name|stopped
operator|&&
name|isHealthy
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|isClusterUp
argument_list|()
condition|)
block|{
if|if
condition|(
name|isOnlineRegionsEmpty
argument_list|()
condition|)
block|{
name|stop
argument_list|(
literal|"Exiting; cluster shutdown set and not carrying any regions"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|this
operator|.
name|stopping
condition|)
block|{
name|this
operator|.
name|stopping
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Closing user regions"
argument_list|)
expr_stmt|;
name|closeUserRegions
argument_list|(
name|this
operator|.
name|abortRequested
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this
operator|.
name|stopping
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping meta regions, if the HRegionServer hosts any"
argument_list|)
expr_stmt|;
name|boolean
name|allUserRegionsOffline
init|=
name|areAllUserRegionsOffline
argument_list|()
decl_stmt|;
if|if
condition|(
name|allUserRegionsOffline
condition|)
block|{
comment|// Set stopped if no requests since last time we went around the loop.
comment|// The remaining meta regions will be closed on our way out.
if|if
condition|(
name|oldRequestCount
operator|==
name|this
operator|.
name|requestCount
operator|.
name|get
argument_list|()
condition|)
block|{
name|stop
argument_list|(
literal|"Stopped; only catalog regions remaining online"
argument_list|)
expr_stmt|;
break|break;
block|}
name|oldRequestCount
operator|=
name|this
operator|.
name|requestCount
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting on "
operator|+
name|getOnlineRegionsAsPrintableString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|now
operator|-
name|lastMsg
operator|)
operator|>=
name|msgInterval
condition|)
block|{
name|doMetrics
argument_list|()
expr_stmt|;
name|tryRegionServerReport
argument_list|()
expr_stmt|;
name|lastMsg
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|this
operator|.
name|stopped
condition|)
name|this
operator|.
name|sleeper
operator|.
name|sleep
argument_list|()
expr_stmt|;
block|}
comment|// for
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|checkOOME
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|abort
argument_list|(
literal|"Unhandled exception: "
operator|+
name|t
operator|.
name|getMessage
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Run shutdown.
name|this
operator|.
name|leases
operator|.
name|closeAfterLeasesExpire
argument_list|()
expr_stmt|;
name|this
operator|.
name|rpcServer
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|splitLogWorker
operator|!=
literal|null
condition|)
block|{
name|splitLogWorker
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|infoServer
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping infoServer"
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|infoServer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Send cache a shutdown.
name|BlockCache
name|c
init|=
name|StoreFile
operator|.
name|getBlockCache
argument_list|(
name|this
operator|.
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
name|c
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
comment|// Send interrupts to wake up threads if sleeping so they notice shutdown.
comment|// TODO: Should we check they are alive? If OOME could have exited already
if|if
condition|(
name|this
operator|.
name|cacheFlusher
operator|!=
literal|null
condition|)
name|this
operator|.
name|cacheFlusher
operator|.
name|interruptIfNecessary
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|compactSplitThread
operator|!=
literal|null
condition|)
name|this
operator|.
name|compactSplitThread
operator|.
name|interruptIfNecessary
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|hlogRoller
operator|!=
literal|null
condition|)
name|this
operator|.
name|hlogRoller
operator|.
name|interruptIfNecessary
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|compactionChecker
operator|!=
literal|null
condition|)
name|this
operator|.
name|compactionChecker
operator|.
name|interrupt
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|killed
condition|)
block|{
comment|// Just skip out w/o closing regions.  Used when testing.
block|}
elseif|else
if|if
condition|(
name|abortRequested
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|fsOk
condition|)
block|{
name|closeAllRegions
argument_list|(
name|abortRequested
argument_list|)
expr_stmt|;
comment|// Don't leave any open file handles
name|closeWAL
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"aborting server "
operator|+
name|this
operator|.
name|serverNameFromMasterPOV
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|closeAllRegions
argument_list|(
name|abortRequested
argument_list|)
expr_stmt|;
name|closeWAL
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|closeAllScanners
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"stopping server "
operator|+
name|this
operator|.
name|serverNameFromMasterPOV
argument_list|)
expr_stmt|;
block|}
comment|// Interrupt catalog tracker here in case any regions being opened out in
comment|// handlers are stuck waiting on meta or root.
if|if
condition|(
name|this
operator|.
name|catalogTracker
operator|!=
literal|null
condition|)
name|this
operator|.
name|catalogTracker
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|fsOk
condition|)
name|waitOnAllRegionsToClose
argument_list|()
expr_stmt|;
comment|// Make sure the proxy is down.
if|if
condition|(
name|this
operator|.
name|hbaseMaster
operator|!=
literal|null
condition|)
block|{
name|HBaseRPC
operator|.
name|stopProxy
argument_list|(
name|this
operator|.
name|hbaseMaster
argument_list|)
expr_stmt|;
name|this
operator|.
name|hbaseMaster
operator|=
literal|null
expr_stmt|;
block|}
name|this
operator|.
name|leases
operator|.
name|close
argument_list|()
expr_stmt|;
try|try
block|{
name|deleteMyEphemeralNode
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed deleting my ephemeral node"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|zooKeeper
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|killed
condition|)
block|{
name|join
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" exiting"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|boolean
name|areAllUserRegionsOffline
parameter_list|()
block|{
if|if
condition|(
name|getNumberOfOnlineRegions
argument_list|()
operator|>
literal|2
condition|)
return|return
literal|false
return|;
name|boolean
name|allUserRegionsOffline
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|HRegion
argument_list|>
name|e
range|:
name|this
operator|.
name|onlineRegions
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
name|allUserRegionsOffline
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
return|return
name|allUserRegionsOffline
return|;
block|}
end_function

begin_function
name|void
name|tryRegionServerReport
parameter_list|()
throws|throws
name|IOException
block|{
name|HServerLoad
name|hsl
init|=
name|buildServerLoad
argument_list|()
decl_stmt|;
comment|// Why we do this?
name|this
operator|.
name|requestCount
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|hbaseMaster
operator|.
name|regionServerReport
argument_list|(
name|this
operator|.
name|serverNameFromMasterPOV
operator|.
name|getBytes
argument_list|()
argument_list|,
name|hsl
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
if|if
condition|(
name|ioe
operator|instanceof
name|RemoteException
condition|)
block|{
name|ioe
operator|=
operator|(
operator|(
name|RemoteException
operator|)
name|ioe
operator|)
operator|.
name|unwrapRemoteException
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ioe
operator|instanceof
name|YouAreDeadException
condition|)
block|{
comment|// This will be caught and handled as a fatal error in run()
throw|throw
name|ioe
throw|;
block|}
comment|// Couldn't connect to the master, get location from zk and reconnect
comment|// Method blocks until new master is found or we are stopped
name|getMaster
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|HServerLoad
name|buildServerLoad
parameter_list|()
block|{
name|Collection
argument_list|<
name|HRegion
argument_list|>
name|regions
init|=
name|getOnlineRegionsLocalContext
argument_list|()
decl_stmt|;
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HServerLoad
operator|.
name|RegionLoad
argument_list|>
name|regionLoads
init|=
operator|new
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HServerLoad
operator|.
name|RegionLoad
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
for|for
control|(
name|HRegion
name|region
range|:
name|regions
control|)
block|{
name|regionLoads
operator|.
name|put
argument_list|(
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|createRegionLoad
argument_list|(
name|region
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|MemoryUsage
name|memory
init|=
name|ManagementFactory
operator|.
name|getMemoryMXBean
argument_list|()
operator|.
name|getHeapMemoryUsage
argument_list|()
decl_stmt|;
return|return
operator|new
name|HServerLoad
argument_list|(
name|requestCount
operator|.
name|get
argument_list|()
argument_list|,
call|(
name|int
call|)
argument_list|(
name|memory
operator|.
name|getUsed
argument_list|()
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|memory
operator|.
name|getMax
argument_list|()
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
argument_list|,
name|regionLoads
argument_list|)
return|;
block|}
end_function

begin_function
name|String
name|getOnlineRegionsAsPrintableString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|HRegion
name|r
range|:
name|this
operator|.
name|onlineRegions
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|r
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Wait on regions close.    */
end_comment

begin_function
specifier|private
name|void
name|waitOnAllRegionsToClose
parameter_list|()
block|{
comment|// Wait till all regions are closed before going out.
name|int
name|lastCount
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
operator|!
name|isOnlineRegionsEmpty
argument_list|()
condition|)
block|{
name|int
name|count
init|=
name|getNumberOfOnlineRegions
argument_list|()
decl_stmt|;
comment|// Only print a message if the count of regions has changed.
if|if
condition|(
name|count
operator|!=
name|lastCount
condition|)
block|{
name|lastCount
operator|=
name|count
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting on "
operator|+
name|count
operator|+
literal|" regions to close"
argument_list|)
expr_stmt|;
comment|// Only print out regions still closing if a small number else will
comment|// swamp the log.
if|if
condition|(
name|count
operator|<
literal|10
operator|&&
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|this
operator|.
name|onlineRegions
argument_list|)
expr_stmt|;
block|}
block|}
name|Threads
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|private
name|void
name|closeWAL
parameter_list|(
specifier|final
name|boolean
name|delete
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|this
operator|.
name|hlog
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|delete
condition|)
block|{
name|hlog
operator|.
name|closeAndDelete
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|hlog
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Close and delete failed"
argument_list|,
name|RemoteExceptionHandler
operator|.
name|checkThrowable
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|private
name|void
name|closeAllScanners
parameter_list|()
block|{
comment|// Close any outstanding scanners. Means they'll get an UnknownScanner
comment|// exception next time they come in.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|InternalScanner
argument_list|>
name|e
range|:
name|this
operator|.
name|scanners
operator|.
name|entrySet
argument_list|()
control|)
block|{
try|try
block|{
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Closing scanner "
operator|+
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*    * Run init. Sets up hlog and starts up all server threads.    *    * @param c Extra configuration.    */
end_comment

begin_function
specifier|protected
name|void
name|handleReportForDutyResponse
parameter_list|(
specifier|final
name|MapWritable
name|c
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Writable
argument_list|,
name|Writable
argument_list|>
name|e
range|:
name|c
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|// The hostname the master sees us as.
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
name|HConstants
operator|.
name|KEY_FOR_HOSTNAME_SEEN_BY_MASTER
argument_list|)
condition|)
block|{
name|String
name|hostnameFromMasterPOV
init|=
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|this
operator|.
name|serverNameFromMasterPOV
operator|=
operator|new
name|ServerName
argument_list|(
name|hostnameFromMasterPOV
argument_list|,
name|this
operator|.
name|isa
operator|.
name|getPort
argument_list|()
argument_list|,
name|this
operator|.
name|startcode
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Master passed us hostname to use. Was="
operator|+
name|this
operator|.
name|isa
operator|.
name|getHostName
argument_list|()
operator|+
literal|", Now="
operator|+
name|this
operator|.
name|serverNameFromMasterPOV
operator|.
name|getHostname
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|String
name|value
init|=
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Config from master: "
operator|+
name|key
operator|+
literal|"="
operator|+
name|value
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|conf
operator|.
name|set
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|// hack! Maps DFSClient => RegionServer for logs.  HDFS made this
comment|// config param for task trackers, but we can piggyback off of it.
if|if
condition|(
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
literal|"mapred.task.id"
argument_list|)
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|conf
operator|.
name|set
argument_list|(
literal|"mapred.task.id"
argument_list|,
literal|"hb_rs_"
operator|+
name|this
operator|.
name|serverNameFromMasterPOV
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Set our ephemeral znode up in zookeeper now we have a name.
name|createMyEphemeralNode
argument_list|()
expr_stmt|;
comment|// Master sent us hbase.rootdir to use. Should be fully qualified
comment|// path with file system specification included. Set 'fs.defaultFS'
comment|// to match the filesystem on hbase.rootdir else underlying hadoop hdfs
comment|// accessors will be going against wrong filesystem (unless all is set
comment|// to defaults).
name|this
operator|.
name|conf
operator|.
name|set
argument_list|(
literal|"fs.defaultFS"
argument_list|,
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.rootdir"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Get fs instance used by this RS
name|this
operator|.
name|fs
operator|=
name|FileSystem
operator|.
name|get
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|rootDir
operator|=
operator|new
name|Path
argument_list|(
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|HBASE_DIR
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableDescriptors
operator|=
operator|new
name|FSTableDescriptors
argument_list|(
name|this
operator|.
name|fs
argument_list|,
name|this
operator|.
name|rootDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|hlog
operator|=
name|setupWALAndReplication
argument_list|()
expr_stmt|;
comment|// Init in here rather than in constructor after thread name has been set
name|this
operator|.
name|metrics
operator|=
operator|new
name|RegionServerMetrics
argument_list|()
expr_stmt|;
name|startServiceThreads
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Serving as "
operator|+
name|this
operator|.
name|serverNameFromMasterPOV
operator|+
literal|", RPC listening on "
operator|+
name|this
operator|.
name|isa
operator|+
literal|", sessionid=0x"
operator|+
name|Long
operator|.
name|toHexString
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|getSessionId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|isOnline
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|this
operator|.
name|isOnline
operator|=
literal|false
expr_stmt|;
name|stop
argument_list|(
literal|"Failed initialization"
argument_list|)
expr_stmt|;
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|e
argument_list|,
literal|"Failed init"
argument_list|)
argument_list|,
literal|"Region server startup failed"
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
specifier|private
name|String
name|getMyEphemeralNodePath
parameter_list|()
block|{
return|return
name|ZKUtil
operator|.
name|joinZNode
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|rsZNode
argument_list|,
name|getServerName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
specifier|private
name|void
name|createMyEphemeralNode
parameter_list|()
throws|throws
name|KeeperException
block|{
name|ZKUtil
operator|.
name|createEphemeralNodeAndWatch
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|getMyEphemeralNodePath
argument_list|()
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|deleteMyEphemeralNode
parameter_list|()
throws|throws
name|KeeperException
block|{
name|ZKUtil
operator|.
name|deleteNode
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|getMyEphemeralNodePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|public
name|RegionServerAccounting
name|getRegionServerAccounting
parameter_list|()
block|{
return|return
name|regionServerAccounting
return|;
block|}
end_function

begin_comment
comment|/*    * @param r Region to get RegionLoad for.    *    * @return RegionLoad instance.    *    * @throws IOException    */
end_comment

begin_function
specifier|private
name|HServerLoad
operator|.
name|RegionLoad
name|createRegionLoad
parameter_list|(
specifier|final
name|HRegion
name|r
parameter_list|)
block|{
name|byte
index|[]
name|name
init|=
name|r
operator|.
name|getRegionName
argument_list|()
decl_stmt|;
name|int
name|stores
init|=
literal|0
decl_stmt|;
name|int
name|storefiles
init|=
literal|0
decl_stmt|;
name|int
name|storeUncompressedSizeMB
init|=
literal|0
decl_stmt|;
name|int
name|storefileSizeMB
init|=
literal|0
decl_stmt|;
name|int
name|memstoreSizeMB
init|=
call|(
name|int
call|)
argument_list|(
name|r
operator|.
name|memstoreSize
operator|.
name|get
argument_list|()
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
decl_stmt|;
name|int
name|storefileIndexSizeMB
init|=
literal|0
decl_stmt|;
synchronized|synchronized
init|(
name|r
operator|.
name|stores
init|)
block|{
name|stores
operator|+=
name|r
operator|.
name|stores
operator|.
name|size
argument_list|()
expr_stmt|;
for|for
control|(
name|Store
name|store
range|:
name|r
operator|.
name|stores
operator|.
name|values
argument_list|()
control|)
block|{
name|storefiles
operator|+=
name|store
operator|.
name|getStorefilesCount
argument_list|()
expr_stmt|;
name|storeUncompressedSizeMB
operator|+=
call|(
name|int
call|)
argument_list|(
name|store
operator|.
name|getStoreSizeUncompressed
argument_list|()
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|storefileSizeMB
operator|+=
call|(
name|int
call|)
argument_list|(
name|store
operator|.
name|getStorefilesSize
argument_list|()
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|storefileIndexSizeMB
operator|+=
call|(
name|int
call|)
argument_list|(
name|store
operator|.
name|getStorefilesIndexSize
argument_list|()
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|HServerLoad
operator|.
name|RegionLoad
argument_list|(
name|name
argument_list|,
name|stores
argument_list|,
name|storefiles
argument_list|,
name|storeUncompressedSizeMB
argument_list|,
name|storefileSizeMB
argument_list|,
name|memstoreSizeMB
argument_list|,
name|storefileIndexSizeMB
argument_list|,
operator|(
name|int
operator|)
name|r
operator|.
name|readRequestsCount
operator|.
name|get
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|r
operator|.
name|writeRequestsCount
operator|.
name|get
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * @param encodedRegionName    * @return An instance of RegionLoad.    * @throws IOException    */
end_comment

begin_function
specifier|public
name|HServerLoad
operator|.
name|RegionLoad
name|createRegionLoad
parameter_list|(
specifier|final
name|String
name|encodedRegionName
parameter_list|)
block|{
name|HRegion
name|r
init|=
literal|null
decl_stmt|;
name|r
operator|=
name|this
operator|.
name|onlineRegions
operator|.
name|get
argument_list|(
name|encodedRegionName
argument_list|)
expr_stmt|;
return|return
name|r
operator|!=
literal|null
condition|?
name|createRegionLoad
argument_list|(
name|r
argument_list|)
else|:
literal|null
return|;
block|}
end_function

begin_comment
comment|/*    * Cleanup after Throwable caught invoking method. Converts<code>t</code> to    * IOE if it isn't already.    *    * @param t Throwable    *    * @return Throwable converted to an IOE; methods can only let out IOEs.    */
end_comment

begin_function
specifier|private
name|Throwable
name|cleanup
parameter_list|(
specifier|final
name|Throwable
name|t
parameter_list|)
block|{
return|return
name|cleanup
argument_list|(
name|t
argument_list|,
literal|null
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*    * Cleanup after Throwable caught invoking method. Converts<code>t</code> to    * IOE if it isn't already.    *    * @param t Throwable    *    * @param msg Message to log in error. Can be null.    *    * @return Throwable converted to an IOE; methods can only let out IOEs.    */
end_comment

begin_function
specifier|private
name|Throwable
name|cleanup
parameter_list|(
specifier|final
name|Throwable
name|t
parameter_list|,
specifier|final
name|String
name|msg
parameter_list|)
block|{
comment|// Don't log as error if NSRE; NSRE is 'normal' operation.
if|if
condition|(
name|t
operator|instanceof
name|NotServingRegionException
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"NotServingRegionException; "
operator|+
name|t
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
if|if
condition|(
name|msg
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|""
argument_list|,
name|RemoteExceptionHandler
operator|.
name|checkThrowable
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|,
name|RemoteExceptionHandler
operator|.
name|checkThrowable
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|checkOOME
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|checkFileSystem
argument_list|()
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/*    * @param t    *    * @return Make<code>t</code> an IOE if it isn't already.    */
end_comment

begin_function
specifier|private
name|IOException
name|convertThrowableToIOE
parameter_list|(
specifier|final
name|Throwable
name|t
parameter_list|)
block|{
return|return
name|convertThrowableToIOE
argument_list|(
name|t
argument_list|,
literal|null
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*    * @param t    *    * @param msg Message to put in new IOE if passed<code>t</code> is not an IOE    *    * @return Make<code>t</code> an IOE if it isn't already.    */
end_comment

begin_function
specifier|private
name|IOException
name|convertThrowableToIOE
parameter_list|(
specifier|final
name|Throwable
name|t
parameter_list|,
specifier|final
name|String
name|msg
parameter_list|)
block|{
return|return
operator|(
name|t
operator|instanceof
name|IOException
condition|?
operator|(
name|IOException
operator|)
name|t
else|:
name|msg
operator|==
literal|null
operator|||
name|msg
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|?
operator|new
name|IOException
argument_list|(
name|t
argument_list|)
else|:
operator|new
name|IOException
argument_list|(
name|msg
argument_list|,
name|t
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*    * Check if an OOME and if so, call abort.    *    * @param e    *    * @return True if we OOME'd and are aborting.    */
end_comment

begin_function
specifier|public
name|boolean
name|checkOOME
parameter_list|(
specifier|final
name|Throwable
name|e
parameter_list|)
block|{
name|boolean
name|stop
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|OutOfMemoryError
operator|||
operator|(
name|e
operator|.
name|getCause
argument_list|()
operator|!=
literal|null
operator|&&
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|OutOfMemoryError
operator|)
operator|||
operator|(
name|e
operator|.
name|getMessage
argument_list|()
operator|!=
literal|null
operator|&&
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"java.lang.OutOfMemoryError"
argument_list|)
operator|)
condition|)
block|{
name|abort
argument_list|(
literal|"OutOfMemoryError, aborting"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|stop
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|stop
return|;
block|}
end_function

begin_comment
comment|/**    * Checks to see if the file system is still accessible. If not, sets    * abortRequested and stopRequested    *    * @return false if file system is not available    */
end_comment

begin_function
specifier|public
name|boolean
name|checkFileSystem
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|fsOk
operator|&&
name|this
operator|.
name|fs
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|FSUtils
operator|.
name|checkFileSystemAvailable
argument_list|(
name|this
operator|.
name|fs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|abort
argument_list|(
literal|"File System not available"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|this
operator|.
name|fsOk
operator|=
literal|false
expr_stmt|;
block|}
block|}
return|return
name|this
operator|.
name|fsOk
return|;
block|}
end_function

begin_comment
comment|/*    * Inner class that runs on a long period checking if regions need compaction.    */
end_comment

begin_class
specifier|private
specifier|static
class|class
name|CompactionChecker
extends|extends
name|Chore
block|{
specifier|private
specifier|final
name|HRegionServer
name|instance
decl_stmt|;
specifier|private
specifier|final
name|int
name|majorCompactPriority
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|int
name|DEFAULT_PRIORITY
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
name|CompactionChecker
parameter_list|(
specifier|final
name|HRegionServer
name|h
parameter_list|,
specifier|final
name|int
name|sleepTime
parameter_list|,
specifier|final
name|Stoppable
name|stopper
parameter_list|)
block|{
name|super
argument_list|(
literal|"CompactionChecker"
argument_list|,
name|sleepTime
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|this
operator|.
name|instance
operator|=
name|h
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Runs every "
operator|+
name|StringUtils
operator|.
name|formatTime
argument_list|(
name|sleepTime
argument_list|)
argument_list|)
expr_stmt|;
comment|/* MajorCompactPriority is configurable.        * If not set, the compaction will use default priority.        */
name|this
operator|.
name|majorCompactPriority
operator|=
name|this
operator|.
name|instance
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.compactionChecker.majorCompactPriority"
argument_list|,
name|DEFAULT_PRIORITY
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|chore
parameter_list|()
block|{
for|for
control|(
name|HRegion
name|r
range|:
name|this
operator|.
name|instance
operator|.
name|onlineRegions
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|r
operator|==
literal|null
condition|)
continue|continue;
for|for
control|(
name|Store
name|s
range|:
name|r
operator|.
name|getStores
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
try|try
block|{
if|if
condition|(
name|s
operator|.
name|needsCompaction
argument_list|()
condition|)
block|{
comment|// Queue a compaction. Will recognize if major is needed.
name|this
operator|.
name|instance
operator|.
name|compactSplitThread
operator|.
name|requestCompaction
argument_list|(
name|r
argument_list|,
name|s
argument_list|,
name|getName
argument_list|()
operator|+
literal|" requests compaction"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|isMajorCompaction
argument_list|()
condition|)
block|{
if|if
condition|(
name|majorCompactPriority
operator|==
name|DEFAULT_PRIORITY
operator|||
name|majorCompactPriority
operator|>
name|r
operator|.
name|getCompactPriority
argument_list|()
condition|)
block|{
name|this
operator|.
name|instance
operator|.
name|compactSplitThread
operator|.
name|requestCompaction
argument_list|(
name|r
argument_list|,
name|s
argument_list|,
name|getName
argument_list|()
operator|+
literal|" requests major compaction; use default priority"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|instance
operator|.
name|compactSplitThread
operator|.
name|requestCompaction
argument_list|(
name|r
argument_list|,
name|s
argument_list|,
name|getName
argument_list|()
operator|+
literal|" requests major compaction; use configured priority"
argument_list|,
name|this
operator|.
name|majorCompactPriority
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed major compaction check on "
operator|+
name|r
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_class

begin_comment
comment|/**    * Report the status of the server. A server is online once all the startup is    * completed (setting up filesystem, starting service threads, etc.). This    * method is designed mostly to be useful in tests.    *    * @return true if online, false if not.    */
end_comment

begin_function
specifier|public
name|boolean
name|isOnline
parameter_list|()
block|{
return|return
name|isOnline
return|;
block|}
end_function

begin_comment
comment|/**    * Setup WAL log and replication if enabled.    * Replication setup is done in here because it wants to be hooked up to WAL.    * @return A WAL instance.    * @throws IOException    */
end_comment

begin_function
specifier|private
name|HLog
name|setupWALAndReplication
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|oldLogDir
init|=
operator|new
name|Path
argument_list|(
name|rootDir
argument_list|,
name|HConstants
operator|.
name|HREGION_OLDLOGDIR_NAME
argument_list|)
decl_stmt|;
name|Path
name|logdir
init|=
operator|new
name|Path
argument_list|(
name|rootDir
argument_list|,
name|HLog
operator|.
name|getHLogDirectoryName
argument_list|(
name|this
operator|.
name|serverNameFromMasterPOV
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"logdir="
operator|+
name|logdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|fs
operator|.
name|exists
argument_list|(
name|logdir
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RegionServerRunningException
argument_list|(
literal|"Region server has already "
operator|+
literal|"created directory at "
operator|+
name|this
operator|.
name|serverNameFromMasterPOV
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
comment|// Instantiate replication manager if replication enabled.  Pass it the
comment|// log directories.
try|try
block|{
name|this
operator|.
name|replicationHandler
operator|=
name|Replication
operator|.
name|isReplication
argument_list|(
name|this
operator|.
name|conf
argument_list|)
condition|?
operator|new
name|Replication
argument_list|(
name|this
argument_list|,
name|this
operator|.
name|fs
argument_list|,
name|logdir
argument_list|,
name|oldLogDir
argument_list|)
else|:
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed replication handler create"
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|instantiateHLog
argument_list|(
name|logdir
argument_list|,
name|oldLogDir
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Called by {@link #setupWALAndReplication()} creating WAL instance.    * @param logdir    * @param oldLogDir    * @return WAL instance.    * @throws IOException    */
end_comment

begin_function
specifier|protected
name|HLog
name|instantiateHLog
parameter_list|(
name|Path
name|logdir
parameter_list|,
name|Path
name|oldLogDir
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|HLog
argument_list|(
name|this
operator|.
name|fs
argument_list|,
name|logdir
argument_list|,
name|oldLogDir
argument_list|,
name|this
operator|.
name|conf
argument_list|,
name|getWALActionListeners
argument_list|()
argument_list|,
name|this
operator|.
name|serverNameFromMasterPOV
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Called by {@link #instantiateHLog(Path, Path)} setting up WAL instance.    * Add any {@link WALObserver}s you want inserted before WAL startup.    * @return List of WALActionsListener that will be passed in to    * {@link HLog} on construction.    */
end_comment

begin_function
specifier|protected
name|List
argument_list|<
name|WALObserver
argument_list|>
name|getWALActionListeners
parameter_list|()
block|{
name|List
argument_list|<
name|WALObserver
argument_list|>
name|listeners
init|=
operator|new
name|ArrayList
argument_list|<
name|WALObserver
argument_list|>
argument_list|()
decl_stmt|;
comment|// Log roller.
name|this
operator|.
name|hlogRoller
operator|=
operator|new
name|LogRoller
argument_list|(
name|this
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|listeners
operator|.
name|add
argument_list|(
name|this
operator|.
name|hlogRoller
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|replicationHandler
operator|!=
literal|null
condition|)
block|{
comment|// Replication handler is an implementation of WALActionsListener.
name|listeners
operator|.
name|add
argument_list|(
name|this
operator|.
name|replicationHandler
argument_list|)
expr_stmt|;
block|}
return|return
name|listeners
return|;
block|}
end_function

begin_function
specifier|protected
name|LogRoller
name|getLogRoller
parameter_list|()
block|{
return|return
name|hlogRoller
return|;
block|}
end_function

begin_comment
comment|/*    * @param interval Interval since last time metrics were called.    */
end_comment

begin_function
specifier|protected
name|void
name|doMetrics
parameter_list|()
block|{
try|try
block|{
name|metrics
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed metrics"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|protected
name|void
name|metrics
parameter_list|()
block|{
name|this
operator|.
name|metrics
operator|.
name|regions
operator|.
name|set
argument_list|(
name|this
operator|.
name|onlineRegions
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|incrementRequests
argument_list|(
name|this
operator|.
name|requestCount
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
comment|// Is this too expensive every three seconds getting a lock on onlineRegions
comment|// and then per store carried? Can I make metrics be sloppier and avoid
comment|// the synchronizations?
name|int
name|stores
init|=
literal|0
decl_stmt|;
name|int
name|storefiles
init|=
literal|0
decl_stmt|;
name|long
name|memstoreSize
init|=
literal|0
decl_stmt|;
name|int
name|readRequestsCount
init|=
literal|0
decl_stmt|;
name|int
name|writeRequestsCount
init|=
literal|0
decl_stmt|;
name|long
name|storefileIndexSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|HRegion
argument_list|>
name|e
range|:
name|this
operator|.
name|onlineRegions
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|HRegion
name|r
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|memstoreSize
operator|+=
name|r
operator|.
name|memstoreSize
operator|.
name|get
argument_list|()
expr_stmt|;
name|readRequestsCount
operator|+=
name|r
operator|.
name|readRequestsCount
operator|.
name|get
argument_list|()
expr_stmt|;
name|writeRequestsCount
operator|+=
name|r
operator|.
name|writeRequestsCount
operator|.
name|get
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|r
operator|.
name|stores
init|)
block|{
name|stores
operator|+=
name|r
operator|.
name|stores
operator|.
name|size
argument_list|()
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|Store
argument_list|>
name|ee
range|:
name|r
operator|.
name|stores
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Store
name|store
init|=
name|ee
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|storefiles
operator|+=
name|store
operator|.
name|getStorefilesCount
argument_list|()
expr_stmt|;
name|storefileIndexSize
operator|+=
name|store
operator|.
name|getStorefilesIndexSize
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|this
operator|.
name|metrics
operator|.
name|stores
operator|.
name|set
argument_list|(
name|stores
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|storefiles
operator|.
name|set
argument_list|(
name|storefiles
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|memstoreSizeMB
operator|.
name|set
argument_list|(
call|(
name|int
call|)
argument_list|(
name|memstoreSize
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|readRequestsCount
operator|.
name|set
argument_list|(
name|readRequestsCount
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|writeRequestsCount
operator|.
name|set
argument_list|(
name|writeRequestsCount
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|storefileIndexSizeMB
operator|.
name|set
argument_list|(
call|(
name|int
call|)
argument_list|(
name|storefileIndexSize
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|compactionQueueSize
operator|.
name|set
argument_list|(
name|compactSplitThread
operator|.
name|getCompactionQueueSize
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|flushQueueSize
operator|.
name|set
argument_list|(
name|cacheFlusher
operator|.
name|getFlushQueueSize
argument_list|()
argument_list|)
expr_stmt|;
name|BlockCache
name|blockCache
init|=
name|StoreFile
operator|.
name|getBlockCache
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|blockCache
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|metrics
operator|.
name|blockCacheCount
operator|.
name|set
argument_list|(
name|blockCache
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|blockCacheFree
operator|.
name|set
argument_list|(
name|blockCache
operator|.
name|getFreeSize
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|blockCacheSize
operator|.
name|set
argument_list|(
name|blockCache
operator|.
name|getCurrentSize
argument_list|()
argument_list|)
expr_stmt|;
name|CacheStats
name|cacheStats
init|=
name|blockCache
operator|.
name|getStats
argument_list|()
decl_stmt|;
name|this
operator|.
name|metrics
operator|.
name|blockCacheHitCount
operator|.
name|set
argument_list|(
name|cacheStats
operator|.
name|getHitCount
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|blockCacheMissCount
operator|.
name|set
argument_list|(
name|cacheStats
operator|.
name|getMissCount
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|blockCacheEvictedCount
operator|.
name|set
argument_list|(
name|blockCache
operator|.
name|getEvictedCount
argument_list|()
argument_list|)
expr_stmt|;
name|double
name|ratio
init|=
name|blockCache
operator|.
name|getStats
argument_list|()
operator|.
name|getHitRatio
argument_list|()
decl_stmt|;
name|int
name|percent
init|=
call|(
name|int
call|)
argument_list|(
name|ratio
operator|*
literal|100
argument_list|)
decl_stmt|;
name|this
operator|.
name|metrics
operator|.
name|blockCacheHitRatio
operator|.
name|set
argument_list|(
name|percent
argument_list|)
expr_stmt|;
name|ratio
operator|=
name|blockCache
operator|.
name|getStats
argument_list|()
operator|.
name|getHitCachingRatio
argument_list|()
expr_stmt|;
name|percent
operator|=
call|(
name|int
call|)
argument_list|(
name|ratio
operator|*
literal|100
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|blockCacheHitCachingRatio
operator|.
name|set
argument_list|(
name|percent
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * @return Region server metrics instance.    */
end_comment

begin_function
specifier|public
name|RegionServerMetrics
name|getMetrics
parameter_list|()
block|{
return|return
name|this
operator|.
name|metrics
return|;
block|}
end_function

begin_comment
comment|/*    * Start maintanence Threads, Server, Worker and lease checker threads.    * Install an UncaughtExceptionHandler that calls abort of RegionServer if we    * get an unhandled exception. We cannot set the handler on all threads.    * Server's internal Listener thread is off limits. For Server, if an OOME, it    * waits a while then retries. Meantime, a flush or a compaction that tries to    * run should trigger same critical condition and the shutdown will run. On    * its way out, this server will shut down Server. Leases are sort of    * inbetween. It has an internal thread that while it inherits from Chore, it    * keeps its own internal stop mechanism so needs to be stopped by this    * hosting server. Worker logs the exception and exits.    */
end_comment

begin_function
specifier|private
name|void
name|startServiceThreads
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|n
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|UncaughtExceptionHandler
name|handler
init|=
operator|new
name|UncaughtExceptionHandler
argument_list|()
block|{
specifier|public
name|void
name|uncaughtException
parameter_list|(
name|Thread
name|t
parameter_list|,
name|Throwable
name|e
parameter_list|)
block|{
name|abort
argument_list|(
literal|"Uncaught exception in service thread "
operator|+
name|t
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
comment|// Start executor services
name|this
operator|.
name|service
operator|=
operator|new
name|ExecutorService
argument_list|(
name|getServerName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|RS_OPEN_REGION
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.executor.openregion.threads"
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|RS_OPEN_ROOT
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.executor.openroot.threads"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|RS_OPEN_META
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.executor.openmeta.threads"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|RS_CLOSE_REGION
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.executor.closeregion.threads"
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|RS_CLOSE_ROOT
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.executor.closeroot.threads"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|RS_CLOSE_META
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.executor.closemeta.threads"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|this
operator|.
name|hlogRoller
argument_list|,
name|n
operator|+
literal|".logRoller"
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|this
operator|.
name|cacheFlusher
argument_list|,
name|n
operator|+
literal|".cacheFlusher"
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|this
operator|.
name|compactionChecker
argument_list|,
name|n
operator|+
literal|".compactionChecker"
argument_list|,
name|handler
argument_list|)
expr_stmt|;
comment|// Leases is not a Thread. Internally it runs a daemon thread. If it gets
comment|// an unhandled exception, it will just exit.
name|this
operator|.
name|leases
operator|.
name|setName
argument_list|(
name|n
operator|+
literal|".leaseChecker"
argument_list|)
expr_stmt|;
name|this
operator|.
name|leases
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Put up the webui.  Webui may come up on port other than configured if
comment|// that port is occupied. Adjust serverInfo if this is the case.
name|this
operator|.
name|webuiport
operator|=
name|putUpWebUI
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|replicationHandler
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|replicationHandler
operator|.
name|startReplicationServices
argument_list|()
expr_stmt|;
block|}
comment|// Start Server.  This service is like leases in that it internally runs
comment|// a thread.
name|this
operator|.
name|rpcServer
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Create the log splitting worker and start it
name|this
operator|.
name|splitLogWorker
operator|=
operator|new
name|SplitLogWorker
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|this
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|this
operator|.
name|getServerName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|splitLogWorker
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Puts up the webui.    * @return Returns final port -- maybe different from what we started with.    * @throws IOException    */
end_comment

begin_function
specifier|private
name|int
name|putUpWebUI
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|port
init|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.info.port"
argument_list|,
literal|60030
argument_list|)
decl_stmt|;
comment|// -1 is for disabling info server
if|if
condition|(
name|port
operator|<
literal|0
condition|)
return|return
name|port
return|;
name|String
name|addr
init|=
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.regionserver.info.bindAddress"
argument_list|,
literal|"0.0.0.0"
argument_list|)
decl_stmt|;
comment|// check if auto port bind enabled
name|boolean
name|auto
init|=
name|this
operator|.
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.regionserver.info.port.auto"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|this
operator|.
name|infoServer
operator|=
operator|new
name|InfoServer
argument_list|(
literal|"regionserver"
argument_list|,
name|addr
argument_list|,
name|port
argument_list|,
literal|false
argument_list|,
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|addServlet
argument_list|(
literal|"status"
argument_list|,
literal|"/rs-status"
argument_list|,
name|RSStatusServlet
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|setAttribute
argument_list|(
name|REGIONSERVER
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|start
argument_list|()
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|BindException
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|auto
condition|)
block|{
comment|// auto bind disabled throw BindException
throw|throw
name|e
throw|;
block|}
comment|// auto bind enabled, try to use another port
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed binding http info server to port: "
operator|+
name|port
argument_list|)
expr_stmt|;
name|port
operator|++
expr_stmt|;
block|}
block|}
return|return
name|port
return|;
block|}
end_function

begin_comment
comment|/*    * Verify that server is healthy    */
end_comment

begin_function
specifier|private
name|boolean
name|isHealthy
parameter_list|()
block|{
if|if
condition|(
operator|!
name|fsOk
condition|)
block|{
comment|// File system problem
return|return
literal|false
return|;
block|}
comment|// Verify that all threads are alive
if|if
condition|(
operator|!
operator|(
name|leases
operator|.
name|isAlive
argument_list|()
operator|&&
name|cacheFlusher
operator|.
name|isAlive
argument_list|()
operator|&&
name|hlogRoller
operator|.
name|isAlive
argument_list|()
operator|&&
name|this
operator|.
name|compactionChecker
operator|.
name|isAlive
argument_list|()
operator|)
condition|)
block|{
name|stop
argument_list|(
literal|"One or more threads are no longer alive -- stop"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|HLog
name|getWAL
parameter_list|()
block|{
return|return
name|this
operator|.
name|hlog
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|CatalogTracker
name|getCatalogTracker
parameter_list|()
block|{
return|return
name|this
operator|.
name|catalogTracker
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|stop
parameter_list|(
specifier|final
name|String
name|msg
parameter_list|)
block|{
name|this
operator|.
name|stopped
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"STOPPED: "
operator|+
name|msg
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// Wakes run() if it is sleeping
name|notifyAll
argument_list|()
expr_stmt|;
comment|// FindBugs NN_NAKED_NOTIFY
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|postOpenDeployTasks
parameter_list|(
specifier|final
name|HRegion
name|r
parameter_list|,
specifier|final
name|CatalogTracker
name|ct
parameter_list|,
specifier|final
name|boolean
name|daughter
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Post open deploy tasks for region="
operator|+
name|r
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", daughter="
operator|+
name|daughter
argument_list|)
expr_stmt|;
comment|// Do checks to see if we need to compact (references or too many files)
for|for
control|(
name|Store
name|s
range|:
name|r
operator|.
name|getStores
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|s
operator|.
name|hasReferences
argument_list|()
operator|||
name|s
operator|.
name|needsCompaction
argument_list|()
condition|)
block|{
name|getCompactionRequester
argument_list|()
operator|.
name|requestCompaction
argument_list|(
name|r
argument_list|,
name|s
argument_list|,
literal|"Opening Region"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Add to online regions if all above was successful.
name|addToOnlineRegions
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"addToOnlineRegions is done"
operator|+
name|r
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
comment|// Update ZK, ROOT or META
if|if
condition|(
name|r
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isRootRegion
argument_list|()
condition|)
block|{
name|RootLocationEditor
operator|.
name|setRootLocation
argument_list|(
name|getZooKeeper
argument_list|()
argument_list|,
name|this
operator|.
name|serverNameFromMasterPOV
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
name|MetaEditor
operator|.
name|updateMetaLocation
argument_list|(
name|ct
argument_list|,
name|r
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|this
operator|.
name|serverNameFromMasterPOV
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|daughter
condition|)
block|{
comment|// If daughter of a split, update whole row, not just location.
name|MetaEditor
operator|.
name|addDaughter
argument_list|(
name|ct
argument_list|,
name|r
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|this
operator|.
name|serverNameFromMasterPOV
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MetaEditor
operator|.
name|updateRegionLocation
argument_list|(
name|ct
argument_list|,
name|r
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|this
operator|.
name|serverNameFromMasterPOV
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Done with post open deploy taks for region="
operator|+
name|r
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", daughter="
operator|+
name|daughter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Return a reference to the metrics instance used for counting RPC calls.    * @return Metrics instance.    */
end_comment

begin_function
specifier|public
name|HBaseRpcMetrics
name|getRpcMetrics
parameter_list|()
block|{
return|return
name|rpcServer
operator|.
name|getRpcMetrics
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Cause the server to exit without closing the regions it is serving, the log    * it is using and without notifying the master. Used unit testing and on    * catastrophic events such as HDFS is yanked out from under hbase or we OOME.    *    * @param reason    *          the reason we are aborting    * @param cause    *          the exception that caused the abort, or null    */
end_comment

begin_function
specifier|public
name|void
name|abort
parameter_list|(
name|String
name|reason
parameter_list|,
name|Throwable
name|cause
parameter_list|)
block|{
if|if
condition|(
name|cause
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"ABORTING region server "
operator|+
name|this
operator|+
literal|": "
operator|+
name|reason
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"ABORTING region server "
operator|+
name|this
operator|+
literal|": "
operator|+
name|reason
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|abortRequested
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|reservedSpace
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|metrics
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Dump of metrics: "
operator|+
name|this
operator|.
name|metrics
argument_list|)
expr_stmt|;
block|}
name|stop
argument_list|(
name|reason
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * @see HRegionServer#abort(String, Throwable)    */
end_comment

begin_function
specifier|public
name|void
name|abort
parameter_list|(
name|String
name|reason
parameter_list|)
block|{
name|abort
argument_list|(
name|reason
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*    * Simulate a kill -9 of this server. Exits w/o closing regions or cleaninup    * logs but it does close socket in case want to bring up server on old    * hostname+port immediately.    */
end_comment

begin_function
specifier|protected
name|void
name|kill
parameter_list|()
block|{
name|this
operator|.
name|killed
operator|=
literal|true
expr_stmt|;
name|abort
argument_list|(
literal|"Simulated kill"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Wait on all threads to finish. Presumption is that all closes and stops    * have already been called.    */
end_comment

begin_function
specifier|protected
name|void
name|join
parameter_list|()
block|{
name|Threads
operator|.
name|shutdown
argument_list|(
name|this
operator|.
name|compactionChecker
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|shutdown
argument_list|(
name|this
operator|.
name|cacheFlusher
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|shutdown
argument_list|(
name|this
operator|.
name|hlogRoller
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|compactSplitThread
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|compactSplitThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|service
operator|!=
literal|null
condition|)
name|this
operator|.
name|service
operator|.
name|shutdown
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|replicationHandler
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|replicationHandler
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * Get the current master from ZooKeeper and open the RPC connection to it.    *    * Method will block until a master is available. You can break from this    * block by requesting the server stop.    *    * @return master + port, or null if server has been stopped    */
end_comment

begin_function
specifier|private
name|ServerName
name|getMaster
parameter_list|()
block|{
name|ServerName
name|masterServerName
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|(
name|masterServerName
operator|=
name|this
operator|.
name|masterAddressManager
operator|.
name|getMasterAddress
argument_list|()
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|keepLooping
argument_list|()
condition|)
return|return
literal|null
return|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"No master found; retry"
argument_list|)
expr_stmt|;
name|sleeper
operator|.
name|sleep
argument_list|()
expr_stmt|;
block|}
name|InetSocketAddress
name|isa
init|=
operator|new
name|InetSocketAddress
argument_list|(
name|masterServerName
operator|.
name|getHostname
argument_list|()
argument_list|,
name|masterServerName
operator|.
name|getPort
argument_list|()
argument_list|)
decl_stmt|;
name|HMasterRegionInterface
name|master
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|keepLooping
argument_list|()
operator|&&
name|master
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Attempting connect to Master server at "
operator|+
name|this
operator|.
name|masterAddressManager
operator|.
name|getMasterAddress
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
comment|// Do initial RPC setup. The final argument indicates that the RPC
comment|// should retry indefinitely.
name|master
operator|=
operator|(
name|HMasterRegionInterface
operator|)
name|HBaseRPC
operator|.
name|waitForProxy
argument_list|(
name|HMasterRegionInterface
operator|.
name|class
argument_list|,
name|HMasterRegionInterface
operator|.
name|VERSION
argument_list|,
name|isa
argument_list|,
name|this
operator|.
name|conf
argument_list|,
operator|-
literal|1
argument_list|,
name|this
operator|.
name|rpcTimeout
argument_list|,
name|this
operator|.
name|rpcTimeout
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|=
name|e
operator|instanceof
name|RemoteException
condition|?
operator|(
operator|(
name|RemoteException
operator|)
name|e
operator|)
operator|.
name|unwrapRemoteException
argument_list|()
else|:
name|e
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|ServerNotRunningYetException
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Master isn't available yet, retrying"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to connect to master. Retrying. Error was:"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|sleeper
operator|.
name|sleep
argument_list|()
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Connected to master at "
operator|+
name|isa
argument_list|)
expr_stmt|;
name|this
operator|.
name|hbaseMaster
operator|=
name|master
expr_stmt|;
return|return
name|masterServerName
return|;
block|}
end_function

begin_comment
comment|/**    * @return True if we should break loop because cluster is going down or    * this server has been stopped or hdfs has gone bad.    */
end_comment

begin_function
specifier|private
name|boolean
name|keepLooping
parameter_list|()
block|{
return|return
operator|!
name|this
operator|.
name|stopped
operator|&&
name|isClusterUp
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/*    * Let the master know we're here Run initialization using parameters passed    * us by the master.    * @return A Map of key/value configurations we got from the Master else    * null if we failed to register.    * @throws IOException    */
end_comment

begin_function
specifier|private
name|MapWritable
name|reportForDuty
parameter_list|()
throws|throws
name|IOException
block|{
name|MapWritable
name|result
init|=
literal|null
decl_stmt|;
name|ServerName
name|masterServerName
init|=
name|getMaster
argument_list|()
decl_stmt|;
if|if
condition|(
name|masterServerName
operator|==
literal|null
condition|)
return|return
name|result
return|;
try|try
block|{
name|this
operator|.
name|requestCount
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Telling master at "
operator|+
name|masterServerName
operator|+
literal|" that we are up "
operator|+
literal|"with port="
operator|+
name|this
operator|.
name|isa
operator|.
name|getPort
argument_list|()
operator|+
literal|", startcode="
operator|+
name|this
operator|.
name|startcode
argument_list|)
expr_stmt|;
name|long
name|now
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|int
name|port
init|=
name|this
operator|.
name|isa
operator|.
name|getPort
argument_list|()
decl_stmt|;
name|result
operator|=
name|this
operator|.
name|hbaseMaster
operator|.
name|regionServerStartup
argument_list|(
name|port
argument_list|,
name|this
operator|.
name|startcode
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
name|IOException
name|ioe
init|=
name|e
operator|.
name|unwrapRemoteException
argument_list|()
decl_stmt|;
if|if
condition|(
name|ioe
operator|instanceof
name|ClockOutOfSyncException
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Master rejected startup because clock is out of sync"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
comment|// Re-throw IOE will cause RS to abort
throw|throw
name|ioe
throw|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"remote error telling master we are up"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"error telling master we are up"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**    * Closes all regions.  Called on our way out.    * Assumes that its not possible for new regions to be added to onlineRegions    * while this method runs.    */
end_comment

begin_function
specifier|protected
name|void
name|closeAllRegions
parameter_list|(
specifier|final
name|boolean
name|abort
parameter_list|)
block|{
name|closeUserRegions
argument_list|(
name|abort
argument_list|)
expr_stmt|;
comment|// Only root and meta should remain.  Are we carrying root or meta?
name|HRegion
name|meta
init|=
literal|null
decl_stmt|;
name|HRegion
name|root
init|=
literal|null
decl_stmt|;
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|HRegion
argument_list|>
name|e
range|:
name|onlineRegions
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|HRegionInfo
name|hri
init|=
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|hri
operator|.
name|isRootRegion
argument_list|()
condition|)
block|{
name|root
operator|=
name|e
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hri
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
name|meta
operator|=
name|e
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|meta
operator|!=
literal|null
operator|&&
name|root
operator|!=
literal|null
condition|)
break|break;
block|}
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|meta
operator|!=
literal|null
condition|)
name|closeRegion
argument_list|(
name|meta
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|abort
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|!=
literal|null
condition|)
name|closeRegion
argument_list|(
name|root
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|abort
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Schedule closes on all user regions.    * @param abort Whether we're running an abort.    */
end_comment

begin_function
name|void
name|closeUserRegions
parameter_list|(
specifier|final
name|boolean
name|abort
parameter_list|)
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|HRegion
argument_list|>
name|e
range|:
name|this
operator|.
name|onlineRegions
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|HRegion
name|r
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|r
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
comment|// Don't update zk with this close transition; pass false.
name|closeRegion
argument_list|(
name|r
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|abort
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
annotation|@
name|QosPriority
argument_list|(
name|priority
operator|=
name|HIGH_QOS
argument_list|)
specifier|public
name|HRegionInfo
name|getRegionInfo
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|NotServingRegionException
throws|,
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return
name|getRegion
argument_list|(
name|regionName
argument_list|)
operator|.
name|getRegionInfo
argument_list|()
return|;
block|}
end_function

begin_function
specifier|public
name|Result
name|getClosestRowBefore
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
comment|// locate the region we're operating on
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
comment|// ask the region for all the data
name|Result
name|r
init|=
name|region
operator|.
name|getClosestRowBefore
argument_list|(
name|row
argument_list|,
name|family
argument_list|)
decl_stmt|;
return|return
name|r
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
end_function

begin_comment
comment|/** {@inheritDoc} */
end_comment

begin_function
specifier|public
name|Result
name|get
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|,
name|Get
name|get
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
return|return
name|region
operator|.
name|get
argument_list|(
name|get
argument_list|,
name|getLockFromId
argument_list|(
name|get
operator|.
name|getLockId
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
specifier|public
name|boolean
name|exists
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|,
name|Get
name|get
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|Integer
name|lock
init|=
name|getLockFromId
argument_list|(
name|get
operator|.
name|getLockId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|Boolean
name|result
init|=
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|.
name|preExists
argument_list|(
name|get
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
return|return
name|result
operator|.
name|booleanValue
argument_list|()
return|;
block|}
block|}
name|Result
name|r
init|=
name|region
operator|.
name|get
argument_list|(
name|get
argument_list|,
name|lock
argument_list|)
decl_stmt|;
name|boolean
name|result
init|=
name|r
operator|!=
literal|null
operator|&&
operator|!
name|r
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
if|if
condition|(
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|.
name|postExists
argument_list|(
name|get
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
specifier|public
name|void
name|put
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|Put
name|put
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|put
operator|.
name|getRow
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"update has null row"
argument_list|)
throw|;
block|}
name|checkOpen
argument_list|()
expr_stmt|;
name|this
operator|.
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isMetaTable
argument_list|()
condition|)
block|{
name|this
operator|.
name|cacheFlusher
operator|.
name|reclaimMemStoreMemory
argument_list|()
expr_stmt|;
block|}
name|boolean
name|writeToWAL
init|=
name|put
operator|.
name|getWriteToWAL
argument_list|()
decl_stmt|;
name|region
operator|.
name|put
argument_list|(
name|put
argument_list|,
name|getLockFromId
argument_list|(
name|put
operator|.
name|getLockId
argument_list|()
argument_list|)
argument_list|,
name|writeToWAL
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
specifier|public
name|int
name|put
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|List
argument_list|<
name|Put
argument_list|>
name|puts
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|HRegion
name|region
init|=
literal|null
decl_stmt|;
try|try
block|{
name|region
operator|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isMetaTable
argument_list|()
condition|)
block|{
name|this
operator|.
name|cacheFlusher
operator|.
name|reclaimMemStoreMemory
argument_list|()
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Pair
argument_list|<
name|Put
argument_list|,
name|Integer
argument_list|>
index|[]
name|putsWithLocks
init|=
operator|new
name|Pair
index|[
name|puts
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Put
name|p
range|:
name|puts
control|)
block|{
name|Integer
name|lock
init|=
name|getLockFromId
argument_list|(
name|p
operator|.
name|getLockId
argument_list|()
argument_list|)
decl_stmt|;
name|putsWithLocks
index|[
name|i
operator|++
index|]
operator|=
operator|new
name|Pair
argument_list|<
name|Put
argument_list|,
name|Integer
argument_list|>
argument_list|(
name|p
argument_list|,
name|lock
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|requestCount
operator|.
name|addAndGet
argument_list|(
name|puts
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|OperationStatusCode
index|[]
name|codes
init|=
name|region
operator|.
name|put
argument_list|(
name|putsWithLocks
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|codes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|codes
index|[
name|i
index|]
operator|!=
name|OperationStatusCode
operator|.
name|SUCCESS
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
specifier|private
name|boolean
name|checkAndMutate
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|CompareOp
name|compareOp
parameter_list|,
specifier|final
name|WritableByteArrayComparable
name|comparator
parameter_list|,
specifier|final
name|Writable
name|w
parameter_list|,
name|Integer
name|lock
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|this
operator|.
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isMetaTable
argument_list|()
condition|)
block|{
name|this
operator|.
name|cacheFlusher
operator|.
name|reclaimMemStoreMemory
argument_list|()
expr_stmt|;
block|}
return|return
name|region
operator|.
name|checkAndMutate
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|compareOp
argument_list|,
name|comparator
argument_list|,
name|w
argument_list|,
name|lock
argument_list|,
literal|true
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
end_function

begin_comment
comment|/**    *    * @param regionName    * @param row    * @param family    * @param qualifier    * @param value    *          the expected value    * @param put    * @throws IOException    * @return true if the new put was execute, false otherwise    */
end_comment

begin_function
specifier|public
name|boolean
name|checkAndPut
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|Put
name|put
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|regionName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid arguments to checkAndPut "
operator|+
literal|"regionName is null"
argument_list|)
throw|;
block|}
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|Integer
name|lock
init|=
name|getLockFromId
argument_list|(
name|put
operator|.
name|getLockId
argument_list|()
argument_list|)
decl_stmt|;
name|WritableByteArrayComparable
name|comparator
init|=
operator|new
name|BinaryComparator
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|Boolean
name|result
init|=
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|.
name|preCheckAndPut
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|CompareOp
operator|.
name|EQUAL
argument_list|,
name|comparator
argument_list|,
name|put
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
return|return
name|result
operator|.
name|booleanValue
argument_list|()
return|;
block|}
block|}
name|boolean
name|result
init|=
name|checkAndMutate
argument_list|(
name|regionName
argument_list|,
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|CompareOp
operator|.
name|EQUAL
argument_list|,
operator|new
name|BinaryComparator
argument_list|(
name|value
argument_list|)
argument_list|,
name|put
argument_list|,
name|lock
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|.
name|postCheckAndPut
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|CompareOp
operator|.
name|EQUAL
argument_list|,
name|comparator
argument_list|,
name|put
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**    *    * @param regionName    * @param row    * @param family    * @param qualifier    * @param compareOp    * @param comparator    * @param put    * @throws IOException    * @return true if the new put was execute, false otherwise    */
end_comment

begin_function
specifier|public
name|boolean
name|checkAndPut
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|CompareOp
name|compareOp
parameter_list|,
specifier|final
name|WritableByteArrayComparable
name|comparator
parameter_list|,
specifier|final
name|Put
name|put
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|regionName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid arguments to checkAndPut "
operator|+
literal|"regionName is null"
argument_list|)
throw|;
block|}
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|Integer
name|lock
init|=
name|getLockFromId
argument_list|(
name|put
operator|.
name|getLockId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|Boolean
name|result
init|=
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|.
name|preCheckAndPut
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|compareOp
argument_list|,
name|comparator
argument_list|,
name|put
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
return|return
name|result
operator|.
name|booleanValue
argument_list|()
return|;
block|}
block|}
name|boolean
name|result
init|=
name|checkAndMutate
argument_list|(
name|regionName
argument_list|,
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|compareOp
argument_list|,
name|comparator
argument_list|,
name|put
argument_list|,
name|lock
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|.
name|postCheckAndPut
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|compareOp
argument_list|,
name|comparator
argument_list|,
name|put
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**    *    * @param regionName    * @param row    * @param family    * @param qualifier    * @param value    *          the expected value    * @param delete    * @throws IOException    * @return true if the new put was execute, false otherwise    */
end_comment

begin_function
specifier|public
name|boolean
name|checkAndDelete
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|Delete
name|delete
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|regionName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid arguments to checkAndDelete "
operator|+
literal|"regionName is null"
argument_list|)
throw|;
block|}
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|Integer
name|lock
init|=
name|getLockFromId
argument_list|(
name|delete
operator|.
name|getLockId
argument_list|()
argument_list|)
decl_stmt|;
name|WritableByteArrayComparable
name|comparator
init|=
operator|new
name|BinaryComparator
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|Boolean
name|result
init|=
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|.
name|preCheckAndDelete
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|CompareOp
operator|.
name|EQUAL
argument_list|,
name|comparator
argument_list|,
name|delete
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
return|return
name|result
operator|.
name|booleanValue
argument_list|()
return|;
block|}
block|}
name|boolean
name|result
init|=
name|checkAndMutate
argument_list|(
name|regionName
argument_list|,
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|CompareOp
operator|.
name|EQUAL
argument_list|,
name|comparator
argument_list|,
name|delete
argument_list|,
name|lock
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|.
name|postCheckAndDelete
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|CompareOp
operator|.
name|EQUAL
argument_list|,
name|comparator
argument_list|,
name|delete
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**    *    * @param regionName    * @param row    * @param family    * @param qualifier    * @param compareOp    * @param comparator    * @param delete    * @throws IOException    * @return true if the new put was execute, false otherwise    */
end_comment

begin_function
specifier|public
name|boolean
name|checkAndDelete
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|CompareOp
name|compareOp
parameter_list|,
specifier|final
name|WritableByteArrayComparable
name|comparator
parameter_list|,
specifier|final
name|Delete
name|delete
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|regionName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid arguments to checkAndDelete "
operator|+
literal|"regionName is null"
argument_list|)
throw|;
block|}
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|Integer
name|lock
init|=
name|getLockFromId
argument_list|(
name|delete
operator|.
name|getLockId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|Boolean
name|result
init|=
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|.
name|preCheckAndDelete
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|compareOp
argument_list|,
name|comparator
argument_list|,
name|delete
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
return|return
name|result
operator|.
name|booleanValue
argument_list|()
return|;
block|}
block|}
name|boolean
name|result
init|=
name|checkAndMutate
argument_list|(
name|regionName
argument_list|,
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|compareOp
argument_list|,
name|comparator
argument_list|,
name|delete
argument_list|,
name|lock
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|.
name|postCheckAndDelete
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|compareOp
argument_list|,
name|comparator
argument_list|,
name|delete
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|//
end_comment

begin_comment
comment|// remote scanner interface
end_comment

begin_comment
comment|//
end_comment

begin_function
specifier|public
name|long
name|openScanner
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|,
name|Scan
name|scan
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|NullPointerException
name|npe
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|regionName
operator|==
literal|null
condition|)
block|{
name|npe
operator|=
operator|new
name|NullPointerException
argument_list|(
literal|"regionName is null"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scan
operator|==
literal|null
condition|)
block|{
name|npe
operator|=
operator|new
name|NullPointerException
argument_list|(
literal|"scan is null"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|npe
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid arguments to openScanner"
argument_list|,
name|npe
argument_list|)
throw|;
block|}
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|r
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|r
operator|.
name|prepareScanner
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|InternalScanner
name|s
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|getCoprocessorHost
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|s
operator|=
name|r
operator|.
name|getCoprocessorHost
argument_list|()
operator|.
name|preScannerOpen
argument_list|(
name|scan
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
name|s
operator|=
name|r
operator|.
name|getScanner
argument_list|(
name|scan
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|.
name|getCoprocessorHost
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|s
operator|=
name|r
operator|.
name|getCoprocessorHost
argument_list|()
operator|.
name|postScannerOpen
argument_list|(
name|scan
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|addScanner
argument_list|(
name|s
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|,
literal|"Failed openScanner"
argument_list|)
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
specifier|protected
name|long
name|addScanner
parameter_list|(
name|InternalScanner
name|s
parameter_list|)
throws|throws
name|LeaseStillHeldException
block|{
name|long
name|scannerId
init|=
operator|-
literal|1L
decl_stmt|;
name|scannerId
operator|=
name|rand
operator|.
name|nextLong
argument_list|()
expr_stmt|;
name|String
name|scannerName
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
name|scanners
operator|.
name|put
argument_list|(
name|scannerName
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|this
operator|.
name|leases
operator|.
name|createLease
argument_list|(
name|scannerName
argument_list|,
operator|new
name|ScannerListener
argument_list|(
name|scannerName
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|scannerId
return|;
block|}
end_function

begin_function
specifier|public
name|Result
name|next
parameter_list|(
specifier|final
name|long
name|scannerId
parameter_list|)
throws|throws
name|IOException
block|{
name|Result
index|[]
name|res
init|=
name|next
argument_list|(
name|scannerId
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
literal|null
operator|||
name|res
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|res
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
specifier|public
name|Result
index|[]
name|next
parameter_list|(
specifier|final
name|long
name|scannerId
parameter_list|,
name|int
name|nbRows
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|scannerName
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
name|InternalScanner
name|s
init|=
name|this
operator|.
name|scanners
operator|.
name|get
argument_list|(
name|scannerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
throw|throw
operator|new
name|UnknownScannerException
argument_list|(
literal|"Name: "
operator|+
name|scannerName
argument_list|)
throw|;
try|try
block|{
name|checkOpen
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// If checkOpen failed, server not running or filesystem gone,
comment|// cancel this lease; filesystem is gone or we're closing or something.
try|try
block|{
name|this
operator|.
name|leases
operator|.
name|cancelLease
argument_list|(
name|scannerName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LeaseException
name|le
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Server shutting down and client tried to access missing scanner "
operator|+
name|scannerName
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
name|Leases
operator|.
name|Lease
name|lease
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// Remove lease while its being processed in server; protects against case
comment|// where processing of request takes> lease expiration time.
name|lease
operator|=
name|this
operator|.
name|leases
operator|.
name|removeLease
argument_list|(
name|scannerName
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Result
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|Result
argument_list|>
argument_list|(
name|nbRows
argument_list|)
decl_stmt|;
name|long
name|currentScanResultSize
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|KeyValue
argument_list|>
name|values
init|=
operator|new
name|ArrayList
argument_list|<
name|KeyValue
argument_list|>
argument_list|()
decl_stmt|;
comment|// Call coprocessor. Get region info from scanner.
name|HRegion
name|region
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|s
operator|instanceof
name|HRegion
operator|.
name|RegionScanner
condition|)
block|{
name|HRegion
operator|.
name|RegionScanner
name|rs
init|=
operator|(
name|HRegion
operator|.
name|RegionScanner
operator|)
name|s
decl_stmt|;
name|region
operator|=
name|getRegion
argument_list|(
name|rs
operator|.
name|getRegionName
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"InternalScanner implementation is expected "
operator|+
literal|"to be HRegion.RegionScanner."
argument_list|)
throw|;
block|}
if|if
condition|(
name|region
operator|!=
literal|null
operator|&&
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|Boolean
name|bypass
init|=
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|.
name|preScannerNext
argument_list|(
name|s
argument_list|,
name|results
argument_list|,
name|nbRows
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|results
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Result
name|r
range|:
name|results
control|)
block|{
for|for
control|(
name|KeyValue
name|kv
range|:
name|r
operator|.
name|raw
argument_list|()
control|)
block|{
name|currentScanResultSize
operator|+=
name|kv
operator|.
name|heapSize
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|bypass
operator|!=
literal|null
condition|)
block|{
return|return
operator|(
operator|(
name|HRegion
operator|.
name|RegionScanner
operator|)
name|s
operator|)
operator|.
name|isFilterDone
argument_list|()
operator|&&
name|results
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|results
operator|.
name|toArray
argument_list|(
operator|new
name|Result
index|[
literal|0
index|]
argument_list|)
return|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nbRows
operator|&&
name|currentScanResultSize
operator|<
name|maxScannerResultSize
condition|;
name|i
operator|++
control|)
block|{
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
comment|// Collect values to be returned here
name|boolean
name|moreRows
init|=
name|s
operator|.
name|next
argument_list|(
name|values
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|values
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|KeyValue
name|kv
range|:
name|values
control|)
block|{
name|currentScanResultSize
operator|+=
name|kv
operator|.
name|heapSize
argument_list|()
expr_stmt|;
block|}
name|results
operator|.
name|add
argument_list|(
operator|new
name|Result
argument_list|(
name|values
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|moreRows
condition|)
block|{
break|break;
block|}
name|values
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|// coprocessor postNext hook
if|if
condition|(
name|region
operator|!=
literal|null
operator|&&
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|.
name|postScannerNext
argument_list|(
name|s
argument_list|,
name|results
argument_list|,
name|nbRows
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// Below is an ugly hack where we cast the InternalScanner to be a
comment|// HRegion.RegionScanner. The alternative is to change InternalScanner
comment|// interface but its used everywhere whereas we just need a bit of info
comment|// from HRegion.RegionScanner, IF its filter if any is done with the scan
comment|// and wants to tell the client to stop the scan. This is done by passing
comment|// a null result.
return|return
operator|(
operator|(
name|HRegion
operator|.
name|RegionScanner
operator|)
name|s
operator|)
operator|.
name|isFilterDone
argument_list|()
operator|&&
name|results
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|results
operator|.
name|toArray
argument_list|(
operator|new
name|Result
index|[
literal|0
index|]
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|NotServingRegionException
condition|)
block|{
name|this
operator|.
name|scanners
operator|.
name|remove
argument_list|(
name|scannerName
argument_list|)
expr_stmt|;
block|}
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
finally|finally
block|{
comment|// We're done. On way out readd the above removed lease.  Adding resets
comment|// expiration time on lease.
if|if
condition|(
name|this
operator|.
name|scanners
operator|.
name|containsKey
argument_list|(
name|scannerName
argument_list|)
condition|)
block|{
if|if
condition|(
name|lease
operator|!=
literal|null
condition|)
name|this
operator|.
name|leases
operator|.
name|addLease
argument_list|(
name|lease
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|public
name|void
name|close
parameter_list|(
specifier|final
name|long
name|scannerId
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|String
name|scannerName
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
name|InternalScanner
name|s
init|=
name|scanners
operator|.
name|get
argument_list|(
name|scannerName
argument_list|)
decl_stmt|;
name|HRegion
name|region
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
comment|// call coprocessor.
if|if
condition|(
name|s
operator|instanceof
name|HRegion
operator|.
name|RegionScanner
condition|)
block|{
name|HRegion
operator|.
name|RegionScanner
name|rs
init|=
operator|(
name|HRegion
operator|.
name|RegionScanner
operator|)
name|s
decl_stmt|;
name|region
operator|=
name|getRegion
argument_list|(
name|rs
operator|.
name|getRegionName
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"InternalScanner implementation is expected "
operator|+
literal|"to be HRegion.RegionScanner."
argument_list|)
throw|;
block|}
if|if
condition|(
name|region
operator|!=
literal|null
operator|&&
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|.
name|preScannerClose
argument_list|(
name|s
argument_list|)
condition|)
block|{
return|return;
comment|// bypass
block|}
block|}
block|}
name|s
operator|=
name|scanners
operator|.
name|remove
argument_list|(
name|scannerName
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|close
argument_list|()
expr_stmt|;
name|this
operator|.
name|leases
operator|.
name|cancelLease
argument_list|(
name|scannerName
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|!=
literal|null
operator|&&
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|.
name|postScannerClose
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
end_function

begin_comment
comment|/**    * Instantiated as a scanner lease. If the lease times out, the scanner is    * closed    */
end_comment

begin_class
specifier|private
class|class
name|ScannerListener
implements|implements
name|LeaseListener
block|{
specifier|private
specifier|final
name|String
name|scannerName
decl_stmt|;
name|ScannerListener
parameter_list|(
specifier|final
name|String
name|n
parameter_list|)
block|{
name|this
operator|.
name|scannerName
operator|=
name|n
expr_stmt|;
block|}
specifier|public
name|void
name|leaseExpired
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Scanner "
operator|+
name|this
operator|.
name|scannerName
operator|+
literal|" lease expired"
argument_list|)
expr_stmt|;
name|InternalScanner
name|s
init|=
name|scanners
operator|.
name|remove
argument_list|(
name|this
operator|.
name|scannerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|s
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Closing scanner"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

begin_comment
comment|//
end_comment

begin_comment
comment|// Methods that do the actual work for the remote API
end_comment

begin_comment
comment|//
end_comment

begin_function
specifier|public
name|void
name|delete
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|Delete
name|delete
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
try|try
block|{
name|boolean
name|writeToWAL
init|=
name|delete
operator|.
name|getWriteToWAL
argument_list|()
decl_stmt|;
name|this
operator|.
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isMetaTable
argument_list|()
condition|)
block|{
name|this
operator|.
name|cacheFlusher
operator|.
name|reclaimMemStoreMemory
argument_list|()
expr_stmt|;
block|}
name|Integer
name|lid
init|=
name|getLockFromId
argument_list|(
name|delete
operator|.
name|getLockId
argument_list|()
argument_list|)
decl_stmt|;
name|region
operator|.
name|delete
argument_list|(
name|delete
argument_list|,
name|lid
argument_list|,
name|writeToWAL
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
specifier|public
name|int
name|delete
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|List
argument_list|<
name|Delete
argument_list|>
name|deletes
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
comment|// Count of Deletes processed.
name|int
name|i
init|=
literal|0
decl_stmt|;
name|HRegion
name|region
init|=
literal|null
decl_stmt|;
try|try
block|{
name|region
operator|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isMetaTable
argument_list|()
condition|)
block|{
name|this
operator|.
name|cacheFlusher
operator|.
name|reclaimMemStoreMemory
argument_list|()
expr_stmt|;
block|}
name|int
name|size
init|=
name|deletes
operator|.
name|size
argument_list|()
decl_stmt|;
name|Integer
index|[]
name|locks
init|=
operator|new
name|Integer
index|[
name|size
index|]
decl_stmt|;
for|for
control|(
name|Delete
name|delete
range|:
name|deletes
control|)
block|{
name|this
operator|.
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|locks
index|[
name|i
index|]
operator|=
name|getLockFromId
argument_list|(
name|delete
operator|.
name|getLockId
argument_list|()
argument_list|)
expr_stmt|;
name|region
operator|.
name|delete
argument_list|(
name|delete
argument_list|,
name|locks
index|[
name|i
index|]
argument_list|,
name|delete
operator|.
name|getWriteToWAL
argument_list|()
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|WrongRegionException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Batch deletes: "
operator|+
name|i
argument_list|,
name|ex
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
catch|catch
parameter_list|(
name|NotServingRegionException
name|ex
parameter_list|)
block|{
return|return
name|i
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|public
name|long
name|lockRow
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|,
name|byte
index|[]
name|row
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|NullPointerException
name|npe
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|regionName
operator|==
literal|null
condition|)
block|{
name|npe
operator|=
operator|new
name|NullPointerException
argument_list|(
literal|"regionName is null"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|row
operator|==
literal|null
condition|)
block|{
name|npe
operator|=
operator|new
name|NullPointerException
argument_list|(
literal|"row to lock is null"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|npe
operator|!=
literal|null
condition|)
block|{
name|IOException
name|io
init|=
operator|new
name|IOException
argument_list|(
literal|"Invalid arguments to lockRow"
argument_list|)
decl_stmt|;
name|io
operator|.
name|initCause
argument_list|(
name|npe
argument_list|)
expr_stmt|;
throw|throw
name|io
throw|;
block|}
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|Integer
name|r
init|=
name|region
operator|.
name|obtainRowLock
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|long
name|lockId
init|=
name|addRowLock
argument_list|(
name|r
argument_list|,
name|region
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Row lock "
operator|+
name|lockId
operator|+
literal|" explicitly acquired by client"
argument_list|)
expr_stmt|;
return|return
name|lockId
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|,
literal|"Error obtaining row lock (fsOk: "
operator|+
name|this
operator|.
name|fsOk
operator|+
literal|")"
argument_list|)
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
specifier|protected
name|long
name|addRowLock
parameter_list|(
name|Integer
name|r
parameter_list|,
name|HRegion
name|region
parameter_list|)
throws|throws
name|LeaseStillHeldException
block|{
name|long
name|lockId
init|=
operator|-
literal|1L
decl_stmt|;
name|lockId
operator|=
name|rand
operator|.
name|nextLong
argument_list|()
expr_stmt|;
name|String
name|lockName
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|lockId
argument_list|)
decl_stmt|;
name|rowlocks
operator|.
name|put
argument_list|(
name|lockName
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|this
operator|.
name|leases
operator|.
name|createLease
argument_list|(
name|lockName
argument_list|,
operator|new
name|RowLockListener
argument_list|(
name|lockName
argument_list|,
name|region
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|lockId
return|;
block|}
end_function

begin_comment
comment|/**    * Method to get the Integer lock identifier used internally from the long    * lock identifier used by the client.    *    * @param lockId    *          long row lock identifier from client    * @return intId Integer row lock used internally in HRegion    * @throws IOException    *           Thrown if this is not a valid client lock id.    */
end_comment

begin_function
name|Integer
name|getLockFromId
parameter_list|(
name|long
name|lockId
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|lockId
operator|==
operator|-
literal|1L
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|lockName
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|lockId
argument_list|)
decl_stmt|;
name|Integer
name|rl
init|=
name|rowlocks
operator|.
name|get
argument_list|(
name|lockName
argument_list|)
decl_stmt|;
if|if
condition|(
name|rl
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownRowLockException
argument_list|(
literal|"Invalid row lock"
argument_list|)
throw|;
block|}
name|this
operator|.
name|leases
operator|.
name|renewLease
argument_list|(
name|lockName
argument_list|)
expr_stmt|;
return|return
name|rl
return|;
block|}
end_function

begin_function
annotation|@
name|Override
annotation|@
name|QosPriority
argument_list|(
name|priority
operator|=
name|HIGH_QOS
argument_list|)
specifier|public
name|void
name|unlockRow
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|,
name|long
name|lockId
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|NullPointerException
name|npe
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|regionName
operator|==
literal|null
condition|)
block|{
name|npe
operator|=
operator|new
name|NullPointerException
argument_list|(
literal|"regionName is null"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lockId
operator|==
operator|-
literal|1L
condition|)
block|{
name|npe
operator|=
operator|new
name|NullPointerException
argument_list|(
literal|"lockId is null"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|npe
operator|!=
literal|null
condition|)
block|{
name|IOException
name|io
init|=
operator|new
name|IOException
argument_list|(
literal|"Invalid arguments to unlockRow"
argument_list|)
decl_stmt|;
name|io
operator|.
name|initCause
argument_list|(
name|npe
argument_list|)
expr_stmt|;
throw|throw
name|io
throw|;
block|}
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|String
name|lockName
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|lockId
argument_list|)
decl_stmt|;
name|Integer
name|r
init|=
name|rowlocks
operator|.
name|remove
argument_list|(
name|lockName
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownRowLockException
argument_list|(
name|lockName
argument_list|)
throw|;
block|}
name|region
operator|.
name|releaseRowLock
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|this
operator|.
name|leases
operator|.
name|cancelLease
argument_list|(
name|lockName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Row lock "
operator|+
name|lockId
operator|+
literal|" has been explicitly released by client"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|bulkLoadHFile
parameter_list|(
name|String
name|hfilePath
parameter_list|,
name|byte
index|[]
name|regionName
parameter_list|,
name|byte
index|[]
name|familyName
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|region
operator|.
name|bulkLoadHFile
argument_list|(
name|hfilePath
argument_list|,
name|familyName
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|rowlocks
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**    * Instantiated as a row lock lease. If the lease times out, the row lock is    * released    */
end_comment

begin_class
specifier|private
class|class
name|RowLockListener
implements|implements
name|LeaseListener
block|{
specifier|private
specifier|final
name|String
name|lockName
decl_stmt|;
specifier|private
specifier|final
name|HRegion
name|region
decl_stmt|;
name|RowLockListener
parameter_list|(
specifier|final
name|String
name|lockName
parameter_list|,
specifier|final
name|HRegion
name|region
parameter_list|)
block|{
name|this
operator|.
name|lockName
operator|=
name|lockName
expr_stmt|;
name|this
operator|.
name|region
operator|=
name|region
expr_stmt|;
block|}
specifier|public
name|void
name|leaseExpired
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Row Lock "
operator|+
name|this
operator|.
name|lockName
operator|+
literal|" lease expired"
argument_list|)
expr_stmt|;
name|Integer
name|r
init|=
name|rowlocks
operator|.
name|remove
argument_list|(
name|this
operator|.
name|lockName
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|null
condition|)
block|{
name|region
operator|.
name|releaseRowLock
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// Region open/close direct RPCs
end_comment

begin_function
annotation|@
name|Override
annotation|@
name|QosPriority
argument_list|(
name|priority
operator|=
name|HIGH_QOS
argument_list|)
specifier|public
name|RegionOpeningState
name|openRegion
parameter_list|(
name|HRegionInfo
name|region
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|regionsInTransitionInRS
operator|.
name|contains
argument_list|(
name|region
operator|.
name|getEncodedNameAsBytes
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RegionAlreadyInTransitionException
argument_list|(
literal|"open"
argument_list|,
name|region
operator|.
name|getEncodedName
argument_list|()
argument_list|)
throw|;
block|}
name|HRegion
name|onlineRegion
init|=
name|this
operator|.
name|getFromOnlineRegions
argument_list|(
name|region
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|onlineRegion
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Attempted open of "
operator|+
name|region
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" but already online on this server"
argument_list|)
expr_stmt|;
return|return
name|RegionOpeningState
operator|.
name|ALREADY_OPENED
return|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Received request to open region: "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
name|HTableDescriptor
name|htd
init|=
name|this
operator|.
name|tableDescriptors
operator|.
name|get
argument_list|(
name|region
operator|.
name|getTableName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|.
name|isRootRegion
argument_list|()
condition|)
block|{
name|this
operator|.
name|service
operator|.
name|submit
argument_list|(
operator|new
name|OpenRootHandler
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|region
argument_list|,
name|htd
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|region
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
name|this
operator|.
name|service
operator|.
name|submit
argument_list|(
operator|new
name|OpenMetaHandler
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|region
argument_list|,
name|htd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|service
operator|.
name|submit
argument_list|(
operator|new
name|OpenRegionHandler
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|region
argument_list|,
name|htd
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|RegionOpeningState
operator|.
name|OPENED
return|;
block|}
end_function

begin_function
annotation|@
name|Override
annotation|@
name|QosPriority
argument_list|(
name|priority
operator|=
name|HIGH_QOS
argument_list|)
specifier|public
name|void
name|openRegions
parameter_list|(
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Received request to open "
operator|+
name|regions
operator|.
name|size
argument_list|()
operator|+
literal|" region(s)"
argument_list|)
expr_stmt|;
for|for
control|(
name|HRegionInfo
name|region
range|:
name|regions
control|)
name|openRegion
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
annotation|@
name|QosPriority
argument_list|(
name|priority
operator|=
name|HIGH_QOS
argument_list|)
specifier|public
name|boolean
name|closeRegion
parameter_list|(
name|HRegionInfo
name|region
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|closeRegion
argument_list|(
name|region
argument_list|,
literal|true
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
annotation|@
name|QosPriority
argument_list|(
name|priority
operator|=
name|HIGH_QOS
argument_list|)
specifier|public
name|boolean
name|closeRegion
parameter_list|(
name|HRegionInfo
name|region
parameter_list|,
specifier|final
name|boolean
name|zk
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Received close region: "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|hasit
init|=
name|this
operator|.
name|onlineRegions
operator|.
name|containsKey
argument_list|(
name|region
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|hasit
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received close for region we are not serving; "
operator|+
name|region
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|NotServingRegionException
argument_list|(
literal|"Received close for "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" but we are not serving it"
argument_list|)
throw|;
block|}
if|if
condition|(
name|this
operator|.
name|regionsInTransitionInRS
operator|.
name|contains
argument_list|(
name|region
operator|.
name|getEncodedNameAsBytes
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RegionAlreadyInTransitionException
argument_list|(
literal|"close"
argument_list|,
name|region
operator|.
name|getEncodedName
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|closeRegion
argument_list|(
name|region
argument_list|,
literal|false
argument_list|,
name|zk
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * @param region Region to close    * @param abort True if we are aborting    * @param zk True if we are to update zk about the region close; if the close    * was orchestrated by master, then update zk.  If the close is being run by    * the regionserver because its going down, don't update zk.    * @return True if closed a region.    */
end_comment

begin_function
specifier|protected
name|boolean
name|closeRegion
parameter_list|(
name|HRegionInfo
name|region
parameter_list|,
specifier|final
name|boolean
name|abort
parameter_list|,
specifier|final
name|boolean
name|zk
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|regionsInTransitionInRS
operator|.
name|contains
argument_list|(
name|region
operator|.
name|getEncodedNameAsBytes
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received close for region we are already opening or closing; "
operator|+
name|region
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|CloseRegionHandler
name|crh
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|region
operator|.
name|isRootRegion
argument_list|()
condition|)
block|{
name|crh
operator|=
operator|new
name|CloseRootHandler
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|region
argument_list|,
name|abort
argument_list|,
name|zk
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|region
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
name|crh
operator|=
operator|new
name|CloseMetaHandler
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|region
argument_list|,
name|abort
argument_list|,
name|zk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|crh
operator|=
operator|new
name|CloseRegionHandler
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|region
argument_list|,
name|abort
argument_list|,
name|zk
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|service
operator|.
name|submit
argument_list|(
name|crh
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function

begin_comment
comment|// Manual remote region administration RPCs
end_comment

begin_function
annotation|@
name|Override
annotation|@
name|QosPriority
argument_list|(
name|priority
operator|=
name|HIGH_QOS
argument_list|)
specifier|public
name|void
name|flushRegion
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|NotServingRegionException
throws|,
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Flushing "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionInfo
operator|.
name|getRegionName
argument_list|()
argument_list|)
decl_stmt|;
name|region
operator|.
name|flushcache
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
annotation|@
name|QosPriority
argument_list|(
name|priority
operator|=
name|HIGH_QOS
argument_list|)
specifier|public
name|void
name|splitRegion
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|NotServingRegionException
throws|,
name|IOException
block|{
name|splitRegion
argument_list|(
name|regionInfo
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|splitRegion
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|,
name|byte
index|[]
name|splitPoint
parameter_list|)
throws|throws
name|NotServingRegionException
throws|,
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionInfo
operator|.
name|getRegionName
argument_list|()
argument_list|)
decl_stmt|;
name|region
operator|.
name|flushcache
argument_list|()
expr_stmt|;
name|region
operator|.
name|forceSplit
argument_list|(
name|splitPoint
argument_list|)
expr_stmt|;
name|compactSplitThread
operator|.
name|requestSplit
argument_list|(
name|region
argument_list|,
name|region
operator|.
name|checkSplit
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
annotation|@
name|QosPriority
argument_list|(
name|priority
operator|=
name|HIGH_QOS
argument_list|)
specifier|public
name|void
name|compactRegion
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|,
name|boolean
name|major
parameter_list|)
throws|throws
name|NotServingRegionException
throws|,
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionInfo
operator|.
name|getRegionName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|major
condition|)
block|{
name|region
operator|.
name|triggerMajorCompaction
argument_list|()
expr_stmt|;
block|}
name|compactSplitThread
operator|.
name|requestCompaction
argument_list|(
name|region
argument_list|,
literal|"User-triggered "
operator|+
operator|(
name|major
condition|?
literal|"major "
else|:
literal|""
operator|)
operator|+
literal|"compaction"
argument_list|,
name|CompactSplitThread
operator|.
name|PRIORITY_USER
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** @return the info server */
end_comment

begin_function
specifier|public
name|InfoServer
name|getInfoServer
parameter_list|()
block|{
return|return
name|infoServer
return|;
block|}
end_function

begin_comment
comment|/**    * @return true if a stop has been requested.    */
end_comment

begin_function
specifier|public
name|boolean
name|isStopped
parameter_list|()
block|{
return|return
name|this
operator|.
name|stopped
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|boolean
name|isStopping
parameter_list|()
block|{
return|return
name|this
operator|.
name|stopping
return|;
block|}
end_function

begin_comment
comment|/**    *    * @return the configuration    */
end_comment

begin_function
specifier|public
name|Configuration
name|getConfiguration
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
end_function

begin_comment
comment|/** @return the write lock for the server */
end_comment

begin_function
name|ReentrantReadWriteLock
operator|.
name|WriteLock
name|getWriteLock
parameter_list|()
block|{
return|return
name|lock
operator|.
name|writeLock
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
annotation|@
name|QosPriority
argument_list|(
name|priority
operator|=
name|HIGH_QOS
argument_list|)
specifier|public
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|getOnlineRegions
parameter_list|()
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|(
name|onlineRegions
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|HRegion
argument_list|>
name|e
range|:
name|this
operator|.
name|onlineRegions
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_function
specifier|public
name|int
name|getNumberOfOnlineRegions
parameter_list|()
block|{
return|return
name|this
operator|.
name|onlineRegions
operator|.
name|size
argument_list|()
return|;
block|}
end_function

begin_function
name|boolean
name|isOnlineRegionsEmpty
parameter_list|()
block|{
return|return
name|this
operator|.
name|onlineRegions
operator|.
name|isEmpty
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * @param encodedRegionName    * @return JSON Map of labels to values for passed in<code>encodedRegionName</code>    * @throws IOException    */
end_comment

begin_function
specifier|public
name|byte
index|[]
name|getRegionStats
parameter_list|(
specifier|final
name|String
name|encodedRegionName
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegion
name|r
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|onlineRegions
init|)
block|{
name|r
operator|=
name|this
operator|.
name|onlineRegions
operator|.
name|get
argument_list|(
name|encodedRegionName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|ObjectMapper
name|mapper
init|=
operator|new
name|ObjectMapper
argument_list|()
decl_stmt|;
name|int
name|stores
init|=
literal|0
decl_stmt|;
name|int
name|storefiles
init|=
literal|0
decl_stmt|;
name|int
name|storefileSizeMB
init|=
literal|0
decl_stmt|;
name|int
name|memstoreSizeMB
init|=
call|(
name|int
call|)
argument_list|(
name|r
operator|.
name|memstoreSize
operator|.
name|get
argument_list|()
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
decl_stmt|;
name|int
name|storefileIndexSizeMB
init|=
literal|0
decl_stmt|;
synchronized|synchronized
init|(
name|r
operator|.
name|stores
init|)
block|{
name|stores
operator|+=
name|r
operator|.
name|stores
operator|.
name|size
argument_list|()
expr_stmt|;
for|for
control|(
name|Store
name|store
range|:
name|r
operator|.
name|stores
operator|.
name|values
argument_list|()
control|)
block|{
name|storefiles
operator|+=
name|store
operator|.
name|getStorefilesCount
argument_list|()
expr_stmt|;
name|storefileSizeMB
operator|+=
call|(
name|int
call|)
argument_list|(
name|store
operator|.
name|getStorefilesSize
argument_list|()
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|storefileIndexSizeMB
operator|+=
call|(
name|int
call|)
argument_list|(
name|store
operator|.
name|getStorefilesIndexSize
argument_list|()
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
expr_stmt|;
block|}
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|map
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"stores"
argument_list|,
name|stores
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"storefiles"
argument_list|,
name|storefiles
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"storefileSizeMB"
argument_list|,
name|storefileIndexSizeMB
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"memstoreSizeMB"
argument_list|,
name|memstoreSizeMB
argument_list|)
expr_stmt|;
name|StringWriter
name|w
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|mapper
operator|.
name|writeValue
argument_list|(
name|w
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|w
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|Bytes
operator|.
name|toBytes
argument_list|(
name|w
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * For tests and web ui.    * This method will only work if HRegionServer is in the same JVM as client;    * HRegion cannot be serialized to cross an rpc.    * @see #getOnlineRegions()    */
end_comment

begin_function
specifier|public
name|Collection
argument_list|<
name|HRegion
argument_list|>
name|getOnlineRegionsLocalContext
parameter_list|()
block|{
name|Collection
argument_list|<
name|HRegion
argument_list|>
name|regions
init|=
name|this
operator|.
name|onlineRegions
operator|.
name|values
argument_list|()
decl_stmt|;
return|return
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|regions
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|addToOnlineRegions
parameter_list|(
name|HRegion
name|region
parameter_list|)
block|{
name|this
operator|.
name|onlineRegions
operator|.
name|put
argument_list|(
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedName
argument_list|()
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|boolean
name|removeFromOnlineRegions
parameter_list|(
specifier|final
name|String
name|encodedName
parameter_list|)
block|{
name|HRegion
name|toReturn
init|=
literal|null
decl_stmt|;
name|toReturn
operator|=
name|this
operator|.
name|onlineRegions
operator|.
name|remove
argument_list|(
name|encodedName
argument_list|)
expr_stmt|;
return|return
name|toReturn
operator|!=
literal|null
return|;
block|}
end_function

begin_comment
comment|/**    * @return A new Map of online regions sorted by region size with the first    *         entry being the biggest.    */
end_comment

begin_function
specifier|public
name|SortedMap
argument_list|<
name|Long
argument_list|,
name|HRegion
argument_list|>
name|getCopyOfOnlineRegionsSortedBySize
parameter_list|()
block|{
comment|// we'll sort the regions in reverse
name|SortedMap
argument_list|<
name|Long
argument_list|,
name|HRegion
argument_list|>
name|sortedRegions
init|=
operator|new
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|HRegion
argument_list|>
argument_list|(
operator|new
name|Comparator
argument_list|<
name|Long
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|Long
name|a
parameter_list|,
name|Long
name|b
parameter_list|)
block|{
return|return
operator|-
literal|1
operator|*
name|a
operator|.
name|compareTo
argument_list|(
name|b
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
comment|// Copy over all regions. Regions are sorted by size with biggest first.
for|for
control|(
name|HRegion
name|region
range|:
name|this
operator|.
name|onlineRegions
operator|.
name|values
argument_list|()
control|)
block|{
name|sortedRegions
operator|.
name|put
argument_list|(
name|Long
operator|.
name|valueOf
argument_list|(
name|region
operator|.
name|memstoreSize
operator|.
name|get
argument_list|()
argument_list|)
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
return|return
name|sortedRegions
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|HRegion
name|getFromOnlineRegions
parameter_list|(
specifier|final
name|String
name|encodedRegionName
parameter_list|)
block|{
name|HRegion
name|r
init|=
literal|null
decl_stmt|;
name|r
operator|=
name|this
operator|.
name|onlineRegions
operator|.
name|get
argument_list|(
name|encodedRegionName
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/**    * @param regionName    * @return HRegion for the passed binary<code>regionName</code> or null if    *         named region is not member of the online regions.    */
end_comment

begin_function
specifier|public
name|HRegion
name|getOnlineRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
block|{
return|return
name|getFromOnlineRegions
argument_list|(
name|HRegionInfo
operator|.
name|encodeRegionName
argument_list|(
name|regionName
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** @return the request count */
end_comment

begin_function
specifier|public
name|AtomicInteger
name|getRequestCount
parameter_list|()
block|{
return|return
name|this
operator|.
name|requestCount
return|;
block|}
end_function

begin_comment
comment|/** @return reference to FlushRequester */
end_comment

begin_function
specifier|public
name|FlushRequester
name|getFlushRequester
parameter_list|()
block|{
return|return
name|this
operator|.
name|cacheFlusher
return|;
block|}
end_function

begin_comment
comment|/**    * Protected utility method for safely obtaining an HRegion handle.    *    * @param regionName    *          Name of online {@link HRegion} to return    * @return {@link HRegion} for<code>regionName</code>    * @throws NotServingRegionException    */
end_comment

begin_function
specifier|protected
name|HRegion
name|getRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|NotServingRegionException
block|{
name|HRegion
name|region
init|=
literal|null
decl_stmt|;
name|region
operator|=
name|getOnlineRegion
argument_list|(
name|regionName
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NotServingRegionException
argument_list|(
literal|"Region is not online: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionName
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|region
return|;
block|}
end_function

begin_comment
comment|/**    * Get the top N most loaded regions this server is serving so we can tell the    * master which regions it can reallocate if we're overloaded. TODO: actually    * calculate which regions are most loaded. (Right now, we're just grabbing    * the first N regions being served regardless of load.)    */
end_comment

begin_function
specifier|protected
name|HRegionInfo
index|[]
name|getMostLoadedRegions
parameter_list|()
block|{
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|HRegion
name|r
range|:
name|onlineRegions
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|r
operator|.
name|isClosed
argument_list|()
operator|||
name|r
operator|.
name|isClosing
argument_list|()
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|regions
operator|.
name|size
argument_list|()
operator|<
name|numRegionsToReport
condition|)
block|{
name|regions
operator|.
name|add
argument_list|(
name|r
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
return|return
name|regions
operator|.
name|toArray
argument_list|(
operator|new
name|HRegionInfo
index|[
name|regions
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Called to verify that this server is up and running.    *    * @throws IOException    */
end_comment

begin_function
specifier|protected
name|void
name|checkOpen
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|stopped
operator|||
name|this
operator|.
name|abortRequested
condition|)
block|{
throw|throw
operator|new
name|RegionServerStoppedException
argument_list|(
literal|"Server "
operator|+
name|getServerName
argument_list|()
operator|+
literal|" not running"
operator|+
operator|(
name|this
operator|.
name|abortRequested
condition|?
literal|", aborting"
else|:
literal|""
operator|)
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|fsOk
condition|)
block|{
throw|throw
operator|new
name|RegionServerStoppedException
argument_list|(
literal|"File system not available"
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
annotation|@
name|QosPriority
argument_list|(
name|priority
operator|=
name|HIGH_QOS
argument_list|)
specifier|public
name|long
name|getProtocolVersion
parameter_list|(
specifier|final
name|String
name|protocol
parameter_list|,
specifier|final
name|long
name|clientVersion
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|HRegionInterface
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|HRegionInterface
operator|.
name|VERSION
return|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown protocol: "
operator|+
name|protocol
argument_list|)
throw|;
block|}
end_function

begin_comment
comment|/**    * @return Return the leases.    */
end_comment

begin_function
specifier|protected
name|Leases
name|getLeases
parameter_list|()
block|{
return|return
name|leases
return|;
block|}
end_function

begin_comment
comment|/**    * @return Return the rootDir.    */
end_comment

begin_function
specifier|protected
name|Path
name|getRootDir
parameter_list|()
block|{
return|return
name|rootDir
return|;
block|}
end_function

begin_comment
comment|/**    * @return Return the fs.    */
end_comment

begin_function
specifier|protected
name|FileSystem
name|getFileSystem
parameter_list|()
block|{
return|return
name|fs
return|;
block|}
end_function

begin_comment
comment|/**    * @return This servers {@link HServerInfo}    */
end_comment

begin_comment
comment|// TODO: Deprecate and do getServerName instead.
end_comment

begin_function
specifier|public
name|HServerInfo
name|getServerInfo
parameter_list|()
block|{
try|try
block|{
return|return
name|getHServerInfo
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|Result
name|increment
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|,
name|Increment
name|increment
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|regionName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid arguments to increment "
operator|+
literal|"regionName is null"
argument_list|)
throw|;
block|}
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|Integer
name|lock
init|=
name|getLockFromId
argument_list|(
name|increment
operator|.
name|getLockId
argument_list|()
argument_list|)
decl_stmt|;
name|Increment
name|incVal
init|=
name|increment
decl_stmt|;
name|Result
name|resVal
decl_stmt|;
if|if
condition|(
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|resVal
operator|=
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|.
name|preIncrement
argument_list|(
name|incVal
argument_list|)
expr_stmt|;
if|if
condition|(
name|resVal
operator|!=
literal|null
condition|)
block|{
return|return
name|resVal
return|;
block|}
block|}
name|resVal
operator|=
name|region
operator|.
name|increment
argument_list|(
name|incVal
argument_list|,
name|lock
argument_list|,
name|increment
operator|.
name|getWriteToWAL
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|.
name|postIncrement
argument_list|(
name|incVal
argument_list|,
name|resVal
argument_list|)
expr_stmt|;
block|}
return|return
name|resVal
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkFileSystem
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
end_function

begin_comment
comment|/** {@inheritDoc} */
end_comment

begin_function
specifier|public
name|long
name|incrementColumnValue
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|,
name|byte
index|[]
name|row
parameter_list|,
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|long
name|amount
parameter_list|,
name|boolean
name|writeToWAL
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|regionName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid arguments to incrementColumnValue "
operator|+
literal|"regionName is null"
argument_list|)
throw|;
block|}
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|Long
name|amountVal
init|=
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|.
name|preIncrementColumnValue
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|amount
argument_list|,
name|writeToWAL
argument_list|)
decl_stmt|;
if|if
condition|(
name|amountVal
operator|!=
literal|null
condition|)
block|{
return|return
name|amountVal
operator|.
name|longValue
argument_list|()
return|;
block|}
block|}
name|long
name|retval
init|=
name|region
operator|.
name|incrementColumnValue
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|amount
argument_list|,
name|writeToWAL
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|retval
operator|=
name|region
operator|.
name|getCoprocessorHost
argument_list|()
operator|.
name|postIncrementColumnValue
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|amount
argument_list|,
name|writeToWAL
argument_list|,
name|retval
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkFileSystem
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
end_function

begin_comment
comment|/** {@inheritDoc}    * @deprecated Use {@link #getServerName()} instead.    */
end_comment

begin_function
annotation|@
name|Override
annotation|@
name|QosPriority
argument_list|(
name|priority
operator|=
name|HIGH_QOS
argument_list|)
specifier|public
name|HServerInfo
name|getHServerInfo
parameter_list|()
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
return|return
operator|new
name|HServerInfo
argument_list|(
operator|new
name|HServerAddress
argument_list|(
name|this
operator|.
name|isa
argument_list|)
argument_list|,
name|this
operator|.
name|startcode
argument_list|,
name|this
operator|.
name|webuiport
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
specifier|public
parameter_list|<
name|R
parameter_list|>
name|MultiResponse
name|multi
parameter_list|(
name|MultiAction
argument_list|<
name|R
argument_list|>
name|multi
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|MultiResponse
name|response
init|=
operator|new
name|MultiResponse
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|List
argument_list|<
name|Action
argument_list|<
name|R
argument_list|>
argument_list|>
argument_list|>
name|e
range|:
name|multi
operator|.
name|actions
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|byte
index|[]
name|regionName
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Action
argument_list|<
name|R
argument_list|>
argument_list|>
name|actionsForRegion
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// sort based on the row id - this helps in the case where we reach the
comment|// end of a region, so that we don't have to try the rest of the
comment|// actions in the list.
name|Collections
operator|.
name|sort
argument_list|(
name|actionsForRegion
argument_list|)
expr_stmt|;
name|Row
name|action
decl_stmt|;
name|List
argument_list|<
name|Action
argument_list|<
name|R
argument_list|>
argument_list|>
name|puts
init|=
operator|new
name|ArrayList
argument_list|<
name|Action
argument_list|<
name|R
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Action
argument_list|<
name|R
argument_list|>
name|a
range|:
name|actionsForRegion
control|)
block|{
name|action
operator|=
name|a
operator|.
name|getAction
argument_list|()
expr_stmt|;
name|int
name|originalIndex
init|=
name|a
operator|.
name|getOriginalIndex
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|action
operator|instanceof
name|Delete
condition|)
block|{
name|delete
argument_list|(
name|regionName
argument_list|,
operator|(
name|Delete
operator|)
name|action
argument_list|)
expr_stmt|;
name|response
operator|.
name|add
argument_list|(
name|regionName
argument_list|,
name|originalIndex
argument_list|,
operator|new
name|Result
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|instanceof
name|Get
condition|)
block|{
name|response
operator|.
name|add
argument_list|(
name|regionName
argument_list|,
name|originalIndex
argument_list|,
name|get
argument_list|(
name|regionName
argument_list|,
operator|(
name|Get
operator|)
name|action
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|instanceof
name|Put
condition|)
block|{
name|puts
operator|.
name|add
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|// wont throw.
block|}
elseif|else
if|if
condition|(
name|action
operator|instanceof
name|Exec
condition|)
block|{
name|ExecResult
name|result
init|=
name|execCoprocessor
argument_list|(
name|regionName
argument_list|,
operator|(
name|Exec
operator|)
name|action
argument_list|)
decl_stmt|;
name|response
operator|.
name|add
argument_list|(
name|regionName
argument_list|,
operator|new
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Object
argument_list|>
argument_list|(
name|a
operator|.
name|getOriginalIndex
argument_list|()
argument_list|,
name|result
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Error: invalid Action, row must be a Get, Delete, "
operator|+
literal|"Put or Exec."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DoNotRetryIOException
argument_list|(
literal|"Invalid Action, row must be a "
operator|+
literal|"Get, Delete or Put."
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|response
operator|.
name|add
argument_list|(
name|regionName
argument_list|,
name|originalIndex
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
comment|// We do the puts with result.put so we can get the batching efficiency
comment|// we so need. All this data munging doesn't seem great, but at least
comment|// we arent copying bytes or anything.
if|if
condition|(
operator|!
name|puts
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
try|try
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isMetaTable
argument_list|()
condition|)
block|{
name|this
operator|.
name|cacheFlusher
operator|.
name|reclaimMemStoreMemory
argument_list|()
expr_stmt|;
block|}
name|List
argument_list|<
name|Pair
argument_list|<
name|Put
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|putsWithLocks
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|puts
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Action
argument_list|<
name|R
argument_list|>
name|a
range|:
name|puts
control|)
block|{
name|Put
name|p
init|=
operator|(
name|Put
operator|)
name|a
operator|.
name|getAction
argument_list|()
decl_stmt|;
name|Integer
name|lock
decl_stmt|;
try|try
block|{
name|lock
operator|=
name|getLockFromId
argument_list|(
name|p
operator|.
name|getLockId
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownRowLockException
name|ex
parameter_list|)
block|{
name|response
operator|.
name|add
argument_list|(
name|regionName
argument_list|,
name|a
operator|.
name|getOriginalIndex
argument_list|()
argument_list|,
name|ex
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|putsWithLocks
operator|.
name|add
argument_list|(
operator|new
name|Pair
argument_list|<
name|Put
argument_list|,
name|Integer
argument_list|>
argument_list|(
name|p
argument_list|,
name|lock
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|requestCount
operator|.
name|addAndGet
argument_list|(
name|puts
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|OperationStatusCode
index|[]
name|codes
init|=
name|region
operator|.
name|put
argument_list|(
name|putsWithLocks
operator|.
name|toArray
argument_list|(
operator|new
name|Pair
index|[]
block|{}
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|codes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|OperationStatusCode
name|code
init|=
name|codes
index|[
name|i
index|]
decl_stmt|;
name|Action
argument_list|<
name|R
argument_list|>
name|theAction
init|=
name|puts
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Object
name|result
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|OperationStatusCode
operator|.
name|SUCCESS
condition|)
block|{
name|result
operator|=
operator|new
name|Result
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|OperationStatusCode
operator|.
name|BAD_FAMILY
condition|)
block|{
name|result
operator|=
operator|new
name|NoSuchColumnFamilyException
argument_list|()
expr_stmt|;
block|}
comment|// FAILURE&& NOT_RUN becomes null, aka: need to run again.
name|response
operator|.
name|add
argument_list|(
name|regionName
argument_list|,
name|theAction
operator|.
name|getOriginalIndex
argument_list|()
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// fail all the puts with the ioe in question.
for|for
control|(
name|Action
argument_list|<
name|R
argument_list|>
name|a
range|:
name|puts
control|)
block|{
name|response
operator|.
name|add
argument_list|(
name|regionName
argument_list|,
name|a
operator|.
name|getOriginalIndex
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|response
return|;
block|}
end_function

begin_comment
comment|/**    * @deprecated Use HRegionServer.multi( MultiAction action) instead    */
end_comment

begin_function
annotation|@
name|Override
specifier|public
name|MultiPutResponse
name|multiPut
parameter_list|(
name|MultiPut
name|puts
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|MultiPutResponse
name|resp
init|=
operator|new
name|MultiPutResponse
argument_list|()
decl_stmt|;
comment|// do each region as it's own.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|List
argument_list|<
name|Put
argument_list|>
argument_list|>
name|e
range|:
name|puts
operator|.
name|puts
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|int
name|result
init|=
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|resp
operator|.
name|addResult
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// clear some RAM
block|}
return|return
name|resp
return|;
block|}
end_function

begin_comment
comment|/**    * Executes a single {@link org.apache.hadoop.hbase.ipc.CoprocessorProtocol}    * method using the registered protocol handlers.    * {@link CoprocessorProtocol} implementations must be registered per-region    * via the    * {@link org.apache.hadoop.hbase.regionserver.HRegion#registerProtocol(Class, org.apache.hadoop.hbase.ipc.CoprocessorProtocol)}    * method before they are available.    *    * @param regionName name of the region against which the invocation is executed    * @param call an {@code Exec} instance identifying the protocol, method name,    *     and parameters for the method invocation    * @return an {@code ExecResult} instance containing the region name of the    *     invocation and the return value    * @throws IOException if no registered protocol handler is found or an error    *     occurs during the invocation    * @see org.apache.hadoop.hbase.regionserver.HRegion#registerProtocol(Class, org.apache.hadoop.hbase.ipc.CoprocessorProtocol)    */
end_comment

begin_function
annotation|@
name|Override
specifier|public
name|ExecResult
name|execCoprocessor
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|,
name|Exec
name|call
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
return|return
name|region
operator|.
name|exec
argument_list|(
name|call
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getServerName
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Interval at which threads should run    *    * @return the interval    */
end_comment

begin_function
specifier|public
name|int
name|getThreadWakeFrequency
parameter_list|()
block|{
return|return
name|threadWakeFrequency
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|ZooKeeperWatcher
name|getZooKeeper
parameter_list|()
block|{
return|return
name|zooKeeper
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|ServerName
name|getServerName
parameter_list|()
block|{
comment|// Our servername could change after we talk to the master.
return|return
name|this
operator|.
name|serverNameFromMasterPOV
operator|==
literal|null
condition|?
operator|new
name|ServerName
argument_list|(
name|this
operator|.
name|isa
operator|.
name|getHostName
argument_list|()
argument_list|,
name|this
operator|.
name|isa
operator|.
name|getPort
argument_list|()
argument_list|,
name|this
operator|.
name|startcode
argument_list|)
else|:
name|this
operator|.
name|serverNameFromMasterPOV
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|CompactionRequestor
name|getCompactionRequester
parameter_list|()
block|{
return|return
name|this
operator|.
name|compactSplitThread
return|;
block|}
end_function

begin_function
specifier|public
name|ZooKeeperWatcher
name|getZooKeeperWatcher
parameter_list|()
block|{
return|return
name|this
operator|.
name|zooKeeper
return|;
block|}
end_function

begin_function
specifier|public
name|Set
argument_list|<
name|byte
index|[]
argument_list|>
name|getRegionsInTransitionInRS
parameter_list|()
block|{
return|return
name|this
operator|.
name|regionsInTransitionInRS
return|;
block|}
end_function

begin_comment
comment|//
end_comment

begin_comment
comment|// Main program and support routines
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/**    * @param hrs    * @return Thread the RegionServer is running in correctly named.    * @throws IOException    */
end_comment

begin_function
specifier|public
specifier|static
name|Thread
name|startRegionServer
parameter_list|(
specifier|final
name|HRegionServer
name|hrs
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|startRegionServer
argument_list|(
name|hrs
argument_list|,
literal|"regionserver"
operator|+
name|hrs
operator|.
name|isa
operator|.
name|getPort
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * @param hrs    * @param name    * @return Thread the RegionServer is running in correctly named.    * @throws IOException    */
end_comment

begin_function
specifier|public
specifier|static
name|Thread
name|startRegionServer
parameter_list|(
specifier|final
name|HRegionServer
name|hrs
parameter_list|,
specifier|final
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|Thread
name|t
init|=
operator|new
name|Thread
argument_list|(
name|hrs
argument_list|)
decl_stmt|;
name|t
operator|.
name|setName
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Install shutdown hook that will catch signals and run an orderly shutdown
comment|// of the hrs.
name|ShutdownHook
operator|.
name|install
argument_list|(
name|hrs
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|FileSystem
operator|.
name|get
argument_list|(
name|hrs
operator|.
name|getConfiguration
argument_list|()
argument_list|)
argument_list|,
name|hrs
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/**    * Utility for constructing an instance of the passed HRegionServer class.    *    * @param regionServerClass    * @param conf2    * @return HRegionServer instance.    */
end_comment

begin_function
specifier|public
specifier|static
name|HRegionServer
name|constructRegionServer
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|HRegionServer
argument_list|>
name|regionServerClass
parameter_list|,
specifier|final
name|Configuration
name|conf2
parameter_list|)
block|{
try|try
block|{
name|Constructor
argument_list|<
name|?
extends|extends
name|HRegionServer
argument_list|>
name|c
init|=
name|regionServerClass
operator|.
name|getConstructor
argument_list|(
name|Configuration
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|c
operator|.
name|newInstance
argument_list|(
name|conf2
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Failed construction of "
operator|+
literal|"Regionserver: "
operator|+
name|regionServerClass
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|replicateLogEntries
parameter_list|(
specifier|final
name|HLog
operator|.
name|Entry
index|[]
name|entries
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|replicationHandler
operator|==
literal|null
condition|)
return|return;
name|this
operator|.
name|replicationHandler
operator|.
name|replicateLogEntries
argument_list|(
name|entries
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * @see org.apache.hadoop.hbase.regionserver.HRegionServerCommandLine    */
end_comment

begin_function
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|VersionInfo
operator|.
name|logVersion
argument_list|()
expr_stmt|;
name|Configuration
name|conf
init|=
name|HBaseConfiguration
operator|.
name|create
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Class
argument_list|<
name|?
extends|extends
name|HRegionServer
argument_list|>
name|regionServerClass
init|=
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|HRegionServer
argument_list|>
operator|)
name|conf
operator|.
name|getClass
argument_list|(
name|HConstants
operator|.
name|REGION_SERVER_IMPL
argument_list|,
name|HRegionServer
operator|.
name|class
argument_list|)
decl_stmt|;
operator|new
name|HRegionServerCommandLine
argument_list|(
name|regionServerClass
argument_list|)
operator|.
name|doMain
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

unit|}
end_unit

