begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2010 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|Thread
operator|.
name|UncaughtExceptionHandler
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|ManagementFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|MemoryUsage
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|BindException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Chore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HMsg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerAddress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerLoad
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MasterAddressTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NotServingRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|RemoteExceptionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Stoppable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|UnknownRowLockException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|UnknownScannerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|YouAreDeadException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
operator|.
name|OperationStatusCode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|CatalogTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|MetaEditor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|RootLocationEditor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Action
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Delete
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Get
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|HConnection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|HConnectionManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MultiAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MultiPut
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MultiPutResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MultiResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Put
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Row
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Scan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|ExecutorService
operator|.
name|ExecutorType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|LruBlockCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HBaseRPC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HBaseRPCErrorHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HBaseRPCProtocolVersion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HBaseServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HMasterRegionInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HRegionInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|Leases
operator|.
name|LeaseStillHeldException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|handler
operator|.
name|CloseMetaHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|handler
operator|.
name|CloseRegionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|handler
operator|.
name|CloseRootHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|handler
operator|.
name|OpenMetaHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|handler
operator|.
name|OpenRegionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|handler
operator|.
name|OpenRootHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|metrics
operator|.
name|RegionServerMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|wal
operator|.
name|HLog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|wal
operator|.
name|WALObserver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|regionserver
operator|.
name|Replication
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|InfoServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Sleeper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ClusterStatusTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|MapWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|DNS
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_comment
comment|/**  * HRegionServer makes a set of HRegions available to clients. It checks in with  * the HMaster. There are many HRegionServers in a single HBase deployment.  */
end_comment

begin_class
specifier|public
class|class
name|HRegionServer
implements|implements
name|HRegionInterface
implements|,
name|HBaseRPCErrorHandler
implements|,
name|Runnable
implements|,
name|RegionServerServices
implements|,
name|Server
block|{
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HRegionServer
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Set when a report to the master comes back with a message asking us to
comment|// shutdown. Also set by call to stop when debugging or running unit tests
comment|// of HRegionServer in isolation.
specifier|protected
specifier|volatile
name|boolean
name|stopped
init|=
literal|false
decl_stmt|;
comment|// Go down hard. Used if file system becomes unavailable and also in
comment|// debugging and unit tests.
specifier|protected
specifier|volatile
name|boolean
name|abortRequested
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|killed
init|=
literal|false
decl_stmt|;
comment|// If false, the file system has become unavailable
specifier|protected
specifier|volatile
name|boolean
name|fsOk
decl_stmt|;
specifier|protected
name|HServerInfo
name|serverInfo
decl_stmt|;
specifier|protected
specifier|final
name|Configuration
name|conf
decl_stmt|;
specifier|private
specifier|final
name|HConnection
name|connection
decl_stmt|;
specifier|protected
specifier|final
name|AtomicBoolean
name|haveRootRegion
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|private
name|FileSystem
name|fs
decl_stmt|;
specifier|private
name|Path
name|rootDir
decl_stmt|;
specifier|private
specifier|final
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
comment|/**    * Map of regions currently being served by this region server. Key is the    * encoded region name.    */
specifier|protected
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|HRegion
argument_list|>
name|onlineRegions
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|HRegion
argument_list|>
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|ReentrantReadWriteLock
name|lock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|LinkedBlockingQueue
argument_list|<
name|HMsg
argument_list|>
name|outboundMsgs
init|=
operator|new
name|LinkedBlockingQueue
argument_list|<
name|HMsg
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|int
name|numRetries
decl_stmt|;
specifier|protected
specifier|final
name|int
name|threadWakeFrequency
decl_stmt|;
specifier|private
specifier|final
name|int
name|msgInterval
decl_stmt|;
specifier|protected
specifier|final
name|int
name|numRegionsToReport
decl_stmt|;
specifier|private
specifier|final
name|long
name|maxScannerResultSize
decl_stmt|;
comment|// Remote HMaster
specifier|private
name|HMasterRegionInterface
name|hbaseMaster
decl_stmt|;
comment|// Server to handle client requests. Default access so can be accessed by
comment|// unit tests.
name|HBaseServer
name|server
decl_stmt|;
comment|// Leases
specifier|private
name|Leases
name|leases
decl_stmt|;
comment|// Request counter
specifier|private
specifier|volatile
name|AtomicInteger
name|requestCount
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|// Info server. Default access so can be used by unit tests. REGIONSERVER
comment|// is name of the webapp and the attribute name used stuffing this instance
comment|// into web context.
name|InfoServer
name|infoServer
decl_stmt|;
comment|/** region server process name */
specifier|public
specifier|static
specifier|final
name|String
name|REGIONSERVER
init|=
literal|"regionserver"
decl_stmt|;
comment|/*    * Space is reserved in HRS constructor and then released when aborting to    * recover from an OOME. See HBASE-706. TODO: Make this percentage of the heap    * or a minimum.    */
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|byte
index|[]
argument_list|>
name|reservedSpace
init|=
operator|new
name|LinkedList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|RegionServerMetrics
name|metrics
decl_stmt|;
comment|// Compactions
name|CompactSplitThread
name|compactSplitThread
decl_stmt|;
comment|// Cache flushing
name|MemStoreFlusher
name|cacheFlusher
decl_stmt|;
comment|/*    * Check for major compactions.    */
name|Chore
name|majorCompactionChecker
decl_stmt|;
comment|// HLog and HLog roller. log is protected rather than private to avoid
comment|// eclipse warning when accessed by inner classes
specifier|protected
specifier|volatile
name|HLog
name|hlog
decl_stmt|;
name|LogRoller
name|hlogRoller
decl_stmt|;
comment|// flag set after we're done setting up server threads (used for testing)
specifier|protected
specifier|volatile
name|boolean
name|isOnline
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|InternalScanner
argument_list|>
name|scanners
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|InternalScanner
argument_list|>
argument_list|()
decl_stmt|;
comment|// zookeeper connection and watcher
specifier|private
name|ZooKeeperWatcher
name|zooKeeper
decl_stmt|;
comment|// master address manager and watcher
specifier|private
name|MasterAddressTracker
name|masterAddressManager
decl_stmt|;
comment|// catalog tracker
specifier|private
name|CatalogTracker
name|catalogTracker
decl_stmt|;
comment|// Cluster Status Tracker
specifier|private
name|ClusterStatusTracker
name|clusterStatusTracker
decl_stmt|;
comment|// A sleeper that sleeps for msgInterval.
specifier|private
specifier|final
name|Sleeper
name|sleeper
decl_stmt|;
specifier|private
specifier|final
name|long
name|rpcTimeout
decl_stmt|;
comment|// Address passed in to constructor. This is not always the address we run
comment|// with. For example, if passed port is 0, then we are to pick a port. The
comment|// actual address we run with is in the #serverInfo data member.
specifier|private
specifier|final
name|HServerAddress
name|address
decl_stmt|;
comment|// The main region server thread.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|private
name|Thread
name|regionServerThread
decl_stmt|;
specifier|private
specifier|final
name|String
name|machineName
decl_stmt|;
comment|// Instance of the hbase executor service.
specifier|private
name|ExecutorService
name|service
decl_stmt|;
comment|// Replication services. If no replication, this handler will be null.
specifier|private
name|Replication
name|replicationHandler
decl_stmt|;
comment|/**    * Starts a HRegionServer at the default location    *    * @param conf    * @throws IOException    * @throws InterruptedException     */
specifier|public
name|HRegionServer
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|this
operator|.
name|machineName
operator|=
name|DNS
operator|.
name|getDefaultHost
argument_list|(
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.regionserver.dns.interface"
argument_list|,
literal|"default"
argument_list|)
argument_list|,
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.regionserver.dns.nameserver"
argument_list|,
literal|"default"
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|addressStr
init|=
name|machineName
operator|+
literal|":"
operator|+
name|conf
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|REGIONSERVER_PORT
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|HConstants
operator|.
name|DEFAULT_REGIONSERVER_PORT
argument_list|)
argument_list|)
decl_stmt|;
comment|// This is not necessarily the address we will run with. The address we
comment|// use will be in #serverInfo data member. For example, we may have been
comment|// passed a port of 0 which means we should pick some ephemeral port to bind
comment|// to.
name|this
operator|.
name|address
operator|=
operator|new
name|HServerAddress
argument_list|(
name|addressStr
argument_list|)
expr_stmt|;
name|this
operator|.
name|fsOk
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|connection
operator|=
name|HConnectionManager
operator|.
name|getConnection
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|isOnline
operator|=
literal|false
expr_stmt|;
comment|// Config'ed params
name|this
operator|.
name|numRetries
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.client.retries.number"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|this
operator|.
name|threadWakeFrequency
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|THREAD_WAKE_FREQUENCY
argument_list|,
literal|10
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|this
operator|.
name|msgInterval
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.msginterval"
argument_list|,
literal|1
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|sleeper
operator|=
operator|new
name|Sleeper
argument_list|(
name|this
operator|.
name|msgInterval
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxScannerResultSize
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_SCANNER_MAX_RESULT_SIZE_KEY
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_SCANNER_MAX_RESULT_SIZE
argument_list|)
expr_stmt|;
name|this
operator|.
name|numRegionsToReport
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.numregionstoreport"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|this
operator|.
name|rpcTimeout
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|HConstants
operator|.
name|HBASE_REGIONSERVER_LEASE_PERIOD_KEY
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_REGIONSERVER_LEASE_PERIOD
argument_list|)
expr_stmt|;
name|initialize
argument_list|()
expr_stmt|;
block|}
specifier|private
specifier|static
specifier|final
name|int
name|NORMAL_QOS
init|=
literal|0
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|QOS_THRESHOLD
init|=
literal|10
decl_stmt|;
comment|// the line between low and high qos
specifier|private
specifier|static
specifier|final
name|int
name|HIGH_QOS
init|=
literal|100
decl_stmt|;
class|class
name|QosFunction
implements|implements
name|Function
argument_list|<
name|Writable
argument_list|,
name|Integer
argument_list|>
block|{
specifier|public
name|boolean
name|isMetaRegion
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|)
block|{
name|HRegion
name|region
decl_stmt|;
try|try
block|{
name|region
operator|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotServingRegionException
name|ignored
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isMetaRegion
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Integer
name|apply
parameter_list|(
name|Writable
name|from
parameter_list|)
block|{
if|if
condition|(
name|from
operator|instanceof
name|HBaseRPC
operator|.
name|Invocation
condition|)
block|{
name|HBaseRPC
operator|.
name|Invocation
name|inv
init|=
operator|(
name|HBaseRPC
operator|.
name|Invocation
operator|)
name|from
decl_stmt|;
name|String
name|methodName
init|=
name|inv
operator|.
name|getMethodName
argument_list|()
decl_stmt|;
comment|// scanner methods...
if|if
condition|(
name|methodName
operator|.
name|equals
argument_list|(
literal|"next"
argument_list|)
operator|||
name|methodName
operator|.
name|equals
argument_list|(
literal|"close"
argument_list|)
condition|)
block|{
comment|// translate!
name|Long
name|scannerId
decl_stmt|;
try|try
block|{
name|scannerId
operator|=
operator|(
name|Long
operator|)
name|inv
operator|.
name|getParameters
argument_list|()
index|[
literal|0
index|]
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|ignored
parameter_list|)
block|{
comment|//LOG.debug("Low priority: " + from);
return|return
name|NORMAL_QOS
return|;
comment|// doh.
block|}
name|String
name|scannerIdString
init|=
name|Long
operator|.
name|toString
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
name|InternalScanner
name|scanner
init|=
name|scanners
operator|.
name|get
argument_list|(
name|scannerIdString
argument_list|)
decl_stmt|;
if|if
condition|(
name|scanner
operator|instanceof
name|HRegion
operator|.
name|RegionScanner
condition|)
block|{
name|HRegion
operator|.
name|RegionScanner
name|rs
init|=
operator|(
name|HRegion
operator|.
name|RegionScanner
operator|)
name|scanner
decl_stmt|;
name|HRegionInfo
name|regionName
init|=
name|rs
operator|.
name|getRegionName
argument_list|()
decl_stmt|;
if|if
condition|(
name|regionName
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
comment|//LOG.debug("High priority scanner request: " + scannerId);
return|return
name|HIGH_QOS
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|methodName
operator|.
name|equals
argument_list|(
literal|"getHServerInfo"
argument_list|)
operator|||
name|methodName
operator|.
name|equals
argument_list|(
literal|"getRegionsAssignment"
argument_list|)
operator|||
name|methodName
operator|.
name|equals
argument_list|(
literal|"unlockRow"
argument_list|)
operator|||
name|methodName
operator|.
name|equals
argument_list|(
literal|"getProtocolVersion"
argument_list|)
operator|||
name|methodName
operator|.
name|equals
argument_list|(
literal|"getClosestRowBefore"
argument_list|)
condition|)
block|{
comment|//LOG.debug("High priority method: " + methodName);
return|return
name|HIGH_QOS
return|;
block|}
elseif|else
if|if
condition|(
name|inv
operator|.
name|getParameterClasses
argument_list|()
index|[
literal|0
index|]
operator|==
name|byte
index|[]
operator|.
name|class
condition|)
block|{
comment|// first arg is byte array, so assume this is a regionname:
if|if
condition|(
name|isMetaRegion
argument_list|(
operator|(
name|byte
index|[]
operator|)
name|inv
operator|.
name|getParameters
argument_list|()
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|//LOG.debug("High priority with method: " + methodName + " and region: "
comment|//    + Bytes.toString((byte[]) inv.getParameters()[0]));
return|return
name|HIGH_QOS
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|inv
operator|.
name|getParameterClasses
argument_list|()
index|[
literal|0
index|]
operator|==
name|MultiAction
operator|.
name|class
condition|)
block|{
name|MultiAction
name|ma
init|=
operator|(
name|MultiAction
operator|)
name|inv
operator|.
name|getParameters
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
name|Set
argument_list|<
name|byte
index|[]
argument_list|>
name|regions
init|=
name|ma
operator|.
name|getRegions
argument_list|()
decl_stmt|;
comment|// ok this sucks, but if any single of the actions touches a meta, the whole
comment|// thing gets pingged high priority.  This is a dangerous hack because people
comment|// can get their multi action tagged high QOS by tossing a Get(.META.) AND this
comment|// regionserver hosts META/-ROOT-
for|for
control|(
name|byte
index|[]
name|region
range|:
name|regions
control|)
block|{
if|if
condition|(
name|isMetaRegion
argument_list|(
name|region
argument_list|)
condition|)
block|{
comment|//LOG.debug("High priority multi with region: " + Bytes.toString(region));
return|return
name|HIGH_QOS
return|;
comment|// short circuit for the win.
block|}
block|}
block|}
block|}
comment|//LOG.debug("Low priority: " + from.toString());
return|return
name|NORMAL_QOS
return|;
block|}
block|}
comment|/**    * Creates all of the state that needs to be reconstructed in case we are    * doing a restart. This is shared between the constructor and restart(). Both    * call it.    *    * @throws IOException    * @throws InterruptedException     */
specifier|private
name|void
name|initialize
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|this
operator|.
name|abortRequested
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|stopped
operator|=
literal|false
expr_stmt|;
comment|// Server to handle client requests
name|this
operator|.
name|server
operator|=
name|HBaseRPC
operator|.
name|getServer
argument_list|(
name|this
argument_list|,
operator|new
name|Class
argument_list|<
name|?
argument_list|>
index|[]
block|{
name|HRegionInterface
operator|.
name|class
operator|,
name|HBaseRPCErrorHandler
operator|.
name|class
operator|,
name|OnlineRegions
operator|.
name|class
block|}
operator|,
name|address
operator|.
name|getBindAddress
argument_list|()
operator|,
name|address
operator|.
name|getPort
argument_list|()
operator|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.handler.count"
argument_list|,
literal|10
argument_list|)
operator|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.metahandler.count"
argument_list|,
literal|10
argument_list|)
operator|,
literal|false
operator|,
name|conf
operator|,
name|QOS_THRESHOLD
block|)
function|;
name|this
operator|.
name|server
operator|.
name|setErrorHandler
parameter_list|(
name|this
parameter_list|)
constructor_decl|;
name|this
operator|.
name|server
operator|.
name|setQosFunction
argument_list|(
operator|new
name|QosFunction
argument_list|()
argument_list|)
expr_stmt|;
comment|// Address is giving a default IP for the moment. Will be changed after
comment|// calling the master.
name|this
operator|.
name|serverInfo
operator|=
operator|new
name|HServerInfo
argument_list|(
operator|new
name|HServerAddress
argument_list|(
operator|new
name|InetSocketAddress
argument_list|(
name|address
operator|.
name|getBindAddress
argument_list|()
argument_list|,
name|this
operator|.
name|server
operator|.
name|getListenerAddress
argument_list|()
operator|.
name|getPort
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|,
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.info.port"
argument_list|,
literal|60030
argument_list|)
argument_list|,
name|machineName
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Server address cannot be null; "
operator|+
literal|"hbase-958 debugging"
argument_list|)
throw|;
block|}
name|initializeZooKeeper
parameter_list|()
constructor_decl|;
name|initializeThreads
parameter_list|()
constructor_decl|;
name|int
name|nbBlocks
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.nbreservationblocks"
argument_list|,
literal|4
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nbBlocks
condition|;
name|i
operator|++
control|)
block|{
name|reservedSpace
operator|.
name|add
argument_list|(
operator|new
name|byte
index|[
name|HConstants
operator|.
name|DEFAULT_SIZE_RESERVATION_BLOCK
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_class

begin_comment
comment|/**    * Bring up connection to zk ensemble and then wait until a master for this    * cluster and then after that, wait until cluster 'up' flag has been set.    * This is the order in which master does things.    * Finally put up a catalog tracker.    * @throws IOException    * @throws InterruptedException    */
end_comment

begin_function
specifier|private
name|void
name|initializeZooKeeper
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
comment|// Open connection to zookeeper and set primary watcher
name|zooKeeper
operator|=
operator|new
name|ZooKeeperWatcher
argument_list|(
name|conf
argument_list|,
name|REGIONSERVER
operator|+
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|getPort
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|// Create the master address manager, register with zk, and start it.  Then
comment|// block until a master is available.  No point in starting up if no master
comment|// running.
name|this
operator|.
name|masterAddressManager
operator|=
operator|new
name|MasterAddressTracker
argument_list|(
name|zooKeeper
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|masterAddressManager
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|masterAddressManager
operator|.
name|blockUntilAvailable
argument_list|()
expr_stmt|;
comment|// Wait on cluster being up.  Master will set this flag up in zookeeper
comment|// when ready.
name|this
operator|.
name|clusterStatusTracker
operator|=
operator|new
name|ClusterStatusTracker
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|clusterStatusTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|clusterStatusTracker
operator|.
name|blockUntilAvailable
argument_list|()
expr_stmt|;
comment|// Create the catalog tracker and start it;
name|this
operator|.
name|catalogTracker
operator|=
operator|new
name|CatalogTracker
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|this
operator|.
name|connection
argument_list|,
name|this
argument_list|,
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.catalog.timeout"
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
expr_stmt|;
name|catalogTracker
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * @return True if cluster shutdown in progress    */
end_comment

begin_function
specifier|private
name|boolean
name|isClusterUp
parameter_list|()
block|{
return|return
name|this
operator|.
name|clusterStatusTracker
operator|.
name|isClusterUp
argument_list|()
return|;
block|}
end_function

begin_function
specifier|private
name|void
name|initializeThreads
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Cache flushing thread.
name|this
operator|.
name|cacheFlusher
operator|=
operator|new
name|MemStoreFlusher
argument_list|(
name|conf
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|// Compaction thread
name|this
operator|.
name|compactSplitThread
operator|=
operator|new
name|CompactSplitThread
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Background thread to check for major compactions; needed if region
comment|// has not gotten updates in a while. Make it run at a lesser frequency.
name|int
name|multiplier
init|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|THREAD_WAKE_FREQUENCY
operator|+
literal|".multiplier"
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
name|this
operator|.
name|majorCompactionChecker
operator|=
operator|new
name|MajorCompactionChecker
argument_list|(
name|this
argument_list|,
name|this
operator|.
name|threadWakeFrequency
operator|*
name|multiplier
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|leases
operator|=
operator|new
name|Leases
argument_list|(
operator|(
name|int
operator|)
name|conf
operator|.
name|getLong
argument_list|(
name|HConstants
operator|.
name|HBASE_REGIONSERVER_LEASE_PERIOD_KEY
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_REGIONSERVER_LEASE_PERIOD
argument_list|)
argument_list|,
name|this
operator|.
name|threadWakeFrequency
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * The HRegionServer sticks in this loop until closed. It repeatedly checks in    * with the HMaster, sending heartbeats& reports, and receiving HRegion    * load/unload instructions.    */
end_comment

begin_function
specifier|public
name|void
name|run
parameter_list|()
block|{
name|this
operator|.
name|regionServerThread
operator|=
name|Thread
operator|.
name|currentThread
argument_list|()
expr_stmt|;
name|boolean
name|calledCloseUserRegions
init|=
literal|false
decl_stmt|;
try|try
block|{
while|while
condition|(
operator|!
name|this
operator|.
name|stopped
condition|)
block|{
if|if
condition|(
name|tryReportForDuty
argument_list|()
condition|)
break|break;
block|}
name|long
name|lastMsg
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|HMsg
argument_list|>
name|outboundMessages
init|=
operator|new
name|ArrayList
argument_list|<
name|HMsg
argument_list|>
argument_list|()
decl_stmt|;
comment|// The main run loop.
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
operator|!
name|this
operator|.
name|stopped
operator|&&
name|isHealthy
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|isClusterUp
argument_list|()
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|onlineRegions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|stop
argument_list|(
literal|"Exiting; cluster shutdown set and not carrying any regions"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|calledCloseUserRegions
condition|)
block|{
name|closeUserRegions
argument_list|(
name|this
operator|.
name|abortRequested
argument_list|)
expr_stmt|;
name|calledCloseUserRegions
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// Try to get the root region location from zookeeper.
name|this
operator|.
name|catalogTracker
operator|.
name|waitForRoot
argument_list|()
expr_stmt|;
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|// Drop into the send loop if msgInterval has elapsed or if something
comment|// to send. If we fail talking to the master, then we'll sleep below
comment|// on poll of the outboundMsgs blockingqueue.
if|if
condition|(
operator|(
name|now
operator|-
name|lastMsg
operator|)
operator|>=
name|msgInterval
operator|||
operator|!
name|outboundMessages
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
try|try
block|{
name|doMetrics
argument_list|()
expr_stmt|;
name|tryRegionServerReport
argument_list|(
name|outboundMessages
argument_list|)
expr_stmt|;
name|lastMsg
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
comment|// Reset tries count if we had a successful transaction.
name|tries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|stopped
condition|)
continue|continue;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// FindBugs REC_CATCH_EXCEPTION
comment|// Two special exceptions could be printed out here,
comment|// PleaseHoldException and YouAreDeadException
if|if
condition|(
name|e
operator|instanceof
name|IOException
condition|)
block|{
name|e
operator|=
name|RemoteExceptionHandler
operator|.
name|checkIOException
argument_list|(
operator|(
name|IOException
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|instanceof
name|YouAreDeadException
condition|)
block|{
comment|// This will be caught and handled as a fatal error below
throw|throw
name|e
throw|;
block|}
name|tries
operator|++
expr_stmt|;
if|if
condition|(
name|tries
operator|>
literal|0
operator|&&
operator|(
name|tries
operator|%
name|this
operator|.
name|numRetries
operator|)
operator|==
literal|0
condition|)
block|{
comment|// Check filesystem every so often.
name|checkFileSystem
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|stopped
condition|)
block|{
continue|continue;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"Attempt="
operator|+
name|tries
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// No point retrying immediately; this is probably connection to
comment|// master issue. Doing below will cause us to sleep.
name|lastMsg
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
block|}
name|now
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|HMsg
name|msg
init|=
name|this
operator|.
name|outboundMsgs
operator|.
name|poll
argument_list|(
operator|(
name|msgInterval
operator|-
operator|(
name|now
operator|-
name|lastMsg
operator|)
operator|)
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
operator|!=
literal|null
condition|)
name|outboundMessages
operator|.
name|add
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
comment|// for
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|checkOOME
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|abort
argument_list|(
literal|"Unhandled exception"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|leases
operator|.
name|closeAfterLeasesExpire
argument_list|()
expr_stmt|;
name|this
operator|.
name|server
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|infoServer
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping infoServer"
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|infoServer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Send cache a shutdown.
name|LruBlockCache
name|c
init|=
operator|(
name|LruBlockCache
operator|)
name|StoreFile
operator|.
name|getBlockCache
argument_list|(
name|this
operator|.
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
name|c
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
comment|// Send interrupts to wake up threads if sleeping so they notice shutdown.
comment|// TODO: Should we check they are alive? If OOME could have exited already
name|cacheFlusher
operator|.
name|interruptIfNecessary
argument_list|()
expr_stmt|;
name|compactSplitThread
operator|.
name|interruptIfNecessary
argument_list|()
expr_stmt|;
name|hlogRoller
operator|.
name|interruptIfNecessary
argument_list|()
expr_stmt|;
name|this
operator|.
name|majorCompactionChecker
operator|.
name|interrupt
argument_list|()
expr_stmt|;
if|if
condition|(
name|killed
condition|)
block|{
comment|// Just skip out w/o closing regions.
block|}
elseif|else
if|if
condition|(
name|abortRequested
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|fsOk
condition|)
block|{
name|closeAllRegions
argument_list|(
name|abortRequested
argument_list|)
expr_stmt|;
comment|// Don't leave any open file handles
name|closeWAL
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"aborting server at: "
operator|+
name|this
operator|.
name|serverInfo
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|closeAllRegions
argument_list|(
name|abortRequested
argument_list|)
expr_stmt|;
name|closeWAL
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|closeAllScanners
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"stopping server at: "
operator|+
name|this
operator|.
name|serverInfo
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|waitOnAllRegionsToClose
argument_list|()
expr_stmt|;
comment|// Make sure the proxy is down.
if|if
condition|(
name|this
operator|.
name|hbaseMaster
operator|!=
literal|null
condition|)
block|{
name|HBaseRPC
operator|.
name|stopProxy
argument_list|(
name|this
operator|.
name|hbaseMaster
argument_list|)
expr_stmt|;
name|this
operator|.
name|hbaseMaster
operator|=
literal|null
expr_stmt|;
block|}
name|this
operator|.
name|leases
operator|.
name|close
argument_list|()
expr_stmt|;
name|HConnectionManager
operator|.
name|deleteConnection
argument_list|(
name|conf
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|zooKeeper
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|killed
condition|)
block|{
name|join
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" exiting"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Wait on regions close.    */
end_comment

begin_function
specifier|private
name|void
name|waitOnAllRegionsToClose
parameter_list|()
block|{
comment|// Wait till all regions are closed before going out.
name|int
name|lastCount
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
operator|!
name|this
operator|.
name|onlineRegions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|count
init|=
name|this
operator|.
name|onlineRegions
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// Only print a message if the count of regions has changed.
if|if
condition|(
name|count
operator|!=
name|lastCount
condition|)
block|{
name|lastCount
operator|=
name|count
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting on "
operator|+
name|count
operator|+
literal|" regions to close"
argument_list|)
expr_stmt|;
comment|// Only print out regions still closing if a small number else will
comment|// swamp the log.
if|if
condition|(
name|count
operator|<
literal|10
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|this
operator|.
name|onlineRegions
argument_list|)
expr_stmt|;
block|}
block|}
name|Threads
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|List
argument_list|<
name|HMsg
argument_list|>
name|tryRegionServerReport
parameter_list|(
specifier|final
name|List
argument_list|<
name|HMsg
argument_list|>
name|outboundMessages
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|serverInfo
operator|.
name|setLoad
argument_list|(
name|buildServerLoad
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|requestCount
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|addOutboundMsgs
argument_list|(
name|outboundMessages
argument_list|)
expr_stmt|;
name|HMsg
index|[]
name|msgs
init|=
name|this
operator|.
name|hbaseMaster
operator|.
name|regionServerReport
argument_list|(
name|this
operator|.
name|serverInfo
argument_list|,
name|outboundMessages
operator|.
name|toArray
argument_list|(
name|HMsg
operator|.
name|EMPTY_HMSG_ARRAY
argument_list|)
argument_list|,
name|getMostLoadedRegions
argument_list|()
argument_list|)
decl_stmt|;
name|updateOutboundMsgs
argument_list|(
name|outboundMessages
argument_list|)
expr_stmt|;
name|outboundMessages
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
operator|!
name|this
operator|.
name|stopped
operator|&&
name|msgs
operator|!=
literal|null
operator|&&
name|i
operator|<
name|msgs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|msgs
index|[
name|i
index|]
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Intercept stop regionserver messages
if|if
condition|(
name|msgs
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|HMsg
operator|.
name|Type
operator|.
name|STOP_REGIONSERVER
argument_list|)
condition|)
block|{
name|stop
argument_list|(
literal|"Received "
operator|+
name|msgs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"NOT PROCESSING "
operator|+
name|msgs
index|[
name|i
index|]
operator|+
literal|" -- WHY IS MASTER SENDING IT TO US?"
argument_list|)
expr_stmt|;
block|}
return|return
name|outboundMessages
return|;
block|}
end_function

begin_function
specifier|private
name|HServerLoad
name|buildServerLoad
parameter_list|()
block|{
name|MemoryUsage
name|memory
init|=
name|ManagementFactory
operator|.
name|getMemoryMXBean
argument_list|()
operator|.
name|getHeapMemoryUsage
argument_list|()
decl_stmt|;
name|HServerLoad
name|hsl
init|=
operator|new
name|HServerLoad
argument_list|(
name|requestCount
operator|.
name|get
argument_list|()
argument_list|,
call|(
name|int
call|)
argument_list|(
name|memory
operator|.
name|getUsed
argument_list|()
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|memory
operator|.
name|getMax
argument_list|()
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|HRegion
name|r
range|:
name|this
operator|.
name|onlineRegions
operator|.
name|values
argument_list|()
control|)
block|{
name|hsl
operator|.
name|addRegionInfo
argument_list|(
name|createRegionLoad
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|hsl
return|;
block|}
end_function

begin_function
specifier|private
name|void
name|closeWAL
parameter_list|(
specifier|final
name|boolean
name|delete
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|this
operator|.
name|hlog
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|delete
condition|)
block|{
name|hlog
operator|.
name|closeAndDelete
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|hlog
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Close and delete failed"
argument_list|,
name|RemoteExceptionHandler
operator|.
name|checkThrowable
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|private
name|void
name|closeAllScanners
parameter_list|()
block|{
comment|// Close any outstanding scanners. Means they'll get an UnknownScanner
comment|// exception next time they come in.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|InternalScanner
argument_list|>
name|e
range|:
name|this
operator|.
name|scanners
operator|.
name|entrySet
argument_list|()
control|)
block|{
try|try
block|{
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Closing scanner "
operator|+
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*    * Add to the passed<code>msgs</code> messages to pass to the master.    *    * @param msgs Current outboundMsgs array; we'll add messages to this List.    */
end_comment

begin_function
specifier|private
name|void
name|addOutboundMsgs
parameter_list|(
specifier|final
name|List
argument_list|<
name|HMsg
argument_list|>
name|msgs
parameter_list|)
block|{
if|if
condition|(
name|msgs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|this
operator|.
name|outboundMsgs
operator|.
name|drainTo
argument_list|(
name|msgs
argument_list|)
expr_stmt|;
return|return;
block|}
name|OUTER
label|:
for|for
control|(
name|HMsg
name|m
range|:
name|this
operator|.
name|outboundMsgs
control|)
block|{
for|for
control|(
name|HMsg
name|mm
range|:
name|msgs
control|)
block|{
comment|// Be careful don't add duplicates.
if|if
condition|(
name|mm
operator|.
name|equals
argument_list|(
name|m
argument_list|)
condition|)
block|{
continue|continue
name|OUTER
continue|;
block|}
block|}
name|msgs
operator|.
name|add
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*    * Remove from this.outboundMsgs those messsages we sent the master.    *    * @param msgs Messages we sent the master.    */
end_comment

begin_function
specifier|private
name|void
name|updateOutboundMsgs
parameter_list|(
specifier|final
name|List
argument_list|<
name|HMsg
argument_list|>
name|msgs
parameter_list|)
block|{
if|if
condition|(
name|msgs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
for|for
control|(
name|HMsg
name|m
range|:
name|this
operator|.
name|outboundMsgs
control|)
block|{
for|for
control|(
name|HMsg
name|mm
range|:
name|msgs
control|)
block|{
if|if
condition|(
name|mm
operator|.
name|equals
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|this
operator|.
name|outboundMsgs
operator|.
name|remove
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*    * Run init. Sets up hlog and starts up all server threads.    *    * @param c Extra configuration.    */
end_comment

begin_function
specifier|protected
name|void
name|handleReportForDutyResponse
parameter_list|(
specifier|final
name|MapWritable
name|c
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Writable
argument_list|,
name|Writable
argument_list|>
name|e
range|:
name|c
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|value
init|=
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Config from master: "
operator|+
name|key
operator|+
literal|"="
operator|+
name|value
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|conf
operator|.
name|set
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|// Master may have sent us a new address with the other configs.
comment|// Update our address in this case. See HBASE-719
name|String
name|hra
init|=
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.regionserver.address"
argument_list|)
decl_stmt|;
comment|// TODO: The below used to be this.address != null. Was broken by what
comment|// looks like a mistake in:
comment|//
comment|// HBASE-1215 migration; metautils scan of meta region was broken;
comment|// wouldn't see first row
comment|// ------------------------------------------------------------------------
comment|// r796326 | stack | 2009-07-21 07:40:34 -0700 (Tue, 21 Jul 2009) | 38
comment|// lines
if|if
condition|(
name|hra
operator|!=
literal|null
condition|)
block|{
name|HServerAddress
name|hsa
init|=
operator|new
name|HServerAddress
argument_list|(
name|hra
argument_list|,
name|this
operator|.
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|getPort
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Master passed us address to use. Was="
operator|+
name|this
operator|.
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|+
literal|", Now="
operator|+
name|hsa
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|serverInfo
operator|.
name|setServerAddress
argument_list|(
name|hsa
argument_list|)
expr_stmt|;
block|}
comment|// hack! Maps DFSClient => RegionServer for logs.  HDFS made this
comment|// config param for task trackers, but we can piggyback off of it.
if|if
condition|(
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
literal|"mapred.task.id"
argument_list|)
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|conf
operator|.
name|set
argument_list|(
literal|"mapred.task.id"
argument_list|,
literal|"hb_rs_"
operator|+
name|this
operator|.
name|serverInfo
operator|.
name|getServerName
argument_list|()
operator|+
literal|"_"
operator|+
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Master sent us hbase.rootdir to use. Should be fully qualified
comment|// path with file system specification included. Set 'fs.defaultFS'
comment|// to match the filesystem on hbase.rootdir else underlying hadoop hdfs
comment|// accessors will be going against wrong filesystem (unless all is set
comment|// to defaults).
name|this
operator|.
name|conf
operator|.
name|set
argument_list|(
literal|"fs.defaultFS"
argument_list|,
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.rootdir"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Get fs instance used by this RS
name|this
operator|.
name|fs
operator|=
name|FileSystem
operator|.
name|get
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|rootDir
operator|=
operator|new
name|Path
argument_list|(
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|HBASE_DIR
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|hlog
operator|=
name|setupWALAndReplication
argument_list|()
expr_stmt|;
comment|// Init in here rather than in constructor after thread name has been set
name|this
operator|.
name|metrics
operator|=
operator|new
name|RegionServerMetrics
argument_list|()
expr_stmt|;
name|startServiceThreads
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Serving as "
operator|+
name|this
operator|.
name|serverInfo
operator|.
name|getServerName
argument_list|()
operator|+
literal|", sessionid=0x"
operator|+
name|Long
operator|.
name|toHexString
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|getZooKeeper
argument_list|()
operator|.
name|getSessionId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|isOnline
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|this
operator|.
name|isOnline
operator|=
literal|false
expr_stmt|;
name|stop
argument_list|(
literal|"Failed initialization"
argument_list|)
expr_stmt|;
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|e
argument_list|,
literal|"Failed init"
argument_list|)
argument_list|,
literal|"Region server startup failed"
argument_list|)
throw|;
block|}
block|}
end_function

begin_comment
comment|/*    * @param r Region to get RegionLoad for.    *    * @return RegionLoad instance.    *    * @throws IOException    */
end_comment

begin_function
specifier|private
name|HServerLoad
operator|.
name|RegionLoad
name|createRegionLoad
parameter_list|(
specifier|final
name|HRegion
name|r
parameter_list|)
block|{
name|byte
index|[]
name|name
init|=
name|r
operator|.
name|getRegionName
argument_list|()
decl_stmt|;
name|int
name|stores
init|=
literal|0
decl_stmt|;
name|int
name|storefiles
init|=
literal|0
decl_stmt|;
name|int
name|storefileSizeMB
init|=
literal|0
decl_stmt|;
name|int
name|memstoreSizeMB
init|=
call|(
name|int
call|)
argument_list|(
name|r
operator|.
name|memstoreSize
operator|.
name|get
argument_list|()
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
decl_stmt|;
name|int
name|storefileIndexSizeMB
init|=
literal|0
decl_stmt|;
synchronized|synchronized
init|(
name|r
operator|.
name|stores
init|)
block|{
name|stores
operator|+=
name|r
operator|.
name|stores
operator|.
name|size
argument_list|()
expr_stmt|;
for|for
control|(
name|Store
name|store
range|:
name|r
operator|.
name|stores
operator|.
name|values
argument_list|()
control|)
block|{
name|storefiles
operator|+=
name|store
operator|.
name|getStorefilesCount
argument_list|()
expr_stmt|;
name|storefileSizeMB
operator|+=
call|(
name|int
call|)
argument_list|(
name|store
operator|.
name|getStorefilesSize
argument_list|()
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|storefileIndexSizeMB
operator|+=
call|(
name|int
call|)
argument_list|(
name|store
operator|.
name|getStorefilesIndexSize
argument_list|()
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|HServerLoad
operator|.
name|RegionLoad
argument_list|(
name|name
argument_list|,
name|stores
argument_list|,
name|storefiles
argument_list|,
name|storefileSizeMB
argument_list|,
name|memstoreSizeMB
argument_list|,
name|storefileIndexSizeMB
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * @param encodedRegionName    * @return An instance of RegionLoad.    * @throws IOException    */
end_comment

begin_function
specifier|public
name|HServerLoad
operator|.
name|RegionLoad
name|createRegionLoad
parameter_list|(
specifier|final
name|String
name|encodedRegionName
parameter_list|)
block|{
return|return
name|createRegionLoad
argument_list|(
name|this
operator|.
name|onlineRegions
operator|.
name|get
argument_list|(
name|encodedRegionName
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*    * Cleanup after Throwable caught invoking method. Converts<code>t</code> to    * IOE if it isn't already.    *    * @param t Throwable    *    * @return Throwable converted to an IOE; methods can only let out IOEs.    */
end_comment

begin_function
specifier|private
name|Throwable
name|cleanup
parameter_list|(
specifier|final
name|Throwable
name|t
parameter_list|)
block|{
return|return
name|cleanup
argument_list|(
name|t
argument_list|,
literal|null
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*    * Cleanup after Throwable caught invoking method. Converts<code>t</code> to    * IOE if it isn't already.    *    * @param t Throwable    *    * @param msg Message to log in error. Can be null.    *    * @return Throwable converted to an IOE; methods can only let out IOEs.    */
end_comment

begin_function
specifier|private
name|Throwable
name|cleanup
parameter_list|(
specifier|final
name|Throwable
name|t
parameter_list|,
specifier|final
name|String
name|msg
parameter_list|)
block|{
comment|// Don't log as error if NSRE; NSRE is 'normal' operation.
if|if
condition|(
name|t
operator|instanceof
name|NotServingRegionException
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"NotServingRegionException; "
operator|+
name|t
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
if|if
condition|(
name|msg
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|""
argument_list|,
name|RemoteExceptionHandler
operator|.
name|checkThrowable
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|,
name|RemoteExceptionHandler
operator|.
name|checkThrowable
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|checkOOME
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|checkFileSystem
argument_list|()
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/*    * @param t    *    * @return Make<code>t</code> an IOE if it isn't already.    */
end_comment

begin_function
specifier|private
name|IOException
name|convertThrowableToIOE
parameter_list|(
specifier|final
name|Throwable
name|t
parameter_list|)
block|{
return|return
name|convertThrowableToIOE
argument_list|(
name|t
argument_list|,
literal|null
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*    * @param t    *    * @param msg Message to put in new IOE if passed<code>t</code> is not an IOE    *    * @return Make<code>t</code> an IOE if it isn't already.    */
end_comment

begin_function
specifier|private
name|IOException
name|convertThrowableToIOE
parameter_list|(
specifier|final
name|Throwable
name|t
parameter_list|,
specifier|final
name|String
name|msg
parameter_list|)
block|{
return|return
operator|(
name|t
operator|instanceof
name|IOException
condition|?
operator|(
name|IOException
operator|)
name|t
else|:
name|msg
operator|==
literal|null
operator|||
name|msg
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|?
operator|new
name|IOException
argument_list|(
name|t
argument_list|)
else|:
operator|new
name|IOException
argument_list|(
name|msg
argument_list|,
name|t
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*    * Check if an OOME and if so, call abort.    *    * @param e    *    * @return True if we OOME'd and are aborting.    */
end_comment

begin_function
specifier|public
name|boolean
name|checkOOME
parameter_list|(
specifier|final
name|Throwable
name|e
parameter_list|)
block|{
name|boolean
name|stop
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|OutOfMemoryError
operator|||
operator|(
name|e
operator|.
name|getCause
argument_list|()
operator|!=
literal|null
operator|&&
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|OutOfMemoryError
operator|)
operator|||
operator|(
name|e
operator|.
name|getMessage
argument_list|()
operator|!=
literal|null
operator|&&
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"java.lang.OutOfMemoryError"
argument_list|)
operator|)
condition|)
block|{
name|abort
argument_list|(
literal|"OutOfMemoryError, aborting"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|stop
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|stop
return|;
block|}
end_function

begin_comment
comment|/**    * Checks to see if the file system is still accessible. If not, sets    * abortRequested and stopRequested    *    * @return false if file system is not available    */
end_comment

begin_function
specifier|protected
name|boolean
name|checkFileSystem
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|fsOk
operator|&&
name|this
operator|.
name|fs
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|FSUtils
operator|.
name|checkFileSystemAvailable
argument_list|(
name|this
operator|.
name|fs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|abort
argument_list|(
literal|"File System not available"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|this
operator|.
name|fsOk
operator|=
literal|false
expr_stmt|;
block|}
block|}
return|return
name|this
operator|.
name|fsOk
return|;
block|}
end_function

begin_comment
comment|/*    * Inner class that runs on a long period checking if regions need major    * compaction.    */
end_comment

begin_class
specifier|private
specifier|static
class|class
name|MajorCompactionChecker
extends|extends
name|Chore
block|{
specifier|private
specifier|final
name|HRegionServer
name|instance
decl_stmt|;
name|MajorCompactionChecker
parameter_list|(
specifier|final
name|HRegionServer
name|h
parameter_list|,
specifier|final
name|int
name|sleepTime
parameter_list|,
specifier|final
name|Stoppable
name|stopper
parameter_list|)
block|{
name|super
argument_list|(
literal|"MajorCompactionChecker"
argument_list|,
name|sleepTime
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|this
operator|.
name|instance
operator|=
name|h
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Runs every "
operator|+
name|sleepTime
operator|+
literal|"ms"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|chore
parameter_list|()
block|{
for|for
control|(
name|HRegion
name|r
range|:
name|this
operator|.
name|instance
operator|.
name|onlineRegions
operator|.
name|values
argument_list|()
control|)
block|{
try|try
block|{
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
name|r
operator|.
name|isMajorCompaction
argument_list|()
condition|)
block|{
comment|// Queue a compaction. Will recognize if major is needed.
name|this
operator|.
name|instance
operator|.
name|compactSplitThread
operator|.
name|requestCompaction
argument_list|(
name|r
argument_list|,
name|getName
argument_list|()
operator|+
literal|" requests major compaction"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed major compaction check on "
operator|+
name|r
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

begin_comment
comment|/**    * Report the status of the server. A server is online once all the startup is    * completed (setting up filesystem, starting service threads, etc.). This    * method is designed mostly to be useful in tests.    *    * @return true if online, false if not.    */
end_comment

begin_function
specifier|public
name|boolean
name|isOnline
parameter_list|()
block|{
return|return
name|isOnline
return|;
block|}
end_function

begin_comment
comment|/**    * Setup WAL log and replication if enabled.    * Replication setup is done in here because it wants to be hooked up to WAL.    * @return A WAL instance.    * @throws IOException    */
end_comment

begin_function
specifier|private
name|HLog
name|setupWALAndReplication
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|oldLogDir
init|=
operator|new
name|Path
argument_list|(
name|rootDir
argument_list|,
name|HConstants
operator|.
name|HREGION_OLDLOGDIR_NAME
argument_list|)
decl_stmt|;
name|Path
name|logdir
init|=
operator|new
name|Path
argument_list|(
name|rootDir
argument_list|,
name|HLog
operator|.
name|getHLogDirectoryName
argument_list|(
name|this
operator|.
name|serverInfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"logdir="
operator|+
name|logdir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|fs
operator|.
name|exists
argument_list|(
name|logdir
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RegionServerRunningException
argument_list|(
literal|"Region server already "
operator|+
literal|"running at "
operator|+
name|this
operator|.
name|serverInfo
operator|.
name|getServerName
argument_list|()
operator|+
literal|" because logdir "
operator|+
name|logdir
operator|.
name|toString
argument_list|()
operator|+
literal|" exists"
argument_list|)
throw|;
block|}
comment|// Instantiate replication manager if replication enabled.  Pass it the
comment|// log directories.
try|try
block|{
name|this
operator|.
name|replicationHandler
operator|=
name|Replication
operator|.
name|isReplication
argument_list|(
name|this
operator|.
name|conf
argument_list|)
condition|?
operator|new
name|Replication
argument_list|(
name|this
argument_list|,
name|this
operator|.
name|fs
argument_list|,
name|logdir
argument_list|,
name|oldLogDir
argument_list|)
else|:
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed replication handler create"
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|instantiateHLog
argument_list|(
name|logdir
argument_list|,
name|oldLogDir
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Called by {@link #setupWALAndReplication()} creating WAL instance.    * @param logdir    * @param oldLogDir    * @return WAL instance.    * @throws IOException    */
end_comment

begin_function
specifier|protected
name|HLog
name|instantiateHLog
parameter_list|(
name|Path
name|logdir
parameter_list|,
name|Path
name|oldLogDir
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|HLog
argument_list|(
name|this
operator|.
name|fs
argument_list|,
name|logdir
argument_list|,
name|oldLogDir
argument_list|,
name|this
operator|.
name|conf
argument_list|,
name|getWALActionListeners
argument_list|()
argument_list|,
name|this
operator|.
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Called by {@link #instantiateHLog(Path, Path)} setting up WAL instance.    * Add any {@link WALObserver}s you want inserted before WAL startup.    * @return List of WALActionsListener that will be passed in to    * {@link HLog} on construction.    */
end_comment

begin_function
specifier|protected
name|List
argument_list|<
name|WALObserver
argument_list|>
name|getWALActionListeners
parameter_list|()
block|{
name|List
argument_list|<
name|WALObserver
argument_list|>
name|listeners
init|=
operator|new
name|ArrayList
argument_list|<
name|WALObserver
argument_list|>
argument_list|()
decl_stmt|;
comment|// Log roller.
name|this
operator|.
name|hlogRoller
operator|=
operator|new
name|LogRoller
argument_list|(
name|this
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|listeners
operator|.
name|add
argument_list|(
name|this
operator|.
name|hlogRoller
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|replicationHandler
operator|!=
literal|null
condition|)
block|{
name|listeners
operator|=
operator|new
name|ArrayList
argument_list|<
name|WALObserver
argument_list|>
argument_list|()
expr_stmt|;
comment|// Replication handler is an implementation of WALActionsListener.
name|listeners
operator|.
name|add
argument_list|(
name|this
operator|.
name|replicationHandler
argument_list|)
expr_stmt|;
block|}
return|return
name|listeners
return|;
block|}
end_function

begin_function
specifier|protected
name|LogRoller
name|getLogRoller
parameter_list|()
block|{
return|return
name|hlogRoller
return|;
block|}
end_function

begin_comment
comment|/*    * @param interval Interval since last time metrics were called.    */
end_comment

begin_function
specifier|protected
name|void
name|doMetrics
parameter_list|()
block|{
try|try
block|{
name|metrics
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed metrics"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|protected
name|void
name|metrics
parameter_list|()
block|{
name|this
operator|.
name|metrics
operator|.
name|regions
operator|.
name|set
argument_list|(
name|this
operator|.
name|onlineRegions
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|incrementRequests
argument_list|(
name|this
operator|.
name|requestCount
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
comment|// Is this too expensive every three seconds getting a lock on onlineRegions
comment|// and then per store carried? Can I make metrics be sloppier and avoid
comment|// the synchronizations?
name|int
name|stores
init|=
literal|0
decl_stmt|;
name|int
name|storefiles
init|=
literal|0
decl_stmt|;
name|long
name|memstoreSize
init|=
literal|0
decl_stmt|;
name|long
name|storefileIndexSize
init|=
literal|0
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|onlineRegions
init|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|HRegion
argument_list|>
name|e
range|:
name|this
operator|.
name|onlineRegions
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|HRegion
name|r
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|memstoreSize
operator|+=
name|r
operator|.
name|memstoreSize
operator|.
name|get
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|r
operator|.
name|stores
init|)
block|{
name|stores
operator|+=
name|r
operator|.
name|stores
operator|.
name|size
argument_list|()
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|Store
argument_list|>
name|ee
range|:
name|r
operator|.
name|stores
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Store
name|store
init|=
name|ee
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|storefiles
operator|+=
name|store
operator|.
name|getStorefilesCount
argument_list|()
expr_stmt|;
name|storefileIndexSize
operator|+=
name|store
operator|.
name|getStorefilesIndexSize
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
name|this
operator|.
name|metrics
operator|.
name|stores
operator|.
name|set
argument_list|(
name|stores
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|storefiles
operator|.
name|set
argument_list|(
name|storefiles
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|memstoreSizeMB
operator|.
name|set
argument_list|(
call|(
name|int
call|)
argument_list|(
name|memstoreSize
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|storefileIndexSizeMB
operator|.
name|set
argument_list|(
call|(
name|int
call|)
argument_list|(
name|storefileIndexSize
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|compactionQueueSize
operator|.
name|set
argument_list|(
name|compactSplitThread
operator|.
name|getCompactionQueueSize
argument_list|()
argument_list|)
expr_stmt|;
name|LruBlockCache
name|lruBlockCache
init|=
operator|(
name|LruBlockCache
operator|)
name|StoreFile
operator|.
name|getBlockCache
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|lruBlockCache
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|metrics
operator|.
name|blockCacheCount
operator|.
name|set
argument_list|(
name|lruBlockCache
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|blockCacheFree
operator|.
name|set
argument_list|(
name|lruBlockCache
operator|.
name|getFreeSize
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|.
name|blockCacheSize
operator|.
name|set
argument_list|(
name|lruBlockCache
operator|.
name|getCurrentSize
argument_list|()
argument_list|)
expr_stmt|;
name|double
name|ratio
init|=
name|lruBlockCache
operator|.
name|getStats
argument_list|()
operator|.
name|getHitRatio
argument_list|()
decl_stmt|;
name|int
name|percent
init|=
call|(
name|int
call|)
argument_list|(
name|ratio
operator|*
literal|100
argument_list|)
decl_stmt|;
name|this
operator|.
name|metrics
operator|.
name|blockCacheHitRatio
operator|.
name|set
argument_list|(
name|percent
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * @return Region server metrics instance.    */
end_comment

begin_function
specifier|public
name|RegionServerMetrics
name|getMetrics
parameter_list|()
block|{
return|return
name|this
operator|.
name|metrics
return|;
block|}
end_function

begin_comment
comment|/*    * Start maintanence Threads, Server, Worker and lease checker threads.    * Install an UncaughtExceptionHandler that calls abort of RegionServer if we    * get an unhandled exception. We cannot set the handler on all threads.    * Server's internal Listener thread is off limits. For Server, if an OOME, it    * waits a while then retries. Meantime, a flush or a compaction that tries to    * run should trigger same critical condition and the shutdown will run. On    * its way out, this server will shut down Server. Leases are sort of    * inbetween. It has an internal thread that while it inherits from Chore, it    * keeps its own internal stop mechanism so needs to be stopped by this    * hosting server. Worker logs the exception and exits.    */
end_comment

begin_function
specifier|private
name|void
name|startServiceThreads
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|n
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|UncaughtExceptionHandler
name|handler
init|=
operator|new
name|UncaughtExceptionHandler
argument_list|()
block|{
specifier|public
name|void
name|uncaughtException
parameter_list|(
name|Thread
name|t
parameter_list|,
name|Throwable
name|e
parameter_list|)
block|{
name|abort
argument_list|(
literal|"Uncaught exception in service thread "
operator|+
name|t
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
comment|// Start executor services
name|this
operator|.
name|service
operator|=
operator|new
name|ExecutorService
argument_list|(
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|RS_OPEN_REGION
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.executor.openregion.threads"
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|RS_OPEN_ROOT
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.executor.openroot.threads"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|RS_OPEN_META
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.executor.openmeta.threads"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|RS_CLOSE_REGION
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.executor.closeregion.threads"
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|RS_CLOSE_ROOT
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.executor.closeroot.threads"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|RS_CLOSE_META
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.executor.closemeta.threads"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|this
operator|.
name|hlogRoller
argument_list|,
name|n
operator|+
literal|".logRoller"
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|this
operator|.
name|cacheFlusher
argument_list|,
name|n
operator|+
literal|".cacheFlusher"
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|this
operator|.
name|compactSplitThread
argument_list|,
name|n
operator|+
literal|".compactor"
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
name|this
operator|.
name|majorCompactionChecker
argument_list|,
name|n
operator|+
literal|".majorCompactionChecker"
argument_list|,
name|handler
argument_list|)
expr_stmt|;
comment|// Leases is not a Thread. Internally it runs a daemon thread. If it gets
comment|// an unhandled exception, it will just exit.
name|this
operator|.
name|leases
operator|.
name|setName
argument_list|(
name|n
operator|+
literal|".leaseChecker"
argument_list|)
expr_stmt|;
name|this
operator|.
name|leases
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Put up info server.
name|int
name|port
init|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.regionserver.info.port"
argument_list|,
literal|60030
argument_list|)
decl_stmt|;
comment|// -1 is for disabling info server
if|if
condition|(
name|port
operator|>=
literal|0
condition|)
block|{
name|String
name|addr
init|=
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.regionserver.info.bindAddress"
argument_list|,
literal|"0.0.0.0"
argument_list|)
decl_stmt|;
comment|// check if auto port bind enabled
name|boolean
name|auto
init|=
name|this
operator|.
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.regionserver.info.port.auto"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|this
operator|.
name|infoServer
operator|=
operator|new
name|InfoServer
argument_list|(
literal|"regionserver"
argument_list|,
name|addr
argument_list|,
name|port
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|setAttribute
argument_list|(
literal|"regionserver"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|start
argument_list|()
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|BindException
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|auto
condition|)
block|{
comment|// auto bind disabled throw BindException
throw|throw
name|e
throw|;
block|}
comment|// auto bind enabled, try to use another port
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed binding http info server to port: "
operator|+
name|port
argument_list|)
expr_stmt|;
name|port
operator|++
expr_stmt|;
comment|// update HRS server info port.
name|this
operator|.
name|serverInfo
operator|=
operator|new
name|HServerInfo
argument_list|(
name|this
operator|.
name|serverInfo
operator|.
name|getServerAddress
argument_list|()
argument_list|,
name|this
operator|.
name|serverInfo
operator|.
name|getStartCode
argument_list|()
argument_list|,
name|port
argument_list|,
name|this
operator|.
name|serverInfo
operator|.
name|getHostname
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|this
operator|.
name|replicationHandler
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|replicationHandler
operator|.
name|startReplicationServices
argument_list|()
expr_stmt|;
block|}
comment|// Start Server.  This service is like leases in that it internally runs
comment|// a thread.
name|this
operator|.
name|server
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*    * Verify that server is healthy    */
end_comment

begin_function
specifier|private
name|boolean
name|isHealthy
parameter_list|()
block|{
if|if
condition|(
operator|!
name|fsOk
condition|)
block|{
comment|// File system problem
return|return
literal|false
return|;
block|}
comment|// Verify that all threads are alive
if|if
condition|(
operator|!
operator|(
name|leases
operator|.
name|isAlive
argument_list|()
operator|&&
name|compactSplitThread
operator|.
name|isAlive
argument_list|()
operator|&&
name|cacheFlusher
operator|.
name|isAlive
argument_list|()
operator|&&
name|hlogRoller
operator|.
name|isAlive
argument_list|()
operator|&&
name|this
operator|.
name|majorCompactionChecker
operator|.
name|isAlive
argument_list|()
operator|)
condition|)
block|{
name|stop
argument_list|(
literal|"One or more threads are no longer alive -- stop"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function

begin_comment
comment|/** @return the HLog */
end_comment

begin_function
specifier|public
name|HLog
name|getWAL
parameter_list|()
block|{
return|return
name|this
operator|.
name|hlog
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|CatalogTracker
name|getCatalogTracker
parameter_list|()
block|{
return|return
name|this
operator|.
name|catalogTracker
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|stop
parameter_list|(
specifier|final
name|String
name|msg
parameter_list|)
block|{
name|this
operator|.
name|stopped
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"STOPPED: "
operator|+
name|msg
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// Wakes run() if it is sleeping
name|notifyAll
argument_list|()
expr_stmt|;
comment|// FindBugs NN_NAKED_NOTIFY
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|postOpenDeployTasks
parameter_list|(
specifier|final
name|HRegion
name|r
parameter_list|,
specifier|final
name|CatalogTracker
name|ct
parameter_list|,
specifier|final
name|boolean
name|daughter
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|IOException
block|{
comment|// Do checks to see if we need to compact (references or too many files)
if|if
condition|(
name|r
operator|.
name|hasReferences
argument_list|()
operator|||
name|r
operator|.
name|hasTooManyStoreFiles
argument_list|()
condition|)
block|{
name|getCompactionRequester
argument_list|()
operator|.
name|requestCompaction
argument_list|(
name|r
argument_list|,
name|r
operator|.
name|hasReferences
argument_list|()
condition|?
literal|"Region has references on open"
else|:
literal|"Region has too many store files"
argument_list|)
expr_stmt|;
block|}
comment|// Add to online regions
name|addToOnlineRegions
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|// Update ZK, ROOT or META
if|if
condition|(
name|r
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isRootRegion
argument_list|()
condition|)
block|{
name|RootLocationEditor
operator|.
name|setRootLocation
argument_list|(
name|getZooKeeper
argument_list|()
argument_list|,
name|getServerInfo
argument_list|()
operator|.
name|getServerAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
name|MetaEditor
operator|.
name|updateMetaLocation
argument_list|(
name|ct
argument_list|,
name|r
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|getServerInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|daughter
condition|)
block|{
comment|// If daughter of a split, update whole row, not just location.
name|MetaEditor
operator|.
name|addDaughter
argument_list|(
name|ct
argument_list|,
name|r
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|getServerInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MetaEditor
operator|.
name|updateRegionLocation
argument_list|(
name|ct
argument_list|,
name|r
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|getServerInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**    * Cause the server to exit without closing the regions it is serving, the log    * it is using and without notifying the master. Used unit testing and on    * catastrophic events such as HDFS is yanked out from under hbase or we OOME.    *    * @param reason    *          the reason we are aborting    * @param cause    *          the exception that caused the abort, or null    */
end_comment

begin_function
specifier|public
name|void
name|abort
parameter_list|(
name|String
name|reason
parameter_list|,
name|Throwable
name|cause
parameter_list|)
block|{
if|if
condition|(
name|cause
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Aborting region server "
operator|+
name|this
operator|+
literal|": "
operator|+
name|reason
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Aborting region server "
operator|+
name|this
operator|+
literal|": "
operator|+
name|reason
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|abortRequested
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|reservedSpace
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|metrics
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Dump of metrics: "
operator|+
name|this
operator|.
name|metrics
argument_list|)
expr_stmt|;
block|}
name|stop
argument_list|(
name|reason
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * @see HRegionServer#abort(String, Throwable)    */
end_comment

begin_function
specifier|public
name|void
name|abort
parameter_list|(
name|String
name|reason
parameter_list|)
block|{
name|abort
argument_list|(
name|reason
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*    * Simulate a kill -9 of this server. Exits w/o closing regions or cleaninup    * logs but it does close socket in case want to bring up server on old    * hostname+port immediately.    */
end_comment

begin_function
specifier|protected
name|void
name|kill
parameter_list|()
block|{
name|this
operator|.
name|killed
operator|=
literal|true
expr_stmt|;
name|abort
argument_list|(
literal|"Simulated kill"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Wait on all threads to finish. Presumption is that all closes and stops    * have already been called.    */
end_comment

begin_function
specifier|protected
name|void
name|join
parameter_list|()
block|{
name|Threads
operator|.
name|shutdown
argument_list|(
name|this
operator|.
name|majorCompactionChecker
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|shutdown
argument_list|(
name|this
operator|.
name|cacheFlusher
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|shutdown
argument_list|(
name|this
operator|.
name|compactSplitThread
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|shutdown
argument_list|(
name|this
operator|.
name|hlogRoller
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|shutdown
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|replicationHandler
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|replicationHandler
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * Get the current master from ZooKeeper and open the RPC connection to it.    *    * Method will block until a master is available. You can break from this    * block by requesting the server stop.    *    * @return    */
end_comment

begin_function
specifier|private
name|boolean
name|getMaster
parameter_list|()
block|{
name|HServerAddress
name|masterAddress
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|(
name|masterAddress
operator|=
name|masterAddressManager
operator|.
name|getMasterAddress
argument_list|()
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|stopped
condition|)
block|{
return|return
literal|false
return|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"No master found, will retry"
argument_list|)
expr_stmt|;
name|sleeper
operator|.
name|sleep
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Telling master at "
operator|+
name|masterAddress
operator|+
literal|" that we are up"
argument_list|)
expr_stmt|;
name|HMasterRegionInterface
name|master
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|!
name|stopped
operator|&&
name|master
operator|==
literal|null
condition|)
block|{
try|try
block|{
comment|// Do initial RPC setup. The final argument indicates that the RPC
comment|// should retry indefinitely.
name|master
operator|=
operator|(
name|HMasterRegionInterface
operator|)
name|HBaseRPC
operator|.
name|waitForProxy
argument_list|(
name|HMasterRegionInterface
operator|.
name|class
argument_list|,
name|HBaseRPCProtocolVersion
operator|.
name|versionID
argument_list|,
name|masterAddress
operator|.
name|getInetSocketAddress
argument_list|()
argument_list|,
name|this
operator|.
name|conf
argument_list|,
operator|-
literal|1
argument_list|,
name|this
operator|.
name|rpcTimeout
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to connect to master. Retrying. Error was:"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|sleeper
operator|.
name|sleep
argument_list|()
expr_stmt|;
block|}
block|}
name|this
operator|.
name|hbaseMaster
operator|=
name|master
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function

begin_comment
comment|/**    * @return True if successfully invoked {@link #reportForDuty()}    * @throws IOException    */
end_comment

begin_function
specifier|private
name|boolean
name|tryReportForDuty
parameter_list|()
throws|throws
name|IOException
block|{
name|MapWritable
name|w
init|=
name|reportForDuty
argument_list|()
decl_stmt|;
if|if
condition|(
name|w
operator|!=
literal|null
condition|)
block|{
name|handleReportForDutyResponse
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|sleeper
operator|.
name|sleep
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"No response on reportForDuty. Sleeping and then retrying."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function

begin_comment
comment|/*    * Let the master know we're here Run initialization using parameters passed    * us by the master.    */
end_comment

begin_function
specifier|private
name|MapWritable
name|reportForDuty
parameter_list|()
block|{
while|while
condition|(
operator|!
name|stopped
operator|&&
operator|!
name|getMaster
argument_list|()
condition|)
block|{
name|sleeper
operator|.
name|sleep
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to get master for initialization"
argument_list|)
expr_stmt|;
block|}
name|MapWritable
name|result
init|=
literal|null
decl_stmt|;
name|long
name|lastMsg
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|stopped
condition|)
block|{
try|try
block|{
name|this
operator|.
name|requestCount
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|lastMsg
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|ZKUtil
operator|.
name|setAddressAndWatch
argument_list|(
name|zooKeeper
argument_list|,
name|ZKUtil
operator|.
name|joinZNode
argument_list|(
name|zooKeeper
operator|.
name|rsZNode
argument_list|,
name|ZKUtil
operator|.
name|getNodeName
argument_list|(
name|serverInfo
argument_list|)
argument_list|)
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|this
operator|.
name|serverInfo
operator|.
name|setLoad
argument_list|(
name|buildServerLoad
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|=
name|this
operator|.
name|hbaseMaster
operator|.
name|regionServerStartup
argument_list|(
name|this
operator|.
name|serverInfo
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"error telling master we are up"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"error putting up ephemeral node in zookeeper"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|sleeper
operator|.
name|sleep
argument_list|(
name|lastMsg
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**    * Add to the outbound message buffer    *    * When a region splits, we need to tell the master that there are two new    * regions that need to be assigned.    *    * We do not need to inform the master about the old region, because we've    * updated the meta or root regions, and the master will pick that up on its    * next rescan of the root or meta tables.    */
end_comment

begin_function
name|void
name|reportSplit
parameter_list|(
name|HRegionInfo
name|oldRegion
parameter_list|,
name|HRegionInfo
name|newRegionA
parameter_list|,
name|HRegionInfo
name|newRegionB
parameter_list|)
block|{
name|this
operator|.
name|outboundMsgs
operator|.
name|add
argument_list|(
operator|new
name|HMsg
argument_list|(
name|HMsg
operator|.
name|Type
operator|.
name|REGION_SPLIT
argument_list|,
name|oldRegion
argument_list|,
name|newRegionA
argument_list|,
name|newRegionB
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"Daughters; "
operator|+
name|newRegionA
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|", "
operator|+
name|newRegionB
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Closes all regions.  Called on our way out.    * Assumes that its not possible for new regions to be added to onlineRegions    * while this method runs.    */
end_comment

begin_function
specifier|protected
name|void
name|closeAllRegions
parameter_list|(
specifier|final
name|boolean
name|abort
parameter_list|)
block|{
name|closeUserRegions
argument_list|(
name|abort
argument_list|)
expr_stmt|;
comment|// Only root and meta should remain.  Are we carrying root or meta?
name|HRegion
name|meta
init|=
literal|null
decl_stmt|;
name|HRegion
name|root
init|=
literal|null
decl_stmt|;
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|HRegion
argument_list|>
name|e
range|:
name|onlineRegions
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|HRegionInfo
name|hri
init|=
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|hri
operator|.
name|isRootRegion
argument_list|()
condition|)
block|{
name|root
operator|=
name|e
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hri
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
name|meta
operator|=
name|e
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|meta
operator|!=
literal|null
operator|&&
name|root
operator|!=
literal|null
condition|)
break|break;
block|}
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|meta
operator|!=
literal|null
condition|)
name|closeRegion
argument_list|(
name|meta
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|abort
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|!=
literal|null
condition|)
name|closeRegion
argument_list|(
name|root
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|abort
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * Schedule closes on all user regions.    * @param abort Whether we're running an abort.    */
end_comment

begin_function
name|void
name|closeUserRegions
parameter_list|(
specifier|final
name|boolean
name|abort
parameter_list|)
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|onlineRegions
init|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|HRegion
argument_list|>
name|e
range|:
name|this
operator|.
name|onlineRegions
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|HRegion
name|r
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|r
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
comment|// Don't update zk with this close transition; pass false.
name|closeRegion
argument_list|(
name|r
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|abort
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|HRegionInfo
name|getRegionInfo
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|NotServingRegionException
block|{
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return
name|getRegion
argument_list|(
name|regionName
argument_list|)
operator|.
name|getRegionInfo
argument_list|()
return|;
block|}
end_function

begin_function
specifier|public
name|Result
name|getClosestRowBefore
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
comment|// locate the region we're operating on
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
comment|// ask the region for all the data
name|Result
name|r
init|=
name|region
operator|.
name|getClosestRowBefore
argument_list|(
name|row
argument_list|,
name|family
argument_list|)
decl_stmt|;
return|return
name|r
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
end_function

begin_comment
comment|/** {@inheritDoc} */
end_comment

begin_function
specifier|public
name|Result
name|get
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|,
name|Get
name|get
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
return|return
name|region
operator|.
name|get
argument_list|(
name|get
argument_list|,
name|getLockFromId
argument_list|(
name|get
operator|.
name|getLockId
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
specifier|public
name|boolean
name|exists
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|,
name|Get
name|get
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|Result
name|r
init|=
name|region
operator|.
name|get
argument_list|(
name|get
argument_list|,
name|getLockFromId
argument_list|(
name|get
operator|.
name|getLockId
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|r
operator|!=
literal|null
operator|&&
operator|!
name|r
operator|.
name|isEmpty
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
specifier|public
name|void
name|put
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|Put
name|put
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|put
operator|.
name|getRow
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"update has null row"
argument_list|)
throw|;
block|}
name|checkOpen
argument_list|()
expr_stmt|;
name|this
operator|.
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isMetaTable
argument_list|()
condition|)
block|{
name|this
operator|.
name|cacheFlusher
operator|.
name|reclaimMemStoreMemory
argument_list|()
expr_stmt|;
block|}
name|boolean
name|writeToWAL
init|=
name|put
operator|.
name|getWriteToWAL
argument_list|()
decl_stmt|;
name|region
operator|.
name|put
argument_list|(
name|put
argument_list|,
name|getLockFromId
argument_list|(
name|put
operator|.
name|getLockId
argument_list|()
argument_list|)
argument_list|,
name|writeToWAL
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
specifier|public
name|int
name|put
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|List
argument_list|<
name|Put
argument_list|>
name|puts
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|HRegion
name|region
init|=
literal|null
decl_stmt|;
try|try
block|{
name|region
operator|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isMetaTable
argument_list|()
condition|)
block|{
name|this
operator|.
name|cacheFlusher
operator|.
name|reclaimMemStoreMemory
argument_list|()
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Pair
argument_list|<
name|Put
argument_list|,
name|Integer
argument_list|>
index|[]
name|putsWithLocks
init|=
operator|new
name|Pair
index|[
name|puts
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Put
name|p
range|:
name|puts
control|)
block|{
name|Integer
name|lock
init|=
name|getLockFromId
argument_list|(
name|p
operator|.
name|getLockId
argument_list|()
argument_list|)
decl_stmt|;
name|putsWithLocks
index|[
name|i
operator|++
index|]
operator|=
operator|new
name|Pair
argument_list|<
name|Put
argument_list|,
name|Integer
argument_list|>
argument_list|(
name|p
argument_list|,
name|lock
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|requestCount
operator|.
name|addAndGet
argument_list|(
name|puts
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|OperationStatusCode
index|[]
name|codes
init|=
name|region
operator|.
name|put
argument_list|(
name|putsWithLocks
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|codes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|codes
index|[
name|i
index|]
operator|!=
name|OperationStatusCode
operator|.
name|SUCCESS
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
specifier|private
name|boolean
name|checkAndMutate
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|Writable
name|w
parameter_list|,
name|Integer
name|lock
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|this
operator|.
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isMetaTable
argument_list|()
condition|)
block|{
name|this
operator|.
name|cacheFlusher
operator|.
name|reclaimMemStoreMemory
argument_list|()
expr_stmt|;
block|}
return|return
name|region
operator|.
name|checkAndMutate
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|value
argument_list|,
name|w
argument_list|,
name|lock
argument_list|,
literal|true
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
end_function

begin_comment
comment|/**    *    * @param regionName    * @param row    * @param family    * @param qualifier    * @param value    *          the expected value    * @param put    * @throws IOException    * @return true if the new put was execute, false otherwise    */
end_comment

begin_function
specifier|public
name|boolean
name|checkAndPut
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|Put
name|put
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|checkAndMutate
argument_list|(
name|regionName
argument_list|,
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|value
argument_list|,
name|put
argument_list|,
name|getLockFromId
argument_list|(
name|put
operator|.
name|getLockId
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    *    * @param regionName    * @param row    * @param family    * @param qualifier    * @param value    *          the expected value    * @param delete    * @throws IOException    * @return true if the new put was execute, false otherwise    */
end_comment

begin_function
specifier|public
name|boolean
name|checkAndDelete
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|Delete
name|delete
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|checkAndMutate
argument_list|(
name|regionName
argument_list|,
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|value
argument_list|,
name|delete
argument_list|,
name|getLockFromId
argument_list|(
name|delete
operator|.
name|getLockId
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|//
end_comment

begin_comment
comment|// remote scanner interface
end_comment

begin_comment
comment|//
end_comment

begin_function
specifier|public
name|long
name|openScanner
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|,
name|Scan
name|scan
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|NullPointerException
name|npe
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|regionName
operator|==
literal|null
condition|)
block|{
name|npe
operator|=
operator|new
name|NullPointerException
argument_list|(
literal|"regionName is null"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scan
operator|==
literal|null
condition|)
block|{
name|npe
operator|=
operator|new
name|NullPointerException
argument_list|(
literal|"scan is null"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|npe
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid arguments to openScanner"
argument_list|,
name|npe
argument_list|)
throw|;
block|}
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|r
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
return|return
name|addScanner
argument_list|(
name|r
operator|.
name|getScanner
argument_list|(
name|scan
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|,
literal|"Failed openScanner"
argument_list|)
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
specifier|protected
name|long
name|addScanner
parameter_list|(
name|InternalScanner
name|s
parameter_list|)
throws|throws
name|LeaseStillHeldException
block|{
name|long
name|scannerId
init|=
operator|-
literal|1L
decl_stmt|;
name|scannerId
operator|=
name|rand
operator|.
name|nextLong
argument_list|()
expr_stmt|;
name|String
name|scannerName
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
name|scanners
operator|.
name|put
argument_list|(
name|scannerName
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|this
operator|.
name|leases
operator|.
name|createLease
argument_list|(
name|scannerName
argument_list|,
operator|new
name|ScannerListener
argument_list|(
name|scannerName
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|scannerId
return|;
block|}
end_function

begin_function
specifier|public
name|Result
name|next
parameter_list|(
specifier|final
name|long
name|scannerId
parameter_list|)
throws|throws
name|IOException
block|{
name|Result
index|[]
name|res
init|=
name|next
argument_list|(
name|scannerId
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
literal|null
operator|||
name|res
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|res
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
specifier|public
name|Result
index|[]
name|next
parameter_list|(
specifier|final
name|long
name|scannerId
parameter_list|,
name|int
name|nbRows
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|String
name|scannerName
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
name|InternalScanner
name|s
init|=
name|this
operator|.
name|scanners
operator|.
name|get
argument_list|(
name|scannerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownScannerException
argument_list|(
literal|"Name: "
operator|+
name|scannerName
argument_list|)
throw|;
block|}
try|try
block|{
name|checkOpen
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// If checkOpen failed, server not running or filesystem gone,
comment|// cancel this lease; filesystem is gone or we're closing or something.
name|this
operator|.
name|leases
operator|.
name|cancelLease
argument_list|(
name|scannerName
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|this
operator|.
name|leases
operator|.
name|renewLease
argument_list|(
name|scannerName
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Result
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|Result
argument_list|>
argument_list|(
name|nbRows
argument_list|)
decl_stmt|;
name|long
name|currentScanResultSize
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|KeyValue
argument_list|>
name|values
init|=
operator|new
name|ArrayList
argument_list|<
name|KeyValue
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nbRows
operator|&&
name|currentScanResultSize
operator|<
name|maxScannerResultSize
condition|;
name|i
operator|++
control|)
block|{
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
comment|// Collect values to be returned here
name|boolean
name|moreRows
init|=
name|s
operator|.
name|next
argument_list|(
name|values
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|values
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|KeyValue
name|kv
range|:
name|values
control|)
block|{
name|currentScanResultSize
operator|+=
name|kv
operator|.
name|heapSize
argument_list|()
expr_stmt|;
block|}
name|results
operator|.
name|add
argument_list|(
operator|new
name|Result
argument_list|(
name|values
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|moreRows
condition|)
block|{
break|break;
block|}
name|values
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|// Below is an ugly hack where we cast the InternalScanner to be a
comment|// HRegion.RegionScanner. The alternative is to change InternalScanner
comment|// interface but its used everywhere whereas we just need a bit of info
comment|// from HRegion.RegionScanner, IF its filter if any is done with the scan
comment|// and wants to tell the client to stop the scan. This is done by passing
comment|// a null result.
return|return
operator|(
operator|(
name|HRegion
operator|.
name|RegionScanner
operator|)
name|s
operator|)
operator|.
name|isFilterDone
argument_list|()
operator|&&
name|results
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|results
operator|.
name|toArray
argument_list|(
operator|new
name|Result
index|[
literal|0
index|]
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|NotServingRegionException
condition|)
block|{
name|String
name|scannerName
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
name|this
operator|.
name|scanners
operator|.
name|remove
argument_list|(
name|scannerName
argument_list|)
expr_stmt|;
block|}
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
specifier|public
name|void
name|close
parameter_list|(
specifier|final
name|long
name|scannerId
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|String
name|scannerName
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
name|InternalScanner
name|s
init|=
name|scanners
operator|.
name|remove
argument_list|(
name|scannerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|close
argument_list|()
expr_stmt|;
name|this
operator|.
name|leases
operator|.
name|cancelLease
argument_list|(
name|scannerName
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
end_function

begin_comment
comment|/**    * Instantiated as a scanner lease. If the lease times out, the scanner is    * closed    */
end_comment

begin_class
specifier|private
class|class
name|ScannerListener
implements|implements
name|LeaseListener
block|{
specifier|private
specifier|final
name|String
name|scannerName
decl_stmt|;
name|ScannerListener
parameter_list|(
specifier|final
name|String
name|n
parameter_list|)
block|{
name|this
operator|.
name|scannerName
operator|=
name|n
expr_stmt|;
block|}
specifier|public
name|void
name|leaseExpired
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Scanner "
operator|+
name|this
operator|.
name|scannerName
operator|+
literal|" lease expired"
argument_list|)
expr_stmt|;
name|InternalScanner
name|s
init|=
name|scanners
operator|.
name|remove
argument_list|(
name|this
operator|.
name|scannerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|s
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Closing scanner"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

begin_comment
comment|//
end_comment

begin_comment
comment|// Methods that do the actual work for the remote API
end_comment

begin_comment
comment|//
end_comment

begin_function
specifier|public
name|void
name|delete
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|Delete
name|delete
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
try|try
block|{
name|boolean
name|writeToWAL
init|=
literal|true
decl_stmt|;
name|this
operator|.
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isMetaTable
argument_list|()
condition|)
block|{
name|this
operator|.
name|cacheFlusher
operator|.
name|reclaimMemStoreMemory
argument_list|()
expr_stmt|;
block|}
name|Integer
name|lid
init|=
name|getLockFromId
argument_list|(
name|delete
operator|.
name|getLockId
argument_list|()
argument_list|)
decl_stmt|;
name|region
operator|.
name|delete
argument_list|(
name|delete
argument_list|,
name|lid
argument_list|,
name|writeToWAL
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
specifier|public
name|int
name|delete
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|List
argument_list|<
name|Delete
argument_list|>
name|deletes
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Count of Deletes processed.
name|int
name|i
init|=
literal|0
decl_stmt|;
name|checkOpen
argument_list|()
expr_stmt|;
name|HRegion
name|region
init|=
literal|null
decl_stmt|;
try|try
block|{
name|boolean
name|writeToWAL
init|=
literal|true
decl_stmt|;
name|region
operator|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isMetaTable
argument_list|()
condition|)
block|{
name|this
operator|.
name|cacheFlusher
operator|.
name|reclaimMemStoreMemory
argument_list|()
expr_stmt|;
block|}
name|int
name|size
init|=
name|deletes
operator|.
name|size
argument_list|()
decl_stmt|;
name|Integer
index|[]
name|locks
init|=
operator|new
name|Integer
index|[
name|size
index|]
decl_stmt|;
for|for
control|(
name|Delete
name|delete
range|:
name|deletes
control|)
block|{
name|this
operator|.
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|locks
index|[
name|i
index|]
operator|=
name|getLockFromId
argument_list|(
name|delete
operator|.
name|getLockId
argument_list|()
argument_list|)
expr_stmt|;
name|region
operator|.
name|delete
argument_list|(
name|delete
argument_list|,
name|locks
index|[
name|i
index|]
argument_list|,
name|writeToWAL
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|WrongRegionException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Batch deletes: "
operator|+
name|i
argument_list|,
name|ex
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
catch|catch
parameter_list|(
name|NotServingRegionException
name|ex
parameter_list|)
block|{
return|return
name|i
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|public
name|long
name|lockRow
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|,
name|byte
index|[]
name|row
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|NullPointerException
name|npe
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|regionName
operator|==
literal|null
condition|)
block|{
name|npe
operator|=
operator|new
name|NullPointerException
argument_list|(
literal|"regionName is null"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|row
operator|==
literal|null
condition|)
block|{
name|npe
operator|=
operator|new
name|NullPointerException
argument_list|(
literal|"row to lock is null"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|npe
operator|!=
literal|null
condition|)
block|{
name|IOException
name|io
init|=
operator|new
name|IOException
argument_list|(
literal|"Invalid arguments to lockRow"
argument_list|)
decl_stmt|;
name|io
operator|.
name|initCause
argument_list|(
name|npe
argument_list|)
expr_stmt|;
throw|throw
name|io
throw|;
block|}
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|Integer
name|r
init|=
name|region
operator|.
name|obtainRowLock
argument_list|(
name|row
argument_list|)
decl_stmt|;
name|long
name|lockId
init|=
name|addRowLock
argument_list|(
name|r
argument_list|,
name|region
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Row lock "
operator|+
name|lockId
operator|+
literal|" explicitly acquired by client"
argument_list|)
expr_stmt|;
return|return
name|lockId
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|,
literal|"Error obtaining row lock (fsOk: "
operator|+
name|this
operator|.
name|fsOk
operator|+
literal|")"
argument_list|)
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
specifier|protected
name|long
name|addRowLock
parameter_list|(
name|Integer
name|r
parameter_list|,
name|HRegion
name|region
parameter_list|)
throws|throws
name|LeaseStillHeldException
block|{
name|long
name|lockId
init|=
operator|-
literal|1L
decl_stmt|;
name|lockId
operator|=
name|rand
operator|.
name|nextLong
argument_list|()
expr_stmt|;
name|String
name|lockName
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|lockId
argument_list|)
decl_stmt|;
name|rowlocks
operator|.
name|put
argument_list|(
name|lockName
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|this
operator|.
name|leases
operator|.
name|createLease
argument_list|(
name|lockName
argument_list|,
operator|new
name|RowLockListener
argument_list|(
name|lockName
argument_list|,
name|region
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|lockId
return|;
block|}
end_function

begin_comment
comment|/**    * Method to get the Integer lock identifier used internally from the long    * lock identifier used by the client.    *    * @param lockId    *          long row lock identifier from client    * @return intId Integer row lock used internally in HRegion    * @throws IOException    *           Thrown if this is not a valid client lock id.    */
end_comment

begin_function
name|Integer
name|getLockFromId
parameter_list|(
name|long
name|lockId
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|lockId
operator|==
operator|-
literal|1L
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|lockName
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|lockId
argument_list|)
decl_stmt|;
name|Integer
name|rl
init|=
name|rowlocks
operator|.
name|get
argument_list|(
name|lockName
argument_list|)
decl_stmt|;
if|if
condition|(
name|rl
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid row lock"
argument_list|)
throw|;
block|}
name|this
operator|.
name|leases
operator|.
name|renewLease
argument_list|(
name|lockName
argument_list|)
expr_stmt|;
return|return
name|rl
return|;
block|}
end_function

begin_function
specifier|public
name|void
name|unlockRow
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|,
name|long
name|lockId
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
name|NullPointerException
name|npe
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|regionName
operator|==
literal|null
condition|)
block|{
name|npe
operator|=
operator|new
name|NullPointerException
argument_list|(
literal|"regionName is null"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lockId
operator|==
operator|-
literal|1L
condition|)
block|{
name|npe
operator|=
operator|new
name|NullPointerException
argument_list|(
literal|"lockId is null"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|npe
operator|!=
literal|null
condition|)
block|{
name|IOException
name|io
init|=
operator|new
name|IOException
argument_list|(
literal|"Invalid arguments to unlockRow"
argument_list|)
decl_stmt|;
name|io
operator|.
name|initCause
argument_list|(
name|npe
argument_list|)
expr_stmt|;
throw|throw
name|io
throw|;
block|}
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|String
name|lockName
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|lockId
argument_list|)
decl_stmt|;
name|Integer
name|r
init|=
name|rowlocks
operator|.
name|remove
argument_list|(
name|lockName
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownRowLockException
argument_list|(
name|lockName
argument_list|)
throw|;
block|}
name|region
operator|.
name|releaseRowLock
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|this
operator|.
name|leases
operator|.
name|cancelLease
argument_list|(
name|lockName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Row lock "
operator|+
name|lockId
operator|+
literal|" has been explicitly released by client"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|convertThrowableToIOE
argument_list|(
name|cleanup
argument_list|(
name|t
argument_list|)
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|bulkLoadHFile
parameter_list|(
name|String
name|hfilePath
parameter_list|,
name|byte
index|[]
name|regionName
parameter_list|,
name|byte
index|[]
name|familyName
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|region
operator|.
name|bulkLoadHFile
argument_list|(
name|hfilePath
argument_list|,
name|familyName
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|rowlocks
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**    * Instantiated as a row lock lease. If the lease times out, the row lock is    * released    */
end_comment

begin_class
specifier|private
class|class
name|RowLockListener
implements|implements
name|LeaseListener
block|{
specifier|private
specifier|final
name|String
name|lockName
decl_stmt|;
specifier|private
specifier|final
name|HRegion
name|region
decl_stmt|;
name|RowLockListener
parameter_list|(
specifier|final
name|String
name|lockName
parameter_list|,
specifier|final
name|HRegion
name|region
parameter_list|)
block|{
name|this
operator|.
name|lockName
operator|=
name|lockName
expr_stmt|;
name|this
operator|.
name|region
operator|=
name|region
expr_stmt|;
block|}
specifier|public
name|void
name|leaseExpired
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Row Lock "
operator|+
name|this
operator|.
name|lockName
operator|+
literal|" lease expired"
argument_list|)
expr_stmt|;
name|Integer
name|r
init|=
name|rowlocks
operator|.
name|remove
argument_list|(
name|this
operator|.
name|lockName
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|null
condition|)
block|{
name|region
operator|.
name|releaseRowLock
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// Region open/close direct RPCs
end_comment

begin_function
annotation|@
name|Override
specifier|public
name|void
name|openRegion
parameter_list|(
name|HRegionInfo
name|region
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Received request to open region: "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|.
name|isRootRegion
argument_list|()
condition|)
block|{
name|this
operator|.
name|service
operator|.
name|submit
argument_list|(
operator|new
name|OpenRootHandler
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|region
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|region
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
name|this
operator|.
name|service
operator|.
name|submit
argument_list|(
operator|new
name|OpenMetaHandler
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|region
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|service
operator|.
name|submit
argument_list|(
operator|new
name|OpenRegionHandler
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|region
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|boolean
name|closeRegion
parameter_list|(
name|HRegionInfo
name|region
parameter_list|)
throws|throws
name|NotServingRegionException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Received close region: "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO: Need to check if this is being served here but currently undergoing
comment|// a split (so master needs to retry close after split is complete)
if|if
condition|(
operator|!
name|onlineRegions
operator|.
name|containsKey
argument_list|(
name|region
operator|.
name|getEncodedName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received close for region we are not serving; "
operator|+
name|region
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|NotServingRegionException
argument_list|(
literal|"Received close for "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" but we are not serving it"
argument_list|)
throw|;
block|}
return|return
name|closeRegion
argument_list|(
name|region
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * @param region Region to close    * @param abort True if we are aborting    * @param zk True if we are to update zk about the region close; if the close    * was orchestrated by master, then update zk.  If the close is being run by    * the regionserver because its going down, don't update zk.    * @return    */
end_comment

begin_function
specifier|protected
name|boolean
name|closeRegion
parameter_list|(
name|HRegionInfo
name|region
parameter_list|,
specifier|final
name|boolean
name|abort
parameter_list|,
specifier|final
name|boolean
name|zk
parameter_list|)
block|{
name|CloseRegionHandler
name|crh
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|region
operator|.
name|isRootRegion
argument_list|()
condition|)
block|{
name|crh
operator|=
operator|new
name|CloseRootHandler
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|region
argument_list|,
name|abort
argument_list|,
name|zk
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|region
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
name|crh
operator|=
operator|new
name|CloseMetaHandler
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|region
argument_list|,
name|abort
argument_list|,
name|zk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|crh
operator|=
operator|new
name|CloseRegionHandler
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|region
argument_list|,
name|abort
argument_list|,
name|zk
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|service
operator|.
name|submit
argument_list|(
name|crh
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function

begin_comment
comment|// Manual remote region administration RPCs
end_comment

begin_function
annotation|@
name|Override
specifier|public
name|void
name|flushRegion
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|NotServingRegionException
throws|,
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Flushing "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionInfo
operator|.
name|getRegionName
argument_list|()
argument_list|)
decl_stmt|;
name|region
operator|.
name|flushcache
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|splitRegion
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|NotServingRegionException
throws|,
name|IOException
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionInfo
operator|.
name|getRegionName
argument_list|()
argument_list|)
decl_stmt|;
name|region
operator|.
name|flushcache
argument_list|()
expr_stmt|;
name|region
operator|.
name|shouldSplit
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// force a compaction, split will be side-effect
comment|// TODO: flush/compact/split refactor will make it trivial to do this
comment|// sync/async (and won't require us to do a compaction to split!)
name|compactSplitThread
operator|.
name|requestCompaction
argument_list|(
name|region
argument_list|,
literal|"User-triggered split"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|compactRegion
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|,
name|boolean
name|major
parameter_list|)
throws|throws
name|NotServingRegionException
throws|,
name|IOException
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionInfo
operator|.
name|getRegionName
argument_list|()
argument_list|)
decl_stmt|;
name|region
operator|.
name|flushcache
argument_list|()
expr_stmt|;
name|region
operator|.
name|shouldSplit
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|compactSplitThread
operator|.
name|requestCompaction
argument_list|(
name|region
argument_list|,
name|major
argument_list|,
literal|"User-triggered "
operator|+
operator|(
name|major
condition|?
literal|"major "
else|:
literal|""
operator|)
operator|+
literal|"compaction"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** @return the info server */
end_comment

begin_function
specifier|public
name|InfoServer
name|getInfoServer
parameter_list|()
block|{
return|return
name|infoServer
return|;
block|}
end_function

begin_comment
comment|/**    * @return true if a stop has been requested.    */
end_comment

begin_function
specifier|public
name|boolean
name|isStopped
parameter_list|()
block|{
return|return
name|this
operator|.
name|stopped
return|;
block|}
end_function

begin_comment
comment|/**    *    * @return the configuration    */
end_comment

begin_function
specifier|public
name|Configuration
name|getConfiguration
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
end_function

begin_comment
comment|/** @return the write lock for the server */
end_comment

begin_function
name|ReentrantReadWriteLock
operator|.
name|WriteLock
name|getWriteLock
parameter_list|()
block|{
return|return
name|lock
operator|.
name|writeLock
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|NavigableSet
argument_list|<
name|HRegionInfo
argument_list|>
name|getOnlineRegions
parameter_list|()
block|{
name|NavigableSet
argument_list|<
name|HRegionInfo
argument_list|>
name|sortedset
init|=
operator|new
name|TreeSet
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|onlineRegions
init|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|HRegion
argument_list|>
name|e
range|:
name|this
operator|.
name|onlineRegions
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|sortedset
operator|.
name|add
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sortedset
return|;
block|}
end_function

begin_function
specifier|public
name|int
name|getNumberOfOnlineRegions
parameter_list|()
block|{
return|return
name|onlineRegions
operator|.
name|size
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * For tests and web ui.    * This method will only work if HRegionServer is in the same JVM as client;    * HRegion cannot be serialized to cross an rpc.    * @see #getOnlineRegions()    */
end_comment

begin_function
specifier|public
name|Collection
argument_list|<
name|HRegion
argument_list|>
name|getOnlineRegionsLocalContext
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|this
operator|.
name|onlineRegions
operator|.
name|values
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|addToOnlineRegions
parameter_list|(
name|HRegion
name|region
parameter_list|)
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|onlineRegions
operator|.
name|put
argument_list|(
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedName
argument_list|()
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|boolean
name|removeFromOnlineRegions
parameter_list|(
specifier|final
name|String
name|encodedName
parameter_list|)
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
name|HRegion
name|toReturn
init|=
literal|null
decl_stmt|;
try|try
block|{
name|toReturn
operator|=
name|onlineRegions
operator|.
name|remove
argument_list|(
name|encodedName
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|toReturn
operator|!=
literal|null
return|;
block|}
end_function

begin_comment
comment|/**    * @return A new Map of online regions sorted by region size with the first    *         entry being the biggest.    */
end_comment

begin_function
specifier|public
name|SortedMap
argument_list|<
name|Long
argument_list|,
name|HRegion
argument_list|>
name|getCopyOfOnlineRegionsSortedBySize
parameter_list|()
block|{
comment|// we'll sort the regions in reverse
name|SortedMap
argument_list|<
name|Long
argument_list|,
name|HRegion
argument_list|>
name|sortedRegions
init|=
operator|new
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|HRegion
argument_list|>
argument_list|(
operator|new
name|Comparator
argument_list|<
name|Long
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|Long
name|a
parameter_list|,
name|Long
name|b
parameter_list|)
block|{
return|return
operator|-
literal|1
operator|*
name|a
operator|.
name|compareTo
argument_list|(
name|b
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
comment|// Copy over all regions. Regions are sorted by size with biggest first.
synchronized|synchronized
init|(
name|this
operator|.
name|onlineRegions
init|)
block|{
for|for
control|(
name|HRegion
name|region
range|:
name|this
operator|.
name|onlineRegions
operator|.
name|values
argument_list|()
control|)
block|{
name|sortedRegions
operator|.
name|put
argument_list|(
name|Long
operator|.
name|valueOf
argument_list|(
name|region
operator|.
name|memstoreSize
operator|.
name|get
argument_list|()
argument_list|)
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sortedRegions
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|HRegion
name|getFromOnlineRegions
parameter_list|(
specifier|final
name|String
name|encodedRegionName
parameter_list|)
block|{
return|return
name|onlineRegions
operator|.
name|get
argument_list|(
name|encodedRegionName
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * @param regionName    * @return HRegion for the passed binary<code>regionName</code> or null if    *         named region is not member of the online regions.    */
end_comment

begin_function
specifier|public
name|HRegion
name|getOnlineRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
block|{
return|return
name|getFromOnlineRegions
argument_list|(
name|HRegionInfo
operator|.
name|encodeRegionName
argument_list|(
name|regionName
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** @return the request count */
end_comment

begin_function
specifier|public
name|AtomicInteger
name|getRequestCount
parameter_list|()
block|{
return|return
name|this
operator|.
name|requestCount
return|;
block|}
end_function

begin_comment
comment|/** @return reference to FlushRequester */
end_comment

begin_function
specifier|public
name|FlushRequester
name|getFlushRequester
parameter_list|()
block|{
return|return
name|this
operator|.
name|cacheFlusher
return|;
block|}
end_function

begin_comment
comment|/**    * Protected utility method for safely obtaining an HRegion handle.    *    * @param regionName    *          Name of online {@link HRegion} to return    * @return {@link HRegion} for<code>regionName</code>    * @throws NotServingRegionException    */
end_comment

begin_function
specifier|protected
name|HRegion
name|getRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|NotServingRegionException
block|{
name|HRegion
name|region
init|=
literal|null
decl_stmt|;
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|region
operator|=
name|getOnlineRegion
argument_list|(
name|regionName
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NotServingRegionException
argument_list|(
literal|"Region is not online: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionName
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|region
return|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**    * Get the top N most loaded regions this server is serving so we can tell the    * master which regions it can reallocate if we're overloaded. TODO: actually    * calculate which regions are most loaded. (Right now, we're just grabbing    * the first N regions being served regardless of load.)    */
end_comment

begin_function
specifier|protected
name|HRegionInfo
index|[]
name|getMostLoadedRegions
parameter_list|()
block|{
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|onlineRegions
init|)
block|{
for|for
control|(
name|HRegion
name|r
range|:
name|onlineRegions
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|r
operator|.
name|isClosed
argument_list|()
operator|||
name|r
operator|.
name|isClosing
argument_list|()
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|regions
operator|.
name|size
argument_list|()
operator|<
name|numRegionsToReport
condition|)
block|{
name|regions
operator|.
name|add
argument_list|(
name|r
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
return|return
name|regions
operator|.
name|toArray
argument_list|(
operator|new
name|HRegionInfo
index|[
name|regions
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Called to verify that this server is up and running.    *    * @throws IOException    */
end_comment

begin_function
specifier|protected
name|void
name|checkOpen
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|stopped
operator|||
name|this
operator|.
name|abortRequested
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Server not running"
operator|+
operator|(
name|this
operator|.
name|abortRequested
condition|?
literal|", aborting"
else|:
literal|""
operator|)
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|fsOk
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"File system not available"
argument_list|)
throw|;
block|}
block|}
end_function

begin_comment
comment|/**    * @return Returns list of non-closed regions hosted on this server. If no    *         regions to check, returns an empty list.    */
end_comment

begin_function
specifier|protected
name|Set
argument_list|<
name|HRegion
argument_list|>
name|getRegionsToCheck
parameter_list|()
block|{
name|HashSet
argument_list|<
name|HRegion
argument_list|>
name|regionsToCheck
init|=
operator|new
name|HashSet
argument_list|<
name|HRegion
argument_list|>
argument_list|()
decl_stmt|;
comment|// TODO: is this locking necessary?
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|regionsToCheck
operator|.
name|addAll
argument_list|(
name|this
operator|.
name|onlineRegions
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// Purge closed regions.
for|for
control|(
specifier|final
name|Iterator
argument_list|<
name|HRegion
argument_list|>
name|i
init|=
name|regionsToCheck
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|HRegion
name|r
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|isClosed
argument_list|()
condition|)
block|{
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|regionsToCheck
return|;
block|}
end_function

begin_function
specifier|public
name|long
name|getProtocolVersion
parameter_list|(
specifier|final
name|String
name|protocol
parameter_list|,
specifier|final
name|long
name|clientVersion
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|HRegionInterface
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|HBaseRPCProtocolVersion
operator|.
name|versionID
return|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown protocol to name node: "
operator|+
name|protocol
argument_list|)
throw|;
block|}
end_function

begin_comment
comment|/**    * @return Queue to which you can add outbound messages.    */
end_comment

begin_function
specifier|protected
name|LinkedBlockingQueue
argument_list|<
name|HMsg
argument_list|>
name|getOutboundMsgs
parameter_list|()
block|{
return|return
name|this
operator|.
name|outboundMsgs
return|;
block|}
end_function

begin_comment
comment|/**    * Return the total size of all memstores in every region.    *    * @return memstore size in bytes    */
end_comment

begin_function
specifier|public
name|long
name|getGlobalMemStoreSize
parameter_list|()
block|{
name|long
name|total
init|=
literal|0
decl_stmt|;
synchronized|synchronized
init|(
name|onlineRegions
init|)
block|{
for|for
control|(
name|HRegion
name|region
range|:
name|onlineRegions
operator|.
name|values
argument_list|()
control|)
block|{
name|total
operator|+=
name|region
operator|.
name|memstoreSize
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|total
return|;
block|}
end_function

begin_comment
comment|/**    * @return Return the leases.    */
end_comment

begin_function
specifier|protected
name|Leases
name|getLeases
parameter_list|()
block|{
return|return
name|leases
return|;
block|}
end_function

begin_comment
comment|/**    * @return Return the rootDir.    */
end_comment

begin_function
specifier|protected
name|Path
name|getRootDir
parameter_list|()
block|{
return|return
name|rootDir
return|;
block|}
end_function

begin_comment
comment|/**    * @return Return the fs.    */
end_comment

begin_function
specifier|protected
name|FileSystem
name|getFileSystem
parameter_list|()
block|{
return|return
name|fs
return|;
block|}
end_function

begin_comment
comment|/**    * @return Info on port this server has bound to, etc.    */
end_comment

begin_function
specifier|public
name|HServerInfo
name|getServerInfo
parameter_list|()
block|{
return|return
name|this
operator|.
name|serverInfo
return|;
block|}
end_function

begin_comment
comment|/** {@inheritDoc} */
end_comment

begin_function
specifier|public
name|long
name|incrementColumnValue
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|,
name|byte
index|[]
name|row
parameter_list|,
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|long
name|amount
parameter_list|,
name|boolean
name|writeToWAL
parameter_list|)
throws|throws
name|IOException
block|{
name|checkOpen
argument_list|()
expr_stmt|;
if|if
condition|(
name|regionName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid arguments to incrementColumnValue "
operator|+
literal|"regionName is null"
argument_list|)
throw|;
block|}
name|requestCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|HRegion
name|region
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|long
name|retval
init|=
name|region
operator|.
name|incrementColumnValue
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|amount
argument_list|,
name|writeToWAL
argument_list|)
decl_stmt|;
return|return
name|retval
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkFileSystem
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
end_function

begin_comment
comment|/** {@inheritDoc} */
end_comment

begin_function
specifier|public
name|HRegionInfo
index|[]
name|getRegionsAssignment
parameter_list|()
throws|throws
name|IOException
block|{
name|HRegionInfo
index|[]
name|regions
init|=
operator|new
name|HRegionInfo
index|[
name|onlineRegions
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|Iterator
argument_list|<
name|HRegion
argument_list|>
name|ite
init|=
name|onlineRegions
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|ite
operator|.
name|hasNext
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|regions
index|[
name|i
index|]
operator|=
name|ite
operator|.
name|next
argument_list|()
operator|.
name|getRegionInfo
argument_list|()
expr_stmt|;
block|}
return|return
name|regions
return|;
block|}
end_function

begin_comment
comment|/** {@inheritDoc} */
end_comment

begin_function
specifier|public
name|HServerInfo
name|getHServerInfo
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|serverInfo
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|MultiResponse
name|multi
parameter_list|(
name|MultiAction
name|multi
parameter_list|)
throws|throws
name|IOException
block|{
name|MultiResponse
name|response
init|=
operator|new
name|MultiResponse
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|List
argument_list|<
name|Action
argument_list|>
argument_list|>
name|e
range|:
name|multi
operator|.
name|actions
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|byte
index|[]
name|regionName
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Action
argument_list|>
name|actionsForRegion
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// sort based on the row id - this helps in the case where we reach the
comment|// end of a region, so that we don't have to try the rest of the
comment|// actions in the list.
name|Collections
operator|.
name|sort
argument_list|(
name|actionsForRegion
argument_list|)
expr_stmt|;
name|Row
name|action
init|=
literal|null
decl_stmt|;
try|try
block|{
for|for
control|(
name|Action
name|a
range|:
name|actionsForRegion
control|)
block|{
name|action
operator|=
name|a
operator|.
name|getAction
argument_list|()
expr_stmt|;
if|if
condition|(
name|action
operator|instanceof
name|Delete
condition|)
block|{
name|delete
argument_list|(
name|regionName
argument_list|,
operator|(
name|Delete
operator|)
name|action
argument_list|)
expr_stmt|;
name|response
operator|.
name|add
argument_list|(
name|regionName
argument_list|,
operator|new
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Result
argument_list|>
argument_list|(
name|a
operator|.
name|getOriginalIndex
argument_list|()
argument_list|,
operator|new
name|Result
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|instanceof
name|Get
condition|)
block|{
name|response
operator|.
name|add
argument_list|(
name|regionName
argument_list|,
operator|new
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Result
argument_list|>
argument_list|(
name|a
operator|.
name|getOriginalIndex
argument_list|()
argument_list|,
name|get
argument_list|(
name|regionName
argument_list|,
operator|(
name|Get
operator|)
name|action
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|instanceof
name|Put
condition|)
block|{
name|put
argument_list|(
name|regionName
argument_list|,
operator|(
name|Put
operator|)
name|action
argument_list|)
expr_stmt|;
name|response
operator|.
name|add
argument_list|(
name|regionName
argument_list|,
operator|new
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Result
argument_list|>
argument_list|(
name|a
operator|.
name|getOriginalIndex
argument_list|()
argument_list|,
operator|new
name|Result
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Error: invalid Action, row must be a Get, Delete or Put."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid Action, row must be a Get, Delete or Put."
argument_list|)
throw|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
if|if
condition|(
name|multi
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
throw|throw
name|ioe
throw|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception processing "
operator|+
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
operator|.
name|abbreviate
argument_list|(
name|action
operator|.
name|toString
argument_list|()
argument_list|,
literal|64
argument_list|)
operator|+
literal|"; "
operator|+
name|ioe
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|response
operator|.
name|add
argument_list|(
name|regionName
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// stop processing on this region, continue to the next.
block|}
block|}
return|return
name|response
return|;
block|}
end_function

begin_comment
comment|/**    * @deprecated Use HRegionServer.multi( MultiAction action) instead    */
end_comment

begin_function
annotation|@
name|Override
specifier|public
name|MultiPutResponse
name|multiPut
parameter_list|(
name|MultiPut
name|puts
parameter_list|)
throws|throws
name|IOException
block|{
name|MultiPutResponse
name|resp
init|=
operator|new
name|MultiPutResponse
argument_list|()
decl_stmt|;
comment|// do each region as it's own.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|List
argument_list|<
name|Put
argument_list|>
argument_list|>
name|e
range|:
name|puts
operator|.
name|puts
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|int
name|result
init|=
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|resp
operator|.
name|addResult
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// clear some RAM
block|}
return|return
name|resp
return|;
block|}
end_function

begin_function
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|this
operator|.
name|serverInfo
operator|.
name|toString
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Interval at which threads should run    *    * @return the interval    */
end_comment

begin_function
specifier|public
name|int
name|getThreadWakeFrequency
parameter_list|()
block|{
return|return
name|threadWakeFrequency
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|ZooKeeperWatcher
name|getZooKeeper
parameter_list|()
block|{
return|return
name|zooKeeper
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|String
name|getServerName
parameter_list|()
block|{
return|return
name|serverInfo
operator|.
name|getServerName
argument_list|()
return|;
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|CompactionRequestor
name|getCompactionRequester
parameter_list|()
block|{
return|return
name|this
operator|.
name|compactSplitThread
return|;
block|}
end_function

begin_comment
comment|//
end_comment

begin_comment
comment|// Main program and support routines
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/**    * @param hrs    * @return Thread the RegionServer is running in correctly named.    * @throws IOException    */
end_comment

begin_function
specifier|public
specifier|static
name|Thread
name|startRegionServer
parameter_list|(
specifier|final
name|HRegionServer
name|hrs
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|startRegionServer
argument_list|(
name|hrs
argument_list|,
literal|"regionserver"
operator|+
name|hrs
operator|.
name|getServerInfo
argument_list|()
operator|.
name|getServerAddress
argument_list|()
operator|.
name|getPort
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * @param hrs    * @param name    * @return Thread the RegionServer is running in correctly named.    * @throws IOException    */
end_comment

begin_function
specifier|public
specifier|static
name|Thread
name|startRegionServer
parameter_list|(
specifier|final
name|HRegionServer
name|hrs
parameter_list|,
specifier|final
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|Thread
name|t
init|=
operator|new
name|Thread
argument_list|(
name|hrs
argument_list|)
decl_stmt|;
name|t
operator|.
name|setName
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Install shutdown hook that will catch signals and run an orderly shutdown
comment|// of the hrs.
name|ShutdownHook
operator|.
name|install
argument_list|(
name|hrs
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|FileSystem
operator|.
name|get
argument_list|(
name|hrs
operator|.
name|getConfiguration
argument_list|()
argument_list|)
argument_list|,
name|hrs
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/**    * Utility for constructing an instance of the passed HRegionServer class.    *    * @param regionServerClass    * @param conf2    * @return HRegionServer instance.    */
end_comment

begin_function
specifier|public
specifier|static
name|HRegionServer
name|constructRegionServer
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|HRegionServer
argument_list|>
name|regionServerClass
parameter_list|,
specifier|final
name|Configuration
name|conf2
parameter_list|)
block|{
try|try
block|{
name|Constructor
argument_list|<
name|?
extends|extends
name|HRegionServer
argument_list|>
name|c
init|=
name|regionServerClass
operator|.
name|getConstructor
argument_list|(
name|Configuration
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|c
operator|.
name|newInstance
argument_list|(
name|conf2
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Failed construction of "
operator|+
literal|"Master: "
operator|+
name|regionServerClass
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|void
name|replicateLogEntries
parameter_list|(
specifier|final
name|HLog
operator|.
name|Entry
index|[]
name|entries
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|replicationHandler
operator|==
literal|null
condition|)
return|return;
name|this
operator|.
name|replicationHandler
operator|.
name|replicateLogEntries
argument_list|(
name|entries
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**    * @see org.apache.hadoop.hbase.regionserver.HRegionServerCommandLine    */
end_comment

begin_function
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|Configuration
name|conf
init|=
name|HBaseConfiguration
operator|.
name|create
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Class
argument_list|<
name|?
extends|extends
name|HRegionServer
argument_list|>
name|regionServerClass
init|=
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|HRegionServer
argument_list|>
operator|)
name|conf
operator|.
name|getClass
argument_list|(
name|HConstants
operator|.
name|REGION_SERVER_IMPL
argument_list|,
name|HRegionServer
operator|.
name|class
argument_list|)
decl_stmt|;
operator|new
name|HRegionServerCommandLine
argument_list|(
name|regionServerClass
argument_list|)
operator|.
name|doMain
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

unit|}
end_unit

