begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2011 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|HFile
operator|.
name|FileInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|IdLock
import|;
end_import

begin_comment
comment|/**  * {@link HFile} reader for version 2.  */
end_comment

begin_class
specifier|public
class|class
name|HFileReaderV2
extends|extends
name|AbstractHFileReader
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HFileReaderV2
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * The size of a (key length, value length) tuple that prefixes each entry in    * a data block.    */
specifier|private
specifier|static
specifier|final
name|int
name|KEY_VALUE_LEN_SIZE
init|=
literal|2
operator|*
name|Bytes
operator|.
name|SIZEOF_INT
decl_stmt|;
comment|/**    * A "sparse lock" implementation allowing to lock on a particular block    * identified by offset. The purpose of this is to avoid two clients loading    * the same block, and have all but one client wait to get the block from the    * cache.    */
specifier|private
name|IdLock
name|offsetLock
init|=
operator|new
name|IdLock
argument_list|()
decl_stmt|;
comment|/**    * Blocks read from the load-on-open section, excluding data root index, meta    * index, and file info.    */
specifier|private
name|List
argument_list|<
name|HFileBlock
argument_list|>
name|loadOnOpenBlocks
init|=
operator|new
name|ArrayList
argument_list|<
name|HFileBlock
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Opens a HFile. You must load the index before you can use it by calling    * {@link #loadFileInfo()}.    *    * @param fsdis input stream. Caller is responsible for closing the passed    *          stream.    * @param size Length of the stream.    * @param blockCache block cache. Pass null if none.    * @param inMemory whether blocks should be marked as in-memory in cache    * @param evictOnClose whether blocks in cache should be evicted on close    * @throws IOException    */
specifier|public
name|HFileReaderV2
parameter_list|(
name|Path
name|path
parameter_list|,
name|FixedFileTrailer
name|trailer
parameter_list|,
specifier|final
name|FSDataInputStream
name|fsdis
parameter_list|,
specifier|final
name|long
name|size
parameter_list|,
specifier|final
name|boolean
name|closeIStream
parameter_list|,
specifier|final
name|BlockCache
name|blockCache
parameter_list|,
specifier|final
name|boolean
name|inMemory
parameter_list|,
specifier|final
name|boolean
name|evictOnClose
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|path
argument_list|,
name|trailer
argument_list|,
name|fsdis
argument_list|,
name|size
argument_list|,
name|closeIStream
argument_list|,
name|blockCache
argument_list|,
name|inMemory
argument_list|,
name|evictOnClose
argument_list|)
expr_stmt|;
name|trailer
operator|.
name|expectVersion
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|fsBlockReader
operator|=
operator|new
name|HFileBlock
operator|.
name|FSReaderV2
argument_list|(
name|fsdis
argument_list|,
name|compressAlgo
argument_list|,
name|fileSize
argument_list|)
expr_stmt|;
comment|// Comparator class name is stored in the trailer in version 2.
name|comparator
operator|=
name|trailer
operator|.
name|createComparator
argument_list|()
expr_stmt|;
name|dataBlockIndexReader
operator|=
operator|new
name|HFileBlockIndex
operator|.
name|BlockIndexReader
argument_list|(
name|comparator
argument_list|,
name|trailer
operator|.
name|getNumDataIndexLevels
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|metaBlockIndexReader
operator|=
operator|new
name|HFileBlockIndex
operator|.
name|BlockIndexReader
argument_list|(
name|Bytes
operator|.
name|BYTES_RAWCOMPARATOR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// Parse load-on-open data.
name|HFileBlock
operator|.
name|BlockIterator
name|blockIter
init|=
name|fsBlockReader
operator|.
name|blockRange
argument_list|(
name|trailer
operator|.
name|getLoadOnOpenDataOffset
argument_list|()
argument_list|,
name|fileSize
operator|-
name|trailer
operator|.
name|getTrailerSize
argument_list|()
argument_list|)
decl_stmt|;
comment|// Data index. We also read statistics about the block index written after
comment|// the root level.
name|dataBlockIndexReader
operator|.
name|readMultiLevelIndexRoot
argument_list|(
name|blockIter
operator|.
name|nextBlockAsStream
argument_list|(
name|BlockType
operator|.
name|ROOT_INDEX
argument_list|)
argument_list|,
name|trailer
operator|.
name|getDataIndexCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// Meta index.
name|metaBlockIndexReader
operator|.
name|readRootIndex
argument_list|(
name|blockIter
operator|.
name|nextBlockAsStream
argument_list|(
name|BlockType
operator|.
name|ROOT_INDEX
argument_list|)
argument_list|,
name|trailer
operator|.
name|getMetaIndexCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// File info
name|fileInfo
operator|=
operator|new
name|FileInfo
argument_list|()
expr_stmt|;
name|fileInfo
operator|.
name|readFields
argument_list|(
name|blockIter
operator|.
name|nextBlockAsStream
argument_list|(
name|BlockType
operator|.
name|FILE_INFO
argument_list|)
argument_list|)
expr_stmt|;
name|lastKey
operator|=
name|fileInfo
operator|.
name|get
argument_list|(
name|FileInfo
operator|.
name|LASTKEY
argument_list|)
expr_stmt|;
name|avgKeyLen
operator|=
name|Bytes
operator|.
name|toInt
argument_list|(
name|fileInfo
operator|.
name|get
argument_list|(
name|FileInfo
operator|.
name|AVG_KEY_LEN
argument_list|)
argument_list|)
expr_stmt|;
name|avgValueLen
operator|=
name|Bytes
operator|.
name|toInt
argument_list|(
name|fileInfo
operator|.
name|get
argument_list|(
name|FileInfo
operator|.
name|AVG_VALUE_LEN
argument_list|)
argument_list|)
expr_stmt|;
comment|// Store all other load-on-open blocks for further consumption.
name|HFileBlock
name|b
decl_stmt|;
while|while
condition|(
operator|(
name|b
operator|=
name|blockIter
operator|.
name|nextBlock
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|loadOnOpenBlocks
operator|.
name|add
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Create a Scanner on this file. No seeks or reads are done on creation. Call    * {@link HFileScanner#seekTo(byte[])} to position an start the read. There is    * nothing to clean up in a Scanner. Letting go of your references to the    * scanner is sufficient.    *    * @param cacheBlocks True if we should cache blocks read in by this scanner.    * @param pread Use positional read rather than seek+read if true (pread is    *          better for random reads, seek+read is better scanning).    * @param isCompaction is scanner being used for a compaction?    * @return Scanner on this file.    */
annotation|@
name|Override
specifier|public
name|HFileScanner
name|getScanner
parameter_list|(
name|boolean
name|cacheBlocks
parameter_list|,
specifier|final
name|boolean
name|pread
parameter_list|,
specifier|final
name|boolean
name|isCompaction
parameter_list|)
block|{
return|return
operator|new
name|ScannerV2
argument_list|(
name|this
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|)
return|;
block|}
comment|/**    * @param metaBlockName    * @param cacheBlock Add block to cache, if found    * @return block wrapped in a ByteBuffer, with header skipped    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|ByteBuffer
name|getMetaBlock
parameter_list|(
name|String
name|metaBlockName
parameter_list|,
name|boolean
name|cacheBlock
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|trailer
operator|.
name|getMetaIndexCount
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
comment|// there are no meta blocks
block|}
if|if
condition|(
name|metaBlockIndexReader
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Meta index not loaded"
argument_list|)
throw|;
block|}
name|byte
index|[]
name|mbname
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|metaBlockName
argument_list|)
decl_stmt|;
name|int
name|block
init|=
name|metaBlockIndexReader
operator|.
name|rootBlockContainingKey
argument_list|(
name|mbname
argument_list|,
literal|0
argument_list|,
name|mbname
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|block
operator|==
operator|-
literal|1
condition|)
return|return
literal|null
return|;
name|long
name|blockSize
init|=
name|metaBlockIndexReader
operator|.
name|getRootBlockDataSize
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|long
name|startTimeNs
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
comment|// Per meta key from any given file, synchronize reads for said block. This
comment|// is OK to do for meta blocks because the meta block index is always
comment|// single-level.
synchronized|synchronized
init|(
name|metaBlockIndexReader
operator|.
name|getRootBlockKey
argument_list|(
name|block
argument_list|)
init|)
block|{
name|metaLoads
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
comment|// Check cache for block. If found return.
name|long
name|metaBlockOffset
init|=
name|metaBlockIndexReader
operator|.
name|getRootBlockOffset
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|String
name|cacheKey
init|=
name|HFile
operator|.
name|getBlockCacheKey
argument_list|(
name|name
argument_list|,
name|metaBlockOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|blockCache
operator|!=
literal|null
condition|)
block|{
name|HFileBlock
name|cachedBlock
init|=
operator|(
name|HFileBlock
operator|)
name|blockCache
operator|.
name|getBlock
argument_list|(
name|cacheKey
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|cachedBlock
operator|!=
literal|null
condition|)
block|{
comment|// Return a distinct 'shallow copy' of the block,
comment|// so pos does not get messed by the scanner
name|cacheHits
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return
name|cachedBlock
operator|.
name|getBufferWithoutHeader
argument_list|()
return|;
block|}
comment|// Cache Miss, please load.
block|}
name|HFileBlock
name|metaBlock
init|=
name|fsBlockReader
operator|.
name|readBlockData
argument_list|(
name|metaBlockOffset
argument_list|,
name|blockSize
argument_list|,
operator|-
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|HFile
operator|.
name|readTimeNano
operator|.
name|addAndGet
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTimeNs
argument_list|)
expr_stmt|;
name|HFile
operator|.
name|readOps
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
comment|// Cache the block
if|if
condition|(
name|cacheBlock
operator|&&
name|blockCache
operator|!=
literal|null
condition|)
block|{
name|blockCache
operator|.
name|cacheBlock
argument_list|(
name|cacheKey
argument_list|,
name|metaBlock
argument_list|,
name|inMemory
argument_list|)
expr_stmt|;
block|}
return|return
name|metaBlock
operator|.
name|getBufferWithoutHeader
argument_list|()
return|;
block|}
block|}
comment|/**    * Read in a file block.    *    * @param dataBlockOffset offset to read.    * @param onDiskSize size of the block    * @param pread Use positional read instead of seek+read (positional is better    *          doing random reads whereas seek+read is better scanning).    * @param isCompaction is this block being read as part of a compaction    * @return Block wrapped in a ByteBuffer.    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|HFileBlock
name|readBlock
parameter_list|(
name|long
name|dataBlockOffset
parameter_list|,
name|long
name|onDiskBlockSize
parameter_list|,
name|boolean
name|cacheBlock
parameter_list|,
name|boolean
name|pread
parameter_list|,
specifier|final
name|boolean
name|isCompaction
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|dataBlockIndexReader
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block index not loaded"
argument_list|)
throw|;
block|}
if|if
condition|(
name|dataBlockOffset
operator|<
literal|0
operator|||
name|dataBlockOffset
operator|>=
name|trailer
operator|.
name|getLoadOnOpenDataOffset
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Requested block is out of range: "
operator|+
name|dataBlockOffset
operator|+
literal|", lastDataBlockOffset: "
operator|+
name|trailer
operator|.
name|getLastDataBlockOffset
argument_list|()
argument_list|)
throw|;
block|}
comment|// For any given block from any given file, synchronize reads for said
comment|// block.
comment|// Without a cache, this synchronizing is needless overhead, but really
comment|// the other choice is to duplicate work (which the cache would prevent you
comment|// from doing).
name|String
name|cacheKey
init|=
name|HFile
operator|.
name|getBlockCacheKey
argument_list|(
name|name
argument_list|,
name|dataBlockOffset
argument_list|)
decl_stmt|;
name|IdLock
operator|.
name|Entry
name|lockEntry
init|=
name|offsetLock
operator|.
name|getLockEntry
argument_list|(
name|dataBlockOffset
argument_list|)
decl_stmt|;
try|try
block|{
name|blockLoads
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
comment|// Check cache for block. If found return.
if|if
condition|(
name|blockCache
operator|!=
literal|null
condition|)
block|{
name|HFileBlock
name|cachedBlock
init|=
operator|(
name|HFileBlock
operator|)
name|blockCache
operator|.
name|getBlock
argument_list|(
name|cacheKey
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|cachedBlock
operator|!=
literal|null
condition|)
block|{
name|cacheHits
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return
name|cachedBlock
return|;
block|}
comment|// Carry on, please load.
block|}
comment|// Load block from filesystem.
name|long
name|startTimeNs
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|HFileBlock
name|dataBlock
init|=
name|fsBlockReader
operator|.
name|readBlockData
argument_list|(
name|dataBlockOffset
argument_list|,
name|onDiskBlockSize
argument_list|,
operator|-
literal|1
argument_list|,
name|pread
argument_list|)
decl_stmt|;
name|HFile
operator|.
name|readTimeNano
operator|.
name|addAndGet
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTimeNs
argument_list|)
expr_stmt|;
name|HFile
operator|.
name|readOps
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
comment|// Cache the block
if|if
condition|(
name|cacheBlock
operator|&&
name|blockCache
operator|!=
literal|null
condition|)
block|{
name|blockCache
operator|.
name|cacheBlock
argument_list|(
name|cacheKey
argument_list|,
name|dataBlock
argument_list|,
name|inMemory
argument_list|)
expr_stmt|;
block|}
return|return
name|dataBlock
return|;
block|}
finally|finally
block|{
name|offsetLock
operator|.
name|releaseLockEntry
argument_list|(
name|lockEntry
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @return Last key in the file. May be null if file has no entries. Note that    *         this is not the last row key, but rather the byte form of the last    *         KeyValue.    */
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|getLastKey
parameter_list|()
block|{
return|return
name|dataBlockIndexReader
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|lastKey
return|;
block|}
comment|/**    * @return Midkey for this file. We work with block boundaries only so    *         returned midkey is an approximation only.    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|midkey
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|dataBlockIndexReader
operator|.
name|midkey
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|evictOnClose
operator|&&
name|blockCache
operator|!=
literal|null
condition|)
block|{
name|int
name|numEvicted
init|=
name|blockCache
operator|.
name|evictBlocksByPrefix
argument_list|(
name|name
operator|+
name|HFile
operator|.
name|CACHE_KEY_SEPARATOR
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"On close of file "
operator|+
name|name
operator|+
literal|" evicted "
operator|+
name|numEvicted
operator|+
literal|" block(s)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|closeIStream
operator|&&
name|istream
operator|!=
literal|null
condition|)
block|{
name|istream
operator|.
name|close
argument_list|()
expr_stmt|;
name|istream
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**    * Implementation of {@link HFileScanner} interface.    */
specifier|protected
specifier|static
class|class
name|ScannerV2
extends|extends
name|AbstractHFileReader
operator|.
name|Scanner
block|{
specifier|private
name|HFileBlock
name|block
decl_stmt|;
specifier|public
name|ScannerV2
parameter_list|(
name|HFileReaderV2
name|r
parameter_list|,
name|boolean
name|cacheBlocks
parameter_list|,
specifier|final
name|boolean
name|pread
parameter_list|,
specifier|final
name|boolean
name|isCompaction
parameter_list|)
block|{
name|super
argument_list|(
name|r
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|KeyValue
name|getKeyValue
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isSeeked
argument_list|()
condition|)
return|return
literal|null
return|;
return|return
operator|new
name|KeyValue
argument_list|(
name|blockBuffer
operator|.
name|array
argument_list|()
argument_list|,
name|blockBuffer
operator|.
name|arrayOffset
argument_list|()
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|ByteBuffer
name|getKey
parameter_list|()
block|{
name|assertSeeked
argument_list|()
expr_stmt|;
return|return
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|blockBuffer
operator|.
name|array
argument_list|()
argument_list|,
name|blockBuffer
operator|.
name|arrayOffset
argument_list|()
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
name|KEY_VALUE_LEN_SIZE
argument_list|,
name|currKeyLen
argument_list|)
operator|.
name|slice
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|ByteBuffer
name|getValue
parameter_list|()
block|{
name|assertSeeked
argument_list|()
expr_stmt|;
return|return
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|blockBuffer
operator|.
name|array
argument_list|()
argument_list|,
name|blockBuffer
operator|.
name|arrayOffset
argument_list|()
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
name|KEY_VALUE_LEN_SIZE
operator|+
name|currKeyLen
argument_list|,
name|currValueLen
argument_list|)
operator|.
name|slice
argument_list|()
return|;
block|}
specifier|private
name|void
name|setNonSeekedState
parameter_list|()
block|{
name|block
operator|=
literal|null
expr_stmt|;
name|blockBuffer
operator|=
literal|null
expr_stmt|;
name|currKeyLen
operator|=
literal|0
expr_stmt|;
name|currValueLen
operator|=
literal|0
expr_stmt|;
block|}
comment|/**      * Go to the next key/value in the block section. Loads the next block if      * necessary. If successful, {@link #getKey()} and {@link #getValue()} can      * be called.      *      * @return true if successfully navigated to the next key/value      */
annotation|@
name|Override
specifier|public
name|boolean
name|next
parameter_list|()
throws|throws
name|IOException
block|{
name|assertSeeked
argument_list|()
expr_stmt|;
try|try
block|{
name|blockBuffer
operator|.
name|position
argument_list|(
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
name|KEY_VALUE_LEN_SIZE
operator|+
name|currKeyLen
operator|+
name|currValueLen
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Current pos = "
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
literal|"; currKeyLen = "
operator|+
name|currKeyLen
operator|+
literal|"; currValLen = "
operator|+
name|currValueLen
operator|+
literal|"; block limit = "
operator|+
name|blockBuffer
operator|.
name|limit
argument_list|()
operator|+
literal|"; HFile name = "
operator|+
name|reader
operator|.
name|getName
argument_list|()
operator|+
literal|"; currBlock currBlockOffset = "
operator|+
name|block
operator|.
name|getOffset
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
if|if
condition|(
name|blockBuffer
operator|.
name|remaining
argument_list|()
operator|<=
literal|0
condition|)
block|{
name|long
name|lastDataBlockOffset
init|=
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getLastDataBlockOffset
argument_list|()
decl_stmt|;
if|if
condition|(
name|block
operator|.
name|getOffset
argument_list|()
operator|>=
name|lastDataBlockOffset
condition|)
block|{
name|setNonSeekedState
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// read the next block
name|HFileBlock
name|nextBlock
init|=
name|readNextDataBlock
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextBlock
operator|==
literal|null
condition|)
block|{
name|setNonSeekedState
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|updateCurrBlock
argument_list|(
name|nextBlock
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// We are still in the same block.
name|readKeyValueLen
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * Scans blocks in the "scanned" section of the {@link HFile} until the next      * data block is found.      *      * @return the next block, or null if there are no more data blocks      * @throws IOException      */
specifier|private
name|HFileBlock
name|readNextDataBlock
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|lastDataBlockOffset
init|=
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getLastDataBlockOffset
argument_list|()
decl_stmt|;
if|if
condition|(
name|block
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|HFileBlock
name|curBlock
init|=
name|block
decl_stmt|;
do|do
block|{
if|if
condition|(
name|curBlock
operator|.
name|getOffset
argument_list|()
operator|>=
name|lastDataBlockOffset
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|curBlock
operator|.
name|getOffset
argument_list|()
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid block file offset: "
operator|+
name|block
argument_list|)
throw|;
block|}
name|curBlock
operator|=
name|reader
operator|.
name|readBlock
argument_list|(
name|curBlock
operator|.
name|getOffset
argument_list|()
operator|+
name|curBlock
operator|.
name|getOnDiskSizeWithHeader
argument_list|()
argument_list|,
name|curBlock
operator|.
name|getNextBlockOnDiskSizeWithHeader
argument_list|()
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|curBlock
operator|.
name|getBlockType
argument_list|()
operator|.
name|equals
argument_list|(
name|BlockType
operator|.
name|DATA
argument_list|)
condition|)
do|;
return|return
name|curBlock
return|;
block|}
comment|/**      * Positions this scanner at the start of the file.      *      * @return false if empty file; i.e. a call to next would return false and      *         the current key and value are undefined.      * @throws IOException      */
annotation|@
name|Override
specifier|public
name|boolean
name|seekTo
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|reader
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getEntryCount
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// No data blocks.
return|return
literal|false
return|;
block|}
name|long
name|firstDataBlockOffset
init|=
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getFirstDataBlockOffset
argument_list|()
decl_stmt|;
if|if
condition|(
name|block
operator|!=
literal|null
operator|&&
name|block
operator|.
name|getOffset
argument_list|()
operator|==
name|firstDataBlockOffset
condition|)
block|{
name|blockBuffer
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|readKeyValueLen
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
name|block
operator|=
name|reader
operator|.
name|readBlock
argument_list|(
name|firstDataBlockOffset
argument_list|,
operator|-
literal|1
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|.
name|getOffset
argument_list|()
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid block offset: "
operator|+
name|block
operator|.
name|getOffset
argument_list|()
argument_list|)
throw|;
block|}
name|updateCurrBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|seekTo
parameter_list|(
name|byte
index|[]
name|key
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|seekTo
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**      * An internal API function. Seek to the given key, optionally rewinding to      * the first key of the block before doing the seek.      *      * @param key key byte array      * @param offset key offset in the key byte array      * @param length key length      * @param rewind whether to rewind to the first key of the block before      *        doing the seek. If this is false, we are assuming we never go      *        back, otherwise the result is undefined.      * @return -1 if the key is earlier than the first key of the file,      *         0 if we are at the given key, and 1 if we are past the given key      * @throws IOException      */
specifier|private
name|int
name|seekTo
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|rewind
parameter_list|)
throws|throws
name|IOException
block|{
name|HFileBlockIndex
operator|.
name|BlockIndexReader
name|indexReader
init|=
name|reader
operator|.
name|getDataBlockIndexReader
argument_list|()
decl_stmt|;
name|HFileBlock
name|seekToBlock
init|=
name|indexReader
operator|.
name|seekToDataBlock
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|block
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|)
decl_stmt|;
if|if
condition|(
name|seekToBlock
operator|==
literal|null
condition|)
block|{
comment|// This happens if the key e.g. falls before the beginning of the file.
return|return
operator|-
literal|1
return|;
block|}
return|return
name|loadBlockAndSeekToKey
argument_list|(
name|seekToBlock
argument_list|,
name|rewind
argument_list|,
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|seekTo
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Always rewind to the first key of the block, because the given key
comment|// might be before or after the current key.
return|return
name|seekTo
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|reseekTo
parameter_list|(
name|byte
index|[]
name|key
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|reseekTo
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|length
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|reseekTo
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isSeeked
argument_list|()
condition|)
block|{
name|ByteBuffer
name|bb
init|=
name|getKey
argument_list|()
decl_stmt|;
name|int
name|compared
init|=
name|reader
operator|.
name|getComparator
argument_list|()
operator|.
name|compare
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|bb
operator|.
name|array
argument_list|()
argument_list|,
name|bb
operator|.
name|arrayOffset
argument_list|()
argument_list|,
name|bb
operator|.
name|limit
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|compared
operator|<
literal|1
condition|)
block|{
comment|// If the required key is less than or equal to current key, then
comment|// don't do anything.
return|return
name|compared
return|;
block|}
block|}
comment|// Don't rewind on a reseek operation, because reseek implies that we are
comment|// always going forward in the file.
return|return
name|seekTo
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|private
name|int
name|loadBlockAndSeekToKey
parameter_list|(
name|HFileBlock
name|seekToBlock
parameter_list|,
name|boolean
name|rewind
parameter_list|,
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|seekBefore
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|block
operator|==
literal|null
operator|||
name|block
operator|.
name|getOffset
argument_list|()
operator|!=
name|seekToBlock
operator|.
name|getOffset
argument_list|()
condition|)
block|{
name|updateCurrBlock
argument_list|(
name|seekToBlock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rewind
condition|)
block|{
name|blockBuffer
operator|.
name|rewind
argument_list|()
expr_stmt|;
block|}
return|return
name|blockSeek
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|seekBefore
argument_list|)
return|;
block|}
comment|/**      * Updates the current block to be the given {@link HFileBlock}. Seeks to      * the the first key/value pair.      *      * @param newBlock the block to make current      */
specifier|private
name|void
name|updateCurrBlock
parameter_list|(
name|HFileBlock
name|newBlock
parameter_list|)
block|{
name|block
operator|=
name|newBlock
expr_stmt|;
name|blockBuffer
operator|=
name|block
operator|.
name|getBufferWithoutHeader
argument_list|()
expr_stmt|;
name|readKeyValueLen
argument_list|()
expr_stmt|;
name|blockFetches
operator|++
expr_stmt|;
block|}
specifier|private
specifier|final
name|void
name|readKeyValueLen
parameter_list|()
block|{
name|blockBuffer
operator|.
name|mark
argument_list|()
expr_stmt|;
name|currKeyLen
operator|=
name|blockBuffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|currValueLen
operator|=
name|blockBuffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|blockBuffer
operator|.
name|reset
argument_list|()
expr_stmt|;
if|if
condition|(
name|currKeyLen
argument_list|<
literal|0
operator|||
name|currValueLen
argument_list|<
literal|0
operator|||
name|currKeyLen
argument_list|>
name|blockBuffer
operator|.
name|limit
operator|(
operator|)
operator|||
name|currValueLen
argument_list|>
name|blockBuffer
operator|.
name|limit
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Invalid currKeyLen "
operator|+
name|currKeyLen
operator|+
literal|" or currValueLen "
operator|+
name|currValueLen
operator|+
literal|". Block offset: "
operator|+
name|block
operator|.
name|getOffset
argument_list|()
operator|+
literal|", block length: "
operator|+
name|blockBuffer
operator|.
name|limit
argument_list|()
operator|+
literal|", position: "
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
literal|" (without header)."
argument_list|)
throw|;
block|}
block|}
comment|/**      * Within a loaded block, seek looking for the first key that is smaller      * than (or equal to?) the key we are interested in.      *      * A note on the seekBefore: if you have seekBefore = true, AND the first      * key in the block = key, then you'll get thrown exceptions. The caller has      * to check for that case and load the previous block as appropriate.      *      * @param key the key to find      * @param seekBefore find the key before the given key in case of exact      *          match.      * @return 0 in case of an exact key match, 1 in case of an inexact match      */
specifier|private
name|int
name|blockSeek
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|seekBefore
parameter_list|)
block|{
name|int
name|klen
decl_stmt|,
name|vlen
decl_stmt|;
name|int
name|lastKeyValueSize
init|=
operator|-
literal|1
decl_stmt|;
do|do
block|{
name|blockBuffer
operator|.
name|mark
argument_list|()
expr_stmt|;
name|klen
operator|=
name|blockBuffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|vlen
operator|=
name|blockBuffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|blockBuffer
operator|.
name|reset
argument_list|()
expr_stmt|;
name|int
name|keyOffset
init|=
name|blockBuffer
operator|.
name|arrayOffset
argument_list|()
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
name|KEY_VALUE_LEN_SIZE
decl_stmt|;
name|int
name|comp
init|=
name|reader
operator|.
name|getComparator
argument_list|()
operator|.
name|compare
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|blockBuffer
operator|.
name|array
argument_list|()
argument_list|,
name|keyOffset
argument_list|,
name|klen
argument_list|)
decl_stmt|;
if|if
condition|(
name|comp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|seekBefore
condition|)
block|{
if|if
condition|(
name|lastKeyValueSize
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"blockSeek with seekBefore "
operator|+
literal|"at the first key of the block: key="
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|key
argument_list|)
operator|+
literal|", blockOffset="
operator|+
name|block
operator|.
name|getOffset
argument_list|()
operator|+
literal|", onDiskSize="
operator|+
name|block
operator|.
name|getOnDiskSizeWithHeader
argument_list|()
argument_list|)
throw|;
block|}
name|blockBuffer
operator|.
name|position
argument_list|(
name|blockBuffer
operator|.
name|position
argument_list|()
operator|-
name|lastKeyValueSize
argument_list|)
expr_stmt|;
name|readKeyValueLen
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
comment|// non exact match.
block|}
name|currKeyLen
operator|=
name|klen
expr_stmt|;
name|currValueLen
operator|=
name|vlen
expr_stmt|;
return|return
literal|0
return|;
comment|// indicate exact match
block|}
if|if
condition|(
name|comp
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|lastKeyValueSize
operator|>
literal|0
condition|)
name|blockBuffer
operator|.
name|position
argument_list|(
name|blockBuffer
operator|.
name|position
argument_list|()
operator|-
name|lastKeyValueSize
argument_list|)
expr_stmt|;
name|readKeyValueLen
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|// The size of this key/value tuple, including key/value length fields.
name|lastKeyValueSize
operator|=
name|klen
operator|+
name|vlen
operator|+
name|KEY_VALUE_LEN_SIZE
expr_stmt|;
name|blockBuffer
operator|.
name|position
argument_list|(
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
name|lastKeyValueSize
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|blockBuffer
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
do|;
comment|// Seek to the last key we successfully read. This will happen if this is
comment|// the last key/value pair in the file, in which case the following call
comment|// to next() has to return false.
name|blockBuffer
operator|.
name|position
argument_list|(
name|blockBuffer
operator|.
name|position
argument_list|()
operator|-
name|lastKeyValueSize
argument_list|)
expr_stmt|;
name|readKeyValueLen
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
comment|// didn't exactly find it.
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|seekBefore
parameter_list|(
name|byte
index|[]
name|key
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|seekBefore
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|length
argument_list|)
return|;
block|}
specifier|private
name|ByteBuffer
name|getFirstKeyInBlock
parameter_list|(
name|HFileBlock
name|curBlock
parameter_list|)
block|{
name|ByteBuffer
name|buffer
init|=
name|curBlock
operator|.
name|getBufferWithoutHeader
argument_list|()
decl_stmt|;
comment|// It is safe to manipulate this buffer because we own the buffer object.
name|buffer
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|int
name|klen
init|=
name|buffer
operator|.
name|getInt
argument_list|()
decl_stmt|;
name|buffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|ByteBuffer
name|keyBuff
init|=
name|buffer
operator|.
name|slice
argument_list|()
decl_stmt|;
name|keyBuff
operator|.
name|limit
argument_list|(
name|klen
argument_list|)
expr_stmt|;
name|keyBuff
operator|.
name|rewind
argument_list|()
expr_stmt|;
return|return
name|keyBuff
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|seekBefore
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|HFileBlock
name|seekToBlock
init|=
name|reader
operator|.
name|getDataBlockIndexReader
argument_list|()
operator|.
name|seekToDataBlock
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|block
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|)
decl_stmt|;
if|if
condition|(
name|seekToBlock
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|ByteBuffer
name|firstKey
init|=
name|getFirstKeyInBlock
argument_list|(
name|seekToBlock
argument_list|)
decl_stmt|;
if|if
condition|(
name|reader
operator|.
name|getComparator
argument_list|()
operator|.
name|compare
argument_list|(
name|firstKey
operator|.
name|array
argument_list|()
argument_list|,
name|firstKey
operator|.
name|arrayOffset
argument_list|()
argument_list|,
name|firstKey
operator|.
name|limit
argument_list|()
argument_list|,
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|long
name|previousBlockOffset
init|=
name|seekToBlock
operator|.
name|getPrevBlockOffset
argument_list|()
decl_stmt|;
comment|// The key we are interested in
if|if
condition|(
name|previousBlockOffset
operator|==
operator|-
literal|1
condition|)
block|{
comment|// we have a 'problem', the key we want is the first of the file.
return|return
literal|false
return|;
block|}
comment|// It is important that we compute and pass onDiskSize to the block
comment|// reader so that it does not have to read the header separately to
comment|// figure out the size.
name|seekToBlock
operator|=
name|reader
operator|.
name|readBlock
argument_list|(
name|previousBlockOffset
argument_list|,
name|seekToBlock
operator|.
name|getOffset
argument_list|()
operator|-
name|previousBlockOffset
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|)
expr_stmt|;
comment|// TODO shortcut: seek forward in this block to the last key of the
comment|// block.
block|}
name|loadBlockAndSeekToKey
argument_list|(
name|seekToBlock
argument_list|,
literal|true
argument_list|,
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getKeyString
parameter_list|()
block|{
return|return
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|blockBuffer
operator|.
name|array
argument_list|()
argument_list|,
name|blockBuffer
operator|.
name|arrayOffset
argument_list|()
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
name|KEY_VALUE_LEN_SIZE
argument_list|,
name|currKeyLen
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getValueString
parameter_list|()
block|{
return|return
name|Bytes
operator|.
name|toString
argument_list|(
name|blockBuffer
operator|.
name|array
argument_list|()
argument_list|,
name|blockBuffer
operator|.
name|arrayOffset
argument_list|()
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
name|KEY_VALUE_LEN_SIZE
operator|+
name|currKeyLen
argument_list|,
name|currValueLen
argument_list|)
return|;
block|}
block|}
comment|/**    * Returns a buffer with the Bloom filter metadata. The caller takes    * ownership of the buffer.    */
annotation|@
name|Override
specifier|public
name|DataInput
name|getBloomFilterMetadata
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|HFileBlock
name|b
range|:
name|loadOnOpenBlocks
control|)
if|if
condition|(
name|b
operator|.
name|getBlockType
argument_list|()
operator|==
name|BlockType
operator|.
name|BLOOM_META
condition|)
return|return
name|b
operator|.
name|getByteStream
argument_list|()
return|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isFileInfoLoaded
parameter_list|()
block|{
return|return
literal|true
return|;
comment|// We load file info in constructor in version 2.
block|}
block|}
end_class

end_unit

