begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2009 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|WeakReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|HeapSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ClassSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactoryBuilder
import|;
end_import

begin_comment
comment|/**  * A block cache implementation that is memory-aware using {@link HeapSize},  * memory-bound using an LRU eviction algorithm, and concurrent: backed by a  * {@link ConcurrentHashMap} and with a non-blocking eviction thread giving  * constant-time {@link #cacheBlock} and {@link #getBlock} operations.<p>  *  * Contains three levels of block priority to allow for  * scan-resistance and in-memory families.  A block is added with an inMemory  * flag if necessary, otherwise a block becomes a single access priority.  Once  * a blocked is accessed again, it changes to multiple access.  This is used  * to prevent scans from thrashing the cache, adding a least-frequently-used  * element to the eviction algorithm.<p>  *  * Each priority is given its own chunk of the total cache to ensure  * fairness during eviction.  Each priority will retain close to its maximum  * size, however, if any priority is not using its entire chunk the others  * are able to grow beyond their chunk size.<p>  *  * Instantiated at a minimum with the total size and average block size.  * All sizes are in bytes.  The block size is not especially important as this  * cache is fully dynamic in its sizing of blocks.  It is only used for  * pre-allocating data structures and in initial heap estimation of the map.<p>  *  * The detailed constructor defines the sizes for the three priorities (they  * should total to the maximum size defined).  It also sets the levels that  * trigger and control the eviction thread.<p>  *  * The acceptable size is the cache size level which triggers the eviction  * process to start.  It evicts enough blocks to get the size below the  * minimum size specified.<p>  *  * Eviction happens in a separate thread and involves a single full-scan  * of the map.  It determines how many bytes must be freed to reach the minimum  * size, and then while scanning determines the fewest least-recently-used  * blocks necessary from each of the three priorities (would be 3 times bytes  * to free).  It then uses the priority chunk sizes to evict fairly according  * to the relative sizes and usage.  */
end_comment

begin_class
specifier|public
class|class
name|LruBlockCache
implements|implements
name|BlockCache
implements|,
name|HeapSize
block|{
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|LruBlockCache
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** Default Configuration Parameters*/
comment|/** Backing Concurrent Map Configuration */
specifier|static
specifier|final
name|float
name|DEFAULT_LOAD_FACTOR
init|=
literal|0.75f
decl_stmt|;
specifier|static
specifier|final
name|int
name|DEFAULT_CONCURRENCY_LEVEL
init|=
literal|16
decl_stmt|;
comment|/** Eviction thresholds */
specifier|static
specifier|final
name|float
name|DEFAULT_MIN_FACTOR
init|=
literal|0.75f
decl_stmt|;
specifier|static
specifier|final
name|float
name|DEFAULT_ACCEPTABLE_FACTOR
init|=
literal|0.85f
decl_stmt|;
comment|/** Priority buckets */
specifier|static
specifier|final
name|float
name|DEFAULT_SINGLE_FACTOR
init|=
literal|0.25f
decl_stmt|;
specifier|static
specifier|final
name|float
name|DEFAULT_MULTI_FACTOR
init|=
literal|0.50f
decl_stmt|;
specifier|static
specifier|final
name|float
name|DEFAULT_MEMORY_FACTOR
init|=
literal|0.25f
decl_stmt|;
comment|/** Statistics thread */
specifier|static
specifier|final
name|int
name|statThreadPeriod
init|=
literal|60
operator|*
literal|5
decl_stmt|;
comment|/** Concurrent map (the cache) */
specifier|private
specifier|final
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|CachedBlock
argument_list|>
name|map
decl_stmt|;
comment|/** Eviction lock (locked when eviction in process) */
specifier|private
specifier|final
name|ReentrantLock
name|evictionLock
init|=
operator|new
name|ReentrantLock
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|/** Volatile boolean to track if we are in an eviction process or not */
specifier|private
specifier|volatile
name|boolean
name|evictionInProgress
init|=
literal|false
decl_stmt|;
comment|/** Eviction thread */
specifier|private
specifier|final
name|EvictionThread
name|evictionThread
decl_stmt|;
comment|/** Statistics thread schedule pool (for heavy debugging, could remove) */
specifier|private
specifier|final
name|ScheduledExecutorService
name|scheduleThreadPool
init|=
name|Executors
operator|.
name|newScheduledThreadPool
argument_list|(
literal|1
argument_list|,
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setNameFormat
argument_list|(
literal|"LRU Statistics #%d"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
comment|/** Current size of cache */
specifier|private
specifier|final
name|AtomicLong
name|size
decl_stmt|;
comment|/** Current number of cached elements */
specifier|private
specifier|final
name|AtomicLong
name|elements
decl_stmt|;
comment|/** Cache access count (sequential ID) */
specifier|private
specifier|final
name|AtomicLong
name|count
decl_stmt|;
comment|/** Cache statistics */
specifier|private
specifier|final
name|CacheStats
name|stats
decl_stmt|;
comment|/** Maximum allowable size of cache (block put if size> max, evict) */
specifier|private
name|long
name|maxSize
decl_stmt|;
comment|/** Approximate block size */
specifier|private
name|long
name|blockSize
decl_stmt|;
comment|/** Acceptable size of cache (no evictions if size< acceptable) */
specifier|private
name|float
name|acceptableFactor
decl_stmt|;
comment|/** Minimum threshold of cache (when evicting, evict until size< min) */
specifier|private
name|float
name|minFactor
decl_stmt|;
comment|/** Single access bucket size */
specifier|private
name|float
name|singleFactor
decl_stmt|;
comment|/** Multiple access bucket size */
specifier|private
name|float
name|multiFactor
decl_stmt|;
comment|/** In-memory bucket size */
specifier|private
name|float
name|memoryFactor
decl_stmt|;
comment|/** Overhead of the structure itself */
specifier|private
name|long
name|overhead
decl_stmt|;
comment|/**    * Default constructor.  Specify maximum size and expected average block    * size (approximation is fine).    *    *<p>All other factors will be calculated based on defaults specified in    * this class.    * @param maxSize maximum size of cache, in bytes    * @param blockSize approximate size of each block, in bytes    */
specifier|public
name|LruBlockCache
parameter_list|(
name|long
name|maxSize
parameter_list|,
name|long
name|blockSize
parameter_list|)
block|{
name|this
argument_list|(
name|maxSize
argument_list|,
name|blockSize
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructor used for testing.  Allows disabling of the eviction thread.    */
specifier|public
name|LruBlockCache
parameter_list|(
name|long
name|maxSize
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|boolean
name|evictionThread
parameter_list|)
block|{
name|this
argument_list|(
name|maxSize
argument_list|,
name|blockSize
argument_list|,
name|evictionThread
argument_list|,
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
literal|1.2
operator|*
name|maxSize
operator|/
name|blockSize
argument_list|)
argument_list|,
name|DEFAULT_LOAD_FACTOR
argument_list|,
name|DEFAULT_CONCURRENCY_LEVEL
argument_list|,
name|DEFAULT_MIN_FACTOR
argument_list|,
name|DEFAULT_ACCEPTABLE_FACTOR
argument_list|,
name|DEFAULT_SINGLE_FACTOR
argument_list|,
name|DEFAULT_MULTI_FACTOR
argument_list|,
name|DEFAULT_MEMORY_FACTOR
argument_list|)
expr_stmt|;
block|}
comment|/**    * Configurable constructor.  Use this constructor if not using defaults.    * @param maxSize maximum size of this cache, in bytes    * @param blockSize expected average size of blocks, in bytes    * @param evictionThread whether to run evictions in a bg thread or not    * @param mapInitialSize initial size of backing ConcurrentHashMap    * @param mapLoadFactor initial load factor of backing ConcurrentHashMap    * @param mapConcurrencyLevel initial concurrency factor for backing CHM    * @param minFactor percentage of total size that eviction will evict until    * @param acceptableFactor percentage of total size that triggers eviction    * @param singleFactor percentage of total size for single-access blocks    * @param multiFactor percentage of total size for multiple-access blocks    * @param memoryFactor percentage of total size for in-memory blocks    */
specifier|public
name|LruBlockCache
parameter_list|(
name|long
name|maxSize
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|boolean
name|evictionThread
parameter_list|,
name|int
name|mapInitialSize
parameter_list|,
name|float
name|mapLoadFactor
parameter_list|,
name|int
name|mapConcurrencyLevel
parameter_list|,
name|float
name|minFactor
parameter_list|,
name|float
name|acceptableFactor
parameter_list|,
name|float
name|singleFactor
parameter_list|,
name|float
name|multiFactor
parameter_list|,
name|float
name|memoryFactor
parameter_list|)
block|{
if|if
condition|(
name|singleFactor
operator|+
name|multiFactor
operator|+
name|memoryFactor
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Single, multi, and memory factors "
operator|+
literal|" should total 1.0"
argument_list|)
throw|;
block|}
if|if
condition|(
name|minFactor
operator|>=
name|acceptableFactor
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"minFactor must be smaller than acceptableFactor"
argument_list|)
throw|;
block|}
if|if
condition|(
name|minFactor
operator|>=
literal|1.0f
operator|||
name|acceptableFactor
operator|>=
literal|1.0f
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"all factors must be< 1"
argument_list|)
throw|;
block|}
name|this
operator|.
name|maxSize
operator|=
name|maxSize
expr_stmt|;
name|this
operator|.
name|blockSize
operator|=
name|blockSize
expr_stmt|;
name|map
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|CachedBlock
argument_list|>
argument_list|(
name|mapInitialSize
argument_list|,
name|mapLoadFactor
argument_list|,
name|mapConcurrencyLevel
argument_list|)
expr_stmt|;
name|this
operator|.
name|minFactor
operator|=
name|minFactor
expr_stmt|;
name|this
operator|.
name|acceptableFactor
operator|=
name|acceptableFactor
expr_stmt|;
name|this
operator|.
name|singleFactor
operator|=
name|singleFactor
expr_stmt|;
name|this
operator|.
name|multiFactor
operator|=
name|multiFactor
expr_stmt|;
name|this
operator|.
name|memoryFactor
operator|=
name|memoryFactor
expr_stmt|;
name|this
operator|.
name|stats
operator|=
operator|new
name|CacheStats
argument_list|()
expr_stmt|;
name|this
operator|.
name|count
operator|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|elements
operator|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|overhead
operator|=
name|calculateOverhead
argument_list|(
name|maxSize
argument_list|,
name|blockSize
argument_list|,
name|mapConcurrencyLevel
argument_list|)
expr_stmt|;
name|this
operator|.
name|size
operator|=
operator|new
name|AtomicLong
argument_list|(
name|this
operator|.
name|overhead
argument_list|)
expr_stmt|;
if|if
condition|(
name|evictionThread
condition|)
block|{
name|this
operator|.
name|evictionThread
operator|=
operator|new
name|EvictionThread
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|evictionThread
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// FindBugs SC_START_IN_CTOR
block|}
else|else
block|{
name|this
operator|.
name|evictionThread
operator|=
literal|null
expr_stmt|;
block|}
name|this
operator|.
name|scheduleThreadPool
operator|.
name|scheduleAtFixedRate
argument_list|(
operator|new
name|StatisticsThread
argument_list|(
name|this
argument_list|)
argument_list|,
name|statThreadPeriod
argument_list|,
name|statThreadPeriod
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setMaxSize
parameter_list|(
name|long
name|maxSize
parameter_list|)
block|{
name|this
operator|.
name|maxSize
operator|=
name|maxSize
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|size
operator|.
name|get
argument_list|()
operator|>
name|acceptableSize
argument_list|()
operator|&&
operator|!
name|evictionInProgress
condition|)
block|{
name|runEviction
argument_list|()
expr_stmt|;
block|}
block|}
comment|// BlockCache implementation
comment|/**    * Cache the block with the specified name and buffer.    *<p>    * It is assumed this will NEVER be called on an already cached block.  If    * that is done, it is assumed that you are reinserting the same exact    * block due to a race condition and will update the buffer but not modify    * the size of the cache.    * @param blockName block name    * @param buf block buffer    * @param inMemory if block is in-memory    */
specifier|public
name|void
name|cacheBlock
parameter_list|(
name|String
name|blockName
parameter_list|,
name|ByteBuffer
name|buf
parameter_list|,
name|boolean
name|inMemory
parameter_list|)
block|{
name|CachedBlock
name|cb
init|=
name|map
operator|.
name|get
argument_list|(
name|blockName
argument_list|)
decl_stmt|;
if|if
condition|(
name|cb
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Cached an already cached block"
argument_list|)
throw|;
block|}
name|cb
operator|=
operator|new
name|CachedBlock
argument_list|(
name|blockName
argument_list|,
name|buf
argument_list|,
name|count
operator|.
name|incrementAndGet
argument_list|()
argument_list|,
name|inMemory
argument_list|)
expr_stmt|;
name|long
name|newSize
init|=
name|size
operator|.
name|addAndGet
argument_list|(
name|cb
operator|.
name|heapSize
argument_list|()
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|blockName
argument_list|,
name|cb
argument_list|)
expr_stmt|;
name|elements
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
if|if
condition|(
name|newSize
operator|>
name|acceptableSize
argument_list|()
operator|&&
operator|!
name|evictionInProgress
condition|)
block|{
name|runEviction
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Cache the block with the specified name and buffer.    *<p>    * It is assumed this will NEVER be called on an already cached block.  If    * that is done, it is assumed that you are reinserting the same exact    * block due to a race condition and will update the buffer but not modify    * the size of the cache.    * @param blockName block name    * @param buf block buffer    */
specifier|public
name|void
name|cacheBlock
parameter_list|(
name|String
name|blockName
parameter_list|,
name|ByteBuffer
name|buf
parameter_list|)
block|{
name|cacheBlock
argument_list|(
name|blockName
argument_list|,
name|buf
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the buffer of the block with the specified name.    * @param blockName block name    * @return buffer of specified block name, or null if not in cache    */
specifier|public
name|ByteBuffer
name|getBlock
parameter_list|(
name|String
name|blockName
parameter_list|,
name|boolean
name|caching
parameter_list|)
block|{
name|CachedBlock
name|cb
init|=
name|map
operator|.
name|get
argument_list|(
name|blockName
argument_list|)
decl_stmt|;
if|if
condition|(
name|cb
operator|==
literal|null
condition|)
block|{
name|stats
operator|.
name|miss
argument_list|(
name|caching
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|stats
operator|.
name|hit
argument_list|(
name|caching
argument_list|)
expr_stmt|;
name|cb
operator|.
name|access
argument_list|(
name|count
operator|.
name|incrementAndGet
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|cb
operator|.
name|getBuffer
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|evictBlock
parameter_list|(
name|String
name|blockName
parameter_list|)
block|{
name|CachedBlock
name|cb
init|=
name|map
operator|.
name|get
argument_list|(
name|blockName
argument_list|)
decl_stmt|;
if|if
condition|(
name|cb
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|evictBlock
argument_list|(
name|cb
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|protected
name|long
name|evictBlock
parameter_list|(
name|CachedBlock
name|block
parameter_list|)
block|{
name|map
operator|.
name|remove
argument_list|(
name|block
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|size
operator|.
name|addAndGet
argument_list|(
operator|-
literal|1
operator|*
name|block
operator|.
name|heapSize
argument_list|()
argument_list|)
expr_stmt|;
name|elements
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
name|stats
operator|.
name|evicted
argument_list|()
expr_stmt|;
return|return
name|block
operator|.
name|heapSize
argument_list|()
return|;
block|}
comment|/**    * Multi-threaded call to run the eviction process.    */
specifier|private
name|void
name|runEviction
parameter_list|()
block|{
if|if
condition|(
name|evictionThread
operator|==
literal|null
condition|)
block|{
name|evict
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|evictionThread
operator|.
name|evict
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Eviction method.    */
name|void
name|evict
parameter_list|()
block|{
comment|// Ensure only one eviction at a time
if|if
condition|(
operator|!
name|evictionLock
operator|.
name|tryLock
argument_list|()
condition|)
return|return;
try|try
block|{
name|evictionInProgress
operator|=
literal|true
expr_stmt|;
name|long
name|currentSize
init|=
name|this
operator|.
name|size
operator|.
name|get
argument_list|()
decl_stmt|;
name|long
name|bytesToFree
init|=
name|currentSize
operator|-
name|minSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Block cache LRU eviction started; Attempting to free "
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesToFree
argument_list|)
operator|+
literal|" of total="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|currentSize
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bytesToFree
operator|<=
literal|0
condition|)
return|return;
comment|// Instantiate priority buckets
name|BlockBucket
name|bucketSingle
init|=
operator|new
name|BlockBucket
argument_list|(
name|bytesToFree
argument_list|,
name|blockSize
argument_list|,
name|singleSize
argument_list|()
argument_list|)
decl_stmt|;
name|BlockBucket
name|bucketMulti
init|=
operator|new
name|BlockBucket
argument_list|(
name|bytesToFree
argument_list|,
name|blockSize
argument_list|,
name|multiSize
argument_list|()
argument_list|)
decl_stmt|;
name|BlockBucket
name|bucketMemory
init|=
operator|new
name|BlockBucket
argument_list|(
name|bytesToFree
argument_list|,
name|blockSize
argument_list|,
name|memorySize
argument_list|()
argument_list|)
decl_stmt|;
comment|// Scan entire map putting into appropriate buckets
for|for
control|(
name|CachedBlock
name|cachedBlock
range|:
name|map
operator|.
name|values
argument_list|()
control|)
block|{
switch|switch
condition|(
name|cachedBlock
operator|.
name|getPriority
argument_list|()
condition|)
block|{
case|case
name|SINGLE
case|:
block|{
name|bucketSingle
operator|.
name|add
argument_list|(
name|cachedBlock
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MULTI
case|:
block|{
name|bucketMulti
operator|.
name|add
argument_list|(
name|cachedBlock
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MEMORY
case|:
block|{
name|bucketMemory
operator|.
name|add
argument_list|(
name|cachedBlock
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|PriorityQueue
argument_list|<
name|BlockBucket
argument_list|>
name|bucketQueue
init|=
operator|new
name|PriorityQueue
argument_list|<
name|BlockBucket
argument_list|>
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|bucketQueue
operator|.
name|add
argument_list|(
name|bucketSingle
argument_list|)
expr_stmt|;
name|bucketQueue
operator|.
name|add
argument_list|(
name|bucketMulti
argument_list|)
expr_stmt|;
name|bucketQueue
operator|.
name|add
argument_list|(
name|bucketMemory
argument_list|)
expr_stmt|;
name|int
name|remainingBuckets
init|=
literal|3
decl_stmt|;
name|long
name|bytesFreed
init|=
literal|0
decl_stmt|;
name|BlockBucket
name|bucket
decl_stmt|;
while|while
condition|(
operator|(
name|bucket
operator|=
name|bucketQueue
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|long
name|overflow
init|=
name|bucket
operator|.
name|overflow
argument_list|()
decl_stmt|;
if|if
condition|(
name|overflow
operator|>
literal|0
condition|)
block|{
name|long
name|bucketBytesToFree
init|=
name|Math
operator|.
name|min
argument_list|(
name|overflow
argument_list|,
operator|(
name|bytesToFree
operator|-
name|bytesFreed
operator|)
operator|/
name|remainingBuckets
argument_list|)
decl_stmt|;
name|bytesFreed
operator|+=
name|bucket
operator|.
name|free
argument_list|(
name|bucketBytesToFree
argument_list|)
expr_stmt|;
block|}
name|remainingBuckets
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|long
name|single
init|=
name|bucketSingle
operator|.
name|totalSize
argument_list|()
decl_stmt|;
name|long
name|multi
init|=
name|bucketMulti
operator|.
name|totalSize
argument_list|()
decl_stmt|;
name|long
name|memory
init|=
name|bucketMemory
operator|.
name|totalSize
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Block cache LRU eviction completed; "
operator|+
literal|"freed="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesFreed
argument_list|)
operator|+
literal|", "
operator|+
literal|"total="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|this
operator|.
name|size
operator|.
name|get
argument_list|()
argument_list|)
operator|+
literal|", "
operator|+
literal|"single="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|single
argument_list|)
operator|+
literal|", "
operator|+
literal|"multi="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|multi
argument_list|)
operator|+
literal|", "
operator|+
literal|"memory="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|memory
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|stats
operator|.
name|evict
argument_list|()
expr_stmt|;
name|evictionInProgress
operator|=
literal|false
expr_stmt|;
name|evictionLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Used to group blocks into priority buckets.  There will be a BlockBucket    * for each priority (single, multi, memory).  Once bucketed, the eviction    * algorithm takes the appropriate number of elements out of each according    * to configuration parameters and their relatives sizes.    */
specifier|private
class|class
name|BlockBucket
implements|implements
name|Comparable
argument_list|<
name|BlockBucket
argument_list|>
block|{
specifier|private
name|CachedBlockQueue
name|queue
decl_stmt|;
specifier|private
name|long
name|totalSize
init|=
literal|0
decl_stmt|;
specifier|private
name|long
name|bucketSize
decl_stmt|;
specifier|public
name|BlockBucket
parameter_list|(
name|long
name|bytesToFree
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|long
name|bucketSize
parameter_list|)
block|{
name|this
operator|.
name|bucketSize
operator|=
name|bucketSize
expr_stmt|;
name|queue
operator|=
operator|new
name|CachedBlockQueue
argument_list|(
name|bytesToFree
argument_list|,
name|blockSize
argument_list|)
expr_stmt|;
name|totalSize
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
name|void
name|add
parameter_list|(
name|CachedBlock
name|block
parameter_list|)
block|{
name|totalSize
operator|+=
name|block
operator|.
name|heapSize
argument_list|()
expr_stmt|;
name|queue
operator|.
name|add
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
specifier|public
name|long
name|free
parameter_list|(
name|long
name|toFree
parameter_list|)
block|{
name|LinkedList
argument_list|<
name|CachedBlock
argument_list|>
name|blocks
init|=
name|queue
operator|.
name|get
argument_list|()
decl_stmt|;
name|long
name|freedBytes
init|=
literal|0
decl_stmt|;
for|for
control|(
name|CachedBlock
name|cb
range|:
name|blocks
control|)
block|{
name|freedBytes
operator|+=
name|evictBlock
argument_list|(
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|freedBytes
operator|>=
name|toFree
condition|)
block|{
return|return
name|freedBytes
return|;
block|}
block|}
return|return
name|freedBytes
return|;
block|}
specifier|public
name|long
name|overflow
parameter_list|()
block|{
return|return
name|totalSize
operator|-
name|bucketSize
return|;
block|}
specifier|public
name|long
name|totalSize
parameter_list|()
block|{
return|return
name|totalSize
return|;
block|}
specifier|public
name|int
name|compareTo
parameter_list|(
name|BlockBucket
name|that
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|overflow
argument_list|()
operator|==
name|that
operator|.
name|overflow
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|this
operator|.
name|overflow
argument_list|()
operator|>
name|that
operator|.
name|overflow
argument_list|()
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
block|}
comment|/**    * Get the maximum size of this cache.    * @return max size in bytes    */
specifier|public
name|long
name|getMaxSize
parameter_list|()
block|{
return|return
name|this
operator|.
name|maxSize
return|;
block|}
comment|/**    * Get the current size of this cache.    * @return current size in bytes    */
specifier|public
name|long
name|getCurrentSize
parameter_list|()
block|{
return|return
name|this
operator|.
name|size
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * Get the current size of this cache.    * @return current size in bytes    */
specifier|public
name|long
name|getFreeSize
parameter_list|()
block|{
return|return
name|getMaxSize
argument_list|()
operator|-
name|getCurrentSize
argument_list|()
return|;
block|}
comment|/**    * Get the size of this cache (number of cached blocks)    * @return number of cached blocks    */
specifier|public
name|long
name|size
parameter_list|()
block|{
return|return
name|this
operator|.
name|elements
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * Get the number of eviction runs that have occurred    */
specifier|public
name|long
name|getEvictionCount
parameter_list|()
block|{
return|return
name|this
operator|.
name|stats
operator|.
name|getEvictionCount
argument_list|()
return|;
block|}
comment|/**    * Get the number of blocks that have been evicted during the lifetime    * of this cache.    */
specifier|public
name|long
name|getEvictedCount
parameter_list|()
block|{
return|return
name|this
operator|.
name|stats
operator|.
name|getEvictedCount
argument_list|()
return|;
block|}
comment|/*    * Eviction thread.  Sits in waiting state until an eviction is triggered    * when the cache size grows above the acceptable level.<p>    *    * Thread is triggered into action by {@link LruBlockCache#runEviction()}    */
specifier|private
specifier|static
class|class
name|EvictionThread
extends|extends
name|Thread
block|{
specifier|private
name|WeakReference
argument_list|<
name|LruBlockCache
argument_list|>
name|cache
decl_stmt|;
specifier|public
name|EvictionThread
parameter_list|(
name|LruBlockCache
name|cache
parameter_list|)
block|{
name|super
argument_list|(
literal|"LruBlockCache.EvictionThread"
argument_list|)
expr_stmt|;
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|cache
operator|=
operator|new
name|WeakReference
argument_list|<
name|LruBlockCache
argument_list|>
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
try|try
block|{
name|this
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{}
block|}
name|LruBlockCache
name|cache
init|=
name|this
operator|.
name|cache
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|cache
operator|==
literal|null
condition|)
break|break;
name|cache
operator|.
name|evict
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|evict
parameter_list|()
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|this
operator|.
name|notify
argument_list|()
expr_stmt|;
comment|// FindBugs NN_NAKED_NOTIFY
block|}
block|}
block|}
comment|/*    * Statistics thread.  Periodically prints the cache statistics to the log.    */
specifier|static
class|class
name|StatisticsThread
extends|extends
name|Thread
block|{
name|LruBlockCache
name|lru
decl_stmt|;
specifier|public
name|StatisticsThread
parameter_list|(
name|LruBlockCache
name|lru
parameter_list|)
block|{
name|super
argument_list|(
literal|"LruBlockCache.StatisticsThread"
argument_list|)
expr_stmt|;
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|lru
operator|=
name|lru
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|lru
operator|.
name|logStats
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|logStats
parameter_list|()
block|{
if|if
condition|(
operator|!
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
return|return;
comment|// Log size
name|long
name|totalSize
init|=
name|heapSize
argument_list|()
decl_stmt|;
name|long
name|freeSize
init|=
name|maxSize
operator|-
name|totalSize
decl_stmt|;
name|LruBlockCache
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"LRU Stats: "
operator|+
literal|"total="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|totalSize
argument_list|)
operator|+
literal|", "
operator|+
literal|"free="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|freeSize
argument_list|)
operator|+
literal|", "
operator|+
literal|"max="
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|this
operator|.
name|maxSize
argument_list|)
operator|+
literal|", "
operator|+
literal|"blocks="
operator|+
name|size
argument_list|()
operator|+
literal|", "
operator|+
literal|"accesses="
operator|+
name|stats
operator|.
name|getRequestCount
argument_list|()
operator|+
literal|", "
operator|+
literal|"hits="
operator|+
name|stats
operator|.
name|getHitCount
argument_list|()
operator|+
literal|", "
operator|+
literal|"hitRatio="
operator|+
name|StringUtils
operator|.
name|formatPercent
argument_list|(
name|stats
operator|.
name|getHitRatio
argument_list|()
argument_list|,
literal|2
argument_list|)
operator|+
literal|"%, "
operator|+
literal|"cachingAccesses="
operator|+
name|stats
operator|.
name|getRequestCachingCount
argument_list|()
operator|+
literal|", "
operator|+
literal|"cachingHits="
operator|+
name|stats
operator|.
name|getHitCachingCount
argument_list|()
operator|+
literal|", "
operator|+
literal|"cachingHitsRatio="
operator|+
name|StringUtils
operator|.
name|formatPercent
argument_list|(
name|stats
operator|.
name|getHitCachingRatio
argument_list|()
argument_list|,
literal|2
argument_list|)
operator|+
literal|"%, "
operator|+
literal|"evictions="
operator|+
name|stats
operator|.
name|getEvictionCount
argument_list|()
operator|+
literal|", "
operator|+
literal|"evicted="
operator|+
name|stats
operator|.
name|getEvictedCount
argument_list|()
operator|+
literal|", "
operator|+
literal|"evictedPerRun="
operator|+
name|stats
operator|.
name|evictedPerEviction
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get counter statistics for this cache.    *    *<p>Includes: total accesses, hits, misses, evicted blocks, and runs    * of the eviction processes.    */
specifier|public
name|CacheStats
name|getStats
parameter_list|()
block|{
return|return
name|this
operator|.
name|stats
return|;
block|}
specifier|public
specifier|static
class|class
name|CacheStats
block|{
comment|/** The number of getBlock requests that were cache hits */
specifier|private
specifier|final
name|AtomicLong
name|hitCount
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/**      * The number of getBlock requests that were cache hits, but only from      * requests that were set to use the block cache.  This is because all reads      * attempt to read from the block cache even if they will not put new blocks      * into the block cache.  See HBASE-2253 for more information.      */
specifier|private
specifier|final
name|AtomicLong
name|hitCachingCount
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/** The number of getBlock requests that were cache misses */
specifier|private
specifier|final
name|AtomicLong
name|missCount
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/**      * The number of getBlock requests that were cache misses, but only from      * requests that were set to use the block cache.      */
specifier|private
specifier|final
name|AtomicLong
name|missCachingCount
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/** The number of times an eviction has occurred */
specifier|private
specifier|final
name|AtomicLong
name|evictionCount
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/** The total number of blocks that have been evicted */
specifier|private
specifier|final
name|AtomicLong
name|evictedCount
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|public
name|void
name|miss
parameter_list|(
name|boolean
name|caching
parameter_list|)
block|{
name|missCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
if|if
condition|(
name|caching
condition|)
name|missCachingCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|hit
parameter_list|(
name|boolean
name|caching
parameter_list|)
block|{
name|hitCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
if|if
condition|(
name|caching
condition|)
name|hitCachingCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|evict
parameter_list|()
block|{
name|evictionCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|evicted
parameter_list|()
block|{
name|evictedCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
specifier|public
name|long
name|getRequestCount
parameter_list|()
block|{
return|return
name|getHitCount
argument_list|()
operator|+
name|getMissCount
argument_list|()
return|;
block|}
specifier|public
name|long
name|getRequestCachingCount
parameter_list|()
block|{
return|return
name|getHitCachingCount
argument_list|()
operator|+
name|getMissCachingCount
argument_list|()
return|;
block|}
specifier|public
name|long
name|getMissCount
parameter_list|()
block|{
return|return
name|missCount
operator|.
name|get
argument_list|()
return|;
block|}
specifier|public
name|long
name|getMissCachingCount
parameter_list|()
block|{
return|return
name|missCachingCount
operator|.
name|get
argument_list|()
return|;
block|}
specifier|public
name|long
name|getHitCount
parameter_list|()
block|{
return|return
name|hitCachingCount
operator|.
name|get
argument_list|()
return|;
block|}
specifier|public
name|long
name|getHitCachingCount
parameter_list|()
block|{
return|return
name|hitCachingCount
operator|.
name|get
argument_list|()
return|;
block|}
specifier|public
name|long
name|getEvictionCount
parameter_list|()
block|{
return|return
name|evictionCount
operator|.
name|get
argument_list|()
return|;
block|}
specifier|public
name|long
name|getEvictedCount
parameter_list|()
block|{
return|return
name|evictedCount
operator|.
name|get
argument_list|()
return|;
block|}
specifier|public
name|double
name|getHitRatio
parameter_list|()
block|{
return|return
operator|(
operator|(
name|float
operator|)
name|getHitCount
argument_list|()
operator|/
operator|(
name|float
operator|)
name|getRequestCount
argument_list|()
operator|)
return|;
block|}
specifier|public
name|double
name|getHitCachingRatio
parameter_list|()
block|{
return|return
operator|(
operator|(
name|float
operator|)
name|getHitCachingCount
argument_list|()
operator|/
operator|(
name|float
operator|)
name|getRequestCachingCount
argument_list|()
operator|)
return|;
block|}
specifier|public
name|double
name|getMissRatio
parameter_list|()
block|{
return|return
operator|(
operator|(
name|float
operator|)
name|getMissCount
argument_list|()
operator|/
operator|(
name|float
operator|)
name|getRequestCount
argument_list|()
operator|)
return|;
block|}
specifier|public
name|double
name|getMissCachingRatio
parameter_list|()
block|{
return|return
operator|(
operator|(
name|float
operator|)
name|getMissCachingCount
argument_list|()
operator|/
operator|(
name|float
operator|)
name|getRequestCachingCount
argument_list|()
operator|)
return|;
block|}
specifier|public
name|double
name|evictedPerEviction
parameter_list|()
block|{
return|return
operator|(
operator|(
name|float
operator|)
name|getEvictedCount
argument_list|()
operator|/
operator|(
name|float
operator|)
name|getEvictionCount
argument_list|()
operator|)
return|;
block|}
block|}
specifier|public
specifier|final
specifier|static
name|long
name|CACHE_FIXED_OVERHEAD
init|=
name|ClassSize
operator|.
name|align
argument_list|(
operator|(
literal|3
operator|*
name|Bytes
operator|.
name|SIZEOF_LONG
operator|)
operator|+
operator|(
literal|8
operator|*
name|ClassSize
operator|.
name|REFERENCE
operator|)
operator|+
operator|(
literal|5
operator|*
name|Bytes
operator|.
name|SIZEOF_FLOAT
operator|)
operator|+
name|Bytes
operator|.
name|SIZEOF_BOOLEAN
operator|+
name|ClassSize
operator|.
name|OBJECT
argument_list|)
decl_stmt|;
comment|// HeapSize implementation
specifier|public
name|long
name|heapSize
parameter_list|()
block|{
return|return
name|getCurrentSize
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|long
name|calculateOverhead
parameter_list|(
name|long
name|maxSize
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|int
name|concurrency
parameter_list|)
block|{
comment|// FindBugs ICAST_INTEGER_MULTIPLY_CAST_TO_LONG
return|return
name|CACHE_FIXED_OVERHEAD
operator|+
name|ClassSize
operator|.
name|CONCURRENT_HASHMAP
operator|+
operator|(
operator|(
name|long
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|maxSize
operator|*
literal|1.2
operator|/
name|blockSize
argument_list|)
operator|*
name|ClassSize
operator|.
name|CONCURRENT_HASHMAP_ENTRY
operator|)
operator|+
operator|(
name|concurrency
operator|*
name|ClassSize
operator|.
name|CONCURRENT_HASHMAP_SEGMENT
operator|)
return|;
block|}
comment|// Simple calculators of sizes given factors and maxSize
specifier|private
name|long
name|acceptableSize
parameter_list|()
block|{
return|return
operator|(
name|long
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|this
operator|.
name|maxSize
operator|*
name|this
operator|.
name|acceptableFactor
argument_list|)
return|;
block|}
specifier|private
name|long
name|minSize
parameter_list|()
block|{
return|return
operator|(
name|long
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|this
operator|.
name|maxSize
operator|*
name|this
operator|.
name|minFactor
argument_list|)
return|;
block|}
specifier|private
name|long
name|singleSize
parameter_list|()
block|{
return|return
operator|(
name|long
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|this
operator|.
name|maxSize
operator|*
name|this
operator|.
name|singleFactor
operator|*
name|this
operator|.
name|minFactor
argument_list|)
return|;
block|}
specifier|private
name|long
name|multiSize
parameter_list|()
block|{
return|return
operator|(
name|long
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|this
operator|.
name|maxSize
operator|*
name|this
operator|.
name|multiFactor
operator|*
name|this
operator|.
name|minFactor
argument_list|)
return|;
block|}
specifier|private
name|long
name|memorySize
parameter_list|()
block|{
return|return
operator|(
name|long
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|this
operator|.
name|maxSize
operator|*
name|this
operator|.
name|memoryFactor
operator|*
name|this
operator|.
name|minFactor
argument_list|)
return|;
block|}
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|this
operator|.
name|scheduleThreadPool
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

