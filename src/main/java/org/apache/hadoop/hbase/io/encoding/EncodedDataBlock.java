begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements. See the NOTICE file distributed with this  * work for additional information regarding copyright ownership. The ASF  * licenses this file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the  * License for the specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|encoding
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|NotImplementedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|Compressor
import|;
end_import

begin_comment
comment|/**  * Encapsulates a data block compressed using a particular encoding algorithm.  * Useful for testing and benchmarking.  */
end_comment

begin_class
specifier|public
class|class
name|EncodedDataBlock
block|{
specifier|private
specifier|static
specifier|final
name|int
name|BUFFER_SIZE
init|=
literal|4
operator|*
literal|1024
decl_stmt|;
specifier|protected
name|DataBlockEncoder
name|dataBlockEncoder
decl_stmt|;
name|ByteArrayOutputStream
name|uncompressedOutputStream
decl_stmt|;
name|ByteBuffer
name|uncompressedBuffer
decl_stmt|;
specifier|private
name|byte
index|[]
name|cacheCompressData
decl_stmt|;
specifier|private
name|ByteArrayOutputStream
name|compressedStream
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|includesMemstoreTS
decl_stmt|;
comment|/**    * Create a buffer which will be encoded using dataBlockEncoder.    * @param dataBlockEncoder Algorithm used for compression.    */
specifier|public
name|EncodedDataBlock
parameter_list|(
name|DataBlockEncoder
name|dataBlockEncoder
parameter_list|,
name|boolean
name|includesMemstoreTS
parameter_list|)
block|{
name|this
operator|.
name|dataBlockEncoder
operator|=
name|dataBlockEncoder
expr_stmt|;
name|uncompressedOutputStream
operator|=
operator|new
name|ByteArrayOutputStream
argument_list|(
name|BUFFER_SIZE
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add KeyValue and compress it.    * @param kv Item to be added and compressed.    */
specifier|public
name|void
name|addKv
parameter_list|(
name|KeyValue
name|kv
parameter_list|)
block|{
name|cacheCompressData
operator|=
literal|null
expr_stmt|;
name|uncompressedOutputStream
operator|.
name|write
argument_list|(
name|kv
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|kv
operator|.
name|getOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Provides access to compressed value.    * @return Forwards sequential iterator.    */
specifier|public
name|Iterator
argument_list|<
name|KeyValue
argument_list|>
name|getIterator
parameter_list|()
block|{
specifier|final
name|int
name|uncompressedSize
init|=
name|uncompressedOutputStream
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|ByteArrayInputStream
name|bais
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|getCompressedData
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|DataInputStream
name|dis
init|=
operator|new
name|DataInputStream
argument_list|(
name|bais
argument_list|)
decl_stmt|;
return|return
operator|new
name|Iterator
argument_list|<
name|KeyValue
argument_list|>
argument_list|()
block|{
specifier|private
name|ByteBuffer
name|decompressedData
init|=
literal|null
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
if|if
condition|(
name|decompressedData
operator|==
literal|null
condition|)
block|{
return|return
name|uncompressedSize
operator|>
literal|0
return|;
block|}
return|return
name|decompressedData
operator|.
name|hasRemaining
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|KeyValue
name|next
parameter_list|()
block|{
if|if
condition|(
name|decompressedData
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|decompressedData
operator|=
name|dataBlockEncoder
operator|.
name|uncompressKeyValues
argument_list|(
name|dis
argument_list|,
name|includesMemstoreTS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Problem with data block encoder, "
operator|+
literal|"most likely it requested more bytes than are available."
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|decompressedData
operator|.
name|rewind
argument_list|()
expr_stmt|;
block|}
name|int
name|offset
init|=
name|decompressedData
operator|.
name|position
argument_list|()
decl_stmt|;
name|KeyValue
name|kv
init|=
operator|new
name|KeyValue
argument_list|(
name|decompressedData
operator|.
name|array
argument_list|()
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|decompressedData
operator|.
name|position
argument_list|(
name|offset
operator|+
name|kv
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|kv
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|NotImplementedException
argument_list|(
literal|"remove() is not supported!"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Iterator of: "
operator|+
name|dataBlockEncoder
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|/**    * Find the size of minimal buffer that could store compressed data.    * @return Size in bytes of compressed data.    */
specifier|public
name|int
name|getSize
parameter_list|()
block|{
return|return
name|getCompressedData
argument_list|()
operator|.
name|length
return|;
block|}
comment|/**    * Find the size of compressed data assuming that buffer will be compressed    * using given algorithm.    * @param compressor Algorithm used for compression.    * @param buffer Array to be compressed.    * @param offset Offset to beginning of the data.    * @param length Length to be compressed.    * @return Size of compressed data in bytes.    */
specifier|public
specifier|static
name|int
name|checkCompressedSize
parameter_list|(
name|Compressor
name|compressor
parameter_list|,
name|byte
index|[]
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|byte
index|[]
name|compressedBuffer
init|=
operator|new
name|byte
index|[
name|buffer
operator|.
name|length
index|]
decl_stmt|;
comment|// in fact the buffer could be of any positive size
name|compressor
operator|.
name|setInput
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|compressor
operator|.
name|finish
argument_list|()
expr_stmt|;
name|int
name|currentPos
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|compressor
operator|.
name|finished
argument_list|()
condition|)
block|{
try|try
block|{
comment|// we don't care about compressed data,
comment|// we just want to callculate number of bytes
name|currentPos
operator|+=
name|compressor
operator|.
name|compress
argument_list|(
name|compressedBuffer
argument_list|,
literal|0
argument_list|,
name|compressedBuffer
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"For some reason compressor couldn't read data. "
operator|+
literal|"It is likely a problem with "
operator|+
name|compressor
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|currentPos
return|;
block|}
comment|/**    * Estimate size after second stage of compression (e.g. LZO).    * @param compressor Algorithm which will be used for compressions.    * @return Size after second stage of compression.    */
specifier|public
name|int
name|checkCompressedSize
parameter_list|(
name|Compressor
name|compressor
parameter_list|)
block|{
comment|// compress
name|byte
index|[]
name|compressedBytes
init|=
name|getCompressedData
argument_list|()
decl_stmt|;
return|return
name|checkCompressedSize
argument_list|(
name|compressor
argument_list|,
name|compressedBytes
argument_list|,
literal|0
argument_list|,
name|compressedBytes
operator|.
name|length
argument_list|)
return|;
block|}
specifier|private
name|byte
index|[]
name|getCompressedData
parameter_list|()
block|{
comment|// is cached
if|if
condition|(
name|cacheCompressData
operator|!=
literal|null
condition|)
block|{
return|return
name|cacheCompressData
return|;
block|}
name|cacheCompressData
operator|=
name|doCompressData
argument_list|()
expr_stmt|;
return|return
name|cacheCompressData
return|;
block|}
specifier|private
name|ByteBuffer
name|getUncompressedBuffer
parameter_list|()
block|{
if|if
condition|(
name|uncompressedBuffer
operator|==
literal|null
operator|||
name|uncompressedBuffer
operator|.
name|limit
argument_list|()
operator|<
name|uncompressedOutputStream
operator|.
name|size
argument_list|()
condition|)
block|{
name|uncompressedBuffer
operator|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|uncompressedOutputStream
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|uncompressedBuffer
return|;
block|}
comment|/**    * Do the compression.    * @return Compressed byte buffer.    */
specifier|public
name|byte
index|[]
name|doCompressData
parameter_list|()
block|{
name|compressedStream
operator|.
name|reset
argument_list|()
expr_stmt|;
name|DataOutputStream
name|dataOut
init|=
operator|new
name|DataOutputStream
argument_list|(
name|compressedStream
argument_list|)
decl_stmt|;
try|try
block|{
name|this
operator|.
name|dataBlockEncoder
operator|.
name|compressKeyValues
argument_list|(
name|dataOut
argument_list|,
name|getUncompressedBuffer
argument_list|()
argument_list|,
name|includesMemstoreTS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Bug in decoding part of algorithm %s. "
operator|+
literal|"Probably it requested more bytes than are available."
argument_list|,
name|toString
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|compressedStream
operator|.
name|toByteArray
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|dataBlockEncoder
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Get uncompressed buffer.    * @return The buffer.    */
specifier|public
name|byte
index|[]
name|getRawKeyValues
parameter_list|()
block|{
return|return
name|uncompressedOutputStream
operator|.
name|toByteArray
argument_list|()
return|;
block|}
block|}
end_class

end_unit

