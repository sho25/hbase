begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2011 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|HFile
operator|.
name|FileInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|HFile
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|HFile
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|RawComparator
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_comment
comment|/**  * {@link HFile} reader for version 1.  */
end_comment

begin_class
specifier|public
class|class
name|HFileReaderV1
extends|extends
name|AbstractHFileReader
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HFileReaderV1
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|fileInfoLoaded
init|=
literal|false
decl_stmt|;
comment|/**    * Opens a HFile.  You must load the index before you can    * use it by calling {@link #loadFileInfo()}.    *    * @param fsdis input stream.  Caller is responsible for closing the passed    * stream.    * @param size Length of the stream.    * @param blockCache block cache. Pass null if none.    * @param inMemory whether blocks should be marked as in-memory in cache    * @param evictOnClose whether blocks in cache should be evicted on close    * @throws IOException    */
specifier|public
name|HFileReaderV1
parameter_list|(
name|Path
name|path
parameter_list|,
name|FixedFileTrailer
name|trailer
parameter_list|,
specifier|final
name|FSDataInputStream
name|fsdis
parameter_list|,
specifier|final
name|long
name|size
parameter_list|,
specifier|final
name|boolean
name|closeIStream
parameter_list|,
specifier|final
name|BlockCache
name|blockCache
parameter_list|,
specifier|final
name|boolean
name|inMemory
parameter_list|,
specifier|final
name|boolean
name|evictOnClose
parameter_list|)
block|{
name|super
argument_list|(
name|path
argument_list|,
name|trailer
argument_list|,
name|fsdis
argument_list|,
name|size
argument_list|,
name|closeIStream
argument_list|,
name|blockCache
argument_list|,
name|inMemory
argument_list|,
name|evictOnClose
argument_list|)
expr_stmt|;
name|trailer
operator|.
name|expectVersion
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fsBlockReader
operator|=
operator|new
name|HFileBlock
operator|.
name|FSReaderV1
argument_list|(
name|fsdis
argument_list|,
name|compressAlgo
argument_list|,
name|fileSize
argument_list|)
expr_stmt|;
block|}
specifier|private
name|byte
index|[]
name|readAllIndex
parameter_list|(
specifier|final
name|FSDataInputStream
name|in
parameter_list|,
specifier|final
name|long
name|indexOffset
parameter_list|,
specifier|final
name|int
name|indexSize
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|allIndex
init|=
operator|new
name|byte
index|[
name|indexSize
index|]
decl_stmt|;
name|in
operator|.
name|seek
argument_list|(
name|indexOffset
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|readFully
argument_list|(
name|in
argument_list|,
name|allIndex
argument_list|,
literal|0
argument_list|,
name|allIndex
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|allIndex
return|;
block|}
comment|/**    * Read in the index and file info.    *    * @return A map of fileinfo data.    * @see {@link Writer#appendFileInfo(byte[], byte[])}.    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|FileInfo
name|loadFileInfo
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|fileInfoLoaded
condition|)
return|return
name|fileInfo
return|;
comment|// Read in the fileinfo and get what we need from it.
name|istream
operator|.
name|seek
argument_list|(
name|trailer
operator|.
name|getFileInfoOffset
argument_list|()
argument_list|)
expr_stmt|;
name|fileInfo
operator|=
operator|new
name|FileInfo
argument_list|()
expr_stmt|;
name|fileInfo
operator|.
name|readFields
argument_list|(
name|istream
argument_list|)
expr_stmt|;
name|lastKey
operator|=
name|fileInfo
operator|.
name|get
argument_list|(
name|FileInfo
operator|.
name|LASTKEY
argument_list|)
expr_stmt|;
name|avgKeyLen
operator|=
name|Bytes
operator|.
name|toInt
argument_list|(
name|fileInfo
operator|.
name|get
argument_list|(
name|FileInfo
operator|.
name|AVG_KEY_LEN
argument_list|)
argument_list|)
expr_stmt|;
name|avgValueLen
operator|=
name|Bytes
operator|.
name|toInt
argument_list|(
name|fileInfo
operator|.
name|get
argument_list|(
name|FileInfo
operator|.
name|AVG_VALUE_LEN
argument_list|)
argument_list|)
expr_stmt|;
comment|// Comparator is stored in the file info in version 1.
name|String
name|clazzName
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|fileInfo
operator|.
name|get
argument_list|(
name|FileInfo
operator|.
name|COMPARATOR
argument_list|)
argument_list|)
decl_stmt|;
name|comparator
operator|=
name|getComparator
argument_list|(
name|clazzName
argument_list|)
expr_stmt|;
name|dataBlockIndexReader
operator|=
operator|new
name|HFileBlockIndex
operator|.
name|BlockIndexReader
argument_list|(
name|comparator
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|metaBlockIndexReader
operator|=
operator|new
name|HFileBlockIndex
operator|.
name|BlockIndexReader
argument_list|(
name|Bytes
operator|.
name|BYTES_RAWCOMPARATOR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|int
name|sizeToLoadOnOpen
init|=
call|(
name|int
call|)
argument_list|(
name|fileSize
operator|-
name|trailer
operator|.
name|getLoadOnOpenDataOffset
argument_list|()
operator|-
name|trailer
operator|.
name|getTrailerSize
argument_list|()
argument_list|)
decl_stmt|;
name|byte
index|[]
name|dataAndMetaIndex
init|=
name|readAllIndex
argument_list|(
name|istream
argument_list|,
name|trailer
operator|.
name|getLoadOnOpenDataOffset
argument_list|()
argument_list|,
name|sizeToLoadOnOpen
argument_list|)
decl_stmt|;
name|ByteArrayInputStream
name|bis
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|dataAndMetaIndex
argument_list|)
decl_stmt|;
name|DataInputStream
name|dis
init|=
operator|new
name|DataInputStream
argument_list|(
name|bis
argument_list|)
decl_stmt|;
comment|// Read in the data index.
if|if
condition|(
name|trailer
operator|.
name|getDataIndexCount
argument_list|()
operator|>
literal|0
condition|)
name|BlockType
operator|.
name|INDEX_V1
operator|.
name|readAndCheck
argument_list|(
name|dis
argument_list|)
expr_stmt|;
name|dataBlockIndexReader
operator|.
name|readRootIndex
argument_list|(
name|dis
argument_list|,
name|trailer
operator|.
name|getDataIndexCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// Read in the metadata index.
if|if
condition|(
name|trailer
operator|.
name|getMetaIndexCount
argument_list|()
operator|>
literal|0
condition|)
name|BlockType
operator|.
name|INDEX_V1
operator|.
name|readAndCheck
argument_list|(
name|dis
argument_list|)
expr_stmt|;
name|metaBlockIndexReader
operator|.
name|readRootIndex
argument_list|(
name|dis
argument_list|,
name|trailer
operator|.
name|getMetaIndexCount
argument_list|()
argument_list|)
expr_stmt|;
name|fileInfoLoaded
operator|=
literal|true
expr_stmt|;
return|return
name|fileInfo
return|;
block|}
comment|/**    * Creates comparator from the given class name.    *    * @param clazzName the comparator class name read from the trailer    * @return an instance of the comparator to use    * @throws IOException in case comparator class name is invalid    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
name|RawComparator
argument_list|<
name|byte
index|[]
argument_list|>
name|getComparator
parameter_list|(
specifier|final
name|String
name|clazzName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|clazzName
operator|==
literal|null
operator|||
name|clazzName
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
try|try
block|{
return|return
operator|(
name|RawComparator
argument_list|<
name|byte
index|[]
argument_list|>
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|clazzName
argument_list|)
operator|.
name|newInstance
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|InstantiationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Create a Scanner on this file. No seeks or reads are done on creation. Call    * {@link HFileScanner#seekTo(byte[])} to position an start the read. There is    * nothing to clean up in a Scanner. Letting go of your references to the    * scanner is sufficient.    *    * @param cacheBlocks True if we should cache blocks read in by this scanner.    * @param pread Use positional read rather than seek+read if true (pread is    *          better for random reads, seek+read is better scanning).    * @param isCompaction is scanner being used for a compaction?    * @return Scanner on this file.    */
annotation|@
name|Override
specifier|public
name|HFileScanner
name|getScanner
parameter_list|(
name|boolean
name|cacheBlocks
parameter_list|,
specifier|final
name|boolean
name|pread
parameter_list|,
specifier|final
name|boolean
name|isCompaction
parameter_list|)
block|{
return|return
operator|new
name|ScannerV1
argument_list|(
name|this
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|)
return|;
block|}
comment|/**    * @param key Key to search.    * @return Block number of the block containing the key or -1 if not in this    * file.    */
specifier|protected
name|int
name|blockContainingKey
parameter_list|(
specifier|final
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|dataBlockIndexReader
operator|.
name|isEmpty
argument_list|()
argument_list|,
literal|"Block index not loaded"
argument_list|)
expr_stmt|;
return|return
name|dataBlockIndexReader
operator|.
name|rootBlockContainingKey
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
comment|/**    * @param metaBlockName    * @param cacheBlock Add block to cache, if found    * @return Block wrapped in a ByteBuffer    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|ByteBuffer
name|getMetaBlock
parameter_list|(
name|String
name|metaBlockName
parameter_list|,
name|boolean
name|cacheBlock
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|trailer
operator|.
name|getMetaIndexCount
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
comment|// there are no meta blocks
block|}
if|if
condition|(
name|metaBlockIndexReader
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Meta index not loaded"
argument_list|)
throw|;
block|}
name|byte
index|[]
name|nameBytes
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|metaBlockName
argument_list|)
decl_stmt|;
name|int
name|block
init|=
name|metaBlockIndexReader
operator|.
name|rootBlockContainingKey
argument_list|(
name|nameBytes
argument_list|,
literal|0
argument_list|,
name|nameBytes
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|block
operator|==
operator|-
literal|1
condition|)
return|return
literal|null
return|;
name|long
name|offset
init|=
name|metaBlockIndexReader
operator|.
name|getRootBlockOffset
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|long
name|nextOffset
decl_stmt|;
if|if
condition|(
name|block
operator|==
name|metaBlockIndexReader
operator|.
name|getRootBlockCount
argument_list|()
operator|-
literal|1
condition|)
block|{
name|nextOffset
operator|=
name|trailer
operator|.
name|getFileInfoOffset
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|nextOffset
operator|=
name|metaBlockIndexReader
operator|.
name|getRootBlockOffset
argument_list|(
name|block
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|long
name|startTimeNs
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|String
name|cacheKey
init|=
name|HFile
operator|.
name|getBlockCacheKey
argument_list|(
name|name
argument_list|,
name|offset
argument_list|)
decl_stmt|;
comment|// Per meta key from any given file, synchronize reads for said block
synchronized|synchronized
init|(
name|metaBlockIndexReader
operator|.
name|getRootBlockKey
argument_list|(
name|block
argument_list|)
init|)
block|{
name|metaLoads
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
comment|// Check cache for block.  If found return.
if|if
condition|(
name|blockCache
operator|!=
literal|null
condition|)
block|{
name|HFileBlock
name|cachedBlock
init|=
operator|(
name|HFileBlock
operator|)
name|blockCache
operator|.
name|getBlock
argument_list|(
name|cacheKey
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|cachedBlock
operator|!=
literal|null
condition|)
block|{
name|cacheHits
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return
name|cachedBlock
operator|.
name|getBufferWithoutHeader
argument_list|()
return|;
block|}
comment|// Cache Miss, please load.
block|}
name|HFileBlock
name|hfileBlock
init|=
name|fsBlockReader
operator|.
name|readBlockData
argument_list|(
name|offset
argument_list|,
name|nextOffset
operator|-
name|offset
argument_list|,
name|metaBlockIndexReader
operator|.
name|getRootBlockDataSize
argument_list|(
name|block
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|hfileBlock
operator|.
name|expectType
argument_list|(
name|BlockType
operator|.
name|META
argument_list|)
expr_stmt|;
name|HFile
operator|.
name|readTimeNano
operator|.
name|addAndGet
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTimeNs
argument_list|)
expr_stmt|;
name|HFile
operator|.
name|readOps
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
comment|// Cache the block
if|if
condition|(
name|cacheBlock
operator|&&
name|blockCache
operator|!=
literal|null
condition|)
block|{
name|blockCache
operator|.
name|cacheBlock
argument_list|(
name|cacheKey
argument_list|,
name|hfileBlock
argument_list|,
name|inMemory
argument_list|)
expr_stmt|;
block|}
return|return
name|hfileBlock
operator|.
name|getBufferWithoutHeader
argument_list|()
return|;
block|}
block|}
comment|/**    * Read in a file block.    * @param block Index of block to read.    * @param pread Use positional read instead of seek+read (positional is    * better doing random reads whereas seek+read is better scanning).    * @param isCompaction is this block being read as part of a compaction    * @return Block wrapped in a ByteBuffer.    * @throws IOException    */
name|ByteBuffer
name|readBlockBuffer
parameter_list|(
name|int
name|block
parameter_list|,
name|boolean
name|cacheBlock
parameter_list|,
specifier|final
name|boolean
name|pread
parameter_list|,
specifier|final
name|boolean
name|isCompaction
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|dataBlockIndexReader
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Block index not loaded"
argument_list|)
throw|;
block|}
if|if
condition|(
name|block
operator|<
literal|0
operator|||
name|block
operator|>=
name|dataBlockIndexReader
operator|.
name|getRootBlockCount
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Requested block is out of range: "
operator|+
name|block
operator|+
literal|", max: "
operator|+
name|dataBlockIndexReader
operator|.
name|getRootBlockCount
argument_list|()
argument_list|)
throw|;
block|}
name|long
name|offset
init|=
name|dataBlockIndexReader
operator|.
name|getRootBlockOffset
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|String
name|cacheKey
init|=
name|HFile
operator|.
name|getBlockCacheKey
argument_list|(
name|name
argument_list|,
name|offset
argument_list|)
decl_stmt|;
comment|// For any given block from any given file, synchronize reads for said
comment|// block.
comment|// Without a cache, this synchronizing is needless overhead, but really
comment|// the other choice is to duplicate work (which the cache would prevent you
comment|// from doing).
synchronized|synchronized
init|(
name|dataBlockIndexReader
operator|.
name|getRootBlockKey
argument_list|(
name|block
argument_list|)
init|)
block|{
name|blockLoads
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
comment|// Check cache for block.  If found return.
if|if
condition|(
name|blockCache
operator|!=
literal|null
condition|)
block|{
name|HFileBlock
name|cachedBlock
init|=
operator|(
name|HFileBlock
operator|)
name|blockCache
operator|.
name|getBlock
argument_list|(
name|cacheKey
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|cachedBlock
operator|!=
literal|null
condition|)
block|{
name|cacheHits
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return
name|cachedBlock
operator|.
name|getBufferWithoutHeader
argument_list|()
return|;
block|}
comment|// Carry on, please load.
block|}
comment|// Load block from filesystem.
name|long
name|startTimeNs
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|long
name|nextOffset
decl_stmt|;
if|if
condition|(
name|block
operator|==
name|dataBlockIndexReader
operator|.
name|getRootBlockCount
argument_list|()
operator|-
literal|1
condition|)
block|{
comment|// last block!  The end of data block is first meta block if there is
comment|// one or if there isn't, the fileinfo offset.
name|nextOffset
operator|=
operator|(
name|metaBlockIndexReader
operator|.
name|getRootBlockCount
argument_list|()
operator|==
literal|0
operator|)
condition|?
name|this
operator|.
name|trailer
operator|.
name|getFileInfoOffset
argument_list|()
else|:
name|metaBlockIndexReader
operator|.
name|getRootBlockOffset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nextOffset
operator|=
name|dataBlockIndexReader
operator|.
name|getRootBlockOffset
argument_list|(
name|block
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|HFileBlock
name|hfileBlock
init|=
name|fsBlockReader
operator|.
name|readBlockData
argument_list|(
name|offset
argument_list|,
name|nextOffset
operator|-
name|offset
argument_list|,
name|dataBlockIndexReader
operator|.
name|getRootBlockDataSize
argument_list|(
name|block
argument_list|)
argument_list|,
name|pread
argument_list|)
decl_stmt|;
name|hfileBlock
operator|.
name|expectType
argument_list|(
name|BlockType
operator|.
name|DATA
argument_list|)
expr_stmt|;
name|ByteBuffer
name|buf
init|=
name|hfileBlock
operator|.
name|getBufferWithoutHeader
argument_list|()
decl_stmt|;
name|HFile
operator|.
name|readTimeNano
operator|.
name|addAndGet
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTimeNs
argument_list|)
expr_stmt|;
name|HFile
operator|.
name|readOps
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
comment|// Cache the block
if|if
condition|(
name|cacheBlock
operator|&&
name|blockCache
operator|!=
literal|null
condition|)
block|{
name|blockCache
operator|.
name|cacheBlock
argument_list|(
name|cacheKey
argument_list|,
name|hfileBlock
argument_list|,
name|inMemory
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
block|}
comment|/**    * @return Last key in the file.  May be null if file has no entries.    * Note that this is not the last rowkey, but rather the byte form of    * the last KeyValue.    */
specifier|public
name|byte
index|[]
name|getLastKey
parameter_list|()
block|{
if|if
condition|(
operator|!
name|fileInfoLoaded
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Load file info first"
argument_list|)
throw|;
block|}
return|return
name|dataBlockIndexReader
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|lastKey
return|;
block|}
comment|/**    * @return Midkey for this file. We work with block boundaries only so    *         returned midkey is an approximation only.    *    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|midkey
parameter_list|()
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|isFileInfoLoaded
argument_list|()
argument_list|,
literal|"File info is not loaded"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|dataBlockIndexReader
operator|.
name|isEmpty
argument_list|()
argument_list|,
literal|"Data block index is not loaded or is empty"
argument_list|)
expr_stmt|;
return|return
name|dataBlockIndexReader
operator|.
name|midkey
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|evictOnClose
operator|&&
name|this
operator|.
name|blockCache
operator|!=
literal|null
condition|)
block|{
name|int
name|numEvicted
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dataBlockIndexReader
operator|.
name|getRootBlockCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|blockCache
operator|.
name|evictBlock
argument_list|(
name|HFile
operator|.
name|getBlockCacheKey
argument_list|(
name|name
argument_list|,
name|dataBlockIndexReader
operator|.
name|getRootBlockOffset
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
name|numEvicted
operator|++
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"On close of file "
operator|+
name|name
operator|+
literal|" evicted "
operator|+
name|numEvicted
operator|+
literal|" block(s) of "
operator|+
name|dataBlockIndexReader
operator|.
name|getRootBlockCount
argument_list|()
operator|+
literal|" total blocks"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|closeIStream
operator|&&
name|this
operator|.
name|istream
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|istream
operator|.
name|close
argument_list|()
expr_stmt|;
name|this
operator|.
name|istream
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**    * Implementation of {@link HFileScanner} interface.    */
specifier|protected
specifier|static
class|class
name|ScannerV1
extends|extends
name|AbstractHFileReader
operator|.
name|Scanner
block|{
specifier|private
specifier|final
name|HFileReaderV1
name|readerV1
decl_stmt|;
specifier|private
name|int
name|currBlock
decl_stmt|;
specifier|public
name|ScannerV1
parameter_list|(
name|HFileReaderV1
name|reader
parameter_list|,
name|boolean
name|cacheBlocks
parameter_list|,
specifier|final
name|boolean
name|pread
parameter_list|,
specifier|final
name|boolean
name|isCompaction
parameter_list|)
block|{
name|super
argument_list|(
name|reader
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|)
expr_stmt|;
name|readerV1
operator|=
name|reader
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|KeyValue
name|getKeyValue
parameter_list|()
block|{
if|if
condition|(
name|blockBuffer
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|KeyValue
argument_list|(
name|blockBuffer
operator|.
name|array
argument_list|()
argument_list|,
name|blockBuffer
operator|.
name|arrayOffset
argument_list|()
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
operator|-
literal|8
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|ByteBuffer
name|getKey
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|blockBuffer
operator|!=
literal|null
operator|&&
name|currKeyLen
operator|>
literal|0
argument_list|,
literal|"you need to seekTo() before calling getKey()"
argument_list|)
expr_stmt|;
name|ByteBuffer
name|keyBuff
init|=
name|blockBuffer
operator|.
name|slice
argument_list|()
decl_stmt|;
name|keyBuff
operator|.
name|limit
argument_list|(
name|currKeyLen
argument_list|)
expr_stmt|;
name|keyBuff
operator|.
name|rewind
argument_list|()
expr_stmt|;
comment|// Do keyBuff.asReadOnly()?
return|return
name|keyBuff
return|;
block|}
annotation|@
name|Override
specifier|public
name|ByteBuffer
name|getValue
parameter_list|()
block|{
if|if
condition|(
name|blockBuffer
operator|==
literal|null
operator|||
name|currKeyLen
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"you need to seekTo() before calling getValue()"
argument_list|)
throw|;
block|}
comment|// TODO: Could this be done with one ByteBuffer rather than create two?
name|ByteBuffer
name|valueBuff
init|=
name|blockBuffer
operator|.
name|slice
argument_list|()
decl_stmt|;
name|valueBuff
operator|.
name|position
argument_list|(
name|currKeyLen
argument_list|)
expr_stmt|;
name|valueBuff
operator|=
name|valueBuff
operator|.
name|slice
argument_list|()
expr_stmt|;
name|valueBuff
operator|.
name|limit
argument_list|(
name|currValueLen
argument_list|)
expr_stmt|;
name|valueBuff
operator|.
name|rewind
argument_list|()
expr_stmt|;
return|return
name|valueBuff
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|blockBuffer
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Next called on non-seeked scanner"
argument_list|)
throw|;
block|}
try|try
block|{
name|blockBuffer
operator|.
name|position
argument_list|(
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
name|currKeyLen
operator|+
name|currValueLen
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Current pos = "
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
literal|"; currKeyLen = "
operator|+
name|currKeyLen
operator|+
literal|"; currValLen = "
operator|+
name|currValueLen
operator|+
literal|"; block limit = "
operator|+
name|blockBuffer
operator|.
name|limit
argument_list|()
operator|+
literal|"; HFile name = "
operator|+
name|reader
operator|.
name|getName
argument_list|()
operator|+
literal|"; currBlock id = "
operator|+
name|currBlock
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
if|if
condition|(
name|blockBuffer
operator|.
name|remaining
argument_list|()
operator|<=
literal|0
condition|)
block|{
comment|// LOG.debug("Fetch next block");
name|currBlock
operator|++
expr_stmt|;
if|if
condition|(
name|currBlock
operator|>=
name|reader
operator|.
name|getDataBlockIndexReader
argument_list|()
operator|.
name|getRootBlockCount
argument_list|()
condition|)
block|{
comment|// damn we are at the end
name|currBlock
operator|=
literal|0
expr_stmt|;
name|blockBuffer
operator|=
literal|null
expr_stmt|;
return|return
literal|false
return|;
block|}
name|blockBuffer
operator|=
name|readerV1
operator|.
name|readBlockBuffer
argument_list|(
name|currBlock
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|)
expr_stmt|;
name|currKeyLen
operator|=
name|blockBuffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|currValueLen
operator|=
name|blockBuffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|blockFetches
operator|++
expr_stmt|;
return|return
literal|true
return|;
block|}
name|currKeyLen
operator|=
name|blockBuffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|currValueLen
operator|=
name|blockBuffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|seekTo
parameter_list|(
name|byte
index|[]
name|key
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|seekTo
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|length
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|seekTo
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|b
init|=
name|readerV1
operator|.
name|blockContainingKey
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|// falls before the beginning of the file! :-(
comment|// Avoid re-reading the same block (that'd be dumb).
name|loadBlock
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|blockSeek
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|reseekTo
parameter_list|(
name|byte
index|[]
name|key
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|reseekTo
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|length
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|reseekTo
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|blockBuffer
operator|!=
literal|null
operator|&&
name|currKeyLen
operator|!=
literal|0
condition|)
block|{
name|ByteBuffer
name|bb
init|=
name|getKey
argument_list|()
decl_stmt|;
name|int
name|compared
init|=
name|reader
operator|.
name|getComparator
argument_list|()
operator|.
name|compare
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|bb
operator|.
name|array
argument_list|()
argument_list|,
name|bb
operator|.
name|arrayOffset
argument_list|()
argument_list|,
name|bb
operator|.
name|limit
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|compared
operator|<=
literal|0
condition|)
block|{
comment|// If the required key is less than or equal to current key, then
comment|// don't do anything.
return|return
name|compared
return|;
block|}
block|}
name|int
name|b
init|=
name|readerV1
operator|.
name|blockContainingKey
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|loadBlock
argument_list|(
name|b
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|blockSeek
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Within a loaded block, seek looking for the first key      * that is smaller than (or equal to?) the key we are interested in.      *      * A note on the seekBefore - if you have seekBefore = true, AND the      * first key in the block = key, then you'll get thrown exceptions.      * @param key to find      * @param seekBefore find the key before the exact match.      * @return      */
specifier|private
name|int
name|blockSeek
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|seekBefore
parameter_list|)
block|{
name|int
name|klen
decl_stmt|,
name|vlen
decl_stmt|;
name|int
name|lastLen
init|=
literal|0
decl_stmt|;
do|do
block|{
name|klen
operator|=
name|blockBuffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|vlen
operator|=
name|blockBuffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|int
name|comp
init|=
name|reader
operator|.
name|getComparator
argument_list|()
operator|.
name|compare
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|blockBuffer
operator|.
name|array
argument_list|()
argument_list|,
name|blockBuffer
operator|.
name|arrayOffset
argument_list|()
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
argument_list|,
name|klen
argument_list|)
decl_stmt|;
if|if
condition|(
name|comp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|seekBefore
condition|)
block|{
name|blockBuffer
operator|.
name|position
argument_list|(
name|blockBuffer
operator|.
name|position
argument_list|()
operator|-
name|lastLen
operator|-
literal|16
argument_list|)
expr_stmt|;
name|currKeyLen
operator|=
name|blockBuffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|currValueLen
operator|=
name|blockBuffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
comment|// non exact match.
block|}
name|currKeyLen
operator|=
name|klen
expr_stmt|;
name|currValueLen
operator|=
name|vlen
expr_stmt|;
return|return
literal|0
return|;
comment|// indicate exact match
block|}
if|if
condition|(
name|comp
operator|<
literal|0
condition|)
block|{
comment|// go back one key:
name|blockBuffer
operator|.
name|position
argument_list|(
name|blockBuffer
operator|.
name|position
argument_list|()
operator|-
name|lastLen
operator|-
literal|16
argument_list|)
expr_stmt|;
name|currKeyLen
operator|=
name|blockBuffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|currValueLen
operator|=
name|blockBuffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
name|blockBuffer
operator|.
name|position
argument_list|(
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
name|klen
operator|+
name|vlen
argument_list|)
expr_stmt|;
name|lastLen
operator|=
name|klen
operator|+
name|vlen
expr_stmt|;
block|}
do|while
condition|(
name|blockBuffer
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
do|;
comment|// ok we are at the end, so go back a littleeeeee....
comment|// The 8 in the below is intentionally different to the 16s in the above
comment|// Do the math you you'll figure it.
name|blockBuffer
operator|.
name|position
argument_list|(
name|blockBuffer
operator|.
name|position
argument_list|()
operator|-
name|lastLen
operator|-
literal|8
argument_list|)
expr_stmt|;
name|currKeyLen
operator|=
name|blockBuffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|currValueLen
operator|=
name|blockBuffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
comment|// didn't exactly find it.
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|seekBefore
parameter_list|(
name|byte
index|[]
name|key
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|seekBefore
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|length
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|seekBefore
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|b
init|=
name|readerV1
operator|.
name|blockContainingKey
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|<
literal|0
condition|)
return|return
literal|false
return|;
comment|// key is before the start of the file.
comment|// Question: does this block begin with 'key'?
name|byte
index|[]
name|firstkKey
init|=
name|reader
operator|.
name|getDataBlockIndexReader
argument_list|()
operator|.
name|getRootBlockKey
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|reader
operator|.
name|getComparator
argument_list|()
operator|.
name|compare
argument_list|(
name|firstkKey
argument_list|,
literal|0
argument_list|,
name|firstkKey
operator|.
name|length
argument_list|,
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// Ok the key we're interested in is the first of the block, so go back
comment|// by one.
if|if
condition|(
name|b
operator|==
literal|0
condition|)
block|{
comment|// we have a 'problem', the key we want is the first of the file.
return|return
literal|false
return|;
block|}
name|b
operator|--
expr_stmt|;
comment|// TODO shortcut: seek forward in this block to the last key of the
comment|// block.
block|}
name|loadBlock
argument_list|(
name|b
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|blockSeek
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getKeyString
parameter_list|()
block|{
return|return
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|blockBuffer
operator|.
name|array
argument_list|()
argument_list|,
name|blockBuffer
operator|.
name|arrayOffset
argument_list|()
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
argument_list|,
name|currKeyLen
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getValueString
parameter_list|()
block|{
return|return
name|Bytes
operator|.
name|toString
argument_list|(
name|blockBuffer
operator|.
name|array
argument_list|()
argument_list|,
name|blockBuffer
operator|.
name|arrayOffset
argument_list|()
operator|+
name|blockBuffer
operator|.
name|position
argument_list|()
operator|+
name|currKeyLen
argument_list|,
name|currValueLen
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Reader
name|getReader
parameter_list|()
block|{
return|return
name|reader
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|seekTo
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|reader
operator|.
name|getDataBlockIndexReader
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|blockBuffer
operator|!=
literal|null
operator|&&
name|currBlock
operator|==
literal|0
condition|)
block|{
name|blockBuffer
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|currKeyLen
operator|=
name|blockBuffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|currValueLen
operator|=
name|blockBuffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
name|currBlock
operator|=
literal|0
expr_stmt|;
name|blockBuffer
operator|=
name|readerV1
operator|.
name|readBlockBuffer
argument_list|(
name|currBlock
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|)
expr_stmt|;
name|currKeyLen
operator|=
name|blockBuffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|currValueLen
operator|=
name|blockBuffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
name|blockFetches
operator|++
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|loadBlock
parameter_list|(
name|int
name|bloc
parameter_list|,
name|boolean
name|rewind
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|blockBuffer
operator|==
literal|null
condition|)
block|{
name|blockBuffer
operator|=
name|readerV1
operator|.
name|readBlockBuffer
argument_list|(
name|bloc
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|)
expr_stmt|;
name|currBlock
operator|=
name|bloc
expr_stmt|;
name|blockFetches
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bloc
operator|!=
name|currBlock
condition|)
block|{
name|blockBuffer
operator|=
name|readerV1
operator|.
name|readBlockBuffer
argument_list|(
name|bloc
argument_list|,
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|)
expr_stmt|;
name|currBlock
operator|=
name|bloc
expr_stmt|;
name|blockFetches
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|// we are already in the same block, just rewind to seek again.
if|if
condition|(
name|rewind
condition|)
block|{
name|blockBuffer
operator|.
name|rewind
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Go back by (size of rowlength + size of valuelength) = 8 bytes
name|blockBuffer
operator|.
name|position
argument_list|(
name|blockBuffer
operator|.
name|position
argument_list|()
operator|-
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|HFileBlock
name|readBlock
parameter_list|(
name|long
name|offset
parameter_list|,
name|long
name|onDiskBlockSize
parameter_list|,
name|boolean
name|cacheBlock
parameter_list|,
name|boolean
name|pread
parameter_list|,
name|boolean
name|isCompaction
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|DataInput
name|getBloomFilterMetadata
parameter_list|()
throws|throws
name|IOException
block|{
name|ByteBuffer
name|buf
init|=
name|getMetaBlock
argument_list|(
name|HFileWriterV1
operator|.
name|BLOOM_FILTER_META_KEY
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|ByteArrayInputStream
name|bais
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|buf
operator|.
name|array
argument_list|()
argument_list|,
name|buf
operator|.
name|arrayOffset
argument_list|()
argument_list|,
name|buf
operator|.
name|limit
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|DataInputStream
argument_list|(
name|bais
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isFileInfoLoaded
parameter_list|()
block|{
return|return
name|fileInfoLoaded
return|;
block|}
block|}
end_class

end_unit

