begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2010 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|BindException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|ServerSocket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Socket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|CancelledKeyException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ClosedChannelException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ReadableByteChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|SelectionKey
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|Selector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ServerSocketChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|SocketChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|WritableByteChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|HbaseObjectWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|WritableWithSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|monitoring
operator|.
name|MonitoredRPCHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|monitoring
operator|.
name|TaskMonitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|User
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ByteBufferOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RPC
operator|.
name|VersionMismatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactoryBuilder
import|;
end_import

begin_comment
comment|/** An abstract IPC service.  IPC calls take a single {@link Writable} as a  * parameter, and return a {@link Writable} as their value.  A service runs on  * a port and is defined by a parameter class and a value class.  *  *  *<p>Copied local so can fix HBASE-900.  *  * @see HBaseClient  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|abstract
class|class
name|HBaseServer
implements|implements
name|RpcServer
block|{
comment|/**    * The first four bytes of Hadoop RPC connections    */
specifier|public
specifier|static
specifier|final
name|ByteBuffer
name|HEADER
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
literal|"hrpc"
operator|.
name|getBytes
argument_list|()
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
name|CURRENT_VERSION
init|=
literal|3
decl_stmt|;
comment|/**    * How many calls/handler are allowed in the queue.    */
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_QUEUE_SIZE_PER_HANDLER
init|=
literal|10
decl_stmt|;
specifier|static
specifier|final
name|int
name|BUFFER_INITIAL_SIZE
init|=
literal|1024
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|WARN_DELAYED_CALLS
init|=
literal|"hbase.ipc.warn.delayedrpc.number"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_WARN_DELAYED_CALLS
init|=
literal|1000
decl_stmt|;
specifier|private
specifier|final
name|int
name|warnDelayedCalls
decl_stmt|;
specifier|private
name|AtomicInteger
name|delayedCalls
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
literal|"org.apache.hadoop.ipc.HBaseServer"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|Log
name|TRACELOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
literal|"org.apache.hadoop.ipc.HBaseServer.trace"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|RpcServer
argument_list|>
name|SERVER
init|=
operator|new
name|ThreadLocal
argument_list|<
name|RpcServer
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|started
init|=
literal|false
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Class
argument_list|<
name|?
extends|extends
name|VersionedProtocol
argument_list|>
argument_list|>
name|PROTOCOL_CACHE
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|Class
argument_list|<
name|?
extends|extends
name|VersionedProtocol
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|static
name|Class
argument_list|<
name|?
extends|extends
name|VersionedProtocol
argument_list|>
name|getProtocolClass
parameter_list|(
name|String
name|protocolName
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|ClassNotFoundException
block|{
name|Class
argument_list|<
name|?
extends|extends
name|VersionedProtocol
argument_list|>
name|protocol
init|=
name|PROTOCOL_CACHE
operator|.
name|get
argument_list|(
name|protocolName
argument_list|)
decl_stmt|;
if|if
condition|(
name|protocol
operator|==
literal|null
condition|)
block|{
name|protocol
operator|=
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|VersionedProtocol
argument_list|>
operator|)
name|conf
operator|.
name|getClassByName
argument_list|(
name|protocolName
argument_list|)
expr_stmt|;
name|PROTOCOL_CACHE
operator|.
name|put
argument_list|(
name|protocolName
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
block|}
return|return
name|protocol
return|;
block|}
comment|/** Returns the server instance called under or null.  May be called under    * {@link #call(Class, Writable, long, MonitoredRPCHandler)} implementations,    * and under {@link Writable} methods of paramters and return values.    * Permits applications to access the server context.    * @return HBaseServer    */
specifier|public
specifier|static
name|RpcServer
name|get
parameter_list|()
block|{
return|return
name|SERVER
operator|.
name|get
argument_list|()
return|;
block|}
comment|/** This is set to Call object before Handler invokes an RPC and reset    * after the call returns.    */
specifier|protected
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|Call
argument_list|>
name|CurCall
init|=
operator|new
name|ThreadLocal
argument_list|<
name|Call
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Returns the remote side ip address when invoked inside an RPC    *  Returns null incase of an error.    *  @return InetAddress    */
specifier|public
specifier|static
name|InetAddress
name|getRemoteIp
parameter_list|()
block|{
name|Call
name|call
init|=
name|CurCall
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|call
operator|!=
literal|null
condition|)
block|{
return|return
name|call
operator|.
name|connection
operator|.
name|socket
operator|.
name|getInetAddress
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/** Returns remote address as a string when invoked inside an RPC.    *  Returns null in case of an error.    *  @return String    */
specifier|public
specifier|static
name|String
name|getRemoteAddress
parameter_list|()
block|{
name|InetAddress
name|addr
init|=
name|getRemoteIp
argument_list|()
decl_stmt|;
return|return
operator|(
name|addr
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|addr
operator|.
name|getHostAddress
argument_list|()
return|;
block|}
specifier|protected
name|String
name|bindAddress
decl_stmt|;
specifier|protected
name|int
name|port
decl_stmt|;
comment|// port we listen on
specifier|private
name|int
name|handlerCount
decl_stmt|;
comment|// number of handler threads
specifier|private
name|int
name|priorityHandlerCount
decl_stmt|;
specifier|private
name|int
name|readThreads
decl_stmt|;
comment|// number of read threads
specifier|protected
name|Class
argument_list|<
name|?
extends|extends
name|Writable
argument_list|>
name|paramClass
decl_stmt|;
comment|// class of call parameters
specifier|protected
name|int
name|maxIdleTime
decl_stmt|;
comment|// the maximum idle time after
comment|// which a client may be
comment|// disconnected
specifier|protected
name|int
name|thresholdIdleConnections
decl_stmt|;
comment|// the number of idle
comment|// connections after which we
comment|// will start cleaning up idle
comment|// connections
name|int
name|maxConnectionsToNuke
decl_stmt|;
comment|// the max number of
comment|// connections to nuke
comment|// during a cleanup
specifier|protected
name|HBaseRpcMetrics
name|rpcMetrics
decl_stmt|;
specifier|protected
name|Configuration
name|conf
decl_stmt|;
specifier|private
name|int
name|maxQueueSize
decl_stmt|;
specifier|protected
name|int
name|socketSendBufferSize
decl_stmt|;
specifier|protected
specifier|final
name|boolean
name|tcpNoDelay
decl_stmt|;
comment|// if T then disable Nagle's Algorithm
specifier|protected
specifier|final
name|boolean
name|tcpKeepAlive
decl_stmt|;
comment|// if T then use keepalives
specifier|volatile
specifier|protected
name|boolean
name|running
init|=
literal|true
decl_stmt|;
comment|// true while server runs
specifier|protected
name|BlockingQueue
argument_list|<
name|Call
argument_list|>
name|callQueue
decl_stmt|;
comment|// queued calls
specifier|protected
name|BlockingQueue
argument_list|<
name|Call
argument_list|>
name|priorityCallQueue
decl_stmt|;
specifier|protected
name|int
name|highPriorityLevel
decl_stmt|;
comment|// what level a high priority call is at
specifier|private
specifier|volatile
name|int
name|responseQueueLen
decl_stmt|;
comment|// size of response queue for this server
specifier|protected
specifier|final
name|List
argument_list|<
name|Connection
argument_list|>
name|connectionList
init|=
name|Collections
operator|.
name|synchronizedList
argument_list|(
operator|new
name|LinkedList
argument_list|<
name|Connection
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|//maintain a list
comment|//of client connections
specifier|private
name|Listener
name|listener
init|=
literal|null
decl_stmt|;
specifier|protected
name|Responder
name|responder
init|=
literal|null
decl_stmt|;
specifier|protected
name|int
name|numConnections
init|=
literal|0
decl_stmt|;
specifier|private
name|Handler
index|[]
name|handlers
init|=
literal|null
decl_stmt|;
specifier|private
name|Handler
index|[]
name|priorityHandlers
init|=
literal|null
decl_stmt|;
specifier|protected
name|HBaseRPCErrorHandler
name|errorHandler
init|=
literal|null
decl_stmt|;
comment|/**    * A convenience method to bind to a given address and report    * better exceptions if the address is not a valid host.    * @param socket the socket to bind    * @param address the address to bind to    * @param backlog the number of connections allowed in the queue    * @throws BindException if the address can't be bound    * @throws UnknownHostException if the address isn't a valid host name    * @throws IOException other random errors from bind    */
specifier|public
specifier|static
name|void
name|bind
parameter_list|(
name|ServerSocket
name|socket
parameter_list|,
name|InetSocketAddress
name|address
parameter_list|,
name|int
name|backlog
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|socket
operator|.
name|bind
argument_list|(
name|address
argument_list|,
name|backlog
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BindException
name|e
parameter_list|)
block|{
name|BindException
name|bindException
init|=
operator|new
name|BindException
argument_list|(
literal|"Problem binding to "
operator|+
name|address
operator|+
literal|" : "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
decl_stmt|;
name|bindException
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|bindException
throw|;
block|}
catch|catch
parameter_list|(
name|SocketException
name|e
parameter_list|)
block|{
comment|// If they try to bind to a different host's address, give a better
comment|// error message.
if|if
condition|(
literal|"Unresolved address"
operator|.
name|equals
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|UnknownHostException
argument_list|(
literal|"Invalid hostname for server: "
operator|+
name|address
operator|.
name|getHostName
argument_list|()
argument_list|)
throw|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
comment|/** A call queued for handling. */
specifier|protected
class|class
name|Call
implements|implements
name|Delayable
block|{
specifier|protected
name|int
name|id
decl_stmt|;
comment|// the client's call id
specifier|protected
name|Writable
name|param
decl_stmt|;
comment|// the parameter passed
specifier|protected
name|Connection
name|connection
decl_stmt|;
comment|// connection to client
specifier|protected
name|long
name|timestamp
decl_stmt|;
comment|// the time received when response is null
comment|// the time served when response is not null
specifier|protected
name|ByteBuffer
name|response
decl_stmt|;
comment|// the response for this call
specifier|protected
name|boolean
name|delayResponse
decl_stmt|;
specifier|protected
name|Responder
name|responder
decl_stmt|;
specifier|protected
name|boolean
name|delayReturnValue
decl_stmt|;
comment|// if the return value should be
comment|// set at call completion
specifier|protected
name|boolean
name|isError
decl_stmt|;
specifier|public
name|Call
parameter_list|(
name|int
name|id
parameter_list|,
name|Writable
name|param
parameter_list|,
name|Connection
name|connection
parameter_list|,
name|Responder
name|responder
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|this
operator|.
name|param
operator|=
name|param
expr_stmt|;
name|this
operator|.
name|connection
operator|=
name|connection
expr_stmt|;
name|this
operator|.
name|timestamp
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|this
operator|.
name|response
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|delayResponse
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|responder
operator|=
name|responder
expr_stmt|;
name|this
operator|.
name|isError
operator|=
literal|false
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|param
operator|.
name|toString
argument_list|()
operator|+
literal|" from "
operator|+
name|connection
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|protected
specifier|synchronized
name|void
name|setResponse
parameter_list|(
name|Object
name|value
parameter_list|,
name|Status
name|status
parameter_list|,
name|String
name|errorClass
parameter_list|,
name|String
name|error
parameter_list|)
block|{
comment|// Avoid overwriting an error value in the response.  This can happen if
comment|// endDelayThrowing is called by another thread before the actual call
comment|// returning.
if|if
condition|(
name|this
operator|.
name|isError
condition|)
return|return;
if|if
condition|(
name|errorClass
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|isError
operator|=
literal|true
expr_stmt|;
block|}
name|Writable
name|result
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Writable
condition|)
block|{
name|result
operator|=
operator|(
name|Writable
operator|)
name|value
expr_stmt|;
block|}
else|else
block|{
comment|/* We might have a null value and errors. Avoid creating a          * HbaseObjectWritable, because the constructor fails on null. */
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
operator|new
name|HbaseObjectWritable
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|size
init|=
name|BUFFER_INITIAL_SIZE
decl_stmt|;
if|if
condition|(
name|result
operator|instanceof
name|WritableWithSize
condition|)
block|{
comment|// get the size hint.
name|WritableWithSize
name|ohint
init|=
operator|(
name|WritableWithSize
operator|)
name|result
decl_stmt|;
name|long
name|hint
init|=
name|ohint
operator|.
name|getWritableSize
argument_list|()
operator|+
name|Bytes
operator|.
name|SIZEOF_BYTE
operator|+
operator|(
literal|2
operator|*
name|Bytes
operator|.
name|SIZEOF_INT
operator|)
decl_stmt|;
if|if
condition|(
name|hint
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
comment|// oops, new problem.
name|IOException
name|ioe
init|=
operator|new
name|IOException
argument_list|(
literal|"Result buffer size too large: "
operator|+
name|hint
argument_list|)
decl_stmt|;
name|errorClass
operator|=
name|ioe
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
name|error
operator|=
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
operator|(
name|int
operator|)
name|hint
expr_stmt|;
block|}
block|}
name|ByteBufferOutputStream
name|buf
init|=
operator|new
name|ByteBufferOutputStream
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|DataOutputStream
name|out
init|=
operator|new
name|DataOutputStream
argument_list|(
name|buf
argument_list|)
decl_stmt|;
try|try
block|{
comment|// Call id.
name|out
operator|.
name|writeInt
argument_list|(
name|this
operator|.
name|id
argument_list|)
expr_stmt|;
comment|// Write flag.
name|byte
name|flag
init|=
operator|(
name|error
operator|!=
literal|null
operator|)
condition|?
name|ResponseFlag
operator|.
name|getErrorAndLengthSet
argument_list|()
else|:
name|ResponseFlag
operator|.
name|getLengthSetOnly
argument_list|()
decl_stmt|;
name|out
operator|.
name|writeByte
argument_list|(
name|flag
argument_list|)
expr_stmt|;
comment|// Place holder for length set later below after we
comment|// fill the buffer with data.
name|out
operator|.
name|writeInt
argument_list|(
literal|0xdeadbeef
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|status
operator|.
name|state
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|errorClass
operator|=
name|e
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
name|error
operator|=
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|error
operator|==
literal|null
condition|)
block|{
name|result
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WritableUtils
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|errorClass
argument_list|)
expr_stmt|;
name|WritableUtils
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error sending response to call: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// Set the length into the ByteBuffer after call id and after
comment|// byte flag.
name|ByteBuffer
name|bb
init|=
name|buf
operator|.
name|getByteBuffer
argument_list|()
decl_stmt|;
name|int
name|bufSiz
init|=
name|bb
operator|.
name|remaining
argument_list|()
decl_stmt|;
comment|// Move to the size location in our ByteBuffer past call.id
comment|// and past the byte flag.
name|bb
operator|.
name|position
argument_list|(
name|Bytes
operator|.
name|SIZEOF_INT
operator|+
name|Bytes
operator|.
name|SIZEOF_BYTE
argument_list|)
expr_stmt|;
name|bb
operator|.
name|putInt
argument_list|(
name|bufSiz
argument_list|)
expr_stmt|;
name|bb
operator|.
name|position
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|response
operator|=
name|bb
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|endDelay
parameter_list|(
name|Object
name|result
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|this
operator|.
name|delayResponse
assert|;
assert|assert
name|this
operator|.
name|delayReturnValue
operator|||
name|result
operator|==
literal|null
assert|;
name|this
operator|.
name|delayResponse
operator|=
literal|false
expr_stmt|;
name|delayedCalls
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|delayReturnValue
condition|)
name|this
operator|.
name|setResponse
argument_list|(
name|result
argument_list|,
name|Status
operator|.
name|SUCCESS
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|this
operator|.
name|responder
operator|.
name|doRespond
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|endDelay
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|endDelay
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|startDelay
parameter_list|(
name|boolean
name|delayReturnValue
parameter_list|)
block|{
assert|assert
operator|!
name|this
operator|.
name|delayResponse
assert|;
name|this
operator|.
name|delayResponse
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|delayReturnValue
operator|=
name|delayReturnValue
expr_stmt|;
name|int
name|numDelayed
init|=
name|delayedCalls
operator|.
name|incrementAndGet
argument_list|()
decl_stmt|;
if|if
condition|(
name|numDelayed
operator|>
name|warnDelayedCalls
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Too many delayed calls: limit "
operator|+
name|warnDelayedCalls
operator|+
literal|" current "
operator|+
name|numDelayed
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|endDelayThrowing
parameter_list|(
name|Throwable
name|t
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|setResponse
argument_list|(
literal|null
argument_list|,
name|Status
operator|.
name|ERROR
argument_list|,
name|t
operator|.
name|getClass
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|delayResponse
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|sendResponseIfReady
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|boolean
name|isDelayed
parameter_list|()
block|{
return|return
name|this
operator|.
name|delayResponse
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|boolean
name|isReturnValueDelayed
parameter_list|()
block|{
return|return
name|this
operator|.
name|delayReturnValue
return|;
block|}
comment|/**      * If we have a response, and delay is not set, then respond      * immediately.  Otherwise, do not respond to client.  This is      * called the by the RPC code in the context of the Handler thread.      */
specifier|public
specifier|synchronized
name|void
name|sendResponseIfReady
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|delayResponse
condition|)
block|{
name|this
operator|.
name|responder
operator|.
name|doRespond
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Listens on the socket. Creates jobs for the handler threads*/
specifier|private
class|class
name|Listener
extends|extends
name|Thread
block|{
specifier|private
name|ServerSocketChannel
name|acceptChannel
init|=
literal|null
decl_stmt|;
comment|//the accept channel
specifier|private
name|Selector
name|selector
init|=
literal|null
decl_stmt|;
comment|//the selector that we use for the server
specifier|private
name|Reader
index|[]
name|readers
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|currentReader
init|=
literal|0
decl_stmt|;
specifier|private
name|InetSocketAddress
name|address
decl_stmt|;
comment|//the address we bind at
specifier|private
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
specifier|private
name|long
name|lastCleanupRunTime
init|=
literal|0
decl_stmt|;
comment|//the last time when a cleanup connec-
comment|//-tion (for idle connections) ran
specifier|private
name|long
name|cleanupInterval
init|=
literal|10000
decl_stmt|;
comment|//the minimum interval between
comment|//two cleanup runs
specifier|private
name|int
name|backlogLength
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"ipc.server.listen.queue.size"
argument_list|,
literal|128
argument_list|)
decl_stmt|;
specifier|private
name|ExecutorService
name|readPool
decl_stmt|;
specifier|public
name|Listener
parameter_list|()
throws|throws
name|IOException
block|{
name|address
operator|=
operator|new
name|InetSocketAddress
argument_list|(
name|bindAddress
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|// Create a new server socket and set to non blocking mode
name|acceptChannel
operator|=
name|ServerSocketChannel
operator|.
name|open
argument_list|()
expr_stmt|;
name|acceptChannel
operator|.
name|configureBlocking
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Bind the server socket to the local host and port
name|bind
argument_list|(
name|acceptChannel
operator|.
name|socket
argument_list|()
argument_list|,
name|address
argument_list|,
name|backlogLength
argument_list|)
expr_stmt|;
name|port
operator|=
name|acceptChannel
operator|.
name|socket
argument_list|()
operator|.
name|getLocalPort
argument_list|()
expr_stmt|;
comment|//Could be an ephemeral port
comment|// create a selector;
name|selector
operator|=
name|Selector
operator|.
name|open
argument_list|()
expr_stmt|;
name|readers
operator|=
operator|new
name|Reader
index|[
name|readThreads
index|]
expr_stmt|;
name|readPool
operator|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
name|readThreads
argument_list|,
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setNameFormat
argument_list|(
literal|"IPC Reader %d on port "
operator|+
name|port
argument_list|)
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|readThreads
condition|;
operator|++
name|i
control|)
block|{
name|Reader
name|reader
init|=
operator|new
name|Reader
argument_list|()
decl_stmt|;
name|readers
index|[
name|i
index|]
operator|=
name|reader
expr_stmt|;
name|readPool
operator|.
name|execute
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
comment|// Register accepts on the server socket with the selector.
name|acceptChannel
operator|.
name|register
argument_list|(
name|selector
argument_list|,
name|SelectionKey
operator|.
name|OP_ACCEPT
argument_list|)
expr_stmt|;
name|this
operator|.
name|setName
argument_list|(
literal|"IPC Server listener on "
operator|+
name|port
argument_list|)
expr_stmt|;
name|this
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|private
class|class
name|Reader
implements|implements
name|Runnable
block|{
specifier|private
specifier|volatile
name|boolean
name|adding
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
name|Selector
name|readSelector
decl_stmt|;
name|Reader
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|readSelector
operator|=
name|Selector
operator|.
name|open
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting "
operator|+
name|getName
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|doRunLoop
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
try|try
block|{
name|readSelector
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error closing read selector in "
operator|+
name|getName
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|synchronized
name|void
name|doRunLoop
parameter_list|()
block|{
while|while
condition|(
name|running
condition|)
block|{
name|SelectionKey
name|key
init|=
literal|null
decl_stmt|;
try|try
block|{
name|readSelector
operator|.
name|select
argument_list|()
expr_stmt|;
while|while
condition|(
name|adding
condition|)
block|{
name|this
operator|.
name|wait
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|SelectionKey
argument_list|>
name|iter
init|=
name|readSelector
operator|.
name|selectedKeys
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|key
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
if|if
condition|(
name|key
operator|.
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|key
operator|.
name|isReadable
argument_list|()
condition|)
block|{
name|doRead
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
name|key
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
if|if
condition|(
name|running
condition|)
block|{
comment|// unexpected -- log it
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|" unexpectedly interrupted: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error in Reader"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**        * This gets reader into the state that waits for the new channel        * to be registered with readSelector. If it was waiting in select()        * the thread will be woken up, otherwise whenever select() is called        * it will return even if there is nothing to read and wait        * in while(adding) for finishAdd call        */
specifier|public
name|void
name|startAdd
parameter_list|()
block|{
name|adding
operator|=
literal|true
expr_stmt|;
name|readSelector
operator|.
name|wakeup
argument_list|()
expr_stmt|;
block|}
specifier|public
specifier|synchronized
name|SelectionKey
name|registerChannel
parameter_list|(
name|SocketChannel
name|channel
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|channel
operator|.
name|register
argument_list|(
name|readSelector
argument_list|,
name|SelectionKey
operator|.
name|OP_READ
argument_list|)
return|;
block|}
specifier|public
specifier|synchronized
name|void
name|finishAdd
parameter_list|()
block|{
name|adding
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|notify
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** cleanup connections from connectionList. Choose a random range      * to scan and also have a limit on the number of the connections      * that will be cleanedup per run. The criteria for cleanup is the time      * for which the connection was idle. If 'force' is true then all      * connections will be looked at for the cleanup.      * @param force all connections will be looked at for cleanup      */
specifier|private
name|void
name|cleanupConnections
parameter_list|(
name|boolean
name|force
parameter_list|)
block|{
if|if
condition|(
name|force
operator|||
name|numConnections
operator|>
name|thresholdIdleConnections
condition|)
block|{
name|long
name|currentTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|force
operator|&&
operator|(
name|currentTime
operator|-
name|lastCleanupRunTime
operator|)
operator|<
name|cleanupInterval
condition|)
block|{
return|return;
block|}
name|int
name|start
init|=
literal|0
decl_stmt|;
name|int
name|end
init|=
name|numConnections
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|force
condition|)
block|{
name|start
operator|=
name|rand
operator|.
name|nextInt
argument_list|()
operator|%
name|numConnections
expr_stmt|;
name|end
operator|=
name|rand
operator|.
name|nextInt
argument_list|()
operator|%
name|numConnections
expr_stmt|;
name|int
name|temp
decl_stmt|;
if|if
condition|(
name|end
operator|<
name|start
condition|)
block|{
name|temp
operator|=
name|start
expr_stmt|;
name|start
operator|=
name|end
expr_stmt|;
name|end
operator|=
name|temp
expr_stmt|;
block|}
block|}
name|int
name|i
init|=
name|start
decl_stmt|;
name|int
name|numNuked
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<=
name|end
condition|)
block|{
name|Connection
name|c
decl_stmt|;
synchronized|synchronized
init|(
name|connectionList
init|)
block|{
try|try
block|{
name|c
operator|=
name|connectionList
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return;
block|}
block|}
if|if
condition|(
name|c
operator|.
name|timedOut
argument_list|(
name|currentTime
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|": disconnecting client "
operator|+
name|c
operator|.
name|getHostAddress
argument_list|()
argument_list|)
expr_stmt|;
name|closeConnection
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|numNuked
operator|++
expr_stmt|;
name|end
operator|--
expr_stmt|;
comment|//noinspection UnusedAssignment
name|c
operator|=
literal|null
expr_stmt|;
if|if
condition|(
operator|!
name|force
operator|&&
name|numNuked
operator|==
name|maxConnectionsToNuke
condition|)
break|break;
block|}
else|else
name|i
operator|++
expr_stmt|;
block|}
name|lastCleanupRunTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": starting"
argument_list|)
expr_stmt|;
name|SERVER
operator|.
name|set
argument_list|(
name|HBaseServer
operator|.
name|this
argument_list|)
expr_stmt|;
while|while
condition|(
name|running
condition|)
block|{
name|SelectionKey
name|key
init|=
literal|null
decl_stmt|;
try|try
block|{
name|selector
operator|.
name|select
argument_list|()
expr_stmt|;
comment|// FindBugs IS2_INCONSISTENT_SYNC
name|Iterator
argument_list|<
name|SelectionKey
argument_list|>
name|iter
init|=
name|selector
operator|.
name|selectedKeys
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|key
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|key
operator|.
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|key
operator|.
name|isAcceptable
argument_list|()
condition|)
name|doAccept
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ignored
parameter_list|)
block|{             }
name|key
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|e
parameter_list|)
block|{
if|if
condition|(
name|errorHandler
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|errorHandler
operator|.
name|checkOOME
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": exiting on OOME"
argument_list|)
expr_stmt|;
name|closeCurrentConnection
argument_list|(
name|key
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|cleanupConnections
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|// we can run out of memory if we have too many threads
comment|// log the event and sleep for a minute and give
comment|// some thread(s) a chance to finish
name|LOG
operator|.
name|warn
argument_list|(
literal|"Out of Memory in server select"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|closeCurrentConnection
argument_list|(
name|key
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|cleanupConnections
argument_list|(
literal|true
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|60000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ignored
parameter_list|)
block|{}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|closeCurrentConnection
argument_list|(
name|key
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|cleanupConnections
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping "
operator|+
name|this
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
try|try
block|{
name|acceptChannel
operator|.
name|close
argument_list|()
expr_stmt|;
name|selector
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ignored
parameter_list|)
block|{ }
name|selector
operator|=
literal|null
expr_stmt|;
name|acceptChannel
operator|=
literal|null
expr_stmt|;
comment|// clean up all connections
while|while
condition|(
operator|!
name|connectionList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|closeConnection
argument_list|(
name|connectionList
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|closeCurrentConnection
parameter_list|(
name|SelectionKey
name|key
parameter_list|,
name|Throwable
name|e
parameter_list|)
block|{
if|if
condition|(
name|key
operator|!=
literal|null
condition|)
block|{
name|Connection
name|c
init|=
operator|(
name|Connection
operator|)
name|key
operator|.
name|attachment
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|": disconnecting client "
operator|+
name|c
operator|.
name|getHostAddress
argument_list|()
operator|+
operator|(
name|e
operator|!=
literal|null
condition|?
literal|" on error "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
name|closeConnection
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|key
operator|.
name|attach
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|InetSocketAddress
name|getAddress
parameter_list|()
block|{
return|return
operator|(
name|InetSocketAddress
operator|)
name|acceptChannel
operator|.
name|socket
argument_list|()
operator|.
name|getLocalSocketAddress
argument_list|()
return|;
block|}
name|void
name|doAccept
parameter_list|(
name|SelectionKey
name|key
parameter_list|)
throws|throws
name|IOException
throws|,
name|OutOfMemoryError
block|{
name|Connection
name|c
decl_stmt|;
name|ServerSocketChannel
name|server
init|=
operator|(
name|ServerSocketChannel
operator|)
name|key
operator|.
name|channel
argument_list|()
decl_stmt|;
name|SocketChannel
name|channel
decl_stmt|;
while|while
condition|(
operator|(
name|channel
operator|=
name|server
operator|.
name|accept
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|channel
operator|.
name|configureBlocking
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|channel
operator|.
name|socket
argument_list|()
operator|.
name|setTcpNoDelay
argument_list|(
name|tcpNoDelay
argument_list|)
expr_stmt|;
name|channel
operator|.
name|socket
argument_list|()
operator|.
name|setKeepAlive
argument_list|(
name|tcpKeepAlive
argument_list|)
expr_stmt|;
name|Reader
name|reader
init|=
name|getReader
argument_list|()
decl_stmt|;
try|try
block|{
name|reader
operator|.
name|startAdd
argument_list|()
expr_stmt|;
name|SelectionKey
name|readKey
init|=
name|reader
operator|.
name|registerChannel
argument_list|(
name|channel
argument_list|)
decl_stmt|;
name|c
operator|=
name|getConnection
argument_list|(
name|channel
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|readKey
operator|.
name|attach
argument_list|(
name|c
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|connectionList
init|)
block|{
name|connectionList
operator|.
name|add
argument_list|(
name|numConnections
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|numConnections
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"Server connection from "
operator|+
name|c
operator|.
name|toString
argument_list|()
operator|+
literal|"; # active connections: "
operator|+
name|numConnections
operator|+
literal|"; # queued calls: "
operator|+
name|callQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|reader
operator|.
name|finishAdd
argument_list|()
expr_stmt|;
block|}
block|}
name|rpcMetrics
operator|.
name|numOpenConnections
operator|.
name|set
argument_list|(
name|numConnections
argument_list|)
expr_stmt|;
block|}
name|void
name|doRead
parameter_list|(
name|SelectionKey
name|key
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|Connection
name|c
init|=
operator|(
name|Connection
operator|)
name|key
operator|.
name|attachment
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|c
operator|.
name|setLastContact
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|count
operator|=
name|c
operator|.
name|readAndProcess
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ieo
parameter_list|)
block|{
throw|throw
name|ieo
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|getName
argument_list|()
operator|+
literal|": readAndProcess threw exception "
operator|+
name|e
operator|+
literal|". Count of bytes read: "
operator|+
name|count
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|count
operator|=
operator|-
literal|1
expr_stmt|;
comment|//so that the (count< 0) block is executed
block|}
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|": disconnecting client "
operator|+
name|c
operator|.
name|getHostAddress
argument_list|()
operator|+
literal|". Number of active connections: "
operator|+
name|numConnections
argument_list|)
expr_stmt|;
name|closeConnection
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|// c = null;
block|}
else|else
block|{
name|c
operator|.
name|setLastContact
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|synchronized
name|void
name|doStop
parameter_list|()
block|{
if|if
condition|(
name|selector
operator|!=
literal|null
condition|)
block|{
name|selector
operator|.
name|wakeup
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|yield
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|acceptChannel
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|acceptChannel
operator|.
name|socket
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|":Exception in closing listener socket. "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|readPool
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
comment|// The method that will return the next reader to work with
comment|// Simplistic implementation of round robin for now
name|Reader
name|getReader
parameter_list|()
block|{
name|currentReader
operator|=
operator|(
name|currentReader
operator|+
literal|1
operator|)
operator|%
name|readers
operator|.
name|length
expr_stmt|;
return|return
name|readers
index|[
name|currentReader
index|]
return|;
block|}
block|}
comment|// Sends responses of RPC back to clients.
specifier|protected
class|class
name|Responder
extends|extends
name|Thread
block|{
specifier|private
specifier|final
name|Selector
name|writeSelector
decl_stmt|;
specifier|private
name|int
name|pending
decl_stmt|;
comment|// connections waiting to register
specifier|final
specifier|static
name|int
name|PURGE_INTERVAL
init|=
literal|900000
decl_stmt|;
comment|// 15mins
name|Responder
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|setName
argument_list|(
literal|"IPC Server Responder"
argument_list|)
expr_stmt|;
name|this
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|writeSelector
operator|=
name|Selector
operator|.
name|open
argument_list|()
expr_stmt|;
comment|// create a selector
name|pending
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": starting"
argument_list|)
expr_stmt|;
name|SERVER
operator|.
name|set
argument_list|(
name|HBaseServer
operator|.
name|this
argument_list|)
expr_stmt|;
try|try
block|{
name|doRunLoop
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping "
operator|+
name|this
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|writeSelector
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Couldn't close write selector in "
operator|+
name|this
operator|.
name|getName
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|doRunLoop
parameter_list|()
block|{
name|long
name|lastPurgeTime
init|=
literal|0
decl_stmt|;
comment|// last check for old calls.
while|while
condition|(
name|running
condition|)
block|{
try|try
block|{
name|waitPending
argument_list|()
expr_stmt|;
comment|// If a channel is being registered, wait.
name|writeSelector
operator|.
name|select
argument_list|(
name|PURGE_INTERVAL
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|SelectionKey
argument_list|>
name|iter
init|=
name|writeSelector
operator|.
name|selectedKeys
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|SelectionKey
name|key
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|key
operator|.
name|isValid
argument_list|()
operator|&&
name|key
operator|.
name|isWritable
argument_list|()
condition|)
block|{
name|doAsyncWrite
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": doAsyncWrite threw exception "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|now
operator|<
name|lastPurgeTime
operator|+
name|PURGE_INTERVAL
condition|)
block|{
continue|continue;
block|}
name|lastPurgeTime
operator|=
name|now
expr_stmt|;
comment|//
comment|// If there were some calls that have not been sent out for a
comment|// long time, discard them.
comment|//
name|LOG
operator|.
name|debug
argument_list|(
literal|"Checking for old call responses."
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|Call
argument_list|>
name|calls
decl_stmt|;
comment|// get the list of channels from list of keys.
synchronized|synchronized
init|(
name|writeSelector
operator|.
name|keys
argument_list|()
init|)
block|{
name|calls
operator|=
operator|new
name|ArrayList
argument_list|<
name|Call
argument_list|>
argument_list|(
name|writeSelector
operator|.
name|keys
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|iter
operator|=
name|writeSelector
operator|.
name|keys
argument_list|()
operator|.
name|iterator
argument_list|()
expr_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|SelectionKey
name|key
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|Call
name|call
init|=
operator|(
name|Call
operator|)
name|key
operator|.
name|attachment
argument_list|()
decl_stmt|;
if|if
condition|(
name|call
operator|!=
literal|null
operator|&&
name|key
operator|.
name|channel
argument_list|()
operator|==
name|call
operator|.
name|connection
operator|.
name|channel
condition|)
block|{
name|calls
operator|.
name|add
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|Call
name|call
range|:
name|calls
control|)
block|{
try|try
block|{
name|doPurge
argument_list|(
name|call
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error in purging old calls "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|e
parameter_list|)
block|{
if|if
condition|(
name|errorHandler
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|errorHandler
operator|.
name|checkOOME
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": exiting on OOME"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|//
comment|// we can run out of memory if we have too many threads
comment|// log the event and sleep for a minute and give
comment|// some thread(s) a chance to finish
comment|//
name|LOG
operator|.
name|warn
argument_list|(
literal|"Out of Memory in server select"
argument_list|,
name|e
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|60000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ignored
parameter_list|)
block|{}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception in Responder "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping "
operator|+
name|this
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|doAsyncWrite
parameter_list|(
name|SelectionKey
name|key
parameter_list|)
throws|throws
name|IOException
block|{
name|Call
name|call
init|=
operator|(
name|Call
operator|)
name|key
operator|.
name|attachment
argument_list|()
decl_stmt|;
if|if
condition|(
name|call
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|key
operator|.
name|channel
argument_list|()
operator|!=
name|call
operator|.
name|connection
operator|.
name|channel
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"doAsyncWrite: bad channel"
argument_list|)
throw|;
block|}
synchronized|synchronized
init|(
name|call
operator|.
name|connection
operator|.
name|responseQueue
init|)
block|{
if|if
condition|(
name|processResponse
argument_list|(
name|call
operator|.
name|connection
operator|.
name|responseQueue
argument_list|,
literal|false
argument_list|)
condition|)
block|{
try|try
block|{
name|key
operator|.
name|interestOps
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CancelledKeyException
name|e
parameter_list|)
block|{
comment|/* The Listener/reader might have closed the socket.              * We don't explicitly cancel the key, so not sure if this will              * ever fire.              * This warning could be removed.              */
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while changing ops : "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|//
comment|// Remove calls that have been pending in the responseQueue
comment|// for a long time.
comment|//
specifier|private
name|void
name|doPurge
parameter_list|(
name|Call
name|call
parameter_list|,
name|long
name|now
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|call
operator|.
name|connection
operator|.
name|responseQueue
init|)
block|{
name|Iterator
argument_list|<
name|Call
argument_list|>
name|iter
init|=
name|call
operator|.
name|connection
operator|.
name|responseQueue
operator|.
name|listIterator
argument_list|(
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Call
name|nextCall
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|now
operator|>
name|nextCall
operator|.
name|timestamp
operator|+
name|PURGE_INTERVAL
condition|)
block|{
name|closeConnection
argument_list|(
name|nextCall
operator|.
name|connection
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|// Processes one response. Returns true if there are no more pending
comment|// data for this channel.
comment|//
specifier|private
name|boolean
name|processResponse
parameter_list|(
specifier|final
name|LinkedList
argument_list|<
name|Call
argument_list|>
name|responseQueue
parameter_list|,
name|boolean
name|inHandler
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|error
init|=
literal|true
decl_stmt|;
name|boolean
name|done
init|=
literal|false
decl_stmt|;
comment|// there is more data for this channel.
name|int
name|numElements
decl_stmt|;
name|Call
name|call
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|//noinspection SynchronizationOnLocalVariableOrMethodParameter
synchronized|synchronized
init|(
name|responseQueue
init|)
block|{
comment|//
comment|// If there are no items for this channel, then we are done
comment|//
name|numElements
operator|=
name|responseQueue
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|numElements
operator|==
literal|0
condition|)
block|{
name|error
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
comment|// no more data for this channel.
block|}
comment|//
comment|// Extract the first call
comment|//
name|call
operator|=
name|responseQueue
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
name|SocketChannel
name|channel
init|=
name|call
operator|.
name|connection
operator|.
name|channel
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|": responding to #"
operator|+
name|call
operator|.
name|id
operator|+
literal|" from "
operator|+
name|call
operator|.
name|connection
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Send as much data as we can in the non-blocking fashion
comment|//
name|int
name|numBytes
init|=
name|channelWrite
argument_list|(
name|channel
argument_list|,
name|call
operator|.
name|response
argument_list|)
decl_stmt|;
if|if
condition|(
name|numBytes
operator|<
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|call
operator|.
name|response
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
name|responseQueueLen
operator|--
expr_stmt|;
name|call
operator|.
name|connection
operator|.
name|decRpcCount
argument_list|()
expr_stmt|;
comment|//noinspection RedundantIfStatement
if|if
condition|(
name|numElements
operator|==
literal|1
condition|)
block|{
comment|// last call fully processes.
name|done
operator|=
literal|true
expr_stmt|;
comment|// no more data for this channel.
block|}
else|else
block|{
name|done
operator|=
literal|false
expr_stmt|;
comment|// more calls pending to be sent.
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|": responding to #"
operator|+
name|call
operator|.
name|id
operator|+
literal|" from "
operator|+
name|call
operator|.
name|connection
operator|+
literal|" Wrote "
operator|+
name|numBytes
operator|+
literal|" bytes."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//
comment|// If we were unable to write the entire response out, then
comment|// insert in Selector queue.
comment|//
name|call
operator|.
name|connection
operator|.
name|responseQueue
operator|.
name|addFirst
argument_list|(
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
name|inHandler
condition|)
block|{
comment|// set the serve time when the response has to be sent later
name|call
operator|.
name|timestamp
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
if|if
condition|(
name|enqueueInSelector
argument_list|(
name|call
argument_list|)
condition|)
name|done
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|": responding to #"
operator|+
name|call
operator|.
name|id
operator|+
literal|" from "
operator|+
name|call
operator|.
name|connection
operator|+
literal|" Wrote partial "
operator|+
name|numBytes
operator|+
literal|" bytes."
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
literal|false
expr_stmt|;
comment|// everything went off well
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|error
operator|&&
name|call
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|getName
argument_list|()
operator|+
literal|", call "
operator|+
name|call
operator|+
literal|": output error"
argument_list|)
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
comment|// error. no more data for this channel.
name|closeConnection
argument_list|(
name|call
operator|.
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|done
return|;
block|}
comment|//
comment|// Enqueue for background thread to send responses out later.
comment|//
specifier|private
name|boolean
name|enqueueInSelector
parameter_list|(
name|Call
name|call
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|done
init|=
literal|false
decl_stmt|;
name|incPending
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Wake up the thread blocked on select, only then can the call
comment|// to channel.register() complete.
name|SocketChannel
name|channel
init|=
name|call
operator|.
name|connection
operator|.
name|channel
decl_stmt|;
name|writeSelector
operator|.
name|wakeup
argument_list|()
expr_stmt|;
name|channel
operator|.
name|register
argument_list|(
name|writeSelector
argument_list|,
name|SelectionKey
operator|.
name|OP_WRITE
argument_list|,
name|call
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClosedChannelException
name|e
parameter_list|)
block|{
comment|//It's OK.  Channel might be closed else where.
name|done
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|decPending
argument_list|()
expr_stmt|;
block|}
return|return
name|done
return|;
block|}
comment|//
comment|// Enqueue a response from the application.
comment|//
name|void
name|doRespond
parameter_list|(
name|Call
name|call
parameter_list|)
throws|throws
name|IOException
block|{
comment|// set the serve time when the response has to be sent later
name|call
operator|.
name|timestamp
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|responseQueueLen
operator|++
expr_stmt|;
name|boolean
name|doRegister
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|call
operator|.
name|connection
operator|.
name|responseQueue
init|)
block|{
name|call
operator|.
name|connection
operator|.
name|responseQueue
operator|.
name|addLast
argument_list|(
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
name|call
operator|.
name|connection
operator|.
name|responseQueue
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|doRegister
operator|=
operator|!
name|processResponse
argument_list|(
name|call
operator|.
name|connection
operator|.
name|responseQueue
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|doRegister
condition|)
block|{
name|enqueueInSelector
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|synchronized
name|void
name|incPending
parameter_list|()
block|{
comment|// call waiting to be enqueued.
name|pending
operator|++
expr_stmt|;
block|}
specifier|private
specifier|synchronized
name|void
name|decPending
parameter_list|()
block|{
comment|// call done enqueueing.
name|pending
operator|--
expr_stmt|;
name|notify
argument_list|()
expr_stmt|;
block|}
specifier|private
specifier|synchronized
name|void
name|waitPending
parameter_list|()
throws|throws
name|InterruptedException
block|{
while|while
condition|(
name|pending
operator|>
literal|0
condition|)
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/** Reads calls from a connection and queues them for handling. */
specifier|protected
class|class
name|Connection
block|{
specifier|private
name|boolean
name|versionRead
init|=
literal|false
decl_stmt|;
comment|//if initial signature and
comment|//version are read
specifier|private
name|boolean
name|headerRead
init|=
literal|false
decl_stmt|;
comment|//if the connection header that
comment|//follows version is read.
specifier|protected
name|SocketChannel
name|channel
decl_stmt|;
specifier|private
name|ByteBuffer
name|data
decl_stmt|;
specifier|private
name|ByteBuffer
name|dataLengthBuffer
decl_stmt|;
specifier|protected
specifier|final
name|LinkedList
argument_list|<
name|Call
argument_list|>
name|responseQueue
decl_stmt|;
specifier|private
specifier|volatile
name|int
name|rpcCount
init|=
literal|0
decl_stmt|;
comment|// number of outstanding rpcs
specifier|private
name|long
name|lastContact
decl_stmt|;
specifier|private
name|int
name|dataLength
decl_stmt|;
specifier|protected
name|Socket
name|socket
decl_stmt|;
comment|// Cache the remote host& port info so that even if the socket is
comment|// disconnected, we can say where it used to connect to.
specifier|protected
name|String
name|hostAddress
decl_stmt|;
specifier|protected
name|int
name|remotePort
decl_stmt|;
name|ConnectionHeader
name|header
init|=
operator|new
name|ConnectionHeader
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|VersionedProtocol
argument_list|>
name|protocol
decl_stmt|;
specifier|protected
name|User
name|ticket
init|=
literal|null
decl_stmt|;
specifier|public
name|Connection
parameter_list|(
name|SocketChannel
name|channel
parameter_list|,
name|long
name|lastContact
parameter_list|)
block|{
name|this
operator|.
name|channel
operator|=
name|channel
expr_stmt|;
name|this
operator|.
name|lastContact
operator|=
name|lastContact
expr_stmt|;
name|this
operator|.
name|data
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|dataLengthBuffer
operator|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|this
operator|.
name|socket
operator|=
name|channel
operator|.
name|socket
argument_list|()
expr_stmt|;
name|InetAddress
name|addr
init|=
name|socket
operator|.
name|getInetAddress
argument_list|()
decl_stmt|;
if|if
condition|(
name|addr
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|hostAddress
operator|=
literal|"*Unknown*"
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|hostAddress
operator|=
name|addr
operator|.
name|getHostAddress
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|remotePort
operator|=
name|socket
operator|.
name|getPort
argument_list|()
expr_stmt|;
name|this
operator|.
name|responseQueue
operator|=
operator|new
name|LinkedList
argument_list|<
name|Call
argument_list|>
argument_list|()
expr_stmt|;
if|if
condition|(
name|socketSendBufferSize
operator|!=
literal|0
condition|)
block|{
try|try
block|{
name|socket
operator|.
name|setSendBufferSize
argument_list|(
name|socketSendBufferSize
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Connection: unable to set socket send buffer size to "
operator|+
name|socketSendBufferSize
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getHostAddress
argument_list|()
operator|+
literal|":"
operator|+
name|remotePort
return|;
block|}
specifier|public
name|String
name|getHostAddress
parameter_list|()
block|{
return|return
name|hostAddress
return|;
block|}
specifier|public
name|int
name|getRemotePort
parameter_list|()
block|{
return|return
name|remotePort
return|;
block|}
specifier|public
name|void
name|setLastContact
parameter_list|(
name|long
name|lastContact
parameter_list|)
block|{
name|this
operator|.
name|lastContact
operator|=
name|lastContact
expr_stmt|;
block|}
specifier|public
name|long
name|getLastContact
parameter_list|()
block|{
return|return
name|lastContact
return|;
block|}
comment|/* Return true if the connection has no outstanding rpc */
specifier|private
name|boolean
name|isIdle
parameter_list|()
block|{
return|return
name|rpcCount
operator|==
literal|0
return|;
block|}
comment|/* Decrement the outstanding RPC count */
specifier|protected
name|void
name|decRpcCount
parameter_list|()
block|{
name|rpcCount
operator|--
expr_stmt|;
block|}
comment|/* Increment the outstanding RPC count */
specifier|protected
name|void
name|incRpcCount
parameter_list|()
block|{
name|rpcCount
operator|++
expr_stmt|;
block|}
specifier|protected
name|boolean
name|timedOut
parameter_list|(
name|long
name|currentTime
parameter_list|)
block|{
return|return
name|isIdle
argument_list|()
operator|&&
name|currentTime
operator|-
name|lastContact
operator|>
name|maxIdleTime
return|;
block|}
specifier|public
name|int
name|readAndProcess
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
while|while
condition|(
literal|true
condition|)
block|{
comment|/* Read at most one RPC. If the header is not read completely yet          * then iterate until we read first RPC or until there is no data left.          */
name|int
name|count
decl_stmt|;
if|if
condition|(
name|dataLengthBuffer
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
block|{
name|count
operator|=
name|channelRead
argument_list|(
name|channel
argument_list|,
name|dataLengthBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
argument_list|<
literal|0
operator|||
name|dataLengthBuffer
operator|.
name|remaining
operator|(
operator|)
argument_list|>
literal|0
condition|)
return|return
name|count
return|;
block|}
if|if
condition|(
operator|!
name|versionRead
condition|)
block|{
comment|//Every connection is expected to send the header.
name|ByteBuffer
name|versionBuffer
init|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|count
operator|=
name|channelRead
argument_list|(
name|channel
argument_list|,
name|versionBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
block|{
return|return
name|count
return|;
block|}
name|int
name|version
init|=
name|versionBuffer
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|dataLengthBuffer
operator|.
name|flip
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|HEADER
operator|.
name|equals
argument_list|(
name|dataLengthBuffer
argument_list|)
operator|||
name|version
operator|!=
name|CURRENT_VERSION
condition|)
block|{
comment|//Warning is ok since this is not supposed to happen.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Incorrect header or version mismatch from "
operator|+
name|hostAddress
operator|+
literal|":"
operator|+
name|remotePort
operator|+
literal|" got version "
operator|+
name|version
operator|+
literal|" expected version "
operator|+
name|CURRENT_VERSION
argument_list|)
expr_stmt|;
name|setupBadVersionResponse
argument_list|(
name|version
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|dataLengthBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|versionRead
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
name|dataLengthBuffer
operator|.
name|flip
argument_list|()
expr_stmt|;
name|dataLength
operator|=
name|dataLengthBuffer
operator|.
name|getInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|dataLength
operator|==
name|HBaseClient
operator|.
name|PING_CALL_ID
condition|)
block|{
name|dataLengthBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
comment|//ping message
block|}
name|data
operator|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|dataLength
argument_list|)
expr_stmt|;
name|incRpcCount
argument_list|()
expr_stmt|;
comment|// Increment the rpc count
block|}
name|count
operator|=
name|channelRead
argument_list|(
name|channel
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|remaining
argument_list|()
operator|==
literal|0
condition|)
block|{
name|dataLengthBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|data
operator|.
name|flip
argument_list|()
expr_stmt|;
if|if
condition|(
name|headerRead
condition|)
block|{
name|processData
argument_list|(
name|data
operator|.
name|array
argument_list|()
argument_list|)
expr_stmt|;
name|data
operator|=
literal|null
expr_stmt|;
return|return
name|count
return|;
block|}
name|processHeader
argument_list|()
expr_stmt|;
name|headerRead
operator|=
literal|true
expr_stmt|;
name|data
operator|=
literal|null
expr_stmt|;
continue|continue;
block|}
return|return
name|count
return|;
block|}
block|}
comment|/**      * Try to set up the response to indicate that the client version      * is incompatible with the server. This can contain special-case      * code to speak enough of past IPC protocols to pass back      * an exception to the caller.      * @param clientVersion the version the caller is using      * @throws IOException      */
specifier|private
name|void
name|setupBadVersionResponse
parameter_list|(
name|int
name|clientVersion
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|errMsg
init|=
literal|"Server IPC version "
operator|+
name|CURRENT_VERSION
operator|+
literal|" cannot communicate with client version "
operator|+
name|clientVersion
decl_stmt|;
name|ByteArrayOutputStream
name|buffer
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
if|if
condition|(
name|clientVersion
operator|>=
literal|3
condition|)
block|{
comment|// We used to return an id of -1 which caused server to close the
comment|// connection without telling the client what the problem was.  Now
comment|// we return 0 which will keep the socket up -- bad clients, unless
comment|// they switch to suit the running server -- will fail later doing
comment|// getProtocolVersion.
name|Call
name|fakeCall
init|=
operator|new
name|Call
argument_list|(
literal|0
argument_list|,
literal|null
argument_list|,
name|this
argument_list|,
name|responder
argument_list|)
decl_stmt|;
comment|// Versions 3 and greater can interpret this exception
comment|// response in the same manner
name|setupResponse
argument_list|(
name|buffer
argument_list|,
name|fakeCall
argument_list|,
name|Status
operator|.
name|FATAL
argument_list|,
literal|null
argument_list|,
name|VersionMismatch
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|,
name|errMsg
argument_list|)
expr_stmt|;
name|responder
operator|.
name|doRespond
argument_list|(
name|fakeCall
argument_list|)
expr_stmt|;
block|}
block|}
comment|/// Reads the connection header following version
specifier|private
name|void
name|processHeader
parameter_list|()
throws|throws
name|IOException
block|{
name|DataInputStream
name|in
init|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|data
operator|.
name|array
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|header
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
try|try
block|{
name|String
name|protocolClassName
init|=
name|header
operator|.
name|getProtocol
argument_list|()
decl_stmt|;
if|if
condition|(
name|protocolClassName
operator|==
literal|null
condition|)
block|{
name|protocolClassName
operator|=
literal|"org.apache.hadoop.hbase.ipc.HRegionInterface"
expr_stmt|;
block|}
name|protocol
operator|=
name|getProtocolClass
argument_list|(
name|protocolClassName
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|cnfe
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown protocol: "
operator|+
name|header
operator|.
name|getProtocol
argument_list|()
argument_list|)
throw|;
block|}
name|ticket
operator|=
name|header
operator|.
name|getUser
argument_list|()
expr_stmt|;
block|}
specifier|protected
name|void
name|processData
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|DataInputStream
name|dis
init|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|buf
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|id
init|=
name|dis
operator|.
name|readInt
argument_list|()
decl_stmt|;
comment|// try to read an id
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|" got call #"
operator|+
name|id
operator|+
literal|", "
operator|+
name|buf
operator|.
name|length
operator|+
literal|" bytes"
argument_list|)
expr_stmt|;
name|Writable
name|param
decl_stmt|;
try|try
block|{
name|param
operator|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|paramClass
argument_list|,
name|conf
argument_list|)
expr_stmt|;
comment|//read param
name|param
operator|.
name|readFields
argument_list|(
name|dis
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to read call parameters for client "
operator|+
name|getHostAddress
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
specifier|final
name|Call
name|readParamsFailedCall
init|=
operator|new
name|Call
argument_list|(
name|id
argument_list|,
literal|null
argument_list|,
name|this
argument_list|,
name|responder
argument_list|)
decl_stmt|;
name|ByteArrayOutputStream
name|responseBuffer
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|setupResponse
argument_list|(
name|responseBuffer
argument_list|,
name|readParamsFailedCall
argument_list|,
name|Status
operator|.
name|FATAL
argument_list|,
literal|null
argument_list|,
name|t
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
literal|"IPC server unable to read call parameters: "
operator|+
name|t
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|responder
operator|.
name|doRespond
argument_list|(
name|readParamsFailedCall
argument_list|)
expr_stmt|;
return|return;
block|}
name|Call
name|call
init|=
operator|new
name|Call
argument_list|(
name|id
argument_list|,
name|param
argument_list|,
name|this
argument_list|,
name|responder
argument_list|)
decl_stmt|;
if|if
condition|(
name|priorityCallQueue
operator|!=
literal|null
operator|&&
name|getQosLevel
argument_list|(
name|param
argument_list|)
operator|>
name|highPriorityLevel
condition|)
block|{
name|priorityCallQueue
operator|.
name|put
argument_list|(
name|call
argument_list|)
expr_stmt|;
name|updateCallQueueLenMetrics
argument_list|(
name|priorityCallQueue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|callQueue
operator|.
name|put
argument_list|(
name|call
argument_list|)
expr_stmt|;
comment|// queue the call; maybe blocked here
name|updateCallQueueLenMetrics
argument_list|(
name|callQueue
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
specifier|synchronized
name|void
name|close
parameter_list|()
block|{
name|data
operator|=
literal|null
expr_stmt|;
name|dataLengthBuffer
operator|=
literal|null
expr_stmt|;
if|if
condition|(
operator|!
name|channel
operator|.
name|isOpen
argument_list|()
condition|)
return|return;
try|try
block|{
name|socket
operator|.
name|shutdownOutput
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ignored
parameter_list|)
block|{}
comment|// FindBugs DE_MIGHT_IGNORE
if|if
condition|(
name|channel
operator|.
name|isOpen
argument_list|()
condition|)
block|{
try|try
block|{
name|channel
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ignored
parameter_list|)
block|{}
block|}
try|try
block|{
name|socket
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ignored
parameter_list|)
block|{}
block|}
block|}
comment|/**    * Reports length of the call queue to HBaseRpcMetrics.    * @param queue Which queue to report    */
specifier|private
name|void
name|updateCallQueueLenMetrics
parameter_list|(
name|BlockingQueue
argument_list|<
name|Call
argument_list|>
name|queue
parameter_list|)
block|{
if|if
condition|(
name|queue
operator|==
name|callQueue
condition|)
block|{
name|rpcMetrics
operator|.
name|callQueueLen
operator|.
name|set
argument_list|(
name|callQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|queue
operator|==
name|priorityCallQueue
condition|)
block|{
name|rpcMetrics
operator|.
name|priorityCallQueueLen
operator|.
name|set
argument_list|(
name|priorityCallQueue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unknown call queue"
argument_list|)
expr_stmt|;
block|}
name|rpcMetrics
operator|.
name|responseQueueLen
operator|.
name|set
argument_list|(
name|responseQueueLen
argument_list|)
expr_stmt|;
block|}
comment|/** Handles queued calls . */
specifier|private
class|class
name|Handler
extends|extends
name|Thread
block|{
specifier|private
specifier|final
name|BlockingQueue
argument_list|<
name|Call
argument_list|>
name|myCallQueue
decl_stmt|;
specifier|private
name|MonitoredRPCHandler
name|status
decl_stmt|;
specifier|public
name|Handler
parameter_list|(
specifier|final
name|BlockingQueue
argument_list|<
name|Call
argument_list|>
name|cq
parameter_list|,
name|int
name|instanceNumber
parameter_list|)
block|{
name|this
operator|.
name|myCallQueue
operator|=
name|cq
expr_stmt|;
name|this
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|String
name|threadName
init|=
literal|"IPC Server handler "
operator|+
name|instanceNumber
operator|+
literal|" on "
operator|+
name|port
decl_stmt|;
if|if
condition|(
name|cq
operator|==
name|priorityCallQueue
condition|)
block|{
comment|// this is just an amazing hack, but it works.
name|threadName
operator|=
literal|"PRI "
operator|+
name|threadName
expr_stmt|;
block|}
name|this
operator|.
name|setName
argument_list|(
name|threadName
argument_list|)
expr_stmt|;
name|this
operator|.
name|status
operator|=
name|TaskMonitor
operator|.
name|get
argument_list|()
operator|.
name|createRPCStatus
argument_list|(
name|threadName
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": starting"
argument_list|)
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"starting"
argument_list|)
expr_stmt|;
name|SERVER
operator|.
name|set
argument_list|(
name|HBaseServer
operator|.
name|this
argument_list|)
expr_stmt|;
while|while
condition|(
name|running
condition|)
block|{
try|try
block|{
name|status
operator|.
name|pause
argument_list|(
literal|"Waiting for a call"
argument_list|)
expr_stmt|;
name|Call
name|call
init|=
name|myCallQueue
operator|.
name|take
argument_list|()
decl_stmt|;
comment|// pop the queue; maybe blocked here
name|updateCallQueueLenMetrics
argument_list|(
name|myCallQueue
argument_list|)
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Setting up call"
argument_list|)
expr_stmt|;
name|status
operator|.
name|setConnection
argument_list|(
name|call
operator|.
name|connection
operator|.
name|getHostAddress
argument_list|()
argument_list|,
name|call
operator|.
name|connection
operator|.
name|getRemotePort
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|": has #"
operator|+
name|call
operator|.
name|id
operator|+
literal|" from "
operator|+
name|call
operator|.
name|connection
argument_list|)
expr_stmt|;
name|String
name|errorClass
init|=
literal|null
decl_stmt|;
name|String
name|error
init|=
literal|null
decl_stmt|;
name|Writable
name|value
init|=
literal|null
decl_stmt|;
name|CurCall
operator|.
name|set
argument_list|(
name|call
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|started
condition|)
throw|throw
operator|new
name|ServerNotRunningYetException
argument_list|(
literal|"Server is not running yet"
argument_list|)
throw|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|User
name|remoteUser
init|=
name|call
operator|.
name|connection
operator|.
name|ticket
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|": call #"
operator|+
name|call
operator|.
name|id
operator|+
literal|" executing as "
operator|+
operator|(
name|remoteUser
operator|==
literal|null
condition|?
literal|"NULL principal"
else|:
name|remoteUser
operator|.
name|getName
argument_list|()
operator|)
argument_list|)
expr_stmt|;
block|}
name|RequestContext
operator|.
name|set
argument_list|(
name|call
operator|.
name|connection
operator|.
name|ticket
argument_list|,
name|getRemoteIp
argument_list|()
argument_list|,
name|call
operator|.
name|connection
operator|.
name|protocol
argument_list|)
expr_stmt|;
comment|// make the call
name|value
operator|=
name|call
argument_list|(
name|call
operator|.
name|connection
operator|.
name|protocol
argument_list|,
name|call
operator|.
name|param
argument_list|,
name|call
operator|.
name|timestamp
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|", call "
operator|+
name|call
operator|+
literal|": error: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|errorClass
operator|=
name|e
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
name|error
operator|=
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// Must always clear the request context to avoid leaking
comment|// credentials between requests.
name|RequestContext
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|CurCall
operator|.
name|set
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// Set the response for undelayed calls and delayed calls with
comment|// undelayed responses.
if|if
condition|(
operator|!
name|call
operator|.
name|isDelayed
argument_list|()
operator|||
operator|!
name|call
operator|.
name|isReturnValueDelayed
argument_list|()
condition|)
block|{
name|call
operator|.
name|setResponse
argument_list|(
name|value
argument_list|,
name|errorClass
operator|==
literal|null
condition|?
name|Status
operator|.
name|SUCCESS
else|:
name|Status
operator|.
name|ERROR
argument_list|,
name|errorClass
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|call
operator|.
name|sendResponseIfReady
argument_list|()
expr_stmt|;
name|status
operator|.
name|markComplete
argument_list|(
literal|"Sent response"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
if|if
condition|(
name|running
condition|)
block|{
comment|// unexpected -- log it
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|" caught: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|OutOfMemoryError
name|e
parameter_list|)
block|{
if|if
condition|(
name|errorHandler
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|errorHandler
operator|.
name|checkOOME
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": exiting on OOME"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|// rethrow if no handler
throw|throw
name|e
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|ClosedChannelException
name|cce
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|getName
argument_list|()
operator|+
literal|" caught a ClosedChannelException, "
operator|+
literal|"this means that the server was processing a "
operator|+
literal|"request but the client went away. The error message was: "
operator|+
name|cce
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|getName
argument_list|()
operator|+
literal|" caught: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|": exiting"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|Function
argument_list|<
name|Writable
argument_list|,
name|Integer
argument_list|>
name|qosFunction
init|=
literal|null
decl_stmt|;
comment|/**    * Gets the QOS level for this call.  If it is higher than the highPriorityLevel and there    * are priorityHandlers available it will be processed in it's own thread set.    *    * @param newFunc    */
annotation|@
name|Override
specifier|public
name|void
name|setQosFunction
parameter_list|(
name|Function
argument_list|<
name|Writable
argument_list|,
name|Integer
argument_list|>
name|newFunc
parameter_list|)
block|{
name|qosFunction
operator|=
name|newFunc
expr_stmt|;
block|}
specifier|protected
name|int
name|getQosLevel
parameter_list|(
name|Writable
name|param
parameter_list|)
block|{
if|if
condition|(
name|qosFunction
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
name|Integer
name|res
init|=
name|qosFunction
operator|.
name|apply
argument_list|(
name|param
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|res
return|;
block|}
comment|/* Constructs a server listening on the named port and address.  Parameters passed must    * be of the named class.  The<code>handlerCount</handlerCount> determines    * the number of handler threads that will be used to process calls.    *    */
specifier|protected
name|HBaseServer
parameter_list|(
name|String
name|bindAddress
parameter_list|,
name|int
name|port
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Writable
argument_list|>
name|paramClass
parameter_list|,
name|int
name|handlerCount
parameter_list|,
name|int
name|priorityHandlerCount
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|String
name|serverName
parameter_list|,
name|int
name|highPriorityLevel
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|bindAddress
operator|=
name|bindAddress
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|port
operator|=
name|port
expr_stmt|;
name|this
operator|.
name|paramClass
operator|=
name|paramClass
expr_stmt|;
name|this
operator|.
name|handlerCount
operator|=
name|handlerCount
expr_stmt|;
name|this
operator|.
name|priorityHandlerCount
operator|=
name|priorityHandlerCount
expr_stmt|;
name|this
operator|.
name|socketSendBufferSize
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|maxQueueSize
operator|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"ipc.server.max.queue.size"
argument_list|,
name|handlerCount
operator|*
name|DEFAULT_MAX_QUEUE_SIZE_PER_HANDLER
argument_list|)
expr_stmt|;
name|this
operator|.
name|readThreads
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"ipc.server.read.threadpool.size"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|this
operator|.
name|callQueue
operator|=
operator|new
name|LinkedBlockingQueue
argument_list|<
name|Call
argument_list|>
argument_list|(
name|maxQueueSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|priorityHandlerCount
operator|>
literal|0
condition|)
block|{
name|this
operator|.
name|priorityCallQueue
operator|=
operator|new
name|LinkedBlockingQueue
argument_list|<
name|Call
argument_list|>
argument_list|(
name|maxQueueSize
argument_list|)
expr_stmt|;
comment|// TODO hack on size
block|}
else|else
block|{
name|this
operator|.
name|priorityCallQueue
operator|=
literal|null
expr_stmt|;
block|}
name|this
operator|.
name|highPriorityLevel
operator|=
name|highPriorityLevel
expr_stmt|;
name|this
operator|.
name|maxIdleTime
operator|=
literal|2
operator|*
name|conf
operator|.
name|getInt
argument_list|(
literal|"ipc.client.connection.maxidletime"
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxConnectionsToNuke
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"ipc.client.kill.max"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|this
operator|.
name|thresholdIdleConnections
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"ipc.client.idlethreshold"
argument_list|,
literal|4000
argument_list|)
expr_stmt|;
comment|// Start the listener here and let it bind to the port
name|listener
operator|=
operator|new
name|Listener
argument_list|()
expr_stmt|;
name|this
operator|.
name|port
operator|=
name|listener
operator|.
name|getAddress
argument_list|()
operator|.
name|getPort
argument_list|()
expr_stmt|;
name|this
operator|.
name|rpcMetrics
operator|=
operator|new
name|HBaseRpcMetrics
argument_list|(
name|serverName
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|this
operator|.
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|tcpNoDelay
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"ipc.server.tcpnodelay"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|tcpKeepAlive
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"ipc.server.tcpkeepalive"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|warnDelayedCalls
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|WARN_DELAYED_CALLS
argument_list|,
name|DEFAULT_WARN_DELAYED_CALLS
argument_list|)
expr_stmt|;
name|this
operator|.
name|delayedCalls
operator|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// Create the responder here
name|responder
operator|=
operator|new
name|Responder
argument_list|()
expr_stmt|;
block|}
comment|/**    * Subclasses of HBaseServer can override this to provide their own    * Connection implementations.    */
specifier|protected
name|Connection
name|getConnection
parameter_list|(
name|SocketChannel
name|channel
parameter_list|,
name|long
name|time
parameter_list|)
block|{
return|return
operator|new
name|Connection
argument_list|(
name|channel
argument_list|,
name|time
argument_list|)
return|;
block|}
comment|/**    * Setup response for the IPC Call.    *    * @param response buffer to serialize the response into    * @param call {@link Call} to which we are setting up the response    * @param status {@link Status} of the IPC call    * @param rv return value for the IPC Call, if the call was successful    * @param errorClass error class, if the the call failed    * @param error error message, if the call failed    * @throws IOException    */
specifier|private
name|void
name|setupResponse
parameter_list|(
name|ByteArrayOutputStream
name|response
parameter_list|,
name|Call
name|call
parameter_list|,
name|Status
name|status
parameter_list|,
name|Writable
name|rv
parameter_list|,
name|String
name|errorClass
parameter_list|,
name|String
name|error
parameter_list|)
throws|throws
name|IOException
block|{
name|response
operator|.
name|reset
argument_list|()
expr_stmt|;
name|DataOutputStream
name|out
init|=
operator|new
name|DataOutputStream
argument_list|(
name|response
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|==
name|Status
operator|.
name|SUCCESS
condition|)
block|{
try|try
block|{
name|rv
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|call
operator|.
name|setResponse
argument_list|(
name|rv
argument_list|,
name|status
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error serializing call response for call "
operator|+
name|call
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|// Call back to same function - this is OK since the
comment|// buffer is reset at the top, and since status is changed
comment|// to ERROR it won't infinite loop.
name|call
operator|.
name|setResponse
argument_list|(
literal|null
argument_list|,
name|status
operator|.
name|ERROR
argument_list|,
name|t
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|call
operator|.
name|setResponse
argument_list|(
name|rv
argument_list|,
name|status
argument_list|,
name|errorClass
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|closeConnection
parameter_list|(
name|Connection
name|connection
parameter_list|)
block|{
synchronized|synchronized
init|(
name|connectionList
init|)
block|{
if|if
condition|(
name|connectionList
operator|.
name|remove
argument_list|(
name|connection
argument_list|)
condition|)
block|{
name|numConnections
operator|--
expr_stmt|;
block|}
block|}
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
name|rpcMetrics
operator|.
name|numOpenConnections
operator|.
name|set
argument_list|(
name|numConnections
argument_list|)
expr_stmt|;
block|}
comment|/** Sets the socket buffer size used for responding to RPCs.    * @param size send size    */
annotation|@
name|Override
specifier|public
name|void
name|setSocketSendBufSize
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|this
operator|.
name|socketSendBufferSize
operator|=
name|size
expr_stmt|;
block|}
comment|/** Starts the service.  Must be called before any calls will be handled. */
annotation|@
name|Override
specifier|public
name|void
name|start
parameter_list|()
block|{
name|startThreads
argument_list|()
expr_stmt|;
name|openServer
argument_list|()
expr_stmt|;
block|}
comment|/**    * Open a previously started server.    */
annotation|@
name|Override
specifier|public
name|void
name|openServer
parameter_list|()
block|{
name|started
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * Starts the service threads but does not allow requests to be responded yet.    * Client will get {@link ServerNotRunningYetException} instead.    */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|startThreads
parameter_list|()
block|{
name|responder
operator|.
name|start
argument_list|()
expr_stmt|;
name|listener
operator|.
name|start
argument_list|()
expr_stmt|;
name|handlers
operator|=
operator|new
name|Handler
index|[
name|handlerCount
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|handlerCount
condition|;
name|i
operator|++
control|)
block|{
name|handlers
index|[
name|i
index|]
operator|=
operator|new
name|Handler
argument_list|(
name|callQueue
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|handlers
index|[
name|i
index|]
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|priorityHandlerCount
operator|>
literal|0
condition|)
block|{
name|priorityHandlers
operator|=
operator|new
name|Handler
index|[
name|priorityHandlerCount
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|priorityHandlerCount
condition|;
name|i
operator|++
control|)
block|{
name|priorityHandlers
index|[
name|i
index|]
operator|=
operator|new
name|Handler
argument_list|(
name|priorityCallQueue
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|priorityHandlers
index|[
name|i
index|]
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/** Stops the service.  No new calls will be handled after this is called. */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|stop
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping server on "
operator|+
name|port
argument_list|)
expr_stmt|;
name|running
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|handlers
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Handler
name|handler
range|:
name|handlers
control|)
block|{
if|if
condition|(
name|handler
operator|!=
literal|null
condition|)
block|{
name|handler
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|priorityHandlers
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Handler
name|handler
range|:
name|priorityHandlers
control|)
block|{
if|if
condition|(
name|handler
operator|!=
literal|null
condition|)
block|{
name|handler
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|listener
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|listener
operator|.
name|doStop
argument_list|()
expr_stmt|;
name|responder
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|rpcMetrics
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|rpcMetrics
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Wait for the server to be stopped.    * Does not wait for all subthreads to finish.    *  See {@link #stop()}.    * @throws InterruptedException e    */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|join
parameter_list|()
throws|throws
name|InterruptedException
block|{
while|while
condition|(
name|running
condition|)
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Return the socket (ip+port) on which the RPC server is listening to.    * @return the socket (ip+port) on which the RPC server is listening to.    */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|InetSocketAddress
name|getListenerAddress
parameter_list|()
block|{
return|return
name|listener
operator|.
name|getAddress
argument_list|()
return|;
block|}
comment|/**    * Set the handler for calling out of RPC for error conditions.    * @param handler the handler implementation    */
annotation|@
name|Override
specifier|public
name|void
name|setErrorHandler
parameter_list|(
name|HBaseRPCErrorHandler
name|handler
parameter_list|)
block|{
name|this
operator|.
name|errorHandler
operator|=
name|handler
expr_stmt|;
block|}
comment|/**    * Returns the metrics instance for reporting RPC call statistics    */
specifier|public
name|HBaseRpcMetrics
name|getRpcMetrics
parameter_list|()
block|{
return|return
name|rpcMetrics
return|;
block|}
comment|/**    * When the read or write buffer size is larger than this limit, i/o will be    * done in chunks of this size. Most RPC requests and responses would be    * be smaller.    */
specifier|private
specifier|static
name|int
name|NIO_BUFFER_LIMIT
init|=
literal|8
operator|*
literal|1024
decl_stmt|;
comment|//should not be more than 64KB.
comment|/**    * This is a wrapper around {@link java.nio.channels.WritableByteChannel#write(java.nio.ByteBuffer)}.    * If the amount of data is large, it writes to channel in smaller chunks.    * This is to avoid jdk from creating many direct buffers as the size of    * buffer increases. This also minimizes extra copies in NIO layer    * as a result of multiple write operations required to write a large    * buffer.    *    * @param channel writable byte channel to write to    * @param buffer buffer to write    * @return number of bytes written    * @throws java.io.IOException e    * @see java.nio.channels.WritableByteChannel#write(java.nio.ByteBuffer)    */
specifier|protected
name|int
name|channelWrite
parameter_list|(
name|WritableByteChannel
name|channel
parameter_list|,
name|ByteBuffer
name|buffer
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|count
init|=
operator|(
name|buffer
operator|.
name|remaining
argument_list|()
operator|<=
name|NIO_BUFFER_LIMIT
operator|)
condition|?
name|channel
operator|.
name|write
argument_list|(
name|buffer
argument_list|)
else|:
name|channelIO
argument_list|(
literal|null
argument_list|,
name|channel
argument_list|,
name|buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|rpcMetrics
operator|.
name|sentBytes
operator|.
name|inc
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
comment|/**    * This is a wrapper around {@link java.nio.channels.ReadableByteChannel#read(java.nio.ByteBuffer)}.    * If the amount of data is large, it writes to channel in smaller chunks.    * This is to avoid jdk from creating many direct buffers as the size of    * ByteBuffer increases. There should not be any performance degredation.    *    * @param channel writable byte channel to write on    * @param buffer buffer to write    * @return number of bytes written    * @throws java.io.IOException e    * @see java.nio.channels.ReadableByteChannel#read(java.nio.ByteBuffer)    */
specifier|protected
name|int
name|channelRead
parameter_list|(
name|ReadableByteChannel
name|channel
parameter_list|,
name|ByteBuffer
name|buffer
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|count
init|=
operator|(
name|buffer
operator|.
name|remaining
argument_list|()
operator|<=
name|NIO_BUFFER_LIMIT
operator|)
condition|?
name|channel
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
else|:
name|channelIO
argument_list|(
name|channel
argument_list|,
literal|null
argument_list|,
name|buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|rpcMetrics
operator|.
name|receivedBytes
operator|.
name|inc
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
comment|/**    * Helper for {@link #channelRead(java.nio.channels.ReadableByteChannel, java.nio.ByteBuffer)}    * and {@link #channelWrite(java.nio.channels.WritableByteChannel, java.nio.ByteBuffer)}. Only    * one of readCh or writeCh should be non-null.    *    * @param readCh read channel    * @param writeCh write channel    * @param buf buffer to read or write into/out of    * @return bytes written    * @throws java.io.IOException e    * @see #channelRead(java.nio.channels.ReadableByteChannel, java.nio.ByteBuffer)    * @see #channelWrite(java.nio.channels.WritableByteChannel, java.nio.ByteBuffer)    */
specifier|private
specifier|static
name|int
name|channelIO
parameter_list|(
name|ReadableByteChannel
name|readCh
parameter_list|,
name|WritableByteChannel
name|writeCh
parameter_list|,
name|ByteBuffer
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|originalLimit
init|=
name|buf
operator|.
name|limit
argument_list|()
decl_stmt|;
name|int
name|initialRemaining
init|=
name|buf
operator|.
name|remaining
argument_list|()
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|buf
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|int
name|ioSize
init|=
name|Math
operator|.
name|min
argument_list|(
name|buf
operator|.
name|remaining
argument_list|()
argument_list|,
name|NIO_BUFFER_LIMIT
argument_list|)
decl_stmt|;
name|buf
operator|.
name|limit
argument_list|(
name|buf
operator|.
name|position
argument_list|()
operator|+
name|ioSize
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|readCh
operator|==
literal|null
operator|)
condition|?
name|writeCh
operator|.
name|write
argument_list|(
name|buf
argument_list|)
else|:
name|readCh
operator|.
name|read
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
name|ioSize
condition|)
block|{
break|break;
block|}
block|}
finally|finally
block|{
name|buf
operator|.
name|limit
argument_list|(
name|originalLimit
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|nBytes
init|=
name|initialRemaining
operator|-
name|buf
operator|.
name|remaining
argument_list|()
decl_stmt|;
return|return
operator|(
name|nBytes
operator|>
literal|0
operator|)
condition|?
name|nBytes
else|:
name|ret
return|;
block|}
specifier|public
name|Delayable
name|getCurrentCall
parameter_list|()
block|{
return|return
name|CurCall
operator|.
name|get
argument_list|()
return|;
block|}
block|}
end_class

end_unit

