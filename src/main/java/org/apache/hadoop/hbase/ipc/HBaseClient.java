begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2010 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilterInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|ConnectException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Socket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketTimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentSkipListMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|net
operator|.
name|SocketFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|User
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|PoolMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|PoolMap
operator|.
name|PoolType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|DataOutputBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_comment
comment|/** A client for an IPC service.  IPC calls take a single {@link Writable} as a  * parameter, and return a {@link Writable} as their value.  A service runs on  * a port and is defined by a parameter class and a value class.  *  *<p>This is the org.apache.hadoop.ipc.Client renamed as HBaseClient and  * moved into this package so can access package-private methods.  *  * @see HBaseServer  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|HBaseClient
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
literal|"org.apache.hadoop.ipc.HBaseClient"
argument_list|)
decl_stmt|;
specifier|protected
specifier|final
name|PoolMap
argument_list|<
name|ConnectionId
argument_list|,
name|Connection
argument_list|>
name|connections
decl_stmt|;
specifier|protected
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|Writable
argument_list|>
name|valueClass
decl_stmt|;
comment|// class of call values
specifier|protected
name|int
name|counter
decl_stmt|;
comment|// counter for call ids
specifier|protected
specifier|final
name|AtomicBoolean
name|running
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|// if client runs
specifier|final
specifier|protected
name|Configuration
name|conf
decl_stmt|;
specifier|final
specifier|protected
name|int
name|maxIdleTime
decl_stmt|;
comment|// connections will be culled if it was idle for
comment|// maxIdleTime microsecs
specifier|final
specifier|protected
name|int
name|maxRetries
decl_stmt|;
comment|//the max. no. of retries for socket connections
specifier|final
specifier|protected
name|long
name|failureSleep
decl_stmt|;
comment|// Time to sleep before retry on failure.
specifier|protected
specifier|final
name|boolean
name|tcpNoDelay
decl_stmt|;
comment|// if T then disable Nagle's Algorithm
specifier|protected
specifier|final
name|boolean
name|tcpKeepAlive
decl_stmt|;
comment|// if T then use keepalives
specifier|protected
name|int
name|pingInterval
decl_stmt|;
comment|// how often sends ping to the server in msecs
specifier|protected
name|int
name|socketTimeout
decl_stmt|;
comment|// socket timeout
specifier|protected
specifier|final
name|SocketFactory
name|socketFactory
decl_stmt|;
comment|// how to create sockets
specifier|private
name|int
name|refCount
init|=
literal|1
decl_stmt|;
specifier|protected
name|String
name|clusterId
decl_stmt|;
specifier|final
specifier|private
specifier|static
name|String
name|PING_INTERVAL_NAME
init|=
literal|"ipc.ping.interval"
decl_stmt|;
specifier|final
specifier|private
specifier|static
name|String
name|SOCKET_TIMEOUT
init|=
literal|"ipc.socket.timeout"
decl_stmt|;
specifier|final
specifier|static
name|int
name|DEFAULT_PING_INTERVAL
init|=
literal|60000
decl_stmt|;
comment|// 1 min
specifier|final
specifier|static
name|int
name|DEFAULT_SOCKET_TIMEOUT
init|=
literal|20000
decl_stmt|;
comment|// 20 seconds
specifier|final
specifier|static
name|int
name|PING_CALL_ID
init|=
operator|-
literal|1
decl_stmt|;
comment|/**    * set the ping interval value in configuration    *    * @param conf Configuration    * @param pingInterval the ping interval    */
specifier|public
specifier|static
name|void
name|setPingInterval
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|int
name|pingInterval
parameter_list|)
block|{
name|conf
operator|.
name|setInt
argument_list|(
name|PING_INTERVAL_NAME
argument_list|,
name|pingInterval
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the ping interval from configuration;    * If not set in the configuration, return the default value.    *    * @param conf Configuration    * @return the ping interval    */
specifier|static
name|int
name|getPingInterval
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|getInt
argument_list|(
name|PING_INTERVAL_NAME
argument_list|,
name|DEFAULT_PING_INTERVAL
argument_list|)
return|;
block|}
comment|/**    * Set the socket timeout    * @param conf Configuration    * @param socketTimeout the socket timeout    */
specifier|public
specifier|static
name|void
name|setSocketTimeout
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|int
name|socketTimeout
parameter_list|)
block|{
name|conf
operator|.
name|setInt
argument_list|(
name|SOCKET_TIMEOUT
argument_list|,
name|socketTimeout
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return the socket timeout    */
specifier|static
name|int
name|getSocketTimeout
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|getInt
argument_list|(
name|SOCKET_TIMEOUT
argument_list|,
name|DEFAULT_SOCKET_TIMEOUT
argument_list|)
return|;
block|}
comment|/**    * Increment this client's reference count    *    */
specifier|synchronized
name|void
name|incCount
parameter_list|()
block|{
name|refCount
operator|++
expr_stmt|;
block|}
comment|/**    * Decrement this client's reference count    *    */
specifier|synchronized
name|void
name|decCount
parameter_list|()
block|{
name|refCount
operator|--
expr_stmt|;
block|}
comment|/**    * Return if this client has no reference    *    * @return true if this client has no reference; false otherwise    */
specifier|synchronized
name|boolean
name|isZeroReference
parameter_list|()
block|{
return|return
name|refCount
operator|==
literal|0
return|;
block|}
comment|/** A call waiting for a value. */
specifier|protected
class|class
name|Call
block|{
specifier|final
name|int
name|id
decl_stmt|;
comment|// call id
specifier|final
name|Writable
name|param
decl_stmt|;
comment|// parameter
name|Writable
name|value
decl_stmt|;
comment|// value, null if error
name|IOException
name|error
decl_stmt|;
comment|// exception, null if value
name|boolean
name|done
decl_stmt|;
comment|// true when call is done
name|long
name|startTime
decl_stmt|;
specifier|protected
name|Call
parameter_list|(
name|Writable
name|param
parameter_list|)
block|{
name|this
operator|.
name|param
operator|=
name|param
expr_stmt|;
name|this
operator|.
name|startTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|HBaseClient
operator|.
name|this
init|)
block|{
name|this
operator|.
name|id
operator|=
name|counter
operator|++
expr_stmt|;
block|}
block|}
comment|/** Indicate when the call is complete and the      * value or error are available.  Notifies by default.  */
specifier|protected
specifier|synchronized
name|void
name|callComplete
parameter_list|()
block|{
name|this
operator|.
name|done
operator|=
literal|true
expr_stmt|;
name|notify
argument_list|()
expr_stmt|;
comment|// notify caller
block|}
comment|/** Set the exception when there is an error.      * Notify the caller the call is done.      *      * @param error exception thrown by the call; either local or remote      */
specifier|public
specifier|synchronized
name|void
name|setException
parameter_list|(
name|IOException
name|error
parameter_list|)
block|{
name|this
operator|.
name|error
operator|=
name|error
expr_stmt|;
name|callComplete
argument_list|()
expr_stmt|;
block|}
comment|/** Set the return value when there is no error.      * Notify the caller the call is done.      *      * @param value return value of the call.      */
specifier|public
specifier|synchronized
name|void
name|setValue
parameter_list|(
name|Writable
name|value
parameter_list|)
block|{
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|callComplete
argument_list|()
expr_stmt|;
block|}
specifier|public
name|long
name|getStartTime
parameter_list|()
block|{
return|return
name|this
operator|.
name|startTime
return|;
block|}
block|}
comment|/** Thread that reads responses and notifies callers.  Each connection owns a    * socket connected to a remote address.  Calls are multiplexed through this    * socket: responses may be delivered out of order. */
specifier|protected
class|class
name|Connection
extends|extends
name|Thread
block|{
specifier|private
name|ConnectionHeader
name|header
decl_stmt|;
comment|// connection header
specifier|protected
name|ConnectionId
name|remoteId
decl_stmt|;
specifier|protected
name|Socket
name|socket
init|=
literal|null
decl_stmt|;
comment|// connected socket
specifier|protected
name|DataInputStream
name|in
decl_stmt|;
specifier|protected
name|DataOutputStream
name|out
decl_stmt|;
comment|// currently active calls
specifier|protected
specifier|final
name|ConcurrentSkipListMap
argument_list|<
name|Integer
argument_list|,
name|Call
argument_list|>
name|calls
init|=
operator|new
name|ConcurrentSkipListMap
argument_list|<
name|Integer
argument_list|,
name|Call
argument_list|>
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|AtomicLong
name|lastActivity
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
comment|// last I/O activity time
specifier|protected
specifier|final
name|AtomicBoolean
name|shouldCloseConnection
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
comment|// indicate if the connection is closed
specifier|protected
name|IOException
name|closeException
decl_stmt|;
comment|// close reason
specifier|public
name|Connection
parameter_list|(
name|ConnectionId
name|remoteId
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|remoteId
operator|.
name|getAddress
argument_list|()
operator|.
name|isUnresolved
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnknownHostException
argument_list|(
literal|"unknown host: "
operator|+
name|remoteId
operator|.
name|getAddress
argument_list|()
operator|.
name|getHostName
argument_list|()
argument_list|)
throw|;
block|}
name|this
operator|.
name|remoteId
operator|=
name|remoteId
expr_stmt|;
name|User
name|ticket
init|=
name|remoteId
operator|.
name|getTicket
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|VersionedProtocol
argument_list|>
name|protocol
init|=
name|remoteId
operator|.
name|getProtocol
argument_list|()
decl_stmt|;
name|header
operator|=
operator|new
name|ConnectionHeader
argument_list|(
name|protocol
operator|==
literal|null
condition|?
literal|null
else|:
name|protocol
operator|.
name|getName
argument_list|()
argument_list|,
name|ticket
argument_list|)
expr_stmt|;
name|this
operator|.
name|setName
argument_list|(
literal|"IPC Client ("
operator|+
name|socketFactory
operator|.
name|hashCode
argument_list|()
operator|+
literal|") connection to "
operator|+
name|remoteId
operator|.
name|getAddress
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
operator|(
operator|(
name|ticket
operator|==
literal|null
operator|)
condition|?
literal|" from an unknown user"
else|:
operator|(
literal|" from "
operator|+
name|ticket
operator|.
name|getName
argument_list|()
operator|)
operator|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/** Update lastActivity with the current time. */
specifier|protected
name|void
name|touch
parameter_list|()
block|{
name|lastActivity
operator|.
name|set
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add a call to this connection's call queue and notify      * a listener; synchronized.      * Returns false if called during shutdown.      * @param call to add      * @return true if the call was added.      */
specifier|protected
specifier|synchronized
name|boolean
name|addCall
parameter_list|(
name|Call
name|call
parameter_list|)
block|{
if|if
condition|(
name|shouldCloseConnection
operator|.
name|get
argument_list|()
condition|)
return|return
literal|false
return|;
name|calls
operator|.
name|put
argument_list|(
name|call
operator|.
name|id
argument_list|,
name|call
argument_list|)
expr_stmt|;
name|notify
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/** This class sends a ping to the remote side when timeout on      * reading. If no failure is detected, it retries until at least      * a byte is read.      */
specifier|protected
class|class
name|PingInputStream
extends|extends
name|FilterInputStream
block|{
comment|/* constructor */
specifier|protected
name|PingInputStream
parameter_list|(
name|InputStream
name|in
parameter_list|)
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
comment|/* Process timeout exception        * if the connection is not going to be closed, send a ping.        * otherwise, throw the timeout exception.        */
specifier|private
name|void
name|handleTimeout
parameter_list|(
name|SocketTimeoutException
name|e
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|shouldCloseConnection
operator|.
name|get
argument_list|()
operator|||
operator|!
name|running
operator|.
name|get
argument_list|()
operator|||
name|remoteId
operator|.
name|rpcTimeout
operator|>
literal|0
condition|)
block|{
throw|throw
name|e
throw|;
block|}
name|sendPing
argument_list|()
expr_stmt|;
block|}
comment|/** Read a byte from the stream.        * Send a ping if timeout on read. Retries if no failure is detected        * until a byte is read.        * @throws IOException for any IO problem other than socket timeout        */
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
do|do
block|{
try|try
block|{
return|return
name|super
operator|.
name|read
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SocketTimeoutException
name|e
parameter_list|)
block|{
name|handleTimeout
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
literal|true
condition|)
do|;
block|}
comment|/** Read bytes into a buffer starting from offset<code>off</code>        * Send a ping if timeout on read. Retries if no failure is detected        * until a byte is read.        *        * @return the total number of bytes read; -1 if the connection is closed.        */
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
do|do
block|{
try|try
block|{
return|return
name|super
operator|.
name|read
argument_list|(
name|buf
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SocketTimeoutException
name|e
parameter_list|)
block|{
name|handleTimeout
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
literal|true
condition|)
do|;
block|}
block|}
specifier|protected
specifier|synchronized
name|void
name|setupConnection
parameter_list|()
throws|throws
name|IOException
block|{
name|short
name|ioFailures
init|=
literal|0
decl_stmt|;
name|short
name|timeoutFailures
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|this
operator|.
name|socket
operator|=
name|socketFactory
operator|.
name|createSocket
argument_list|()
expr_stmt|;
name|this
operator|.
name|socket
operator|.
name|setTcpNoDelay
argument_list|(
name|tcpNoDelay
argument_list|)
expr_stmt|;
name|this
operator|.
name|socket
operator|.
name|setKeepAlive
argument_list|(
name|tcpKeepAlive
argument_list|)
expr_stmt|;
comment|// connection time out is 20s
name|NetUtils
operator|.
name|connect
argument_list|(
name|this
operator|.
name|socket
argument_list|,
name|remoteId
operator|.
name|getAddress
argument_list|()
argument_list|,
name|getSocketTimeout
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|remoteId
operator|.
name|rpcTimeout
operator|>
literal|0
condition|)
block|{
name|pingInterval
operator|=
name|remoteId
operator|.
name|rpcTimeout
expr_stmt|;
comment|// overwrite pingInterval
block|}
name|this
operator|.
name|socket
operator|.
name|setSoTimeout
argument_list|(
name|pingInterval
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|SocketTimeoutException
name|toe
parameter_list|)
block|{
comment|/* The max number of retries is 45,            * which amounts to 20s*45 = 15 minutes retries.            */
name|handleConnectionFailure
argument_list|(
name|timeoutFailures
operator|++
argument_list|,
name|maxRetries
argument_list|,
name|toe
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|handleConnectionFailure
argument_list|(
name|ioFailures
operator|++
argument_list|,
name|maxRetries
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Connect to the server and set up the I/O streams. It then sends      * a header to the server and starts      * the connection thread that waits for responses.      * @throws java.io.IOException e      */
specifier|protected
specifier|synchronized
name|void
name|setupIOstreams
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|socket
operator|!=
literal|null
operator|||
name|shouldCloseConnection
operator|.
name|get
argument_list|()
condition|)
block|{
return|return;
block|}
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Connecting to "
operator|+
name|remoteId
argument_list|)
expr_stmt|;
block|}
name|setupConnection
argument_list|()
expr_stmt|;
name|this
operator|.
name|in
operator|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
operator|new
name|PingInputStream
argument_list|(
name|NetUtils
operator|.
name|getInputStream
argument_list|(
name|socket
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|out
operator|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|NetUtils
operator|.
name|getOutputStream
argument_list|(
name|socket
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|writeHeader
argument_list|()
expr_stmt|;
comment|// update last activity time
name|touch
argument_list|()
expr_stmt|;
comment|// start the receiver thread after the socket connection has been set up
name|start
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|markClosed
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
specifier|protected
name|void
name|closeConnection
parameter_list|()
block|{
comment|// close the current connection
if|if
condition|(
name|socket
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|socket
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Not able to close a socket"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|// set socket to null so that the next call to setupIOstreams
comment|// can start the process of connect all over again.
name|socket
operator|=
literal|null
expr_stmt|;
block|}
comment|/**      *  Handle connection failures      *      * If the current number of retries is equal to the max number of retries,      * stop retrying and throw the exception; Otherwise backoff N seconds and      * try connecting again.      *      * This Method is only called from inside setupIOstreams(), which is      * synchronized. Hence the sleep is synchronized; the locks will be retained.      *      * @param curRetries current number of retries      * @param maxRetries max number of retries allowed      * @param ioe failure reason      * @throws IOException if max number of retries is reached      */
specifier|private
name|void
name|handleConnectionFailure
parameter_list|(
name|int
name|curRetries
parameter_list|,
name|int
name|maxRetries
parameter_list|,
name|IOException
name|ioe
parameter_list|)
throws|throws
name|IOException
block|{
name|closeConnection
argument_list|()
expr_stmt|;
comment|// throw the exception if the maximum number of retries is reached
if|if
condition|(
name|curRetries
operator|>=
name|maxRetries
condition|)
block|{
throw|throw
name|ioe
throw|;
block|}
comment|// otherwise back off and retry
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|failureSleep
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{}
name|LOG
operator|.
name|info
argument_list|(
literal|"Retrying connect to server: "
operator|+
name|remoteId
operator|.
name|getAddress
argument_list|()
operator|+
literal|" after sleeping "
operator|+
name|failureSleep
operator|+
literal|"ms. Already tried "
operator|+
name|curRetries
operator|+
literal|" time(s)."
argument_list|)
expr_stmt|;
block|}
comment|/* Write the header for each connection      * Out is not synchronized because only the first thread does this.      */
specifier|private
name|void
name|writeHeader
parameter_list|()
throws|throws
name|IOException
block|{
name|out
operator|.
name|write
argument_list|(
name|HBaseServer
operator|.
name|HEADER
operator|.
name|array
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|HBaseServer
operator|.
name|CURRENT_VERSION
argument_list|)
expr_stmt|;
comment|//When there are more fields we can have ConnectionHeader Writable.
name|DataOutputBuffer
name|buf
init|=
operator|new
name|DataOutputBuffer
argument_list|()
decl_stmt|;
name|header
operator|.
name|write
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|int
name|bufLen
init|=
name|buf
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|bufLen
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|buf
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|bufLen
argument_list|)
expr_stmt|;
block|}
comment|/* wait till someone signals us to start reading RPC response or      * it is idle too long, it is marked as to be closed,      * or the client is marked as not running.      *      * Return true if it is time to read a response; false otherwise.      */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"ThrowableInstanceNeverThrown"
block|}
argument_list|)
specifier|protected
specifier|synchronized
name|boolean
name|waitForWork
parameter_list|()
block|{
if|if
condition|(
name|calls
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|shouldCloseConnection
operator|.
name|get
argument_list|()
operator|&&
name|running
operator|.
name|get
argument_list|()
condition|)
block|{
name|long
name|timeout
init|=
name|maxIdleTime
operator|-
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|lastActivity
operator|.
name|get
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|wait
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{}
block|}
block|}
if|if
condition|(
operator|!
name|calls
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|shouldCloseConnection
operator|.
name|get
argument_list|()
operator|&&
name|running
operator|.
name|get
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|shouldCloseConnection
operator|.
name|get
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|calls
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// idle connection closed or stopped
name|markClosed
argument_list|(
literal|null
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
comment|// get stopped but there are still pending requests
name|markClosed
argument_list|(
operator|(
name|IOException
operator|)
operator|new
name|IOException
argument_list|()
operator|.
name|initCause
argument_list|(
operator|new
name|InterruptedException
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
specifier|public
name|InetSocketAddress
name|getRemoteAddress
parameter_list|()
block|{
return|return
name|remoteId
operator|.
name|getAddress
argument_list|()
return|;
block|}
comment|/* Send a ping to the server if the time elapsed      * since last I/O activity is equal to or greater than the ping interval      */
specifier|protected
specifier|synchronized
name|void
name|sendPing
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|curTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|curTime
operator|-
name|lastActivity
operator|.
name|get
argument_list|()
operator|>=
name|pingInterval
condition|)
block|{
name|lastActivity
operator|.
name|set
argument_list|(
name|curTime
argument_list|)
expr_stmt|;
comment|//noinspection SynchronizeOnNonFinalField
synchronized|synchronized
init|(
name|this
operator|.
name|out
init|)
block|{
name|out
operator|.
name|writeInt
argument_list|(
name|PING_CALL_ID
argument_list|)
expr_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|": starting, having connections "
operator|+
name|connections
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
while|while
condition|(
name|waitForWork
argument_list|()
condition|)
block|{
comment|//wait here for work - read or close connection
name|receiveResponse
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected exception receiving call responses"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|markClosed
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"Unexpected exception receiving call responses"
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|": stopped, remaining connections "
operator|+
name|connections
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* Initiates a call by sending the parameter to the remote server.      * Note: this is not called from the Connection thread, but by other      * threads.      */
specifier|protected
name|void
name|sendParam
parameter_list|(
name|Call
name|call
parameter_list|)
block|{
if|if
condition|(
name|shouldCloseConnection
operator|.
name|get
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// For serializing the data to be written.
specifier|final
name|DataOutputBuffer
name|d
init|=
operator|new
name|DataOutputBuffer
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|" sending #"
operator|+
name|call
operator|.
name|id
argument_list|)
expr_stmt|;
name|d
operator|.
name|writeInt
argument_list|(
literal|0xdeadbeef
argument_list|)
expr_stmt|;
comment|// placeholder for data length
name|d
operator|.
name|writeInt
argument_list|(
name|call
operator|.
name|id
argument_list|)
expr_stmt|;
name|call
operator|.
name|param
operator|.
name|write
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|byte
index|[]
name|data
init|=
name|d
operator|.
name|getData
argument_list|()
decl_stmt|;
name|int
name|dataLength
init|=
name|d
operator|.
name|getLength
argument_list|()
decl_stmt|;
comment|// fill in the placeholder
name|Bytes
operator|.
name|putInt
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|dataLength
operator|-
literal|4
argument_list|)
expr_stmt|;
comment|//noinspection SynchronizeOnNonFinalField
synchronized|synchronized
init|(
name|this
operator|.
name|out
init|)
block|{
comment|// FindBugs IS2_INCONSISTENT_SYNC
name|out
operator|.
name|write
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|dataLength
argument_list|)
expr_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|markClosed
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|//the buffer is just an in-memory buffer, but it is still polite to
comment|// close early
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Receive a response.      * Because only one receiver, so no synchronization on in.      */
specifier|protected
name|void
name|receiveResponse
parameter_list|()
block|{
if|if
condition|(
name|shouldCloseConnection
operator|.
name|get
argument_list|()
condition|)
block|{
return|return;
block|}
name|touch
argument_list|()
expr_stmt|;
try|try
block|{
comment|// See HBaseServer.Call.setResponse for where we write out the response.
comment|// It writes the call.id (int), a flag byte, then optionally the length
comment|// of the response (int) followed by data.
comment|// Read the call id.
name|int
name|id
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|" got value #"
operator|+
name|id
argument_list|)
expr_stmt|;
name|Call
name|call
init|=
name|calls
operator|.
name|remove
argument_list|(
name|id
argument_list|)
decl_stmt|;
comment|// Read the flag byte
name|byte
name|flag
init|=
name|in
operator|.
name|readByte
argument_list|()
decl_stmt|;
name|boolean
name|isError
init|=
name|ResponseFlag
operator|.
name|isError
argument_list|(
name|flag
argument_list|)
decl_stmt|;
if|if
condition|(
name|ResponseFlag
operator|.
name|isLength
argument_list|(
name|flag
argument_list|)
condition|)
block|{
comment|// Currently length if present is unused.
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
name|int
name|state
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
comment|// Read the state.  Currently unused.
if|if
condition|(
name|isError
condition|)
block|{
if|if
condition|(
name|call
operator|!=
literal|null
condition|)
block|{
comment|//noinspection ThrowableInstanceNeverThrown
name|call
operator|.
name|setException
argument_list|(
operator|new
name|RemoteException
argument_list|(
name|WritableUtils
operator|.
name|readString
argument_list|(
name|in
argument_list|)
argument_list|,
name|WritableUtils
operator|.
name|readString
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Writable
name|value
init|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|valueClass
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|value
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
comment|// read value
comment|// it's possible that this call may have been cleaned up due to a RPC
comment|// timeout, so check if it still exists before setting the value.
if|if
condition|(
name|call
operator|!=
literal|null
condition|)
block|{
name|call
operator|.
name|setValue
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|SocketTimeoutException
operator|&&
name|remoteId
operator|.
name|rpcTimeout
operator|>
literal|0
condition|)
block|{
comment|// Clean up open calls but don't treat this as a fatal condition,
comment|// since we expect certain responses to not make it by the specified
comment|// {@link ConnectionId#rpcTimeout}.
name|closeException
operator|=
name|e
expr_stmt|;
block|}
else|else
block|{
comment|// Since the server did not respond within the default ping interval
comment|// time, treat this as a fatal condition and close this connection
name|markClosed
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|remoteId
operator|.
name|rpcTimeout
operator|>
literal|0
condition|)
block|{
name|cleanupCalls
argument_list|(
name|remoteId
operator|.
name|rpcTimeout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|protected
specifier|synchronized
name|void
name|markClosed
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|shouldCloseConnection
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|closeException
operator|=
name|e
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Close the connection. */
specifier|protected
specifier|synchronized
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
operator|!
name|shouldCloseConnection
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"The connection is not in the closed state"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// release the resources
comment|// first thing to do;take the connection out of the connection list
synchronized|synchronized
init|(
name|connections
init|)
block|{
name|connections
operator|.
name|remove
argument_list|(
name|remoteId
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
comment|// close the streams and therefore the socket
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|in
argument_list|)
expr_stmt|;
comment|// clean up all calls
if|if
condition|(
name|closeException
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|calls
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"A connection is closed for no cause and calls are not empty"
argument_list|)
expr_stmt|;
comment|// clean up calls anyway
name|closeException
operator|=
operator|new
name|IOException
argument_list|(
literal|"Unexpected closed connection"
argument_list|)
expr_stmt|;
name|cleanupCalls
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// log the info
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"closing ipc connection to "
operator|+
name|remoteId
operator|.
name|address
operator|+
literal|": "
operator|+
name|closeException
operator|.
name|getMessage
argument_list|()
argument_list|,
name|closeException
argument_list|)
expr_stmt|;
block|}
comment|// cleanup calls
name|cleanupCalls
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|": closed"
argument_list|)
expr_stmt|;
block|}
comment|/* Cleanup all calls and mark them as done */
specifier|protected
name|void
name|cleanupCalls
parameter_list|()
block|{
name|cleanupCalls
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|cleanupCalls
parameter_list|(
name|long
name|rpcTimeout
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|Integer
argument_list|,
name|Call
argument_list|>
argument_list|>
name|itor
init|=
name|calls
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|itor
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Call
name|c
init|=
name|itor
operator|.
name|next
argument_list|()
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|long
name|waitTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|c
operator|.
name|getStartTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|waitTime
operator|>=
name|rpcTimeout
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|closeException
operator|==
literal|null
condition|)
block|{
comment|// There may be no exception in the case that there are many calls
comment|// being multiplexed over this connection and these are succeeding
comment|// fine while this Call object is taking a long time to finish
comment|// over on the server; e.g. I just asked the regionserver to bulk
comment|// open 3k regions or its a big fat multiput into a heavily-loaded
comment|// server (Perhaps this only happens at the extremes?)
name|this
operator|.
name|closeException
operator|=
operator|new
name|CallTimeoutException
argument_list|(
literal|"Call id="
operator|+
name|c
operator|.
name|id
operator|+
literal|", waitTime="
operator|+
name|waitTime
operator|+
literal|", rpcTimetout="
operator|+
name|rpcTimeout
argument_list|)
expr_stmt|;
block|}
name|c
operator|.
name|setException
argument_list|(
name|this
operator|.
name|closeException
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|c
init|)
block|{
name|c
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
name|itor
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
try|try
block|{
if|if
condition|(
operator|!
name|calls
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Call
name|firstCall
init|=
name|calls
operator|.
name|get
argument_list|(
name|calls
operator|.
name|firstKey
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|maxWaitTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|firstCall
operator|.
name|getStartTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|maxWaitTime
operator|<
name|rpcTimeout
condition|)
block|{
name|rpcTimeout
operator|-=
name|maxWaitTime
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|shouldCloseConnection
operator|.
name|get
argument_list|()
condition|)
block|{
name|closeException
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|socket
operator|!=
literal|null
condition|)
block|{
name|socket
operator|.
name|setSoTimeout
argument_list|(
operator|(
name|int
operator|)
name|rpcTimeout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|SocketException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Couldn't lower timeout, which may result in longer than expected calls"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Client-side call timeout    */
specifier|public
specifier|static
class|class
name|CallTimeoutException
extends|extends
name|IOException
block|{
specifier|public
name|CallTimeoutException
parameter_list|(
specifier|final
name|String
name|msg
parameter_list|)
block|{
name|super
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Call implementation used for parallel calls. */
specifier|protected
class|class
name|ParallelCall
extends|extends
name|Call
block|{
specifier|private
specifier|final
name|ParallelResults
name|results
decl_stmt|;
specifier|protected
specifier|final
name|int
name|index
decl_stmt|;
specifier|public
name|ParallelCall
parameter_list|(
name|Writable
name|param
parameter_list|,
name|ParallelResults
name|results
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|super
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|this
operator|.
name|results
operator|=
name|results
expr_stmt|;
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
block|}
comment|/** Deliver result to result collector. */
annotation|@
name|Override
specifier|protected
name|void
name|callComplete
parameter_list|()
block|{
name|results
operator|.
name|callComplete
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Result collector for parallel calls. */
specifier|protected
specifier|static
class|class
name|ParallelResults
block|{
specifier|protected
specifier|final
name|Writable
index|[]
name|values
decl_stmt|;
specifier|protected
name|int
name|size
decl_stmt|;
specifier|protected
name|int
name|count
decl_stmt|;
specifier|public
name|ParallelResults
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|this
operator|.
name|values
operator|=
operator|new
name|Writable
index|[
name|size
index|]
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
block|}
comment|/*      * Collect a result.      */
specifier|synchronized
name|void
name|callComplete
parameter_list|(
name|ParallelCall
name|call
parameter_list|)
block|{
comment|// FindBugs IS2_INCONSISTENT_SYNC
name|values
index|[
name|call
operator|.
name|index
index|]
operator|=
name|call
operator|.
name|value
expr_stmt|;
comment|// store the value
name|count
operator|++
expr_stmt|;
comment|// count it
if|if
condition|(
name|count
operator|==
name|size
condition|)
comment|// if all values are in
name|notify
argument_list|()
expr_stmt|;
comment|// then notify waiting caller
block|}
block|}
comment|/**    * Construct an IPC client whose values are of the given {@link Writable}    * class.    * @param valueClass value class    * @param conf configuration    * @param factory socket factory    */
specifier|public
name|HBaseClient
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|Writable
argument_list|>
name|valueClass
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|SocketFactory
name|factory
parameter_list|)
block|{
name|this
operator|.
name|valueClass
operator|=
name|valueClass
expr_stmt|;
name|this
operator|.
name|maxIdleTime
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.client.connection.maxidletime"
argument_list|,
literal|10000
argument_list|)
expr_stmt|;
comment|//10s
name|this
operator|.
name|maxRetries
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.client.connect.max.retries"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|failureSleep
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.client.pause"
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|this
operator|.
name|tcpNoDelay
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.ipc.client.tcpnodelay"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|tcpKeepAlive
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.ipc.client.tcpkeepalive"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|pingInterval
operator|=
name|getPingInterval
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The ping interval is"
operator|+
name|this
operator|.
name|pingInterval
operator|+
literal|"ms."
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|socketFactory
operator|=
name|factory
expr_stmt|;
name|this
operator|.
name|clusterId
operator|=
name|conf
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|CLUSTER_ID
argument_list|,
literal|"default"
argument_list|)
expr_stmt|;
name|this
operator|.
name|connections
operator|=
operator|new
name|PoolMap
argument_list|<
name|ConnectionId
argument_list|,
name|Connection
argument_list|>
argument_list|(
name|getPoolType
argument_list|(
name|conf
argument_list|)
argument_list|,
name|getPoolSize
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct an IPC client with the default SocketFactory    * @param valueClass value class    * @param conf configuration    */
specifier|public
name|HBaseClient
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|Writable
argument_list|>
name|valueClass
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
argument_list|(
name|valueClass
argument_list|,
name|conf
argument_list|,
name|NetUtils
operator|.
name|getDefaultSocketFactory
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return the pool type specified in the configuration, which must be set to    * either {@link PoolType#RoundRobin} or {@link PoolType#ThreadLocal},    * otherwise default to the former.    *    * For applications with many user threads, use a small round-robin pool. For    * applications with few user threads, you may want to try using a    * thread-local pool. In any case, the number of {@link HBaseClient} instances    * should not exceed the operating system's hard limit on the number of    * connections.    *    * @param config configuration    * @return either a {@link PoolType#RoundRobin} or    *         {@link PoolType#ThreadLocal}    */
specifier|protected
specifier|static
name|PoolType
name|getPoolType
parameter_list|(
name|Configuration
name|config
parameter_list|)
block|{
return|return
name|PoolType
operator|.
name|valueOf
argument_list|(
name|config
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_IPC_POOL_TYPE
argument_list|)
argument_list|,
name|PoolType
operator|.
name|RoundRobin
argument_list|,
name|PoolType
operator|.
name|ThreadLocal
argument_list|)
return|;
block|}
comment|/**    * Return the pool size specified in the configuration, which is applicable only if    * the pool type is {@link PoolType#RoundRobin}.    *    * @param config    * @return the maximum pool size    */
specifier|protected
specifier|static
name|int
name|getPoolSize
parameter_list|(
name|Configuration
name|config
parameter_list|)
block|{
return|return
name|config
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_IPC_POOL_SIZE
argument_list|,
literal|1
argument_list|)
return|;
block|}
comment|/** Return the socket factory of this client    *    * @return this client's socket factory    */
name|SocketFactory
name|getSocketFactory
parameter_list|()
block|{
return|return
name|socketFactory
return|;
block|}
comment|/** Stop all threads related to this client.  No further calls may be made    * using this client. */
specifier|public
name|void
name|stop
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Stopping client"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|running
operator|.
name|compareAndSet
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// wake up all connections
synchronized|synchronized
init|(
name|connections
init|)
block|{
for|for
control|(
name|Connection
name|conn
range|:
name|connections
operator|.
name|values
argument_list|()
control|)
block|{
name|conn
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
comment|// wait until all connections are closed
while|while
condition|(
operator|!
name|connections
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{       }
block|}
block|}
comment|/** Make a call, passing<code>param</code>, to the IPC server running at    *<code>address</code>, returning the value.  Throws exceptions if there are    * network problems or if the remote code threw an exception.    * @param param writable parameter    * @param address network address    * @return Writable    * @throws IOException e    */
specifier|public
name|Writable
name|call
parameter_list|(
name|Writable
name|param
parameter_list|,
name|InetSocketAddress
name|address
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|call
argument_list|(
name|param
argument_list|,
name|address
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|public
name|Writable
name|call
parameter_list|(
name|Writable
name|param
parameter_list|,
name|InetSocketAddress
name|addr
parameter_list|,
name|User
name|ticket
parameter_list|,
name|int
name|rpcTimeout
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|call
argument_list|(
name|param
argument_list|,
name|addr
argument_list|,
literal|null
argument_list|,
name|ticket
argument_list|,
name|rpcTimeout
argument_list|)
return|;
block|}
comment|/** Make a call, passing<code>param</code>, to the IPC server running at    *<code>address</code> which is servicing the<code>protocol</code> protocol,    * with the<code>ticket</code> credentials, returning the value.    * Throws exceptions if there are network problems or if the remote code    * threw an exception. */
specifier|public
name|Writable
name|call
parameter_list|(
name|Writable
name|param
parameter_list|,
name|InetSocketAddress
name|addr
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|VersionedProtocol
argument_list|>
name|protocol
parameter_list|,
name|User
name|ticket
parameter_list|,
name|int
name|rpcTimeout
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|IOException
block|{
name|Call
name|call
init|=
operator|new
name|Call
argument_list|(
name|param
argument_list|)
decl_stmt|;
name|Connection
name|connection
init|=
name|getConnection
argument_list|(
name|addr
argument_list|,
name|protocol
argument_list|,
name|ticket
argument_list|,
name|rpcTimeout
argument_list|,
name|call
argument_list|)
decl_stmt|;
name|connection
operator|.
name|sendParam
argument_list|(
name|call
argument_list|)
expr_stmt|;
comment|// send the parameter
name|boolean
name|interrupted
init|=
literal|false
decl_stmt|;
comment|//noinspection SynchronizationOnLocalVariableOrMethodParameter
synchronized|synchronized
init|(
name|call
init|)
block|{
while|while
condition|(
operator|!
name|call
operator|.
name|done
condition|)
block|{
try|try
block|{
name|call
operator|.
name|wait
argument_list|()
expr_stmt|;
comment|// wait for the result
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{
comment|// save the fact that we were interrupted
name|interrupted
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|interrupted
condition|)
block|{
comment|// set the interrupt flag now that we are done waiting
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|call
operator|.
name|error
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|call
operator|.
name|error
operator|instanceof
name|RemoteException
condition|)
block|{
name|call
operator|.
name|error
operator|.
name|fillInStackTrace
argument_list|()
expr_stmt|;
throw|throw
name|call
operator|.
name|error
throw|;
block|}
comment|// local exception
throw|throw
name|wrapException
argument_list|(
name|addr
argument_list|,
name|call
operator|.
name|error
argument_list|)
throw|;
block|}
return|return
name|call
operator|.
name|value
return|;
block|}
block|}
comment|/**    * Take an IOException and the address we were trying to connect to    * and return an IOException with the input exception as the cause.    * The new exception provides the stack trace of the place where    * the exception is thrown and some extra diagnostics information.    * If the exception is ConnectException or SocketTimeoutException,    * return a new one of the same type; Otherwise return an IOException.    *    * @param addr target address    * @param exception the relevant exception    * @return an exception to throw    */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"ThrowableInstanceNeverThrown"
block|}
argument_list|)
specifier|protected
name|IOException
name|wrapException
parameter_list|(
name|InetSocketAddress
name|addr
parameter_list|,
name|IOException
name|exception
parameter_list|)
block|{
if|if
condition|(
name|exception
operator|instanceof
name|ConnectException
condition|)
block|{
comment|//connection refused; include the host:port in the error
return|return
operator|(
name|ConnectException
operator|)
operator|new
name|ConnectException
argument_list|(
literal|"Call to "
operator|+
name|addr
operator|+
literal|" failed on connection exception: "
operator|+
name|exception
argument_list|)
operator|.
name|initCause
argument_list|(
name|exception
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|exception
operator|instanceof
name|SocketTimeoutException
condition|)
block|{
return|return
operator|(
name|SocketTimeoutException
operator|)
operator|new
name|SocketTimeoutException
argument_list|(
literal|"Call to "
operator|+
name|addr
operator|+
literal|" failed on socket timeout exception: "
operator|+
name|exception
argument_list|)
operator|.
name|initCause
argument_list|(
name|exception
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|IOException
operator|)
operator|new
name|IOException
argument_list|(
literal|"Call to "
operator|+
name|addr
operator|+
literal|" failed on local exception: "
operator|+
name|exception
argument_list|)
operator|.
name|initCause
argument_list|(
name|exception
argument_list|)
return|;
block|}
block|}
comment|/** Makes a set of calls in parallel.  Each parameter is sent to the    * corresponding address.  When all values are available, or have timed out    * or errored, the collected results are returned in an array.  The array    * contains nulls for calls that timed out or errored.    * @param params writable parameters    * @param addresses socket addresses    * @return  Writable[]    * @throws IOException e    * @deprecated Use {@link #call(Writable[], InetSocketAddress[], Class, User)} instead    */
annotation|@
name|Deprecated
specifier|public
name|Writable
index|[]
name|call
parameter_list|(
name|Writable
index|[]
name|params
parameter_list|,
name|InetSocketAddress
index|[]
name|addresses
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|call
argument_list|(
name|params
argument_list|,
name|addresses
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Makes a set of calls in parallel.  Each parameter is sent to the    * corresponding address.  When all values are available, or have timed out    * or errored, the collected results are returned in an array.  The array    * contains nulls for calls that timed out or errored.  */
specifier|public
name|Writable
index|[]
name|call
parameter_list|(
name|Writable
index|[]
name|params
parameter_list|,
name|InetSocketAddress
index|[]
name|addresses
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|VersionedProtocol
argument_list|>
name|protocol
parameter_list|,
name|User
name|ticket
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|addresses
operator|.
name|length
operator|==
literal|0
condition|)
return|return
operator|new
name|Writable
index|[
literal|0
index|]
return|;
name|ParallelResults
name|results
init|=
operator|new
name|ParallelResults
argument_list|(
name|params
operator|.
name|length
argument_list|)
decl_stmt|;
comment|// TODO this synchronization block doesnt make any sense, we should possibly fix it
comment|//noinspection SynchronizationOnLocalVariableOrMethodParameter
synchronized|synchronized
init|(
name|results
init|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|params
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ParallelCall
name|call
init|=
operator|new
name|ParallelCall
argument_list|(
name|params
index|[
name|i
index|]
argument_list|,
name|results
argument_list|,
name|i
argument_list|)
decl_stmt|;
try|try
block|{
name|Connection
name|connection
init|=
name|getConnection
argument_list|(
name|addresses
index|[
name|i
index|]
argument_list|,
name|protocol
argument_list|,
name|ticket
argument_list|,
literal|0
argument_list|,
name|call
argument_list|)
decl_stmt|;
name|connection
operator|.
name|sendParam
argument_list|(
name|call
argument_list|)
expr_stmt|;
comment|// send each parameter
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// log errors
name|LOG
operator|.
name|info
argument_list|(
literal|"Calling "
operator|+
name|addresses
index|[
name|i
index|]
operator|+
literal|" caught: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|results
operator|.
name|size
operator|--
expr_stmt|;
comment|//  wait for one fewer result
block|}
block|}
while|while
condition|(
name|results
operator|.
name|count
operator|!=
name|results
operator|.
name|size
condition|)
block|{
try|try
block|{
name|results
operator|.
name|wait
argument_list|()
expr_stmt|;
comment|// wait for all results
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{}
block|}
return|return
name|results
operator|.
name|values
return|;
block|}
block|}
comment|/* Get a connection from the pool, or create a new one and add it to the    * pool.  Connections to a given host/port are reused. */
specifier|protected
name|Connection
name|getConnection
parameter_list|(
name|InetSocketAddress
name|addr
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|VersionedProtocol
argument_list|>
name|protocol
parameter_list|,
name|User
name|ticket
parameter_list|,
name|int
name|rpcTimeout
parameter_list|,
name|Call
name|call
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
operator|!
name|running
operator|.
name|get
argument_list|()
condition|)
block|{
comment|// the client is stopped
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The client is stopped"
argument_list|)
throw|;
block|}
name|Connection
name|connection
decl_stmt|;
comment|/* we could avoid this allocation for each RPC by having a      * connectionsId object and with set() method. We need to manage the      * refs for keys in HashMap properly. For now its ok.      */
name|ConnectionId
name|remoteId
init|=
operator|new
name|ConnectionId
argument_list|(
name|addr
argument_list|,
name|protocol
argument_list|,
name|ticket
argument_list|,
name|rpcTimeout
argument_list|)
decl_stmt|;
do|do
block|{
synchronized|synchronized
init|(
name|connections
init|)
block|{
name|connection
operator|=
name|connections
operator|.
name|get
argument_list|(
name|remoteId
argument_list|)
expr_stmt|;
if|if
condition|(
name|connection
operator|==
literal|null
condition|)
block|{
name|connection
operator|=
operator|new
name|Connection
argument_list|(
name|remoteId
argument_list|)
expr_stmt|;
name|connections
operator|.
name|put
argument_list|(
name|remoteId
argument_list|,
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|!
name|connection
operator|.
name|addCall
argument_list|(
name|call
argument_list|)
condition|)
do|;
comment|//we don't invoke the method below inside "synchronized (connections)"
comment|//block above. The reason for that is if the server happens to be slow,
comment|//it will take longer to establish a connection and that will slow the
comment|//entire system down.
name|connection
operator|.
name|setupIOstreams
argument_list|()
expr_stmt|;
return|return
name|connection
return|;
block|}
comment|/**    * This class holds the address and the user ticket. The client connections    * to servers are uniquely identified by<remoteAddress, ticket>    */
specifier|protected
specifier|static
class|class
name|ConnectionId
block|{
specifier|final
name|InetSocketAddress
name|address
decl_stmt|;
specifier|final
name|User
name|ticket
decl_stmt|;
specifier|final
name|int
name|rpcTimeout
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|VersionedProtocol
argument_list|>
name|protocol
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|PRIME
init|=
literal|16777619
decl_stmt|;
name|ConnectionId
parameter_list|(
name|InetSocketAddress
name|address
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|VersionedProtocol
argument_list|>
name|protocol
parameter_list|,
name|User
name|ticket
parameter_list|,
name|int
name|rpcTimeout
parameter_list|)
block|{
name|this
operator|.
name|protocol
operator|=
name|protocol
expr_stmt|;
name|this
operator|.
name|address
operator|=
name|address
expr_stmt|;
name|this
operator|.
name|ticket
operator|=
name|ticket
expr_stmt|;
name|this
operator|.
name|rpcTimeout
operator|=
name|rpcTimeout
expr_stmt|;
block|}
name|InetSocketAddress
name|getAddress
parameter_list|()
block|{
return|return
name|address
return|;
block|}
name|Class
argument_list|<
name|?
extends|extends
name|VersionedProtocol
argument_list|>
name|getProtocol
parameter_list|()
block|{
return|return
name|protocol
return|;
block|}
name|User
name|getTicket
parameter_list|()
block|{
return|return
name|ticket
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|instanceof
name|ConnectionId
condition|)
block|{
name|ConnectionId
name|id
init|=
operator|(
name|ConnectionId
operator|)
name|obj
decl_stmt|;
return|return
name|address
operator|.
name|equals
argument_list|(
name|id
operator|.
name|address
argument_list|)
operator|&&
name|protocol
operator|==
name|id
operator|.
name|protocol
operator|&&
operator|(
operator|(
name|ticket
operator|!=
literal|null
operator|&&
name|ticket
operator|.
name|equals
argument_list|(
name|id
operator|.
name|ticket
argument_list|)
operator|)
operator|||
operator|(
name|ticket
operator|==
name|id
operator|.
name|ticket
operator|)
operator|)
operator|&&
name|rpcTimeout
operator|==
name|id
operator|.
name|rpcTimeout
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
comment|// simply use the default Object#hashcode() ?
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
operator|(
name|address
operator|.
name|hashCode
argument_list|()
operator|+
name|PRIME
operator|*
operator|(
name|PRIME
operator|*
name|System
operator|.
name|identityHashCode
argument_list|(
name|protocol
argument_list|)
operator|^
operator|(
name|ticket
operator|==
literal|null
condition|?
literal|0
else|:
name|ticket
operator|.
name|hashCode
argument_list|()
operator|)
operator|)
operator|)
operator|^
name|rpcTimeout
return|;
block|}
block|}
block|}
end_class

end_unit

