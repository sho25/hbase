begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2010 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Abortable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ClusterStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HColumnDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerAddress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MasterNotRunningException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NotServingRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|RegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|RemoteExceptionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|UnknownRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ZooKeeperConnectionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|CatalogTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|catalog
operator|.
name|MetaReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HMasterInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HRegionInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Addressing
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_comment
comment|/**  * Provides an interface to manage HBase database table metadata + general  * administrative functions.  Use HBaseAdmin to create, drop, list, enable and  * disable tables. Use it also to add and drop table column families.  *  *<p>See {@link HTable} to add, update, and delete data from an individual table.  *<p>Currently HBaseAdmin instances are not expected to be long-lived.  For  * example, an HBaseAdmin instance will not ride over a Master restart.  */
end_comment

begin_class
specifier|public
class|class
name|HBaseAdmin
implements|implements
name|Abortable
implements|,
name|Closeable
block|{
specifier|private
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|//  private final HConnection connection;
specifier|private
specifier|final
name|HConnection
name|connection
decl_stmt|;
specifier|private
specifier|volatile
name|Configuration
name|conf
decl_stmt|;
specifier|private
specifier|final
name|long
name|pause
decl_stmt|;
specifier|private
specifier|final
name|int
name|numRetries
decl_stmt|;
comment|// Some operations can take a long time such as disable of big table.
comment|// numRetries is for 'normal' stuff... Mutliply by this factor when
comment|// want to wait a long time.
specifier|private
specifier|final
name|int
name|retryLongerMultiplier
decl_stmt|;
comment|/**    * Constructor    *    * @param c Configuration object    * @throws MasterNotRunningException if the master is not running    * @throws ZooKeeperConnectionException if unable to connect to zookeeper    */
specifier|public
name|HBaseAdmin
parameter_list|(
name|Configuration
name|c
parameter_list|)
throws|throws
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
block|{
name|this
operator|.
name|conf
operator|=
name|HBaseConfiguration
operator|.
name|create
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|this
operator|.
name|connection
operator|=
name|HConnectionManager
operator|.
name|getConnection
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|pause
operator|=
name|this
operator|.
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.client.pause"
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|this
operator|.
name|numRetries
operator|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.client.retries.number"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|this
operator|.
name|retryLongerMultiplier
operator|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.client.retries.longer.multiplier"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|this
operator|.
name|connection
operator|.
name|getMaster
argument_list|()
expr_stmt|;
block|}
comment|/**    * @return A new CatalogTracker instance; call {@link #cleanupCatalogTracker(CatalogTracker)}    * to cleanup the returned catalog tracker.    * @throws ZooKeeperConnectionException    * @throws IOException    * @see #cleanupCatalogTracker(CatalogTracker);    */
specifier|private
specifier|synchronized
name|CatalogTracker
name|getCatalogTracker
parameter_list|()
throws|throws
name|ZooKeeperConnectionException
throws|,
name|IOException
block|{
name|CatalogTracker
name|ct
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ct
operator|=
operator|new
name|CatalogTracker
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|ct
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// Let it out as an IOE for now until we redo all so tolerate IEs
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Interrupted"
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|ct
return|;
block|}
specifier|private
name|void
name|cleanupCatalogTracker
parameter_list|(
specifier|final
name|CatalogTracker
name|ct
parameter_list|)
block|{
name|ct
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|abort
parameter_list|(
name|String
name|why
parameter_list|,
name|Throwable
name|e
parameter_list|)
block|{
comment|// Currently does nothing but throw the passed message and exception
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|why
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|/** @return HConnection used by this object. */
specifier|public
name|HConnection
name|getConnection
parameter_list|()
block|{
return|return
name|connection
return|;
block|}
comment|/**    * Get a connection to the currently set master.    * @return proxy connection to master server for this instance    * @throws MasterNotRunningException if the master is not running    * @throws ZooKeeperConnectionException if unable to connect to zookeeper    */
specifier|public
name|HMasterInterface
name|getMaster
parameter_list|()
throws|throws
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
block|{
return|return
name|this
operator|.
name|connection
operator|.
name|getMaster
argument_list|()
return|;
block|}
comment|/** @return - true if the master server is running    * @throws ZooKeeperConnectionException    * @throws MasterNotRunningException */
specifier|public
name|boolean
name|isMasterRunning
parameter_list|()
throws|throws
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
block|{
return|return
name|this
operator|.
name|connection
operator|.
name|isMasterRunning
argument_list|()
return|;
block|}
comment|/**    * @param tableName Table to check.    * @return True if table exists already.    * @throws IOException    */
specifier|public
name|boolean
name|tableExists
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|b
init|=
literal|false
decl_stmt|;
name|CatalogTracker
name|ct
init|=
name|getCatalogTracker
argument_list|()
decl_stmt|;
try|try
block|{
name|b
operator|=
name|MetaReader
operator|.
name|tableExists
argument_list|(
name|ct
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|cleanupCatalogTracker
argument_list|(
name|ct
argument_list|)
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
comment|/**    * @param tableName Table to check.    * @return True if table exists already.    * @throws IOException    */
specifier|public
name|boolean
name|tableExists
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|tableExists
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * List all the userspace tables.  In other words, scan the META table.    *    * If we wanted this to be really fast, we could implement a special    * catalog table that just contains table names and their descriptors.    * Right now, it only exists as part of the META table's region info.    *    * @return - returns an array of HTableDescriptors    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|HTableDescriptor
index|[]
name|listTables
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|this
operator|.
name|connection
operator|.
name|listTables
argument_list|()
return|;
block|}
comment|/**    * Method for getting the tableDescriptor    * @param tableName as a byte []    * @return the tableDescriptor    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|HTableDescriptor
name|getTableDescriptor
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|this
operator|.
name|connection
operator|.
name|getHTableDescriptor
argument_list|(
name|tableName
argument_list|)
return|;
block|}
specifier|private
name|long
name|getPauseTime
parameter_list|(
name|int
name|tries
parameter_list|)
block|{
name|int
name|triesCount
init|=
name|tries
decl_stmt|;
if|if
condition|(
name|triesCount
operator|>=
name|HConstants
operator|.
name|RETRY_BACKOFF
operator|.
name|length
condition|)
block|{
name|triesCount
operator|=
name|HConstants
operator|.
name|RETRY_BACKOFF
operator|.
name|length
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|this
operator|.
name|pause
operator|*
name|HConstants
operator|.
name|RETRY_BACKOFF
index|[
name|triesCount
index|]
return|;
block|}
comment|/**    * Creates a new table.    * Synchronous operation.    *    * @param desc table descriptor for table    *    * @throws IllegalArgumentException if the table name is reserved    * @throws MasterNotRunningException if master is not running    * @throws TableExistsException if table already exists (If concurrent    * threads, the table may have been created between test-for-existence    * and attempt-at-creation).    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|createTable
parameter_list|(
name|HTableDescriptor
name|desc
parameter_list|)
throws|throws
name|IOException
block|{
name|createTable
argument_list|(
name|desc
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a new table with the specified number of regions.  The start key    * specified will become the end key of the first region of the table, and    * the end key specified will become the start key of the last region of the    * table (the first region has a null start key and the last region has a    * null end key).    *    * BigInteger math will be used to divide the key range specified into    * enough segments to make the required number of total regions.    *    * Synchronous operation.    *    * @param desc table descriptor for table    * @param startKey beginning of key range    * @param endKey end of key range    * @param numRegions the total number of regions to create    *    * @throws IllegalArgumentException if the table name is reserved    * @throws MasterNotRunningException if master is not running    * @throws TableExistsException if table already exists (If concurrent    * threads, the table may have been created between test-for-existence    * and attempt-at-creation).    * @throws IOException    */
specifier|public
name|void
name|createTable
parameter_list|(
name|HTableDescriptor
name|desc
parameter_list|,
name|byte
index|[]
name|startKey
parameter_list|,
name|byte
index|[]
name|endKey
parameter_list|,
name|int
name|numRegions
parameter_list|)
throws|throws
name|IOException
block|{
name|HTableDescriptor
operator|.
name|isLegalTableName
argument_list|(
name|desc
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|numRegions
operator|<
literal|3
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Must create at least three regions"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|startKey
argument_list|,
name|endKey
argument_list|)
operator|>=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Start key must be smaller than end key"
argument_list|)
throw|;
block|}
name|byte
index|[]
index|[]
name|splitKeys
init|=
name|Bytes
operator|.
name|split
argument_list|(
name|startKey
argument_list|,
name|endKey
argument_list|,
name|numRegions
operator|-
literal|3
argument_list|)
decl_stmt|;
if|if
condition|(
name|splitKeys
operator|==
literal|null
operator|||
name|splitKeys
operator|.
name|length
operator|!=
name|numRegions
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unable to split key range into enough regions"
argument_list|)
throw|;
block|}
name|createTable
argument_list|(
name|desc
argument_list|,
name|splitKeys
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a new table with an initial set of empty regions defined by the    * specified split keys.  The total number of regions created will be the    * number of split keys plus one (the first region has a null start key and    * the last region has a null end key).    * Synchronous operation.    *    * @param desc table descriptor for table    * @param splitKeys array of split keys for the initial regions of the table    *    * @throws IllegalArgumentException if the table name is reserved    * @throws MasterNotRunningException if master is not running    * @throws TableExistsException if table already exists (If concurrent    * threads, the table may have been created between test-for-existence    * and attempt-at-creation).    * @throws IOException    */
specifier|public
name|void
name|createTable
parameter_list|(
name|HTableDescriptor
name|desc
parameter_list|,
name|byte
index|[]
index|[]
name|splitKeys
parameter_list|)
throws|throws
name|IOException
block|{
name|HTableDescriptor
operator|.
name|isLegalTableName
argument_list|(
name|desc
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|createTableAsync
argument_list|(
name|desc
argument_list|,
name|splitKeys
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
name|numRetries
condition|;
name|tries
operator|++
control|)
block|{
try|try
block|{
comment|// Wait for new table to come on-line
name|connection
operator|.
name|locateRegion
argument_list|(
name|desc
operator|.
name|getName
argument_list|()
argument_list|,
name|HConstants
operator|.
name|EMPTY_START_ROW
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|RegionException
name|e
parameter_list|)
block|{
if|if
condition|(
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
comment|// Ran out of tries
throw|throw
name|e
throw|;
block|}
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|getPauseTime
argument_list|(
name|tries
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// Just continue; ignore the interruption.
block|}
block|}
block|}
comment|/**    * Creates a new table but does not block and wait for it to come online.    * Asynchronous operation.    *    * @param desc table descriptor for table    *    * @throws IllegalArgumentException Bad table name.    * @throws MasterNotRunningException if master is not running    * @throws TableExistsException if table already exists (If concurrent    * threads, the table may have been created between test-for-existence    * and attempt-at-creation).    * @throws IOException    */
specifier|public
name|void
name|createTableAsync
parameter_list|(
name|HTableDescriptor
name|desc
parameter_list|,
name|byte
index|[]
index|[]
name|splitKeys
parameter_list|)
throws|throws
name|IOException
block|{
name|HTableDescriptor
operator|.
name|isLegalTableName
argument_list|(
name|desc
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|splitKeys
operator|!=
literal|null
operator|&&
name|splitKeys
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|splitKeys
argument_list|,
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
expr_stmt|;
comment|// Verify there are no duplicate split keys
name|byte
index|[]
name|lastKey
init|=
literal|null
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|splitKey
range|:
name|splitKeys
control|)
block|{
if|if
condition|(
name|lastKey
operator|!=
literal|null
operator|&&
name|Bytes
operator|.
name|equals
argument_list|(
name|splitKey
argument_list|,
name|lastKey
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"All split keys must be unique, "
operator|+
literal|"found duplicate: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|splitKey
argument_list|)
operator|+
literal|", "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|lastKey
argument_list|)
argument_list|)
throw|;
block|}
name|lastKey
operator|=
name|splitKey
expr_stmt|;
block|}
block|}
try|try
block|{
name|getMaster
argument_list|()
operator|.
name|createTable
argument_list|(
name|desc
argument_list|,
name|splitKeys
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
throw|throw
name|e
operator|.
name|unwrapRemoteException
argument_list|()
throw|;
block|}
block|}
comment|/**    * Deletes a table.    * Synchronous operation.    *    * @param tableName name of table to delete    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|deleteTable
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|deleteTable
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Deletes a table.    * Synchronous operation.    *    * @param tableName name of table to delete    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|deleteTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|isMasterRunning
argument_list|()
expr_stmt|;
name|HTableDescriptor
operator|.
name|isLegalTableName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|HRegionLocation
name|firstMetaServer
init|=
name|getFirstMetaServerForTable
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
try|try
block|{
name|getMaster
argument_list|()
operator|.
name|deleteTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
throw|throw
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// Wait until all regions deleted
name|HRegionInterface
name|server
init|=
name|connection
operator|.
name|getHRegionConnection
argument_list|(
name|firstMetaServer
operator|.
name|getHostname
argument_list|()
argument_list|,
name|firstMetaServer
operator|.
name|getPort
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
operator|(
name|this
operator|.
name|numRetries
operator|*
name|this
operator|.
name|retryLongerMultiplier
operator|)
condition|;
name|tries
operator|++
control|)
block|{
name|long
name|scannerId
init|=
operator|-
literal|1L
decl_stmt|;
try|try
block|{
name|Scan
name|scan
init|=
name|MetaReader
operator|.
name|getScanForTableName
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|scan
operator|.
name|addColumn
argument_list|(
name|HConstants
operator|.
name|CATALOG_FAMILY
argument_list|,
name|HConstants
operator|.
name|REGIONINFO_QUALIFIER
argument_list|)
expr_stmt|;
name|scannerId
operator|=
name|server
operator|.
name|openScanner
argument_list|(
name|firstMetaServer
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|scan
argument_list|)
expr_stmt|;
comment|// Get a batch at a time.
name|Result
name|values
init|=
name|server
operator|.
name|next
argument_list|(
name|scannerId
argument_list|)
decl_stmt|;
if|if
condition|(
name|values
operator|==
literal|null
condition|)
block|{
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
if|if
condition|(
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
comment|// no more tries left
if|if
condition|(
name|ex
operator|instanceof
name|RemoteException
condition|)
block|{
name|ex
operator|=
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
operator|(
name|RemoteException
operator|)
name|ex
argument_list|)
expr_stmt|;
block|}
throw|throw
name|ex
throw|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|scannerId
operator|!=
operator|-
literal|1L
condition|)
block|{
try|try
block|{
name|server
operator|.
name|close
argument_list|(
name|scannerId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|getPauseTime
argument_list|(
name|tries
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// continue
block|}
block|}
comment|// Delete cached information to prevent clients from using old locations
name|this
operator|.
name|connection
operator|.
name|clearRegionCache
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleted "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|enableTable
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|enableTable
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Enable a table.  May timeout.  Use {@link #enableTableAsync(byte[])}    * and {@link #isTableEnabled(byte[])} instead.    * @param tableName name of the table    * @throws IOException if a remote or network exception occurs    * @see #isTableEnabled(byte[])    * @see #disableTable(byte[])    * @see #enableTableAsync(byte[])    */
specifier|public
name|void
name|enableTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|enableTableAsync
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
comment|// Wait until all regions are enabled
name|boolean
name|enabled
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
operator|(
name|this
operator|.
name|numRetries
operator|*
name|this
operator|.
name|retryLongerMultiplier
operator|)
condition|;
name|tries
operator|++
control|)
block|{
name|enabled
operator|=
name|isTableEnabled
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
if|if
condition|(
name|enabled
condition|)
block|{
break|break;
block|}
name|long
name|sleep
init|=
name|getPauseTime
argument_list|(
name|tries
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sleeping= "
operator|+
name|sleep
operator|+
literal|"ms, waiting for all regions to be "
operator|+
literal|"enabled in "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleep
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
comment|// Do this conversion rather than let it out because do not want to
comment|// change the method signature.
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Interrupted"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|enabled
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to enable table "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Enabled table "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|enableTableAsync
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|enableTableAsync
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Brings a table on-line (enables it).  Method returns immediately though    * enable of table may take some time to complete, especially if the table    * is large (All regions are opened as part of enabling process).  Check    * {@link #isTableEnabled(byte[])} to learn when table is fully online.  If    * table is taking too long to online, check server logs.    * @param tableName    * @throws IOException    * @since 0.90.0    */
specifier|public
name|void
name|enableTableAsync
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|isMasterRunning
argument_list|()
expr_stmt|;
try|try
block|{
name|getMaster
argument_list|()
operator|.
name|enableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
throw|throw
name|e
operator|.
name|unwrapRemoteException
argument_list|()
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Started enable of "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|disableTableAsync
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|disableTableAsync
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Starts the disable of a table.  If it is being served, the master    * will tell the servers to stop serving it.  This method returns immediately.    * The disable of a table can take some time if the table is large (all    * regions are closed as part of table disable operation).    * Call {@link #isTableDisabled(byte[])} to check for when disable completes.    * If table is taking too long to online, check server logs.    * @param tableName name of table    * @throws IOException if a remote or network exception occurs    * @see #isTableDisabled(byte[])    * @see #isTableEnabled(byte[])    * @since 0.90.0    */
specifier|public
name|void
name|disableTableAsync
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|isMasterRunning
argument_list|()
expr_stmt|;
try|try
block|{
name|getMaster
argument_list|()
operator|.
name|disableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
throw|throw
name|e
operator|.
name|unwrapRemoteException
argument_list|()
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Started disable of "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|disableTable
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|disableTable
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Disable table and wait on completion.  May timeout eventually.  Use    * {@link #disableTableAsync(byte[])} and {@link #isTableDisabled(String)}    * instead.    * @param tableName    * @throws IOException    */
specifier|public
name|void
name|disableTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|disableTableAsync
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
comment|// Wait until table is disabled
name|boolean
name|disabled
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
operator|(
name|this
operator|.
name|numRetries
operator|*
name|this
operator|.
name|retryLongerMultiplier
operator|)
condition|;
name|tries
operator|++
control|)
block|{
name|disabled
operator|=
name|isTableDisabled
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
if|if
condition|(
name|disabled
condition|)
block|{
break|break;
block|}
name|long
name|sleep
init|=
name|getPauseTime
argument_list|(
name|tries
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sleeping= "
operator|+
name|sleep
operator|+
literal|"ms, waiting for all regions to be "
operator|+
literal|"disabled in "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleep
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// Do this conversion rather than let it out because do not want to
comment|// change the method signature.
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Interrupted"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|disabled
condition|)
block|{
throw|throw
operator|new
name|RegionException
argument_list|(
literal|"Retries exhausted, it took too long to wait"
operator|+
literal|" for the table "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
operator|+
literal|" to be disabled."
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Disabled "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param tableName name of table to check    * @return true if table is on-line    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|boolean
name|isTableEnabled
parameter_list|(
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isTableEnabled
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @param tableName name of table to check    * @return true if table is on-line    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|boolean
name|isTableEnabled
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|HTableDescriptor
operator|.
name|isLegalTableName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
return|return
name|connection
operator|.
name|isTableEnabled
argument_list|(
name|tableName
argument_list|)
return|;
block|}
comment|/**    * @param tableName name of table to check    * @return true if table is off-line    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|boolean
name|isTableDisabled
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isTableDisabled
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @param tableName name of table to check    * @return true if table is off-line    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|boolean
name|isTableDisabled
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|HTableDescriptor
operator|.
name|isLegalTableName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
return|return
name|connection
operator|.
name|isTableDisabled
argument_list|(
name|tableName
argument_list|)
return|;
block|}
comment|/**    * @param tableName name of table to check    * @return true if all regions of the table are available    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|boolean
name|isTableAvailable
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|connection
operator|.
name|isTableAvailable
argument_list|(
name|tableName
argument_list|)
return|;
block|}
comment|/**    * @param tableName name of table to check    * @return true if all regions of the table are available    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|boolean
name|isTableAvailable
parameter_list|(
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|connection
operator|.
name|isTableAvailable
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Add a column to an existing table.    * Asynchronous operation.    *    * @param tableName name of the table to add column to    * @param column column descriptor of column to be added    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|addColumn
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|,
name|HColumnDescriptor
name|column
parameter_list|)
throws|throws
name|IOException
block|{
name|addColumn
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|column
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a column to an existing table.    * Asynchronous operation.    *    * @param tableName name of the table to add column to    * @param column column descriptor of column to be added    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|addColumn
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
name|HColumnDescriptor
name|column
parameter_list|)
throws|throws
name|IOException
block|{
name|HTableDescriptor
operator|.
name|isLegalTableName
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
try|try
block|{
name|getMaster
argument_list|()
operator|.
name|addColumn
argument_list|(
name|tableName
argument_list|,
name|column
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
throw|throw
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Delete a column from a table.    * Asynchronous operation.    *    * @param tableName name of table    * @param columnName name of column to be deleted    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|deleteColumn
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|,
specifier|final
name|String
name|columnName
parameter_list|)
throws|throws
name|IOException
block|{
name|deleteColumn
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|columnName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete a column from a table.    * Asynchronous operation.    *    * @param tableName name of table    * @param columnName name of column to be deleted    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|deleteColumn
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|columnName
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|getMaster
argument_list|()
operator|.
name|deleteColumn
argument_list|(
name|tableName
argument_list|,
name|columnName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
throw|throw
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Modify an existing column family on a table.    * Asynchronous operation.    *    * @param tableName name of table    * @param columnName name of column to be modified    * @param descriptor new column descriptor to use    * @throws IOException if a remote or network exception occurs    * @deprecated The<code>columnName</code> is redundant. Use {@link #addColumn(String, HColumnDescriptor)}    */
specifier|public
name|void
name|modifyColumn
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|,
specifier|final
name|String
name|columnName
parameter_list|,
name|HColumnDescriptor
name|descriptor
parameter_list|)
throws|throws
name|IOException
block|{
name|modifyColumn
argument_list|(
name|tableName
argument_list|,
name|descriptor
argument_list|)
expr_stmt|;
block|}
comment|/**    * Modify an existing column family on a table.    * Asynchronous operation.    *    * @param tableName name of table    * @param descriptor new column descriptor to use    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|modifyColumn
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|,
name|HColumnDescriptor
name|descriptor
parameter_list|)
throws|throws
name|IOException
block|{
name|modifyColumn
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|descriptor
argument_list|)
expr_stmt|;
block|}
comment|/**    * Modify an existing column family on a table.    * Asynchronous operation.    *    * @param tableName name of table    * @param columnName name of column to be modified    * @param descriptor new column descriptor to use    * @throws IOException if a remote or network exception occurs    * @deprecated The<code>columnName</code> is redundant. Use {@link #modifyColumn(byte[], HColumnDescriptor)}    */
specifier|public
name|void
name|modifyColumn
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|columnName
parameter_list|,
name|HColumnDescriptor
name|descriptor
parameter_list|)
throws|throws
name|IOException
block|{
name|modifyColumn
argument_list|(
name|tableName
argument_list|,
name|descriptor
argument_list|)
expr_stmt|;
block|}
comment|/**    * Modify an existing column family on a table.    * Asynchronous operation.    *    * @param tableName name of table    * @param descriptor new column descriptor to use    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|modifyColumn
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
name|HColumnDescriptor
name|descriptor
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|getMaster
argument_list|()
operator|.
name|modifyColumn
argument_list|(
name|tableName
argument_list|,
name|descriptor
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
comment|// Convert RE exceptions in here; client shouldn't have to deal with them,
comment|// at least w/ the type of exceptions that come out of this method:
comment|// TableNotFoundException, etc.
throw|throw
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
name|re
argument_list|)
throw|;
block|}
block|}
comment|/**    * Close a region. For expert-admins.  Runs close on the regionserver.  The    * master will not be informed of the close.    * @param regionname region name to close    * @param hostAndPort If supplied, we'll use this location rather than    * the one currently in<code>.META.</code>    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|closeRegion
parameter_list|(
specifier|final
name|String
name|regionname
parameter_list|,
specifier|final
name|String
name|hostAndPort
parameter_list|)
throws|throws
name|IOException
block|{
name|closeRegion
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|regionname
argument_list|)
argument_list|,
name|hostAndPort
argument_list|)
expr_stmt|;
block|}
comment|/**    * Close a region.  For expert-admins  Runs close on the regionserver.  The    * master will not be informed of the close.    * @param regionname region name to close    * @param hostAndPort If supplied, we'll use this location rather than    * the one currently in<code>.META.</code>    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|closeRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|regionname
parameter_list|,
specifier|final
name|String
name|hostAndPort
parameter_list|)
throws|throws
name|IOException
block|{
name|CatalogTracker
name|ct
init|=
name|getCatalogTracker
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|hostAndPort
operator|!=
literal|null
condition|)
block|{
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
init|=
name|MetaReader
operator|.
name|getRegion
argument_list|(
name|ct
argument_list|,
name|regionname
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
literal|null
operator|||
name|pair
operator|.
name|getSecond
argument_list|()
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No server in .META. for "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionname
argument_list|)
operator|+
literal|"; pair="
operator|+
name|pair
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|closeRegion
argument_list|(
name|pair
operator|.
name|getSecond
argument_list|()
argument_list|,
name|pair
operator|.
name|getFirst
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
init|=
name|MetaReader
operator|.
name|getRegion
argument_list|(
name|ct
argument_list|,
name|regionname
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
literal|null
operator|||
name|pair
operator|.
name|getSecond
argument_list|()
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No server in .META. for "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionname
argument_list|)
operator|+
literal|"; pair="
operator|+
name|pair
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|closeRegion
argument_list|(
name|pair
operator|.
name|getSecond
argument_list|()
argument_list|,
name|pair
operator|.
name|getFirst
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|cleanupCatalogTracker
argument_list|(
name|ct
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|closeRegion
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|,
specifier|final
name|HRegionInfo
name|hri
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegionInterface
name|rs
init|=
name|this
operator|.
name|connection
operator|.
name|getHRegionConnection
argument_list|(
name|sn
operator|.
name|getHostname
argument_list|()
argument_list|,
name|sn
operator|.
name|getPort
argument_list|()
argument_list|)
decl_stmt|;
comment|// Close the region without updating zk state.
name|rs
operator|.
name|closeRegion
argument_list|(
name|hri
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Flush a table or an individual region.    * Asynchronous operation.    *    * @param tableNameOrRegionName table or region to flush    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException    */
specifier|public
name|void
name|flush
parameter_list|(
specifier|final
name|String
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|flush
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Flush a table or an individual region.    * Asynchronous operation.    *    * @param tableNameOrRegionName table or region to flush    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException    */
specifier|public
name|void
name|flush
parameter_list|(
specifier|final
name|byte
index|[]
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|boolean
name|isRegionName
init|=
name|isRegionName
argument_list|(
name|tableNameOrRegionName
argument_list|)
decl_stmt|;
name|CatalogTracker
name|ct
init|=
name|getCatalogTracker
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|isRegionName
condition|)
block|{
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
init|=
name|MetaReader
operator|.
name|getRegion
argument_list|(
name|ct
argument_list|,
name|tableNameOrRegionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
literal|null
operator|||
name|pair
operator|.
name|getSecond
argument_list|()
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No server in .META. for "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|tableNameOrRegionName
argument_list|)
operator|+
literal|"; pair="
operator|+
name|pair
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flush
argument_list|(
name|pair
operator|.
name|getSecond
argument_list|()
argument_list|,
name|pair
operator|.
name|getFirst
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|>
name|pairs
init|=
name|MetaReader
operator|.
name|getTableRegionsAndLocations
argument_list|(
name|ct
argument_list|,
name|Bytes
operator|.
name|toString
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
if|if
condition|(
name|pair
operator|.
name|getFirst
argument_list|()
operator|.
name|isOffline
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|pair
operator|.
name|getSecond
argument_list|()
operator|==
literal|null
condition|)
continue|continue;
try|try
block|{
name|flush
argument_list|(
name|pair
operator|.
name|getSecond
argument_list|()
argument_list|,
name|pair
operator|.
name|getFirst
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotServingRegionException
name|e
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Trying to flush "
operator|+
name|pair
operator|.
name|getFirst
argument_list|()
operator|+
literal|": "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
finally|finally
block|{
name|cleanupCatalogTracker
argument_list|(
name|ct
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|flush
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|,
specifier|final
name|HRegionInfo
name|hri
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegionInterface
name|rs
init|=
name|this
operator|.
name|connection
operator|.
name|getHRegionConnection
argument_list|(
name|sn
operator|.
name|getHostname
argument_list|()
argument_list|,
name|sn
operator|.
name|getPort
argument_list|()
argument_list|)
decl_stmt|;
name|rs
operator|.
name|flushRegion
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
comment|/**    * Compact a table or an individual region.    * Asynchronous operation.    *    * @param tableNameOrRegionName table or region to compact    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException    */
specifier|public
name|void
name|compact
parameter_list|(
specifier|final
name|String
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|compact
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Compact a table or an individual region.    * Asynchronous operation.    *    * @param tableNameOrRegionName table or region to compact    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException    */
specifier|public
name|void
name|compact
parameter_list|(
specifier|final
name|byte
index|[]
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|compact
argument_list|(
name|tableNameOrRegionName
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Major compact a table or an individual region.    * Asynchronous operation.    *    * @param tableNameOrRegionName table or region to major compact    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException    */
specifier|public
name|void
name|majorCompact
parameter_list|(
specifier|final
name|String
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|majorCompact
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Major compact a table or an individual region.    * Asynchronous operation.    *    * @param tableNameOrRegionName table or region to major compact    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException    */
specifier|public
name|void
name|majorCompact
parameter_list|(
specifier|final
name|byte
index|[]
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|compact
argument_list|(
name|tableNameOrRegionName
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Compact a table or an individual region.    * Asynchronous operation.    *    * @param tableNameOrRegionName table or region to compact    * @param major True if we are to do a major compaction.    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException    */
specifier|private
name|void
name|compact
parameter_list|(
specifier|final
name|byte
index|[]
name|tableNameOrRegionName
parameter_list|,
specifier|final
name|boolean
name|major
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|CatalogTracker
name|ct
init|=
name|getCatalogTracker
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|isRegionName
argument_list|(
name|tableNameOrRegionName
argument_list|)
condition|)
block|{
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
init|=
name|MetaReader
operator|.
name|getRegion
argument_list|(
name|ct
argument_list|,
name|tableNameOrRegionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
literal|null
operator|||
name|pair
operator|.
name|getSecond
argument_list|()
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No server in .META. for "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|tableNameOrRegionName
argument_list|)
operator|+
literal|"; pair="
operator|+
name|pair
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|compact
argument_list|(
name|pair
operator|.
name|getSecond
argument_list|()
argument_list|,
name|pair
operator|.
name|getFirst
argument_list|()
argument_list|,
name|major
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|>
name|pairs
init|=
name|MetaReader
operator|.
name|getTableRegionsAndLocations
argument_list|(
name|ct
argument_list|,
name|Bytes
operator|.
name|toString
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
if|if
condition|(
name|pair
operator|.
name|getFirst
argument_list|()
operator|.
name|isOffline
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|pair
operator|.
name|getSecond
argument_list|()
operator|==
literal|null
condition|)
continue|continue;
try|try
block|{
name|compact
argument_list|(
name|pair
operator|.
name|getSecond
argument_list|()
argument_list|,
name|pair
operator|.
name|getFirst
argument_list|()
argument_list|,
name|major
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotServingRegionException
name|e
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Trying to"
operator|+
operator|(
name|major
condition|?
literal|" major"
else|:
literal|""
operator|)
operator|+
literal|" compact "
operator|+
name|pair
operator|.
name|getFirst
argument_list|()
operator|+
literal|": "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
finally|finally
block|{
name|cleanupCatalogTracker
argument_list|(
name|ct
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|compact
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|,
specifier|final
name|HRegionInfo
name|hri
parameter_list|,
specifier|final
name|boolean
name|major
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegionInterface
name|rs
init|=
name|this
operator|.
name|connection
operator|.
name|getHRegionConnection
argument_list|(
name|sn
operator|.
name|getHostname
argument_list|()
argument_list|,
name|sn
operator|.
name|getPort
argument_list|()
argument_list|)
decl_stmt|;
name|rs
operator|.
name|compactRegion
argument_list|(
name|hri
argument_list|,
name|major
argument_list|)
expr_stmt|;
block|}
comment|/**    * Move the region<code>r</code> to<code>dest</code>.    * @param encodedRegionName The encoded region name; i.e. the hash that makes    * up the region name suffix: e.g. if regionname is    *<code>TestTable,0094429456,1289497600452.527db22f95c8a9e0116f0cc13c680396.</code>,    * then the encoded region name is:<code>527db22f95c8a9e0116f0cc13c680396</code>.    * @param destServerName The servername of the destination regionserver.  If    * passed the empty byte array we'll assign to a random server.  A server name    * is made of host, port and startcode.  Here is an example:    *<code> host187.example.com,60020,1289493121758</code>    * @throws UnknownRegionException Thrown if we can't find a region named    *<code>encodedRegionName</code>    * @throws ZooKeeperConnectionException    * @throws MasterNotRunningException    */
specifier|public
name|void
name|move
parameter_list|(
specifier|final
name|byte
index|[]
name|encodedRegionName
parameter_list|,
specifier|final
name|byte
index|[]
name|destServerName
parameter_list|)
throws|throws
name|UnknownRegionException
throws|,
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
block|{
name|getMaster
argument_list|()
operator|.
name|move
argument_list|(
name|encodedRegionName
argument_list|,
name|destServerName
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param regionName Region name to assign.    * @param force True to force assign.    * @throws MasterNotRunningException    * @throws ZooKeeperConnectionException    * @throws IOException    */
specifier|public
name|void
name|assign
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|boolean
name|force
parameter_list|)
throws|throws
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
throws|,
name|IOException
block|{
name|getMaster
argument_list|()
operator|.
name|assign
argument_list|(
name|regionName
argument_list|,
name|force
argument_list|)
expr_stmt|;
block|}
comment|/**    * Unassign a region from current hosting regionserver.  Region will then be    * assigned to a regionserver chosen at random.  Region could be reassigned    * back to the same server.  Use {@link #move(byte[], byte[])} if you want    * to control the region movement.    * @param regionName Region to unassign. Will clear any existing RegionPlan    * if one found.    * @param force If true, force unassign (Will remove region from    * regions-in-transition too if present).    * @throws MasterNotRunningException    * @throws ZooKeeperConnectionException    * @throws IOException    */
specifier|public
name|void
name|unassign
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|boolean
name|force
parameter_list|)
throws|throws
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
throws|,
name|IOException
block|{
name|getMaster
argument_list|()
operator|.
name|unassign
argument_list|(
name|regionName
argument_list|,
name|force
argument_list|)
expr_stmt|;
block|}
comment|/**    * Turn the load balancer on or off.    * @param b If true, enable balancer. If false, disable balancer.    * @return Previous balancer value    */
specifier|public
name|boolean
name|balanceSwitch
parameter_list|(
specifier|final
name|boolean
name|b
parameter_list|)
throws|throws
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
block|{
return|return
name|getMaster
argument_list|()
operator|.
name|balanceSwitch
argument_list|(
name|b
argument_list|)
return|;
block|}
comment|/**    * Invoke the balancer.  Will run the balancer and if regions to move, it will    * go ahead and do the reassignments.  Can NOT run for various reasons.  Check    * logs.    * @return True if balancer ran, false otherwise.    */
specifier|public
name|boolean
name|balancer
parameter_list|()
throws|throws
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
block|{
return|return
name|getMaster
argument_list|()
operator|.
name|balance
argument_list|()
return|;
block|}
comment|/**    * Split a table or an individual region.    * Asynchronous operation.    *    * @param tableNameOrRegionName table or region to split    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException    */
specifier|public
name|void
name|split
parameter_list|(
specifier|final
name|String
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|split
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Split a table or an individual region.  Implicitly finds an optimal split    * point.  Asynchronous operation.    *    * @param tableNameOrRegionName table to region to split    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException    */
specifier|public
name|void
name|split
parameter_list|(
specifier|final
name|byte
index|[]
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|split
argument_list|(
name|tableNameOrRegionName
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|split
parameter_list|(
specifier|final
name|String
name|tableNameOrRegionName
parameter_list|,
specifier|final
name|String
name|splitPoint
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|split
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|splitPoint
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Split a table or an individual region.    * Asynchronous operation.    *    * @param tableNameOrRegionName table to region to split    * @param splitPoint the explicit position to split on    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException interrupt exception occurred    */
specifier|public
name|void
name|split
parameter_list|(
specifier|final
name|byte
index|[]
name|tableNameOrRegionName
parameter_list|,
specifier|final
name|byte
index|[]
name|splitPoint
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|CatalogTracker
name|ct
init|=
name|getCatalogTracker
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|isRegionName
argument_list|(
name|tableNameOrRegionName
argument_list|)
condition|)
block|{
comment|// Its a possible region name.
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
init|=
name|MetaReader
operator|.
name|getRegion
argument_list|(
name|ct
argument_list|,
name|tableNameOrRegionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
literal|null
operator|||
name|pair
operator|.
name|getSecond
argument_list|()
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No server in .META. for "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|tableNameOrRegionName
argument_list|)
operator|+
literal|"; pair="
operator|+
name|pair
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|split
argument_list|(
name|pair
operator|.
name|getSecond
argument_list|()
argument_list|,
name|pair
operator|.
name|getFirst
argument_list|()
argument_list|,
name|splitPoint
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|>
name|pairs
init|=
name|MetaReader
operator|.
name|getTableRegionsAndLocations
argument_list|(
name|ct
argument_list|,
name|Bytes
operator|.
name|toString
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
comment|// May not be a server for a particular row
if|if
condition|(
name|pair
operator|.
name|getSecond
argument_list|()
operator|==
literal|null
condition|)
continue|continue;
name|HRegionInfo
name|r
init|=
name|pair
operator|.
name|getFirst
argument_list|()
decl_stmt|;
comment|// check for parents
if|if
condition|(
name|r
operator|.
name|isSplitParent
argument_list|()
condition|)
continue|continue;
comment|// if a split point given, only split that particular region
if|if
condition|(
name|splitPoint
operator|!=
literal|null
operator|&&
operator|!
name|r
operator|.
name|containsRow
argument_list|(
name|splitPoint
argument_list|)
condition|)
continue|continue;
comment|// call out to region server to do split now
name|split
argument_list|(
name|pair
operator|.
name|getSecond
argument_list|()
argument_list|,
name|pair
operator|.
name|getFirst
argument_list|()
argument_list|,
name|splitPoint
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|cleanupCatalogTracker
argument_list|(
name|ct
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|split
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|,
specifier|final
name|HRegionInfo
name|hri
parameter_list|,
name|byte
index|[]
name|splitPoint
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegionInterface
name|rs
init|=
name|this
operator|.
name|connection
operator|.
name|getHRegionConnection
argument_list|(
name|sn
operator|.
name|getHostname
argument_list|()
argument_list|,
name|sn
operator|.
name|getPort
argument_list|()
argument_list|)
decl_stmt|;
name|rs
operator|.
name|splitRegion
argument_list|(
name|hri
argument_list|,
name|splitPoint
argument_list|)
expr_stmt|;
block|}
comment|/**    * Modify an existing table, more IRB friendly version.    * Asynchronous operation.  This means that it may be a while before your    * schema change is updated across all of the table.    *    * @param tableName name of table.    * @param htd modified description of the table    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|modifyTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
name|HTableDescriptor
name|htd
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|getMaster
argument_list|()
operator|.
name|modifyTable
argument_list|(
name|tableName
argument_list|,
name|htd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
comment|// Convert RE exceptions in here; client shouldn't have to deal with them,
comment|// at least w/ the type of exceptions that come out of this method:
comment|// TableNotFoundException, etc.
throw|throw
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
name|re
argument_list|)
throw|;
block|}
block|}
comment|/**    * @param tableNameOrRegionName Name of a table or name of a region.    * @return True if<code>tableNameOrRegionName</code> is *possibly* a region    * name else false if a verified tablename (we call {@link #tableExists(byte[])};    * else we throw an exception.    * @throws IOException    */
specifier|private
name|boolean
name|isRegionName
parameter_list|(
specifier|final
name|byte
index|[]
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|tableNameOrRegionName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Pass a table name or region name"
argument_list|)
throw|;
block|}
return|return
operator|!
name|tableExists
argument_list|(
name|tableNameOrRegionName
argument_list|)
return|;
block|}
comment|/**    * Shuts down the HBase cluster    * @throws IOException if a remote or network exception occurs    */
specifier|public
specifier|synchronized
name|void
name|shutdown
parameter_list|()
throws|throws
name|IOException
block|{
name|isMasterRunning
argument_list|()
expr_stmt|;
try|try
block|{
name|getMaster
argument_list|()
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
throw|throw
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Shuts down the current HBase master only.    * Does not shutdown the cluster.    * @see #shutdown()    * @throws IOException if a remote or network exception occurs    */
specifier|public
specifier|synchronized
name|void
name|stopMaster
parameter_list|()
throws|throws
name|IOException
block|{
name|isMasterRunning
argument_list|()
expr_stmt|;
try|try
block|{
name|getMaster
argument_list|()
operator|.
name|stopMaster
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
throw|throw
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Stop the designated regionserver.    * @throws IOException if a remote or network exception occurs    * @deprecated Use {@link #stopRegionServer(String)}    */
specifier|public
specifier|synchronized
name|void
name|stopRegionServer
parameter_list|(
specifier|final
name|HServerAddress
name|hsa
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegionInterface
name|rs
init|=
name|this
operator|.
name|connection
operator|.
name|getHRegionConnection
argument_list|(
name|hsa
argument_list|)
decl_stmt|;
name|rs
operator|.
name|stop
argument_list|(
literal|"Called by admin client "
operator|+
name|this
operator|.
name|connection
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Stop the designated regionserver    * @param hostnamePort Hostname and port delimited by a<code>:</code> as in    *<code>example.org:1234</code>    * @throws IOException if a remote or network exception occurs    */
specifier|public
specifier|synchronized
name|void
name|stopRegionServer
parameter_list|(
specifier|final
name|String
name|hostnamePort
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|hostname
init|=
name|Addressing
operator|.
name|parseHostname
argument_list|(
name|hostnamePort
argument_list|)
decl_stmt|;
name|int
name|port
init|=
name|Addressing
operator|.
name|parsePort
argument_list|(
name|hostnamePort
argument_list|)
decl_stmt|;
name|HRegionInterface
name|rs
init|=
name|this
operator|.
name|connection
operator|.
name|getHRegionConnection
argument_list|(
name|hostname
argument_list|,
name|port
argument_list|)
decl_stmt|;
name|rs
operator|.
name|stop
argument_list|(
literal|"Called by admin client "
operator|+
name|this
operator|.
name|connection
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return cluster status    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|ClusterStatus
name|getClusterStatus
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getMaster
argument_list|()
operator|.
name|getClusterStatus
argument_list|()
return|;
block|}
specifier|private
name|HRegionLocation
name|getFirstMetaServerForTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|connection
operator|.
name|locateRegion
argument_list|(
name|HConstants
operator|.
name|META_TABLE_NAME
argument_list|,
name|HRegionInfo
operator|.
name|createRegionName
argument_list|(
name|tableName
argument_list|,
literal|null
argument_list|,
name|HConstants
operator|.
name|NINES
argument_list|,
literal|false
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @return Configuration used by the instance.    */
specifier|public
name|Configuration
name|getConfiguration
parameter_list|()
block|{
return|return
name|this
operator|.
name|conf
return|;
block|}
comment|/**    * Check to see if HBase is running. Throw an exception if not.    *    * @param conf system configuration    * @throws MasterNotRunningException if the master is not running    * @throws ZooKeeperConnectionException if unable to connect to zookeeper    */
specifier|public
specifier|static
name|void
name|checkHBaseAvailable
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
block|{
name|Configuration
name|copyOfConf
init|=
name|HBaseConfiguration
operator|.
name|create
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|copyOfConf
operator|.
name|setInt
argument_list|(
literal|"hbase.client.retries.number"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|new
name|HBaseAdmin
argument_list|(
name|copyOfConf
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|connection
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

