begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2010 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Proxy
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|UndeclaredThrowableException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|ConnectException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketTimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArraySet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|DoNotRetryIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HServerAddress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MasterAddressTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MasterNotRunningException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|RemoteExceptionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ZooKeeperConnectionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MetaScanner
operator|.
name|MetaScannerVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|coprocessor
operator|.
name|Batch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|CoprocessorProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|ExecRPCInvoker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HBaseRPC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HMasterInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HRegionInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|User
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Addressing
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|SoftValueSortedMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Writables
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ClusterId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|RootRegionTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_comment
comment|/**  * A non-instantiable class that manages {@link HConnection}s.  * This class has a static Map of {@link HConnection} instances keyed by  * {@link Configuration}; all invocations of {@link #getConnection(Configuration)}  * that pass the same {@link Configuration} instance will be returned the same  * {@link  HConnection} instance (Adding properties to a Configuration  * instance does not change its object identity).  Sharing {@link HConnection}  * instances is usually what you want; all clients of the {@link HConnection}  * instances share the HConnections' cache of Region locations rather than each  * having to discover for itself the location of meta, root, etc.  It makes  * sense for the likes of the pool of HTables class {@link HTablePool}, for  * instance (If concerned that a single {@link HConnection} is insufficient  * for sharing amongst clients in say an heavily-multithreaded environment,  * in practise its not proven to be an issue.  Besides, {@link HConnection} is  * implemented atop Hadoop RPC and as of this writing, Hadoop RPC does a  * connection per cluster-member, exclusively).  *  *<p>But sharing connections  * makes clean up of {@link HConnection} instances a little awkward.  Currently,  * clients cleanup by calling  * {@link #deleteConnection(Configuration, boolean)}.  This will shutdown the  * zookeeper connection the HConnection was using and clean up all  * HConnection resources as well as stopping proxies to servers out on the  * cluster. Not running the cleanup will not end the world; it'll  * just stall the closeup some and spew some zookeeper connection failed  * messages into the log.  Running the cleanup on a {@link HConnection} that is  * subsequently used by another will cause breakage so be careful running  * cleanup.  *<p>To create a {@link HConnection} that is not shared by others, you can  * create a new {@link Configuration} instance, pass this new instance to  * {@link #getConnection(Configuration)}, and then when done, close it up by  * doing something like the following:  *<pre>  * {@code  * Configuration newConfig = new Configuration(originalConf);  * HConnection connection = HConnectionManager.getConnection(newConfig);  * // Use the connection to your hearts' delight and then when done...  * HConnectionManager.deleteConnection(newConfig, true);  * }  *</pre>  *<p>Cleanup used to be done inside in a shutdown hook.  On startup we'd  * register a shutdown hook that called {@link #deleteAllConnections(boolean)}  * on its way out but the order in which shutdown hooks run is not defined so  * were problematic for clients of HConnection that wanted to register their  * own shutdown hooks so we removed ours though this shifts the onus for  * cleanup to the client.  */
end_comment

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|public
class|class
name|HConnectionManager
block|{
comment|// An LRU Map of HConnectionKey -> HConnection (TableServer).  All
comment|// access must be synchronized.  This map is not private because tests
comment|// need to be able to tinker with it.
specifier|static
specifier|final
name|Map
argument_list|<
name|HConnectionKey
argument_list|,
name|HConnectionImplementation
argument_list|>
name|HBASE_INSTANCES
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|MAX_CACHED_HBASE_INSTANCES
decl_stmt|;
specifier|private
specifier|static
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HConnectionManager
operator|.
name|class
argument_list|)
decl_stmt|;
static|static
block|{
comment|// We set instances to one more than the value specified for {@link
comment|// HConstants#ZOOKEEPER_MAX_CLIENT_CNXNS}. By default, the zk default max
comment|// connections to the ensemble from the one client is 30, so in that case we
comment|// should run into zk issues before the LRU hit this value of 31.
name|MAX_CACHED_HBASE_INSTANCES
operator|=
name|HBaseConfiguration
operator|.
name|create
argument_list|()
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|ZOOKEEPER_MAX_CLIENT_CNXNS
argument_list|,
name|HConstants
operator|.
name|DEFAULT_ZOOKEPER_MAX_CLIENT_CNXNS
argument_list|)
operator|+
literal|1
expr_stmt|;
name|HBASE_INSTANCES
operator|=
operator|new
name|LinkedHashMap
argument_list|<
name|HConnectionKey
argument_list|,
name|HConnectionImplementation
argument_list|>
argument_list|(
call|(
name|int
call|)
argument_list|(
name|MAX_CACHED_HBASE_INSTANCES
operator|/
literal|0.75F
argument_list|)
operator|+
literal|1
argument_list|,
literal|0.75F
argument_list|,
literal|true
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|boolean
name|removeEldestEntry
parameter_list|(
name|Map
operator|.
name|Entry
argument_list|<
name|HConnectionKey
argument_list|,
name|HConnectionImplementation
argument_list|>
name|eldest
parameter_list|)
block|{
return|return
name|size
argument_list|()
operator|>
name|MAX_CACHED_HBASE_INSTANCES
return|;
block|}
block|}
expr_stmt|;
block|}
comment|/*    * Non-instantiable.    */
specifier|protected
name|HConnectionManager
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
comment|/**    * Get the connection that goes with the passed<code>conf</code>    * configuration instance.    * If no current connection exists, method creates a new connection for the    * passed<code>conf</code> instance.    * @param conf configuration    * @return HConnection object for<code>conf</code>    * @throws ZooKeeperConnectionException    */
specifier|public
specifier|static
name|HConnection
name|getConnection
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|ZooKeeperConnectionException
block|{
name|HConnectionKey
name|connectionKey
init|=
operator|new
name|HConnectionKey
argument_list|(
name|conf
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|HBASE_INSTANCES
init|)
block|{
name|HConnectionImplementation
name|connection
init|=
name|HBASE_INSTANCES
operator|.
name|get
argument_list|(
name|connectionKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|connection
operator|==
literal|null
condition|)
block|{
name|connection
operator|=
operator|new
name|HConnectionImplementation
argument_list|(
name|conf
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|HBASE_INSTANCES
operator|.
name|put
argument_list|(
name|connectionKey
argument_list|,
name|connection
argument_list|)
expr_stmt|;
block|}
name|connection
operator|.
name|incCount
argument_list|()
expr_stmt|;
return|return
name|connection
return|;
block|}
block|}
comment|/**    * Create a new HConnection instance using the passed<code>conf</code>    * instance.    * Note: This bypasses the usual HConnection life cycle management!    * Use this with caution, the caller is responsible for closing the    * created connection.    * @param conf configuration    * @return HConnection object for<code>conf</code>    * @throws ZooKeeperConnectionException    */
specifier|public
specifier|static
name|HConnection
name|createConnection
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|ZooKeeperConnectionException
block|{
return|return
operator|new
name|HConnectionImplementation
argument_list|(
name|conf
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Delete connection information for the instance specified by configuration.    * If there are no more references to it, this will then close connection to    * the zookeeper ensemble and let go of all resources.    *    * @param conf    *          configuration whose identity is used to find {@link HConnection}    *          instance.    * @param stopProxy    *          Shuts down all the proxy's put up to cluster members including to    *          cluster HMaster. Calls    *          {@link HBaseRPC#stopProxy(org.apache.hadoop.hbase.ipc.VersionedProtocol)}    *          .    */
specifier|public
specifier|static
name|void
name|deleteConnection
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|stopProxy
parameter_list|)
block|{
name|deleteConnection
argument_list|(
operator|new
name|HConnectionKey
argument_list|(
name|conf
argument_list|)
argument_list|,
name|stopProxy
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete stale connection information for the instance specified by configuration.    * This will then close connection to    * the zookeeper ensemble and let go of all resources.    *    * @param connection    */
specifier|public
specifier|static
name|void
name|deleteStaleConnection
parameter_list|(
name|HConnection
name|connection
parameter_list|)
block|{
name|deleteConnection
argument_list|(
name|connection
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete information for all connections.    * @param stopProxy stop the proxy as well    * @throws IOException    */
specifier|public
specifier|static
name|void
name|deleteAllConnections
parameter_list|(
name|boolean
name|stopProxy
parameter_list|)
block|{
synchronized|synchronized
init|(
name|HBASE_INSTANCES
init|)
block|{
name|Set
argument_list|<
name|HConnectionKey
argument_list|>
name|connectionKeys
init|=
operator|new
name|HashSet
argument_list|<
name|HConnectionKey
argument_list|>
argument_list|()
decl_stmt|;
name|connectionKeys
operator|.
name|addAll
argument_list|(
name|HBASE_INSTANCES
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|HConnectionKey
name|connectionKey
range|:
name|connectionKeys
control|)
block|{
name|deleteConnection
argument_list|(
name|connectionKey
argument_list|,
name|stopProxy
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|HBASE_INSTANCES
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|void
name|deleteConnection
parameter_list|(
name|HConnection
name|connection
parameter_list|,
name|boolean
name|stopProxy
parameter_list|,
name|boolean
name|staleConnection
parameter_list|)
block|{
synchronized|synchronized
init|(
name|HBASE_INSTANCES
init|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|HConnectionKey
argument_list|,
name|HConnectionImplementation
argument_list|>
name|connectionEntry
range|:
name|HBASE_INSTANCES
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|connectionEntry
operator|.
name|getValue
argument_list|()
operator|==
name|connection
condition|)
block|{
name|deleteConnection
argument_list|(
name|connectionEntry
operator|.
name|getKey
argument_list|()
argument_list|,
name|stopProxy
argument_list|,
name|staleConnection
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
specifier|private
specifier|static
name|void
name|deleteConnection
parameter_list|(
name|HConnectionKey
name|connectionKey
parameter_list|,
name|boolean
name|stopProxy
parameter_list|,
name|boolean
name|staleConnection
parameter_list|)
block|{
synchronized|synchronized
init|(
name|HBASE_INSTANCES
init|)
block|{
name|HConnectionImplementation
name|connection
init|=
name|HBASE_INSTANCES
operator|.
name|get
argument_list|(
name|connectionKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|connection
operator|!=
literal|null
condition|)
block|{
name|connection
operator|.
name|decCount
argument_list|()
expr_stmt|;
if|if
condition|(
name|connection
operator|.
name|isZeroReference
argument_list|()
operator|||
name|staleConnection
condition|)
block|{
name|HBASE_INSTANCES
operator|.
name|remove
argument_list|(
name|connectionKey
argument_list|)
expr_stmt|;
name|connection
operator|.
name|close
argument_list|(
name|stopProxy
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stopProxy
condition|)
block|{
name|connection
operator|.
name|stopProxyOnClose
argument_list|(
name|stopProxy
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * It is provided for unit test cases which verify the behavior of region    * location cache prefetch.    * @return Number of cached regions for the table.    * @throws ZooKeeperConnectionException    */
specifier|static
name|int
name|getCachedRegionCount
parameter_list|(
name|Configuration
name|conf
parameter_list|,
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|execute
argument_list|(
operator|new
name|HConnectable
argument_list|<
name|Integer
argument_list|>
argument_list|(
name|conf
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Integer
name|connect
parameter_list|(
name|HConnection
name|connection
parameter_list|)
block|{
return|return
operator|(
operator|(
name|HConnectionImplementation
operator|)
name|connection
operator|)
operator|.
name|getNumberOfCachedRegionLocations
argument_list|(
name|tableName
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * It's provided for unit test cases which verify the behavior of region    * location cache prefetch.    * @return true if the region where the table and row reside is cached.    * @throws ZooKeeperConnectionException    */
specifier|static
name|boolean
name|isRegionCached
parameter_list|(
name|Configuration
name|conf
parameter_list|,
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|execute
argument_list|(
operator|new
name|HConnectable
argument_list|<
name|Boolean
argument_list|>
argument_list|(
name|conf
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|connect
parameter_list|(
name|HConnection
name|connection
parameter_list|)
block|{
return|return
operator|(
operator|(
name|HConnectionImplementation
operator|)
name|connection
operator|)
operator|.
name|isRegionCached
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * This class makes it convenient for one to execute a command in the context    * of a {@link HConnection} instance based on the given {@link Configuration}.    *    *<p>    * If you find yourself wanting to use a {@link HConnection} for a relatively    * short duration of time, and do not want to deal with the hassle of creating    * and cleaning up that resource, then you should consider using this    * convenience class.    *    * @param<T>    *          the return type of the {@link HConnectable#connect(HConnection)}    *          method.    */
specifier|public
specifier|static
specifier|abstract
class|class
name|HConnectable
parameter_list|<
name|T
parameter_list|>
block|{
specifier|public
name|Configuration
name|conf
decl_stmt|;
specifier|public
name|HConnectable
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
block|}
specifier|public
specifier|abstract
name|T
name|connect
parameter_list|(
name|HConnection
name|connection
parameter_list|)
throws|throws
name|IOException
function_decl|;
block|}
comment|/**    * This convenience method invokes the given {@link HConnectable#connect}    * implementation using a {@link HConnection} instance that lasts just for the    * duration of that invocation.    *    * @param<T> the return type of the connect method    * @param connectable the {@link HConnectable} instance    * @return the value returned by the connect method    * @throws IOException    */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|execute
parameter_list|(
name|HConnectable
argument_list|<
name|T
argument_list|>
name|connectable
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|connectable
operator|==
literal|null
operator|||
name|connectable
operator|.
name|conf
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Configuration
name|conf
init|=
name|connectable
operator|.
name|conf
decl_stmt|;
name|HConnection
name|connection
init|=
name|HConnectionManager
operator|.
name|getConnection
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|boolean
name|connectSucceeded
init|=
literal|false
decl_stmt|;
try|try
block|{
name|T
name|returnValue
init|=
name|connectable
operator|.
name|connect
argument_list|(
name|connection
argument_list|)
decl_stmt|;
name|connectSucceeded
operator|=
literal|true
expr_stmt|;
return|return
name|returnValue
return|;
block|}
finally|finally
block|{
try|try
block|{
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|connectSucceeded
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The connection to "
operator|+
name|connection
operator|+
literal|" could not be deleted."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/**    * Denotes a unique key to a {@link HConnection} instance.    *    * In essence, this class captures the properties in {@link Configuration}    * that may be used in the process of establishing a connection. In light of    * that, if any new such properties are introduced into the mix, they must be    * added to the {@link HConnectionKey#properties} list.    *    */
specifier|static
class|class
name|HConnectionKey
block|{
specifier|public
specifier|static
name|String
index|[]
name|CONNECTION_PROPERTIES
init|=
operator|new
name|String
index|[]
block|{
name|HConstants
operator|.
name|ZOOKEEPER_QUORUM
block|,
name|HConstants
operator|.
name|ZOOKEEPER_ZNODE_PARENT
block|,
name|HConstants
operator|.
name|ZOOKEEPER_CLIENT_PORT
block|,
name|HConstants
operator|.
name|ZOOKEEPER_RECOVERABLE_WAITTIME
block|,
name|HConstants
operator|.
name|HBASE_CLIENT_PAUSE
block|,
name|HConstants
operator|.
name|HBASE_CLIENT_RETRIES_NUMBER
block|,
name|HConstants
operator|.
name|HBASE_CLIENT_RPC_MAXATTEMPTS
block|,
name|HConstants
operator|.
name|HBASE_RPC_TIMEOUT_KEY
block|,
name|HConstants
operator|.
name|HBASE_CLIENT_PREFETCH_LIMIT
block|,
name|HConstants
operator|.
name|HBASE_META_SCANNER_CACHING
block|,
name|HConstants
operator|.
name|HBASE_CLIENT_INSTANCE_ID
block|}
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|properties
decl_stmt|;
specifier|private
name|String
name|username
decl_stmt|;
specifier|public
name|HConnectionKey
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|m
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|conf
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|property
range|:
name|CONNECTION_PROPERTIES
control|)
block|{
name|String
name|value
init|=
name|conf
operator|.
name|get
argument_list|(
name|property
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|m
operator|.
name|put
argument_list|(
name|property
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|this
operator|.
name|properties
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|m
argument_list|)
expr_stmt|;
try|try
block|{
name|User
name|currentUser
init|=
name|User
operator|.
name|getCurrent
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentUser
operator|!=
literal|null
condition|)
block|{
name|username
operator|=
name|currentUser
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error obtaining current user, skipping username in HConnectionKey"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
specifier|final
name|int
name|prime
init|=
literal|31
decl_stmt|;
name|int
name|result
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|username
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
name|username
operator|.
name|hashCode
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|String
name|property
range|:
name|CONNECTION_PROPERTIES
control|)
block|{
name|String
name|value
init|=
name|properties
operator|.
name|get
argument_list|(
name|property
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
name|prime
operator|*
name|result
operator|+
name|value
operator|.
name|hashCode
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|obj
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|getClass
argument_list|()
operator|!=
name|obj
operator|.
name|getClass
argument_list|()
condition|)
return|return
literal|false
return|;
name|HConnectionKey
name|that
init|=
operator|(
name|HConnectionKey
operator|)
name|obj
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|username
operator|!=
literal|null
operator|&&
operator|!
name|this
operator|.
name|username
operator|.
name|equals
argument_list|(
name|that
operator|.
name|username
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|this
operator|.
name|username
operator|==
literal|null
operator|&&
name|that
operator|.
name|username
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|this
operator|.
name|properties
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|that
operator|.
name|properties
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|that
operator|.
name|properties
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|String
name|property
range|:
name|CONNECTION_PROPERTIES
control|)
block|{
name|String
name|thisValue
init|=
name|this
operator|.
name|properties
operator|.
name|get
argument_list|(
name|property
argument_list|)
decl_stmt|;
name|String
name|thatValue
init|=
name|that
operator|.
name|properties
operator|.
name|get
argument_list|(
name|property
argument_list|)
decl_stmt|;
if|if
condition|(
name|thisValue
operator|==
name|thatValue
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|thisValue
operator|==
literal|null
operator|||
operator|!
name|thisValue
operator|.
name|equals
argument_list|(
name|thatValue
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
comment|/* Encapsulates connection to zookeeper and regionservers.*/
specifier|static
class|class
name|HConnectionImplementation
implements|implements
name|HConnection
implements|,
name|Closeable
block|{
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HConnectionImplementation
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|HRegionInterface
argument_list|>
name|serverInterfaceClass
decl_stmt|;
specifier|private
specifier|final
name|long
name|pause
decl_stmt|;
specifier|private
specifier|final
name|int
name|numRetries
decl_stmt|;
specifier|private
specifier|final
name|int
name|maxRPCAttempts
decl_stmt|;
specifier|private
specifier|final
name|int
name|rpcTimeout
decl_stmt|;
specifier|private
specifier|final
name|int
name|prefetchRegionLimit
decl_stmt|;
specifier|private
specifier|final
name|Object
name|masterLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|closed
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|aborted
decl_stmt|;
specifier|private
specifier|volatile
name|HMasterInterface
name|master
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|masterChecked
decl_stmt|;
comment|// ZooKeeper reference
specifier|private
name|ZooKeeperWatcher
name|zooKeeper
decl_stmt|;
comment|// ZooKeeper-based master address tracker
specifier|private
name|MasterAddressTracker
name|masterAddressTracker
decl_stmt|;
specifier|private
name|RootRegionTracker
name|rootRegionTracker
decl_stmt|;
specifier|private
name|ClusterId
name|clusterId
decl_stmt|;
specifier|private
specifier|final
name|Object
name|metaRegionLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Object
name|userRegionLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
comment|// Known region HServerAddress.toString() -> HRegionInterface
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|HRegionInterface
argument_list|>
name|servers
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|HRegionInterface
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|connectionLock
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Map of table to table {@link HRegionLocation}s.  The table key is made      * by doing a {@link Bytes#mapKey(byte[])} of the table's name.      */
specifier|private
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|SoftValueSortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
argument_list|>
name|cachedRegionLocations
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|SoftValueSortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// The presence of a server in the map implies it's likely that there is an
comment|// entry in cachedRegionLocations that map to this server; but the absence
comment|// of a server in this map guarentees that there is no entry in cache that
comment|// maps to the absent server.
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|cachedServers
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// region cache prefetch is enabled by default. this set contains all
comment|// tables whose region cache prefetch are disabled.
specifier|private
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|regionCachePrefetchDisabledTables
init|=
operator|new
name|CopyOnWriteArraySet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|stopProxy
decl_stmt|;
specifier|private
name|int
name|refCount
decl_stmt|;
comment|// indicates whether this connection's life cycle is managed
specifier|private
specifier|final
name|boolean
name|managed
decl_stmt|;
comment|/**      * constructor      * @param conf Configuration object      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|HConnectionImplementation
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|managed
parameter_list|)
throws|throws
name|ZooKeeperConnectionException
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|managed
operator|=
name|managed
expr_stmt|;
name|String
name|serverClassName
init|=
name|conf
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|REGION_SERVER_CLASS
argument_list|,
name|HConstants
operator|.
name|DEFAULT_REGION_SERVER_CLASS
argument_list|)
decl_stmt|;
name|this
operator|.
name|closed
operator|=
literal|false
expr_stmt|;
try|try
block|{
name|this
operator|.
name|serverInterfaceClass
operator|=
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|HRegionInterface
argument_list|>
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|serverClassName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Unable to find region server interface "
operator|+
name|serverClassName
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|this
operator|.
name|pause
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_PAUSE
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_PAUSE
argument_list|)
expr_stmt|;
name|this
operator|.
name|numRetries
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_RETRIES_NUMBER
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_RETRIES_NUMBER
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxRPCAttempts
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_RPC_MAXATTEMPTS
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_RPC_MAXATTEMPTS
argument_list|)
expr_stmt|;
name|this
operator|.
name|rpcTimeout
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_RPC_TIMEOUT_KEY
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_RPC_TIMEOUT
argument_list|)
expr_stmt|;
name|this
operator|.
name|prefetchRegionLimit
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_PREFETCH_LIMIT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_PREFETCH_LIMIT
argument_list|)
expr_stmt|;
name|setupZookeeperTrackers
argument_list|()
expr_stmt|;
name|this
operator|.
name|master
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|masterChecked
operator|=
literal|false
expr_stmt|;
block|}
specifier|private
specifier|synchronized
name|void
name|setupZookeeperTrackers
parameter_list|()
throws|throws
name|ZooKeeperConnectionException
block|{
comment|// initialize zookeeper and master address manager
name|this
operator|.
name|zooKeeper
operator|=
name|getZooKeeperWatcher
argument_list|()
expr_stmt|;
name|masterAddressTracker
operator|=
operator|new
name|MasterAddressTracker
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|masterAddressTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|rootRegionTracker
operator|=
operator|new
name|RootRegionTracker
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|rootRegionTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|clusterId
operator|=
operator|new
name|ClusterId
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|synchronized
name|void
name|resetZooKeeperTrackers
parameter_list|()
throws|throws
name|ZooKeeperConnectionException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Trying to reconnect to zookeeper"
argument_list|)
expr_stmt|;
name|masterAddressTracker
operator|.
name|stop
argument_list|()
expr_stmt|;
name|masterAddressTracker
operator|=
literal|null
expr_stmt|;
name|rootRegionTracker
operator|.
name|stop
argument_list|()
expr_stmt|;
name|rootRegionTracker
operator|=
literal|null
expr_stmt|;
name|clusterId
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|zooKeeper
operator|=
literal|null
expr_stmt|;
name|setupZookeeperTrackers
argument_list|()
expr_stmt|;
block|}
specifier|public
name|Configuration
name|getConfiguration
parameter_list|()
block|{
return|return
name|this
operator|.
name|conf
return|;
block|}
specifier|private
name|long
name|getPauseTime
parameter_list|(
name|int
name|tries
parameter_list|)
block|{
name|int
name|ntries
init|=
name|tries
decl_stmt|;
if|if
condition|(
name|ntries
operator|>=
name|HConstants
operator|.
name|RETRY_BACKOFF
operator|.
name|length
condition|)
block|{
name|ntries
operator|=
name|HConstants
operator|.
name|RETRY_BACKOFF
operator|.
name|length
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|this
operator|.
name|pause
operator|*
name|HConstants
operator|.
name|RETRY_BACKOFF
index|[
name|ntries
index|]
return|;
block|}
specifier|public
name|HMasterInterface
name|getMaster
parameter_list|()
throws|throws
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
block|{
comment|// Check if we already have a good master connection
if|if
condition|(
name|master
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|master
operator|.
name|isMasterRunning
argument_list|()
condition|)
block|{
return|return
name|master
return|;
block|}
block|}
name|checkIfBaseNodeAvailable
argument_list|()
expr_stmt|;
name|ServerName
name|sn
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|masterLock
init|)
block|{
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
operator|!
name|this
operator|.
name|closed
operator|&&
operator|!
name|this
operator|.
name|masterChecked
operator|&&
name|this
operator|.
name|master
operator|==
literal|null
operator|&&
name|tries
operator|<
name|numRetries
condition|;
name|tries
operator|++
control|)
block|{
try|try
block|{
name|sn
operator|=
name|masterAddressTracker
operator|.
name|getMasterAddress
argument_list|()
expr_stmt|;
if|if
condition|(
name|sn
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"ZooKeeper available but no active master location found"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MasterNotRunningException
argument_list|()
throw|;
block|}
if|if
condition|(
name|clusterId
operator|.
name|hasId
argument_list|()
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|HConstants
operator|.
name|CLUSTER_ID
argument_list|,
name|clusterId
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|InetSocketAddress
name|isa
init|=
operator|new
name|InetSocketAddress
argument_list|(
name|sn
operator|.
name|getHostname
argument_list|()
argument_list|,
name|sn
operator|.
name|getPort
argument_list|()
argument_list|)
decl_stmt|;
name|HMasterInterface
name|tryMaster
init|=
operator|(
name|HMasterInterface
operator|)
name|HBaseRPC
operator|.
name|getProxy
argument_list|(
name|HMasterInterface
operator|.
name|class
argument_list|,
name|HMasterInterface
operator|.
name|VERSION
argument_list|,
name|isa
argument_list|,
name|this
operator|.
name|conf
argument_list|,
name|this
operator|.
name|rpcTimeout
argument_list|)
decl_stmt|;
if|if
condition|(
name|tryMaster
operator|.
name|isMasterRunning
argument_list|()
condition|)
block|{
name|this
operator|.
name|master
operator|=
name|tryMaster
expr_stmt|;
name|this
operator|.
name|masterLock
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
comment|// This was our last chance - don't bother sleeping
name|LOG
operator|.
name|info
argument_list|(
literal|"getMaster attempt "
operator|+
name|tries
operator|+
literal|" of "
operator|+
name|this
operator|.
name|numRetries
operator|+
literal|" failed; no more retrying."
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"getMaster attempt "
operator|+
name|tries
operator|+
literal|" of "
operator|+
name|this
operator|.
name|numRetries
operator|+
literal|" failed; retrying after sleep of "
operator|+
name|getPauseTime
argument_list|(
name|tries
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// Cannot connect to master or it is not running. Sleep& retry
try|try
block|{
name|this
operator|.
name|masterLock
operator|.
name|wait
argument_list|(
name|getPauseTime
argument_list|(
name|tries
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Thread was interrupted while trying to connect to master."
argument_list|)
throw|;
block|}
block|}
name|this
operator|.
name|masterChecked
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|master
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|sn
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|MasterNotRunningException
argument_list|()
throw|;
block|}
throw|throw
operator|new
name|MasterNotRunningException
argument_list|(
name|sn
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|this
operator|.
name|master
return|;
block|}
specifier|private
name|void
name|checkIfBaseNodeAvailable
parameter_list|()
throws|throws
name|MasterNotRunningException
block|{
if|if
condition|(
literal|false
operator|==
name|masterAddressTracker
operator|.
name|checkIfBaseNodeAvailable
argument_list|()
condition|)
block|{
name|String
name|errorMsg
init|=
literal|"Check the value configured in 'zookeeper.znode.parent'. "
operator|+
literal|"There could be a mismatch with the one configured in the master."
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|errorMsg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MasterNotRunningException
argument_list|(
name|errorMsg
argument_list|)
throw|;
block|}
block|}
specifier|public
name|boolean
name|isMasterRunning
parameter_list|()
throws|throws
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
block|{
if|if
condition|(
name|this
operator|.
name|master
operator|==
literal|null
condition|)
block|{
name|getMaster
argument_list|()
expr_stmt|;
block|}
name|boolean
name|isRunning
init|=
name|master
operator|.
name|isMasterRunning
argument_list|()
decl_stmt|;
if|if
condition|(
name|isRunning
condition|)
block|{
return|return
literal|true
return|;
block|}
throw|throw
operator|new
name|MasterNotRunningException
argument_list|()
throw|;
block|}
specifier|public
name|HRegionLocation
name|getRegionLocation
parameter_list|(
specifier|final
name|byte
index|[]
name|name
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
name|boolean
name|reload
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|reload
condition|?
name|relocateRegion
argument_list|(
name|name
argument_list|,
name|row
argument_list|)
else|:
name|locateRegion
argument_list|(
name|name
argument_list|,
name|row
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isTableEnabled
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|testTableOnlineState
argument_list|(
name|tableName
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isTableDisabled
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|testTableOnlineState
argument_list|(
name|tableName
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isTableAvailable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|AtomicBoolean
name|available
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|AtomicInteger
name|regionCount
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|MetaScannerVisitor
name|visitor
init|=
operator|new
name|MetaScannerVisitor
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|processRow
parameter_list|(
name|Result
name|row
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|value
init|=
name|row
operator|.
name|getValue
argument_list|(
name|HConstants
operator|.
name|CATALOG_FAMILY
argument_list|,
name|HConstants
operator|.
name|REGIONINFO_QUALIFIER
argument_list|)
decl_stmt|;
name|HRegionInfo
name|info
init|=
name|Writables
operator|.
name|getHRegionInfoOrNull
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|tableName
argument_list|,
name|info
operator|.
name|getTableName
argument_list|()
argument_list|)
condition|)
block|{
name|value
operator|=
name|row
operator|.
name|getValue
argument_list|(
name|HConstants
operator|.
name|CATALOG_FAMILY
argument_list|,
name|HConstants
operator|.
name|SERVER_QUALIFIER
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|available
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|regionCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
decl_stmt|;
name|MetaScanner
operator|.
name|metaScan
argument_list|(
name|conf
argument_list|,
name|visitor
argument_list|)
expr_stmt|;
return|return
name|available
operator|.
name|get
argument_list|()
operator|&&
operator|(
name|regionCount
operator|.
name|get
argument_list|()
operator|>
literal|0
operator|)
return|;
block|}
comment|/*      * @param True if table is online      */
specifier|private
name|boolean
name|testTableOnlineState
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|,
name|boolean
name|online
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|tableName
argument_list|,
name|HConstants
operator|.
name|ROOT_TABLE_NAME
argument_list|)
condition|)
block|{
comment|// The root region is always enabled
return|return
name|online
return|;
block|}
name|String
name|tableNameStr
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|online
condition|)
block|{
return|return
name|ZKTable
operator|.
name|isEnabledTable
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|tableNameStr
argument_list|)
return|;
block|}
return|return
name|ZKTable
operator|.
name|isDisabledTable
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|tableNameStr
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Enable/Disable failed"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|HRegionLocation
name|locateRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO implement.  use old stuff or new stuff?
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|HRegionLocation
argument_list|>
name|locateRegions
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO implement.  use old stuff or new stuff?
return|return
literal|null
return|;
block|}
specifier|public
name|HRegionLocation
name|locateRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|locateRegion
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|public
name|HRegionLocation
name|relocateRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|locateRegion
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|private
name|HRegionLocation
name|locateRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
name|boolean
name|useCache
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|closed
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
name|toString
argument_list|()
operator|+
literal|" closed"
argument_list|)
throw|;
if|if
condition|(
name|tableName
operator|==
literal|null
operator|||
name|tableName
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"table name cannot be null or zero length"
argument_list|)
throw|;
block|}
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|tableName
argument_list|,
name|HConstants
operator|.
name|ROOT_TABLE_NAME
argument_list|)
condition|)
block|{
try|try
block|{
name|ServerName
name|servername
init|=
name|this
operator|.
name|rootRegionTracker
operator|.
name|waitRootRegionLocation
argument_list|(
name|this
operator|.
name|rpcTimeout
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Lookedup root region location, connection="
operator|+
name|this
operator|+
literal|"; serverName="
operator|+
operator|(
operator|(
name|servername
operator|==
literal|null
operator|)
condition|?
literal|""
else|:
name|servername
operator|.
name|toString
argument_list|()
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|servername
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
operator|new
name|HRegionLocation
argument_list|(
name|HRegionInfo
operator|.
name|ROOT_REGIONINFO
argument_list|,
name|servername
operator|.
name|getHostname
argument_list|()
argument_list|,
name|servername
operator|.
name|getPort
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|tableName
argument_list|,
name|HConstants
operator|.
name|META_TABLE_NAME
argument_list|)
condition|)
block|{
return|return
name|locateRegionInMeta
argument_list|(
name|HConstants
operator|.
name|ROOT_TABLE_NAME
argument_list|,
name|tableName
argument_list|,
name|row
argument_list|,
name|useCache
argument_list|,
name|metaRegionLock
argument_list|)
return|;
block|}
else|else
block|{
comment|// Region not in the cache - have to go to the meta RS
return|return
name|locateRegionInMeta
argument_list|(
name|HConstants
operator|.
name|META_TABLE_NAME
argument_list|,
name|tableName
argument_list|,
name|row
argument_list|,
name|useCache
argument_list|,
name|userRegionLock
argument_list|)
return|;
block|}
block|}
comment|/*      * Search .META. for the HRegionLocation info that contains the table and      * row we're seeking. It will prefetch certain number of regions info and      * save them to the global region cache.      */
specifier|private
name|void
name|prefetchRegionCache
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|)
block|{
comment|// Implement a new visitor for MetaScanner, and use it to walk through
comment|// the .META.
name|MetaScannerVisitor
name|visitor
init|=
operator|new
name|MetaScannerVisitor
argument_list|()
block|{
specifier|public
name|boolean
name|processRow
parameter_list|(
name|Result
name|result
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|byte
index|[]
name|value
init|=
name|result
operator|.
name|getValue
argument_list|(
name|HConstants
operator|.
name|CATALOG_FAMILY
argument_list|,
name|HConstants
operator|.
name|REGIONINFO_QUALIFIER
argument_list|)
decl_stmt|;
name|HRegionInfo
name|regionInfo
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
comment|// convert the row result into the HRegionLocation we need!
name|regionInfo
operator|=
name|Writables
operator|.
name|getHRegionInfo
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|// possible we got a region of a different table...
if|if
condition|(
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|regionInfo
operator|.
name|getTableName
argument_list|()
argument_list|,
name|tableName
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
comment|// stop scanning
block|}
if|if
condition|(
name|regionInfo
operator|.
name|isOffline
argument_list|()
condition|)
block|{
comment|// don't cache offline regions
return|return
literal|true
return|;
block|}
name|value
operator|=
name|result
operator|.
name|getValue
argument_list|(
name|HConstants
operator|.
name|CATALOG_FAMILY
argument_list|,
name|HConstants
operator|.
name|SERVER_QUALIFIER
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
comment|// don't cache it
block|}
specifier|final
name|String
name|hostAndPort
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|String
name|hostname
init|=
name|Addressing
operator|.
name|parseHostname
argument_list|(
name|hostAndPort
argument_list|)
decl_stmt|;
name|int
name|port
init|=
name|Addressing
operator|.
name|parsePort
argument_list|(
name|hostAndPort
argument_list|)
decl_stmt|;
name|value
operator|=
name|result
operator|.
name|getValue
argument_list|(
name|HConstants
operator|.
name|CATALOG_FAMILY
argument_list|,
name|HConstants
operator|.
name|STARTCODE_QUALIFIER
argument_list|)
expr_stmt|;
comment|// instantiate the location
name|HRegionLocation
name|loc
init|=
operator|new
name|HRegionLocation
argument_list|(
name|regionInfo
argument_list|,
name|hostname
argument_list|,
name|port
argument_list|)
decl_stmt|;
comment|// cache this meta entry
name|cacheLocation
argument_list|(
name|tableName
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
decl_stmt|;
try|try
block|{
comment|// pre-fetch certain number of regions info at region cache.
name|MetaScanner
operator|.
name|metaScan
argument_list|(
name|conf
argument_list|,
name|visitor
argument_list|,
name|tableName
argument_list|,
name|row
argument_list|,
name|this
operator|.
name|prefetchRegionLimit
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Encountered problems when prefetch META table: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*       * Search one of the meta tables (-ROOT- or .META.) for the HRegionLocation       * info that contains the table and row we're seeking.       */
specifier|private
name|HRegionLocation
name|locateRegionInMeta
parameter_list|(
specifier|final
name|byte
index|[]
name|parentTable
parameter_list|,
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
name|boolean
name|useCache
parameter_list|,
name|Object
name|regionLockObject
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegionLocation
name|location
decl_stmt|;
comment|// If we are supposed to be using the cache, look in the cache to see if
comment|// we already have the region.
if|if
condition|(
name|useCache
condition|)
block|{
name|location
operator|=
name|getCachedLocation
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
literal|null
condition|)
block|{
return|return
name|location
return|;
block|}
block|}
comment|// build the key of the meta region we should be looking for.
comment|// the extra 9's on the end are necessary to allow "exact" matches
comment|// without knowing the precise region names.
name|byte
index|[]
name|metaKey
init|=
name|HRegionInfo
operator|.
name|createRegionName
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|,
name|HConstants
operator|.
name|NINES
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
literal|true
condition|;
name|tries
operator|++
control|)
block|{
if|if
condition|(
name|tries
operator|>=
name|numRetries
condition|)
block|{
throw|throw
operator|new
name|NoServerForRegionException
argument_list|(
literal|"Unable to find region for "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|row
argument_list|)
operator|+
literal|" after "
operator|+
name|numRetries
operator|+
literal|" tries."
argument_list|)
throw|;
block|}
name|HRegionLocation
name|metaLocation
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// locate the root or meta region
name|metaLocation
operator|=
name|locateRegion
argument_list|(
name|parentTable
argument_list|,
name|metaKey
argument_list|)
expr_stmt|;
comment|// If null still, go around again.
if|if
condition|(
name|metaLocation
operator|==
literal|null
condition|)
continue|continue;
name|HRegionInterface
name|server
init|=
name|getHRegionConnection
argument_list|(
name|metaLocation
operator|.
name|getHostname
argument_list|()
argument_list|,
name|metaLocation
operator|.
name|getPort
argument_list|()
argument_list|)
decl_stmt|;
name|Result
name|regionInfoRow
init|=
literal|null
decl_stmt|;
comment|// This block guards against two threads trying to load the meta
comment|// region at the same time. The first will load the meta region and
comment|// the second will use the value that the first one found.
synchronized|synchronized
init|(
name|regionLockObject
init|)
block|{
comment|// If the parent table is META, we may want to pre-fetch some
comment|// region info into the global region cache for this table.
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|parentTable
argument_list|,
name|HConstants
operator|.
name|META_TABLE_NAME
argument_list|)
operator|&&
operator|(
name|getRegionCachePrefetch
argument_list|(
name|tableName
argument_list|)
operator|)
condition|)
block|{
name|prefetchRegionCache
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
comment|// Check the cache again for a hit in case some other thread made the
comment|// same query while we were waiting on the lock. If not supposed to
comment|// be using the cache, delete any existing cached location so it won't
comment|// interfere.
if|if
condition|(
name|useCache
condition|)
block|{
name|location
operator|=
name|getCachedLocation
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
literal|null
condition|)
block|{
return|return
name|location
return|;
block|}
block|}
else|else
block|{
name|deleteCachedLocation
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
comment|// Query the root or meta region for the location of the meta region
name|regionInfoRow
operator|=
name|server
operator|.
name|getClosestRowBefore
argument_list|(
name|metaLocation
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|metaKey
argument_list|,
name|HConstants
operator|.
name|CATALOG_FAMILY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regionInfoRow
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|TableNotFoundException
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
throw|;
block|}
name|byte
index|[]
name|value
init|=
name|regionInfoRow
operator|.
name|getValue
argument_list|(
name|HConstants
operator|.
name|CATALOG_FAMILY
argument_list|,
name|HConstants
operator|.
name|REGIONINFO_QUALIFIER
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
operator|||
name|value
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"HRegionInfo was null or empty in "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|parentTable
argument_list|)
operator|+
literal|", row="
operator|+
name|regionInfoRow
argument_list|)
throw|;
block|}
comment|// convert the row result into the HRegionLocation we need!
name|HRegionInfo
name|regionInfo
init|=
operator|(
name|HRegionInfo
operator|)
name|Writables
operator|.
name|getWritable
argument_list|(
name|value
argument_list|,
operator|new
name|HRegionInfo
argument_list|()
argument_list|)
decl_stmt|;
comment|// possible we got a region of a different table...
if|if
condition|(
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|regionInfo
operator|.
name|getTableName
argument_list|()
argument_list|,
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TableNotFoundException
argument_list|(
literal|"Table '"
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
operator|+
literal|"' was not found, got: "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|regionInfo
operator|.
name|getTableName
argument_list|()
argument_list|)
operator|+
literal|"."
argument_list|)
throw|;
block|}
if|if
condition|(
name|regionInfo
operator|.
name|isSplit
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RegionOfflineException
argument_list|(
literal|"the only available region for"
operator|+
literal|" the required row is a split parent,"
operator|+
literal|" the daughters should be online soon: "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|regionInfo
operator|.
name|isOffline
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RegionOfflineException
argument_list|(
literal|"the region is offline, could"
operator|+
literal|" be caused by a disable table call: "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
throw|;
block|}
name|value
operator|=
name|regionInfoRow
operator|.
name|getValue
argument_list|(
name|HConstants
operator|.
name|CATALOG_FAMILY
argument_list|,
name|HConstants
operator|.
name|SERVER_QUALIFIER
argument_list|)
expr_stmt|;
name|String
name|hostAndPort
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|hostAndPort
operator|=
name|Bytes
operator|.
name|toString
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hostAndPort
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|NoServerForRegionException
argument_list|(
literal|"No server address listed "
operator|+
literal|"in "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|parentTable
argument_list|)
operator|+
literal|" for region "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" containing row "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|row
argument_list|)
argument_list|)
throw|;
block|}
comment|// Instantiate the location
name|String
name|hostname
init|=
name|Addressing
operator|.
name|parseHostname
argument_list|(
name|hostAndPort
argument_list|)
decl_stmt|;
name|int
name|port
init|=
name|Addressing
operator|.
name|parsePort
argument_list|(
name|hostAndPort
argument_list|)
decl_stmt|;
name|location
operator|=
operator|new
name|HRegionLocation
argument_list|(
name|regionInfo
argument_list|,
name|hostname
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|cacheLocation
argument_list|(
name|tableName
argument_list|,
name|location
argument_list|)
expr_stmt|;
return|return
name|location
return|;
block|}
catch|catch
parameter_list|(
name|TableNotFoundException
name|e
parameter_list|)
block|{
comment|// if we got this error, probably means the table just plain doesn't
comment|// exist. rethrow the error immediately. this should always be coming
comment|// from the HTable constructor.
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|RemoteException
condition|)
block|{
name|e
operator|=
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
operator|(
name|RemoteException
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tries
operator|<
name|numRetries
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"locateRegionInMeta parentTable="
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|parentTable
argument_list|)
operator|+
literal|", metaLocation="
operator|+
operator|(
operator|(
name|metaLocation
operator|==
literal|null
operator|)
condition|?
literal|"null"
else|:
literal|"{"
operator|+
name|metaLocation
operator|+
literal|"}"
operator|)
operator|+
literal|", attempt="
operator|+
name|tries
operator|+
literal|" of "
operator|+
name|this
operator|.
name|numRetries
operator|+
literal|" failed; retrying after sleep of "
operator|+
name|getPauseTime
argument_list|(
name|tries
argument_list|)
operator|+
literal|" because: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
comment|// Only relocate the parent region if necessary
if|if
condition|(
operator|!
operator|(
name|e
operator|instanceof
name|RegionOfflineException
operator|||
name|e
operator|instanceof
name|NoServerForRegionException
operator|)
condition|)
block|{
name|relocateRegion
argument_list|(
name|parentTable
argument_list|,
name|metaKey
argument_list|)
expr_stmt|;
block|}
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|getPauseTime
argument_list|(
name|tries
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Giving up trying to location region in "
operator|+
literal|"meta: thread is interrupted."
argument_list|)
throw|;
block|}
block|}
block|}
comment|/*      * Search the cache for a location that fits our table and row key.      * Return null if no suitable region is located. TODO: synchronization note      *      *<p>TODO: This method during writing consumes 15% of CPU doing lookup      * into the Soft Reference SortedMap.  Improve.      *      * @param tableName      * @param row      * @return Null or region location found in cache.      */
name|HRegionLocation
name|getCachedLocation
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|)
block|{
name|SoftValueSortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|tableLocations
init|=
name|getTableLocations
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
comment|// start to examine the cache. we can only do cache actions
comment|// if there's something in the cache for this table.
if|if
condition|(
name|tableLocations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|HRegionLocation
name|rl
init|=
name|tableLocations
operator|.
name|get
argument_list|(
name|row
argument_list|)
decl_stmt|;
if|if
condition|(
name|rl
operator|!=
literal|null
condition|)
block|{
return|return
name|rl
return|;
block|}
comment|// Cut the cache so that we only get the part that could contain
comment|// regions that match our key
name|SoftValueSortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|matchingRegions
init|=
name|tableLocations
operator|.
name|headMap
argument_list|(
name|row
argument_list|)
decl_stmt|;
comment|// if that portion of the map is empty, then we're done. otherwise,
comment|// we need to examine the cached location to verify that it is
comment|// a match by end key as well.
if|if
condition|(
operator|!
name|matchingRegions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|HRegionLocation
name|possibleRegion
init|=
literal|null
decl_stmt|;
try|try
block|{
name|possibleRegion
operator|=
name|matchingRegions
operator|.
name|get
argument_list|(
name|matchingRegions
operator|.
name|lastKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchElementException
name|nsee
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"checkReferences() might have removed the key"
argument_list|,
name|nsee
argument_list|)
expr_stmt|;
block|}
comment|// there is a possibility that the reference was garbage collected
comment|// in the instant since we checked isEmpty().
if|if
condition|(
name|possibleRegion
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|endKey
init|=
name|possibleRegion
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEndKey
argument_list|()
decl_stmt|;
comment|// make sure that the end key is greater than the row we're looking
comment|// for, otherwise the row actually belongs in the next region, not
comment|// this one. the exception case is when the endkey is
comment|// HConstants.EMPTY_START_ROW, signifying that the region we're
comment|// checking is actually the last region in the table.
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|endKey
argument_list|,
name|HConstants
operator|.
name|EMPTY_END_ROW
argument_list|)
operator|||
name|KeyValue
operator|.
name|getRowComparator
argument_list|(
name|tableName
argument_list|)
operator|.
name|compareRows
argument_list|(
name|endKey
argument_list|,
literal|0
argument_list|,
name|endKey
operator|.
name|length
argument_list|,
name|row
argument_list|,
literal|0
argument_list|,
name|row
operator|.
name|length
argument_list|)
operator|>
literal|0
condition|)
block|{
return|return
name|possibleRegion
return|;
block|}
block|}
block|}
comment|// Passed all the way through, so we got nothin - complete cache miss
return|return
literal|null
return|;
block|}
comment|/**      * Delete a cached location      * @param tableName tableName      * @param row      */
name|void
name|deleteCachedLocation
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|cachedRegionLocations
init|)
block|{
name|SoftValueSortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|tableLocations
init|=
name|getTableLocations
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
comment|// start to examine the cache. we can only do cache actions
comment|// if there's something in the cache for this table.
if|if
condition|(
operator|!
name|tableLocations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|HRegionLocation
name|rl
init|=
name|getCachedLocation
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|)
decl_stmt|;
if|if
condition|(
name|rl
operator|!=
literal|null
condition|)
block|{
name|tableLocations
operator|.
name|remove
argument_list|(
name|rl
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getStartKey
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removed "
operator|+
name|rl
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" for tableName="
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
operator|+
literal|" from cache "
operator|+
literal|"because of "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|row
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/*      * Delete all cached entries of a table that maps to a specific location.      *      * @param tablename      * @param server      */
specifier|private
name|void
name|clearCachedLocationForServer
parameter_list|(
specifier|final
name|String
name|server
parameter_list|)
block|{
name|boolean
name|deletedSomething
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|cachedRegionLocations
init|)
block|{
if|if
condition|(
operator|!
name|cachedServers
operator|.
name|contains
argument_list|(
name|server
argument_list|)
condition|)
block|{
return|return;
block|}
for|for
control|(
name|SoftValueSortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|tableLocations
range|:
name|cachedRegionLocations
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|e
range|:
name|tableLocations
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
name|server
argument_list|)
condition|)
block|{
name|tableLocations
operator|.
name|remove
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|deletedSomething
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
name|cachedServers
operator|.
name|remove
argument_list|(
name|server
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|deletedSomething
operator|&&
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removed all cached region locations that map to "
operator|+
name|server
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * @param tableName      * @return Map of cached locations for passed<code>tableName</code>      */
specifier|private
name|SoftValueSortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|getTableLocations
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
block|{
comment|// find the map of cached locations for this table
name|Integer
name|key
init|=
name|Bytes
operator|.
name|mapKey
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|SoftValueSortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|result
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|cachedRegionLocations
init|)
block|{
name|result
operator|=
name|this
operator|.
name|cachedRegionLocations
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
comment|// if tableLocations for this table isn't built yet, make one
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|result
operator|=
operator|new
name|SoftValueSortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
expr_stmt|;
name|this
operator|.
name|cachedRegionLocations
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clearRegionCache
parameter_list|()
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|cachedRegionLocations
init|)
block|{
name|this
operator|.
name|cachedRegionLocations
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|cachedServers
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|clearRegionCache
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|cachedRegionLocations
init|)
block|{
name|this
operator|.
name|cachedRegionLocations
operator|.
name|remove
argument_list|(
name|Bytes
operator|.
name|mapKey
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Put a newly discovered HRegionLocation into the cache.      */
specifier|private
name|void
name|cacheLocation
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|HRegionLocation
name|location
parameter_list|)
block|{
name|byte
index|[]
name|startKey
init|=
name|location
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getStartKey
argument_list|()
decl_stmt|;
name|SoftValueSortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|tableLocations
init|=
name|getTableLocations
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|boolean
name|hasNewCache
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|cachedRegionLocations
init|)
block|{
name|cachedServers
operator|.
name|add
argument_list|(
name|location
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|hasNewCache
operator|=
operator|(
name|tableLocations
operator|.
name|put
argument_list|(
name|startKey
argument_list|,
name|location
argument_list|)
operator|==
literal|null
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|hasNewCache
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Cached location for "
operator|+
name|location
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" is "
operator|+
name|location
operator|.
name|getHostnamePort
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|HRegionInterface
name|getHRegionConnection
parameter_list|(
name|HServerAddress
name|hsa
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getHRegionConnection
argument_list|(
name|hsa
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|HRegionInterface
name|getHRegionConnection
parameter_list|(
specifier|final
name|String
name|hostname
parameter_list|,
specifier|final
name|int
name|port
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getHRegionConnection
argument_list|(
name|hostname
argument_list|,
name|port
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
name|HRegionInterface
name|getHRegionConnection
parameter_list|(
name|HServerAddress
name|hsa
parameter_list|,
name|boolean
name|master
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getHRegionConnection
argument_list|(
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
name|hsa
operator|.
name|getInetSocketAddress
argument_list|()
argument_list|,
name|master
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|HRegionInterface
name|getHRegionConnection
parameter_list|(
specifier|final
name|String
name|hostname
parameter_list|,
specifier|final
name|int
name|port
parameter_list|,
specifier|final
name|boolean
name|master
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getHRegionConnection
argument_list|(
name|hostname
argument_list|,
name|port
argument_list|,
literal|null
argument_list|,
name|master
argument_list|)
return|;
block|}
comment|/**      * Either the passed<code>isa</code> is null or<code>hostname</code>      * can be but not both.      * @param hostname      * @param port      * @param isa      * @param master      * @return Proxy.      * @throws IOException      */
name|HRegionInterface
name|getHRegionConnection
parameter_list|(
specifier|final
name|String
name|hostname
parameter_list|,
specifier|final
name|int
name|port
parameter_list|,
specifier|final
name|InetSocketAddress
name|isa
parameter_list|,
specifier|final
name|boolean
name|master
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|master
condition|)
name|getMaster
argument_list|()
expr_stmt|;
name|HRegionInterface
name|server
decl_stmt|;
name|String
name|rsName
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isa
operator|!=
literal|null
condition|)
block|{
name|rsName
operator|=
name|Addressing
operator|.
name|createHostAndPortStr
argument_list|(
name|isa
operator|.
name|getHostName
argument_list|()
argument_list|,
name|isa
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rsName
operator|=
name|Addressing
operator|.
name|createHostAndPortStr
argument_list|(
name|hostname
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
comment|// See if we already have a connection (common case)
name|server
operator|=
name|this
operator|.
name|servers
operator|.
name|get
argument_list|(
name|rsName
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
operator|==
literal|null
condition|)
block|{
comment|// create a unique lock for this RS (if necessary)
name|this
operator|.
name|connectionLock
operator|.
name|putIfAbsent
argument_list|(
name|rsName
argument_list|,
name|rsName
argument_list|)
expr_stmt|;
comment|// get the RS lock
synchronized|synchronized
init|(
name|this
operator|.
name|connectionLock
operator|.
name|get
argument_list|(
name|rsName
argument_list|)
init|)
block|{
comment|// do one more lookup in case we were stalled above
name|server
operator|=
name|this
operator|.
name|servers
operator|.
name|get
argument_list|(
name|rsName
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|clusterId
operator|.
name|hasId
argument_list|()
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|HConstants
operator|.
name|CLUSTER_ID
argument_list|,
name|clusterId
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Only create isa when we need to.
name|InetSocketAddress
name|address
init|=
name|isa
operator|!=
literal|null
condition|?
name|isa
else|:
operator|new
name|InetSocketAddress
argument_list|(
name|hostname
argument_list|,
name|port
argument_list|)
decl_stmt|;
comment|// definitely a cache miss. establish an RPC for this RS
name|server
operator|=
operator|(
name|HRegionInterface
operator|)
name|HBaseRPC
operator|.
name|waitForProxy
argument_list|(
name|serverInterfaceClass
argument_list|,
name|HRegionInterface
operator|.
name|VERSION
argument_list|,
name|address
argument_list|,
name|this
operator|.
name|conf
argument_list|,
name|this
operator|.
name|maxRPCAttempts
argument_list|,
name|this
operator|.
name|rpcTimeout
argument_list|,
name|this
operator|.
name|rpcTimeout
argument_list|)
expr_stmt|;
name|this
operator|.
name|servers
operator|.
name|put
argument_list|(
name|Addressing
operator|.
name|createHostAndPortStr
argument_list|(
name|address
operator|.
name|getHostName
argument_list|()
argument_list|,
name|address
operator|.
name|getPort
argument_list|()
argument_list|)
argument_list|,
name|server
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"RemoteException connecting to RS"
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// Throw what the RemoteException was carrying.
throw|throw
name|e
operator|.
name|unwrapRemoteException
argument_list|()
throw|;
block|}
block|}
block|}
block|}
return|return
name|server
return|;
block|}
comment|/**      * Get the ZooKeeper instance for this TableServers instance.      *      * If ZK has not been initialized yet, this will connect to ZK.      * @returns zookeeper reference      * @throws ZooKeeperConnectionException if there's a problem connecting to zk      */
specifier|public
specifier|synchronized
name|ZooKeeperWatcher
name|getZooKeeperWatcher
parameter_list|()
throws|throws
name|ZooKeeperConnectionException
block|{
if|if
condition|(
name|zooKeeper
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|this
operator|.
name|zooKeeper
operator|=
operator|new
name|ZooKeeperWatcher
argument_list|(
name|conf
argument_list|,
literal|"hconnection"
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ZooKeeperConnectionException
name|zce
parameter_list|)
block|{
throw|throw
name|zce
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ZooKeeperConnectionException
argument_list|(
literal|"An error is preventing"
operator|+
literal|" HBase from connecting to ZooKeeper"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|zooKeeper
return|;
block|}
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|getRegionServerWithRetries
parameter_list|(
name|ServerCallable
argument_list|<
name|T
argument_list|>
name|callable
parameter_list|)
throws|throws
name|IOException
throws|,
name|RuntimeException
block|{
name|List
argument_list|<
name|RetriesExhaustedException
operator|.
name|ThrowableWithExtraContext
argument_list|>
name|exceptions
init|=
operator|new
name|ArrayList
argument_list|<
name|RetriesExhaustedException
operator|.
name|ThrowableWithExtraContext
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
name|numRetries
condition|;
name|tries
operator|++
control|)
block|{
try|try
block|{
name|callable
operator|.
name|beforeCall
argument_list|()
expr_stmt|;
name|callable
operator|.
name|connect
argument_list|(
name|tries
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|callable
operator|.
name|call
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|callable
operator|.
name|shouldRetry
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|translateException
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|SocketTimeoutException
operator|||
name|t
operator|instanceof
name|ConnectException
operator|||
name|t
operator|instanceof
name|RetriesExhaustedException
condition|)
block|{
comment|// if thrown these exceptions, we clear all the cache entries that
comment|// map to that slow/dead server; otherwise, let cache miss and ask
comment|// .META. again to find the new location
name|HRegionLocation
name|hrl
init|=
name|callable
operator|.
name|location
decl_stmt|;
if|if
condition|(
name|hrl
operator|!=
literal|null
condition|)
block|{
name|clearCachedLocationForServer
argument_list|(
name|hrl
operator|.
name|getServerAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|RetriesExhaustedException
operator|.
name|ThrowableWithExtraContext
name|qt
init|=
operator|new
name|RetriesExhaustedException
operator|.
name|ThrowableWithExtraContext
argument_list|(
name|t
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|,
name|callable
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|exceptions
operator|.
name|add
argument_list|(
name|qt
argument_list|)
expr_stmt|;
if|if
condition|(
name|tries
operator|==
name|numRetries
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|RetriesExhaustedException
argument_list|(
name|tries
argument_list|,
name|exceptions
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|callable
operator|.
name|afterCall
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|getPauseTime
argument_list|(
name|tries
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Giving up after tries="
operator|+
name|tries
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|getRegionServerWithoutRetries
parameter_list|(
name|ServerCallable
argument_list|<
name|T
argument_list|>
name|callable
parameter_list|)
throws|throws
name|IOException
throws|,
name|RuntimeException
block|{
try|try
block|{
name|callable
operator|.
name|beforeCall
argument_list|()
expr_stmt|;
name|callable
operator|.
name|connect
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
name|callable
operator|.
name|call
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|Throwable
name|t2
init|=
name|translateException
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|t2
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
operator|(
name|IOException
operator|)
name|t2
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|t2
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|callable
operator|.
name|afterCall
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
parameter_list|<
name|R
parameter_list|>
name|Callable
argument_list|<
name|MultiResponse
argument_list|>
name|createCallable
parameter_list|(
specifier|final
name|HRegionLocation
name|loc
parameter_list|,
specifier|final
name|MultiAction
argument_list|<
name|R
argument_list|>
name|multi
parameter_list|,
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
block|{
specifier|final
name|HConnection
name|connection
init|=
name|this
decl_stmt|;
return|return
operator|new
name|Callable
argument_list|<
name|MultiResponse
argument_list|>
argument_list|()
block|{
specifier|public
name|MultiResponse
name|call
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getRegionServerWithoutRetries
argument_list|(
operator|new
name|ServerCallable
argument_list|<
name|MultiResponse
argument_list|>
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|,
literal|null
argument_list|)
block|{
specifier|public
name|MultiResponse
name|call
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|server
operator|.
name|multi
argument_list|(
name|multi
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|connect
parameter_list|(
name|boolean
name|reload
parameter_list|)
throws|throws
name|IOException
block|{
name|server
operator|=
name|connection
operator|.
name|getHRegionConnection
argument_list|(
name|loc
operator|.
name|getHostname
argument_list|()
argument_list|,
name|loc
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
return|;
block|}
block|}
return|;
block|}
specifier|public
name|void
name|processBatch
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|Row
argument_list|>
name|list
parameter_list|,
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
name|ExecutorService
name|pool
parameter_list|,
name|Object
index|[]
name|results
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
comment|// results must be the same size as list
if|if
condition|(
name|results
operator|.
name|length
operator|!=
name|list
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"argument results must be the same size as argument list"
argument_list|)
throw|;
block|}
name|processBatchCallback
argument_list|(
name|list
argument_list|,
name|tableName
argument_list|,
name|pool
argument_list|,
name|results
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Executes the given      * {@link org.apache.hadoop.hbase.client.coprocessor.Batch.Call}      * callable for each row in the      * given list and invokes      * {@link org.apache.hadoop.hbase.client.coprocessor.Batch.Callback#update(byte[], byte[], Object)}      * for each result returned.      *      * @param protocol the protocol interface being called      * @param rows a list of row keys for which the callable should be invoked      * @param tableName table name for the coprocessor invoked      * @param pool ExecutorService used to submit the calls per row      * @param callable instance on which to invoke      * {@link org.apache.hadoop.hbase.client.coprocessor.Batch.Call#call(Object)}      * for each row      * @param callback instance on which to invoke      * {@link org.apache.hadoop.hbase.client.coprocessor.Batch.Callback#update(byte[], byte[], Object)}      * for each result      * @param<T> the protocol interface type      * @param<R> the callable's return type      * @throws IOException      */
specifier|public
parameter_list|<
name|T
extends|extends
name|CoprocessorProtocol
parameter_list|,
name|R
parameter_list|>
name|void
name|processExecs
parameter_list|(
specifier|final
name|Class
argument_list|<
name|T
argument_list|>
name|protocol
parameter_list|,
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|rows
parameter_list|,
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
name|ExecutorService
name|pool
parameter_list|,
specifier|final
name|Batch
operator|.
name|Call
argument_list|<
name|T
argument_list|,
name|R
argument_list|>
name|callable
parameter_list|,
specifier|final
name|Batch
operator|.
name|Callback
argument_list|<
name|R
argument_list|>
name|callback
parameter_list|)
throws|throws
name|IOException
throws|,
name|Throwable
block|{
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|Future
argument_list|<
name|R
argument_list|>
argument_list|>
name|futures
init|=
operator|new
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|Future
argument_list|<
name|R
argument_list|>
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|byte
index|[]
name|r
range|:
name|rows
control|)
block|{
specifier|final
name|ExecRPCInvoker
name|invoker
init|=
operator|new
name|ExecRPCInvoker
argument_list|(
name|conf
argument_list|,
name|this
argument_list|,
name|protocol
argument_list|,
name|tableName
argument_list|,
name|r
argument_list|)
decl_stmt|;
name|Future
argument_list|<
name|R
argument_list|>
name|future
init|=
name|pool
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|R
argument_list|>
argument_list|()
block|{
specifier|public
name|R
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|T
name|instance
init|=
operator|(
name|T
operator|)
name|Proxy
operator|.
name|newProxyInstance
argument_list|(
name|conf
operator|.
name|getClassLoader
argument_list|()
argument_list|,
operator|new
name|Class
index|[]
block|{
name|protocol
block|}
argument_list|,
name|invoker
argument_list|)
decl_stmt|;
name|R
name|result
init|=
name|callable
operator|.
name|call
argument_list|(
name|instance
argument_list|)
decl_stmt|;
name|byte
index|[]
name|region
init|=
name|invoker
operator|.
name|getRegionName
argument_list|()
decl_stmt|;
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
block|{
name|callback
operator|.
name|update
argument_list|(
name|region
argument_list|,
name|r
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|futures
operator|.
name|put
argument_list|(
name|r
argument_list|,
name|future
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|Future
argument_list|<
name|R
argument_list|>
argument_list|>
name|e
range|:
name|futures
operator|.
name|entrySet
argument_list|()
control|)
block|{
try|try
block|{
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|ee
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error executing for row "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|,
name|ee
argument_list|)
expr_stmt|;
throw|throw
name|ee
operator|.
name|getCause
argument_list|()
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Interrupted executing for row "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|,
name|ie
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * Parameterized batch processing, allowing varying return types for      * different {@link Row} implementations.      */
specifier|public
parameter_list|<
name|R
parameter_list|>
name|void
name|processBatchCallback
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|Row
argument_list|>
name|list
parameter_list|,
name|byte
index|[]
name|tableName
parameter_list|,
name|ExecutorService
name|pool
parameter_list|,
name|Object
index|[]
name|results
parameter_list|,
name|Batch
operator|.
name|Callback
argument_list|<
name|R
argument_list|>
name|callback
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
comment|// results must be the same size as list
if|if
condition|(
name|results
operator|.
name|length
operator|!=
name|list
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"argument results must be the same size as argument list"
argument_list|)
throw|;
block|}
if|if
condition|(
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// Keep track of the most recent servers for any given item for better
comment|// exceptional reporting.  We keep HRegionLocation to save on parsing.
comment|// Later below when we use lastServers, we'll pull what we need from
comment|// lastServers.
name|HRegionLocation
index|[]
name|lastServers
init|=
operator|new
name|HRegionLocation
index|[
name|results
operator|.
name|length
index|]
decl_stmt|;
name|List
argument_list|<
name|Row
argument_list|>
name|workingList
init|=
operator|new
name|ArrayList
argument_list|<
name|Row
argument_list|>
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|boolean
name|retry
init|=
literal|true
decl_stmt|;
comment|// count that helps presize actions array
name|int
name|actionCount
init|=
literal|0
decl_stmt|;
name|Throwable
name|singleRowCause
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
name|numRetries
operator|&&
name|retry
condition|;
operator|++
name|tries
control|)
block|{
comment|// sleep first, if this is a retry
if|if
condition|(
name|tries
operator|>=
literal|1
condition|)
block|{
name|long
name|sleepTime
init|=
name|getPauseTime
argument_list|(
name|tries
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Retry "
operator|+
name|tries
operator|+
literal|", sleep for "
operator|+
name|sleepTime
operator|+
literal|"ms!"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepTime
argument_list|)
expr_stmt|;
block|}
comment|// step 1: break up into regionserver-sized chunks and build the data structs
name|Map
argument_list|<
name|HRegionLocation
argument_list|,
name|MultiAction
argument_list|<
name|R
argument_list|>
argument_list|>
name|actionsByServer
init|=
operator|new
name|HashMap
argument_list|<
name|HRegionLocation
argument_list|,
name|MultiAction
argument_list|<
name|R
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|workingList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Row
name|row
init|=
name|workingList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|row
operator|!=
literal|null
condition|)
block|{
name|HRegionLocation
name|loc
init|=
name|locateRegion
argument_list|(
name|tableName
argument_list|,
name|row
operator|.
name|getRow
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|byte
index|[]
name|regionName
init|=
name|loc
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
decl_stmt|;
name|MultiAction
argument_list|<
name|R
argument_list|>
name|actions
init|=
name|actionsByServer
operator|.
name|get
argument_list|(
name|loc
argument_list|)
decl_stmt|;
if|if
condition|(
name|actions
operator|==
literal|null
condition|)
block|{
name|actions
operator|=
operator|new
name|MultiAction
argument_list|<
name|R
argument_list|>
argument_list|()
expr_stmt|;
name|actionsByServer
operator|.
name|put
argument_list|(
name|loc
argument_list|,
name|actions
argument_list|)
expr_stmt|;
block|}
name|Action
argument_list|<
name|R
argument_list|>
name|action
init|=
operator|new
name|Action
argument_list|<
name|R
argument_list|>
argument_list|(
name|row
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|lastServers
index|[
name|i
index|]
operator|=
name|loc
expr_stmt|;
name|actions
operator|.
name|add
argument_list|(
name|regionName
argument_list|,
name|action
argument_list|)
expr_stmt|;
block|}
block|}
comment|// step 2: make the requests
name|Map
argument_list|<
name|HRegionLocation
argument_list|,
name|Future
argument_list|<
name|MultiResponse
argument_list|>
argument_list|>
name|futures
init|=
operator|new
name|HashMap
argument_list|<
name|HRegionLocation
argument_list|,
name|Future
argument_list|<
name|MultiResponse
argument_list|>
argument_list|>
argument_list|(
name|actionsByServer
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|HRegionLocation
argument_list|,
name|MultiAction
argument_list|<
name|R
argument_list|>
argument_list|>
name|e
range|:
name|actionsByServer
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|futures
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|pool
operator|.
name|submit
argument_list|(
name|createCallable
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|,
name|tableName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// step 3: collect the failures and successes and prepare for retry
for|for
control|(
name|Entry
argument_list|<
name|HRegionLocation
argument_list|,
name|Future
argument_list|<
name|MultiResponse
argument_list|>
argument_list|>
name|responsePerServer
range|:
name|futures
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|HRegionLocation
name|loc
init|=
name|responsePerServer
operator|.
name|getKey
argument_list|()
decl_stmt|;
try|try
block|{
name|Future
argument_list|<
name|MultiResponse
argument_list|>
name|future
init|=
name|responsePerServer
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|MultiResponse
name|resp
init|=
name|future
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|resp
operator|==
literal|null
condition|)
block|{
comment|// Entire server failed
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed all for server: "
operator|+
name|loc
operator|.
name|getHostnamePort
argument_list|()
operator|+
literal|", removing from cache"
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Object
argument_list|>
argument_list|>
argument_list|>
name|e
range|:
name|resp
operator|.
name|getResults
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|byte
index|[]
name|regionName
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Object
argument_list|>
argument_list|>
name|regionResults
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Object
argument_list|>
name|regionResult
range|:
name|regionResults
control|)
block|{
if|if
condition|(
name|regionResult
operator|==
literal|null
condition|)
block|{
comment|// if the first/only record is 'null' the entire region failed.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failures for region: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionName
argument_list|)
operator|+
literal|", removing from cache"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Result might be an Exception, including DNRIOE
name|results
index|[
name|regionResult
operator|.
name|getFirst
argument_list|()
index|]
operator|=
name|regionResult
operator|.
name|getSecond
argument_list|()
expr_stmt|;
if|if
condition|(
name|callback
operator|!=
literal|null
operator|&&
operator|!
operator|(
name|regionResult
operator|.
name|getSecond
argument_list|()
operator|instanceof
name|Throwable
operator|)
condition|)
block|{
name|callback
operator|.
name|update
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|list
operator|.
name|get
argument_list|(
name|regionResult
operator|.
name|getFirst
argument_list|()
argument_list|)
operator|.
name|getRow
argument_list|()
argument_list|,
operator|(
name|R
operator|)
name|regionResult
operator|.
name|getSecond
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed all from "
operator|+
name|loc
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|// step 4: identify failures and prep for a retry (if applicable).
comment|// Find failures (i.e. null Result), and add them to the workingList (in
comment|// order), so they can be retried.
name|retry
operator|=
literal|false
expr_stmt|;
name|workingList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|actionCount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|results
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// if null (fail) or instanceof Throwable&& not instanceof DNRIOE
comment|// then retry that row. else dont.
if|if
condition|(
name|results
index|[
name|i
index|]
operator|==
literal|null
operator|||
operator|(
name|results
index|[
name|i
index|]
operator|instanceof
name|Throwable
operator|&&
operator|!
operator|(
name|results
index|[
name|i
index|]
operator|instanceof
name|DoNotRetryIOException
operator|)
operator|)
condition|)
block|{
name|retry
operator|=
literal|true
expr_stmt|;
name|actionCount
operator|++
expr_stmt|;
name|Row
name|row
init|=
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|workingList
operator|.
name|add
argument_list|(
name|row
argument_list|)
expr_stmt|;
name|deleteCachedLocation
argument_list|(
name|tableName
argument_list|,
name|row
operator|.
name|getRow
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|results
index|[
name|i
index|]
operator|!=
literal|null
operator|&&
name|results
index|[
name|i
index|]
operator|instanceof
name|Throwable
condition|)
block|{
name|actionCount
operator|++
expr_stmt|;
block|}
comment|// add null to workingList, so the order remains consistent with the original list argument.
name|workingList
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|retry
condition|)
block|{
comment|// Simple little check for 1 item failures.
if|if
condition|(
name|singleRowCause
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|singleRowCause
argument_list|)
throw|;
block|}
block|}
name|List
argument_list|<
name|Throwable
argument_list|>
name|exceptions
init|=
operator|new
name|ArrayList
argument_list|<
name|Throwable
argument_list|>
argument_list|(
name|actionCount
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Row
argument_list|>
name|actions
init|=
operator|new
name|ArrayList
argument_list|<
name|Row
argument_list|>
argument_list|(
name|actionCount
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|addresses
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|actionCount
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|results
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|results
index|[
name|i
index|]
operator|==
literal|null
operator|||
name|results
index|[
name|i
index|]
operator|instanceof
name|Throwable
condition|)
block|{
name|exceptions
operator|.
name|add
argument_list|(
operator|(
name|Throwable
operator|)
name|results
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|actions
operator|.
name|add
argument_list|(
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|addresses
operator|.
name|add
argument_list|(
name|lastServers
index|[
name|i
index|]
operator|.
name|getHostnamePort
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|exceptions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RetriesExhaustedWithDetailsException
argument_list|(
name|exceptions
argument_list|,
name|actions
argument_list|,
name|addresses
argument_list|)
throw|;
block|}
block|}
specifier|private
name|Throwable
name|translateException
parameter_list|(
name|Throwable
name|t
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|t
operator|instanceof
name|UndeclaredThrowableException
condition|)
block|{
name|t
operator|=
name|t
operator|.
name|getCause
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|instanceof
name|RemoteException
condition|)
block|{
name|t
operator|=
name|RemoteExceptionHandler
operator|.
name|decodeRemoteException
argument_list|(
operator|(
name|RemoteException
operator|)
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|instanceof
name|DoNotRetryIOException
condition|)
block|{
throw|throw
operator|(
name|DoNotRetryIOException
operator|)
name|t
throw|;
block|}
return|return
name|t
return|;
block|}
comment|/*      * Return the number of cached region for a table. It will only be called      * from a unit test.      */
name|int
name|getNumberOfCachedRegionLocations
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
block|{
name|Integer
name|key
init|=
name|Bytes
operator|.
name|mapKey
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|cachedRegionLocations
init|)
block|{
name|SoftValueSortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|tableLocs
init|=
name|this
operator|.
name|cachedRegionLocations
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|tableLocs
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|tableLocs
operator|.
name|values
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
block|}
comment|/**      * Check the region cache to see whether a region is cached yet or not.      * Called by unit tests.      * @param tableName tableName      * @param row row      * @return Region cached or not.      */
name|boolean
name|isRegionCached
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|)
block|{
name|HRegionLocation
name|location
init|=
name|getCachedLocation
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|)
decl_stmt|;
return|return
name|location
operator|!=
literal|null
return|;
block|}
specifier|public
name|void
name|setRegionCachePrefetch
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|boolean
name|enable
parameter_list|)
block|{
if|if
condition|(
operator|!
name|enable
condition|)
block|{
name|regionCachePrefetchDisabledTables
operator|.
name|add
argument_list|(
name|Bytes
operator|.
name|mapKey
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|regionCachePrefetchDisabledTables
operator|.
name|remove
argument_list|(
name|Bytes
operator|.
name|mapKey
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|getRegionCachePrefetch
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
block|{
return|return
operator|!
name|regionCachePrefetchDisabledTables
operator|.
name|contains
argument_list|(
name|Bytes
operator|.
name|mapKey
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|prewarmRegionCache
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|,
name|Map
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerAddress
argument_list|>
name|regions
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|HRegionInfo
argument_list|,
name|HServerAddress
argument_list|>
name|e
range|:
name|regions
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|HServerAddress
name|hsa
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|hsa
operator|==
literal|null
operator|||
name|hsa
operator|.
name|getInetSocketAddress
argument_list|()
operator|==
literal|null
condition|)
continue|continue;
name|cacheLocation
argument_list|(
name|tableName
argument_list|,
operator|new
name|HRegionLocation
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|hsa
operator|.
name|getHostname
argument_list|()
argument_list|,
name|hsa
operator|.
name|getPort
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|abort
parameter_list|(
specifier|final
name|String
name|msg
parameter_list|,
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|KeeperException
operator|.
name|SessionExpiredException
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"This client just lost it's session with ZooKeeper, trying"
operator|+
literal|" to reconnect."
argument_list|)
expr_stmt|;
name|resetZooKeeperTrackers
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Reconnected successfully. This disconnect could have been"
operator|+
literal|" caused by a network partition or a long-running GC pause,"
operator|+
literal|" either way it's recommended that you verify your environment."
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|ZooKeeperConnectionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Could not reconnect to ZooKeeper after session"
operator|+
literal|" expiration, aborting"
argument_list|)
expr_stmt|;
name|t
operator|=
name|e
expr_stmt|;
block|}
block|}
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
name|LOG
operator|.
name|fatal
argument_list|(
name|msg
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|LOG
operator|.
name|fatal
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|this
operator|.
name|aborted
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|closed
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isClosed
parameter_list|()
block|{
return|return
name|this
operator|.
name|closed
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isAborted
parameter_list|()
block|{
return|return
name|this
operator|.
name|aborted
return|;
block|}
specifier|public
name|int
name|getCurrentNrHRS
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
comment|// We go to zk rather than to master to get count of regions to avoid
comment|// HTable having a Master dependency.  See HBase-2828
return|return
name|ZKUtil
operator|.
name|getNumberOfChildren
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|this
operator|.
name|zooKeeper
operator|.
name|rsZNode
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|ke
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected ZooKeeper exception"
argument_list|,
name|ke
argument_list|)
throw|;
block|}
block|}
specifier|public
name|void
name|stopProxyOnClose
parameter_list|(
name|boolean
name|stopProxy
parameter_list|)
block|{
name|this
operator|.
name|stopProxy
operator|=
name|stopProxy
expr_stmt|;
block|}
comment|/**      * Increment this client's reference count.      */
name|void
name|incCount
parameter_list|()
block|{
operator|++
name|refCount
expr_stmt|;
block|}
comment|/**      * Decrement this client's reference count.      */
name|void
name|decCount
parameter_list|()
block|{
if|if
condition|(
name|refCount
operator|>
literal|0
condition|)
block|{
operator|--
name|refCount
expr_stmt|;
block|}
block|}
comment|/**      * Return if this client has no reference      *      * @return true if this client has no reference; false otherwise      */
name|boolean
name|isZeroReference
parameter_list|()
block|{
return|return
name|refCount
operator|==
literal|0
return|;
block|}
name|void
name|close
parameter_list|(
name|boolean
name|stopProxy
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|closed
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|master
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|stopProxy
condition|)
block|{
name|HBaseRPC
operator|.
name|stopProxy
argument_list|(
name|master
argument_list|)
expr_stmt|;
block|}
name|master
operator|=
literal|null
expr_stmt|;
name|masterChecked
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|stopProxy
condition|)
block|{
for|for
control|(
name|HRegionInterface
name|i
range|:
name|servers
operator|.
name|values
argument_list|()
control|)
block|{
name|HBaseRPC
operator|.
name|stopProxy
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|servers
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|zooKeeper
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Closed zookeeper sessionid=0x"
operator|+
name|Long
operator|.
name|toHexString
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|getSessionId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|zooKeeper
operator|.
name|close
argument_list|()
expr_stmt|;
name|this
operator|.
name|zooKeeper
operator|=
literal|null
expr_stmt|;
block|}
name|this
operator|.
name|closed
operator|=
literal|true
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|managed
condition|)
block|{
name|HConnectionManager
operator|.
name|deleteConnection
argument_list|(
operator|(
name|HConnection
operator|)
name|this
argument_list|,
name|stopProxy
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|close
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"The connection to "
operator|+
name|this
operator|.
name|zooKeeper
operator|+
literal|" has been closed."
argument_list|)
expr_stmt|;
block|}
comment|/**      * Close the connection for good, regardless of what the current value of      * {@link #refCount} is. Ideally, {@link refCount} should be zero at this      * point, which would be the case if all of its consumers close the      * connection. However, on the off chance that someone is unable to close      * the connection, perhaps because it bailed out prematurely, the method      * below will ensure that this {@link Connection} instance is cleaned up.      * Caveat: The JVM may take an unknown amount of time to call finalize on an      * unreachable object, so our hope is that every consumer cleans up after      * itself, like any good citizen.      */
annotation|@
name|Override
specifier|protected
name|void
name|finalize
parameter_list|()
throws|throws
name|Throwable
block|{
comment|// Pretend as if we are about to release the last remaining reference
name|refCount
operator|=
literal|1
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"The connection to "
operator|+
name|this
operator|.
name|zooKeeper
operator|+
literal|" was closed by the finalize method."
argument_list|)
expr_stmt|;
block|}
specifier|public
name|HTableDescriptor
index|[]
name|listTables
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|master
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|master
operator|=
name|getMaster
argument_list|()
expr_stmt|;
block|}
name|HTableDescriptor
index|[]
name|htd
init|=
name|master
operator|.
name|getHTableDescriptors
argument_list|()
decl_stmt|;
return|return
name|htd
return|;
block|}
specifier|public
name|HTableDescriptor
index|[]
name|getHTableDescriptors
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|tableNames
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|tableNames
operator|==
literal|null
operator|||
name|tableNames
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|this
operator|.
name|master
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|master
operator|=
name|getMaster
argument_list|()
expr_stmt|;
block|}
return|return
name|master
operator|.
name|getHTableDescriptors
argument_list|(
name|tableNames
argument_list|)
return|;
block|}
specifier|public
name|HTableDescriptor
name|getHTableDescriptor
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|tableName
operator|==
literal|null
operator|||
name|tableName
operator|.
name|length
operator|==
literal|0
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|tableName
argument_list|,
name|HConstants
operator|.
name|ROOT_TABLE_NAME
argument_list|)
condition|)
block|{
return|return
operator|new
name|UnmodifyableHTableDescriptor
argument_list|(
name|HTableDescriptor
operator|.
name|ROOT_TABLEDESC
argument_list|)
return|;
block|}
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|tableName
argument_list|,
name|HConstants
operator|.
name|META_TABLE_NAME
argument_list|)
condition|)
block|{
return|return
name|HTableDescriptor
operator|.
name|META_TABLEDESC
return|;
block|}
if|if
condition|(
name|this
operator|.
name|master
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|master
operator|=
name|getMaster
argument_list|()
expr_stmt|;
block|}
name|HTableDescriptor
name|hTableDescriptor
init|=
literal|null
decl_stmt|;
name|HTableDescriptor
index|[]
name|htds
init|=
name|master
operator|.
name|getHTableDescriptors
argument_list|()
decl_stmt|;
if|if
condition|(
name|htds
operator|!=
literal|null
operator|&&
name|htds
operator|.
name|length
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|HTableDescriptor
name|htd
range|:
name|htds
control|)
block|{
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|tableName
argument_list|,
name|htd
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|hTableDescriptor
operator|=
name|htd
expr_stmt|;
block|}
block|}
block|}
comment|//HTableDescriptor htd = master.getHTableDescriptor(tableName);
if|if
condition|(
name|hTableDescriptor
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|TableNotFoundException
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|hTableDescriptor
return|;
block|}
block|}
comment|/**    * Set the number of retries to use serverside when trying to communicate    * with another server over {@link HConnection}.  Used updating catalog    * tables, etc.  Call this method before we create any Connections.    * @param c The Configuration instance to set the retries into.    * @param log Used to log what we set in here.    */
specifier|public
specifier|static
name|void
name|setServerSideHConnectionRetries
parameter_list|(
specifier|final
name|Configuration
name|c
parameter_list|,
specifier|final
name|Log
name|log
parameter_list|)
block|{
name|int
name|hcRetries
init|=
name|c
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_RETRIES_NUMBER
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_RETRIES_NUMBER
argument_list|)
decl_stmt|;
comment|// Go big.  Multiply by 10.  If we can't get to meta after this many retries
comment|// then something seriously wrong.
name|int
name|serversideMultiplier
init|=
name|c
operator|.
name|getInt
argument_list|(
literal|"hbase.client.serverside.retries.multiplier"
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|int
name|retries
init|=
name|hcRetries
operator|*
name|serversideMultiplier
decl_stmt|;
name|c
operator|.
name|setInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_RETRIES_NUMBER
argument_list|,
name|retries
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Set serverside HConnection retries="
operator|+
name|retries
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

