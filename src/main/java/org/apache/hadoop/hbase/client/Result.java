begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2010 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|BufferOverflowException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
operator|.
name|SplitKeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|ImmutableBytesWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|WritableWithSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_comment
comment|/**  * Single row result of a {@link Get} or {@link Scan} query.<p>  *  * This class is NOT THREAD SAFE.<p>  *  * Convenience methods are available that return various {@link Map}  * structures and values directly.<p>  *  * To get a complete mapping of all cells in the Result, which can include  * multiple families and multiple versions, use {@link #getMap()}.<p>  *  * To get a mapping of each family to its columns (qualifiers and values),  * including only the latest version of each, use {@link #getNoVersionMap()}.  *  * To get a mapping of qualifiers to latest values for an individual family use  * {@link #getFamilyMap(byte[])}.<p>  *  * To get the latest value for a specific family and qualifier use {@link #getValue(byte[], byte[])}.  *  * A Result is backed by an array of {@link KeyValue} objects, each representing  * an HBase cell defined by the row, family, qualifier, timestamp, and value.<p>  *  * The underlying {@link KeyValue} objects can be accessed through the method {@link #list()}.  * Each KeyValue can then be accessed  * through {@link KeyValue#getRow()}, {@link KeyValue#getFamily()}, {@link KeyValue#getQualifier()},  * {@link KeyValue#getTimestamp()}, and {@link KeyValue#getValue()}.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Stable
specifier|public
class|class
name|Result
implements|implements
name|Writable
implements|,
name|WritableWithSize
block|{
specifier|private
specifier|static
specifier|final
name|byte
name|RESULT_VERSION
init|=
operator|(
name|byte
operator|)
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_BUFFER_SIZE
init|=
literal|1024
decl_stmt|;
specifier|private
name|KeyValue
index|[]
name|kvs
init|=
literal|null
decl_stmt|;
specifier|private
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
argument_list|>
name|familyMap
init|=
literal|null
decl_stmt|;
comment|// We're not using java serialization.  Transient here is just a marker to say
comment|// that this is where we cache row if we're ever asked for it.
specifier|private
specifier|transient
name|byte
index|[]
name|row
init|=
literal|null
decl_stmt|;
specifier|private
name|ImmutableBytesWritable
name|bytes
init|=
literal|null
decl_stmt|;
comment|// never use directly
specifier|private
specifier|static
name|byte
index|[]
name|buffer
init|=
literal|null
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|PAD_WIDTH
init|=
literal|128
decl_stmt|;
comment|/**    * Constructor used for Writable.    */
specifier|public
name|Result
parameter_list|()
block|{}
comment|/**    * Instantiate a Result with the specified array of KeyValues.    * @param kvs array of KeyValues    */
specifier|public
name|Result
parameter_list|(
name|KeyValue
index|[]
name|kvs
parameter_list|)
block|{
if|if
condition|(
name|kvs
operator|!=
literal|null
operator|&&
name|kvs
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|this
operator|.
name|kvs
operator|=
name|kvs
expr_stmt|;
block|}
block|}
comment|/**    * Instantiate a Result with the specified List of KeyValues.    * @param kvs List of KeyValues    */
specifier|public
name|Result
parameter_list|(
name|List
argument_list|<
name|KeyValue
argument_list|>
name|kvs
parameter_list|)
block|{
name|this
argument_list|(
name|kvs
operator|.
name|toArray
argument_list|(
operator|new
name|KeyValue
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Instantiate a Result from the specified raw binary format.    * @param bytes raw binary format of Result    */
specifier|public
name|Result
parameter_list|(
name|ImmutableBytesWritable
name|bytes
parameter_list|)
block|{
name|this
operator|.
name|bytes
operator|=
name|bytes
expr_stmt|;
block|}
comment|/**    * Method for retrieving the row key that corresponds to    * the row from which this Result was created.    * @return row    */
specifier|public
name|byte
index|[]
name|getRow
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|row
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|kvs
operator|==
literal|null
condition|)
block|{
name|readFields
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|row
operator|=
name|this
operator|.
name|kvs
operator|.
name|length
operator|==
literal|0
condition|?
literal|null
else|:
name|this
operator|.
name|kvs
index|[
literal|0
index|]
operator|.
name|getRow
argument_list|()
expr_stmt|;
block|}
return|return
name|this
operator|.
name|row
return|;
block|}
comment|/**    * Return the array of KeyValues backing this Result instance.    *    * The array is sorted from smallest -> largest using the    * {@link KeyValue#COMPARATOR}.    *    * The array only contains what your Get or Scan specifies and no more.    * For example if you request column "A" 1 version you will have at most 1    * KeyValue in the array. If you request column "A" with 2 version you will    * have at most 2 KeyValues, with the first one being the newer timestamp and    * the second being the older timestamp (this is the sort order defined by    * {@link KeyValue#COMPARATOR}).  If columns don't exist, they won't be    * present in the result. Therefore if you ask for 1 version all columns,    * it is safe to iterate over this array and expect to see 1 KeyValue for    * each column and no more.    *    * This API is faster than using getFamilyMap() and getMap()    *    * @return array of KeyValues    */
specifier|public
name|KeyValue
index|[]
name|raw
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|kvs
operator|==
literal|null
condition|)
block|{
name|readFields
argument_list|()
expr_stmt|;
block|}
return|return
name|kvs
return|;
block|}
comment|/**    * Create a sorted list of the KeyValue's in this result.    *    * Since HBase 0.20.5 this is equivalent to raw().    *    * @return The sorted list of KeyValue's.    */
specifier|public
name|List
argument_list|<
name|KeyValue
argument_list|>
name|list
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|kvs
operator|==
literal|null
condition|)
block|{
name|readFields
argument_list|()
expr_stmt|;
block|}
return|return
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|Arrays
operator|.
name|asList
argument_list|(
name|raw
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Return the KeyValues for the specific column.  The KeyValues are sorted in    * the {@link KeyValue#COMPARATOR} order.  That implies the first entry in    * the list is the most recent column.  If the query (Scan or Get) only    * requested 1 version the list will contain at most 1 entry.  If the column    * did not exist in the result set (either the column does not exist    * or the column was not selected in the query) the list will be empty.    *    * Also see getColumnLatest which returns just a KeyValue    *    * @param family the family    * @param qualifier    * @return a list of KeyValues for this column or empty list if the column    * did not exist in the result set    */
specifier|public
name|List
argument_list|<
name|KeyValue
argument_list|>
name|getColumn
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
name|List
argument_list|<
name|KeyValue
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|KeyValue
argument_list|>
argument_list|()
decl_stmt|;
name|KeyValue
index|[]
name|kvs
init|=
name|raw
argument_list|()
decl_stmt|;
if|if
condition|(
name|kvs
operator|==
literal|null
operator|||
name|kvs
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
name|int
name|pos
init|=
name|binarySearch
argument_list|(
name|kvs
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|result
return|;
comment|// cant find it
block|}
for|for
control|(
name|int
name|i
init|=
name|pos
init|;
name|i
operator|<
name|kvs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|KeyValue
name|kv
init|=
name|kvs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|kv
operator|.
name|matchingColumn
argument_list|(
name|family
argument_list|,
name|qualifier
argument_list|)
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|kv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
specifier|protected
name|int
name|binarySearch
parameter_list|(
specifier|final
name|KeyValue
index|[]
name|kvs
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
name|KeyValue
name|searchTerm
init|=
name|KeyValue
operator|.
name|createFirstOnRow
argument_list|(
name|kvs
index|[
literal|0
index|]
operator|.
name|getRow
argument_list|()
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|)
decl_stmt|;
comment|// pos === ( -(insertion point) - 1)
name|int
name|pos
init|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|kvs
argument_list|,
name|searchTerm
argument_list|,
name|KeyValue
operator|.
name|COMPARATOR
argument_list|)
decl_stmt|;
comment|// never will exact match
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
name|pos
operator|=
operator|(
name|pos
operator|+
literal|1
operator|)
operator|*
operator|-
literal|1
expr_stmt|;
comment|// pos is now insertion point
block|}
if|if
condition|(
name|pos
operator|==
name|kvs
operator|.
name|length
condition|)
block|{
return|return
operator|-
literal|1
return|;
comment|// doesn't exist
block|}
return|return
name|pos
return|;
block|}
comment|/**    * Searches for the latest value for the specified column.    *    * @param kvs the array to search    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    *    * @return the index where the value was found, or -1 otherwise    */
specifier|protected
name|int
name|binarySearch
parameter_list|(
specifier|final
name|KeyValue
index|[]
name|kvs
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|int
name|foffset
parameter_list|,
specifier|final
name|int
name|flength
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|int
name|qoffset
parameter_list|,
specifier|final
name|int
name|qlength
parameter_list|)
block|{
name|double
name|keyValueSize
init|=
operator|(
name|double
operator|)
name|KeyValue
operator|.
name|getKeyValueDataStructureSize
argument_list|(
name|kvs
index|[
literal|0
index|]
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|flength
argument_list|,
name|qlength
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|buffer
operator|==
literal|null
operator|||
name|keyValueSize
operator|>
name|buffer
operator|.
name|length
condition|)
block|{
comment|// pad to the smallest multiple of the pad width
name|buffer
operator|=
operator|new
name|byte
index|[
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|keyValueSize
operator|/
name|PAD_WIDTH
argument_list|)
operator|*
name|PAD_WIDTH
index|]
expr_stmt|;
block|}
name|KeyValue
name|searchTerm
init|=
name|KeyValue
operator|.
name|createFirstOnRow
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|kvs
index|[
literal|0
index|]
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|kvs
index|[
literal|0
index|]
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|kvs
index|[
literal|0
index|]
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
decl_stmt|;
comment|// pos === ( -(insertion point) - 1)
name|int
name|pos
init|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|kvs
argument_list|,
name|searchTerm
argument_list|,
name|KeyValue
operator|.
name|COMPARATOR
argument_list|)
decl_stmt|;
comment|// never will exact match
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
name|pos
operator|=
operator|(
name|pos
operator|+
literal|1
operator|)
operator|*
operator|-
literal|1
expr_stmt|;
comment|// pos is now insertion point
block|}
if|if
condition|(
name|pos
operator|==
name|kvs
operator|.
name|length
condition|)
block|{
return|return
operator|-
literal|1
return|;
comment|// doesn't exist
block|}
return|return
name|pos
return|;
block|}
comment|/**    * The KeyValue for the most recent timestamp for a given column.    *    * @param family    * @param qualifier    *    * @return the KeyValue for the column, or null if no value exists in the row or none have been    * selected in the query (Get/Scan)    */
specifier|public
name|KeyValue
name|getColumnLatest
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
name|KeyValue
index|[]
name|kvs
init|=
name|raw
argument_list|()
decl_stmt|;
comment|// side effect possibly.
if|if
condition|(
name|kvs
operator|==
literal|null
operator|||
name|kvs
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|pos
init|=
name|binarySearch
argument_list|(
name|kvs
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
name|KeyValue
name|kv
init|=
name|kvs
index|[
name|pos
index|]
decl_stmt|;
if|if
condition|(
name|kv
operator|.
name|matchingColumn
argument_list|(
name|family
argument_list|,
name|qualifier
argument_list|)
condition|)
block|{
return|return
name|kv
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * The KeyValue for the most recent timestamp for a given column.    *    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    *    * @return the KeyValue for the column, or null if no value exists in the row or none have been    * selected in the query (Get/Scan)    */
specifier|public
name|KeyValue
name|getColumnLatest
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|int
name|foffset
parameter_list|,
name|int
name|flength
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|int
name|qoffset
parameter_list|,
name|int
name|qlength
parameter_list|)
block|{
name|KeyValue
index|[]
name|kvs
init|=
name|raw
argument_list|()
decl_stmt|;
comment|// side effect possibly.
if|if
condition|(
name|kvs
operator|==
literal|null
operator|||
name|kvs
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|pos
init|=
name|binarySearch
argument_list|(
name|kvs
argument_list|,
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
name|KeyValue
name|kv
init|=
name|kvs
index|[
name|pos
index|]
decl_stmt|;
if|if
condition|(
name|kv
operator|.
name|matchingColumn
argument_list|(
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
condition|)
block|{
return|return
name|kv
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Get the latest version of the specified column.    * @param family family name    * @param qualifier column qualifier    * @return value of latest version of column, null if none found    */
specifier|public
name|byte
index|[]
name|getValue
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
name|KeyValue
name|kv
init|=
name|getColumnLatest
argument_list|(
name|family
argument_list|,
name|qualifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|kv
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|kv
operator|.
name|getValue
argument_list|()
return|;
block|}
comment|/**    * Returns the value wrapped in a new<code>ByteBuffer</code>.    *    * @param family family name    * @param qualifier column qualifier    *    * @return the latest version of the column, or<code>null</code> if none found    */
specifier|public
name|ByteBuffer
name|getValueAsByteBuffer
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
name|KeyValue
name|kv
init|=
name|getColumnLatest
argument_list|(
name|family
argument_list|,
literal|0
argument_list|,
name|family
operator|.
name|length
argument_list|,
name|qualifier
argument_list|,
literal|0
argument_list|,
name|qualifier
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|kv
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|kv
operator|.
name|getValueAsByteBuffer
argument_list|()
return|;
block|}
comment|/**    * Returns the value wrapped in a new<code>ByteBuffer</code>.    *    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    *    * @return the latest version of the column, or<code>null</code> if none found    */
specifier|public
name|ByteBuffer
name|getValueAsByteBuffer
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|int
name|foffset
parameter_list|,
name|int
name|flength
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|int
name|qoffset
parameter_list|,
name|int
name|qlength
parameter_list|)
block|{
name|KeyValue
name|kv
init|=
name|getColumnLatest
argument_list|(
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
decl_stmt|;
if|if
condition|(
name|kv
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|kv
operator|.
name|getValueAsByteBuffer
argument_list|()
return|;
block|}
comment|/**    * Loads the latest version of the specified column into the provided<code>ByteBuffer</code>.    *<p>    * Does not clear or flip the buffer.    *    * @param family family name    * @param qualifier column qualifier    * @param dst the buffer where to write the value    *    * @return<code>true</code> if a value was found,<code>false</code> otherwise    *    * @throws BufferOverflowException there is insufficient space remaining in the buffer    */
specifier|public
name|boolean
name|loadValue
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|ByteBuffer
name|dst
parameter_list|)
throws|throws
name|BufferOverflowException
block|{
return|return
name|loadValue
argument_list|(
name|family
argument_list|,
literal|0
argument_list|,
name|family
operator|.
name|length
argument_list|,
name|qualifier
argument_list|,
literal|0
argument_list|,
name|qualifier
operator|.
name|length
argument_list|,
name|dst
argument_list|)
return|;
block|}
comment|/**    * Loads the latest version of the specified column into the provided<code>ByteBuffer</code>.    *<p>    * Does not clear or flip the buffer.    *    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    * @param dst the buffer where to write the value    *    * @return<code>true</code> if a value was found,<code>false</code> otherwise    *    * @throws BufferOverflowException there is insufficient space remaining in the buffer    */
specifier|public
name|boolean
name|loadValue
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|int
name|foffset
parameter_list|,
name|int
name|flength
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|int
name|qoffset
parameter_list|,
name|int
name|qlength
parameter_list|,
name|ByteBuffer
name|dst
parameter_list|)
throws|throws
name|BufferOverflowException
block|{
name|KeyValue
name|kv
init|=
name|getColumnLatest
argument_list|(
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
decl_stmt|;
if|if
condition|(
name|kv
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|kv
operator|.
name|loadValue
argument_list|(
name|dst
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Checks if the specified column contains a non-empty value (not a zero-length byte array).    *    * @param family family name    * @param qualifier column qualifier    *    * @return whether or not a latest value exists and is not empty    */
specifier|public
name|boolean
name|containsNonEmptyColumn
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
return|return
name|containsNonEmptyColumn
argument_list|(
name|family
argument_list|,
literal|0
argument_list|,
name|family
operator|.
name|length
argument_list|,
name|qualifier
argument_list|,
literal|0
argument_list|,
name|qualifier
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * Checks if the specified column contains a non-empty value (not a zero-length byte array).    *    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    *    * @return whether or not a latest value exists and is not empty    */
specifier|public
name|boolean
name|containsNonEmptyColumn
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|int
name|foffset
parameter_list|,
name|int
name|flength
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|int
name|qoffset
parameter_list|,
name|int
name|qlength
parameter_list|)
block|{
name|KeyValue
name|kv
init|=
name|getColumnLatest
argument_list|(
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
decl_stmt|;
return|return
operator|(
name|kv
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|kv
operator|.
name|getValueLength
argument_list|()
operator|>
literal|0
operator|)
return|;
block|}
comment|/**    * Checks if the specified column contains an empty value (a zero-length byte array).    *    * @param family family name    * @param qualifier column qualifier    *    * @return whether or not a latest value exists and is empty    */
specifier|public
name|boolean
name|containsEmptyColumn
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
return|return
name|containsEmptyColumn
argument_list|(
name|family
argument_list|,
literal|0
argument_list|,
name|family
operator|.
name|length
argument_list|,
name|qualifier
argument_list|,
literal|0
argument_list|,
name|qualifier
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * Checks if the specified column contains an empty value (a zero-length byte array).    *    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    *    * @return whether or not a latest value exists and is empty    */
specifier|public
name|boolean
name|containsEmptyColumn
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|int
name|foffset
parameter_list|,
name|int
name|flength
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|int
name|qoffset
parameter_list|,
name|int
name|qlength
parameter_list|)
block|{
name|KeyValue
name|kv
init|=
name|getColumnLatest
argument_list|(
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
decl_stmt|;
return|return
operator|(
name|kv
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|kv
operator|.
name|getValueLength
argument_list|()
operator|==
literal|0
operator|)
return|;
block|}
comment|/**    * Checks for existence of a value for the specified column (empty or not).    *    * @param family family name    * @param qualifier column qualifier    *    * @return true if at least one value exists in the result, false if not    */
specifier|public
name|boolean
name|containsColumn
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
name|KeyValue
name|kv
init|=
name|getColumnLatest
argument_list|(
name|family
argument_list|,
name|qualifier
argument_list|)
decl_stmt|;
return|return
name|kv
operator|!=
literal|null
return|;
block|}
comment|/**    * Checks for existence of a value for the specified column (empty or not).    *    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    *    * @return true if at least one value exists in the result, false if not    */
specifier|public
name|boolean
name|containsColumn
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|int
name|foffset
parameter_list|,
name|int
name|flength
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|int
name|qoffset
parameter_list|,
name|int
name|qlength
parameter_list|)
block|{
return|return
name|getColumnLatest
argument_list|(
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**    * Map of families to all versions of its qualifiers and values.    *<p>    * Returns a three level Map of the form:    *<code>Map&amp;family,Map&lt;qualifier,Map&lt;timestamp,value>>></code>    *<p>    * Note: All other map returning methods make use of this map internally.    * @return map from families to qualifiers to versions    */
specifier|public
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
argument_list|>
name|getMap
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|familyMap
operator|!=
literal|null
condition|)
block|{
return|return
name|this
operator|.
name|familyMap
return|;
block|}
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|this
operator|.
name|familyMap
operator|=
operator|new
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
expr_stmt|;
for|for
control|(
name|KeyValue
name|kv
range|:
name|this
operator|.
name|kvs
control|)
block|{
name|SplitKeyValue
name|splitKV
init|=
name|kv
operator|.
name|split
argument_list|()
decl_stmt|;
name|byte
index|[]
name|family
init|=
name|splitKV
operator|.
name|getFamily
argument_list|()
decl_stmt|;
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|columnMap
init|=
name|familyMap
operator|.
name|get
argument_list|(
name|family
argument_list|)
decl_stmt|;
if|if
condition|(
name|columnMap
operator|==
literal|null
condition|)
block|{
name|columnMap
operator|=
operator|new
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
expr_stmt|;
name|familyMap
operator|.
name|put
argument_list|(
name|family
argument_list|,
name|columnMap
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|qualifier
init|=
name|splitKV
operator|.
name|getQualifier
argument_list|()
decl_stmt|;
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
name|versionMap
init|=
name|columnMap
operator|.
name|get
argument_list|(
name|qualifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|versionMap
operator|==
literal|null
condition|)
block|{
name|versionMap
operator|=
operator|new
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|(
operator|new
name|Comparator
argument_list|<
name|Long
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|Long
name|l1
parameter_list|,
name|Long
name|l2
parameter_list|)
block|{
return|return
name|l2
operator|.
name|compareTo
argument_list|(
name|l1
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|columnMap
operator|.
name|put
argument_list|(
name|qualifier
argument_list|,
name|versionMap
argument_list|)
expr_stmt|;
block|}
name|Long
name|timestamp
init|=
name|Bytes
operator|.
name|toLong
argument_list|(
name|splitKV
operator|.
name|getTimestamp
argument_list|()
argument_list|)
decl_stmt|;
name|byte
index|[]
name|value
init|=
name|splitKV
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|versionMap
operator|.
name|put
argument_list|(
name|timestamp
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|this
operator|.
name|familyMap
return|;
block|}
comment|/**    * Map of families to their most recent qualifiers and values.    *<p>    * Returns a two level Map of the form:<code>Map&amp;family,Map&lt;qualifier,value>></code>    *<p>    * The most recent version of each qualifier will be used.    * @return map from families to qualifiers and value    */
specifier|public
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|getNoVersionMap
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|familyMap
operator|==
literal|null
condition|)
block|{
name|getMap
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|returnMap
init|=
operator|new
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
argument_list|>
name|familyEntry
range|:
name|familyMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|qualifierMap
init|=
operator|new
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|qualifierEntry
range|:
name|familyEntry
operator|.
name|getValue
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|byte
index|[]
name|value
init|=
name|qualifierEntry
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|(
name|qualifierEntry
operator|.
name|getValue
argument_list|()
operator|.
name|firstKey
argument_list|()
argument_list|)
decl_stmt|;
name|qualifierMap
operator|.
name|put
argument_list|(
name|qualifierEntry
operator|.
name|getKey
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|returnMap
operator|.
name|put
argument_list|(
name|familyEntry
operator|.
name|getKey
argument_list|()
argument_list|,
name|qualifierMap
argument_list|)
expr_stmt|;
block|}
return|return
name|returnMap
return|;
block|}
comment|/**    * Map of qualifiers to values.    *<p>    * Returns a Map of the form:<code>Map&lt;qualifier,value></code>    * @param family column family to get    * @return map of qualifiers to values    */
specifier|public
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|getFamilyMap
parameter_list|(
name|byte
index|[]
name|family
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|familyMap
operator|==
literal|null
condition|)
block|{
name|getMap
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|returnMap
init|=
operator|new
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|qualifierMap
init|=
name|familyMap
operator|.
name|get
argument_list|(
name|family
argument_list|)
decl_stmt|;
if|if
condition|(
name|qualifierMap
operator|==
literal|null
condition|)
block|{
return|return
name|returnMap
return|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|entry
range|:
name|qualifierMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|byte
index|[]
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|firstKey
argument_list|()
argument_list|)
decl_stmt|;
name|returnMap
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|returnMap
return|;
block|}
comment|/**    * Returns the value of the first column in the Result.    * @return value of the first column    */
specifier|public
name|byte
index|[]
name|value
parameter_list|()
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|kvs
index|[
literal|0
index|]
operator|.
name|getValue
argument_list|()
return|;
block|}
comment|/**    * Returns the raw binary encoding of this Result.<p>    *    * Please note, there may be an offset into the underlying byte array of the    * returned ImmutableBytesWritable.  Be sure to use both    * {@link ImmutableBytesWritable#get()} and {@link ImmutableBytesWritable#getOffset()}    * @return pointer to raw binary of Result    */
specifier|public
name|ImmutableBytesWritable
name|getBytes
parameter_list|()
block|{
return|return
name|this
operator|.
name|bytes
return|;
block|}
comment|/**    * Check if the underlying KeyValue [] is empty or not    * @return true if empty    */
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|kvs
operator|==
literal|null
condition|)
block|{
name|readFields
argument_list|()
expr_stmt|;
block|}
return|return
name|this
operator|.
name|kvs
operator|==
literal|null
operator|||
name|this
operator|.
name|kvs
operator|.
name|length
operator|==
literal|0
return|;
block|}
comment|/**    * @return the size of the underlying KeyValue []    */
specifier|public
name|int
name|size
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|kvs
operator|==
literal|null
condition|)
block|{
name|readFields
argument_list|()
expr_stmt|;
block|}
return|return
name|this
operator|.
name|kvs
operator|==
literal|null
condition|?
literal|0
else|:
name|this
operator|.
name|kvs
operator|.
name|length
return|;
block|}
comment|/**    * @return String    */
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"keyvalues="
argument_list|)
expr_stmt|;
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"NONE"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|boolean
name|moreThanOne
init|=
literal|false
decl_stmt|;
for|for
control|(
name|KeyValue
name|kv
range|:
name|this
operator|.
name|kvs
control|)
block|{
if|if
condition|(
name|moreThanOne
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|moreThanOne
operator|=
literal|true
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|kv
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|//Writable
specifier|public
name|void
name|readFields
parameter_list|(
specifier|final
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|familyMap
operator|=
literal|null
expr_stmt|;
name|row
operator|=
literal|null
expr_stmt|;
name|kvs
operator|=
literal|null
expr_stmt|;
name|int
name|totalBuffer
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|totalBuffer
operator|==
literal|0
condition|)
block|{
name|bytes
operator|=
literal|null
expr_stmt|;
return|return;
block|}
name|byte
index|[]
name|raw
init|=
operator|new
name|byte
index|[
name|totalBuffer
index|]
decl_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|raw
argument_list|,
literal|0
argument_list|,
name|totalBuffer
argument_list|)
expr_stmt|;
name|bytes
operator|=
operator|new
name|ImmutableBytesWritable
argument_list|(
name|raw
argument_list|,
literal|0
argument_list|,
name|totalBuffer
argument_list|)
expr_stmt|;
block|}
comment|//Create KeyValue[] when needed
specifier|private
name|void
name|readFields
parameter_list|()
block|{
if|if
condition|(
name|bytes
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|kvs
operator|=
operator|new
name|KeyValue
index|[
literal|0
index|]
expr_stmt|;
return|return;
block|}
name|byte
index|[]
name|buf
init|=
name|bytes
operator|.
name|get
argument_list|()
decl_stmt|;
name|int
name|offset
init|=
name|bytes
operator|.
name|getOffset
argument_list|()
decl_stmt|;
name|int
name|finalOffset
init|=
name|bytes
operator|.
name|getSize
argument_list|()
operator|+
name|offset
decl_stmt|;
name|List
argument_list|<
name|KeyValue
argument_list|>
name|kvs
init|=
operator|new
name|ArrayList
argument_list|<
name|KeyValue
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|offset
operator|<
name|finalOffset
condition|)
block|{
name|int
name|keyLength
init|=
name|Bytes
operator|.
name|toInt
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|offset
operator|+=
name|Bytes
operator|.
name|SIZEOF_INT
expr_stmt|;
name|kvs
operator|.
name|add
argument_list|(
operator|new
name|KeyValue
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|keyLength
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|keyLength
expr_stmt|;
block|}
name|this
operator|.
name|kvs
operator|=
name|kvs
operator|.
name|toArray
argument_list|(
operator|new
name|KeyValue
index|[
name|kvs
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
specifier|public
name|long
name|getWritableSize
parameter_list|()
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
return|return
name|Bytes
operator|.
name|SIZEOF_INT
return|;
comment|// int size = 0
name|long
name|size
init|=
name|Bytes
operator|.
name|SIZEOF_INT
decl_stmt|;
comment|// totalLen
for|for
control|(
name|KeyValue
name|kv
range|:
name|kvs
control|)
block|{
name|size
operator|+=
name|kv
operator|.
name|getLength
argument_list|()
expr_stmt|;
name|size
operator|+=
name|Bytes
operator|.
name|SIZEOF_INT
expr_stmt|;
comment|// kv.getLength
block|}
return|return
name|size
return|;
block|}
specifier|public
name|void
name|write
parameter_list|(
specifier|final
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
name|out
operator|.
name|writeInt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|totalLen
init|=
literal|0
decl_stmt|;
for|for
control|(
name|KeyValue
name|kv
range|:
name|kvs
control|)
block|{
name|totalLen
operator|+=
name|kv
operator|.
name|getLength
argument_list|()
operator|+
name|Bytes
operator|.
name|SIZEOF_INT
expr_stmt|;
block|}
name|out
operator|.
name|writeInt
argument_list|(
name|totalLen
argument_list|)
expr_stmt|;
for|for
control|(
name|KeyValue
name|kv
range|:
name|kvs
control|)
block|{
name|out
operator|.
name|writeInt
argument_list|(
name|kv
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|kv
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|kv
operator|.
name|getOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
specifier|static
name|long
name|getWriteArraySize
parameter_list|(
name|Result
index|[]
name|results
parameter_list|)
block|{
name|long
name|size
init|=
name|Bytes
operator|.
name|SIZEOF_BYTE
decl_stmt|;
comment|// RESULT_VERSION
if|if
condition|(
name|results
operator|==
literal|null
operator|||
name|results
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|size
operator|+=
name|Bytes
operator|.
name|SIZEOF_INT
expr_stmt|;
return|return
name|size
return|;
block|}
name|size
operator|+=
name|Bytes
operator|.
name|SIZEOF_INT
expr_stmt|;
comment|// results.length
name|size
operator|+=
name|Bytes
operator|.
name|SIZEOF_INT
expr_stmt|;
comment|// bufLen
for|for
control|(
name|Result
name|result
range|:
name|results
control|)
block|{
name|size
operator|+=
name|Bytes
operator|.
name|SIZEOF_INT
expr_stmt|;
comment|// either 0 or result.size()
if|if
condition|(
name|result
operator|==
literal|null
operator|||
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
for|for
control|(
name|KeyValue
name|kv
range|:
name|result
operator|.
name|raw
argument_list|()
control|)
block|{
name|size
operator|+=
name|Bytes
operator|.
name|SIZEOF_INT
expr_stmt|;
comment|// kv.getLength();
name|size
operator|+=
name|kv
operator|.
name|getLength
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|size
return|;
block|}
specifier|public
specifier|static
name|void
name|writeArray
parameter_list|(
specifier|final
name|DataOutput
name|out
parameter_list|,
name|Result
index|[]
name|results
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Write version when writing array form.
comment|// This assumes that results are sent to the client as Result[], so we
comment|// have an opportunity to handle version differences without affecting
comment|// efficiency.
name|out
operator|.
name|writeByte
argument_list|(
name|RESULT_VERSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|==
literal|null
operator|||
name|results
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|out
operator|.
name|writeInt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|out
operator|.
name|writeInt
argument_list|(
name|results
operator|.
name|length
argument_list|)
expr_stmt|;
name|int
name|bufLen
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Result
name|result
range|:
name|results
control|)
block|{
name|bufLen
operator|+=
name|Bytes
operator|.
name|SIZEOF_INT
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
operator|||
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|KeyValue
name|key
range|:
name|result
operator|.
name|raw
argument_list|()
control|)
block|{
name|bufLen
operator|+=
name|key
operator|.
name|getLength
argument_list|()
operator|+
name|Bytes
operator|.
name|SIZEOF_INT
expr_stmt|;
block|}
block|}
name|out
operator|.
name|writeInt
argument_list|(
name|bufLen
argument_list|)
expr_stmt|;
for|for
control|(
name|Result
name|result
range|:
name|results
control|)
block|{
if|if
condition|(
name|result
operator|==
literal|null
operator|||
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
operator|.
name|writeInt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|out
operator|.
name|writeInt
argument_list|(
name|result
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|KeyValue
name|kv
range|:
name|result
operator|.
name|raw
argument_list|()
control|)
block|{
name|out
operator|.
name|writeInt
argument_list|(
name|kv
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|kv
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|kv
operator|.
name|getOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
specifier|static
name|Result
index|[]
name|readArray
parameter_list|(
specifier|final
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Read version for array form.
comment|// This assumes that results are sent to the client as Result[], so we
comment|// have an opportunity to handle version differences without affecting
comment|// efficiency.
name|int
name|version
init|=
name|in
operator|.
name|readByte
argument_list|()
decl_stmt|;
if|if
condition|(
name|version
operator|>
name|RESULT_VERSION
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"version not supported"
argument_list|)
throw|;
block|}
name|int
name|numResults
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|numResults
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|Result
index|[
literal|0
index|]
return|;
block|}
name|Result
index|[]
name|results
init|=
operator|new
name|Result
index|[
name|numResults
index|]
decl_stmt|;
name|int
name|bufSize
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
name|bufSize
index|]
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numResults
condition|;
name|i
operator|++
control|)
block|{
name|int
name|numKeys
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|offset
operator|+=
name|Bytes
operator|.
name|SIZEOF_INT
expr_stmt|;
if|if
condition|(
name|numKeys
operator|==
literal|0
condition|)
block|{
name|results
index|[
name|i
index|]
operator|=
operator|new
name|Result
argument_list|(
operator|(
name|ImmutableBytesWritable
operator|)
literal|null
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|int
name|initialOffset
init|=
name|offset
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numKeys
condition|;
name|j
operator|++
control|)
block|{
name|int
name|keyLen
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|Bytes
operator|.
name|putInt
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|keyLen
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|Bytes
operator|.
name|SIZEOF_INT
expr_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|keyLen
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|keyLen
expr_stmt|;
block|}
name|int
name|totalLength
init|=
name|offset
operator|-
name|initialOffset
decl_stmt|;
name|results
index|[
name|i
index|]
operator|=
operator|new
name|Result
argument_list|(
operator|new
name|ImmutableBytesWritable
argument_list|(
name|buf
argument_list|,
name|initialOffset
argument_list|,
name|totalLength
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|results
return|;
block|}
comment|/**    * Does a deep comparison of two Results, down to the byte arrays.    * @param res1 first result to compare    * @param res2 second result to compare    * @throws Exception Every difference is throwing an exception    */
specifier|public
specifier|static
name|void
name|compareResults
parameter_list|(
name|Result
name|res1
parameter_list|,
name|Result
name|res2
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|res2
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
literal|"There wasn't enough rows, we stopped at "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|res1
operator|.
name|getRow
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|res1
operator|.
name|size
argument_list|()
operator|!=
name|res2
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
literal|"This row doesn't have the same number of KVs: "
operator|+
name|res1
operator|.
name|toString
argument_list|()
operator|+
literal|" compared to "
operator|+
name|res2
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
name|KeyValue
index|[]
name|ourKVs
init|=
name|res1
operator|.
name|raw
argument_list|()
decl_stmt|;
name|KeyValue
index|[]
name|replicatedKVs
init|=
name|res2
operator|.
name|raw
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|res1
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ourKVs
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
name|replicatedKVs
index|[
name|i
index|]
argument_list|)
operator|||
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|ourKVs
index|[
name|i
index|]
operator|.
name|getValue
argument_list|()
argument_list|,
name|replicatedKVs
index|[
name|i
index|]
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
literal|"This result was different: "
operator|+
name|res1
operator|.
name|toString
argument_list|()
operator|+
literal|" compared to "
operator|+
name|res2
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
block|}
end_class

end_unit

