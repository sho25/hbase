begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|codec
operator|.
name|prefixtree
operator|.
name|encode
operator|.
name|row
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|codec
operator|.
name|prefixtree
operator|.
name|PrefixTreeBlockMeta
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|codec
operator|.
name|prefixtree
operator|.
name|encode
operator|.
name|PrefixTreeEncoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|codec
operator|.
name|prefixtree
operator|.
name|encode
operator|.
name|tokenize
operator|.
name|TokenizerNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|vint
operator|.
name|UFIntTool
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  * Most of the complexity of the PrefixTree is contained in the "row section". It contains the row  * key trie structure used to search and recreate all the row keys. Each nub and leaf in this trie  * also contains references to offsets in the other sections of the data block that enable the  * decoder to match a row key with its qualifier, timestamp, type, value, etc.  *<p>  * The row section is a concatenated collection of {@link RowNodeWriter}s. See that class for the  * internals of each row node.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|RowSectionWriter
block|{
comment|/***************** fields **************************/
specifier|protected
name|PrefixTreeEncoder
name|prefixTreeEncoder
decl_stmt|;
specifier|protected
name|PrefixTreeBlockMeta
name|blockMeta
decl_stmt|;
specifier|protected
name|int
name|numBytes
decl_stmt|;
specifier|protected
name|ArrayList
argument_list|<
name|TokenizerNode
argument_list|>
name|nonLeaves
decl_stmt|;
specifier|protected
name|ArrayList
argument_list|<
name|TokenizerNode
argument_list|>
name|leaves
decl_stmt|;
specifier|protected
name|ArrayList
argument_list|<
name|RowNodeWriter
argument_list|>
name|leafWriters
decl_stmt|;
specifier|protected
name|ArrayList
argument_list|<
name|RowNodeWriter
argument_list|>
name|nonLeafWriters
decl_stmt|;
specifier|protected
name|int
name|numLeafWriters
decl_stmt|;
specifier|protected
name|int
name|numNonLeafWriters
decl_stmt|;
comment|/********************* construct **********************/
specifier|public
name|RowSectionWriter
parameter_list|()
block|{
name|this
operator|.
name|nonLeaves
operator|=
name|Lists
operator|.
name|newArrayList
argument_list|()
expr_stmt|;
name|this
operator|.
name|leaves
operator|=
name|Lists
operator|.
name|newArrayList
argument_list|()
expr_stmt|;
name|this
operator|.
name|leafWriters
operator|=
name|Lists
operator|.
name|newArrayList
argument_list|()
expr_stmt|;
name|this
operator|.
name|nonLeafWriters
operator|=
name|Lists
operator|.
name|newArrayList
argument_list|()
expr_stmt|;
block|}
specifier|public
name|RowSectionWriter
parameter_list|(
name|PrefixTreeEncoder
name|prefixTreeEncoder
parameter_list|)
block|{
name|reconstruct
argument_list|(
name|prefixTreeEncoder
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|reconstruct
parameter_list|(
name|PrefixTreeEncoder
name|prefixTreeEncoder
parameter_list|)
block|{
name|this
operator|.
name|prefixTreeEncoder
operator|=
name|prefixTreeEncoder
expr_stmt|;
name|this
operator|.
name|blockMeta
operator|=
name|prefixTreeEncoder
operator|.
name|getBlockMeta
argument_list|()
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|numBytes
operator|=
literal|0
expr_stmt|;
name|nonLeaves
operator|.
name|clear
argument_list|()
expr_stmt|;
name|leaves
operator|.
name|clear
argument_list|()
expr_stmt|;
name|numLeafWriters
operator|=
literal|0
expr_stmt|;
name|numNonLeafWriters
operator|=
literal|0
expr_stmt|;
block|}
comment|/****************** methods *******************************/
specifier|public
name|RowSectionWriter
name|compile
parameter_list|()
block|{
name|blockMeta
operator|.
name|setMaxRowLength
argument_list|(
name|prefixTreeEncoder
operator|.
name|getRowTokenizer
argument_list|()
operator|.
name|getMaxElementLength
argument_list|()
argument_list|)
expr_stmt|;
name|prefixTreeEncoder
operator|.
name|getRowTokenizer
argument_list|()
operator|.
name|setNodeFirstInsertionIndexes
argument_list|()
expr_stmt|;
name|prefixTreeEncoder
operator|.
name|getRowTokenizer
argument_list|()
operator|.
name|appendNodes
argument_list|(
name|nonLeaves
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|prefixTreeEncoder
operator|.
name|getRowTokenizer
argument_list|()
operator|.
name|appendNodes
argument_list|(
name|leaves
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// track the starting position of each node in final output
name|int
name|negativeIndex
init|=
literal|0
decl_stmt|;
comment|// create leaf writer nodes
comment|// leaf widths are known at this point, so add them up
name|int
name|totalLeafBytes
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|leaves
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|TokenizerNode
name|leaf
init|=
name|leaves
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|RowNodeWriter
name|leafWriter
init|=
name|initializeWriter
argument_list|(
name|leafWriters
argument_list|,
name|numLeafWriters
argument_list|,
name|leaf
argument_list|)
decl_stmt|;
operator|++
name|numLeafWriters
expr_stmt|;
comment|// leaves store all but their first token byte
name|int
name|leafNodeWidth
init|=
name|leafWriter
operator|.
name|calculateWidthOverrideOffsetWidth
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|totalLeafBytes
operator|+=
name|leafNodeWidth
expr_stmt|;
name|negativeIndex
operator|+=
name|leafNodeWidth
expr_stmt|;
name|leaf
operator|.
name|setNegativeIndex
argument_list|(
name|negativeIndex
argument_list|)
expr_stmt|;
block|}
name|int
name|totalNonLeafBytesWithoutOffsets
init|=
literal|0
decl_stmt|;
name|int
name|totalChildPointers
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|nonLeaves
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|TokenizerNode
name|nonLeaf
init|=
name|nonLeaves
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|RowNodeWriter
name|nonLeafWriter
init|=
name|initializeWriter
argument_list|(
name|nonLeafWriters
argument_list|,
name|numNonLeafWriters
argument_list|,
name|nonLeaf
argument_list|)
decl_stmt|;
operator|++
name|numNonLeafWriters
expr_stmt|;
name|totalNonLeafBytesWithoutOffsets
operator|+=
name|nonLeafWriter
operator|.
name|calculateWidthOverrideOffsetWidth
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|totalChildPointers
operator|+=
name|nonLeaf
operator|.
name|getNumChildren
argument_list|()
expr_stmt|;
block|}
comment|// figure out how wide our offset FInts are
name|int
name|offsetWidth
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
operator|++
name|offsetWidth
expr_stmt|;
name|int
name|offsetBytes
init|=
name|totalChildPointers
operator|*
name|offsetWidth
decl_stmt|;
name|int
name|totalRowBytes
init|=
name|totalNonLeafBytesWithoutOffsets
operator|+
name|offsetBytes
operator|+
name|totalLeafBytes
decl_stmt|;
if|if
condition|(
name|totalRowBytes
operator|<
name|UFIntTool
operator|.
name|maxValueForNumBytes
argument_list|(
name|offsetWidth
argument_list|)
condition|)
block|{
comment|// it fits
name|numBytes
operator|=
name|totalRowBytes
expr_stmt|;
break|break;
block|}
block|}
name|blockMeta
operator|.
name|setNextNodeOffsetWidth
argument_list|(
name|offsetWidth
argument_list|)
expr_stmt|;
comment|// populate negativeIndexes
for|for
control|(
name|int
name|i
init|=
name|nonLeaves
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|TokenizerNode
name|nonLeaf
init|=
name|nonLeaves
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|writerIndex
init|=
name|nonLeaves
operator|.
name|size
argument_list|()
operator|-
name|i
operator|-
literal|1
decl_stmt|;
name|RowNodeWriter
name|nonLeafWriter
init|=
name|nonLeafWriters
operator|.
name|get
argument_list|(
name|writerIndex
argument_list|)
decl_stmt|;
name|int
name|nodeWidth
init|=
name|nonLeafWriter
operator|.
name|calculateWidth
argument_list|()
decl_stmt|;
name|negativeIndex
operator|+=
name|nodeWidth
expr_stmt|;
name|nonLeaf
operator|.
name|setNegativeIndex
argument_list|(
name|negativeIndex
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
specifier|protected
name|RowNodeWriter
name|initializeWriter
parameter_list|(
name|List
argument_list|<
name|RowNodeWriter
argument_list|>
name|list
parameter_list|,
name|int
name|index
parameter_list|,
name|TokenizerNode
name|builderNode
parameter_list|)
block|{
name|RowNodeWriter
name|rowNodeWriter
init|=
literal|null
decl_stmt|;
comment|//check if there is an existing node we can recycle
if|if
condition|(
name|index
operator|>=
name|list
operator|.
name|size
argument_list|()
condition|)
block|{
comment|//there are not enough existing nodes, so add a new one which will be retrieved below
name|list
operator|.
name|add
argument_list|(
operator|new
name|RowNodeWriter
argument_list|(
name|prefixTreeEncoder
argument_list|,
name|builderNode
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rowNodeWriter
operator|=
name|list
operator|.
name|get
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|rowNodeWriter
operator|.
name|reset
argument_list|(
name|builderNode
argument_list|)
expr_stmt|;
return|return
name|rowNodeWriter
return|;
block|}
specifier|public
name|void
name|writeBytes
parameter_list|(
name|OutputStream
name|os
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
name|numNonLeafWriters
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|RowNodeWriter
name|nonLeafWriter
init|=
name|nonLeafWriters
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|nonLeafWriter
operator|.
name|write
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
comment|// duplicates above... written more for clarity right now
for|for
control|(
name|int
name|i
init|=
name|numLeafWriters
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|RowNodeWriter
name|leafWriter
init|=
name|leafWriters
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|leafWriter
operator|.
name|write
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
block|}
comment|/***************** static ******************************/
specifier|protected
specifier|static
name|ArrayList
argument_list|<
name|TokenizerNode
argument_list|>
name|filterByLeafAndReverse
parameter_list|(
name|ArrayList
argument_list|<
name|TokenizerNode
argument_list|>
name|ins
parameter_list|,
name|boolean
name|leaves
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|TokenizerNode
argument_list|>
name|outs
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|ins
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|TokenizerNode
name|n
init|=
name|ins
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|.
name|isLeaf
argument_list|()
operator|&&
name|leaves
operator|||
operator|(
operator|!
name|n
operator|.
name|isLeaf
argument_list|()
operator|&&
operator|!
name|leaves
operator|)
condition|)
block|{
name|outs
operator|.
name|add
argument_list|(
name|ins
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|outs
return|;
block|}
comment|/************* get/set **************************/
specifier|public
name|int
name|getNumBytes
parameter_list|()
block|{
return|return
name|numBytes
return|;
block|}
specifier|public
name|ArrayList
argument_list|<
name|TokenizerNode
argument_list|>
name|getNonLeaves
parameter_list|()
block|{
return|return
name|nonLeaves
return|;
block|}
specifier|public
name|ArrayList
argument_list|<
name|TokenizerNode
argument_list|>
name|getLeaves
parameter_list|()
block|{
return|return
name|leaves
return|;
block|}
specifier|public
name|ArrayList
argument_list|<
name|RowNodeWriter
argument_list|>
name|getNonLeafWriters
parameter_list|()
block|{
return|return
name|nonLeafWriters
return|;
block|}
specifier|public
name|ArrayList
argument_list|<
name|RowNodeWriter
argument_list|>
name|getLeafWriters
parameter_list|()
block|{
return|return
name|leafWriters
return|;
block|}
block|}
end_class

end_unit

