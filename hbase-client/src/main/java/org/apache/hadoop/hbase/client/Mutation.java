begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Cell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellScannable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ExtendedCell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|PrivateCellUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|RawCell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Tag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|DeserializationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|HeapSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClientProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|access
operator|.
name|AccessControlConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|access
operator|.
name|AccessControlUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|access
operator|.
name|Permission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|visibility
operator|.
name|CellVisibility
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|visibility
operator|.
name|VisibilityConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ClassSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ArrayListMultimap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ListMultimap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|io
operator|.
name|ByteArrayDataInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|io
operator|.
name|ByteArrayDataOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|io
operator|.
name|ByteStreams
import|;
end_import

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
specifier|public
specifier|abstract
class|class
name|Mutation
extends|extends
name|OperationWithAttributes
implements|implements
name|Row
implements|,
name|CellScannable
implements|,
name|HeapSize
block|{
specifier|public
specifier|static
specifier|final
name|long
name|MUTATION_OVERHEAD
init|=
name|ClassSize
operator|.
name|align
argument_list|(
comment|// This
name|ClassSize
operator|.
name|OBJECT
operator|+
comment|// row + OperationWithAttributes.attributes
literal|2
operator|*
name|ClassSize
operator|.
name|REFERENCE
operator|+
comment|// Timestamp
literal|1
operator|*
name|Bytes
operator|.
name|SIZEOF_LONG
operator|+
comment|// durability
name|ClassSize
operator|.
name|REFERENCE
operator|+
comment|// familyMap
name|ClassSize
operator|.
name|REFERENCE
operator|+
comment|// familyMap
name|ClassSize
operator|.
name|TREEMAP
operator|+
comment|// priority
name|ClassSize
operator|.
name|INTEGER
argument_list|)
decl_stmt|;
comment|/**    * The attribute for storing the list of clusters that have consumed the change.    */
specifier|private
specifier|static
specifier|final
name|String
name|CONSUMED_CLUSTER_IDS
init|=
literal|"_cs.id"
decl_stmt|;
comment|/**    * The attribute for storing TTL for the result of the mutation.    */
specifier|private
specifier|static
specifier|final
name|String
name|OP_ATTRIBUTE_TTL
init|=
literal|"_ttl"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|RETURN_RESULTS
init|=
literal|"_rr_"
decl_stmt|;
comment|// TODO: row should be final
specifier|protected
name|byte
index|[]
name|row
init|=
literal|null
decl_stmt|;
specifier|protected
name|long
name|ts
init|=
name|HConstants
operator|.
name|LATEST_TIMESTAMP
decl_stmt|;
specifier|protected
name|Durability
name|durability
init|=
name|Durability
operator|.
name|USE_DEFAULT
decl_stmt|;
comment|// TODO: familyMap should be final
comment|// A Map sorted by column family.
specifier|protected
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|List
argument_list|<
name|Cell
argument_list|>
argument_list|>
name|familyMap
decl_stmt|;
comment|/**    * empty construction.    * We need this empty construction to keep binary compatibility.    */
specifier|protected
name|Mutation
parameter_list|()
block|{
name|this
operator|.
name|familyMap
operator|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|Mutation
parameter_list|(
name|Mutation
name|clone
parameter_list|)
block|{
name|super
argument_list|(
name|clone
argument_list|)
expr_stmt|;
name|this
operator|.
name|row
operator|=
name|clone
operator|.
name|getRow
argument_list|()
expr_stmt|;
name|this
operator|.
name|ts
operator|=
name|clone
operator|.
name|getTimestamp
argument_list|()
expr_stmt|;
name|this
operator|.
name|familyMap
operator|=
name|clone
operator|.
name|getFamilyCellMap
argument_list|()
operator|.
name|entrySet
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toMap
argument_list|(
name|e
lambda|->
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
lambda|->
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|,
parameter_list|(
name|k
parameter_list|,
name|v
parameter_list|)
lambda|->
block|{
throw|throw
argument_list|new
name|RuntimeException
argument_list|(
literal|"collisions!!!"
argument_list|)
argument_list|;
block|}
operator|,
parameter_list|()
lambda|->
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
block|)
end_class

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|/**    * Construct the mutation with user defined data.    * @param row row. CAN'T be null    * @param ts timestamp    * @param familyMap the map to collect all cells internally. CAN'T be null    */
end_comment

begin_expr_stmt
unit|protected
name|Mutation
argument_list|(
name|byte
index|[]
name|row
argument_list|,
name|long
name|ts
argument_list|,
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|List
argument_list|<
name|Cell
argument_list|>
argument_list|>
name|familyMap
argument_list|)
block|{
name|this
operator|.
name|row
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|row
argument_list|)
block|;
if|if
condition|(
name|row
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Row can't be empty"
argument_list|)
throw|;
block|}
name|this
operator|.
name|ts
operator|=
name|ts
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|this
operator|.
name|familyMap
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|familyMap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
unit|}    @
name|Override
specifier|public
name|CellScanner
name|cellScanner
parameter_list|()
block|{
return|return
name|CellUtil
operator|.
name|createCellScanner
argument_list|(
name|getFamilyCellMap
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Creates an empty list if one doesn't exist for the given column family    * or else it returns the associated list of Cell objects.    *    * @param family column family    * @return a list of Cell objects, returns an empty list if one doesn't exist.    */
end_comment

begin_function
name|List
argument_list|<
name|Cell
argument_list|>
name|getCellList
parameter_list|(
name|byte
index|[]
name|family
parameter_list|)
block|{
name|List
argument_list|<
name|Cell
argument_list|>
name|list
init|=
name|this
operator|.
name|familyMap
operator|.
name|get
argument_list|(
name|family
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|==
literal|null
condition|)
block|{
name|list
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|familyMap
operator|.
name|put
argument_list|(
name|family
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/*    * Create a KeyValue with this objects row key and the Put identifier.    *    * @return a KeyValue with this objects row key and the Put identifier.    */
end_comment

begin_function
name|KeyValue
name|createPutKeyValue
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|long
name|ts
parameter_list|,
name|byte
index|[]
name|value
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|this
operator|.
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|ts
argument_list|,
name|KeyValue
operator|.
name|Type
operator|.
name|Put
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Create a KeyValue with this objects row key and the Put identifier.    * @param family    * @param qualifier    * @param ts    * @param value    * @param tags - Specify the Tags as an Array    * @return a KeyValue with this objects row key and the Put identifier.    */
end_comment

begin_function
name|KeyValue
name|createPutKeyValue
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|long
name|ts
parameter_list|,
name|byte
index|[]
name|value
parameter_list|,
name|Tag
index|[]
name|tags
parameter_list|)
block|{
name|KeyValue
name|kvWithTag
init|=
operator|new
name|KeyValue
argument_list|(
name|this
operator|.
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|ts
argument_list|,
name|value
argument_list|,
name|tags
argument_list|)
decl_stmt|;
return|return
name|kvWithTag
return|;
block|}
end_function

begin_comment
comment|/*    * Create a KeyValue with this objects row key and the Put identifier.    *    * @return a KeyValue with this objects row key and the Put identifier.    */
end_comment

begin_function
name|KeyValue
name|createPutKeyValue
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|ByteBuffer
name|qualifier
parameter_list|,
name|long
name|ts
parameter_list|,
name|ByteBuffer
name|value
parameter_list|,
name|Tag
index|[]
name|tags
parameter_list|)
block|{
return|return
operator|new
name|KeyValue
argument_list|(
name|this
operator|.
name|row
argument_list|,
literal|0
argument_list|,
name|this
operator|.
name|row
operator|==
literal|null
condition|?
literal|0
else|:
name|this
operator|.
name|row
operator|.
name|length
argument_list|,
name|family
argument_list|,
literal|0
argument_list|,
name|family
operator|==
literal|null
condition|?
literal|0
else|:
name|family
operator|.
name|length
argument_list|,
name|qualifier
argument_list|,
name|ts
argument_list|,
name|KeyValue
operator|.
name|Type
operator|.
name|Put
argument_list|,
name|value
argument_list|,
name|tags
operator|!=
literal|null
condition|?
name|Arrays
operator|.
name|asList
argument_list|(
name|tags
argument_list|)
else|:
literal|null
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Compile the column family (i.e. schema) information    * into a Map. Useful for parsing and aggregation by debugging,    * logging, and administration tools.    * @return Map    */
end_comment

begin_function
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getFingerprint
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|families
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|this
operator|.
name|familyMap
operator|.
name|entrySet
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// ideally, we would also include table information, but that information
comment|// is not stored in each Operation instance.
name|map
operator|.
name|put
argument_list|(
literal|"families"
argument_list|,
name|families
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|List
argument_list|<
name|Cell
argument_list|>
argument_list|>
name|entry
range|:
name|this
operator|.
name|familyMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|families
operator|.
name|add
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|map
return|;
block|}
end_function

begin_comment
comment|/**    * Compile the details beyond the scope of getFingerprint (row, columns,    * timestamps, etc.) into a Map along with the fingerprinted information.    * Useful for debugging, logging, and administration tools.    * @param maxCols a limit on the number of columns output prior to truncation    * @return Map    */
end_comment

begin_function
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|toMap
parameter_list|(
name|int
name|maxCols
parameter_list|)
block|{
comment|// we start with the fingerprint map and build on top of it.
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|map
init|=
name|getFingerprint
argument_list|()
decl_stmt|;
comment|// replace the fingerprint's simple list of families with a
comment|// map from column families to lists of qualifiers and kv details
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
argument_list|>
name|columns
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"families"
argument_list|,
name|columns
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"row"
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|this
operator|.
name|row
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|colCount
init|=
literal|0
decl_stmt|;
comment|// iterate through all column families affected
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|List
argument_list|<
name|Cell
argument_list|>
argument_list|>
name|entry
range|:
name|this
operator|.
name|familyMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|// map from this family to details for each cell affected within the family
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|qualifierDetails
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|columns
operator|.
name|put
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|,
name|qualifierDetails
argument_list|)
expr_stmt|;
name|colCount
operator|+=
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|maxCols
operator|<=
literal|0
condition|)
block|{
continue|continue;
block|}
comment|// add details for each cell
for|for
control|(
name|Cell
name|cell
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
if|if
condition|(
operator|--
name|maxCols
operator|<=
literal|0
condition|)
block|{
continue|continue;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|cellMap
init|=
name|cellToStringMap
argument_list|(
name|cell
argument_list|)
decl_stmt|;
name|qualifierDetails
operator|.
name|add
argument_list|(
name|cellMap
argument_list|)
expr_stmt|;
block|}
block|}
name|map
operator|.
name|put
argument_list|(
literal|"totalColumns"
argument_list|,
name|colCount
argument_list|)
expr_stmt|;
comment|// add the id if set
if|if
condition|(
name|getId
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
literal|"id"
argument_list|,
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Add the TTL if set
comment|// Long.MAX_VALUE is the default, and is interpreted to mean this attribute
comment|// has not been set.
if|if
condition|(
name|getTTL
argument_list|()
operator|!=
name|Long
operator|.
name|MAX_VALUE
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
literal|"ttl"
argument_list|,
name|getTTL
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|map
operator|.
name|put
argument_list|(
literal|"ts"
argument_list|,
name|this
operator|.
name|ts
argument_list|)
expr_stmt|;
return|return
name|map
return|;
block|}
end_function

begin_function
specifier|private
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|cellToStringMap
parameter_list|(
name|Cell
name|c
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|stringMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|stringMap
operator|.
name|put
argument_list|(
literal|"qualifier"
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|c
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|c
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|c
operator|.
name|getQualifierLength
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|stringMap
operator|.
name|put
argument_list|(
literal|"timestamp"
argument_list|,
name|c
operator|.
name|getTimestamp
argument_list|()
argument_list|)
expr_stmt|;
name|stringMap
operator|.
name|put
argument_list|(
literal|"vlen"
argument_list|,
name|c
operator|.
name|getValueLength
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Tag
argument_list|>
name|tags
init|=
name|PrivateCellUtil
operator|.
name|getTags
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|tags
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|tagsString
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|tags
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Tag
name|t
range|:
name|tags
control|)
block|{
name|tagsString
operator|.
name|add
argument_list|(
operator|(
name|t
operator|.
name|getType
argument_list|()
operator|)
operator|+
literal|":"
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|Tag
operator|.
name|cloneValue
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|stringMap
operator|.
name|put
argument_list|(
literal|"tag"
argument_list|,
name|tagsString
argument_list|)
expr_stmt|;
block|}
return|return
name|stringMap
return|;
block|}
end_function

begin_comment
comment|/**    * Set the durability for this mutation    * @param d    */
end_comment

begin_function
specifier|public
name|Mutation
name|setDurability
parameter_list|(
name|Durability
name|d
parameter_list|)
block|{
name|this
operator|.
name|durability
operator|=
name|d
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/** Get the current durability */
end_comment

begin_function
specifier|public
name|Durability
name|getDurability
parameter_list|()
block|{
return|return
name|this
operator|.
name|durability
return|;
block|}
end_function

begin_comment
comment|/**    * Method for retrieving the put's familyMap    * @return familyMap    */
end_comment

begin_function
specifier|public
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|List
argument_list|<
name|Cell
argument_list|>
argument_list|>
name|getFamilyCellMap
parameter_list|()
block|{
return|return
name|this
operator|.
name|familyMap
return|;
block|}
end_function

begin_comment
comment|/**    * Method for setting the mutation's familyMap    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    *             Use {@link Mutation#Mutation(byte[], long, NavigableMap)} instead    */
end_comment

begin_function
annotation|@
name|Deprecated
specifier|public
name|Mutation
name|setFamilyCellMap
parameter_list|(
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|List
argument_list|<
name|Cell
argument_list|>
argument_list|>
name|map
parameter_list|)
block|{
comment|// TODO: Shut this down or move it up to be a Constructor.  Get new object rather than change
comment|// this internal data member.
name|this
operator|.
name|familyMap
operator|=
name|map
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/**    * Method to check if the familyMap is empty    * @return true if empty, false otherwise    */
end_comment

begin_function
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|familyMap
operator|.
name|isEmpty
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Method for retrieving the delete's row    * @return row    */
end_comment

begin_function
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|getRow
parameter_list|()
block|{
return|return
name|this
operator|.
name|row
return|;
block|}
end_function

begin_comment
comment|/**    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    *             Use {@link Row#COMPARATOR} instead    */
end_comment

begin_function
annotation|@
name|Deprecated
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
specifier|final
name|Row
name|d
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|this
operator|.
name|getRow
argument_list|()
argument_list|,
name|d
operator|.
name|getRow
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Method for retrieving the timestamp    * @return timestamp    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.    *             Use {@link #getTimestamp()} instead    */
end_comment

begin_function
annotation|@
name|Deprecated
specifier|public
name|long
name|getTimeStamp
parameter_list|()
block|{
return|return
name|this
operator|.
name|getTimestamp
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Method for retrieving the timestamp.    *    * @return timestamp    */
end_comment

begin_function
specifier|public
name|long
name|getTimestamp
parameter_list|()
block|{
return|return
name|this
operator|.
name|ts
return|;
block|}
end_function

begin_comment
comment|/**    * Marks that the clusters with the given clusterIds have consumed the mutation    * @param clusterIds of the clusters that have consumed the mutation    */
end_comment

begin_function
specifier|public
name|Mutation
name|setClusterIds
parameter_list|(
name|List
argument_list|<
name|UUID
argument_list|>
name|clusterIds
parameter_list|)
block|{
name|ByteArrayDataOutput
name|out
init|=
name|ByteStreams
operator|.
name|newDataOutput
argument_list|()
decl_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|clusterIds
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|UUID
name|clusterId
range|:
name|clusterIds
control|)
block|{
name|out
operator|.
name|writeLong
argument_list|(
name|clusterId
operator|.
name|getMostSignificantBits
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeLong
argument_list|(
name|clusterId
operator|.
name|getLeastSignificantBits
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|setAttribute
argument_list|(
name|CONSUMED_CLUSTER_IDS
argument_list|,
name|out
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/**    * @return the set of clusterIds that have consumed the mutation    */
end_comment

begin_function
specifier|public
name|List
argument_list|<
name|UUID
argument_list|>
name|getClusterIds
parameter_list|()
block|{
name|List
argument_list|<
name|UUID
argument_list|>
name|clusterIds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|byte
index|[]
name|bytes
init|=
name|getAttribute
argument_list|(
name|CONSUMED_CLUSTER_IDS
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytes
operator|!=
literal|null
condition|)
block|{
name|ByteArrayDataInput
name|in
init|=
name|ByteStreams
operator|.
name|newDataInput
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
name|int
name|numClusters
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numClusters
condition|;
name|i
operator|++
control|)
block|{
name|clusterIds
operator|.
name|add
argument_list|(
operator|new
name|UUID
argument_list|(
name|in
operator|.
name|readLong
argument_list|()
argument_list|,
name|in
operator|.
name|readLong
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|clusterIds
return|;
block|}
end_function

begin_comment
comment|/**    * Sets the visibility expression associated with cells in this Mutation.    * @param expression    */
end_comment

begin_function
specifier|public
name|Mutation
name|setCellVisibility
parameter_list|(
name|CellVisibility
name|expression
parameter_list|)
block|{
name|this
operator|.
name|setAttribute
argument_list|(
name|VisibilityConstants
operator|.
name|VISIBILITY_LABELS_ATTR_KEY
argument_list|,
name|toCellVisibility
argument_list|(
name|expression
argument_list|)
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/**    * @return CellVisibility associated with cells in this Mutation.    * @throws DeserializationException    */
end_comment

begin_function
specifier|public
name|CellVisibility
name|getCellVisibility
parameter_list|()
throws|throws
name|DeserializationException
block|{
name|byte
index|[]
name|cellVisibilityBytes
init|=
name|this
operator|.
name|getAttribute
argument_list|(
name|VisibilityConstants
operator|.
name|VISIBILITY_LABELS_ATTR_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|cellVisibilityBytes
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|toCellVisibility
argument_list|(
name|cellVisibilityBytes
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Create a protocol buffer CellVisibility based on a client CellVisibility.    *    * @param cellVisibility    * @return a protocol buffer CellVisibility    */
end_comment

begin_function
specifier|static
name|ClientProtos
operator|.
name|CellVisibility
name|toCellVisibility
parameter_list|(
name|CellVisibility
name|cellVisibility
parameter_list|)
block|{
name|ClientProtos
operator|.
name|CellVisibility
operator|.
name|Builder
name|builder
init|=
name|ClientProtos
operator|.
name|CellVisibility
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|setExpression
argument_list|(
name|cellVisibility
operator|.
name|getExpression
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * Convert a protocol buffer CellVisibility to a client CellVisibility    *    * @param proto    * @return the converted client CellVisibility    */
end_comment

begin_function
specifier|private
specifier|static
name|CellVisibility
name|toCellVisibility
parameter_list|(
name|ClientProtos
operator|.
name|CellVisibility
name|proto
parameter_list|)
block|{
if|if
condition|(
name|proto
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
operator|new
name|CellVisibility
argument_list|(
name|proto
operator|.
name|getExpression
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Convert a protocol buffer CellVisibility bytes to a client CellVisibility    *    * @param protoBytes    * @return the converted client CellVisibility    * @throws DeserializationException    */
end_comment

begin_function
specifier|private
specifier|static
name|CellVisibility
name|toCellVisibility
parameter_list|(
name|byte
index|[]
name|protoBytes
parameter_list|)
throws|throws
name|DeserializationException
block|{
if|if
condition|(
name|protoBytes
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|ClientProtos
operator|.
name|CellVisibility
operator|.
name|Builder
name|builder
init|=
name|ClientProtos
operator|.
name|CellVisibility
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|ClientProtos
operator|.
name|CellVisibility
name|proto
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ProtobufUtil
operator|.
name|mergeFrom
argument_list|(
name|builder
argument_list|,
name|protoBytes
argument_list|)
expr_stmt|;
name|proto
operator|=
name|builder
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DeserializationException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|toCellVisibility
argument_list|(
name|proto
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Number of KeyValues carried by this Mutation.    * @return the total number of KeyValues    */
end_comment

begin_function
specifier|public
name|int
name|size
parameter_list|()
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|Cell
argument_list|>
name|cells
range|:
name|this
operator|.
name|familyMap
operator|.
name|values
argument_list|()
control|)
block|{
name|size
operator|+=
name|cells
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/**    * @return the number of different families    */
end_comment

begin_function
specifier|public
name|int
name|numFamilies
parameter_list|()
block|{
return|return
name|familyMap
operator|.
name|size
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**    * @return Calculate what Mutation adds to class heap size.    */
end_comment

begin_function
annotation|@
name|Override
specifier|public
name|long
name|heapSize
parameter_list|()
block|{
name|long
name|heapsize
init|=
name|MUTATION_OVERHEAD
decl_stmt|;
comment|// Adding row
name|heapsize
operator|+=
name|ClassSize
operator|.
name|align
argument_list|(
name|ClassSize
operator|.
name|ARRAY
operator|+
name|this
operator|.
name|row
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// Adding map overhead
name|heapsize
operator|+=
name|ClassSize
operator|.
name|align
argument_list|(
name|this
operator|.
name|familyMap
operator|.
name|size
argument_list|()
operator|*
name|ClassSize
operator|.
name|MAP_ENTRY
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|List
argument_list|<
name|Cell
argument_list|>
argument_list|>
name|entry
range|:
name|this
operator|.
name|familyMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|//Adding key overhead
name|heapsize
operator|+=
name|ClassSize
operator|.
name|align
argument_list|(
name|ClassSize
operator|.
name|ARRAY
operator|+
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
comment|//This part is kinds tricky since the JVM can reuse references if you
comment|//store the same value, but have a good match with SizeOf at the moment
comment|//Adding value overhead
name|heapsize
operator|+=
name|ClassSize
operator|.
name|align
argument_list|(
name|ClassSize
operator|.
name|ARRAYLIST
argument_list|)
expr_stmt|;
name|int
name|size
init|=
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|heapsize
operator|+=
name|ClassSize
operator|.
name|align
argument_list|(
name|ClassSize
operator|.
name|ARRAY
operator|+
name|size
operator|*
name|ClassSize
operator|.
name|REFERENCE
argument_list|)
expr_stmt|;
for|for
control|(
name|Cell
name|cell
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
name|heapsize
operator|+=
name|PrivateCellUtil
operator|.
name|estimatedSizeOfCell
argument_list|(
name|cell
argument_list|)
expr_stmt|;
block|}
block|}
name|heapsize
operator|+=
name|getAttributeSize
argument_list|()
expr_stmt|;
name|heapsize
operator|+=
name|extraHeapSize
argument_list|()
expr_stmt|;
return|return
name|ClassSize
operator|.
name|align
argument_list|(
name|heapsize
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * @return The serialized ACL for this operation, or null if none    */
end_comment

begin_function
specifier|public
name|byte
index|[]
name|getACL
parameter_list|()
block|{
return|return
name|getAttribute
argument_list|(
name|AccessControlConstants
operator|.
name|OP_ATTRIBUTE_ACL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * @param user User short name    * @param perms Permissions for the user    */
end_comment

begin_function
specifier|public
name|Mutation
name|setACL
parameter_list|(
name|String
name|user
parameter_list|,
name|Permission
name|perms
parameter_list|)
block|{
name|setAttribute
argument_list|(
name|AccessControlConstants
operator|.
name|OP_ATTRIBUTE_ACL
argument_list|,
name|AccessControlUtil
operator|.
name|toUsersAndPermissions
argument_list|(
name|user
argument_list|,
name|perms
argument_list|)
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/**    * @param perms A map of permissions for a user or users    */
end_comment

begin_function
specifier|public
name|Mutation
name|setACL
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Permission
argument_list|>
name|perms
parameter_list|)
block|{
name|ListMultimap
argument_list|<
name|String
argument_list|,
name|Permission
argument_list|>
name|permMap
init|=
name|ArrayListMultimap
operator|.
name|create
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Permission
argument_list|>
name|entry
range|:
name|perms
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|permMap
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|setAttribute
argument_list|(
name|AccessControlConstants
operator|.
name|OP_ATTRIBUTE_ACL
argument_list|,
name|AccessControlUtil
operator|.
name|toUsersAndPermissions
argument_list|(
name|permMap
argument_list|)
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/**    * Return the TTL requested for the result of the mutation, in milliseconds.    * @return the TTL requested for the result of the mutation, in milliseconds,    * or Long.MAX_VALUE if unset    */
end_comment

begin_function
specifier|public
name|long
name|getTTL
parameter_list|()
block|{
name|byte
index|[]
name|ttlBytes
init|=
name|getAttribute
argument_list|(
name|OP_ATTRIBUTE_TTL
argument_list|)
decl_stmt|;
if|if
condition|(
name|ttlBytes
operator|!=
literal|null
condition|)
block|{
return|return
name|Bytes
operator|.
name|toLong
argument_list|(
name|ttlBytes
argument_list|)
return|;
block|}
return|return
name|Long
operator|.
name|MAX_VALUE
return|;
block|}
end_function

begin_comment
comment|/**    * Set the TTL desired for the result of the mutation, in milliseconds.    * @param ttl the TTL desired for the result of the mutation, in milliseconds    * @return this    */
end_comment

begin_function
specifier|public
name|Mutation
name|setTTL
parameter_list|(
name|long
name|ttl
parameter_list|)
block|{
name|setAttribute
argument_list|(
name|OP_ATTRIBUTE_TTL
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|ttl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/**    * @return current value for returnResults    */
end_comment

begin_comment
comment|// Used by Increment and Append only.
end_comment

begin_function
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|protected
name|boolean
name|isReturnResults
parameter_list|()
block|{
name|byte
index|[]
name|v
init|=
name|getAttribute
argument_list|(
name|RETURN_RESULTS
argument_list|)
decl_stmt|;
return|return
name|v
operator|==
literal|null
condition|?
literal|true
else|:
name|Bytes
operator|.
name|toBoolean
argument_list|(
name|v
argument_list|)
return|;
block|}
end_function

begin_function
annotation|@
name|InterfaceAudience
operator|.
name|Private
comment|// Used by Increment and Append only.
specifier|protected
name|Mutation
name|setReturnResults
parameter_list|(
name|boolean
name|returnResults
parameter_list|)
block|{
name|setAttribute
argument_list|(
name|RETURN_RESULTS
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|returnResults
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/**    * Subclasses should override this method to add the heap size of their own fields.    * @return the heap size to add (will be aligned).    */
end_comment

begin_function
specifier|protected
name|long
name|extraHeapSize
parameter_list|()
block|{
return|return
literal|0L
return|;
block|}
end_function

begin_comment
comment|/**    * Set the timestamp of the delete.    */
end_comment

begin_function
specifier|public
name|Mutation
name|setTimestamp
parameter_list|(
name|long
name|timestamp
parameter_list|)
block|{
if|if
condition|(
name|timestamp
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Timestamp cannot be negative. ts="
operator|+
name|timestamp
argument_list|)
throw|;
block|}
name|this
operator|.
name|ts
operator|=
name|timestamp
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/**    * A convenience method to determine if this object's familyMap contains    * a value assigned to the given family&amp; qualifier.    * Both given arguments must match the KeyValue object to return true.    *    * @param family column family    * @param qualifier column qualifier    * @return returns true if the given family and qualifier already has an    * existing KeyValue object in the family map.    */
end_comment

begin_function
specifier|public
name|boolean
name|has
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
return|return
name|has
argument_list|(
name|family
argument_list|,
name|qualifier
argument_list|,
name|this
operator|.
name|ts
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * A convenience method to determine if this object's familyMap contains    * a value assigned to the given family, qualifier and timestamp.    * All 3 given arguments must match the KeyValue object to return true.    *    * @param family column family    * @param qualifier column qualifier    * @param ts timestamp    * @return returns true if the given family, qualifier and timestamp already has an    * existing KeyValue object in the family map.    */
end_comment

begin_function
specifier|public
name|boolean
name|has
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|long
name|ts
parameter_list|)
block|{
return|return
name|has
argument_list|(
name|family
argument_list|,
name|qualifier
argument_list|,
name|ts
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * A convenience method to determine if this object's familyMap contains    * a value assigned to the given family, qualifier and timestamp.    * All 3 given arguments must match the KeyValue object to return true.    *    * @param family column family    * @param qualifier column qualifier    * @param value value to check    * @return returns true if the given family, qualifier and value already has an    * existing KeyValue object in the family map.    */
end_comment

begin_function
specifier|public
name|boolean
name|has
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|byte
index|[]
name|value
parameter_list|)
block|{
return|return
name|has
argument_list|(
name|family
argument_list|,
name|qualifier
argument_list|,
name|this
operator|.
name|ts
argument_list|,
name|value
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * A convenience method to determine if this object's familyMap contains    * the given value assigned to the given family, qualifier and timestamp.    * All 4 given arguments must match the KeyValue object to return true.    *    * @param family column family    * @param qualifier column qualifier    * @param ts timestamp    * @param value value to check    * @return returns true if the given family, qualifier timestamp and value    *   already has an existing KeyValue object in the family map.    */
end_comment

begin_function
specifier|public
name|boolean
name|has
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|long
name|ts
parameter_list|,
name|byte
index|[]
name|value
parameter_list|)
block|{
return|return
name|has
argument_list|(
name|family
argument_list|,
name|qualifier
argument_list|,
name|ts
argument_list|,
name|value
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a list of all KeyValue objects with matching column family and qualifier.    *    * @param family column family    * @param qualifier column qualifier    * @return a list of KeyValue objects with the matching family and qualifier,    *   returns an empty list if one doesn't exist for the given family.    */
end_comment

begin_function
specifier|public
name|List
argument_list|<
name|Cell
argument_list|>
name|get
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
name|List
argument_list|<
name|Cell
argument_list|>
name|filteredList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Cell
name|cell
range|:
name|getCellList
argument_list|(
name|family
argument_list|)
control|)
block|{
if|if
condition|(
name|CellUtil
operator|.
name|matchingQualifier
argument_list|(
name|cell
argument_list|,
name|qualifier
argument_list|)
condition|)
block|{
name|filteredList
operator|.
name|add
argument_list|(
name|cell
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|filteredList
return|;
block|}
end_function

begin_comment
comment|/*    * Private method to determine if this object's familyMap contains    * the given value assigned to the given family, qualifier and timestamp    * respecting the 2 boolean arguments    *    * @param family    * @param qualifier    * @param ts    * @param value    * @param ignoreTS    * @param ignoreValue    * @return returns true if the given family, qualifier timestamp and value    * already has an existing KeyValue object in the family map.    */
end_comment

begin_function
specifier|protected
name|boolean
name|has
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|long
name|ts
parameter_list|,
name|byte
index|[]
name|value
parameter_list|,
name|boolean
name|ignoreTS
parameter_list|,
name|boolean
name|ignoreValue
parameter_list|)
block|{
name|List
argument_list|<
name|Cell
argument_list|>
name|list
init|=
name|getCellList
argument_list|(
name|family
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Boolean analysis of ignoreTS/ignoreValue.
comment|// T T => 2
comment|// T F => 3 (first is always true)
comment|// F T => 2
comment|// F F => 1
if|if
condition|(
operator|!
name|ignoreTS
operator|&&
operator|!
name|ignoreValue
condition|)
block|{
for|for
control|(
name|Cell
name|cell
range|:
name|list
control|)
block|{
if|if
condition|(
name|CellUtil
operator|.
name|matchingFamily
argument_list|(
name|cell
argument_list|,
name|family
argument_list|)
operator|&&
name|CellUtil
operator|.
name|matchingQualifier
argument_list|(
name|cell
argument_list|,
name|qualifier
argument_list|)
operator|&&
name|CellUtil
operator|.
name|matchingValue
argument_list|(
name|cell
argument_list|,
name|value
argument_list|)
operator|&&
name|cell
operator|.
name|getTimestamp
argument_list|()
operator|==
name|ts
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ignoreValue
operator|&&
operator|!
name|ignoreTS
condition|)
block|{
for|for
control|(
name|Cell
name|cell
range|:
name|list
control|)
block|{
if|if
condition|(
name|CellUtil
operator|.
name|matchingFamily
argument_list|(
name|cell
argument_list|,
name|family
argument_list|)
operator|&&
name|CellUtil
operator|.
name|matchingQualifier
argument_list|(
name|cell
argument_list|,
name|qualifier
argument_list|)
operator|&&
name|cell
operator|.
name|getTimestamp
argument_list|()
operator|==
name|ts
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|ignoreValue
operator|&&
name|ignoreTS
condition|)
block|{
for|for
control|(
name|Cell
name|cell
range|:
name|list
control|)
block|{
if|if
condition|(
name|CellUtil
operator|.
name|matchingFamily
argument_list|(
name|cell
argument_list|,
name|family
argument_list|)
operator|&&
name|CellUtil
operator|.
name|matchingQualifier
argument_list|(
name|cell
argument_list|,
name|qualifier
argument_list|)
operator|&&
name|CellUtil
operator|.
name|matchingValue
argument_list|(
name|cell
argument_list|,
name|value
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|Cell
name|cell
range|:
name|list
control|)
block|{
if|if
condition|(
name|CellUtil
operator|.
name|matchingFamily
argument_list|(
name|cell
argument_list|,
name|family
argument_list|)
operator|&&
name|CellUtil
operator|.
name|matchingQualifier
argument_list|(
name|cell
argument_list|,
name|qualifier
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
end_function

begin_comment
comment|/**    * @param row Row to check    * @throws IllegalArgumentException Thrown if<code>row</code> is empty or null or    *&gt; {@link HConstants#MAX_ROW_LENGTH}    * @return<code>row</code>    */
end_comment

begin_function
specifier|static
name|byte
index|[]
name|checkRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|)
block|{
return|return
name|checkRow
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
name|row
operator|==
literal|null
condition|?
literal|0
else|:
name|row
operator|.
name|length
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * @param row Row to check    * @param offset    * @param length    * @throws IllegalArgumentException Thrown if<code>row</code> is empty or null or    *&gt; {@link HConstants#MAX_ROW_LENGTH}    * @return<code>row</code>    */
end_comment

begin_function
specifier|static
name|byte
index|[]
name|checkRow
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
name|row
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Row buffer is null"
argument_list|)
throw|;
block|}
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Row length is 0"
argument_list|)
throw|;
block|}
if|if
condition|(
name|length
operator|>
name|HConstants
operator|.
name|MAX_ROW_LENGTH
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Row length "
operator|+
name|length
operator|+
literal|" is> "
operator|+
name|HConstants
operator|.
name|MAX_ROW_LENGTH
argument_list|)
throw|;
block|}
return|return
name|row
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|checkRow
parameter_list|(
name|ByteBuffer
name|row
parameter_list|)
block|{
if|if
condition|(
name|row
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Row buffer is null"
argument_list|)
throw|;
block|}
if|if
condition|(
name|row
operator|.
name|remaining
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Row length is 0"
argument_list|)
throw|;
block|}
if|if
condition|(
name|row
operator|.
name|remaining
argument_list|()
operator|>
name|HConstants
operator|.
name|MAX_ROW_LENGTH
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Row length "
operator|+
name|row
operator|.
name|remaining
argument_list|()
operator|+
literal|" is> "
operator|+
name|HConstants
operator|.
name|MAX_ROW_LENGTH
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
name|Mutation
name|add
parameter_list|(
name|Cell
name|cell
parameter_list|)
throws|throws
name|IOException
block|{
comment|//Checking that the row of the kv is the same as the mutation
comment|// TODO: It is fraught with risk if user pass the wrong row.
comment|// Throwing the IllegalArgumentException is more suitable I'd say.
if|if
condition|(
operator|!
name|CellUtil
operator|.
name|matchingRows
argument_list|(
name|cell
argument_list|,
name|this
operator|.
name|row
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|WrongRowIOException
argument_list|(
literal|"The row in "
operator|+
name|cell
operator|.
name|toString
argument_list|()
operator|+
literal|" doesn't match the original one "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|this
operator|.
name|row
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|cell
operator|.
name|getFamilyArray
argument_list|()
operator|==
literal|null
operator|||
name|cell
operator|.
name|getFamilyLength
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Family cannot be null"
argument_list|)
throw|;
block|}
name|byte
index|[]
name|family
init|=
name|CellUtil
operator|.
name|cloneFamily
argument_list|(
name|cell
argument_list|)
decl_stmt|;
if|if
condition|(
name|cell
operator|instanceof
name|ExtendedCell
condition|)
block|{
name|getCellList
argument_list|(
name|family
argument_list|)
operator|.
name|add
argument_list|(
name|cell
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|getCellList
argument_list|(
name|family
argument_list|)
operator|.
name|add
argument_list|(
operator|new
name|CellWrapper
argument_list|(
name|cell
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
end_function

begin_class
specifier|private
specifier|static
specifier|final
class|class
name|CellWrapper
implements|implements
name|ExtendedCell
block|{
specifier|private
specifier|static
specifier|final
name|long
name|FIXED_OVERHEAD
init|=
name|ClassSize
operator|.
name|align
argument_list|(
name|ClassSize
operator|.
name|OBJECT
comment|// object header
operator|+
name|KeyValue
operator|.
name|TIMESTAMP_SIZE
comment|// timestamp
operator|+
name|Bytes
operator|.
name|SIZEOF_LONG
comment|// sequence id
operator|+
literal|1
operator|*
name|ClassSize
operator|.
name|REFERENCE
argument_list|)
decl_stmt|;
comment|// references to cell
specifier|private
specifier|final
name|Cell
name|cell
decl_stmt|;
specifier|private
name|long
name|sequenceId
decl_stmt|;
specifier|private
name|long
name|timestamp
decl_stmt|;
name|CellWrapper
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
assert|assert
operator|!
operator|(
name|cell
operator|instanceof
name|ExtendedCell
operator|)
assert|;
name|this
operator|.
name|cell
operator|=
name|cell
expr_stmt|;
name|this
operator|.
name|sequenceId
operator|=
name|cell
operator|.
name|getSequenceId
argument_list|()
expr_stmt|;
name|this
operator|.
name|timestamp
operator|=
name|cell
operator|.
name|getTimestamp
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setSequenceId
parameter_list|(
name|long
name|seqId
parameter_list|)
block|{
name|sequenceId
operator|=
name|seqId
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setTimestamp
parameter_list|(
name|long
name|ts
parameter_list|)
block|{
name|timestamp
operator|=
name|ts
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setTimestamp
parameter_list|(
name|byte
index|[]
name|ts
parameter_list|)
block|{
name|timestamp
operator|=
name|Bytes
operator|.
name|toLong
argument_list|(
name|ts
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getSequenceId
parameter_list|()
block|{
return|return
name|sequenceId
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|getValueArray
parameter_list|()
block|{
return|return
name|cell
operator|.
name|getValueArray
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getValueOffset
parameter_list|()
block|{
return|return
name|cell
operator|.
name|getValueOffset
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getValueLength
parameter_list|()
block|{
return|return
name|cell
operator|.
name|getValueLength
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|getTagsArray
parameter_list|()
block|{
return|return
name|cell
operator|.
name|getTagsArray
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getTagsOffset
parameter_list|()
block|{
return|return
name|cell
operator|.
name|getTagsOffset
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getTagsLength
parameter_list|()
block|{
return|return
name|cell
operator|.
name|getTagsLength
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|getRowArray
parameter_list|()
block|{
return|return
name|cell
operator|.
name|getRowArray
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getRowOffset
parameter_list|()
block|{
return|return
name|cell
operator|.
name|getRowOffset
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|short
name|getRowLength
parameter_list|()
block|{
return|return
name|cell
operator|.
name|getRowLength
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|getFamilyArray
parameter_list|()
block|{
return|return
name|cell
operator|.
name|getFamilyArray
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getFamilyOffset
parameter_list|()
block|{
return|return
name|cell
operator|.
name|getFamilyOffset
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
name|getFamilyLength
parameter_list|()
block|{
return|return
name|cell
operator|.
name|getFamilyLength
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|getQualifierArray
parameter_list|()
block|{
return|return
name|cell
operator|.
name|getQualifierArray
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getQualifierOffset
parameter_list|()
block|{
return|return
name|cell
operator|.
name|getQualifierOffset
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getQualifierLength
parameter_list|()
block|{
return|return
name|cell
operator|.
name|getQualifierLength
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getTimestamp
parameter_list|()
block|{
return|return
name|timestamp
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
name|getTypeByte
parameter_list|()
block|{
return|return
name|cell
operator|.
name|getTypeByte
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Optional
argument_list|<
name|Tag
argument_list|>
name|getTag
parameter_list|(
name|byte
name|type
parameter_list|)
block|{
if|if
condition|(
name|cell
operator|instanceof
name|RawCell
condition|)
block|{
return|return
operator|(
operator|(
name|RawCell
operator|)
name|cell
operator|)
operator|.
name|getTag
argument_list|(
name|type
argument_list|)
return|;
block|}
return|return
name|PrivateCellUtil
operator|.
name|getTag
argument_list|(
name|cell
argument_list|,
name|type
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Tag
argument_list|>
name|getTags
parameter_list|()
block|{
if|if
condition|(
name|cell
operator|instanceof
name|RawCell
condition|)
block|{
return|return
operator|(
operator|(
name|RawCell
operator|)
name|cell
operator|)
operator|.
name|getTags
argument_list|()
return|;
block|}
return|return
name|PrivateCellUtil
operator|.
name|tagsIterator
argument_list|(
name|cell
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|cloneTags
parameter_list|()
block|{
if|if
condition|(
name|cell
operator|instanceof
name|RawCell
condition|)
block|{
return|return
operator|(
operator|(
name|RawCell
operator|)
name|cell
operator|)
operator|.
name|cloneTags
argument_list|()
return|;
block|}
return|return
name|PrivateCellUtil
operator|.
name|cloneTags
argument_list|(
name|cell
argument_list|)
return|;
block|}
specifier|private
name|long
name|heapOverhead
parameter_list|()
block|{
return|return
name|FIXED_OVERHEAD
operator|+
name|ClassSize
operator|.
name|ARRAY
comment|// row
operator|+
name|getFamilyLength
argument_list|()
operator|==
literal|0
condition|?
literal|0
else|:
name|ClassSize
operator|.
name|ARRAY
operator|+
name|getQualifierLength
argument_list|()
operator|==
literal|0
condition|?
literal|0
else|:
name|ClassSize
operator|.
name|ARRAY
operator|+
name|getValueLength
argument_list|()
operator|==
literal|0
condition|?
literal|0
else|:
name|ClassSize
operator|.
name|ARRAY
operator|+
name|getTagsLength
argument_list|()
operator|==
literal|0
condition|?
literal|0
else|:
name|ClassSize
operator|.
name|ARRAY
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|heapSize
parameter_list|()
block|{
return|return
name|heapOverhead
argument_list|()
operator|+
name|ClassSize
operator|.
name|align
argument_list|(
name|getRowLength
argument_list|()
argument_list|)
operator|+
name|ClassSize
operator|.
name|align
argument_list|(
name|getFamilyLength
argument_list|()
argument_list|)
operator|+
name|ClassSize
operator|.
name|align
argument_list|(
name|getQualifierLength
argument_list|()
argument_list|)
operator|+
name|ClassSize
operator|.
name|align
argument_list|(
name|getValueLength
argument_list|()
argument_list|)
operator|+
name|ClassSize
operator|.
name|align
argument_list|(
name|getTagsLength
argument_list|()
argument_list|)
return|;
block|}
block|}
end_class

unit|}
end_unit

