begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|RegionTransition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|DeserializationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|EventType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|AsyncCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
operator|.
name|Code
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
operator|.
name|NoNodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
operator|.
name|NodeExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|Stat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|// We should not be importing this Type here, nor a RegionTransition, etc.  This class should be
end_comment

begin_comment
comment|// about zk and bytes only.
end_comment

begin_comment
comment|/**  * Utility class for doing region assignment in ZooKeeper.  This class extends  * stuff done in {@link ZKUtil} to cover specific assignment operations.  *<p>  * Contains only static methods and constants.  *<p>  * Used by both the Master and RegionServer.  *<p>  * All valid transitions outlined below:  *<p>  *<b>MASTER</b>  *<ol>  *<li>  *     Master creates an unassigned node as OFFLINE.  *     - Cluster startup and table enabling.  *</li>  *<li>  *     Master forces an existing unassigned node to OFFLINE.  *     - RegionServer failure.  *     - Allows transitions from all states to OFFLINE.  *</li>  *<li>  *     Master deletes an unassigned node that was in a OPENED state.  *     - Normal region transitions.  Besides cluster startup, no other deletions  *     of unassigned nodes is allowed.  *</li>  *<li>  *     Master deletes all unassigned nodes regardless of state.  *     - Cluster startup before any assignment happens.  *</li>  *</ol>  *<p>  *<b>REGIONSERVER</b>  *<ol>  *<li>  *     RegionServer creates an unassigned node as CLOSING.  *     - All region closes will do this in response to a CLOSE RPC from Master.  *     - A node can never be transitioned to CLOSING, only created.  *</li>  *<li>  *     RegionServer transitions an unassigned node from CLOSING to CLOSED.  *     - Normal region closes.  CAS operation.  *</li>  *<li>  *     RegionServer transitions an unassigned node from OFFLINE to OPENING.  *     - All region opens will do this in response to an OPEN RPC from the Master.  *     - Normal region opens.  CAS operation.  *</li>  *<li>  *     RegionServer transitions an unassigned node from OPENING to OPENED.  *     - Normal region opens.  CAS operation.  *</li>  *</ol>  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
class|class
name|ZKAssign
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ZKAssign
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Gets the full path node name for the unassigned node for the specified    * region.    * @param zkw zk reference    * @param regionName region name    * @return full path node name    */
specifier|public
specifier|static
name|String
name|getNodeName
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|,
name|String
name|regionName
parameter_list|)
block|{
return|return
name|ZKUtil
operator|.
name|joinZNode
argument_list|(
name|zkw
operator|.
name|assignmentZNode
argument_list|,
name|regionName
argument_list|)
return|;
block|}
comment|/**    * Gets the region name from the full path node name of an unassigned node.    * @param path full zk path    * @return region name    */
specifier|public
specifier|static
name|String
name|getRegionName
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|,
name|String
name|path
parameter_list|)
block|{
return|return
name|path
operator|.
name|substring
argument_list|(
name|zkw
operator|.
name|assignmentZNode
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
return|;
block|}
comment|// Master methods
comment|/**    * Creates a new unassigned node in the OFFLINE state for the specified region.    *    *<p>Does not transition nodes from other states.  If a node already exists    * for this region, a {@link NodeExistsException} will be thrown.    *    *<p>Sets a watcher on the unassigned region node if the method is successful.    *    *<p>This method should only be used during cluster startup and the enabling    * of a table.    *    * @param zkw zk reference    * @param region region to be created as offline    * @param serverName server transition will happen on    * @throws KeeperException if unexpected zookeeper exception    * @throws KeeperException.NodeExistsException if node already exists    */
specifier|public
specifier|static
name|void
name|createNodeOffline
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|,
name|HRegionInfo
name|region
parameter_list|,
name|ServerName
name|serverName
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|KeeperException
operator|.
name|NodeExistsException
block|{
name|createNodeOffline
argument_list|(
name|zkw
argument_list|,
name|region
argument_list|,
name|serverName
argument_list|,
name|EventType
operator|.
name|M_ZK_REGION_OFFLINE
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|createNodeOffline
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|,
name|HRegionInfo
name|region
parameter_list|,
name|ServerName
name|serverName
parameter_list|,
specifier|final
name|EventType
name|event
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|KeeperException
operator|.
name|NodeExistsException
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Creating unassigned node "
operator|+
name|region
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" in OFFLINE state"
argument_list|)
argument_list|)
expr_stmt|;
name|RegionTransition
name|rt
init|=
name|RegionTransition
operator|.
name|createRegionTransition
argument_list|(
name|event
argument_list|,
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|serverName
argument_list|)
decl_stmt|;
name|String
name|node
init|=
name|getNodeName
argument_list|(
name|zkw
argument_list|,
name|region
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
name|ZKUtil
operator|.
name|createAndWatch
argument_list|(
name|zkw
argument_list|,
name|node
argument_list|,
name|rt
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates an unassigned node in the OFFLINE state for the specified region.    *<p>    * Runs asynchronously.  Depends on no pre-existing znode.    *    *<p>Sets a watcher on the unassigned region node.    *    * @param zkw zk reference    * @param region region to be created as offline    * @param serverName server transition will happen on    * @param cb    * @param ctx    * @throws KeeperException if unexpected zookeeper exception    * @throws KeeperException.NodeExistsException if node already exists    */
specifier|public
specifier|static
name|void
name|asyncCreateNodeOffline
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|,
name|HRegionInfo
name|region
parameter_list|,
name|ServerName
name|serverName
parameter_list|,
specifier|final
name|AsyncCallback
operator|.
name|StringCallback
name|cb
parameter_list|,
specifier|final
name|Object
name|ctx
parameter_list|)
throws|throws
name|KeeperException
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Async create of unassigned node "
operator|+
name|region
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" with OFFLINE state"
argument_list|)
argument_list|)
expr_stmt|;
name|RegionTransition
name|rt
init|=
name|RegionTransition
operator|.
name|createRegionTransition
argument_list|(
name|EventType
operator|.
name|M_ZK_REGION_OFFLINE
argument_list|,
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|serverName
argument_list|)
decl_stmt|;
name|String
name|node
init|=
name|getNodeName
argument_list|(
name|zkw
argument_list|,
name|region
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
name|ZKUtil
operator|.
name|asyncCreate
argument_list|(
name|zkw
argument_list|,
name|node
argument_list|,
name|rt
operator|.
name|toByteArray
argument_list|()
argument_list|,
name|cb
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates or force updates an unassigned node to the OFFLINE state for the    * specified region.    *<p>    * Attempts to create the node but if it exists will force it to transition to    * and OFFLINE state.    *    *<p>Sets a watcher on the unassigned region node if the method is    * successful.    *    *<p>This method should be used when assigning a region.    *    * @param zkw zk reference    * @param region region to be created as offline    * @param serverName server transition will happen on    * @return the version of the znode created in OFFLINE state, -1 if    *         unsuccessful.    * @throws KeeperException if unexpected zookeeper exception    * @throws KeeperException.NodeExistsException if node already exists    */
specifier|public
specifier|static
name|int
name|createOrForceNodeOffline
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|,
name|HRegionInfo
name|region
parameter_list|,
name|ServerName
name|serverName
parameter_list|)
throws|throws
name|KeeperException
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Creating (or updating) unassigned node "
operator|+
name|region
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" with OFFLINE state"
argument_list|)
argument_list|)
expr_stmt|;
name|RegionTransition
name|rt
init|=
name|RegionTransition
operator|.
name|createRegionTransition
argument_list|(
name|EventType
operator|.
name|M_ZK_REGION_OFFLINE
argument_list|,
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|serverName
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|)
decl_stmt|;
name|byte
index|[]
name|data
init|=
name|rt
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
name|String
name|node
init|=
name|getNodeName
argument_list|(
name|zkw
argument_list|,
name|region
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
name|zkw
operator|.
name|sync
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|int
name|version
init|=
name|ZKUtil
operator|.
name|checkExists
argument_list|(
name|zkw
argument_list|,
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|version
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|ZKUtil
operator|.
name|createAndWatch
argument_list|(
name|zkw
argument_list|,
name|node
argument_list|,
name|data
argument_list|)
return|;
block|}
else|else
block|{
name|boolean
name|setData
init|=
literal|false
decl_stmt|;
try|try
block|{
name|setData
operator|=
name|ZKUtil
operator|.
name|setData
argument_list|(
name|zkw
argument_list|,
name|node
argument_list|,
name|data
argument_list|,
name|version
argument_list|)
expr_stmt|;
comment|// Setdata throws KeeperException which aborts the Master. So we are
comment|// catching it here.
comment|// If just before setting the znode to OFFLINE if the RS has made any
comment|// change to the
comment|// znode state then we need to return -1.
block|}
catch|catch
parameter_list|(
name|KeeperException
name|kpe
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Version mismatch while setting the node to OFFLINE state."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|setData
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
comment|// We successfully forced to OFFLINE, reset watch and handle if
comment|// the state changed in between our set and the watch
name|byte
index|[]
name|bytes
init|=
name|ZKAssign
operator|.
name|getData
argument_list|(
name|zkw
argument_list|,
name|region
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
name|rt
operator|=
name|getRegionTransition
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|.
name|getEventType
argument_list|()
operator|!=
name|EventType
operator|.
name|M_ZK_REGION_OFFLINE
condition|)
block|{
comment|// state changed, need to process
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
return|return
name|version
operator|+
literal|1
return|;
block|}
comment|/**    * Deletes an existing unassigned node that is in the OPENED state for the    * specified region.    *    *<p>If a node does not already exist for this region, a    * {@link NoNodeException} will be thrown.    *    *<p>No watcher is set whether this succeeds or not.    *    *<p>Returns false if the node was not in the proper state but did exist.    *    *<p>This method is used during normal region transitions when a region    * finishes successfully opening.  This is the Master acknowledging completion    * of the specified regions transition.    *    * @param zkw zk reference    * @param encodedRegionName opened region to be deleted from zk    * @throws KeeperException if unexpected zookeeper exception    * @throws KeeperException.NoNodeException if node does not exist    */
specifier|public
specifier|static
name|boolean
name|deleteOpenedNode
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|,
name|String
name|encodedRegionName
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|KeeperException
operator|.
name|NoNodeException
block|{
return|return
name|deleteNode
argument_list|(
name|zkw
argument_list|,
name|encodedRegionName
argument_list|,
name|EventType
operator|.
name|RS_ZK_REGION_OPENED
argument_list|)
return|;
block|}
comment|/**    * Deletes an existing unassigned node that is in the OFFLINE state for the    * specified region.    *    *<p>If a node does not already exist for this region, a    * {@link NoNodeException} will be thrown.    *    *<p>No watcher is set whether this succeeds or not.    *    *<p>Returns false if the node was not in the proper state but did exist.    *    *<p>This method is used during master failover when the regions on an RS    * that has died are all set to OFFLINE before being processed.    *    * @param zkw zk reference    * @param encodedRegionName closed region to be deleted from zk    * @throws KeeperException if unexpected zookeeper exception    * @throws KeeperException.NoNodeException if node does not exist    */
specifier|public
specifier|static
name|boolean
name|deleteOfflineNode
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|,
name|String
name|encodedRegionName
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|KeeperException
operator|.
name|NoNodeException
block|{
return|return
name|deleteNode
argument_list|(
name|zkw
argument_list|,
name|encodedRegionName
argument_list|,
name|EventType
operator|.
name|M_ZK_REGION_OFFLINE
argument_list|)
return|;
block|}
comment|/**    * Deletes an existing unassigned node that is in the CLOSED state for the    * specified region.    *    *<p>If a node does not already exist for this region, a    * {@link NoNodeException} will be thrown.    *    *<p>No watcher is set whether this succeeds or not.    *    *<p>Returns false if the node was not in the proper state but did exist.    *    *<p>This method is used during table disables when a region finishes    * successfully closing.  This is the Master acknowledging completion    * of the specified regions transition to being closed.    *    * @param zkw zk reference    * @param encodedRegionName closed region to be deleted from zk    * @throws KeeperException if unexpected zookeeper exception    * @throws KeeperException.NoNodeException if node does not exist    */
specifier|public
specifier|static
name|boolean
name|deleteClosedNode
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|,
name|String
name|encodedRegionName
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|KeeperException
operator|.
name|NoNodeException
block|{
return|return
name|deleteNode
argument_list|(
name|zkw
argument_list|,
name|encodedRegionName
argument_list|,
name|EventType
operator|.
name|RS_ZK_REGION_CLOSED
argument_list|)
return|;
block|}
comment|/**    * Deletes an existing unassigned node that is in the CLOSING state for the    * specified region.    *    *<p>If a node does not already exist for this region, a    * {@link NoNodeException} will be thrown.    *    *<p>No watcher is set whether this succeeds or not.    *    *<p>Returns false if the node was not in the proper state but did exist.    *    *<p>This method is used during table disables when a region finishes    * successfully closing.  This is the Master acknowledging completion    * of the specified regions transition to being closed.    *    * @param zkw zk reference    * @param region closing region to be deleted from zk    * @throws KeeperException if unexpected zookeeper exception    * @throws KeeperException.NoNodeException if node does not exist    */
specifier|public
specifier|static
name|boolean
name|deleteClosingNode
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|,
name|HRegionInfo
name|region
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|KeeperException
operator|.
name|NoNodeException
block|{
name|String
name|encodedRegionName
init|=
name|region
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
return|return
name|deleteNode
argument_list|(
name|zkw
argument_list|,
name|encodedRegionName
argument_list|,
name|EventType
operator|.
name|M_ZK_REGION_CLOSING
argument_list|)
return|;
block|}
comment|/**    * Deletes an existing unassigned node that is in the specified state for the    * specified region.    *    *<p>If a node does not already exist for this region, a    * {@link NoNodeException} will be thrown.    *    *<p>No watcher is set whether this succeeds or not.    *    *<p>Returns false if the node was not in the proper state but did exist.    *    *<p>This method is used when a region finishes opening/closing.    * The Master acknowledges completion    * of the specified regions transition to being closed/opened.    *    * @param zkw zk reference    * @param encodedRegionName region to be deleted from zk    * @param expectedState state region must be in for delete to complete    * @throws KeeperException if unexpected zookeeper exception    * @throws KeeperException.NoNodeException if node does not exist    */
specifier|public
specifier|static
name|boolean
name|deleteNode
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|,
name|String
name|encodedRegionName
parameter_list|,
name|EventType
name|expectedState
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|KeeperException
operator|.
name|NoNodeException
block|{
return|return
name|deleteNode
argument_list|(
name|zkw
argument_list|,
name|encodedRegionName
argument_list|,
name|expectedState
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/**    * Deletes an existing unassigned node that is in the specified state for the    * specified region.    *    *<p>If a node does not already exist for this region, a    * {@link NoNodeException} will be thrown.    *    *<p>No watcher is set whether this succeeds or not.    *    *<p>Returns false if the node was not in the proper state but did exist.    *    *<p>This method is used when a region finishes opening/closing.    * The Master acknowledges completion    * of the specified regions transition to being closed/opened.    *    * @param zkw zk reference    * @param encodedRegionName region to be deleted from zk    * @param expectedState state region must be in for delete to complete    * @param expectedVersion of the znode that is to be deleted.    *        If expectedVersion need not be compared while deleting the znode    *        pass -1    * @throws KeeperException if unexpected zookeeper exception    * @throws KeeperException.NoNodeException if node does not exist    */
specifier|public
specifier|static
name|boolean
name|deleteNode
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|,
name|String
name|encodedRegionName
parameter_list|,
name|EventType
name|expectedState
parameter_list|,
name|int
name|expectedVersion
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|KeeperException
operator|.
name|NoNodeException
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Deleting existing unassigned "
operator|+
literal|"node "
operator|+
name|encodedRegionName
operator|+
literal|" in expected state "
operator|+
name|expectedState
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|String
name|node
init|=
name|getNodeName
argument_list|(
name|zkw
argument_list|,
name|encodedRegionName
argument_list|)
decl_stmt|;
name|zkw
operator|.
name|sync
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|Stat
name|stat
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
name|byte
index|[]
name|bytes
init|=
name|ZKUtil
operator|.
name|getDataNoWatch
argument_list|(
name|zkw
argument_list|,
name|node
argument_list|,
name|stat
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|null
condition|)
block|{
comment|// If it came back null, node does not exist.
throw|throw
name|KeeperException
operator|.
name|create
argument_list|(
name|Code
operator|.
name|NONODE
argument_list|)
throw|;
block|}
name|RegionTransition
name|rt
init|=
name|getRegionTransition
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
name|EventType
name|et
init|=
name|rt
operator|.
name|getEventType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|et
operator|.
name|equals
argument_list|(
name|expectedState
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Attempting to delete unassigned node "
operator|+
name|encodedRegionName
operator|+
literal|" in "
operator|+
name|expectedState
operator|+
literal|" state but node is in "
operator|+
name|et
operator|+
literal|" state"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|expectedVersion
operator|!=
operator|-
literal|1
operator|&&
name|stat
operator|.
name|getVersion
argument_list|()
operator|!=
name|expectedVersion
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The node "
operator|+
name|encodedRegionName
operator|+
literal|" we are trying to delete is not"
operator|+
literal|" the expected one. Got a version mismatch"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|ZKUtil
operator|.
name|deleteNode
argument_list|(
name|zkw
argument_list|,
name|node
argument_list|,
name|stat
operator|.
name|getVersion
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Attempting to delete "
operator|+
literal|"unassigned node "
operator|+
name|encodedRegionName
operator|+
literal|" in "
operator|+
name|expectedState
operator|+
literal|" state but after verifying state, we got a version mismatch"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Deleted unassigned node "
operator|+
name|encodedRegionName
operator|+
literal|" in expected state "
operator|+
name|expectedState
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Deletes all unassigned nodes regardless of their state.    *    *<p>No watchers are set.    *    *<p>This method is used by the Master during cluster startup to clear out    * any existing state from other cluster runs.    *    * @param zkw zk reference    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|void
name|deleteAllNodes
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|)
throws|throws
name|KeeperException
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Deleting any existing unassigned nodes"
argument_list|)
argument_list|)
expr_stmt|;
name|ZKUtil
operator|.
name|deleteChildrenRecursively
argument_list|(
name|zkw
argument_list|,
name|zkw
operator|.
name|assignmentZNode
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a new unassigned node in the CLOSING state for the specified    * region.    *    *<p>Does not transition nodes from any states.  If a node already exists    * for this region, a {@link NodeExistsException} will be thrown.    *    *<p>If creation is successful, returns the version number of the CLOSING    * node created.    *    *<p>Set a watch.    *    *<p>This method should only be used by a Master when initiating a    * close of a region before sending a close request to the region server.    *    * @param zkw zk reference    * @param region region to be created as closing    * @param serverName server transition will happen on    * @return version of node after transition, -1 if unsuccessful transition    * @throws KeeperException if unexpected zookeeper exception    * @throws KeeperException.NodeExistsException if node already exists    */
specifier|public
specifier|static
name|int
name|createNodeClosing
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|,
name|HRegionInfo
name|region
parameter_list|,
name|ServerName
name|serverName
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|KeeperException
operator|.
name|NodeExistsException
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Creating unassigned node "
operator|+
name|region
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" in a CLOSING state"
argument_list|)
argument_list|)
expr_stmt|;
name|RegionTransition
name|rt
init|=
name|RegionTransition
operator|.
name|createRegionTransition
argument_list|(
name|EventType
operator|.
name|M_ZK_REGION_CLOSING
argument_list|,
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|serverName
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|)
decl_stmt|;
name|String
name|node
init|=
name|getNodeName
argument_list|(
name|zkw
argument_list|,
name|region
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|ZKUtil
operator|.
name|createAndWatch
argument_list|(
name|zkw
argument_list|,
name|node
argument_list|,
name|rt
operator|.
name|toByteArray
argument_list|()
argument_list|)
return|;
block|}
comment|// RegionServer methods
comment|/**    * Transitions an existing unassigned node for the specified region which is    * currently in the CLOSING state to be in the CLOSED state.    *    *<p>Does not transition nodes from other states.  If for some reason the    * node could not be transitioned, the method returns -1.  If the transition    * is successful, the version of the node after transition is returned.    *    *<p>This method can fail and return false for three different reasons:    *<ul><li>Unassigned node for this region does not exist</li>    *<li>Unassigned node for this region is not in CLOSING state</li>    *<li>After verifying CLOSING state, update fails because of wrong version    * (someone else already transitioned the node)</li>    *</ul>    *    *<p>Does not set any watches.    *    *<p>This method should only be used by a RegionServer when initiating a    * close of a region after receiving a CLOSE RPC from the Master.    *    * @param zkw zk reference    * @param region region to be transitioned to closed    * @param serverName server transition happens on    * @return version of node after transition, -1 if unsuccessful transition    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|int
name|transitionNodeClosed
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|,
name|HRegionInfo
name|region
parameter_list|,
name|ServerName
name|serverName
parameter_list|,
name|int
name|expectedVersion
parameter_list|)
throws|throws
name|KeeperException
block|{
return|return
name|transitionNode
argument_list|(
name|zkw
argument_list|,
name|region
argument_list|,
name|serverName
argument_list|,
name|EventType
operator|.
name|M_ZK_REGION_CLOSING
argument_list|,
name|EventType
operator|.
name|RS_ZK_REGION_CLOSED
argument_list|,
name|expectedVersion
argument_list|)
return|;
block|}
comment|/**    * Transitions an existing unassigned node for the specified region which is    * currently in the OFFLINE state to be in the OPENING state.    *    *<p>Does not transition nodes from other states.  If for some reason the    * node could not be transitioned, the method returns -1.  If the transition    * is successful, the version of the node written as OPENING is returned.    *    *<p>This method can fail and return -1 for three different reasons:    *<ul><li>Unassigned node for this region does not exist</li>    *<li>Unassigned node for this region is not in OFFLINE state</li>    *<li>After verifying OFFLINE state, update fails because of wrong version    * (someone else already transitioned the node)</li>    *</ul>    *    *<p>Does not set any watches.    *    *<p>This method should only be used by a RegionServer when initiating an    * open of a region after receiving an OPEN RPC from the Master.    *    * @param zkw zk reference    * @param region region to be transitioned to opening    * @param serverName server transition happens on    * @return version of node after transition, -1 if unsuccessful transition    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|int
name|transitionNodeOpening
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|,
name|HRegionInfo
name|region
parameter_list|,
name|ServerName
name|serverName
parameter_list|)
throws|throws
name|KeeperException
block|{
return|return
name|transitionNodeOpening
argument_list|(
name|zkw
argument_list|,
name|region
argument_list|,
name|serverName
argument_list|,
name|EventType
operator|.
name|M_ZK_REGION_OFFLINE
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|int
name|transitionNodeOpening
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|,
name|HRegionInfo
name|region
parameter_list|,
name|ServerName
name|serverName
parameter_list|,
specifier|final
name|EventType
name|beginState
parameter_list|)
throws|throws
name|KeeperException
block|{
return|return
name|transitionNode
argument_list|(
name|zkw
argument_list|,
name|region
argument_list|,
name|serverName
argument_list|,
name|beginState
argument_list|,
name|EventType
operator|.
name|RS_ZK_REGION_OPENING
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/**    * Retransitions an existing unassigned node for the specified region which is    * currently in the OPENING state to be in the OPENING state.    *    *<p>Does not transition nodes from other states.  If for some reason the    * node could not be transitioned, the method returns -1.  If the transition    * is successful, the version of the node rewritten as OPENING is returned.    *    *<p>This method can fail and return -1 for three different reasons:    *<ul><li>Unassigned node for this region does not exist</li>    *<li>Unassigned node for this region is not in OPENING state</li>    *<li>After verifying OPENING state, update fails because of wrong version    * (someone else already transitioned the node)</li>    *</ul>    *    *<p>Does not set any watches.    *    *<p>This method should only be used by a RegionServer when initiating an    * open of a region after receiving an OPEN RPC from the Master.    *    * @param zkw zk reference    * @param region region to be transitioned to opening    * @param serverName server transition happens on    * @param updateZNode write the znode. If false, we only check.    * @return version of node after transition, -1 if unsuccessful transition    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|int
name|retransitionNodeOpening
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|,
name|HRegionInfo
name|region
parameter_list|,
name|ServerName
name|serverName
parameter_list|,
name|int
name|expectedVersion
parameter_list|,
name|boolean
name|updateZNode
parameter_list|)
throws|throws
name|KeeperException
block|{
name|String
name|encoded
init|=
name|region
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Attempting to retransition opening state of node "
operator|+
name|HRegionInfo
operator|.
name|prettyPrint
argument_list|(
name|encoded
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|String
name|node
init|=
name|getNodeName
argument_list|(
name|zkw
argument_list|,
name|encoded
argument_list|)
decl_stmt|;
name|zkw
operator|.
name|sync
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// Read existing data of the node
name|Stat
name|stat
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
name|byte
index|[]
name|existingBytes
init|=
name|ZKUtil
operator|.
name|getDataNoWatch
argument_list|(
name|zkw
argument_list|,
name|node
argument_list|,
name|stat
argument_list|)
decl_stmt|;
if|if
condition|(
name|existingBytes
operator|==
literal|null
condition|)
block|{
comment|// Node no longer exists.  Return -1. It means unsuccessful transition.
return|return
operator|-
literal|1
return|;
block|}
name|RegionTransition
name|rt
init|=
name|getRegionTransition
argument_list|(
name|existingBytes
argument_list|)
decl_stmt|;
comment|// Verify it is the expected version
if|if
condition|(
name|expectedVersion
operator|!=
operator|-
literal|1
operator|&&
name|stat
operator|.
name|getVersion
argument_list|()
operator|!=
name|expectedVersion
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Attempt to retransition the opening state of the "
operator|+
literal|"unassigned node for "
operator|+
name|encoded
operator|+
literal|" failed, "
operator|+
literal|"the node existed but was version "
operator|+
name|stat
operator|.
name|getVersion
argument_list|()
operator|+
literal|" not the expected version "
operator|+
name|expectedVersion
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|// Verify it is in expected state
name|EventType
name|et
init|=
name|rt
operator|.
name|getEventType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|et
operator|.
name|equals
argument_list|(
name|EventType
operator|.
name|RS_ZK_REGION_OPENING
argument_list|)
condition|)
block|{
name|String
name|existingServer
init|=
operator|(
name|rt
operator|.
name|getServerName
argument_list|()
operator|==
literal|null
operator|)
condition|?
literal|"<unknown>"
else|:
name|rt
operator|.
name|getServerName
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Attempt to retransition the opening state of the unassigned node for "
operator|+
name|encoded
operator|+
literal|" failed, the node existed but was in the state "
operator|+
name|et
operator|+
literal|" set by the server "
operator|+
name|existingServer
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|// We don't have to write the new state: the check is complete.
if|if
condition|(
operator|!
name|updateZNode
condition|)
block|{
return|return
name|expectedVersion
return|;
block|}
comment|// Write new data, ensuring data has not changed since we last read it
try|try
block|{
name|rt
operator|=
name|RegionTransition
operator|.
name|createRegionTransition
argument_list|(
name|EventType
operator|.
name|RS_ZK_REGION_OPENING
argument_list|,
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|serverName
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ZKUtil
operator|.
name|setData
argument_list|(
name|zkw
argument_list|,
name|node
argument_list|,
name|rt
operator|.
name|toByteArray
argument_list|()
argument_list|,
name|stat
operator|.
name|getVersion
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Attempt to retransition the opening state of the "
operator|+
literal|"unassigned node for "
operator|+
name|encoded
operator|+
literal|" failed, "
operator|+
literal|"the node existed and was in the expected state but then when "
operator|+
literal|"setting data we got a version mismatch"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Retransition opening state of node "
operator|+
name|encoded
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|stat
operator|.
name|getVersion
argument_list|()
operator|+
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|nne
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Attempt to retransition the opening state of the "
operator|+
literal|"unassigned node for "
operator|+
name|encoded
operator|+
literal|" failed, "
operator|+
literal|"the node existed and was in the expected state but then when "
operator|+
literal|"setting data it no longer existed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/**    * Transitions an existing unassigned node for the specified region which is    * currently in the OPENING state to be in the OPENED state.    *    *<p>Does not transition nodes from other states.  If for some reason the    * node could not be transitioned, the method returns -1.  If the transition    * is successful, the version of the node after transition is returned.    *    *<p>This method can fail and return false for three different reasons:    *<ul><li>Unassigned node for this region does not exist</li>    *<li>Unassigned node for this region is not in OPENING state</li>    *<li>After verifying OPENING state, update fails because of wrong version    * (this should never actually happen since an RS only does this transition    * following a transition to OPENING.  if two RS are conflicting, one would    * fail the original transition to OPENING and not this transition)</li>    *</ul>    *    *<p>Does not set any watches.    *    *<p>This method should only be used by a RegionServer when completing the    * open of a region.    *    * @param zkw zk reference    * @param region region to be transitioned to opened    * @param serverName server transition happens on    * @return version of node after transition, -1 if unsuccessful transition    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|int
name|transitionNodeOpened
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|,
name|HRegionInfo
name|region
parameter_list|,
name|ServerName
name|serverName
parameter_list|,
name|int
name|expectedVersion
parameter_list|)
throws|throws
name|KeeperException
block|{
return|return
name|transitionNode
argument_list|(
name|zkw
argument_list|,
name|region
argument_list|,
name|serverName
argument_list|,
name|EventType
operator|.
name|RS_ZK_REGION_OPENING
argument_list|,
name|EventType
operator|.
name|RS_ZK_REGION_OPENED
argument_list|,
name|expectedVersion
argument_list|)
return|;
block|}
comment|/**    *    * @param zkw zk reference    * @param region region to be closed    * @param expectedVersion expected version of the znode    * @return true if the znode exists, has the right version and the right state. False otherwise.    * @throws KeeperException    */
specifier|public
specifier|static
name|boolean
name|checkClosingState
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|,
name|HRegionInfo
name|region
parameter_list|,
name|int
name|expectedVersion
parameter_list|)
throws|throws
name|KeeperException
block|{
specifier|final
name|String
name|encoded
init|=
name|getNodeName
argument_list|(
name|zkw
argument_list|,
name|region
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
name|zkw
operator|.
name|sync
argument_list|(
name|encoded
argument_list|)
expr_stmt|;
comment|// Read existing data of the node
name|Stat
name|stat
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
name|byte
index|[]
name|existingBytes
init|=
name|ZKUtil
operator|.
name|getDataNoWatch
argument_list|(
name|zkw
argument_list|,
name|encoded
argument_list|,
name|stat
argument_list|)
decl_stmt|;
if|if
condition|(
name|existingBytes
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Attempt to check the "
operator|+
literal|"closing node for "
operator|+
name|encoded
operator|+
literal|". The node does not exist"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|expectedVersion
operator|!=
operator|-
literal|1
operator|&&
name|stat
operator|.
name|getVersion
argument_list|()
operator|!=
name|expectedVersion
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Attempt to check the "
operator|+
literal|"closing node for "
operator|+
name|encoded
operator|+
literal|". The node existed but was version "
operator|+
name|stat
operator|.
name|getVersion
argument_list|()
operator|+
literal|" not the expected version "
operator|+
name|expectedVersion
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|RegionTransition
name|rt
init|=
name|getRegionTransition
argument_list|(
name|existingBytes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|EventType
operator|.
name|M_ZK_REGION_CLOSING
operator|.
name|equals
argument_list|(
name|rt
operator|.
name|getEventType
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Attempt to check the "
operator|+
literal|"closing node for "
operator|+
name|encoded
operator|+
literal|". The node existed but was in an unexpected state: "
operator|+
name|rt
operator|.
name|getEventType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Method that actually performs unassigned node transitions.    *    *<p>Attempts to transition the unassigned node for the specified region    * from the expected state to the state in the specified transition data.    *    *<p>Method first reads existing data and verifies it is in the expected    * state.  If the node does not exist or the node is not in the expected    * state, the method returns -1.  If the transition is successful, the    * version number of the node following the transition is returned.    *    *<p>If the read state is what is expected, it attempts to write the new    * state and data into the node.  When doing this, it includes the expected    * version (determined when the existing state was verified) to ensure that    * only one transition is successful.  If there is a version mismatch, the    * method returns -1.    *    *<p>If the write is successful, no watch is set and the method returns true.    *    * @param zkw zk reference    * @param region region to be transitioned to opened    * @param serverName server transition happens on    * @param endState state to transition node to if all checks pass    * @param beginState state the node must currently be in to do transition    * @param expectedVersion expected version of data before modification, or -1    * @return version of node after transition, -1 if unsuccessful transition    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|int
name|transitionNode
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|,
name|HRegionInfo
name|region
parameter_list|,
name|ServerName
name|serverName
parameter_list|,
name|EventType
name|beginState
parameter_list|,
name|EventType
name|endState
parameter_list|,
name|int
name|expectedVersion
parameter_list|)
throws|throws
name|KeeperException
block|{
return|return
name|transitionNode
argument_list|(
name|zkw
argument_list|,
name|region
argument_list|,
name|serverName
argument_list|,
name|beginState
argument_list|,
name|endState
argument_list|,
name|expectedVersion
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|int
name|transitionNode
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|,
name|HRegionInfo
name|region
parameter_list|,
name|ServerName
name|serverName
parameter_list|,
name|EventType
name|beginState
parameter_list|,
name|EventType
name|endState
parameter_list|,
name|int
name|expectedVersion
parameter_list|,
specifier|final
name|byte
index|[]
name|payload
parameter_list|)
throws|throws
name|KeeperException
block|{
name|String
name|encoded
init|=
name|region
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Transitioning "
operator|+
name|HRegionInfo
operator|.
name|prettyPrint
argument_list|(
name|encoded
argument_list|)
operator|+
literal|" from "
operator|+
name|beginState
operator|.
name|toString
argument_list|()
operator|+
literal|" to "
operator|+
name|endState
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|String
name|node
init|=
name|getNodeName
argument_list|(
name|zkw
argument_list|,
name|encoded
argument_list|)
decl_stmt|;
name|zkw
operator|.
name|sync
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// Read existing data of the node
name|Stat
name|stat
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
name|byte
index|[]
name|existingBytes
init|=
name|ZKUtil
operator|.
name|getDataNoWatch
argument_list|(
name|zkw
argument_list|,
name|node
argument_list|,
name|stat
argument_list|)
decl_stmt|;
if|if
condition|(
name|existingBytes
operator|==
literal|null
condition|)
block|{
comment|// Node no longer exists.  Return -1. It means unsuccessful transition.
return|return
operator|-
literal|1
return|;
block|}
comment|// Verify it is the expected version
if|if
condition|(
name|expectedVersion
operator|!=
operator|-
literal|1
operator|&&
name|stat
operator|.
name|getVersion
argument_list|()
operator|!=
name|expectedVersion
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Attempt to transition the "
operator|+
literal|"unassigned node for "
operator|+
name|encoded
operator|+
literal|" from "
operator|+
name|beginState
operator|+
literal|" to "
operator|+
name|endState
operator|+
literal|" failed, "
operator|+
literal|"the node existed but was version "
operator|+
name|stat
operator|.
name|getVersion
argument_list|()
operator|+
literal|" not the expected version "
operator|+
name|expectedVersion
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|beginState
operator|.
name|equals
argument_list|(
name|EventType
operator|.
name|M_ZK_REGION_OFFLINE
argument_list|)
operator|&&
name|endState
operator|.
name|equals
argument_list|(
name|EventType
operator|.
name|RS_ZK_REGION_OPENING
argument_list|)
operator|&&
name|expectedVersion
operator|==
operator|-
literal|1
operator|&&
name|stat
operator|.
name|getVersion
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|// the below check ensures that double assignment doesnot happen.
comment|// When the node is created for the first time then the expected version
comment|// that is passed will be -1 and the version in znode will be 0.
comment|// In all other cases the version in znode will be> 0.
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Attempt to transition the "
operator|+
literal|"unassigned node for "
operator|+
name|encoded
operator|+
literal|" from "
operator|+
name|beginState
operator|+
literal|" to "
operator|+
name|endState
operator|+
literal|" failed, "
operator|+
literal|"the node existed but was version "
operator|+
name|stat
operator|.
name|getVersion
argument_list|()
operator|+
literal|" not the expected version "
operator|+
name|expectedVersion
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|RegionTransition
name|rt
init|=
name|getRegionTransition
argument_list|(
name|existingBytes
argument_list|)
decl_stmt|;
comment|// Verify the server transition happens on is not changed
if|if
condition|(
operator|!
name|rt
operator|.
name|getServerName
argument_list|()
operator|.
name|equals
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Attempt to transition the "
operator|+
literal|"unassigned node for "
operator|+
name|encoded
operator|+
literal|" from "
operator|+
name|beginState
operator|+
literal|" to "
operator|+
name|endState
operator|+
literal|" failed, "
operator|+
literal|"the server that tried to transition was "
operator|+
name|serverName
operator|+
literal|" not the expected "
operator|+
name|rt
operator|.
name|getServerName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|// Verify it is in expected state
name|EventType
name|et
init|=
name|rt
operator|.
name|getEventType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|et
operator|.
name|equals
argument_list|(
name|beginState
argument_list|)
condition|)
block|{
name|String
name|existingServer
init|=
operator|(
name|rt
operator|.
name|getServerName
argument_list|()
operator|==
literal|null
operator|)
condition|?
literal|"<unknown>"
else|:
name|rt
operator|.
name|getServerName
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Attempt to transition the unassigned node for "
operator|+
name|encoded
operator|+
literal|" from "
operator|+
name|beginState
operator|+
literal|" to "
operator|+
name|endState
operator|+
literal|" failed, the node existed but"
operator|+
literal|" was in the state "
operator|+
name|et
operator|+
literal|" set by the server "
operator|+
name|existingServer
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|// Write new data, ensuring data has not changed since we last read it
try|try
block|{
name|rt
operator|=
name|RegionTransition
operator|.
name|createRegionTransition
argument_list|(
name|endState
argument_list|,
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|serverName
argument_list|,
name|payload
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ZKUtil
operator|.
name|setData
argument_list|(
name|zkw
argument_list|,
name|node
argument_list|,
name|rt
operator|.
name|toByteArray
argument_list|()
argument_list|,
name|stat
operator|.
name|getVersion
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Attempt to transition the "
operator|+
literal|"unassigned node for "
operator|+
name|encoded
operator|+
literal|" from "
operator|+
name|beginState
operator|+
literal|" to "
operator|+
name|endState
operator|+
literal|" failed, "
operator|+
literal|"the node existed and was in the expected state but then when "
operator|+
literal|"setting data we got a version mismatch"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Transitioned node "
operator|+
name|encoded
operator|+
literal|" from "
operator|+
name|beginState
operator|+
literal|" to "
operator|+
name|endState
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|stat
operator|.
name|getVersion
argument_list|()
operator|+
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|nne
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|zkw
operator|.
name|prefix
argument_list|(
literal|"Attempt to transition the "
operator|+
literal|"unassigned node for "
operator|+
name|encoded
operator|+
literal|" from "
operator|+
name|beginState
operator|+
literal|" to "
operator|+
name|endState
operator|+
literal|" failed, "
operator|+
literal|"the node existed and was in the expected state but then when "
operator|+
literal|"setting data it no longer existed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
specifier|private
specifier|static
name|RegionTransition
name|getRegionTransition
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|)
throws|throws
name|KeeperException
block|{
try|try
block|{
return|return
name|RegionTransition
operator|.
name|parseFrom
argument_list|(
name|bytes
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|e
parameter_list|)
block|{
comment|// Convert to a zk exception for now.  Otherwise have to change API
throw|throw
name|ZKUtil
operator|.
name|convert
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Gets the current data in the unassigned node for the specified region name    * or fully-qualified path.    *    *<p>Returns null if the region does not currently have a node.    *    *<p>Sets a watch on the node if the node exists.    *    * @param zkw zk reference    * @param pathOrRegionName fully-specified path or region name    * @return znode content    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|byte
index|[]
name|getData
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|,
name|String
name|pathOrRegionName
parameter_list|)
throws|throws
name|KeeperException
block|{
name|String
name|node
init|=
name|getPath
argument_list|(
name|zkw
argument_list|,
name|pathOrRegionName
argument_list|)
decl_stmt|;
return|return
name|ZKUtil
operator|.
name|getDataAndWatch
argument_list|(
name|zkw
argument_list|,
name|node
argument_list|)
return|;
block|}
comment|/**    * Gets the current data in the unassigned node for the specified region name    * or fully-qualified path.    *    *<p>Returns null if the region does not currently have a node.    *    *<p>Sets a watch on the node if the node exists.    *    * @param zkw zk reference    * @param pathOrRegionName fully-specified path or region name    * @param stat object to populate the version.    * @return znode content    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|byte
index|[]
name|getDataAndWatch
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|,
name|String
name|pathOrRegionName
parameter_list|,
name|Stat
name|stat
parameter_list|)
throws|throws
name|KeeperException
block|{
name|String
name|node
init|=
name|getPath
argument_list|(
name|zkw
argument_list|,
name|pathOrRegionName
argument_list|)
decl_stmt|;
return|return
name|ZKUtil
operator|.
name|getDataAndWatch
argument_list|(
name|zkw
argument_list|,
name|node
argument_list|,
name|stat
argument_list|)
return|;
block|}
comment|/**    * Gets the current data in the unassigned node for the specified region name    * or fully-qualified path.    *    *<p>Returns null if the region does not currently have a node.    *    *<p>Does not set a watch.    *    * @param zkw zk reference    * @param pathOrRegionName fully-specified path or region name    * @param stat object to store node info into on getData call    * @return znode content    * @throws KeeperException if unexpected zookeeper exception    */
specifier|public
specifier|static
name|byte
index|[]
name|getDataNoWatch
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|,
name|String
name|pathOrRegionName
parameter_list|,
name|Stat
name|stat
parameter_list|)
throws|throws
name|KeeperException
block|{
name|String
name|node
init|=
name|getPath
argument_list|(
name|zkw
argument_list|,
name|pathOrRegionName
argument_list|)
decl_stmt|;
return|return
name|ZKUtil
operator|.
name|getDataNoWatch
argument_list|(
name|zkw
argument_list|,
name|node
argument_list|,
name|stat
argument_list|)
return|;
block|}
comment|/**    * @param zkw    * @param pathOrRegionName    * @return Path to znode    */
specifier|public
specifier|static
name|String
name|getPath
parameter_list|(
specifier|final
name|ZooKeeperWatcher
name|zkw
parameter_list|,
specifier|final
name|String
name|pathOrRegionName
parameter_list|)
block|{
return|return
name|pathOrRegionName
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
condition|?
name|pathOrRegionName
else|:
name|getNodeName
argument_list|(
name|zkw
argument_list|,
name|pathOrRegionName
argument_list|)
return|;
block|}
comment|/**    * Get the version of the specified znode    * @param zkw zk reference    * @param region region's info    * @return the version of the znode, -1 if it doesn't exist    * @throws KeeperException    */
specifier|public
specifier|static
name|int
name|getVersion
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|,
name|HRegionInfo
name|region
parameter_list|)
throws|throws
name|KeeperException
block|{
name|String
name|znode
init|=
name|getNodeName
argument_list|(
name|zkw
argument_list|,
name|region
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|ZKUtil
operator|.
name|checkExists
argument_list|(
name|zkw
argument_list|,
name|znode
argument_list|)
return|;
block|}
comment|/**    * Delete the assignment node regardless of its current state.    *<p>    * Fail silent even if the node does not exist at all.    * @param watcher    * @param regionInfo    * @throws KeeperException    */
specifier|public
specifier|static
name|void
name|deleteNodeFailSilent
parameter_list|(
name|ZooKeeperWatcher
name|watcher
parameter_list|,
name|HRegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|KeeperException
block|{
name|String
name|node
init|=
name|getNodeName
argument_list|(
name|watcher
argument_list|,
name|regionInfo
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
name|ZKUtil
operator|.
name|deleteNodeFailSilent
argument_list|(
name|watcher
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
comment|/**    * Blocks until there are no node in regions in transition.    *<p>    * Used in testing only.    * @param zkw zk reference    * @throws KeeperException    * @throws InterruptedException    */
specifier|public
specifier|static
name|void
name|blockUntilNoRIT
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
while|while
condition|(
name|ZKUtil
operator|.
name|nodeHasChildren
argument_list|(
name|zkw
argument_list|,
name|zkw
operator|.
name|assignmentZNode
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|znodes
init|=
name|ZKUtil
operator|.
name|listChildrenAndWatchForNewChildren
argument_list|(
name|zkw
argument_list|,
name|zkw
operator|.
name|assignmentZNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|znodes
operator|!=
literal|null
operator|&&
operator|!
name|znodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting on RIT: "
operator|+
name|znodes
argument_list|)
expr_stmt|;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Blocks until there is at least one node in regions in transition.    *<p>    * Used in testing only.    * @param zkw zk reference    * @throws KeeperException    * @throws InterruptedException    */
specifier|public
specifier|static
name|void
name|blockUntilRIT
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
while|while
condition|(
operator|!
name|ZKUtil
operator|.
name|nodeHasChildren
argument_list|(
name|zkw
argument_list|,
name|zkw
operator|.
name|assignmentZNode
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|znodes
init|=
name|ZKUtil
operator|.
name|listChildrenAndWatchForNewChildren
argument_list|(
name|zkw
argument_list|,
name|zkw
operator|.
name|assignmentZNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|znodes
operator|==
literal|null
operator|||
name|znodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No RIT in ZK"
argument_list|)
expr_stmt|;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Presume bytes are serialized unassigned data structure    * @param znodeBytes    * @return String of the deserialized znode bytes.    */
specifier|static
name|String
name|toString
parameter_list|(
specifier|final
name|byte
index|[]
name|znodeBytes
parameter_list|)
block|{
comment|// This method should not exist.  Used by ZKUtil stringifying RegionTransition.  Have the
comment|// method in here so RegionTransition does not leak into ZKUtil.
try|try
block|{
name|RegionTransition
name|rt
init|=
name|RegionTransition
operator|.
name|parseFrom
argument_list|(
name|znodeBytes
argument_list|)
decl_stmt|;
return|return
name|rt
operator|.
name|toString
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|e
parameter_list|)
block|{
return|return
literal|""
return|;
block|}
block|}
block|}
end_class

end_unit

