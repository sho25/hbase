begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CompletableFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|User
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|PrettyPrinter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Descriptors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|RpcCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|RpcChannel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|RpcController
import|;
end_import

begin_comment
comment|/**  * A non-blocking implementation of RpcChannel that hedges requests to multiple service end points.  * First received response is returned to the caller. This abstracts out the logic needed to batch  * requests to multiple end points underneath and presents itself as a single logical RpcChannel to  * the client.  *  * Hedging Details:  * ---------------  * - Hedging of RPCs happens in multiple batches. In each iteration, we select a 'batch' of address  * end points to make the call to. We do multiple iterations until we get a proper response to the  * rpc call or all the service addresses are exhausted, which ever happens first. Size of each is  * configurable and is also known as 'fanOutSize'.  *  * - We randomize the addresses up front so that the batch order per client is non deterministic.  * This avoids hot spots on the service side. The size of each batch is controlled via 'fanOutSize'.  * Higher fanOutSize implies we make more rpc calls in a single batch. One needs to mindful of the  * load on the client and server side when configuring the fan out.  *  * - In a happy case, once we receive a response from one end point, we cancel all the  * other inflight rpcs in the same batch and return the response to the caller. If we do not get a  * valid response from any address end point, we propagate the error back to the caller.  *  * - Rpc timeouts are applied to every hedged rpc.  *  * - Callers need to be careful about what rpcs they are trying to hedge. Not every kind of call can  * be hedged (for example: cluster state changing rpcs).  *  * (TODO) Retries and Adaptive hedging policy:  * ------------------------------------------  *  * - No retries are handled at the channel level. Retries can be built in upper layers. However the  * question is, do we even need retries? Hedging in fact is a substitute for retries.  *  * - Clearly hedging puts more load on the service side. To mitigate this, we can make the hedging  * policy more adaptive. In most happy cases, the rpcs from the first few end points should return  * right away (especially short lived rpcs, that do not take up much time). In such cases, hedging  * is not needed. So, the idea is to make this request pattern pluggable so that the requests are  * hedged only when needed.  */
end_comment

begin_class
class|class
name|HedgedRpcChannel
implements|implements
name|RpcChannel
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|HedgedRpcChannel
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Currently hedging is only supported for non-blocking connection implementation types because    * the channel implementation inherently relies on the connection implementation being async.    * Refer to the comments in doCallMethod().    */
specifier|private
specifier|final
name|NettyRpcClient
name|rpcClient
decl_stmt|;
comment|// List of service addresses to hedge the requests to.
specifier|private
specifier|final
name|List
argument_list|<
name|InetSocketAddress
argument_list|>
name|addrs
decl_stmt|;
specifier|private
specifier|final
name|User
name|ticket
decl_stmt|;
specifier|private
specifier|final
name|int
name|rpcTimeout
decl_stmt|;
comment|// Controls the size of request fan out (number of rpcs per a single batch).
specifier|private
specifier|final
name|int
name|fanOutSize
decl_stmt|;
comment|/**    * A simple rpc call back implementation to notify the batch context if any rpc is successful.    */
specifier|private
specifier|static
class|class
name|BatchRpcCtxCallBack
implements|implements
name|RpcCallback
argument_list|<
name|Message
argument_list|>
block|{
specifier|private
specifier|final
name|BatchRpcCtx
name|batchRpcCtx
decl_stmt|;
specifier|private
specifier|final
name|HBaseRpcController
name|rpcController
decl_stmt|;
name|BatchRpcCtxCallBack
parameter_list|(
name|BatchRpcCtx
name|batchRpcCtx
parameter_list|,
name|HBaseRpcController
name|rpcController
parameter_list|)
block|{
name|this
operator|.
name|batchRpcCtx
operator|=
name|batchRpcCtx
expr_stmt|;
name|this
operator|.
name|rpcController
operator|=
name|rpcController
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|(
name|Message
name|result
parameter_list|)
block|{
name|batchRpcCtx
operator|.
name|setResultIfNotSet
argument_list|(
name|result
argument_list|,
name|rpcController
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * A shared RPC context between a batch of hedged RPCs. Tracks the state and helpers needed to    * synchronize on multiple RPCs to different end points fetching the result. All the methods are    * thread-safe.    */
specifier|private
specifier|static
class|class
name|BatchRpcCtx
block|{
comment|// Result set by the thread finishing first. Set only once.
specifier|private
specifier|final
name|AtomicReference
argument_list|<
name|Message
argument_list|>
name|result
init|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Caller waits on this latch being set.
comment|// We set this to 1, so that the first successful RPC result is returned to the client.
specifier|private
name|CountDownLatch
name|resultsReady
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// Failed rpc book-keeping.
specifier|private
name|AtomicInteger
name|failedRpcCount
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|// All the call handles for this batch.
specifier|private
specifier|final
name|List
argument_list|<
name|Call
argument_list|>
name|callsInFlight
init|=
name|Collections
operator|.
name|synchronizedList
argument_list|(
operator|new
name|ArrayList
argument_list|<>
argument_list|()
argument_list|)
decl_stmt|;
comment|// Target addresses.
specifier|private
specifier|final
name|List
argument_list|<
name|InetSocketAddress
argument_list|>
name|addresses
decl_stmt|;
comment|// Called when the result is ready.
specifier|private
specifier|final
name|RpcCallback
argument_list|<
name|Message
argument_list|>
name|callBack
decl_stmt|;
comment|// Last failed rpc's exception. Used to propagate the reason to the controller.
specifier|private
name|IOException
name|lastFailedRpcReason
decl_stmt|;
name|BatchRpcCtx
parameter_list|(
name|List
argument_list|<
name|InetSocketAddress
argument_list|>
name|addresses
parameter_list|,
name|RpcCallback
argument_list|<
name|Message
argument_list|>
name|callBack
parameter_list|)
block|{
name|this
operator|.
name|addresses
operator|=
name|addresses
expr_stmt|;
name|this
operator|.
name|callBack
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|callBack
argument_list|)
expr_stmt|;
block|}
comment|/**      * Sets the result only if it is not already set by another thread. Thread that successfully      * sets the result also count downs the latch.      * @param result Result to be set.      */
specifier|public
name|void
name|setResultIfNotSet
parameter_list|(
name|Message
name|result
parameter_list|,
name|HBaseRpcController
name|rpcController
parameter_list|)
block|{
if|if
condition|(
name|rpcController
operator|.
name|failed
argument_list|()
condition|)
block|{
name|incrementFailedRpcs
argument_list|(
name|rpcController
operator|.
name|getFailed
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|this
operator|.
name|result
operator|.
name|compareAndSet
argument_list|(
literal|null
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|resultsReady
operator|.
name|countDown
argument_list|()
expr_stmt|;
comment|// Cancel all pending in flight calls.
for|for
control|(
name|Call
name|call
range|:
name|callsInFlight
control|)
block|{
comment|// It is ok to do it for all calls as it is a no-op if the call is already done.
specifier|final
name|String
name|exceptionMsg
init|=
name|String
operator|.
name|format
argument_list|(
literal|"%s canceled because another hedged attempt "
operator|+
literal|"for the same rpc already succeeded. This is not needed anymore."
argument_list|,
name|call
argument_list|)
decl_stmt|;
name|call
operator|.
name|setException
argument_list|(
operator|new
name|CallCancelledException
argument_list|(
name|exceptionMsg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Waits until the results are populated and calls the callback if the call is successful.      * @return true for successful rpc and false otherwise.      */
specifier|public
name|boolean
name|waitForResults
parameter_list|()
block|{
try|try
block|{
comment|// We do not set a timeout on await() because we rely on the underlying RPCs to timeout if
comment|// something on the remote is broken. Worst case we should wait for rpc time out to kick in.
name|resultsReady
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted while waiting for batched master RPC results. Aborting wait."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|Message
name|message
init|=
name|result
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|message
operator|!=
literal|null
condition|)
block|{
name|callBack
operator|.
name|run
argument_list|(
name|message
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|void
name|addCallInFlight
parameter_list|(
name|Call
name|c
parameter_list|)
block|{
name|callsInFlight
operator|.
name|add
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|incrementFailedRpcs
parameter_list|(
name|IOException
name|reason
parameter_list|)
block|{
if|if
condition|(
name|failedRpcCount
operator|.
name|incrementAndGet
argument_list|()
operator|==
name|addresses
operator|.
name|size
argument_list|()
condition|)
block|{
name|lastFailedRpcReason
operator|=
name|reason
expr_stmt|;
comment|// All the rpcs in this batch have failed. Invoke the waiting threads.
name|resultsReady
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|IOException
name|getLastFailedRpcReason
parameter_list|()
block|{
return|return
name|lastFailedRpcReason
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"Batched rpc for target(s) %s"
argument_list|,
name|PrettyPrinter
operator|.
name|toString
argument_list|(
name|addresses
argument_list|)
argument_list|)
return|;
block|}
block|}
specifier|public
name|HedgedRpcChannel
parameter_list|(
name|NettyRpcClient
name|rpcClient
parameter_list|,
name|Set
argument_list|<
name|InetSocketAddress
argument_list|>
name|addrs
parameter_list|,
name|User
name|ticket
parameter_list|,
name|int
name|rpcTimeout
parameter_list|,
name|int
name|fanOutSize
parameter_list|)
block|{
name|this
operator|.
name|rpcClient
operator|=
name|rpcClient
expr_stmt|;
name|this
operator|.
name|addrs
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|addrs
argument_list|)
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|this
operator|.
name|addrs
operator|.
name|size
argument_list|()
operator|>=
literal|1
argument_list|)
expr_stmt|;
comment|// For non-deterministic client query pattern. Not all clients want to hedge RPCs in the same
comment|// order, creating hot spots on the service end points.
name|Collections
operator|.
name|shuffle
argument_list|(
name|this
operator|.
name|addrs
argument_list|)
expr_stmt|;
name|this
operator|.
name|ticket
operator|=
name|ticket
expr_stmt|;
name|this
operator|.
name|rpcTimeout
operator|=
name|rpcTimeout
expr_stmt|;
comment|// fanOutSize controls the number of hedged RPCs per batch.
name|this
operator|.
name|fanOutSize
operator|=
name|fanOutSize
expr_stmt|;
block|}
specifier|private
name|HBaseRpcController
name|applyRpcTimeout
parameter_list|(
name|RpcController
name|controller
parameter_list|)
block|{
name|HBaseRpcController
name|hBaseRpcController
init|=
operator|(
name|HBaseRpcController
operator|)
name|controller
decl_stmt|;
name|int
name|rpcTimeoutToSet
init|=
name|hBaseRpcController
operator|.
name|hasCallTimeout
argument_list|()
condition|?
name|hBaseRpcController
operator|.
name|getCallTimeout
argument_list|()
else|:
name|rpcTimeout
decl_stmt|;
name|HBaseRpcController
name|response
init|=
operator|new
name|HBaseRpcControllerImpl
argument_list|()
decl_stmt|;
name|response
operator|.
name|setCallTimeout
argument_list|(
name|rpcTimeoutToSet
argument_list|)
expr_stmt|;
return|return
name|response
return|;
block|}
specifier|private
name|void
name|doCallMethod
parameter_list|(
name|Descriptors
operator|.
name|MethodDescriptor
name|method
parameter_list|,
name|HBaseRpcController
name|controller
parameter_list|,
name|Message
name|request
parameter_list|,
name|Message
name|responsePrototype
parameter_list|,
name|RpcCallback
argument_list|<
name|Message
argument_list|>
name|done
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|BatchRpcCtx
name|lastBatchCtx
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|addrs
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// Each iteration picks fanOutSize addresses to run as batch.
name|int
name|batchEnd
init|=
name|Math
operator|.
name|min
argument_list|(
name|addrs
operator|.
name|size
argument_list|()
argument_list|,
name|i
operator|+
name|fanOutSize
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|InetSocketAddress
argument_list|>
name|addrSubList
init|=
name|addrs
operator|.
name|subList
argument_list|(
name|i
argument_list|,
name|batchEnd
argument_list|)
decl_stmt|;
name|BatchRpcCtx
name|batchRpcCtx
init|=
operator|new
name|BatchRpcCtx
argument_list|(
name|addrSubList
argument_list|,
name|done
argument_list|)
decl_stmt|;
name|lastBatchCtx
operator|=
name|batchRpcCtx
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempting request {}, {}"
argument_list|,
name|method
operator|.
name|getName
argument_list|()
argument_list|,
name|batchRpcCtx
argument_list|)
expr_stmt|;
for|for
control|(
name|InetSocketAddress
name|address
range|:
name|addrSubList
control|)
block|{
name|HBaseRpcController
name|rpcController
init|=
name|applyRpcTimeout
argument_list|(
name|controller
argument_list|)
decl_stmt|;
comment|// ** WARN ** This is a blocking call if the underlying connection for the rpc client is
comment|// a blocking implementation (ex: BlockingRpcConnection). That essentially serializes all
comment|// the write calls. Handling blocking connection means that this should be run in a separate
comment|// thread and hence more code complexity. Is it ok to handle only non-blocking connections?
name|batchRpcCtx
operator|.
name|addCallInFlight
argument_list|(
name|rpcClient
operator|.
name|callMethod
argument_list|(
name|method
argument_list|,
name|rpcController
argument_list|,
name|request
argument_list|,
name|responsePrototype
argument_list|,
name|ticket
argument_list|,
name|address
argument_list|,
operator|new
name|BatchRpcCtxCallBack
argument_list|(
name|batchRpcCtx
argument_list|,
name|rpcController
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|batchRpcCtx
operator|.
name|waitForResults
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// Entire batch has failed, lets try the next batch.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed request {}, {}."
argument_list|,
name|method
operator|.
name|getName
argument_list|()
argument_list|,
name|batchRpcCtx
argument_list|)
expr_stmt|;
name|i
operator|=
name|batchEnd
expr_stmt|;
block|}
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|lastBatchCtx
argument_list|)
expr_stmt|;
comment|// All the batches failed, mark it a failed rpc.
comment|// Propagate the failure reason. We propagate the last batch's last failing rpc reason.
comment|// Can we do something better?
name|controller
operator|.
name|setFailed
argument_list|(
name|lastBatchCtx
operator|.
name|getLastFailedRpcReason
argument_list|()
argument_list|)
expr_stmt|;
name|done
operator|.
name|run
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|callMethod
parameter_list|(
name|Descriptors
operator|.
name|MethodDescriptor
name|method
parameter_list|,
name|RpcController
name|controller
parameter_list|,
name|Message
name|request
parameter_list|,
name|Message
name|responsePrototype
parameter_list|,
name|RpcCallback
argument_list|<
name|Message
argument_list|>
name|done
parameter_list|)
block|{
comment|// There is no reason to use any other implementation of RpcController.
name|Preconditions
operator|.
name|checkState
argument_list|(
name|controller
operator|instanceof
name|HBaseRpcController
argument_list|)
expr_stmt|;
comment|// To make the channel non-blocking, we run the actual doCalMethod() async. The call back is
comment|// called once the hedging finishes.
name|CompletableFuture
operator|.
name|runAsync
argument_list|(
parameter_list|()
lambda|->
name|doCallMethod
argument_list|(
name|method
argument_list|,
operator|(
name|HBaseRpcController
operator|)
name|controller
argument_list|,
name|request
argument_list|,
name|responsePrototype
argument_list|,
name|done
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

