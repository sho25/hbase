begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|DeserializationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|MD5Hash
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|DataInputBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ByteArrayHashKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|HashKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|JenkinsHash
import|;
end_import

begin_comment
comment|/**  * Information about a region. A region is a range of keys in the whole keyspace  * of a table, an identifier (a timestamp) for differentiating between subset  * ranges (after region split) and a replicaId for differentiating the instance  * for the same range and some status information about the region.  *  * The region has a unique name which consists of the following fields:  *<ul>  *<li> tableName   : The name of the table</li>  *<li> startKey    : The startKey for the region.</li>  *<li> regionId    : A timestamp when the region is created.</li>  *<li> replicaId   : An id starting from 0 to differentiate replicas of the  * same region range but hosted in separated servers. The same region range can  * be hosted in multiple locations.</li>  *<li> encodedName : An MD5 encoded string for the region name.</li>  *</ul>  *  *<br> Other than the fields in the region name, region info contains:  *<ul>  *<li> endKey      : the endKey for the region (exclusive)</li>  *<li> split       : Whether the region is split</li>  *<li> offline     : Whether the region is offline</li>  *</ul>  *  */
end_comment

begin_interface
annotation|@
name|InterfaceAudience
operator|.
name|Public
specifier|public
interface|interface
name|RegionInfo
block|{
comment|/**    * Separator used to demarcate the encodedName in a region name    * in the new format. See description on new format above.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
name|int
name|ENC_SEPARATOR
init|=
literal|'.'
decl_stmt|;
annotation|@
name|InterfaceAudience
operator|.
name|Private
name|int
name|MD5_HEX_LENGTH
init|=
literal|32
decl_stmt|;
annotation|@
name|InterfaceAudience
operator|.
name|Private
name|int
name|DEFAULT_REPLICA_ID
init|=
literal|0
decl_stmt|;
comment|/**    * to keep appended int's sorted in string format. Only allows 2 bytes    * to be sorted for replicaId.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
name|String
name|REPLICA_ID_FORMAT
init|=
literal|"%04X"
decl_stmt|;
annotation|@
name|InterfaceAudience
operator|.
name|Private
name|byte
name|REPLICA_ID_DELIMITER
init|=
operator|(
name|byte
operator|)
literal|'_'
decl_stmt|;
annotation|@
name|InterfaceAudience
operator|.
name|Private
name|String
name|INVALID_REGION_NAME_FORMAT_MESSAGE
init|=
literal|"Invalid regionName format"
decl_stmt|;
annotation|@
name|InterfaceAudience
operator|.
name|Private
name|Comparator
argument_list|<
name|RegionInfo
argument_list|>
name|COMPARATOR
init|=
parameter_list|(
name|RegionInfo
name|lhs
parameter_list|,
name|RegionInfo
name|rhs
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|rhs
operator|==
literal|null
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|// Are regions of same table?
name|int
name|result
init|=
name|lhs
operator|.
name|getTable
argument_list|()
operator|.
name|compareTo
argument_list|(
name|rhs
operator|.
name|getTable
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
comment|// Compare start keys.
name|result
operator|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|lhs
operator|.
name|getStartKey
argument_list|()
argument_list|,
name|rhs
operator|.
name|getStartKey
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
comment|// Compare end keys.
name|result
operator|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|lhs
operator|.
name|getEndKey
argument_list|()
argument_list|,
name|rhs
operator|.
name|getEndKey
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|lhs
operator|.
name|getStartKey
argument_list|()
operator|.
name|length
operator|!=
literal|0
operator|&&
name|lhs
operator|.
name|getEndKey
argument_list|()
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
comment|// this is last region
block|}
if|if
condition|(
name|rhs
operator|.
name|getStartKey
argument_list|()
operator|.
name|length
operator|!=
literal|0
operator|&&
name|rhs
operator|.
name|getEndKey
argument_list|()
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
comment|// o is the last region
block|}
return|return
name|result
return|;
block|}
comment|// regionId is usually milli timestamp -- this defines older stamps
comment|// to be "smaller" than newer stamps in sort order.
if|if
condition|(
name|lhs
operator|.
name|getRegionId
argument_list|()
operator|>
name|rhs
operator|.
name|getRegionId
argument_list|()
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|lhs
operator|.
name|getRegionId
argument_list|()
operator|<
name|rhs
operator|.
name|getRegionId
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|int
name|replicaDiff
init|=
name|lhs
operator|.
name|getReplicaId
argument_list|()
operator|-
name|rhs
operator|.
name|getReplicaId
argument_list|()
decl_stmt|;
if|if
condition|(
name|replicaDiff
operator|!=
literal|0
condition|)
return|return
name|replicaDiff
return|;
if|if
condition|(
name|lhs
operator|.
name|isOffline
argument_list|()
operator|==
name|rhs
operator|.
name|isOffline
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|lhs
operator|.
name|isOffline
argument_list|()
operator|==
literal|true
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
decl_stmt|;
comment|/**    * @return Return a short, printable name for this region    * (usually encoded name) for us logging.    */
name|String
name|getShortNameToLog
parameter_list|()
function_decl|;
comment|/**    * @return the regionId.    */
name|long
name|getRegionId
parameter_list|()
function_decl|;
comment|/**    * @return the regionName as an array of bytes.    * @see #getRegionNameAsString()    */
name|byte
index|[]
name|getRegionName
parameter_list|()
function_decl|;
comment|/**    * @return Region name as a String for use in logging, etc.    */
name|String
name|getRegionNameAsString
parameter_list|()
function_decl|;
comment|/**    * @return the encoded region name.    */
name|String
name|getEncodedName
parameter_list|()
function_decl|;
comment|/**    * @return the encoded region name as an array of bytes.    */
name|byte
index|[]
name|getEncodedNameAsBytes
parameter_list|()
function_decl|;
comment|/**    * @return the startKey.    */
name|byte
index|[]
name|getStartKey
parameter_list|()
function_decl|;
comment|/**    * @return the endKey.    */
name|byte
index|[]
name|getEndKey
parameter_list|()
function_decl|;
comment|/**    * @return current table name of the region    */
name|TableName
name|getTable
parameter_list|()
function_decl|;
comment|/**    * @return returns region replica id    */
name|int
name|getReplicaId
parameter_list|()
function_decl|;
comment|/**    * @return True if has been split and has daughters.    */
name|boolean
name|isSplit
parameter_list|()
function_decl|;
comment|/**    * @return True if this region is offline.    */
name|boolean
name|isOffline
parameter_list|()
function_decl|;
comment|/**    * @return True if this is a split parent region.    */
name|boolean
name|isSplitParent
parameter_list|()
function_decl|;
comment|/**    * @return true if this region is from hbase:meta.    */
name|boolean
name|isMetaTable
parameter_list|()
function_decl|;
comment|/**    * @return true if this region is from a system table.    */
name|boolean
name|isSystemTable
parameter_list|()
function_decl|;
comment|/**    * @return true if this region is a meta region.    */
name|boolean
name|isMetaRegion
parameter_list|()
function_decl|;
comment|/**    * @param rangeStartKey    * @param rangeEndKey    * @return true if the given inclusive range of rows is fully contained    * by this region. For example, if the region is foo,a,g and this is    * passed ["b","c"] or ["a","c"] it will return true, but if this is passed    * ["b","z"] it will return false.    * @throws IllegalArgumentException if the range passed is invalid (ie. end&lt; start)    */
name|boolean
name|containsRange
parameter_list|(
name|byte
index|[]
name|rangeStartKey
parameter_list|,
name|byte
index|[]
name|rangeEndKey
parameter_list|)
function_decl|;
comment|/**    * @param row    * @return true if the given row falls in this region.    */
name|boolean
name|containsRow
parameter_list|(
name|byte
index|[]
name|row
parameter_list|)
function_decl|;
comment|/**    * Does region name contain its encoded name?    * @param regionName region name    * @return boolean indicating if this a new format region    *         name which contains its encoded name.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|static
name|boolean
name|hasEncodedName
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
block|{
comment|// check if region name ends in ENC_SEPARATOR
return|return
operator|(
name|regionName
operator|.
name|length
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|regionName
index|[
name|regionName
operator|.
name|length
operator|-
literal|1
index|]
operator|==
name|RegionInfo
operator|.
name|ENC_SEPARATOR
operator|)
return|;
block|}
comment|/**    * @return the encodedName    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|static
name|String
name|encodeRegionName
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
block|{
name|String
name|encodedName
decl_stmt|;
if|if
condition|(
name|hasEncodedName
argument_list|(
name|regionName
argument_list|)
condition|)
block|{
comment|// region is in new format:
comment|//<tableName>,<startKey>,<regionIdTimeStamp>/encodedName/
name|encodedName
operator|=
name|Bytes
operator|.
name|toString
argument_list|(
name|regionName
argument_list|,
name|regionName
operator|.
name|length
operator|-
name|MD5_HEX_LENGTH
operator|-
literal|1
argument_list|,
name|MD5_HEX_LENGTH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// old format region name. First hbase:meta region also
comment|// use this format.EncodedName is the JenkinsHash value.
name|HashKey
argument_list|<
name|byte
index|[]
argument_list|>
name|key
init|=
operator|new
name|ByteArrayHashKey
argument_list|(
name|regionName
argument_list|,
literal|0
argument_list|,
name|regionName
operator|.
name|length
argument_list|)
decl_stmt|;
name|int
name|hashVal
init|=
name|Math
operator|.
name|abs
argument_list|(
name|JenkinsHash
operator|.
name|getInstance
argument_list|()
operator|.
name|hash
argument_list|(
name|key
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|encodedName
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|hashVal
argument_list|)
expr_stmt|;
block|}
return|return
name|encodedName
return|;
block|}
comment|/**    * @return Return a String of short, printable names for<code>hris</code>    * (usually encoded name) for us logging.    */
specifier|static
name|String
name|getShortNameToLog
parameter_list|(
name|RegionInfo
modifier|...
name|hris
parameter_list|)
block|{
return|return
name|getShortNameToLog
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|hris
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @return Return a String of short, printable names for<code>hris</code>    * (usually encoded name) for us logging.    */
specifier|static
name|String
name|getShortNameToLog
parameter_list|(
specifier|final
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|ris
parameter_list|)
block|{
return|return
name|ris
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|ri
lambda|->
name|ri
operator|.
name|getShortNameToLog
argument_list|()
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Gets the table name from the specified region name.    * @param regionName to extract the table name from    * @return Table name    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
comment|// This method should never be used. Its awful doing parse from bytes.
comment|// It is fallback in case we can't get the tablename any other way. Could try removing it.
comment|// Keeping it Audience Private so can remove at later date.
specifier|static
name|TableName
name|getTable
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
block|{
name|int
name|offset
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|regionName
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regionName
index|[
name|i
index|]
operator|==
name|HConstants
operator|.
name|DELIMITER
condition|)
block|{
name|offset
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|byte
index|[]
name|buff
init|=
operator|new
name|byte
index|[
name|offset
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|regionName
argument_list|,
literal|0
argument_list|,
name|buff
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|TableName
operator|.
name|valueOf
argument_list|(
name|buff
argument_list|)
return|;
block|}
comment|/**    * Gets the start key from the specified region name.    * @param regionName    * @return Start key.    * @throws java.io.IOException    */
specifier|static
name|byte
index|[]
name|getStartKey
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|parseRegionName
argument_list|(
name|regionName
argument_list|)
index|[
literal|1
index|]
return|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|static
name|boolean
name|isEncodedRegionName
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|parseRegionName
argument_list|(
name|regionName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
operator|.
name|contains
argument_list|(
name|INVALID_REGION_NAME_FORMAT_MESSAGE
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * @param bytes    * @return A deserialized {@link RegionInfo}    * or null if we failed deserialize or passed bytes null    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|static
name|RegionInfo
name|parseFromOrNull
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|)
block|{
if|if
condition|(
name|bytes
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|parseFromOrNull
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * @param bytes    * @param offset    * @param len    * @return A deserialized {@link RegionInfo} or null    *  if we failed deserialize or passed bytes null    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|static
name|RegionInfo
name|parseFromOrNull
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|bytes
operator|==
literal|null
operator|||
name|len
operator|<=
literal|0
condition|)
return|return
literal|null
return|;
try|try
block|{
return|return
name|parseFrom
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * @param bytes A pb RegionInfo serialized with a pb magic prefix.    * @return A deserialized {@link RegionInfo}    * @throws DeserializationException    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|static
name|RegionInfo
name|parseFrom
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|)
throws|throws
name|DeserializationException
block|{
if|if
condition|(
name|bytes
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|parseFrom
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * @param bytes A pb RegionInfo serialized with a pb magic prefix.    * @param offset starting point in the byte array    * @param len length to read on the byte array    * @return A deserialized {@link RegionInfo}    * @throws DeserializationException    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|static
name|RegionInfo
name|parseFrom
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|DeserializationException
block|{
if|if
condition|(
name|ProtobufUtil
operator|.
name|isPBMagicPrefix
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|int
name|pblen
init|=
name|ProtobufUtil
operator|.
name|lengthOfPBMagic
argument_list|()
decl_stmt|;
try|try
block|{
name|HBaseProtos
operator|.
name|RegionInfo
operator|.
name|Builder
name|builder
init|=
name|HBaseProtos
operator|.
name|RegionInfo
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|ProtobufUtil
operator|.
name|mergeFrom
argument_list|(
name|builder
argument_list|,
name|bytes
argument_list|,
name|pblen
operator|+
name|offset
argument_list|,
name|len
operator|-
name|pblen
argument_list|)
expr_stmt|;
name|HBaseProtos
operator|.
name|RegionInfo
name|ri
init|=
name|builder
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|ProtobufUtil
operator|.
name|toRegionInfo
argument_list|(
name|ri
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DeserializationException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|DeserializationException
argument_list|(
literal|"PB encoded RegionInfo expected"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Check whether two regions are adjacent    * @param regionA    * @param regionB    * @return true if two regions are adjacent    */
specifier|static
name|boolean
name|areAdjacent
parameter_list|(
name|RegionInfo
name|regionA
parameter_list|,
name|RegionInfo
name|regionB
parameter_list|)
block|{
if|if
condition|(
name|regionA
operator|==
literal|null
operator|||
name|regionB
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Can't check whether adjacent for null region"
argument_list|)
throw|;
block|}
name|RegionInfo
name|a
init|=
name|regionA
decl_stmt|;
name|RegionInfo
name|b
init|=
name|regionB
decl_stmt|;
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|a
operator|.
name|getStartKey
argument_list|()
argument_list|,
name|b
operator|.
name|getStartKey
argument_list|()
argument_list|)
operator|>
literal|0
condition|)
block|{
name|a
operator|=
name|regionB
expr_stmt|;
name|b
operator|=
name|regionA
expr_stmt|;
block|}
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|a
operator|.
name|getEndKey
argument_list|()
argument_list|,
name|b
operator|.
name|getStartKey
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * @param ri    * @return This instance serialized as protobuf w/ a magic pb prefix.    * @see #parseFrom(byte[])    */
specifier|static
name|byte
index|[]
name|toByteArray
parameter_list|(
name|RegionInfo
name|ri
parameter_list|)
block|{
name|byte
index|[]
name|bytes
init|=
name|ProtobufUtil
operator|.
name|toProtoRegionInfo
argument_list|(
name|ri
argument_list|)
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
return|return
name|ProtobufUtil
operator|.
name|prependPBMagic
argument_list|(
name|bytes
argument_list|)
return|;
block|}
comment|/**    * Use logging.    * @param encodedRegionName The encoded regionname.    * @return<code>hbase:meta</code> if passed<code>1028785192</code> else returns    *<code>encodedRegionName</code>    */
specifier|static
name|String
name|prettyPrint
parameter_list|(
specifier|final
name|String
name|encodedRegionName
parameter_list|)
block|{
if|if
condition|(
name|encodedRegionName
operator|.
name|equals
argument_list|(
literal|"1028785192"
argument_list|)
condition|)
block|{
return|return
name|encodedRegionName
operator|+
literal|"/hbase:meta"
return|;
block|}
return|return
name|encodedRegionName
return|;
block|}
comment|/**    * Make a region name of passed parameters.    * @param tableName    * @param startKey Can be null    * @param regionid Region id (Usually timestamp from when region was created).    * @param newFormat should we create the region name in the new format    *                  (such that it contains its encoded name?).    * @return Region name made of passed tableName, startKey and id    */
specifier|static
name|byte
index|[]
name|createRegionName
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|long
name|regionid
parameter_list|,
name|boolean
name|newFormat
parameter_list|)
block|{
return|return
name|createRegionName
argument_list|(
name|tableName
argument_list|,
name|startKey
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|regionid
argument_list|)
argument_list|,
name|newFormat
argument_list|)
return|;
block|}
comment|/**    * Make a region name of passed parameters.    * @param tableName    * @param startKey Can be null    * @param id Region id (Usually timestamp from when region was created).    * @param newFormat should we create the region name in the new format    *                  (such that it contains its encoded name?).    * @return Region name made of passed tableName, startKey and id    */
specifier|static
name|byte
index|[]
name|createRegionName
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|String
name|id
parameter_list|,
name|boolean
name|newFormat
parameter_list|)
block|{
return|return
name|createRegionName
argument_list|(
name|tableName
argument_list|,
name|startKey
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|id
argument_list|)
argument_list|,
name|newFormat
argument_list|)
return|;
block|}
comment|/**    * Make a region name of passed parameters.    * @param tableName    * @param startKey Can be null    * @param regionid Region id (Usually timestamp from when region was created).    * @param replicaId    * @param newFormat should we create the region name in the new format    *                  (such that it contains its encoded name?).    * @return Region name made of passed tableName, startKey, id and replicaId    */
specifier|static
name|byte
index|[]
name|createRegionName
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|long
name|regionid
parameter_list|,
name|int
name|replicaId
parameter_list|,
name|boolean
name|newFormat
parameter_list|)
block|{
return|return
name|createRegionName
argument_list|(
name|tableName
argument_list|,
name|startKey
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|Long
operator|.
name|toString
argument_list|(
name|regionid
argument_list|)
argument_list|)
argument_list|,
name|replicaId
argument_list|,
name|newFormat
argument_list|)
return|;
block|}
comment|/**    * Make a region name of passed parameters.    * @param tableName    * @param startKey Can be null    * @param id Region id (Usually timestamp from when region was created).    * @param newFormat should we create the region name in the new format    *                  (such that it contains its encoded name?).    * @return Region name made of passed tableName, startKey and id    */
specifier|static
name|byte
index|[]
name|createRegionName
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|byte
index|[]
name|id
parameter_list|,
name|boolean
name|newFormat
parameter_list|)
block|{
return|return
name|createRegionName
argument_list|(
name|tableName
argument_list|,
name|startKey
argument_list|,
name|id
argument_list|,
name|DEFAULT_REPLICA_ID
argument_list|,
name|newFormat
argument_list|)
return|;
block|}
comment|/**    * Make a region name of passed parameters.    * @param tableName    * @param startKey Can be null    * @param id Region id (Usually timestamp from when region was created).    * @param replicaId    * @param newFormat should we create the region name in the new format    * @return Region name made of passed tableName, startKey, id and replicaId    */
specifier|static
name|byte
index|[]
name|createRegionName
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|byte
index|[]
name|id
parameter_list|,
specifier|final
name|int
name|replicaId
parameter_list|,
name|boolean
name|newFormat
parameter_list|)
block|{
name|int
name|len
init|=
name|tableName
operator|.
name|getName
argument_list|()
operator|.
name|length
operator|+
literal|2
operator|+
name|id
operator|.
name|length
operator|+
operator|(
name|startKey
operator|==
literal|null
condition|?
literal|0
else|:
name|startKey
operator|.
name|length
operator|)
decl_stmt|;
if|if
condition|(
name|newFormat
condition|)
block|{
name|len
operator|+=
name|MD5_HEX_LENGTH
operator|+
literal|2
expr_stmt|;
block|}
name|byte
index|[]
name|replicaIdBytes
init|=
literal|null
decl_stmt|;
comment|// Special casing: replicaId is only appended if replicaId is greater than
comment|// 0. This is because all regions in meta would have to be migrated to the new
comment|// name otherwise
if|if
condition|(
name|replicaId
operator|>
literal|0
condition|)
block|{
comment|// use string representation for replica id
name|replicaIdBytes
operator|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|REPLICA_ID_FORMAT
argument_list|,
name|replicaId
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|1
operator|+
name|replicaIdBytes
operator|.
name|length
expr_stmt|;
block|}
name|byte
index|[]
name|b
init|=
operator|new
name|byte
index|[
name|len
index|]
decl_stmt|;
name|int
name|offset
init|=
name|tableName
operator|.
name|getName
argument_list|()
operator|.
name|length
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|tableName
operator|.
name|getName
argument_list|()
argument_list|,
literal|0
argument_list|,
name|b
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|b
index|[
name|offset
operator|++
index|]
operator|=
name|HConstants
operator|.
name|DELIMITER
expr_stmt|;
if|if
condition|(
name|startKey
operator|!=
literal|null
operator|&&
name|startKey
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|startKey
argument_list|,
literal|0
argument_list|,
name|b
argument_list|,
name|offset
argument_list|,
name|startKey
operator|.
name|length
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|startKey
operator|.
name|length
expr_stmt|;
block|}
name|b
index|[
name|offset
operator|++
index|]
operator|=
name|HConstants
operator|.
name|DELIMITER
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|id
argument_list|,
literal|0
argument_list|,
name|b
argument_list|,
name|offset
argument_list|,
name|id
operator|.
name|length
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|id
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|replicaIdBytes
operator|!=
literal|null
condition|)
block|{
name|b
index|[
name|offset
operator|++
index|]
operator|=
name|REPLICA_ID_DELIMITER
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|replicaIdBytes
argument_list|,
literal|0
argument_list|,
name|b
argument_list|,
name|offset
argument_list|,
name|replicaIdBytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|replicaIdBytes
operator|.
name|length
expr_stmt|;
block|}
if|if
condition|(
name|newFormat
condition|)
block|{
comment|//
comment|// Encoded name should be built into the region name.
comment|//
comment|// Use the region name thus far (namely,<tablename>,<startKey>,<id>_<replicaId>)
comment|// to compute a MD5 hash to be used as the encoded name, and append
comment|// it to the byte buffer.
comment|//
name|String
name|md5Hash
init|=
name|MD5Hash
operator|.
name|getMD5AsHex
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|byte
index|[]
name|md5HashBytes
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|md5Hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|md5HashBytes
operator|.
name|length
operator|!=
name|MD5_HEX_LENGTH
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"MD5-hash length mismatch: Expected="
operator|+
name|MD5_HEX_LENGTH
operator|+
literal|"; Got="
operator|+
name|md5HashBytes
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|// now append the bytes '.<encodedName>.' to the end
name|b
index|[
name|offset
operator|++
index|]
operator|=
name|ENC_SEPARATOR
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|md5HashBytes
argument_list|,
literal|0
argument_list|,
name|b
argument_list|,
name|offset
argument_list|,
name|MD5_HEX_LENGTH
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|MD5_HEX_LENGTH
expr_stmt|;
name|b
index|[
name|offset
operator|++
index|]
operator|=
name|ENC_SEPARATOR
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
comment|/**    * Separate elements of a regionName.    * @param regionName    * @return Array of byte[] containing tableName, startKey and id    * @throws IOException    */
specifier|static
name|byte
index|[]
index|[]
name|parseRegionName
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Region name is of the format:
comment|// tablename,startkey,regionIdTimestamp[_replicaId][.encodedName.]
comment|// startkey can contain the delimiter (',') so we parse from the start and end
comment|// parse from start
name|int
name|offset
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|regionName
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regionName
index|[
name|i
index|]
operator|==
name|HConstants
operator|.
name|DELIMITER
condition|)
block|{
name|offset
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|offset
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|INVALID_REGION_NAME_FORMAT_MESSAGE
operator|+
literal|": "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionName
argument_list|)
argument_list|)
throw|;
block|}
name|byte
index|[]
name|tableName
init|=
operator|new
name|byte
index|[
name|offset
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|regionName
argument_list|,
literal|0
argument_list|,
name|tableName
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
name|int
name|endOffset
init|=
name|regionName
operator|.
name|length
decl_stmt|;
comment|// check whether regionName contains encodedName
if|if
condition|(
name|regionName
operator|.
name|length
operator|>
name|MD5_HEX_LENGTH
operator|+
literal|2
operator|&&
name|regionName
index|[
name|regionName
operator|.
name|length
operator|-
literal|1
index|]
operator|==
name|ENC_SEPARATOR
operator|&&
name|regionName
index|[
name|regionName
operator|.
name|length
operator|-
name|MD5_HEX_LENGTH
operator|-
literal|2
index|]
operator|==
name|ENC_SEPARATOR
condition|)
block|{
name|endOffset
operator|=
name|endOffset
operator|-
name|MD5_HEX_LENGTH
operator|-
literal|2
expr_stmt|;
block|}
comment|// parse from end
name|byte
index|[]
name|replicaId
init|=
literal|null
decl_stmt|;
name|int
name|idEndOffset
init|=
name|endOffset
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|endOffset
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|regionName
index|[
name|i
index|]
operator|==
name|REPLICA_ID_DELIMITER
condition|)
block|{
comment|//replicaId may or may not be present
name|replicaId
operator|=
operator|new
name|byte
index|[
name|endOffset
operator|-
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|regionName
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|replicaId
argument_list|,
literal|0
argument_list|,
name|endOffset
operator|-
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|idEndOffset
operator|=
name|i
expr_stmt|;
comment|// do not break, continue to search for id
block|}
if|if
condition|(
name|regionName
index|[
name|i
index|]
operator|==
name|HConstants
operator|.
name|DELIMITER
condition|)
block|{
name|offset
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|offset
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|INVALID_REGION_NAME_FORMAT_MESSAGE
operator|+
literal|": "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionName
argument_list|)
argument_list|)
throw|;
block|}
name|byte
index|[]
name|startKey
init|=
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
decl_stmt|;
if|if
condition|(
name|offset
operator|!=
name|tableName
operator|.
name|length
operator|+
literal|1
condition|)
block|{
name|startKey
operator|=
operator|new
name|byte
index|[
name|offset
operator|-
name|tableName
operator|.
name|length
operator|-
literal|1
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|regionName
argument_list|,
name|tableName
operator|.
name|length
operator|+
literal|1
argument_list|,
name|startKey
argument_list|,
literal|0
argument_list|,
name|offset
operator|-
name|tableName
operator|.
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|id
init|=
operator|new
name|byte
index|[
name|idEndOffset
operator|-
name|offset
operator|-
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|regionName
argument_list|,
name|offset
operator|+
literal|1
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
name|idEndOffset
operator|-
name|offset
operator|-
literal|1
argument_list|)
expr_stmt|;
name|byte
index|[]
index|[]
name|elements
init|=
operator|new
name|byte
index|[
name|replicaId
operator|==
literal|null
condition|?
literal|3
else|:
literal|4
index|]
index|[]
decl_stmt|;
name|elements
index|[
literal|0
index|]
operator|=
name|tableName
expr_stmt|;
name|elements
index|[
literal|1
index|]
operator|=
name|startKey
expr_stmt|;
name|elements
index|[
literal|2
index|]
operator|=
name|id
expr_stmt|;
if|if
condition|(
name|replicaId
operator|!=
literal|null
condition|)
block|{
name|elements
index|[
literal|3
index|]
operator|=
name|replicaId
expr_stmt|;
block|}
return|return
name|elements
return|;
block|}
comment|/**    * Serializes given RegionInfo's as a byte array. Use this instead of    * {@link RegionInfo#toByteArray(RegionInfo)} when    * writing to a stream and you want to use the pb mergeDelimitedFrom (w/o the delimiter, pb reads    * to EOF which may not be what you want). {@link #parseDelimitedFrom(byte[], int, int)} can    * be used to read back the instances.    * @param infos RegionInfo objects to serialize    * @return This instance serialized as a delimited protobuf w/ a magic pb prefix.    * @throws IOException    */
specifier|static
name|byte
index|[]
name|toDelimitedByteArray
parameter_list|(
name|RegionInfo
modifier|...
name|infos
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|infos
operator|.
name|length
index|]
index|[]
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|infos
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|bytes
index|[
name|i
index|]
operator|=
name|toDelimitedByteArray
argument_list|(
name|infos
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|size
operator|+=
name|bytes
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
block|}
name|byte
index|[]
name|result
init|=
operator|new
name|byte
index|[
name|size
index|]
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|b
range|:
name|bytes
control|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|result
argument_list|,
name|offset
argument_list|,
name|b
operator|.
name|length
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|b
operator|.
name|length
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Use this instead of {@link RegionInfo#toByteArray(RegionInfo)} when writing to a stream and you want to use    * the pb mergeDelimitedFrom (w/o the delimiter, pb reads to EOF which may not be what you want).    * @param ri    * @return This instance serialized as a delimied protobuf w/ a magic pb prefix.    * @throws IOException    */
specifier|static
name|byte
index|[]
name|toDelimitedByteArray
parameter_list|(
name|RegionInfo
name|ri
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|ProtobufUtil
operator|.
name|toDelimitedByteArray
argument_list|(
name|ProtobufUtil
operator|.
name|toProtoRegionInfo
argument_list|(
name|ri
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Parses an RegionInfo instance from the passed in stream.    * Presumes the RegionInfo was serialized to the stream with    * {@link #toDelimitedByteArray(RegionInfo)}.    * @param in    * @return An instance of RegionInfo.    * @throws IOException    */
specifier|static
name|RegionInfo
name|parseFrom
parameter_list|(
specifier|final
name|DataInputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
comment|// I need to be able to move back in the stream if this is not a pb
comment|// serialization so I can do the Writable decoding instead.
name|int
name|pblen
init|=
name|ProtobufUtil
operator|.
name|lengthOfPBMagic
argument_list|()
decl_stmt|;
name|byte
index|[]
name|pbuf
init|=
operator|new
name|byte
index|[
name|pblen
index|]
decl_stmt|;
if|if
condition|(
name|in
operator|.
name|markSupported
argument_list|()
condition|)
block|{
comment|//read it with mark()
name|in
operator|.
name|mark
argument_list|(
name|pblen
argument_list|)
expr_stmt|;
block|}
comment|//assumption: if Writable serialization, it should be longer than pblen.
name|int
name|read
init|=
name|in
operator|.
name|read
argument_list|(
name|pbuf
argument_list|)
decl_stmt|;
if|if
condition|(
name|read
operator|!=
name|pblen
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"read="
operator|+
name|read
operator|+
literal|", wanted="
operator|+
name|pblen
argument_list|)
throw|;
if|if
condition|(
name|ProtobufUtil
operator|.
name|isPBMagicPrefix
argument_list|(
name|pbuf
argument_list|)
condition|)
block|{
return|return
name|ProtobufUtil
operator|.
name|toRegionInfo
argument_list|(
name|HBaseProtos
operator|.
name|RegionInfo
operator|.
name|parseDelimitedFrom
argument_list|(
name|in
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"PB encoded RegionInfo expected"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Parses all the RegionInfo instances from the passed in stream until EOF. Presumes the    * RegionInfo's were serialized to the stream with oDelimitedByteArray()    * @param bytes serialized bytes    * @param offset the start offset into the byte[] buffer    * @param length how far we should read into the byte[] buffer    * @return All the RegionInfos that are in the byte array. Keeps reading till we hit the end.    * @throws IOException    */
specifier|static
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|parseDelimitedFrom
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|bytes
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Can't build an object with empty bytes array"
argument_list|)
throw|;
block|}
name|DataInputBuffer
name|in
init|=
operator|new
name|DataInputBuffer
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|ris
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
try|try
block|{
name|in
operator|.
name|reset
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
while|while
condition|(
name|in
operator|.
name|available
argument_list|()
operator|>
literal|0
condition|)
block|{
name|RegionInfo
name|ri
init|=
name|parseFrom
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|ris
operator|.
name|add
argument_list|(
name|ri
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|ris
return|;
block|}
block|}
end_interface

end_unit

