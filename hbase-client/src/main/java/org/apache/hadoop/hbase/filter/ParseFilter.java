begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|CompareFilter
operator|.
name|CompareOp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CharacterCodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EmptyStackException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_comment
comment|/**  * This class allows a user to specify a filter via a string  * The string is parsed using the methods of this class and  * a filter object is constructed. This filter object is then wrapped  * in a scanner object which is then returned  *<p>  * This class addresses the HBASE-4168 JIRA. More documentation on this  * Filter Language can be found at: https://issues.apache.org/jira/browse/HBASE-4176  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Stable
specifier|public
class|class
name|ParseFilter
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ParseFilter
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|HashMap
argument_list|<
name|ByteBuffer
argument_list|,
name|Integer
argument_list|>
name|operatorPrecedenceHashMap
decl_stmt|;
specifier|private
specifier|static
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|filterHashMap
decl_stmt|;
static|static
block|{
comment|// Registers all the filter supported by the Filter Language
name|filterHashMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|filterHashMap
operator|.
name|put
argument_list|(
literal|"KeyOnlyFilter"
argument_list|,
name|ParseConstants
operator|.
name|FILTER_PACKAGE
operator|+
literal|"."
operator|+
literal|"KeyOnlyFilter"
argument_list|)
expr_stmt|;
name|filterHashMap
operator|.
name|put
argument_list|(
literal|"FirstKeyOnlyFilter"
argument_list|,
name|ParseConstants
operator|.
name|FILTER_PACKAGE
operator|+
literal|"."
operator|+
literal|"FirstKeyOnlyFilter"
argument_list|)
expr_stmt|;
name|filterHashMap
operator|.
name|put
argument_list|(
literal|"PrefixFilter"
argument_list|,
name|ParseConstants
operator|.
name|FILTER_PACKAGE
operator|+
literal|"."
operator|+
literal|"PrefixFilter"
argument_list|)
expr_stmt|;
name|filterHashMap
operator|.
name|put
argument_list|(
literal|"ColumnPrefixFilter"
argument_list|,
name|ParseConstants
operator|.
name|FILTER_PACKAGE
operator|+
literal|"."
operator|+
literal|"ColumnPrefixFilter"
argument_list|)
expr_stmt|;
name|filterHashMap
operator|.
name|put
argument_list|(
literal|"MultipleColumnPrefixFilter"
argument_list|,
name|ParseConstants
operator|.
name|FILTER_PACKAGE
operator|+
literal|"."
operator|+
literal|"MultipleColumnPrefixFilter"
argument_list|)
expr_stmt|;
name|filterHashMap
operator|.
name|put
argument_list|(
literal|"ColumnCountGetFilter"
argument_list|,
name|ParseConstants
operator|.
name|FILTER_PACKAGE
operator|+
literal|"."
operator|+
literal|"ColumnCountGetFilter"
argument_list|)
expr_stmt|;
name|filterHashMap
operator|.
name|put
argument_list|(
literal|"PageFilter"
argument_list|,
name|ParseConstants
operator|.
name|FILTER_PACKAGE
operator|+
literal|"."
operator|+
literal|"PageFilter"
argument_list|)
expr_stmt|;
name|filterHashMap
operator|.
name|put
argument_list|(
literal|"ColumnPaginationFilter"
argument_list|,
name|ParseConstants
operator|.
name|FILTER_PACKAGE
operator|+
literal|"."
operator|+
literal|"ColumnPaginationFilter"
argument_list|)
expr_stmt|;
name|filterHashMap
operator|.
name|put
argument_list|(
literal|"InclusiveStopFilter"
argument_list|,
name|ParseConstants
operator|.
name|FILTER_PACKAGE
operator|+
literal|"."
operator|+
literal|"InclusiveStopFilter"
argument_list|)
expr_stmt|;
name|filterHashMap
operator|.
name|put
argument_list|(
literal|"TimestampsFilter"
argument_list|,
name|ParseConstants
operator|.
name|FILTER_PACKAGE
operator|+
literal|"."
operator|+
literal|"TimestampsFilter"
argument_list|)
expr_stmt|;
name|filterHashMap
operator|.
name|put
argument_list|(
literal|"RowFilter"
argument_list|,
name|ParseConstants
operator|.
name|FILTER_PACKAGE
operator|+
literal|"."
operator|+
literal|"RowFilter"
argument_list|)
expr_stmt|;
name|filterHashMap
operator|.
name|put
argument_list|(
literal|"FamilyFilter"
argument_list|,
name|ParseConstants
operator|.
name|FILTER_PACKAGE
operator|+
literal|"."
operator|+
literal|"FamilyFilter"
argument_list|)
expr_stmt|;
name|filterHashMap
operator|.
name|put
argument_list|(
literal|"QualifierFilter"
argument_list|,
name|ParseConstants
operator|.
name|FILTER_PACKAGE
operator|+
literal|"."
operator|+
literal|"QualifierFilter"
argument_list|)
expr_stmt|;
name|filterHashMap
operator|.
name|put
argument_list|(
literal|"ValueFilter"
argument_list|,
name|ParseConstants
operator|.
name|FILTER_PACKAGE
operator|+
literal|"."
operator|+
literal|"ValueFilter"
argument_list|)
expr_stmt|;
name|filterHashMap
operator|.
name|put
argument_list|(
literal|"ColumnRangeFilter"
argument_list|,
name|ParseConstants
operator|.
name|FILTER_PACKAGE
operator|+
literal|"."
operator|+
literal|"ColumnRangeFilter"
argument_list|)
expr_stmt|;
name|filterHashMap
operator|.
name|put
argument_list|(
literal|"SingleColumnValueFilter"
argument_list|,
name|ParseConstants
operator|.
name|FILTER_PACKAGE
operator|+
literal|"."
operator|+
literal|"SingleColumnValueFilter"
argument_list|)
expr_stmt|;
name|filterHashMap
operator|.
name|put
argument_list|(
literal|"SingleColumnValueExcludeFilter"
argument_list|,
name|ParseConstants
operator|.
name|FILTER_PACKAGE
operator|+
literal|"."
operator|+
literal|"SingleColumnValueExcludeFilter"
argument_list|)
expr_stmt|;
name|filterHashMap
operator|.
name|put
argument_list|(
literal|"DependentColumnFilter"
argument_list|,
name|ParseConstants
operator|.
name|FILTER_PACKAGE
operator|+
literal|"."
operator|+
literal|"DependentColumnFilter"
argument_list|)
expr_stmt|;
comment|// Creates the operatorPrecedenceHashMap
name|operatorPrecedenceHashMap
operator|=
operator|new
name|HashMap
argument_list|<
name|ByteBuffer
argument_list|,
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
name|operatorPrecedenceHashMap
operator|.
name|put
argument_list|(
name|ParseConstants
operator|.
name|SKIP_BUFFER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|operatorPrecedenceHashMap
operator|.
name|put
argument_list|(
name|ParseConstants
operator|.
name|WHILE_BUFFER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|operatorPrecedenceHashMap
operator|.
name|put
argument_list|(
name|ParseConstants
operator|.
name|AND_BUFFER
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|operatorPrecedenceHashMap
operator|.
name|put
argument_list|(
name|ParseConstants
operator|.
name|OR_BUFFER
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/**    * Parses the filterString and constructs a filter using it    *<p>    * @param filterString filter string given by the user    * @return filter object we constructed    */
specifier|public
name|Filter
name|parseFilterString
parameter_list|(
name|String
name|filterString
parameter_list|)
throws|throws
name|CharacterCodingException
block|{
return|return
name|parseFilterString
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|filterString
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Parses the filterString and constructs a filter using it    *<p>    * @param filterStringAsByteArray filter string given by the user    * @return filter object we constructed    */
specifier|public
name|Filter
name|parseFilterString
parameter_list|(
name|byte
index|[]
name|filterStringAsByteArray
parameter_list|)
throws|throws
name|CharacterCodingException
block|{
comment|// stack for the operators and parenthesis
name|Stack
argument_list|<
name|ByteBuffer
argument_list|>
name|operatorStack
init|=
operator|new
name|Stack
argument_list|<
name|ByteBuffer
argument_list|>
argument_list|()
decl_stmt|;
comment|// stack for the filter objects
name|Stack
argument_list|<
name|Filter
argument_list|>
name|filterStack
init|=
operator|new
name|Stack
argument_list|<
name|Filter
argument_list|>
argument_list|()
decl_stmt|;
name|Filter
name|filter
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|filterStringAsByteArray
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|filterStringAsByteArray
index|[
name|i
index|]
operator|==
name|ParseConstants
operator|.
name|LPAREN
condition|)
block|{
comment|// LPAREN found
name|operatorStack
operator|.
name|push
argument_list|(
name|ParseConstants
operator|.
name|LPAREN_BUFFER
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|filterStringAsByteArray
index|[
name|i
index|]
operator|==
name|ParseConstants
operator|.
name|WHITESPACE
operator|||
name|filterStringAsByteArray
index|[
name|i
index|]
operator|==
name|ParseConstants
operator|.
name|TAB
condition|)
block|{
comment|// WHITESPACE or TAB found
continue|continue;
block|}
elseif|else
if|if
condition|(
name|checkForOr
argument_list|(
name|filterStringAsByteArray
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|// OR found
name|i
operator|+=
name|ParseConstants
operator|.
name|OR_ARRAY
operator|.
name|length
operator|-
literal|1
expr_stmt|;
name|reduce
argument_list|(
name|operatorStack
argument_list|,
name|filterStack
argument_list|,
name|ParseConstants
operator|.
name|OR_BUFFER
argument_list|)
expr_stmt|;
name|operatorStack
operator|.
name|push
argument_list|(
name|ParseConstants
operator|.
name|OR_BUFFER
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|checkForAnd
argument_list|(
name|filterStringAsByteArray
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|// AND found
name|i
operator|+=
name|ParseConstants
operator|.
name|AND_ARRAY
operator|.
name|length
operator|-
literal|1
expr_stmt|;
name|reduce
argument_list|(
name|operatorStack
argument_list|,
name|filterStack
argument_list|,
name|ParseConstants
operator|.
name|AND_BUFFER
argument_list|)
expr_stmt|;
name|operatorStack
operator|.
name|push
argument_list|(
name|ParseConstants
operator|.
name|AND_BUFFER
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|checkForSkip
argument_list|(
name|filterStringAsByteArray
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|// SKIP found
name|i
operator|+=
name|ParseConstants
operator|.
name|SKIP_ARRAY
operator|.
name|length
operator|-
literal|1
expr_stmt|;
name|reduce
argument_list|(
name|operatorStack
argument_list|,
name|filterStack
argument_list|,
name|ParseConstants
operator|.
name|SKIP_BUFFER
argument_list|)
expr_stmt|;
name|operatorStack
operator|.
name|push
argument_list|(
name|ParseConstants
operator|.
name|SKIP_BUFFER
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|checkForWhile
argument_list|(
name|filterStringAsByteArray
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|// WHILE found
name|i
operator|+=
name|ParseConstants
operator|.
name|WHILE_ARRAY
operator|.
name|length
operator|-
literal|1
expr_stmt|;
name|reduce
argument_list|(
name|operatorStack
argument_list|,
name|filterStack
argument_list|,
name|ParseConstants
operator|.
name|WHILE_BUFFER
argument_list|)
expr_stmt|;
name|operatorStack
operator|.
name|push
argument_list|(
name|ParseConstants
operator|.
name|WHILE_BUFFER
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|filterStringAsByteArray
index|[
name|i
index|]
operator|==
name|ParseConstants
operator|.
name|RPAREN
condition|)
block|{
comment|// RPAREN found
if|if
condition|(
name|operatorStack
operator|.
name|empty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Mismatched parenthesis"
argument_list|)
throw|;
block|}
name|ByteBuffer
name|argumentOnTopOfStack
init|=
name|operatorStack
operator|.
name|peek
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|argumentOnTopOfStack
operator|.
name|equals
argument_list|(
name|ParseConstants
operator|.
name|LPAREN_BUFFER
argument_list|)
operator|)
condition|)
block|{
name|filterStack
operator|.
name|push
argument_list|(
name|popArguments
argument_list|(
name|operatorStack
argument_list|,
name|filterStack
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|operatorStack
operator|.
name|empty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Mismatched parenthesis"
argument_list|)
throw|;
block|}
name|argumentOnTopOfStack
operator|=
name|operatorStack
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// SimpleFilterExpression found
name|byte
index|[]
name|filterSimpleExpression
init|=
name|extractFilterSimpleExpression
argument_list|(
name|filterStringAsByteArray
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|i
operator|+=
operator|(
name|filterSimpleExpression
operator|.
name|length
operator|-
literal|1
operator|)
expr_stmt|;
name|filter
operator|=
name|parseSimpleFilterExpression
argument_list|(
name|filterSimpleExpression
argument_list|)
expr_stmt|;
name|filterStack
operator|.
name|push
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Finished parsing filterString
while|while
condition|(
operator|!
name|operatorStack
operator|.
name|empty
argument_list|()
condition|)
block|{
name|filterStack
operator|.
name|push
argument_list|(
name|popArguments
argument_list|(
name|operatorStack
argument_list|,
name|filterStack
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|filter
operator|=
name|filterStack
operator|.
name|pop
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|filterStack
operator|.
name|empty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Incorrect Filter String"
argument_list|)
throw|;
block|}
return|return
name|filter
return|;
block|}
comment|/**  * Extracts a simple filter expression from the filter string given by the user  *<p>  * A simpleFilterExpression is of the form: FilterName('arg', 'arg', 'arg')  * The user given filter string can have many simpleFilterExpressions combined  * using operators.  *<p>  * This function extracts a simpleFilterExpression from the  * larger filterString given the start offset of the simpler expression  *<p>  * @param filterStringAsByteArray filter string given by the user  * @param filterExpressionStartOffset start index of the simple filter expression  * @return byte array containing the simple filter expression  */
specifier|public
name|byte
index|[]
name|extractFilterSimpleExpression
parameter_list|(
name|byte
index|[]
name|filterStringAsByteArray
parameter_list|,
name|int
name|filterExpressionStartOffset
parameter_list|)
throws|throws
name|CharacterCodingException
block|{
name|int
name|quoteCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|filterExpressionStartOffset
init|;
name|i
operator|<
name|filterStringAsByteArray
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|filterStringAsByteArray
index|[
name|i
index|]
operator|==
name|ParseConstants
operator|.
name|SINGLE_QUOTE
condition|)
block|{
if|if
condition|(
name|isQuoteUnescaped
argument_list|(
name|filterStringAsByteArray
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|quoteCount
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|// To skip the next quote that has been escaped
name|i
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|filterStringAsByteArray
index|[
name|i
index|]
operator|==
name|ParseConstants
operator|.
name|RPAREN
operator|&&
operator|(
name|quoteCount
operator|%
literal|2
operator|)
operator|==
literal|0
condition|)
block|{
name|byte
index|[]
name|filterSimpleExpression
init|=
operator|new
name|byte
index|[
name|i
operator|-
name|filterExpressionStartOffset
operator|+
literal|1
index|]
decl_stmt|;
name|Bytes
operator|.
name|putBytes
argument_list|(
name|filterSimpleExpression
argument_list|,
literal|0
argument_list|,
name|filterStringAsByteArray
argument_list|,
name|filterExpressionStartOffset
argument_list|,
name|i
operator|-
name|filterExpressionStartOffset
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|filterSimpleExpression
return|;
block|}
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Incorrect Filter String"
argument_list|)
throw|;
block|}
comment|/**  * Constructs a filter object given a simple filter expression  *<p>  * @param filterStringAsByteArray filter string given by the user  * @return filter object we constructed  */
specifier|public
name|Filter
name|parseSimpleFilterExpression
parameter_list|(
name|byte
index|[]
name|filterStringAsByteArray
parameter_list|)
throws|throws
name|CharacterCodingException
block|{
name|String
name|filterName
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|getFilterName
argument_list|(
name|filterStringAsByteArray
argument_list|)
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
name|filterArguments
init|=
name|getFilterArguments
argument_list|(
name|filterStringAsByteArray
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|filterHashMap
operator|.
name|containsKey
argument_list|(
name|filterName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Filter Name "
operator|+
name|filterName
operator|+
literal|" not supported"
argument_list|)
throw|;
block|}
try|try
block|{
name|filterName
operator|=
name|filterHashMap
operator|.
name|get
argument_list|(
name|filterName
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|c
init|=
name|Class
operator|.
name|forName
argument_list|(
name|filterName
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|argTypes
init|=
operator|new
name|Class
index|[]
block|{
name|ArrayList
operator|.
name|class
block|}
decl_stmt|;
name|Method
name|m
init|=
name|c
operator|.
name|getDeclaredMethod
argument_list|(
literal|"createFilterFromArguments"
argument_list|,
name|argTypes
argument_list|)
decl_stmt|;
return|return
operator|(
name|Filter
operator|)
name|m
operator|.
name|invoke
argument_list|(
literal|null
argument_list|,
name|filterArguments
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Incorrect filter string "
operator|+
operator|new
name|String
argument_list|(
name|filterStringAsByteArray
argument_list|)
argument_list|)
throw|;
block|}
comment|/**  * Returns the filter name given a simple filter expression  *<p>  * @param filterStringAsByteArray a simple filter expression  * @return name of filter in the simple filter expression  */
specifier|public
specifier|static
name|byte
index|[]
name|getFilterName
parameter_list|(
name|byte
index|[]
name|filterStringAsByteArray
parameter_list|)
block|{
name|int
name|filterNameStartIndex
init|=
literal|0
decl_stmt|;
name|int
name|filterNameEndIndex
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|filterNameStartIndex
init|;
name|i
operator|<
name|filterStringAsByteArray
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|filterStringAsByteArray
index|[
name|i
index|]
operator|==
name|ParseConstants
operator|.
name|LPAREN
operator|||
name|filterStringAsByteArray
index|[
name|i
index|]
operator|==
name|ParseConstants
operator|.
name|WHITESPACE
condition|)
block|{
name|filterNameEndIndex
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|filterNameEndIndex
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Incorrect Filter Name"
argument_list|)
throw|;
block|}
name|byte
index|[]
name|filterName
init|=
operator|new
name|byte
index|[
name|filterNameEndIndex
operator|-
name|filterNameStartIndex
index|]
decl_stmt|;
name|Bytes
operator|.
name|putBytes
argument_list|(
name|filterName
argument_list|,
literal|0
argument_list|,
name|filterStringAsByteArray
argument_list|,
literal|0
argument_list|,
name|filterNameEndIndex
operator|-
name|filterNameStartIndex
argument_list|)
expr_stmt|;
return|return
name|filterName
return|;
block|}
comment|/**  * Returns the arguments of the filter from the filter string  *<p>  * @param filterStringAsByteArray filter string given by the user  * @return an ArrayList containing the arguments of the filter in the filter string  */
specifier|public
specifier|static
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
name|getFilterArguments
parameter_list|(
name|byte
index|[]
name|filterStringAsByteArray
parameter_list|)
block|{
name|int
name|argumentListStartIndex
init|=
name|KeyValue
operator|.
name|getDelimiter
argument_list|(
name|filterStringAsByteArray
argument_list|,
literal|0
argument_list|,
name|filterStringAsByteArray
operator|.
name|length
argument_list|,
name|ParseConstants
operator|.
name|LPAREN
argument_list|)
decl_stmt|;
if|if
condition|(
name|argumentListStartIndex
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Incorrect argument list"
argument_list|)
throw|;
block|}
name|int
name|argumentStartIndex
init|=
literal|0
decl_stmt|;
name|int
name|argumentEndIndex
init|=
literal|0
decl_stmt|;
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
name|filterArguments
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|argumentListStartIndex
operator|+
literal|1
init|;
name|i
operator|<
name|filterStringAsByteArray
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|filterStringAsByteArray
index|[
name|i
index|]
operator|==
name|ParseConstants
operator|.
name|WHITESPACE
operator|||
name|filterStringAsByteArray
index|[
name|i
index|]
operator|==
name|ParseConstants
operator|.
name|COMMA
operator|||
name|filterStringAsByteArray
index|[
name|i
index|]
operator|==
name|ParseConstants
operator|.
name|RPAREN
condition|)
block|{
continue|continue;
block|}
comment|// The argument is in single quotes - for example 'prefix'
if|if
condition|(
name|filterStringAsByteArray
index|[
name|i
index|]
operator|==
name|ParseConstants
operator|.
name|SINGLE_QUOTE
condition|)
block|{
name|argumentStartIndex
operator|=
name|i
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
name|argumentStartIndex
operator|+
literal|1
init|;
name|j
operator|<
name|filterStringAsByteArray
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|filterStringAsByteArray
index|[
name|j
index|]
operator|==
name|ParseConstants
operator|.
name|SINGLE_QUOTE
condition|)
block|{
if|if
condition|(
name|isQuoteUnescaped
argument_list|(
name|filterStringAsByteArray
argument_list|,
name|j
argument_list|)
condition|)
block|{
name|argumentEndIndex
operator|=
name|j
expr_stmt|;
name|i
operator|=
name|j
operator|+
literal|1
expr_stmt|;
name|byte
index|[]
name|filterArgument
init|=
name|createUnescapdArgument
argument_list|(
name|filterStringAsByteArray
argument_list|,
name|argumentStartIndex
argument_list|,
name|argumentEndIndex
argument_list|)
decl_stmt|;
name|filterArguments
operator|.
name|add
argument_list|(
name|filterArgument
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|// To jump over the second escaped quote
name|j
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|j
operator|==
name|filterStringAsByteArray
operator|.
name|length
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Incorrect argument list"
argument_list|)
throw|;
block|}
block|}
block|}
else|else
block|{
comment|// The argument is an integer, boolean, comparison operator like<,>, != etc
name|argumentStartIndex
operator|=
name|i
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
name|argumentStartIndex
init|;
name|j
operator|<
name|filterStringAsByteArray
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|filterStringAsByteArray
index|[
name|j
index|]
operator|==
name|ParseConstants
operator|.
name|WHITESPACE
operator|||
name|filterStringAsByteArray
index|[
name|j
index|]
operator|==
name|ParseConstants
operator|.
name|COMMA
operator|||
name|filterStringAsByteArray
index|[
name|j
index|]
operator|==
name|ParseConstants
operator|.
name|RPAREN
condition|)
block|{
name|argumentEndIndex
operator|=
name|j
operator|-
literal|1
expr_stmt|;
name|i
operator|=
name|j
expr_stmt|;
name|byte
index|[]
name|filterArgument
init|=
operator|new
name|byte
index|[
name|argumentEndIndex
operator|-
name|argumentStartIndex
operator|+
literal|1
index|]
decl_stmt|;
name|Bytes
operator|.
name|putBytes
argument_list|(
name|filterArgument
argument_list|,
literal|0
argument_list|,
name|filterStringAsByteArray
argument_list|,
name|argumentStartIndex
argument_list|,
name|argumentEndIndex
operator|-
name|argumentStartIndex
operator|+
literal|1
argument_list|)
expr_stmt|;
name|filterArguments
operator|.
name|add
argument_list|(
name|filterArgument
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|j
operator|==
name|filterStringAsByteArray
operator|.
name|length
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Incorrect argument list"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
return|return
name|filterArguments
return|;
block|}
comment|/**  * This function is called while parsing the filterString and an operator is parsed  *<p>  * @param operatorStack the stack containing the operators and parenthesis  * @param filterStack the stack containing the filters  * @param operator the operator found while parsing the filterString  */
specifier|public
name|void
name|reduce
parameter_list|(
name|Stack
argument_list|<
name|ByteBuffer
argument_list|>
name|operatorStack
parameter_list|,
name|Stack
argument_list|<
name|Filter
argument_list|>
name|filterStack
parameter_list|,
name|ByteBuffer
name|operator
parameter_list|)
block|{
while|while
condition|(
operator|!
name|operatorStack
operator|.
name|empty
argument_list|()
operator|&&
operator|!
operator|(
name|ParseConstants
operator|.
name|LPAREN_BUFFER
operator|.
name|equals
argument_list|(
name|operatorStack
operator|.
name|peek
argument_list|()
argument_list|)
operator|)
operator|&&
name|hasHigherPriority
argument_list|(
name|operatorStack
operator|.
name|peek
argument_list|()
argument_list|,
name|operator
argument_list|)
condition|)
block|{
name|filterStack
operator|.
name|push
argument_list|(
name|popArguments
argument_list|(
name|operatorStack
argument_list|,
name|filterStack
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Pops an argument from the operator stack and the number of arguments required by the operator    * from the filterStack and evaluates them    *<p>    * @param operatorStack the stack containing the operators    * @param filterStack the stack containing the filters    * @return the evaluated filter    */
specifier|public
specifier|static
name|Filter
name|popArguments
parameter_list|(
name|Stack
argument_list|<
name|ByteBuffer
argument_list|>
name|operatorStack
parameter_list|,
name|Stack
argument_list|<
name|Filter
argument_list|>
name|filterStack
parameter_list|)
block|{
name|ByteBuffer
name|argumentOnTopOfStack
init|=
name|operatorStack
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|argumentOnTopOfStack
operator|.
name|equals
argument_list|(
name|ParseConstants
operator|.
name|OR_BUFFER
argument_list|)
condition|)
block|{
comment|// The top of the stack is an OR
try|try
block|{
name|ArrayList
argument_list|<
name|Filter
argument_list|>
name|listOfFilters
init|=
operator|new
name|ArrayList
argument_list|<
name|Filter
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|operatorStack
operator|.
name|empty
argument_list|()
operator|&&
name|operatorStack
operator|.
name|peek
argument_list|()
operator|.
name|equals
argument_list|(
name|ParseConstants
operator|.
name|OR_BUFFER
argument_list|)
condition|)
block|{
name|Filter
name|filter
init|=
name|filterStack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|listOfFilters
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|filter
argument_list|)
expr_stmt|;
name|operatorStack
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
name|Filter
name|filter
init|=
name|filterStack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|listOfFilters
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|filter
argument_list|)
expr_stmt|;
name|Filter
name|orFilter
init|=
operator|new
name|FilterList
argument_list|(
name|FilterList
operator|.
name|Operator
operator|.
name|MUST_PASS_ONE
argument_list|,
name|listOfFilters
argument_list|)
decl_stmt|;
return|return
name|orFilter
return|;
block|}
catch|catch
parameter_list|(
name|EmptyStackException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Incorrect input string - an OR needs two filters"
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|argumentOnTopOfStack
operator|.
name|equals
argument_list|(
name|ParseConstants
operator|.
name|AND_BUFFER
argument_list|)
condition|)
block|{
comment|// The top of the stack is an AND
try|try
block|{
name|ArrayList
argument_list|<
name|Filter
argument_list|>
name|listOfFilters
init|=
operator|new
name|ArrayList
argument_list|<
name|Filter
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|operatorStack
operator|.
name|empty
argument_list|()
operator|&&
name|operatorStack
operator|.
name|peek
argument_list|()
operator|.
name|equals
argument_list|(
name|ParseConstants
operator|.
name|AND_BUFFER
argument_list|)
condition|)
block|{
name|Filter
name|filter
init|=
name|filterStack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|listOfFilters
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|filter
argument_list|)
expr_stmt|;
name|operatorStack
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
name|Filter
name|filter
init|=
name|filterStack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|listOfFilters
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|filter
argument_list|)
expr_stmt|;
name|Filter
name|andFilter
init|=
operator|new
name|FilterList
argument_list|(
name|FilterList
operator|.
name|Operator
operator|.
name|MUST_PASS_ALL
argument_list|,
name|listOfFilters
argument_list|)
decl_stmt|;
return|return
name|andFilter
return|;
block|}
catch|catch
parameter_list|(
name|EmptyStackException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Incorrect input string - an AND needs two filters"
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|argumentOnTopOfStack
operator|.
name|equals
argument_list|(
name|ParseConstants
operator|.
name|SKIP_BUFFER
argument_list|)
condition|)
block|{
comment|// The top of the stack is a SKIP
try|try
block|{
name|Filter
name|wrappedFilter
init|=
name|filterStack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Filter
name|skipFilter
init|=
operator|new
name|SkipFilter
argument_list|(
name|wrappedFilter
argument_list|)
decl_stmt|;
name|operatorStack
operator|.
name|pop
argument_list|()
expr_stmt|;
return|return
name|skipFilter
return|;
block|}
catch|catch
parameter_list|(
name|EmptyStackException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Incorrect input string - a SKIP wraps a filter"
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|argumentOnTopOfStack
operator|.
name|equals
argument_list|(
name|ParseConstants
operator|.
name|WHILE_BUFFER
argument_list|)
condition|)
block|{
comment|// The top of the stack is a WHILE
try|try
block|{
name|Filter
name|wrappedFilter
init|=
name|filterStack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|Filter
name|whileMatchFilter
init|=
operator|new
name|WhileMatchFilter
argument_list|(
name|wrappedFilter
argument_list|)
decl_stmt|;
name|operatorStack
operator|.
name|pop
argument_list|()
expr_stmt|;
return|return
name|whileMatchFilter
return|;
block|}
catch|catch
parameter_list|(
name|EmptyStackException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Incorrect input string - a WHILE wraps a filter"
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|argumentOnTopOfStack
operator|.
name|equals
argument_list|(
name|ParseConstants
operator|.
name|LPAREN_BUFFER
argument_list|)
condition|)
block|{
comment|// The top of the stack is a LPAREN
try|try
block|{
name|Filter
name|filter
init|=
name|filterStack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|operatorStack
operator|.
name|pop
argument_list|()
expr_stmt|;
return|return
name|filter
return|;
block|}
catch|catch
parameter_list|(
name|EmptyStackException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Incorrect Filter String"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Incorrect arguments on operatorStack"
argument_list|)
throw|;
block|}
block|}
comment|/**  * Returns which operator has higher precedence  *<p>  * If a has higher precedence than b, it returns true  * If they have the same precedence, it returns false  */
specifier|public
name|boolean
name|hasHigherPriority
parameter_list|(
name|ByteBuffer
name|a
parameter_list|,
name|ByteBuffer
name|b
parameter_list|)
block|{
if|if
condition|(
operator|(
name|operatorPrecedenceHashMap
operator|.
name|get
argument_list|(
name|a
argument_list|)
operator|-
name|operatorPrecedenceHashMap
operator|.
name|get
argument_list|(
name|b
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**  * Removes the single quote escaping a single quote - thus it returns an unescaped argument  *<p>  * @param filterStringAsByteArray filter string given by user  * @param argumentStartIndex start index of the argument  * @param argumentEndIndex end index of the argument  * @return returns an unescaped argument  */
specifier|public
specifier|static
name|byte
index|[]
name|createUnescapdArgument
parameter_list|(
name|byte
index|[]
name|filterStringAsByteArray
parameter_list|,
name|int
name|argumentStartIndex
parameter_list|,
name|int
name|argumentEndIndex
parameter_list|)
block|{
name|int
name|unescapedArgumentLength
init|=
literal|2
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|argumentStartIndex
operator|+
literal|1
init|;
name|i
operator|<=
name|argumentEndIndex
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|unescapedArgumentLength
operator|++
expr_stmt|;
if|if
condition|(
name|filterStringAsByteArray
index|[
name|i
index|]
operator|==
name|ParseConstants
operator|.
name|SINGLE_QUOTE
operator|&&
name|i
operator|!=
operator|(
name|argumentEndIndex
operator|-
literal|1
operator|)
operator|&&
name|filterStringAsByteArray
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|ParseConstants
operator|.
name|SINGLE_QUOTE
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
name|byte
index|[]
name|unescapedArgument
init|=
operator|new
name|byte
index|[
name|unescapedArgumentLength
index|]
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
name|unescapedArgument
index|[
literal|0
index|]
operator|=
literal|'\''
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|argumentStartIndex
operator|+
literal|1
init|;
name|i
operator|<=
name|argumentEndIndex
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|filterStringAsByteArray
index|[
name|i
index|]
operator|==
name|ParseConstants
operator|.
name|SINGLE_QUOTE
operator|&&
name|i
operator|!=
operator|(
name|argumentEndIndex
operator|-
literal|1
operator|)
operator|&&
name|filterStringAsByteArray
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|ParseConstants
operator|.
name|SINGLE_QUOTE
condition|)
block|{
name|unescapedArgument
index|[
name|count
operator|++
index|]
operator|=
name|filterStringAsByteArray
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
name|unescapedArgument
index|[
name|count
operator|++
index|]
operator|=
name|filterStringAsByteArray
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|unescapedArgument
index|[
name|unescapedArgumentLength
operator|-
literal|1
index|]
operator|=
literal|'\''
expr_stmt|;
return|return
name|unescapedArgument
return|;
block|}
comment|/**  * Checks if the current index of filter string we are on is the beginning of the keyword 'OR'  *<p>  * @param filterStringAsByteArray filter string given by the user  * @param indexOfOr index at which an 'O' was read  * @return true if the keyword 'OR' is at the current index  */
specifier|public
specifier|static
name|boolean
name|checkForOr
parameter_list|(
name|byte
index|[]
name|filterStringAsByteArray
parameter_list|,
name|int
name|indexOfOr
parameter_list|)
throws|throws
name|CharacterCodingException
throws|,
name|ArrayIndexOutOfBoundsException
block|{
try|try
block|{
if|if
condition|(
name|filterStringAsByteArray
index|[
name|indexOfOr
index|]
operator|==
name|ParseConstants
operator|.
name|O
operator|&&
name|filterStringAsByteArray
index|[
name|indexOfOr
operator|+
literal|1
index|]
operator|==
name|ParseConstants
operator|.
name|R
operator|&&
operator|(
name|filterStringAsByteArray
index|[
name|indexOfOr
operator|-
literal|1
index|]
operator|==
name|ParseConstants
operator|.
name|WHITESPACE
operator|||
name|filterStringAsByteArray
index|[
name|indexOfOr
operator|-
literal|1
index|]
operator|==
name|ParseConstants
operator|.
name|RPAREN
operator|)
operator|&&
operator|(
name|filterStringAsByteArray
index|[
name|indexOfOr
operator|+
literal|2
index|]
operator|==
name|ParseConstants
operator|.
name|WHITESPACE
operator|||
name|filterStringAsByteArray
index|[
name|indexOfOr
operator|+
literal|2
index|]
operator|==
name|ParseConstants
operator|.
name|LPAREN
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**  * Checks if the current index of filter string we are on is the beginning of the keyword 'AND'  *<p>  * @param filterStringAsByteArray filter string given by the user  * @param indexOfAnd index at which an 'A' was read  * @return true if the keyword 'AND' is at the current index  */
specifier|public
specifier|static
name|boolean
name|checkForAnd
parameter_list|(
name|byte
index|[]
name|filterStringAsByteArray
parameter_list|,
name|int
name|indexOfAnd
parameter_list|)
throws|throws
name|CharacterCodingException
block|{
try|try
block|{
if|if
condition|(
name|filterStringAsByteArray
index|[
name|indexOfAnd
index|]
operator|==
name|ParseConstants
operator|.
name|A
operator|&&
name|filterStringAsByteArray
index|[
name|indexOfAnd
operator|+
literal|1
index|]
operator|==
name|ParseConstants
operator|.
name|N
operator|&&
name|filterStringAsByteArray
index|[
name|indexOfAnd
operator|+
literal|2
index|]
operator|==
name|ParseConstants
operator|.
name|D
operator|&&
operator|(
name|filterStringAsByteArray
index|[
name|indexOfAnd
operator|-
literal|1
index|]
operator|==
name|ParseConstants
operator|.
name|WHITESPACE
operator|||
name|filterStringAsByteArray
index|[
name|indexOfAnd
operator|-
literal|1
index|]
operator|==
name|ParseConstants
operator|.
name|RPAREN
operator|)
operator|&&
operator|(
name|filterStringAsByteArray
index|[
name|indexOfAnd
operator|+
literal|3
index|]
operator|==
name|ParseConstants
operator|.
name|WHITESPACE
operator|||
name|filterStringAsByteArray
index|[
name|indexOfAnd
operator|+
literal|3
index|]
operator|==
name|ParseConstants
operator|.
name|LPAREN
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**  * Checks if the current index of filter string we are on is the beginning of the keyword 'SKIP'  *<p>  * @param filterStringAsByteArray filter string given by the user  * @param indexOfSkip index at which an 'S' was read  * @return true if the keyword 'SKIP' is at the current index  */
specifier|public
specifier|static
name|boolean
name|checkForSkip
parameter_list|(
name|byte
index|[]
name|filterStringAsByteArray
parameter_list|,
name|int
name|indexOfSkip
parameter_list|)
throws|throws
name|CharacterCodingException
block|{
try|try
block|{
if|if
condition|(
name|filterStringAsByteArray
index|[
name|indexOfSkip
index|]
operator|==
name|ParseConstants
operator|.
name|S
operator|&&
name|filterStringAsByteArray
index|[
name|indexOfSkip
operator|+
literal|1
index|]
operator|==
name|ParseConstants
operator|.
name|K
operator|&&
name|filterStringAsByteArray
index|[
name|indexOfSkip
operator|+
literal|2
index|]
operator|==
name|ParseConstants
operator|.
name|I
operator|&&
name|filterStringAsByteArray
index|[
name|indexOfSkip
operator|+
literal|3
index|]
operator|==
name|ParseConstants
operator|.
name|P
operator|&&
operator|(
name|indexOfSkip
operator|==
literal|0
operator|||
name|filterStringAsByteArray
index|[
name|indexOfSkip
operator|-
literal|1
index|]
operator|==
name|ParseConstants
operator|.
name|WHITESPACE
operator|||
name|filterStringAsByteArray
index|[
name|indexOfSkip
operator|-
literal|1
index|]
operator|==
name|ParseConstants
operator|.
name|RPAREN
operator|||
name|filterStringAsByteArray
index|[
name|indexOfSkip
operator|-
literal|1
index|]
operator|==
name|ParseConstants
operator|.
name|LPAREN
operator|)
operator|&&
operator|(
name|filterStringAsByteArray
index|[
name|indexOfSkip
operator|+
literal|4
index|]
operator|==
name|ParseConstants
operator|.
name|WHITESPACE
operator|||
name|filterStringAsByteArray
index|[
name|indexOfSkip
operator|+
literal|4
index|]
operator|==
name|ParseConstants
operator|.
name|LPAREN
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**  * Checks if the current index of filter string we are on is the beginning of the keyword 'WHILE'  *<p>  * @param filterStringAsByteArray filter string given by the user  * @param indexOfWhile index at which an 'W' was read  * @return true if the keyword 'WHILE' is at the current index  */
specifier|public
specifier|static
name|boolean
name|checkForWhile
parameter_list|(
name|byte
index|[]
name|filterStringAsByteArray
parameter_list|,
name|int
name|indexOfWhile
parameter_list|)
throws|throws
name|CharacterCodingException
block|{
try|try
block|{
if|if
condition|(
name|filterStringAsByteArray
index|[
name|indexOfWhile
index|]
operator|==
name|ParseConstants
operator|.
name|W
operator|&&
name|filterStringAsByteArray
index|[
name|indexOfWhile
operator|+
literal|1
index|]
operator|==
name|ParseConstants
operator|.
name|H
operator|&&
name|filterStringAsByteArray
index|[
name|indexOfWhile
operator|+
literal|2
index|]
operator|==
name|ParseConstants
operator|.
name|I
operator|&&
name|filterStringAsByteArray
index|[
name|indexOfWhile
operator|+
literal|3
index|]
operator|==
name|ParseConstants
operator|.
name|L
operator|&&
name|filterStringAsByteArray
index|[
name|indexOfWhile
operator|+
literal|4
index|]
operator|==
name|ParseConstants
operator|.
name|E
operator|&&
operator|(
name|indexOfWhile
operator|==
literal|0
operator|||
name|filterStringAsByteArray
index|[
name|indexOfWhile
operator|-
literal|1
index|]
operator|==
name|ParseConstants
operator|.
name|WHITESPACE
operator|||
name|filterStringAsByteArray
index|[
name|indexOfWhile
operator|-
literal|1
index|]
operator|==
name|ParseConstants
operator|.
name|RPAREN
operator|||
name|filterStringAsByteArray
index|[
name|indexOfWhile
operator|-
literal|1
index|]
operator|==
name|ParseConstants
operator|.
name|LPAREN
operator|)
operator|&&
operator|(
name|filterStringAsByteArray
index|[
name|indexOfWhile
operator|+
literal|5
index|]
operator|==
name|ParseConstants
operator|.
name|WHITESPACE
operator|||
name|filterStringAsByteArray
index|[
name|indexOfWhile
operator|+
literal|5
index|]
operator|==
name|ParseConstants
operator|.
name|LPAREN
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**  * Returns a boolean indicating whether the quote was escaped or not  *<p>  * @param array byte array in which the quote was found  * @param quoteIndex index of the single quote  * @return returns true if the quote was unescaped  */
specifier|public
specifier|static
name|boolean
name|isQuoteUnescaped
parameter_list|(
name|byte
index|[]
name|array
parameter_list|,
name|int
name|quoteIndex
parameter_list|)
block|{
if|if
condition|(
name|array
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"isQuoteUnescaped called with a null array"
argument_list|)
throw|;
block|}
if|if
condition|(
name|quoteIndex
operator|==
name|array
operator|.
name|length
operator|-
literal|1
operator|||
name|array
index|[
name|quoteIndex
operator|+
literal|1
index|]
operator|!=
name|ParseConstants
operator|.
name|SINGLE_QUOTE
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**  * Takes a quoted byte array and converts it into an unquoted byte array  * For example: given a byte array representing 'abc', it returns a  * byte array representing abc  *<p>  * @param quotedByteArray the quoted byte array  * @return Unquoted byte array  */
specifier|public
specifier|static
name|byte
index|[]
name|removeQuotesFromByteArray
parameter_list|(
name|byte
index|[]
name|quotedByteArray
parameter_list|)
block|{
if|if
condition|(
name|quotedByteArray
operator|==
literal|null
operator|||
name|quotedByteArray
operator|.
name|length
operator|<
literal|2
operator|||
name|quotedByteArray
index|[
literal|0
index|]
operator|!=
name|ParseConstants
operator|.
name|SINGLE_QUOTE
operator|||
name|quotedByteArray
index|[
name|quotedByteArray
operator|.
name|length
operator|-
literal|1
index|]
operator|!=
name|ParseConstants
operator|.
name|SINGLE_QUOTE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"removeQuotesFromByteArray needs a quoted byte array"
argument_list|)
throw|;
block|}
else|else
block|{
name|byte
index|[]
name|targetString
init|=
operator|new
name|byte
index|[
name|quotedByteArray
operator|.
name|length
operator|-
literal|2
index|]
decl_stmt|;
name|Bytes
operator|.
name|putBytes
argument_list|(
name|targetString
argument_list|,
literal|0
argument_list|,
name|quotedByteArray
argument_list|,
literal|1
argument_list|,
name|quotedByteArray
operator|.
name|length
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return
name|targetString
return|;
block|}
block|}
comment|/**  * Converts an int expressed in a byte array to an actual int  *<p>  * This doesn't use Bytes.toInt because that assumes  * that there will be {@link Bytes#SIZEOF_INT} bytes available.  *<p>  * @param numberAsByteArray the int value expressed as a byte array  * @return the int value  */
specifier|public
specifier|static
name|int
name|convertByteArrayToInt
parameter_list|(
name|byte
index|[]
name|numberAsByteArray
parameter_list|)
block|{
name|long
name|tempResult
init|=
name|ParseFilter
operator|.
name|convertByteArrayToLong
argument_list|(
name|numberAsByteArray
argument_list|)
decl_stmt|;
if|if
condition|(
name|tempResult
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Integer Argument too large"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|tempResult
operator|<
name|Integer
operator|.
name|MIN_VALUE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Integer Argument too small"
argument_list|)
throw|;
block|}
name|int
name|result
init|=
operator|(
name|int
operator|)
name|tempResult
decl_stmt|;
return|return
name|result
return|;
block|}
comment|/**  * Converts a long expressed in a byte array to an actual long  *<p>  * This doesn't use Bytes.toLong because that assumes  * that there will be {@link Bytes#SIZEOF_INT} bytes available.  *<p>  * @param numberAsByteArray the long value expressed as a byte array  * @return the long value  */
specifier|public
specifier|static
name|long
name|convertByteArrayToLong
parameter_list|(
name|byte
index|[]
name|numberAsByteArray
parameter_list|)
block|{
if|if
condition|(
name|numberAsByteArray
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"convertByteArrayToLong called with a null array"
argument_list|)
throw|;
block|}
name|int
name|i
init|=
literal|0
decl_stmt|;
name|long
name|result
init|=
literal|0
decl_stmt|;
name|boolean
name|isNegative
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|numberAsByteArray
index|[
name|i
index|]
operator|==
name|ParseConstants
operator|.
name|MINUS_SIGN
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|isNegative
operator|=
literal|true
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|!=
name|numberAsByteArray
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|numberAsByteArray
index|[
name|i
index|]
operator|<
name|ParseConstants
operator|.
name|ZERO
operator|||
name|numberAsByteArray
index|[
name|i
index|]
operator|>
name|ParseConstants
operator|.
name|NINE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Byte Array should only contain digits"
argument_list|)
throw|;
block|}
name|result
operator|=
name|result
operator|*
literal|10
operator|+
operator|(
name|numberAsByteArray
index|[
name|i
index|]
operator|-
name|ParseConstants
operator|.
name|ZERO
operator|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Long Argument too large"
argument_list|)
throw|;
block|}
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|isNegative
condition|)
block|{
return|return
operator|-
name|result
return|;
block|}
else|else
block|{
return|return
name|result
return|;
block|}
block|}
comment|/**  * Converts a boolean expressed in a byte array to an actual boolean  *<p>  * This doesn't used Bytes.toBoolean because Bytes.toBoolean(byte [])  * assumes that 1 stands for true and 0 for false.  * Here, the byte array representing "true" and "false" is parsed  *<p>  * @param booleanAsByteArray the boolean value expressed as a byte array  * @return the boolean value  */
specifier|public
specifier|static
name|boolean
name|convertByteArrayToBoolean
parameter_list|(
name|byte
index|[]
name|booleanAsByteArray
parameter_list|)
block|{
if|if
condition|(
name|booleanAsByteArray
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"convertByteArrayToBoolean called with a null array"
argument_list|)
throw|;
block|}
if|if
condition|(
name|booleanAsByteArray
operator|.
name|length
operator|==
literal|4
operator|&&
operator|(
name|booleanAsByteArray
index|[
literal|0
index|]
operator|==
literal|'t'
operator|||
name|booleanAsByteArray
index|[
literal|0
index|]
operator|==
literal|'T'
operator|)
operator|&&
operator|(
name|booleanAsByteArray
index|[
literal|1
index|]
operator|==
literal|'r'
operator|||
name|booleanAsByteArray
index|[
literal|1
index|]
operator|==
literal|'R'
operator|)
operator|&&
operator|(
name|booleanAsByteArray
index|[
literal|2
index|]
operator|==
literal|'u'
operator|||
name|booleanAsByteArray
index|[
literal|2
index|]
operator|==
literal|'U'
operator|)
operator|&&
operator|(
name|booleanAsByteArray
index|[
literal|3
index|]
operator|==
literal|'e'
operator|||
name|booleanAsByteArray
index|[
literal|3
index|]
operator|==
literal|'E'
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|booleanAsByteArray
operator|.
name|length
operator|==
literal|5
operator|&&
operator|(
name|booleanAsByteArray
index|[
literal|0
index|]
operator|==
literal|'f'
operator|||
name|booleanAsByteArray
index|[
literal|0
index|]
operator|==
literal|'F'
operator|)
operator|&&
operator|(
name|booleanAsByteArray
index|[
literal|1
index|]
operator|==
literal|'a'
operator|||
name|booleanAsByteArray
index|[
literal|1
index|]
operator|==
literal|'A'
operator|)
operator|&&
operator|(
name|booleanAsByteArray
index|[
literal|2
index|]
operator|==
literal|'l'
operator|||
name|booleanAsByteArray
index|[
literal|2
index|]
operator|==
literal|'L'
operator|)
operator|&&
operator|(
name|booleanAsByteArray
index|[
literal|3
index|]
operator|==
literal|'s'
operator|||
name|booleanAsByteArray
index|[
literal|3
index|]
operator|==
literal|'S'
operator|)
operator|&&
operator|(
name|booleanAsByteArray
index|[
literal|4
index|]
operator|==
literal|'e'
operator|||
name|booleanAsByteArray
index|[
literal|4
index|]
operator|==
literal|'E'
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Incorrect Boolean Expression"
argument_list|)
throw|;
block|}
block|}
comment|/**  * Takes a compareOperator symbol as a byte array and returns the corresponding CompareOperator  *<p>  * @param compareOpAsByteArray the comparatorOperator symbol as a byte array  * @return the Compare Operator  */
specifier|public
specifier|static
name|CompareFilter
operator|.
name|CompareOp
name|createCompareOp
parameter_list|(
name|byte
index|[]
name|compareOpAsByteArray
parameter_list|)
block|{
name|ByteBuffer
name|compareOp
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|compareOpAsByteArray
argument_list|)
decl_stmt|;
if|if
condition|(
name|compareOp
operator|.
name|equals
argument_list|(
name|ParseConstants
operator|.
name|LESS_THAN_BUFFER
argument_list|)
condition|)
return|return
name|CompareOp
operator|.
name|LESS
return|;
elseif|else
if|if
condition|(
name|compareOp
operator|.
name|equals
argument_list|(
name|ParseConstants
operator|.
name|LESS_THAN_OR_EQUAL_TO_BUFFER
argument_list|)
condition|)
return|return
name|CompareOp
operator|.
name|LESS_OR_EQUAL
return|;
elseif|else
if|if
condition|(
name|compareOp
operator|.
name|equals
argument_list|(
name|ParseConstants
operator|.
name|GREATER_THAN_BUFFER
argument_list|)
condition|)
return|return
name|CompareOp
operator|.
name|GREATER
return|;
elseif|else
if|if
condition|(
name|compareOp
operator|.
name|equals
argument_list|(
name|ParseConstants
operator|.
name|GREATER_THAN_OR_EQUAL_TO_BUFFER
argument_list|)
condition|)
return|return
name|CompareOp
operator|.
name|GREATER_OR_EQUAL
return|;
elseif|else
if|if
condition|(
name|compareOp
operator|.
name|equals
argument_list|(
name|ParseConstants
operator|.
name|NOT_EQUAL_TO_BUFFER
argument_list|)
condition|)
return|return
name|CompareOp
operator|.
name|NOT_EQUAL
return|;
elseif|else
if|if
condition|(
name|compareOp
operator|.
name|equals
argument_list|(
name|ParseConstants
operator|.
name|EQUAL_TO_BUFFER
argument_list|)
condition|)
return|return
name|CompareOp
operator|.
name|EQUAL
return|;
else|else
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid compare operator"
argument_list|)
throw|;
block|}
comment|/**  * Parses a comparator of the form comparatorType:comparatorValue form and returns a comparator  *<p>  * @param comparator the comparator in the form comparatorType:comparatorValue  * @return the parsed comparator  */
specifier|public
specifier|static
name|ByteArrayComparable
name|createComparator
parameter_list|(
name|byte
index|[]
name|comparator
parameter_list|)
block|{
if|if
condition|(
name|comparator
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Incorrect Comparator"
argument_list|)
throw|;
name|byte
index|[]
index|[]
name|parsedComparator
init|=
name|ParseFilter
operator|.
name|parseComparator
argument_list|(
name|comparator
argument_list|)
decl_stmt|;
name|byte
index|[]
name|comparatorType
init|=
name|parsedComparator
index|[
literal|0
index|]
decl_stmt|;
name|byte
index|[]
name|comparatorValue
init|=
name|parsedComparator
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|comparatorType
argument_list|,
name|ParseConstants
operator|.
name|binaryType
argument_list|)
condition|)
return|return
operator|new
name|BinaryComparator
argument_list|(
name|comparatorValue
argument_list|)
return|;
elseif|else
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|comparatorType
argument_list|,
name|ParseConstants
operator|.
name|binaryPrefixType
argument_list|)
condition|)
return|return
operator|new
name|BinaryPrefixComparator
argument_list|(
name|comparatorValue
argument_list|)
return|;
elseif|else
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|comparatorType
argument_list|,
name|ParseConstants
operator|.
name|regexStringType
argument_list|)
condition|)
return|return
operator|new
name|RegexStringComparator
argument_list|(
operator|new
name|String
argument_list|(
name|comparatorValue
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|comparatorType
argument_list|,
name|ParseConstants
operator|.
name|substringType
argument_list|)
condition|)
return|return
operator|new
name|SubstringComparator
argument_list|(
operator|new
name|String
argument_list|(
name|comparatorValue
argument_list|)
argument_list|)
return|;
else|else
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Incorrect comparatorType"
argument_list|)
throw|;
block|}
comment|/**  * Splits a column in comparatorType:comparatorValue form into separate byte arrays  *<p>  * @param comparator the comparator  * @return the parsed arguments of the comparator as a 2D byte array  */
specifier|public
specifier|static
name|byte
index|[]
index|[]
name|parseComparator
parameter_list|(
name|byte
index|[]
name|comparator
parameter_list|)
block|{
specifier|final
name|int
name|index
init|=
name|KeyValue
operator|.
name|getDelimiter
argument_list|(
name|comparator
argument_list|,
literal|0
argument_list|,
name|comparator
operator|.
name|length
argument_list|,
name|ParseConstants
operator|.
name|COLON
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Incorrect comparator"
argument_list|)
throw|;
block|}
name|byte
index|[]
index|[]
name|result
init|=
operator|new
name|byte
index|[
literal|2
index|]
index|[
literal|0
index|]
decl_stmt|;
name|result
index|[
literal|0
index|]
operator|=
operator|new
name|byte
index|[
name|index
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|comparator
argument_list|,
literal|0
argument_list|,
name|result
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|index
argument_list|)
expr_stmt|;
specifier|final
name|int
name|len
init|=
name|comparator
operator|.
name|length
operator|-
operator|(
name|index
operator|+
literal|1
operator|)
decl_stmt|;
name|result
index|[
literal|1
index|]
operator|=
operator|new
name|byte
index|[
name|len
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|comparator
argument_list|,
name|index
operator|+
literal|1
argument_list|,
name|result
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**  * Return a Set of filters supported by the Filter Language  */
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getSupportedFilters
parameter_list|()
block|{
return|return
name|filterHashMap
operator|.
name|keySet
argument_list|()
return|;
block|}
comment|/**    * Returns all known filters    * @return an unmodifiable map of filters    */
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getAllFilters
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|filterHashMap
argument_list|)
return|;
block|}
comment|/**    * Register a new filter with the parser.  If the filter is already registered,    * an IllegalArgumentException will be thrown.    *    * @param name a name for the filter    * @param filterClass fully qualified class name    */
specifier|public
specifier|static
name|void
name|registerFilter
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|filterClass
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|info
argument_list|(
literal|"Registering new filter "
operator|+
name|name
argument_list|)
expr_stmt|;
name|filterHashMap
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|filterClass
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

