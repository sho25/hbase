begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|SequenceInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
operator|.
name|KVComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|DeserializationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|RegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|JenkinsHash
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|MD5Hash
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|PairOfSameType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|DataInputBuffer
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|ByteString
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|InvalidProtocolBufferException
import|;
end_import

begin_comment
comment|/**  * HRegion information.  * Contains HRegion id, start and end keys, a reference to this HRegions' table descriptor, etc.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
class|class
name|HRegionInfo
implements|implements
name|Comparable
argument_list|<
name|HRegionInfo
argument_list|>
block|{
comment|/*    * There are two versions associated with HRegionInfo: HRegionInfo.VERSION and    * HConstants.META_VERSION. HRegionInfo.VERSION indicates the data structure's versioning    * while HConstants.META_VERSION indicates the versioning of the serialized HRIs stored in    * the META table.    *    * Pre-0.92:    *   HRI.VERSION == 0 and HConstants.META_VERSION does not exist (is not stored at META table)    *   HRegionInfo had an HTableDescriptor reference inside it.    *   HRegionInfo is serialized as Writable to META table.    * For 0.92.x and 0.94.x:    *   HRI.VERSION == 1 and HConstants.META_VERSION == 0    *   HRI no longer has HTableDescriptor in it.    *   HRI is serialized as Writable to META table.    * For 0.96.x:    *   HRI.VERSION == 1 and HConstants.META_VERSION == 1    *   HRI data structure is the same as 0.92 and 0.94    *   HRI is serialized as PB to META table.    *    * Versioning of HRegionInfo is deprecated. HRegionInfo does protobuf    * serialization using RegionInfo class, which has it's own versioning.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
specifier|final
name|byte
name|VERSION
init|=
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HRegionInfo
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * The new format for a region name contains its encodedName at the end.    * The encoded name also serves as the directory name for the region    * in the filesystem.    *    * New region name format:    *&lt;tablename>,,&lt;startkey>,&lt;regionIdTimestamp>.&lt;encodedName>.    * where,    *&lt;encodedName> is a hex version of the MD5 hash of    *&lt;tablename>,&lt;startkey>,&lt;regionIdTimestamp>    *    * The old region name format:    *&lt;tablename>,&lt;startkey>,&lt;regionIdTimestamp>    * For region names in the old format, the encoded name is a 32-bit    * JenkinsHash integer value (in its decimal notation, string form).    *<p>    * **NOTE**    *    * The first META region, and regions created by an older    * version of HBase (0.20 or prior) will continue to use the    * old region name format.    */
comment|/** Separator used to demarcate the encodedName in a region name    * in the new format. See description on new format above.    */
specifier|private
specifier|static
specifier|final
name|int
name|ENC_SEPARATOR
init|=
literal|'.'
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|MD5_HEX_LENGTH
init|=
literal|32
decl_stmt|;
comment|/** A non-capture group so that this can be embedded. */
specifier|public
specifier|static
specifier|final
name|String
name|ENCODED_REGION_NAME_REGEX
init|=
literal|"(?:[a-f0-9]+)"
decl_stmt|;
comment|/**    * Does region name contain its encoded name?    * @param regionName region name    * @return boolean indicating if this a new format region    *         name which contains its encoded name.    */
specifier|private
specifier|static
name|boolean
name|hasEncodedName
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
block|{
comment|// check if region name ends in ENC_SEPARATOR
if|if
condition|(
operator|(
name|regionName
operator|.
name|length
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|regionName
index|[
name|regionName
operator|.
name|length
operator|-
literal|1
index|]
operator|==
name|ENC_SEPARATOR
operator|)
condition|)
block|{
comment|// region name is new format. it contains the encoded name.
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * @param regionName    * @return the encodedName    */
specifier|public
specifier|static
name|String
name|encodeRegionName
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
block|{
name|String
name|encodedName
decl_stmt|;
if|if
condition|(
name|hasEncodedName
argument_list|(
name|regionName
argument_list|)
condition|)
block|{
comment|// region is in new format:
comment|//<tableName>,<startKey>,<regionIdTimeStamp>/encodedName/
name|encodedName
operator|=
name|Bytes
operator|.
name|toString
argument_list|(
name|regionName
argument_list|,
name|regionName
operator|.
name|length
operator|-
name|MD5_HEX_LENGTH
operator|-
literal|1
argument_list|,
name|MD5_HEX_LENGTH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// old format region name. First META region also
comment|// use this format.EncodedName is the JenkinsHash value.
name|int
name|hashVal
init|=
name|Math
operator|.
name|abs
argument_list|(
name|JenkinsHash
operator|.
name|getInstance
argument_list|()
operator|.
name|hash
argument_list|(
name|regionName
argument_list|,
name|regionName
operator|.
name|length
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|encodedName
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|hashVal
argument_list|)
expr_stmt|;
block|}
return|return
name|encodedName
return|;
block|}
comment|/**    * Use logging.    * @param encodedRegionName The encoded regionname.    * @return<code>.META.</code> if passed<code>1028785192</code> else returns    *<code>encodedRegionName</code>    */
specifier|public
specifier|static
name|String
name|prettyPrint
parameter_list|(
specifier|final
name|String
name|encodedRegionName
parameter_list|)
block|{
if|if
condition|(
name|encodedRegionName
operator|.
name|equals
argument_list|(
literal|"1028785192"
argument_list|)
condition|)
block|{
return|return
name|encodedRegionName
operator|+
literal|"/.META."
return|;
block|}
return|return
name|encodedRegionName
return|;
block|}
specifier|private
name|byte
index|[]
name|endKey
init|=
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
decl_stmt|;
comment|// This flag is in the parent of a split while the parent is still referenced
comment|// by daughter regions.  We USED to set this flag when we disabled a table
comment|// but now table state is kept up in zookeeper as of 0.90.0 HBase.
specifier|private
name|boolean
name|offLine
init|=
literal|false
decl_stmt|;
specifier|private
name|long
name|regionId
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|transient
name|byte
index|[]
name|regionName
init|=
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
decl_stmt|;
specifier|private
name|String
name|regionNameStr
init|=
literal|""
decl_stmt|;
specifier|private
name|boolean
name|split
init|=
literal|false
decl_stmt|;
specifier|private
name|byte
index|[]
name|startKey
init|=
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
decl_stmt|;
specifier|private
name|int
name|hashCode
init|=
operator|-
literal|1
decl_stmt|;
comment|//TODO: Move NO_HASH to HStoreFile which is really the only place it is used.
specifier|public
specifier|static
specifier|final
name|String
name|NO_HASH
init|=
literal|null
decl_stmt|;
specifier|private
specifier|volatile
name|String
name|encodedName
init|=
name|NO_HASH
decl_stmt|;
specifier|private
name|byte
index|[]
name|encodedNameAsBytes
init|=
literal|null
decl_stmt|;
comment|// Current TableName
specifier|private
name|byte
index|[]
name|tableName
init|=
literal|null
decl_stmt|;
specifier|private
name|String
name|tableNameAsString
init|=
literal|null
decl_stmt|;
comment|/** HRegionInfo for root region */
specifier|public
specifier|static
specifier|final
name|HRegionInfo
name|ROOT_REGIONINFO
init|=
operator|new
name|HRegionInfo
argument_list|(
literal|0L
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"-ROOT-"
argument_list|)
argument_list|)
decl_stmt|;
comment|/** HRegionInfo for first meta region */
specifier|public
specifier|static
specifier|final
name|HRegionInfo
name|FIRST_META_REGIONINFO
init|=
operator|new
name|HRegionInfo
argument_list|(
literal|1L
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|".META."
argument_list|)
argument_list|)
decl_stmt|;
specifier|private
name|void
name|setHashCode
parameter_list|()
block|{
name|int
name|result
init|=
name|Arrays
operator|.
name|hashCode
argument_list|(
name|this
operator|.
name|regionName
argument_list|)
decl_stmt|;
name|result
operator|^=
name|this
operator|.
name|regionId
expr_stmt|;
name|result
operator|^=
name|Arrays
operator|.
name|hashCode
argument_list|(
name|this
operator|.
name|startKey
argument_list|)
expr_stmt|;
name|result
operator|^=
name|Arrays
operator|.
name|hashCode
argument_list|(
name|this
operator|.
name|endKey
argument_list|)
expr_stmt|;
name|result
operator|^=
name|Boolean
operator|.
name|valueOf
argument_list|(
name|this
operator|.
name|offLine
argument_list|)
operator|.
name|hashCode
argument_list|()
expr_stmt|;
name|result
operator|^=
name|Arrays
operator|.
name|hashCode
argument_list|(
name|this
operator|.
name|tableName
argument_list|)
expr_stmt|;
name|this
operator|.
name|hashCode
operator|=
name|result
expr_stmt|;
block|}
comment|/**    * Private constructor used constructing HRegionInfo for the    * first meta regions    */
specifier|private
name|HRegionInfo
parameter_list|(
name|long
name|regionId
parameter_list|,
name|byte
index|[]
name|tableName
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|regionId
operator|=
name|regionId
expr_stmt|;
name|this
operator|.
name|tableName
operator|=
name|tableName
operator|.
name|clone
argument_list|()
expr_stmt|;
comment|// Note: First Meta regions names are still in old format
name|this
operator|.
name|regionName
operator|=
name|createRegionName
argument_list|(
name|tableName
argument_list|,
literal|null
argument_list|,
name|regionId
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionNameStr
operator|=
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|this
operator|.
name|regionName
argument_list|)
expr_stmt|;
name|setHashCode
argument_list|()
expr_stmt|;
block|}
comment|/** Default constructor - creates empty object    * @deprecated Used by Writables and Writables are going away.    */
annotation|@
name|Deprecated
specifier|public
name|HRegionInfo
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
specifier|public
name|HRegionInfo
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
block|{
name|this
argument_list|(
name|tableName
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct HRegionInfo with explicit parameters    *    * @param tableName the table name    * @param startKey first key in region    * @param endKey end of key range    * @throws IllegalArgumentException    */
specifier|public
name|HRegionInfo
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|byte
index|[]
name|endKey
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|this
argument_list|(
name|tableName
argument_list|,
name|startKey
argument_list|,
name|endKey
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct HRegionInfo with explicit parameters    *    * @param tableName the table descriptor    * @param startKey first key in region    * @param endKey end of key range    * @param split true if this region has split and we have daughter regions    * regions that may or may not hold references to this region.    * @throws IllegalArgumentException    */
specifier|public
name|HRegionInfo
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|byte
index|[]
name|endKey
parameter_list|,
specifier|final
name|boolean
name|split
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|this
argument_list|(
name|tableName
argument_list|,
name|startKey
argument_list|,
name|endKey
argument_list|,
name|split
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct HRegionInfo with explicit parameters    *    * @param tableName the table descriptor    * @param startKey first key in region    * @param endKey end of key range    * @param split true if this region has split and we have daughter regions    * regions that may or may not hold references to this region.    * @param regionid Region id to use.    * @throws IllegalArgumentException    */
specifier|public
name|HRegionInfo
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|byte
index|[]
name|endKey
parameter_list|,
specifier|final
name|boolean
name|split
parameter_list|,
specifier|final
name|long
name|regionid
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|super
argument_list|()
expr_stmt|;
if|if
condition|(
name|tableName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"tableName cannot be null"
argument_list|)
throw|;
block|}
name|this
operator|.
name|tableName
operator|=
name|tableName
operator|.
name|clone
argument_list|()
expr_stmt|;
name|this
operator|.
name|offLine
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|regionId
operator|=
name|regionid
expr_stmt|;
name|this
operator|.
name|regionName
operator|=
name|createRegionName
argument_list|(
name|this
operator|.
name|tableName
argument_list|,
name|startKey
argument_list|,
name|regionId
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionNameStr
operator|=
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|this
operator|.
name|regionName
argument_list|)
expr_stmt|;
name|this
operator|.
name|split
operator|=
name|split
expr_stmt|;
name|this
operator|.
name|endKey
operator|=
name|endKey
operator|==
literal|null
condition|?
name|HConstants
operator|.
name|EMPTY_END_ROW
else|:
name|endKey
operator|.
name|clone
argument_list|()
expr_stmt|;
name|this
operator|.
name|startKey
operator|=
name|startKey
operator|==
literal|null
condition|?
name|HConstants
operator|.
name|EMPTY_START_ROW
else|:
name|startKey
operator|.
name|clone
argument_list|()
expr_stmt|;
name|this
operator|.
name|tableName
operator|=
name|tableName
operator|.
name|clone
argument_list|()
expr_stmt|;
name|setHashCode
argument_list|()
expr_stmt|;
block|}
comment|/**    * Costruct a copy of another HRegionInfo    *    * @param other    */
specifier|public
name|HRegionInfo
parameter_list|(
name|HRegionInfo
name|other
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|endKey
operator|=
name|other
operator|.
name|getEndKey
argument_list|()
expr_stmt|;
name|this
operator|.
name|offLine
operator|=
name|other
operator|.
name|isOffline
argument_list|()
expr_stmt|;
name|this
operator|.
name|regionId
operator|=
name|other
operator|.
name|getRegionId
argument_list|()
expr_stmt|;
name|this
operator|.
name|regionName
operator|=
name|other
operator|.
name|getRegionName
argument_list|()
expr_stmt|;
name|this
operator|.
name|regionNameStr
operator|=
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|this
operator|.
name|regionName
argument_list|)
expr_stmt|;
name|this
operator|.
name|split
operator|=
name|other
operator|.
name|isSplit
argument_list|()
expr_stmt|;
name|this
operator|.
name|startKey
operator|=
name|other
operator|.
name|getStartKey
argument_list|()
expr_stmt|;
name|this
operator|.
name|hashCode
operator|=
name|other
operator|.
name|hashCode
argument_list|()
expr_stmt|;
name|this
operator|.
name|encodedName
operator|=
name|other
operator|.
name|getEncodedName
argument_list|()
expr_stmt|;
name|this
operator|.
name|tableName
operator|=
name|other
operator|.
name|tableName
expr_stmt|;
block|}
comment|/**    * Make a region name of passed parameters.    * @param tableName    * @param startKey Can be null    * @param regionid Region id (Usually timestamp from when region was created).    * @param newFormat should we create the region name in the new format    *                  (such that it contains its encoded name?).    * @return Region name made of passed tableName, startKey and id    */
specifier|public
specifier|static
name|byte
index|[]
name|createRegionName
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|long
name|regionid
parameter_list|,
name|boolean
name|newFormat
parameter_list|)
block|{
return|return
name|createRegionName
argument_list|(
name|tableName
argument_list|,
name|startKey
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|regionid
argument_list|)
argument_list|,
name|newFormat
argument_list|)
return|;
block|}
comment|/**    * Make a region name of passed parameters.    * @param tableName    * @param startKey Can be null    * @param id Region id (Usually timestamp from when region was created).    * @param newFormat should we create the region name in the new format    *                  (such that it contains its encoded name?).    * @return Region name made of passed tableName, startKey and id    */
specifier|public
specifier|static
name|byte
index|[]
name|createRegionName
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|String
name|id
parameter_list|,
name|boolean
name|newFormat
parameter_list|)
block|{
return|return
name|createRegionName
argument_list|(
name|tableName
argument_list|,
name|startKey
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|id
argument_list|)
argument_list|,
name|newFormat
argument_list|)
return|;
block|}
comment|/**    * Make a region name of passed parameters.    * @param tableName    * @param startKey Can be null    * @param id Region id (Usually timestamp from when region was created).    * @param newFormat should we create the region name in the new format    *                  (such that it contains its encoded name?).    * @return Region name made of passed tableName, startKey and id    */
specifier|public
specifier|static
name|byte
index|[]
name|createRegionName
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|byte
index|[]
name|id
parameter_list|,
name|boolean
name|newFormat
parameter_list|)
block|{
name|byte
index|[]
name|b
init|=
operator|new
name|byte
index|[
name|tableName
operator|.
name|length
operator|+
literal|2
operator|+
name|id
operator|.
name|length
operator|+
operator|(
name|startKey
operator|==
literal|null
condition|?
literal|0
else|:
name|startKey
operator|.
name|length
operator|)
operator|+
operator|(
name|newFormat
condition|?
operator|(
name|MD5_HEX_LENGTH
operator|+
literal|2
operator|)
else|:
literal|0
operator|)
index|]
decl_stmt|;
name|int
name|offset
init|=
name|tableName
operator|.
name|length
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|tableName
argument_list|,
literal|0
argument_list|,
name|b
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|b
index|[
name|offset
operator|++
index|]
operator|=
name|HConstants
operator|.
name|DELIMITER
expr_stmt|;
if|if
condition|(
name|startKey
operator|!=
literal|null
operator|&&
name|startKey
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|startKey
argument_list|,
literal|0
argument_list|,
name|b
argument_list|,
name|offset
argument_list|,
name|startKey
operator|.
name|length
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|startKey
operator|.
name|length
expr_stmt|;
block|}
name|b
index|[
name|offset
operator|++
index|]
operator|=
name|HConstants
operator|.
name|DELIMITER
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|id
argument_list|,
literal|0
argument_list|,
name|b
argument_list|,
name|offset
argument_list|,
name|id
operator|.
name|length
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|id
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|newFormat
condition|)
block|{
comment|//
comment|// Encoded name should be built into the region name.
comment|//
comment|// Use the region name thus far (namely,<tablename>,<startKey>,<id>)
comment|// to compute a MD5 hash to be used as the encoded name, and append
comment|// it to the byte buffer.
comment|//
name|String
name|md5Hash
init|=
name|MD5Hash
operator|.
name|getMD5AsHex
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|byte
index|[]
name|md5HashBytes
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|md5Hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|md5HashBytes
operator|.
name|length
operator|!=
name|MD5_HEX_LENGTH
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"MD5-hash length mismatch: Expected="
operator|+
name|MD5_HEX_LENGTH
operator|+
literal|"; Got="
operator|+
name|md5HashBytes
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|// now append the bytes '.<encodedName>.' to the end
name|b
index|[
name|offset
operator|++
index|]
operator|=
name|ENC_SEPARATOR
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|md5HashBytes
argument_list|,
literal|0
argument_list|,
name|b
argument_list|,
name|offset
argument_list|,
name|MD5_HEX_LENGTH
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|MD5_HEX_LENGTH
expr_stmt|;
name|b
index|[
name|offset
operator|++
index|]
operator|=
name|ENC_SEPARATOR
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
comment|/**    * Gets the table name from the specified region name.    * @param regionName    * @return Table name.    */
specifier|public
specifier|static
name|byte
index|[]
name|getTableName
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|)
block|{
name|int
name|offset
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|regionName
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regionName
index|[
name|i
index|]
operator|==
name|HConstants
operator|.
name|DELIMITER
condition|)
block|{
name|offset
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|byte
index|[]
name|tableName
init|=
operator|new
name|byte
index|[
name|offset
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|regionName
argument_list|,
literal|0
argument_list|,
name|tableName
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|tableName
return|;
block|}
comment|/**    * Gets the start key from the specified region name.    * @param regionName    * @return Start key.    */
specifier|public
specifier|static
name|byte
index|[]
name|getStartKey
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|parseRegionName
argument_list|(
name|regionName
argument_list|)
index|[
literal|1
index|]
return|;
block|}
comment|/**    * Separate elements of a regionName.    * @param regionName    * @return Array of byte[] containing tableName, startKey and id    * @throws IOException    */
specifier|public
specifier|static
name|byte
index|[]
index|[]
name|parseRegionName
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|offset
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|regionName
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regionName
index|[
name|i
index|]
operator|==
name|HConstants
operator|.
name|DELIMITER
condition|)
block|{
name|offset
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|offset
operator|==
operator|-
literal|1
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid regionName format"
argument_list|)
throw|;
name|byte
index|[]
name|tableName
init|=
operator|new
name|byte
index|[
name|offset
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|regionName
argument_list|,
literal|0
argument_list|,
name|tableName
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|regionName
operator|.
name|length
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|regionName
index|[
name|i
index|]
operator|==
name|HConstants
operator|.
name|DELIMITER
condition|)
block|{
name|offset
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|offset
operator|==
operator|-
literal|1
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid regionName format"
argument_list|)
throw|;
name|byte
index|[]
name|startKey
init|=
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
decl_stmt|;
if|if
condition|(
name|offset
operator|!=
name|tableName
operator|.
name|length
operator|+
literal|1
condition|)
block|{
name|startKey
operator|=
operator|new
name|byte
index|[
name|offset
operator|-
name|tableName
operator|.
name|length
operator|-
literal|1
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|regionName
argument_list|,
name|tableName
operator|.
name|length
operator|+
literal|1
argument_list|,
name|startKey
argument_list|,
literal|0
argument_list|,
name|offset
operator|-
name|tableName
operator|.
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|id
init|=
operator|new
name|byte
index|[
name|regionName
operator|.
name|length
operator|-
name|offset
operator|-
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|regionName
argument_list|,
name|offset
operator|+
literal|1
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
name|regionName
operator|.
name|length
operator|-
name|offset
operator|-
literal|1
argument_list|)
expr_stmt|;
name|byte
index|[]
index|[]
name|elements
init|=
operator|new
name|byte
index|[
literal|3
index|]
index|[]
decl_stmt|;
name|elements
index|[
literal|0
index|]
operator|=
name|tableName
expr_stmt|;
name|elements
index|[
literal|1
index|]
operator|=
name|startKey
expr_stmt|;
name|elements
index|[
literal|2
index|]
operator|=
name|id
expr_stmt|;
return|return
name|elements
return|;
block|}
comment|/** @return the regionId */
specifier|public
name|long
name|getRegionId
parameter_list|()
block|{
return|return
name|regionId
return|;
block|}
comment|/**    * @return the regionName as an array of bytes.    * @see #getRegionNameAsString()    */
specifier|public
name|byte
index|[]
name|getRegionName
parameter_list|()
block|{
return|return
name|regionName
return|;
block|}
comment|/**    * @return Region name as a String for use in logging, etc.    */
specifier|public
name|String
name|getRegionNameAsString
parameter_list|()
block|{
if|if
condition|(
name|hasEncodedName
argument_list|(
name|this
operator|.
name|regionName
argument_list|)
condition|)
block|{
comment|// new format region names already have their encoded name.
return|return
name|this
operator|.
name|regionNameStr
return|;
block|}
comment|// old format. regionNameStr doesn't have the region name.
comment|//
comment|//
return|return
name|this
operator|.
name|regionNameStr
operator|+
literal|"."
operator|+
name|this
operator|.
name|getEncodedName
argument_list|()
return|;
block|}
comment|/** @return the encoded region name */
specifier|public
specifier|synchronized
name|String
name|getEncodedName
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|encodedName
operator|==
name|NO_HASH
condition|)
block|{
name|this
operator|.
name|encodedName
operator|=
name|encodeRegionName
argument_list|(
name|this
operator|.
name|regionName
argument_list|)
expr_stmt|;
block|}
return|return
name|this
operator|.
name|encodedName
return|;
block|}
specifier|public
specifier|synchronized
name|byte
index|[]
name|getEncodedNameAsBytes
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|encodedNameAsBytes
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|encodedNameAsBytes
operator|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|this
operator|.
name|encodedNameAsBytes
return|;
block|}
comment|/** @return the startKey */
specifier|public
name|byte
index|[]
name|getStartKey
parameter_list|()
block|{
return|return
name|startKey
return|;
block|}
comment|/** @return the endKey */
specifier|public
name|byte
index|[]
name|getEndKey
parameter_list|()
block|{
return|return
name|endKey
return|;
block|}
comment|/**    * Get current table name of the region    * @return byte array of table name    */
specifier|public
name|byte
index|[]
name|getTableName
parameter_list|()
block|{
if|if
condition|(
name|tableName
operator|==
literal|null
operator|||
name|tableName
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|tableName
operator|=
name|getTableName
argument_list|(
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|tableName
return|;
block|}
comment|/**    * Get current table name as string    * @return string representation of current table    */
specifier|public
name|String
name|getTableNameAsString
parameter_list|()
block|{
if|if
condition|(
name|tableNameAsString
operator|==
literal|null
condition|)
block|{
name|tableNameAsString
operator|=
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
return|return
name|tableNameAsString
return|;
block|}
comment|/**    * Returns true if the given inclusive range of rows is fully contained    * by this region. For example, if the region is foo,a,g and this is    * passed ["b","c"] or ["a","c"] it will return true, but if this is passed    * ["b","z"] it will return false.    * @throws IllegalArgumentException if the range passed is invalid (ie end< start)    */
specifier|public
name|boolean
name|containsRange
parameter_list|(
name|byte
index|[]
name|rangeStartKey
parameter_list|,
name|byte
index|[]
name|rangeEndKey
parameter_list|)
block|{
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|rangeStartKey
argument_list|,
name|rangeEndKey
argument_list|)
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid range: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|rangeStartKey
argument_list|)
operator|+
literal|"> "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|rangeEndKey
argument_list|)
argument_list|)
throw|;
block|}
name|boolean
name|firstKeyInRange
init|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|rangeStartKey
argument_list|,
name|startKey
argument_list|)
operator|>=
literal|0
decl_stmt|;
name|boolean
name|lastKeyInRange
init|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|rangeEndKey
argument_list|,
name|endKey
argument_list|)
operator|<
literal|0
operator|||
name|Bytes
operator|.
name|equals
argument_list|(
name|endKey
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|)
decl_stmt|;
return|return
name|firstKeyInRange
operator|&&
name|lastKeyInRange
return|;
block|}
comment|/**    * Return true if the given row falls in this region.    */
specifier|public
name|boolean
name|containsRow
parameter_list|(
name|byte
index|[]
name|row
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|row
argument_list|,
name|startKey
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|row
argument_list|,
name|endKey
argument_list|)
operator|<
literal|0
operator|||
name|Bytes
operator|.
name|equals
argument_list|(
name|endKey
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|)
operator|)
return|;
block|}
comment|/**    * @return true if this region is from .META.    */
specifier|public
name|boolean
name|isMetaTable
parameter_list|()
block|{
return|return
name|isMetaRegion
argument_list|()
return|;
block|}
comment|/** @return true if this region is a meta region */
specifier|public
name|boolean
name|isMetaRegion
parameter_list|()
block|{
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|tableName
argument_list|,
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
operator|.
name|getTableName
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @return True if has been split and has daughters.    */
specifier|public
name|boolean
name|isSplit
parameter_list|()
block|{
return|return
name|this
operator|.
name|split
return|;
block|}
comment|/**    * @param split set split status    */
specifier|public
name|void
name|setSplit
parameter_list|(
name|boolean
name|split
parameter_list|)
block|{
name|this
operator|.
name|split
operator|=
name|split
expr_stmt|;
block|}
comment|/**    * @return True if this region is offline.    */
specifier|public
name|boolean
name|isOffline
parameter_list|()
block|{
return|return
name|this
operator|.
name|offLine
return|;
block|}
comment|/**    * The parent of a region split is offline while split daughters hold    * references to the parent. Offlined regions are closed.    * @param offLine Set online/offline status.    */
specifier|public
name|void
name|setOffline
parameter_list|(
name|boolean
name|offLine
parameter_list|)
block|{
name|this
operator|.
name|offLine
operator|=
name|offLine
expr_stmt|;
block|}
comment|/**    * @return True if this is a split parent region.    */
specifier|public
name|boolean
name|isSplitParent
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isSplit
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|isOffline
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Region is split but NOT offline: "
operator|+
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * @see java.lang.Object#toString()    */
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"{"
operator|+
name|HConstants
operator|.
name|NAME
operator|+
literal|" => '"
operator|+
name|this
operator|.
name|regionNameStr
operator|+
literal|"', STARTKEY => '"
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|this
operator|.
name|startKey
argument_list|)
operator|+
literal|"', ENDKEY => '"
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|this
operator|.
name|endKey
argument_list|)
operator|+
literal|"', ENCODED => "
operator|+
name|getEncodedName
argument_list|()
operator|+
literal|","
operator|+
operator|(
name|isOffline
argument_list|()
condition|?
literal|" OFFLINE => true,"
else|:
literal|""
operator|)
operator|+
operator|(
name|isSplit
argument_list|()
condition|?
literal|" SPLIT => true,"
else|:
literal|""
operator|)
operator|+
literal|"}"
return|;
block|}
comment|/**    * @see java.lang.Object#equals(java.lang.Object)    */
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|HRegionInfo
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|this
operator|.
name|compareTo
argument_list|(
operator|(
name|HRegionInfo
operator|)
name|o
argument_list|)
operator|==
literal|0
return|;
block|}
comment|/**    * @see java.lang.Object#hashCode()    */
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|this
operator|.
name|hashCode
return|;
block|}
comment|/** @return the object version number    * @deprecated HRI is no longer a VersionedWritable */
annotation|@
name|Deprecated
specifier|public
name|byte
name|getVersion
parameter_list|()
block|{
return|return
name|VERSION
return|;
block|}
comment|/**    * @deprecated Use protobuf serialization instead.  See {@link #toByteArray()} and    * {@link #toDelimitedByteArray()}    */
annotation|@
name|Deprecated
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|writeByte
argument_list|(
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
name|Bytes
operator|.
name|writeByteArray
argument_list|(
name|out
argument_list|,
name|endKey
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBoolean
argument_list|(
name|offLine
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeLong
argument_list|(
name|regionId
argument_list|)
expr_stmt|;
name|Bytes
operator|.
name|writeByteArray
argument_list|(
name|out
argument_list|,
name|regionName
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBoolean
argument_list|(
name|split
argument_list|)
expr_stmt|;
name|Bytes
operator|.
name|writeByteArray
argument_list|(
name|out
argument_list|,
name|startKey
argument_list|)
expr_stmt|;
name|Bytes
operator|.
name|writeByteArray
argument_list|(
name|out
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|hashCode
argument_list|)
expr_stmt|;
block|}
comment|/**    * @deprecated Use protobuf deserialization instead.    * @see #parseFrom(byte[])    */
annotation|@
name|Deprecated
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Read the single version byte.  We don't ask the super class do it
comment|// because freaks out if its not the current classes' version.  This method
comment|// can deserialize version 0 and version 1 of HRI.
name|byte
name|version
init|=
name|in
operator|.
name|readByte
argument_list|()
decl_stmt|;
if|if
condition|(
name|version
operator|==
literal|0
condition|)
block|{
comment|// This is the old HRI that carried an HTD.  Migrate it.  The below
comment|// was copied from the old 0.90 HRI readFields.
name|this
operator|.
name|endKey
operator|=
name|Bytes
operator|.
name|readByteArray
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|this
operator|.
name|offLine
operator|=
name|in
operator|.
name|readBoolean
argument_list|()
expr_stmt|;
name|this
operator|.
name|regionId
operator|=
name|in
operator|.
name|readLong
argument_list|()
expr_stmt|;
name|this
operator|.
name|regionName
operator|=
name|Bytes
operator|.
name|readByteArray
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionNameStr
operator|=
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|this
operator|.
name|regionName
argument_list|)
expr_stmt|;
name|this
operator|.
name|split
operator|=
name|in
operator|.
name|readBoolean
argument_list|()
expr_stmt|;
name|this
operator|.
name|startKey
operator|=
name|Bytes
operator|.
name|readByteArray
argument_list|(
name|in
argument_list|)
expr_stmt|;
try|try
block|{
name|HTableDescriptor
name|htd
init|=
operator|new
name|HTableDescriptor
argument_list|()
decl_stmt|;
name|htd
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableName
operator|=
name|htd
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|eofe
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"HTD not found in input buffer"
argument_list|,
name|eofe
argument_list|)
throw|;
block|}
name|this
operator|.
name|hashCode
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|getVersion
argument_list|()
operator|==
name|version
condition|)
block|{
name|this
operator|.
name|endKey
operator|=
name|Bytes
operator|.
name|readByteArray
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|this
operator|.
name|offLine
operator|=
name|in
operator|.
name|readBoolean
argument_list|()
expr_stmt|;
name|this
operator|.
name|regionId
operator|=
name|in
operator|.
name|readLong
argument_list|()
expr_stmt|;
name|this
operator|.
name|regionName
operator|=
name|Bytes
operator|.
name|readByteArray
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionNameStr
operator|=
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|this
operator|.
name|regionName
argument_list|)
expr_stmt|;
name|this
operator|.
name|split
operator|=
name|in
operator|.
name|readBoolean
argument_list|()
expr_stmt|;
name|this
operator|.
name|startKey
operator|=
name|Bytes
operator|.
name|readByteArray
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableName
operator|=
name|Bytes
operator|.
name|readByteArray
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|this
operator|.
name|hashCode
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Non-migratable/unknown version="
operator|+
name|getVersion
argument_list|()
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Deprecated
specifier|private
name|void
name|readFields
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|bytes
operator|==
literal|null
operator|||
name|bytes
operator|.
name|length
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Can't build a writable with empty "
operator|+
literal|"bytes array"
argument_list|)
throw|;
block|}
name|DataInputBuffer
name|in
init|=
operator|new
name|DataInputBuffer
argument_list|()
decl_stmt|;
try|try
block|{
name|in
operator|.
name|reset
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|this
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|//
comment|// Comparable
comment|//
specifier|public
name|int
name|compareTo
parameter_list|(
name|HRegionInfo
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|// Are regions of same table?
name|int
name|result
init|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|this
operator|.
name|tableName
argument_list|,
name|o
operator|.
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
comment|// Compare start keys.
name|result
operator|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|this
operator|.
name|startKey
argument_list|,
name|o
operator|.
name|startKey
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
comment|// Compare end keys.
name|result
operator|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|this
operator|.
name|endKey
argument_list|,
name|o
operator|.
name|endKey
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|getStartKey
argument_list|()
operator|.
name|length
operator|!=
literal|0
operator|&&
name|this
operator|.
name|getEndKey
argument_list|()
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
comment|// this is last region
block|}
if|if
condition|(
name|o
operator|.
name|getStartKey
argument_list|()
operator|.
name|length
operator|!=
literal|0
operator|&&
name|o
operator|.
name|getEndKey
argument_list|()
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
comment|// o is the last region
block|}
return|return
name|result
return|;
block|}
comment|// regionId is usually milli timestamp -- this defines older stamps
comment|// to be "smaller" than newer stamps in sort order.
if|if
condition|(
name|this
operator|.
name|regionId
operator|>
name|o
operator|.
name|regionId
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|this
operator|.
name|regionId
operator|<
name|o
operator|.
name|regionId
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|this
operator|.
name|offLine
operator|==
name|o
operator|.
name|offLine
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|this
operator|.
name|offLine
operator|==
literal|true
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
comment|/**    * @return Comparator to use comparing {@link KeyValue}s.    */
specifier|public
name|KVComparator
name|getComparator
parameter_list|()
block|{
return|return
name|isMetaRegion
argument_list|()
condition|?
name|KeyValue
operator|.
name|META_COMPARATOR
else|:
name|KeyValue
operator|.
name|COMPARATOR
return|;
block|}
comment|/**    * Convert a HRegionInfo to a RegionInfo    *    * @return the converted RegionInfo    */
name|RegionInfo
name|convert
parameter_list|()
block|{
return|return
name|convert
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * Convert a HRegionInfo to a RegionInfo    *    * @param info the HRegionInfo to convert    * @return the converted RegionInfo    */
specifier|public
specifier|static
name|RegionInfo
name|convert
parameter_list|(
specifier|final
name|HRegionInfo
name|info
parameter_list|)
block|{
if|if
condition|(
name|info
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|RegionInfo
operator|.
name|Builder
name|builder
init|=
name|RegionInfo
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|setTableName
argument_list|(
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|info
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setRegionId
argument_list|(
name|info
operator|.
name|getRegionId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|getStartKey
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setStartKey
argument_list|(
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|info
operator|.
name|getStartKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|.
name|getEndKey
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setEndKey
argument_list|(
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|info
operator|.
name|getEndKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|setOffline
argument_list|(
name|info
operator|.
name|isOffline
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setSplit
argument_list|(
name|info
operator|.
name|isSplit
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Convert a RegionInfo to a HRegionInfo    *    * @param proto the RegionInfo to convert    * @return the converted HRegionInfo    */
specifier|public
specifier|static
name|HRegionInfo
name|convert
parameter_list|(
specifier|final
name|RegionInfo
name|proto
parameter_list|)
block|{
if|if
condition|(
name|proto
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|byte
index|[]
name|tableName
init|=
name|proto
operator|.
name|getTableName
argument_list|()
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|tableName
argument_list|,
name|HConstants
operator|.
name|META_TABLE_NAME
argument_list|)
condition|)
block|{
return|return
name|FIRST_META_REGIONINFO
return|;
block|}
name|long
name|regionId
init|=
name|proto
operator|.
name|getRegionId
argument_list|()
decl_stmt|;
name|byte
index|[]
name|startKey
init|=
literal|null
decl_stmt|;
name|byte
index|[]
name|endKey
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|proto
operator|.
name|hasStartKey
argument_list|()
condition|)
block|{
name|startKey
operator|=
name|proto
operator|.
name|getStartKey
argument_list|()
operator|.
name|toByteArray
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|proto
operator|.
name|hasEndKey
argument_list|()
condition|)
block|{
name|endKey
operator|=
name|proto
operator|.
name|getEndKey
argument_list|()
operator|.
name|toByteArray
argument_list|()
expr_stmt|;
block|}
name|boolean
name|split
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|proto
operator|.
name|hasSplit
argument_list|()
condition|)
block|{
name|split
operator|=
name|proto
operator|.
name|getSplit
argument_list|()
expr_stmt|;
block|}
name|HRegionInfo
name|hri
init|=
operator|new
name|HRegionInfo
argument_list|(
name|tableName
argument_list|,
name|startKey
argument_list|,
name|endKey
argument_list|,
name|split
argument_list|,
name|regionId
argument_list|)
decl_stmt|;
if|if
condition|(
name|proto
operator|.
name|hasOffline
argument_list|()
condition|)
block|{
name|hri
operator|.
name|setOffline
argument_list|(
name|proto
operator|.
name|getOffline
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|hri
return|;
block|}
comment|/**    * @return This instance serialized as protobuf w/ a magic pb prefix.    * @see #parseFrom(byte[])    */
specifier|public
name|byte
index|[]
name|toByteArray
parameter_list|()
block|{
name|byte
index|[]
name|bytes
init|=
name|convert
argument_list|()
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
return|return
name|ProtobufUtil
operator|.
name|prependPBMagic
argument_list|(
name|bytes
argument_list|)
return|;
block|}
comment|/**    * @param bytes    * @return A deserialized {@link HRegionInfo} or null if we failed deserialize or passed bytes null    * @see #toByteArray()    */
specifier|public
specifier|static
name|HRegionInfo
name|parseFromOrNull
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|)
block|{
if|if
condition|(
name|bytes
operator|==
literal|null
operator|||
name|bytes
operator|.
name|length
operator|<=
literal|0
condition|)
return|return
literal|null
return|;
try|try
block|{
return|return
name|parseFrom
argument_list|(
name|bytes
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * @param bytes A pb RegionInfo serialized with a pb magic prefix.    * @return A deserialized {@link HRegionInfo}    * @throws DeserializationException    * @see #toByteArray()    */
specifier|public
specifier|static
name|HRegionInfo
name|parseFrom
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|)
throws|throws
name|DeserializationException
block|{
if|if
condition|(
name|ProtobufUtil
operator|.
name|isPBMagicPrefix
argument_list|(
name|bytes
argument_list|)
condition|)
block|{
name|int
name|pblen
init|=
name|ProtobufUtil
operator|.
name|lengthOfPBMagic
argument_list|()
decl_stmt|;
try|try
block|{
name|HBaseProtos
operator|.
name|RegionInfo
name|ri
init|=
name|HBaseProtos
operator|.
name|RegionInfo
operator|.
name|newBuilder
argument_list|()
operator|.
name|mergeFrom
argument_list|(
name|bytes
argument_list|,
name|pblen
argument_list|,
name|bytes
operator|.
name|length
operator|-
name|pblen
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|convert
argument_list|(
name|ri
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InvalidProtocolBufferException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DeserializationException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
try|try
block|{
name|HRegionInfo
name|hri
init|=
operator|new
name|HRegionInfo
argument_list|()
decl_stmt|;
name|hri
operator|.
name|readFields
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
return|return
name|hri
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DeserializationException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Use this instead of {@link #toByteArray()} when writing to a stream and you want to use    * the pb mergeDelimitedFrom (w/o the delimiter, pb reads to EOF which may not be what you want).    * @return This instance serialized as a delimited protobuf w/ a magic pb prefix.    * @throws IOException    * @see #toByteArray()    */
specifier|public
name|byte
index|[]
name|toDelimitedByteArray
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|ProtobufUtil
operator|.
name|toDelimitedByteArray
argument_list|(
name|convert
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Extract a HRegionInfo and ServerName from catalog table {@link Result}.    * @param r Result to pull from    * @return A pair of the {@link HRegionInfo} and the {@link ServerName}    * (or null for server address if no address set in .META.).    * @throws IOException    */
specifier|public
specifier|static
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|getHRegionInfoAndServerName
parameter_list|(
specifier|final
name|Result
name|r
parameter_list|)
block|{
name|HRegionInfo
name|info
init|=
name|getHRegionInfo
argument_list|(
name|r
argument_list|,
name|HConstants
operator|.
name|REGIONINFO_QUALIFIER
argument_list|)
decl_stmt|;
name|ServerName
name|sn
init|=
name|getServerName
argument_list|(
name|r
argument_list|)
decl_stmt|;
return|return
operator|new
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|(
name|info
argument_list|,
name|sn
argument_list|)
return|;
block|}
comment|/**    * Returns HRegionInfo object from the column    * HConstants.CATALOG_FAMILY:HConstants.REGIONINFO_QUALIFIER of the catalog    * table Result.    * @param data a Result object from the catalog table scan    * @return HRegionInfo or null    */
specifier|public
specifier|static
name|HRegionInfo
name|getHRegionInfo
parameter_list|(
name|Result
name|data
parameter_list|)
block|{
name|byte
index|[]
name|bytes
init|=
name|data
operator|.
name|getValue
argument_list|(
name|HConstants
operator|.
name|CATALOG_FAMILY
argument_list|,
name|HConstants
operator|.
name|REGIONINFO_QUALIFIER
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|HRegionInfo
name|info
init|=
name|parseFromOrNull
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
return|return
name|info
return|;
block|}
comment|/**    * Returns the daughter regions by reading the corresponding columns of the catalog table    * Result.    * @param data a Result object from the catalog table scan    * @return a pair of HRegionInfo or PairOfSameType(null, null) if the region is not a split    * parent    */
specifier|public
specifier|static
name|PairOfSameType
argument_list|<
name|HRegionInfo
argument_list|>
name|getDaughterRegions
parameter_list|(
name|Result
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegionInfo
name|splitA
init|=
name|getHRegionInfo
argument_list|(
name|data
argument_list|,
name|HConstants
operator|.
name|SPLITA_QUALIFIER
argument_list|)
decl_stmt|;
name|HRegionInfo
name|splitB
init|=
name|getHRegionInfo
argument_list|(
name|data
argument_list|,
name|HConstants
operator|.
name|SPLITB_QUALIFIER
argument_list|)
decl_stmt|;
return|return
operator|new
name|PairOfSameType
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|(
name|splitA
argument_list|,
name|splitB
argument_list|)
return|;
block|}
comment|/**    * Returns the HRegionInfo object from the column {@link HConstants#CATALOG_FAMILY} and    *<code>qualifier</code> of the catalog table result.    * @param r a Result object from the catalog table scan    * @param qualifier Column family qualifier -- either    * {@link HConstants#SPLITA_QUALIFIER}, {@link HConstants#SPLITB_QUALIFIER} or    * {@link HConstants#REGIONINFO_QUALIFIER}.    * @return An HRegionInfo instance or null.    * @throws IOException    */
specifier|public
specifier|static
name|HRegionInfo
name|getHRegionInfo
parameter_list|(
specifier|final
name|Result
name|r
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
name|byte
index|[]
name|bytes
init|=
name|r
operator|.
name|getValue
argument_list|(
name|HConstants
operator|.
name|CATALOG_FAMILY
argument_list|,
name|qualifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|null
operator|||
name|bytes
operator|.
name|length
operator|<=
literal|0
condition|)
return|return
literal|null
return|;
return|return
name|parseFromOrNull
argument_list|(
name|bytes
argument_list|)
return|;
block|}
comment|/**    * Returns a {@link ServerName} from catalog table {@link Result}.    * @param r Result to pull from    * @return A ServerName instance or null if necessary fields not found or empty.    */
specifier|public
specifier|static
name|ServerName
name|getServerName
parameter_list|(
specifier|final
name|Result
name|r
parameter_list|)
block|{
name|byte
index|[]
name|value
init|=
name|r
operator|.
name|getValue
argument_list|(
name|HConstants
operator|.
name|CATALOG_FAMILY
argument_list|,
name|HConstants
operator|.
name|SERVER_QUALIFIER
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
operator|||
name|value
operator|.
name|length
operator|==
literal|0
condition|)
return|return
literal|null
return|;
name|String
name|hostAndPort
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|value
operator|=
name|r
operator|.
name|getValue
argument_list|(
name|HConstants
operator|.
name|CATALOG_FAMILY
argument_list|,
name|HConstants
operator|.
name|STARTCODE_QUALIFIER
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
operator|||
name|value
operator|.
name|length
operator|==
literal|0
condition|)
return|return
literal|null
return|;
return|return
operator|new
name|ServerName
argument_list|(
name|hostAndPort
argument_list|,
name|Bytes
operator|.
name|toLong
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * The latest seqnum that the server writing to meta observed when opening the region.    * E.g. the seqNum when the result of {@link #getServerName(Result)} was written.    * @param r Result to pull the seqNum from    * @return SeqNum, or HConstants.NO_SEQNUM if there's no value written.    */
specifier|public
specifier|static
name|long
name|getSeqNumDuringOpen
parameter_list|(
specifier|final
name|Result
name|r
parameter_list|)
block|{
name|byte
index|[]
name|value
init|=
name|r
operator|.
name|getValue
argument_list|(
name|HConstants
operator|.
name|CATALOG_FAMILY
argument_list|,
name|HConstants
operator|.
name|SEQNUM_QUALIFIER
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
operator|||
name|value
operator|.
name|length
operator|==
literal|0
condition|)
return|return
name|HConstants
operator|.
name|NO_SEQNUM
return|;
name|Long
name|result
init|=
name|Bytes
operator|.
name|toLong
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
return|return
name|HConstants
operator|.
name|NO_SEQNUM
return|;
return|return
name|result
operator|.
name|longValue
argument_list|()
return|;
block|}
comment|/**    * Parses an HRegionInfo instance from the passed in stream.  Presumes the HRegionInfo was    * serialized to the stream with {@link #toDelimitedByteArray()}    * @param in    * @return An instance of HRegionInfo.    * @throws IOException    */
specifier|public
specifier|static
name|HRegionInfo
name|parseFrom
parameter_list|(
specifier|final
name|DataInputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
comment|// I need to be able to move back in the stream if this is not a pb serialization so I can
comment|// do the Writable decoding instead.
name|int
name|pblen
init|=
name|ProtobufUtil
operator|.
name|lengthOfPBMagic
argument_list|()
decl_stmt|;
name|byte
index|[]
name|pbuf
init|=
operator|new
name|byte
index|[
name|pblen
index|]
decl_stmt|;
if|if
condition|(
name|in
operator|.
name|markSupported
argument_list|()
condition|)
block|{
comment|//read it with mark()
name|in
operator|.
name|mark
argument_list|(
name|pblen
argument_list|)
expr_stmt|;
block|}
name|int
name|read
init|=
name|in
operator|.
name|read
argument_list|(
name|pbuf
argument_list|)
decl_stmt|;
comment|//assumption: if Writable serialization, it should be longer than pblen.
if|if
condition|(
name|read
operator|!=
name|pblen
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"read="
operator|+
name|read
operator|+
literal|", wanted="
operator|+
name|pblen
argument_list|)
throw|;
if|if
condition|(
name|ProtobufUtil
operator|.
name|isPBMagicPrefix
argument_list|(
name|pbuf
argument_list|)
condition|)
block|{
return|return
name|convert
argument_list|(
name|HBaseProtos
operator|.
name|RegionInfo
operator|.
name|parseDelimitedFrom
argument_list|(
name|in
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
comment|// Presume Writables.  Need to reset the stream since it didn't start w/ pb.
if|if
condition|(
name|in
operator|.
name|markSupported
argument_list|()
condition|)
block|{
name|in
operator|.
name|reset
argument_list|()
expr_stmt|;
name|HRegionInfo
name|hri
init|=
operator|new
name|HRegionInfo
argument_list|()
decl_stmt|;
name|hri
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
name|hri
return|;
block|}
else|else
block|{
comment|//we cannot use BufferedInputStream, it consumes more than we read from the underlying IS
name|ByteArrayInputStream
name|bais
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|pbuf
argument_list|)
decl_stmt|;
name|SequenceInputStream
name|sis
init|=
operator|new
name|SequenceInputStream
argument_list|(
name|bais
argument_list|,
name|in
argument_list|)
decl_stmt|;
comment|//concatenate input streams
name|HRegionInfo
name|hri
init|=
operator|new
name|HRegionInfo
argument_list|()
decl_stmt|;
name|hri
operator|.
name|readFields
argument_list|(
operator|new
name|DataInputStream
argument_list|(
name|sis
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|hri
return|;
block|}
block|}
block|}
comment|/**    * Serializes given HRegionInfo's as a byte array. Use this instead of {@link #toByteArray()} when    * writing to a stream and you want to use the pb mergeDelimitedFrom (w/o the delimiter, pb reads    * to EOF which may not be what you want). {@link #parseDelimitedFrom(byte[], int, int)} can    * be used to read back the instances.    * @param infos HRegionInfo objects to serialize    * @return This instance serialized as a delimited protobuf w/ a magic pb prefix.    * @throws IOException    * @see #toByteArray()    */
specifier|public
specifier|static
name|byte
index|[]
name|toDelimitedByteArray
parameter_list|(
name|HRegionInfo
modifier|...
name|infos
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|infos
operator|.
name|length
index|]
index|[]
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|infos
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|bytes
index|[
name|i
index|]
operator|=
name|infos
index|[
name|i
index|]
operator|.
name|toDelimitedByteArray
argument_list|()
expr_stmt|;
name|size
operator|+=
name|bytes
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
block|}
name|byte
index|[]
name|result
init|=
operator|new
name|byte
index|[
name|size
index|]
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|b
range|:
name|bytes
control|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|result
argument_list|,
name|offset
argument_list|,
name|b
operator|.
name|length
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|b
operator|.
name|length
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Parses all the HRegionInfo instances from the passed in stream until EOF. Presumes the    * HRegionInfo's were serialized to the stream with {@link #toDelimitedByteArray()}    * @param bytes serialized bytes    * @param offset the start offset into the byte[] buffer    * @param length how far we should read into the byte[] buffer    * @return All the hregioninfos that are in the byte array. Keeps reading till we hit the end.    */
specifier|public
specifier|static
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|parseDelimitedFrom
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|bytes
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Can't build an object with empty bytes array"
argument_list|)
throw|;
block|}
name|DataInputBuffer
name|in
init|=
operator|new
name|DataInputBuffer
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|hris
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|in
operator|.
name|reset
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
while|while
condition|(
name|in
operator|.
name|available
argument_list|()
operator|>
literal|0
condition|)
block|{
name|HRegionInfo
name|hri
init|=
name|parseFrom
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|hris
operator|.
name|add
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|hris
return|;
block|}
comment|/**    * Check whether two regions are adjacent    * @param regionA    * @param regionB    * @return true if two regions are adjacent    */
specifier|public
specifier|static
name|boolean
name|areAdjacent
parameter_list|(
name|HRegionInfo
name|regionA
parameter_list|,
name|HRegionInfo
name|regionB
parameter_list|)
block|{
if|if
condition|(
name|regionA
operator|==
literal|null
operator|||
name|regionB
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Can't check whether adjacent for null region"
argument_list|)
throw|;
block|}
name|HRegionInfo
name|a
init|=
name|regionA
decl_stmt|;
name|HRegionInfo
name|b
init|=
name|regionB
decl_stmt|;
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|a
operator|.
name|getStartKey
argument_list|()
argument_list|,
name|b
operator|.
name|getStartKey
argument_list|()
argument_list|)
operator|>
literal|0
condition|)
block|{
name|a
operator|=
name|regionB
expr_stmt|;
name|b
operator|=
name|regionA
expr_stmt|;
block|}
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|a
operator|.
name|getEndKey
argument_list|()
argument_list|,
name|b
operator|.
name|getStartKey
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
end_class

end_unit

