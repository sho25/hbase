begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
operator|.
name|KVComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionInfoBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionInfoDisplay
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|DeserializationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|RegionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|DataInputBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
import|;
end_import

begin_comment
comment|/**  * Information about a region. A region is a range of keys in the whole keyspace of a table, an  * identifier (a timestamp) for differentiating between subset ranges (after region split)  * and a replicaId for differentiating the instance for the same range and some status information  * about the region.  *  * The region has a unique name which consists of the following fields:  *<ul>  *<li> tableName   : The name of the table</li>  *<li> startKey    : The startKey for the region.</li>  *<li> regionId    : A timestamp when the region is created.</li>  *<li> replicaId   : An id starting from 0 to differentiate replicas of the same region range  * but hosted in separated servers. The same region range can be hosted in multiple locations.</li>  *<li> encodedName : An MD5 encoded string for the region name.</li>  *</ul>  *  *<br> Other than the fields in the region name, region info contains:  *<ul>  *<li> endKey      : the endKey for the region (exclusive)</li>  *<li> split       : Whether the region is split</li>  *<li> offline     : Whether the region is offline</li>  *</ul>  *  * In 0.98 or before, a list of table's regions would fully cover the total keyspace, and at any  * point in time, a row key always belongs to a single region, which is hosted in a single server.  * In 0.99+, a region can have multiple instances (called replicas), and thus a range (or row) can  * correspond to multiple HRegionInfo's. These HRI's share the same fields however except the  * replicaId field. If the replicaId is not set, it defaults to 0, which is compatible with the  * previous behavior of a range corresponding to 1 region.  * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0.  *             use {@link RegionInfoBuilder} to build {@link RegionInfo}.  */
end_comment

begin_class
annotation|@
name|Deprecated
annotation|@
name|InterfaceAudience
operator|.
name|Public
specifier|public
class|class
name|HRegionInfo
implements|implements
name|RegionInfo
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|HRegionInfo
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * The new format for a region name contains its encodedName at the end.    * The encoded name also serves as the directory name for the region    * in the filesystem.    *    * New region name format:    *&lt;tablename>,,&lt;startkey>,&lt;regionIdTimestamp>.&lt;encodedName>.    * where,    *&lt;encodedName> is a hex version of the MD5 hash of    *&lt;tablename>,&lt;startkey>,&lt;regionIdTimestamp>    *    * The old region name format:    *&lt;tablename>,&lt;startkey>,&lt;regionIdTimestamp>    * For region names in the old format, the encoded name is a 32-bit    * JenkinsHash integer value (in its decimal notation, string form).    *<p>    * **NOTE**    *    * The first hbase:meta region, and regions created by an older    * version of HBase (0.20 or prior) will continue to use the    * old region name format.    */
comment|/** A non-capture group so that this can be embedded. */
specifier|public
specifier|static
specifier|final
name|String
name|ENCODED_REGION_NAME_REGEX
init|=
name|RegionInfoBuilder
operator|.
name|ENCODED_REGION_NAME_REGEX
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|MAX_REPLICA_ID
init|=
literal|0xFFFF
decl_stmt|;
comment|/**    * @param regionName    * @return the encodedName    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use {@link org.apache.hadoop.hbase.client.RegionInfo#encodeRegionName(byte[])}.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|String
name|encodeRegionName
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
block|{
return|return
name|RegionInfo
operator|.
name|encodeRegionName
argument_list|(
name|regionName
argument_list|)
return|;
block|}
comment|/**    * @return Return a short, printable name for this region (usually encoded name) for us logging.    */
annotation|@
name|Override
specifier|public
name|String
name|getShortNameToLog
parameter_list|()
block|{
return|return
name|prettyPrint
argument_list|(
name|this
operator|.
name|getEncodedName
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use {@link org.apache.hadoop.hbase.client.RegionInfo#getShortNameToLog(RegionInfo...)}.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|String
name|getShortNameToLog
parameter_list|(
name|HRegionInfo
modifier|...
name|hris
parameter_list|)
block|{
return|return
name|RegionInfo
operator|.
name|getShortNameToLog
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|hris
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @return Return a String of short, printable names for<code>hris</code>    * (usually encoded name) for us logging.    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use {@link org.apache.hadoop.hbase.client.RegionInfo#getShortNameToLog(List)})}.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|String
name|getShortNameToLog
parameter_list|(
specifier|final
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|hris
parameter_list|)
block|{
return|return
name|RegionInfo
operator|.
name|getShortNameToLog
argument_list|(
name|hris
operator|.
name|stream
argument_list|()
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Use logging.    * @param encodedRegionName The encoded regionname.    * @return<code>hbase:meta</code> if passed<code>1028785192</code> else returns    *<code>encodedRegionName</code>    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use {@link RegionInfo#prettyPrint(String)}.    */
annotation|@
name|Deprecated
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|static
name|String
name|prettyPrint
parameter_list|(
specifier|final
name|String
name|encodedRegionName
parameter_list|)
block|{
return|return
name|RegionInfo
operator|.
name|prettyPrint
argument_list|(
name|encodedRegionName
argument_list|)
return|;
block|}
specifier|private
name|byte
index|[]
name|endKey
init|=
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
decl_stmt|;
comment|// This flag is in the parent of a split while the parent is still referenced by daughter regions.
comment|// We USED to set this flag when we disabled a table but now table state is kept up in zookeeper
comment|// as of 0.90.0 HBase. And now in DisableTableProcedure, finally we will create bunch of
comment|// UnassignProcedures and at the last of the procedure we will set the region state to CLOSED, and
comment|// will not change the offLine flag.
specifier|private
name|boolean
name|offLine
init|=
literal|false
decl_stmt|;
specifier|private
name|long
name|regionId
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|transient
name|byte
index|[]
name|regionName
init|=
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
decl_stmt|;
specifier|private
name|boolean
name|split
init|=
literal|false
decl_stmt|;
specifier|private
name|byte
index|[]
name|startKey
init|=
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
decl_stmt|;
specifier|private
name|int
name|hashCode
init|=
operator|-
literal|1
decl_stmt|;
comment|//TODO: Move NO_HASH to HStoreFile which is really the only place it is used.
specifier|public
specifier|static
specifier|final
name|String
name|NO_HASH
init|=
literal|null
decl_stmt|;
specifier|private
name|String
name|encodedName
init|=
literal|null
decl_stmt|;
specifier|private
name|byte
index|[]
name|encodedNameAsBytes
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|replicaId
init|=
name|DEFAULT_REPLICA_ID
decl_stmt|;
comment|// Current TableName
specifier|private
name|TableName
name|tableName
init|=
literal|null
decl_stmt|;
comment|// Duplicated over in RegionInfoDisplay
specifier|final
specifier|static
name|String
name|DISPLAY_KEYS_KEY
init|=
name|RegionInfoDisplay
operator|.
name|DISPLAY_KEYS_KEY
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
index|[]
name|HIDDEN_END_KEY
init|=
name|RegionInfoDisplay
operator|.
name|HIDDEN_END_KEY
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|byte
index|[]
name|HIDDEN_START_KEY
init|=
name|RegionInfoDisplay
operator|.
name|HIDDEN_START_KEY
decl_stmt|;
comment|/** HRegionInfo for first meta region */
comment|// TODO: How come Meta regions still do not have encoded region names? Fix.
specifier|public
specifier|static
specifier|final
name|HRegionInfo
name|FIRST_META_REGIONINFO
init|=
operator|new
name|HRegionInfo
argument_list|(
literal|1L
argument_list|,
name|TableName
operator|.
name|META_TABLE_NAME
argument_list|)
decl_stmt|;
specifier|private
name|void
name|setHashCode
parameter_list|()
block|{
name|int
name|result
init|=
name|Arrays
operator|.
name|hashCode
argument_list|(
name|this
operator|.
name|regionName
argument_list|)
decl_stmt|;
name|result
operator|=
call|(
name|int
call|)
argument_list|(
name|result
operator|^
name|this
operator|.
name|regionId
argument_list|)
expr_stmt|;
name|result
operator|^=
name|Arrays
operator|.
name|hashCode
argument_list|(
name|this
operator|.
name|startKey
argument_list|)
expr_stmt|;
name|result
operator|^=
name|Arrays
operator|.
name|hashCode
argument_list|(
name|this
operator|.
name|endKey
argument_list|)
expr_stmt|;
name|result
operator|^=
name|Boolean
operator|.
name|valueOf
argument_list|(
name|this
operator|.
name|offLine
argument_list|)
operator|.
name|hashCode
argument_list|()
expr_stmt|;
name|result
operator|^=
name|Arrays
operator|.
name|hashCode
argument_list|(
name|this
operator|.
name|tableName
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|^=
name|this
operator|.
name|replicaId
expr_stmt|;
name|this
operator|.
name|hashCode
operator|=
name|result
expr_stmt|;
block|}
comment|/**    * Private constructor used constructing HRegionInfo for the    * first meta regions    */
specifier|private
name|HRegionInfo
parameter_list|(
name|long
name|regionId
parameter_list|,
name|TableName
name|tableName
parameter_list|)
block|{
name|this
argument_list|(
name|regionId
argument_list|,
name|tableName
argument_list|,
name|DEFAULT_REPLICA_ID
argument_list|)
expr_stmt|;
block|}
specifier|public
name|HRegionInfo
parameter_list|(
name|long
name|regionId
parameter_list|,
name|TableName
name|tableName
parameter_list|,
name|int
name|replicaId
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|regionId
operator|=
name|regionId
expr_stmt|;
name|this
operator|.
name|tableName
operator|=
name|tableName
expr_stmt|;
name|this
operator|.
name|replicaId
operator|=
name|replicaId
expr_stmt|;
comment|// Note: First Meta region replicas names are in old format
name|this
operator|.
name|regionName
operator|=
name|createRegionName
argument_list|(
name|tableName
argument_list|,
literal|null
argument_list|,
name|regionId
argument_list|,
name|replicaId
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|setHashCode
argument_list|()
expr_stmt|;
block|}
specifier|public
name|HRegionInfo
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
block|{
name|this
argument_list|(
name|tableName
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct HRegionInfo with explicit parameters    *    * @param tableName the table name    * @param startKey first key in region    * @param endKey end of key range    * @throws IllegalArgumentException    */
specifier|public
name|HRegionInfo
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|byte
index|[]
name|endKey
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|this
argument_list|(
name|tableName
argument_list|,
name|startKey
argument_list|,
name|endKey
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct HRegionInfo with explicit parameters    *    * @param tableName the table descriptor    * @param startKey first key in region    * @param endKey end of key range    * @param split true if this region has split and we have daughter regions    * regions that may or may not hold references to this region.    * @throws IllegalArgumentException    */
specifier|public
name|HRegionInfo
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|byte
index|[]
name|endKey
parameter_list|,
specifier|final
name|boolean
name|split
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|this
argument_list|(
name|tableName
argument_list|,
name|startKey
argument_list|,
name|endKey
argument_list|,
name|split
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct HRegionInfo with explicit parameters    *    * @param tableName the table descriptor    * @param startKey first key in region    * @param endKey end of key range    * @param split true if this region has split and we have daughter regions    * regions that may or may not hold references to this region.    * @param regionid Region id to use.    * @throws IllegalArgumentException    */
specifier|public
name|HRegionInfo
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|byte
index|[]
name|endKey
parameter_list|,
specifier|final
name|boolean
name|split
parameter_list|,
specifier|final
name|long
name|regionid
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|this
argument_list|(
name|tableName
argument_list|,
name|startKey
argument_list|,
name|endKey
argument_list|,
name|split
argument_list|,
name|regionid
argument_list|,
name|DEFAULT_REPLICA_ID
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct HRegionInfo with explicit parameters    *    * @param tableName the table descriptor    * @param startKey first key in region    * @param endKey end of key range    * @param split true if this region has split and we have daughter regions    * regions that may or may not hold references to this region.    * @param regionid Region id to use.    * @param replicaId the replicaId to use    * @throws IllegalArgumentException    */
specifier|public
name|HRegionInfo
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|byte
index|[]
name|endKey
parameter_list|,
specifier|final
name|boolean
name|split
parameter_list|,
specifier|final
name|long
name|regionid
parameter_list|,
specifier|final
name|int
name|replicaId
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|super
argument_list|()
expr_stmt|;
if|if
condition|(
name|tableName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"TableName cannot be null"
argument_list|)
throw|;
block|}
name|this
operator|.
name|tableName
operator|=
name|tableName
expr_stmt|;
name|this
operator|.
name|offLine
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|regionId
operator|=
name|regionid
expr_stmt|;
name|this
operator|.
name|replicaId
operator|=
name|replicaId
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|replicaId
operator|>
name|MAX_REPLICA_ID
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"ReplicaId cannot be greater than"
operator|+
name|MAX_REPLICA_ID
argument_list|)
throw|;
block|}
name|this
operator|.
name|regionName
operator|=
name|createRegionName
argument_list|(
name|this
operator|.
name|tableName
argument_list|,
name|startKey
argument_list|,
name|regionId
argument_list|,
name|replicaId
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|split
operator|=
name|split
expr_stmt|;
name|this
operator|.
name|endKey
operator|=
name|endKey
operator|==
literal|null
condition|?
name|HConstants
operator|.
name|EMPTY_END_ROW
else|:
name|endKey
operator|.
name|clone
argument_list|()
expr_stmt|;
name|this
operator|.
name|startKey
operator|=
name|startKey
operator|==
literal|null
condition|?
name|HConstants
operator|.
name|EMPTY_START_ROW
else|:
name|startKey
operator|.
name|clone
argument_list|()
expr_stmt|;
name|this
operator|.
name|tableName
operator|=
name|tableName
expr_stmt|;
name|setHashCode
argument_list|()
expr_stmt|;
block|}
comment|/**    * Costruct a copy of another HRegionInfo    *    * @param other    */
specifier|public
name|HRegionInfo
parameter_list|(
name|RegionInfo
name|other
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|endKey
operator|=
name|other
operator|.
name|getEndKey
argument_list|()
expr_stmt|;
name|this
operator|.
name|offLine
operator|=
name|other
operator|.
name|isOffline
argument_list|()
expr_stmt|;
name|this
operator|.
name|regionId
operator|=
name|other
operator|.
name|getRegionId
argument_list|()
expr_stmt|;
name|this
operator|.
name|regionName
operator|=
name|other
operator|.
name|getRegionName
argument_list|()
expr_stmt|;
name|this
operator|.
name|split
operator|=
name|other
operator|.
name|isSplit
argument_list|()
expr_stmt|;
name|this
operator|.
name|startKey
operator|=
name|other
operator|.
name|getStartKey
argument_list|()
expr_stmt|;
name|this
operator|.
name|hashCode
operator|=
name|other
operator|.
name|hashCode
argument_list|()
expr_stmt|;
name|this
operator|.
name|encodedName
operator|=
name|other
operator|.
name|getEncodedName
argument_list|()
expr_stmt|;
name|this
operator|.
name|tableName
operator|=
name|other
operator|.
name|getTable
argument_list|()
expr_stmt|;
name|this
operator|.
name|replicaId
operator|=
name|other
operator|.
name|getReplicaId
argument_list|()
expr_stmt|;
block|}
specifier|public
name|HRegionInfo
parameter_list|(
name|HRegionInfo
name|other
parameter_list|,
name|int
name|replicaId
parameter_list|)
block|{
name|this
argument_list|(
name|other
argument_list|)
expr_stmt|;
name|this
operator|.
name|replicaId
operator|=
name|replicaId
expr_stmt|;
name|this
operator|.
name|setHashCode
argument_list|()
expr_stmt|;
block|}
comment|/**    * Make a region name of passed parameters.    * @param tableName    * @param startKey Can be null    * @param regionid Region id (Usually timestamp from when region was created).    * @param newFormat should we create the region name in the new format    *                  (such that it contains its encoded name?).    * @return Region name made of passed tableName, startKey and id    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use {@link RegionInfo#createRegionName(TableName, byte[], long, boolean)}.    */
annotation|@
name|Deprecated
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|static
name|byte
index|[]
name|createRegionName
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|long
name|regionid
parameter_list|,
name|boolean
name|newFormat
parameter_list|)
block|{
return|return
name|RegionInfo
operator|.
name|createRegionName
argument_list|(
name|tableName
argument_list|,
name|startKey
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|regionid
argument_list|)
argument_list|,
name|newFormat
argument_list|)
return|;
block|}
comment|/**    * Make a region name of passed parameters.    * @param tableName    * @param startKey Can be null    * @param id Region id (Usually timestamp from when region was created).    * @param newFormat should we create the region name in the new format    *                  (such that it contains its encoded name?).    * @return Region name made of passed tableName, startKey and id    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use {@link RegionInfo#createRegionName(TableName, byte[], String, boolean)}.    */
annotation|@
name|Deprecated
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|static
name|byte
index|[]
name|createRegionName
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|String
name|id
parameter_list|,
name|boolean
name|newFormat
parameter_list|)
block|{
return|return
name|RegionInfo
operator|.
name|createRegionName
argument_list|(
name|tableName
argument_list|,
name|startKey
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|id
argument_list|)
argument_list|,
name|newFormat
argument_list|)
return|;
block|}
comment|/**    * Make a region name of passed parameters.    * @param tableName    * @param startKey Can be null    * @param regionid Region id (Usually timestamp from when region was created).    * @param replicaId    * @param newFormat should we create the region name in the new format    *                  (such that it contains its encoded name?).    * @return Region name made of passed tableName, startKey, id and replicaId    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use {@link RegionInfo#createRegionName(TableName, byte[], long, int, boolean)}.    */
annotation|@
name|Deprecated
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|static
name|byte
index|[]
name|createRegionName
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|long
name|regionid
parameter_list|,
name|int
name|replicaId
parameter_list|,
name|boolean
name|newFormat
parameter_list|)
block|{
return|return
name|RegionInfo
operator|.
name|createRegionName
argument_list|(
name|tableName
argument_list|,
name|startKey
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|Long
operator|.
name|toString
argument_list|(
name|regionid
argument_list|)
argument_list|)
argument_list|,
name|replicaId
argument_list|,
name|newFormat
argument_list|)
return|;
block|}
comment|/**    * Make a region name of passed parameters.    * @param tableName    * @param startKey Can be null    * @param id Region id (Usually timestamp from when region was created).    * @param newFormat should we create the region name in the new format    *                  (such that it contains its encoded name?).    * @return Region name made of passed tableName, startKey and id    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use {@link RegionInfo#createRegionName(TableName, byte[], byte[], boolean)}.    */
annotation|@
name|Deprecated
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|static
name|byte
index|[]
name|createRegionName
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|byte
index|[]
name|id
parameter_list|,
name|boolean
name|newFormat
parameter_list|)
block|{
return|return
name|RegionInfo
operator|.
name|createRegionName
argument_list|(
name|tableName
argument_list|,
name|startKey
argument_list|,
name|id
argument_list|,
name|DEFAULT_REPLICA_ID
argument_list|,
name|newFormat
argument_list|)
return|;
block|}
comment|/**    * Make a region name of passed parameters.    * @param tableName    * @param startKey Can be null    * @param id Region id (Usually timestamp from when region was created).    * @param replicaId    * @param newFormat should we create the region name in the new format    * @return Region name made of passed tableName, startKey, id and replicaId    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use {@link RegionInfo#createRegionName(TableName, byte[], byte[], int, boolean)}.    */
annotation|@
name|Deprecated
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|static
name|byte
index|[]
name|createRegionName
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|byte
index|[]
name|id
parameter_list|,
specifier|final
name|int
name|replicaId
parameter_list|,
name|boolean
name|newFormat
parameter_list|)
block|{
return|return
name|RegionInfo
operator|.
name|createRegionName
argument_list|(
name|tableName
argument_list|,
name|startKey
argument_list|,
name|id
argument_list|,
name|replicaId
argument_list|,
name|newFormat
argument_list|)
return|;
block|}
comment|/**    * Gets the table name from the specified region name.    * @param regionName to extract the table name from    * @return Table name    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use {@link org.apache.hadoop.hbase.client.RegionInfo#getTable(byte[])}.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|TableName
name|getTable
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
block|{
return|return
name|RegionInfo
operator|.
name|getTable
argument_list|(
name|regionName
argument_list|)
return|;
block|}
comment|/**    * Gets the start key from the specified region name.    * @param regionName    * @return Start key.    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use {@link org.apache.hadoop.hbase.client.RegionInfo#getStartKey(byte[])}.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|byte
index|[]
name|getStartKey
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|RegionInfo
operator|.
name|getStartKey
argument_list|(
name|regionName
argument_list|)
return|;
block|}
comment|/**    * Separate elements of a regionName.    * @param regionName    * @return Array of byte[] containing tableName, startKey and id    * @throws IOException    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use {@link RegionInfo#parseRegionName(byte[])}.    */
annotation|@
name|Deprecated
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|static
name|byte
index|[]
index|[]
name|parseRegionName
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|RegionInfo
operator|.
name|parseRegionName
argument_list|(
name|regionName
argument_list|)
return|;
block|}
comment|/**    *    * @param regionName    * @return if region name is encoded.    * @throws IOException    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use {@link org.apache.hadoop.hbase.client.RegionInfo#isEncodedRegionName(byte[])}.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|boolean
name|isEncodedRegionName
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|RegionInfo
operator|.
name|isEncodedRegionName
argument_list|(
name|regionName
argument_list|)
return|;
block|}
comment|/** @return the regionId */
annotation|@
name|Override
specifier|public
name|long
name|getRegionId
parameter_list|()
block|{
return|return
name|regionId
return|;
block|}
comment|/**    * @return the regionName as an array of bytes.    * @see #getRegionNameAsString()    */
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|getRegionName
parameter_list|()
block|{
return|return
name|regionName
return|;
block|}
comment|/**    * @return Region name as a String for use in logging, etc.    */
annotation|@
name|Override
specifier|public
name|String
name|getRegionNameAsString
parameter_list|()
block|{
if|if
condition|(
name|RegionInfo
operator|.
name|hasEncodedName
argument_list|(
name|this
operator|.
name|regionName
argument_list|)
condition|)
block|{
comment|// new format region names already have their encoded name.
return|return
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|this
operator|.
name|regionName
argument_list|)
return|;
block|}
comment|// old format. regionNameStr doesn't have the region name.
comment|//
comment|//
return|return
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|this
operator|.
name|regionName
argument_list|)
operator|+
literal|"."
operator|+
name|this
operator|.
name|getEncodedName
argument_list|()
return|;
block|}
comment|/**    * @return the encoded region name    */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|String
name|getEncodedName
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|encodedName
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|encodedName
operator|=
name|RegionInfo
operator|.
name|encodeRegionName
argument_list|(
name|this
operator|.
name|regionName
argument_list|)
expr_stmt|;
block|}
return|return
name|this
operator|.
name|encodedName
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|byte
index|[]
name|getEncodedNameAsBytes
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|encodedNameAsBytes
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|encodedNameAsBytes
operator|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|this
operator|.
name|encodedNameAsBytes
return|;
block|}
comment|/**    * @return the startKey    */
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|getStartKey
parameter_list|()
block|{
return|return
name|startKey
return|;
block|}
comment|/**    * @return the endKey    */
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|getEndKey
parameter_list|()
block|{
return|return
name|endKey
return|;
block|}
comment|/**    * Get current table name of the region    * @return TableName    */
annotation|@
name|Override
specifier|public
name|TableName
name|getTable
parameter_list|()
block|{
comment|// This method name should be getTableName but there was already a method getTableName
comment|// that returned a byte array.  It is unfortunate given everywhere else, getTableName returns
comment|// a TableName instance.
if|if
condition|(
name|tableName
operator|==
literal|null
operator|||
name|tableName
operator|.
name|getName
argument_list|()
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|tableName
operator|=
name|getTable
argument_list|(
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|this
operator|.
name|tableName
return|;
block|}
comment|/**    * Returns true if the given inclusive range of rows is fully contained    * by this region. For example, if the region is foo,a,g and this is    * passed ["b","c"] or ["a","c"] it will return true, but if this is passed    * ["b","z"] it will return false.    * @throws IllegalArgumentException if the range passed is invalid (ie. end&lt; start)    */
annotation|@
name|Override
specifier|public
name|boolean
name|containsRange
parameter_list|(
name|byte
index|[]
name|rangeStartKey
parameter_list|,
name|byte
index|[]
name|rangeEndKey
parameter_list|)
block|{
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|rangeStartKey
argument_list|,
name|rangeEndKey
argument_list|)
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid range: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|rangeStartKey
argument_list|)
operator|+
literal|"> "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|rangeEndKey
argument_list|)
argument_list|)
throw|;
block|}
name|boolean
name|firstKeyInRange
init|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|rangeStartKey
argument_list|,
name|startKey
argument_list|)
operator|>=
literal|0
decl_stmt|;
name|boolean
name|lastKeyInRange
init|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|rangeEndKey
argument_list|,
name|endKey
argument_list|)
operator|<
literal|0
operator|||
name|Bytes
operator|.
name|equals
argument_list|(
name|endKey
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|)
decl_stmt|;
return|return
name|firstKeyInRange
operator|&&
name|lastKeyInRange
return|;
block|}
comment|/**    * @return true if the given row falls in this region.    */
annotation|@
name|Override
specifier|public
name|boolean
name|containsRow
parameter_list|(
name|byte
index|[]
name|row
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|row
argument_list|,
name|startKey
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|row
argument_list|,
name|endKey
argument_list|)
operator|<
literal|0
operator|||
name|Bytes
operator|.
name|equals
argument_list|(
name|endKey
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|)
operator|)
return|;
block|}
comment|/**    * @return true if this region is from hbase:meta    */
specifier|public
name|boolean
name|isMetaTable
parameter_list|()
block|{
return|return
name|isMetaRegion
argument_list|()
return|;
block|}
comment|/**    * @return true if this region is a meta region    */
annotation|@
name|Override
specifier|public
name|boolean
name|isMetaRegion
parameter_list|()
block|{
return|return
name|tableName
operator|.
name|equals
argument_list|(
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
operator|.
name|getTable
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @return true if this region is from a system table    */
specifier|public
name|boolean
name|isSystemTable
parameter_list|()
block|{
return|return
name|tableName
operator|.
name|isSystemTable
argument_list|()
return|;
block|}
comment|/**    * @return true if has been split and has daughters.    */
annotation|@
name|Override
specifier|public
name|boolean
name|isSplit
parameter_list|()
block|{
return|return
name|this
operator|.
name|split
return|;
block|}
comment|/**    * @param split set split status    */
specifier|public
name|void
name|setSplit
parameter_list|(
name|boolean
name|split
parameter_list|)
block|{
name|this
operator|.
name|split
operator|=
name|split
expr_stmt|;
block|}
comment|/**    * @return true if this region is offline.    */
annotation|@
name|Override
specifier|public
name|boolean
name|isOffline
parameter_list|()
block|{
return|return
name|this
operator|.
name|offLine
return|;
block|}
comment|/**    * The parent of a region split is offline while split daughters hold    * references to the parent. Offlined regions are closed.    * @param offLine Set online/offline status.    */
specifier|public
name|void
name|setOffline
parameter_list|(
name|boolean
name|offLine
parameter_list|)
block|{
name|this
operator|.
name|offLine
operator|=
name|offLine
expr_stmt|;
block|}
comment|/**    * @return true if this is a split parent region.    */
annotation|@
name|Override
specifier|public
name|boolean
name|isSplitParent
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isSplit
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|isOffline
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Region is split but NOT offline: "
operator|+
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns the region replica id    * @return returns region replica id    */
annotation|@
name|Override
specifier|public
name|int
name|getReplicaId
parameter_list|()
block|{
return|return
name|replicaId
return|;
block|}
comment|/**    * @see java.lang.Object#toString()    */
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"{ENCODED => "
operator|+
name|getEncodedName
argument_list|()
operator|+
literal|", "
operator|+
name|HConstants
operator|.
name|NAME
operator|+
literal|" => '"
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|this
operator|.
name|regionName
argument_list|)
operator|+
literal|"', STARTKEY => '"
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|this
operator|.
name|startKey
argument_list|)
operator|+
literal|"', ENDKEY => '"
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|this
operator|.
name|endKey
argument_list|)
operator|+
literal|"'"
operator|+
operator|(
name|isOffline
argument_list|()
condition|?
literal|", OFFLINE => true"
else|:
literal|""
operator|)
operator|+
operator|(
name|isSplit
argument_list|()
condition|?
literal|", SPLIT => true"
else|:
literal|""
operator|)
operator|+
operator|(
operator|(
name|replicaId
operator|>
literal|0
operator|)
condition|?
literal|", REPLICA_ID => "
operator|+
name|replicaId
else|:
literal|""
operator|)
operator|+
literal|"}"
return|;
block|}
comment|/**    * @see java.lang.Object#equals(java.lang.Object)    */
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|HRegionInfo
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|this
operator|.
name|compareTo
argument_list|(
operator|(
name|HRegionInfo
operator|)
name|o
argument_list|)
operator|==
literal|0
return|;
block|}
comment|/**    * @see java.lang.Object#hashCode()    */
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|this
operator|.
name|hashCode
return|;
block|}
comment|/**    * @return Comparator to use comparing {@link KeyValue}s.    * @deprecated Use Region#getCellComparator().  deprecated for hbase 2.0, remove for hbase 3.0    */
annotation|@
name|Deprecated
specifier|public
name|KVComparator
name|getComparator
parameter_list|()
block|{
return|return
name|isMetaRegion
argument_list|()
condition|?
name|KeyValue
operator|.
name|META_COMPARATOR
else|:
name|KeyValue
operator|.
name|COMPARATOR
return|;
block|}
comment|/**    * Convert a HRegionInfo to the protobuf RegionInfo    *    * @return the converted RegionInfo    */
name|HBaseProtos
operator|.
name|RegionInfo
name|convert
parameter_list|()
block|{
return|return
name|convert
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * Convert a HRegionInfo to a RegionInfo    *    * @param info the HRegionInfo to convert    * @return the converted RegionInfo    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use toRegionInfo(org.apache.hadoop.hbase.client.RegionInfo)    *             in org.apache.hadoop.hbase.shaded.protobuf.ProtobufUtil.    */
annotation|@
name|Deprecated
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|static
name|HBaseProtos
operator|.
name|RegionInfo
name|convert
parameter_list|(
specifier|final
name|HRegionInfo
name|info
parameter_list|)
block|{
return|return
name|ProtobufUtil
operator|.
name|toRegionInfo
argument_list|(
name|info
argument_list|)
return|;
block|}
comment|/**    * Convert a RegionInfo to a HRegionInfo    *    * @param proto the RegionInfo to convert    * @return the converted HRegionInfo    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use toRegionInfo(HBaseProtos.RegionInfo)    *             in org.apache.hadoop.hbase.shaded.protobuf.ProtobufUtil.    */
annotation|@
name|Deprecated
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|static
name|HRegionInfo
name|convert
parameter_list|(
specifier|final
name|HBaseProtos
operator|.
name|RegionInfo
name|proto
parameter_list|)
block|{
name|RegionInfo
name|ri
init|=
name|ProtobufUtil
operator|.
name|toRegionInfo
argument_list|(
name|proto
argument_list|)
decl_stmt|;
comment|// This is hack of what is in RegionReplicaUtil but it is doing translation of
comment|// RegionInfo into HRegionInfo which is what is wanted here.
name|HRegionInfo
name|hri
decl_stmt|;
if|if
condition|(
name|ri
operator|.
name|isMetaRegion
argument_list|()
condition|)
block|{
name|hri
operator|=
name|ri
operator|.
name|getReplicaId
argument_list|()
operator|==
name|RegionInfo
operator|.
name|DEFAULT_REPLICA_ID
condition|?
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
else|:
operator|new
name|HRegionInfo
argument_list|(
name|ri
operator|.
name|getRegionId
argument_list|()
argument_list|,
name|ri
operator|.
name|getTable
argument_list|()
argument_list|,
name|ri
operator|.
name|getReplicaId
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hri
operator|=
operator|new
name|HRegionInfo
argument_list|(
name|ri
operator|.
name|getTable
argument_list|()
argument_list|,
name|ri
operator|.
name|getStartKey
argument_list|()
argument_list|,
name|ri
operator|.
name|getEndKey
argument_list|()
argument_list|,
name|ri
operator|.
name|isSplit
argument_list|()
argument_list|,
name|ri
operator|.
name|getRegionId
argument_list|()
argument_list|,
name|ri
operator|.
name|getReplicaId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
operator|.
name|hasOffline
argument_list|()
condition|)
block|{
name|hri
operator|.
name|setOffline
argument_list|(
name|proto
operator|.
name|getOffline
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|hri
return|;
block|}
comment|/**    * @return This instance serialized as protobuf w/ a magic pb prefix.    * @see #parseFrom(byte[])    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use {@link org.apache.hadoop.hbase.client.RegionInfo#toByteArray(RegionInfo)}.    */
annotation|@
name|Deprecated
specifier|public
name|byte
index|[]
name|toByteArray
parameter_list|()
block|{
return|return
name|RegionInfo
operator|.
name|toByteArray
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * @return A deserialized {@link HRegionInfo}    * or null if we failed deserialize or passed bytes null    * @see #toByteArray()    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use {@link org.apache.hadoop.hbase.client.RegionInfo#parseFromOrNull(byte[])}.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|HRegionInfo
name|parseFromOrNull
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|)
block|{
if|if
condition|(
name|bytes
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|parseFromOrNull
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * @return A deserialized {@link HRegionInfo} or null    *  if we failed deserialize or passed bytes null    * @see #toByteArray()    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use {@link org.apache.hadoop.hbase.client.RegionInfo#parseFromOrNull(byte[], int, int)}.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|HRegionInfo
name|parseFromOrNull
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|bytes
operator|==
literal|null
operator|||
name|len
operator|<=
literal|0
condition|)
return|return
literal|null
return|;
try|try
block|{
return|return
name|parseFrom
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * @param bytes A pb RegionInfo serialized with a pb magic prefix.    * @return A deserialized {@link HRegionInfo}    * @throws DeserializationException    * @see #toByteArray()    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use {@link org.apache.hadoop.hbase.client.RegionInfo#parseFrom(byte[])}.    */
specifier|public
specifier|static
name|HRegionInfo
name|parseFrom
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|)
throws|throws
name|DeserializationException
block|{
if|if
condition|(
name|bytes
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|parseFrom
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * @param bytes A pb RegionInfo serialized with a pb magic prefix.    * @param offset starting point in the byte array    * @param len length to read on the byte array    * @return A deserialized {@link HRegionInfo}    * @throws DeserializationException    * @see #toByteArray()    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use {@link org.apache.hadoop.hbase.client.RegionInfo#parseFrom(byte[], int, int)}.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|HRegionInfo
name|parseFrom
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|DeserializationException
block|{
if|if
condition|(
name|ProtobufUtil
operator|.
name|isPBMagicPrefix
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|int
name|pblen
init|=
name|ProtobufUtil
operator|.
name|lengthOfPBMagic
argument_list|()
decl_stmt|;
try|try
block|{
name|HBaseProtos
operator|.
name|RegionInfo
operator|.
name|Builder
name|builder
init|=
name|HBaseProtos
operator|.
name|RegionInfo
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|ProtobufUtil
operator|.
name|mergeFrom
argument_list|(
name|builder
argument_list|,
name|bytes
argument_list|,
name|pblen
operator|+
name|offset
argument_list|,
name|len
operator|-
name|pblen
argument_list|)
expr_stmt|;
name|HBaseProtos
operator|.
name|RegionInfo
name|ri
init|=
name|builder
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|convert
argument_list|(
name|ri
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DeserializationException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|DeserializationException
argument_list|(
literal|"PB encoded HRegionInfo expected"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Use this instead of {@link #toByteArray()} when writing to a stream and you want to use    * the pb mergeDelimitedFrom (w/o the delimiter, pb reads to EOF which may not be what you want).    * @return This instance serialized as a delimited protobuf w/ a magic pb prefix.    * @throws IOException    * @see #toByteArray()    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use {@link RegionInfo#toDelimitedByteArray(RegionInfo)}.    */
annotation|@
name|Deprecated
specifier|public
name|byte
index|[]
name|toDelimitedByteArray
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|RegionInfo
operator|.
name|toDelimitedByteArray
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * Get the descriptive name as {@link RegionState} does it but with hidden    * startkey optionally    * @param state    * @param conf    * @return descriptive string    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use RegionInfoDisplay#getDescriptiveNameFromRegionStateForDisplay(RegionState, Configuration)    *             over in hbase-server module.    */
annotation|@
name|Deprecated
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|static
name|String
name|getDescriptiveNameFromRegionStateForDisplay
parameter_list|(
name|RegionState
name|state
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|RegionInfoDisplay
operator|.
name|getDescriptiveNameFromRegionStateForDisplay
argument_list|(
name|state
argument_list|,
name|conf
argument_list|)
return|;
block|}
comment|/**    * Get the end key for display. Optionally hide the real end key.    * @param hri    * @param conf    * @return the endkey    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use RegionInfoDisplay#getEndKeyForDisplay(RegionInfo, Configuration)    *             over in hbase-server module.    */
annotation|@
name|Deprecated
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|static
name|byte
index|[]
name|getEndKeyForDisplay
parameter_list|(
name|HRegionInfo
name|hri
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|RegionInfoDisplay
operator|.
name|getEndKeyForDisplay
argument_list|(
name|hri
argument_list|,
name|conf
argument_list|)
return|;
block|}
comment|/**    * Get the start key for display. Optionally hide the real start key.    * @param hri    * @param conf    * @return the startkey    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use RegionInfoDisplay#getStartKeyForDisplay(RegionInfo, Configuration)    *             over in hbase-server module.    */
annotation|@
name|Deprecated
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|static
name|byte
index|[]
name|getStartKeyForDisplay
parameter_list|(
name|HRegionInfo
name|hri
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|RegionInfoDisplay
operator|.
name|getStartKeyForDisplay
argument_list|(
name|hri
argument_list|,
name|conf
argument_list|)
return|;
block|}
comment|/**    * Get the region name for display. Optionally hide the start key.    * @param hri    * @param conf    * @return region name as String    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use RegionInfoDisplay#getRegionNameAsStringForDisplay(RegionInfo, Configuration)    *             over in hbase-server module.    */
annotation|@
name|Deprecated
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|static
name|String
name|getRegionNameAsStringForDisplay
parameter_list|(
name|HRegionInfo
name|hri
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|RegionInfoDisplay
operator|.
name|getRegionNameAsStringForDisplay
argument_list|(
name|hri
argument_list|,
name|conf
argument_list|)
return|;
block|}
comment|/**    * Get the region name for display. Optionally hide the start key.    * @param hri    * @param conf    * @return region name bytes    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use RegionInfoDisplay#getRegionNameForDisplay(RegionInfo, Configuration)    *             over in hbase-server module.    */
annotation|@
name|Deprecated
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|static
name|byte
index|[]
name|getRegionNameForDisplay
parameter_list|(
name|HRegionInfo
name|hri
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|RegionInfoDisplay
operator|.
name|getRegionNameForDisplay
argument_list|(
name|hri
argument_list|,
name|conf
argument_list|)
return|;
block|}
comment|/**    * Parses an HRegionInfo instance from the passed in stream.  Presumes the HRegionInfo was    * serialized to the stream with {@link #toDelimitedByteArray()}    * @param in    * @return An instance of HRegionInfo.    * @throws IOException    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use {@link RegionInfo#parseFrom(DataInputStream)}.    */
annotation|@
name|Deprecated
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|static
name|HRegionInfo
name|parseFrom
parameter_list|(
specifier|final
name|DataInputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
comment|// I need to be able to move back in the stream if this is not a pb serialization so I can
comment|// do the Writable decoding instead.
name|int
name|pblen
init|=
name|ProtobufUtil
operator|.
name|lengthOfPBMagic
argument_list|()
decl_stmt|;
name|byte
index|[]
name|pbuf
init|=
operator|new
name|byte
index|[
name|pblen
index|]
decl_stmt|;
if|if
condition|(
name|in
operator|.
name|markSupported
argument_list|()
condition|)
block|{
comment|//read it with mark()
name|in
operator|.
name|mark
argument_list|(
name|pblen
argument_list|)
expr_stmt|;
block|}
comment|//assumption: if Writable serialization, it should be longer than pblen.
name|int
name|read
init|=
name|in
operator|.
name|read
argument_list|(
name|pbuf
argument_list|)
decl_stmt|;
if|if
condition|(
name|read
operator|!=
name|pblen
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"read="
operator|+
name|read
operator|+
literal|", wanted="
operator|+
name|pblen
argument_list|)
throw|;
if|if
condition|(
name|ProtobufUtil
operator|.
name|isPBMagicPrefix
argument_list|(
name|pbuf
argument_list|)
condition|)
block|{
return|return
name|convert
argument_list|(
name|HBaseProtos
operator|.
name|RegionInfo
operator|.
name|parseDelimitedFrom
argument_list|(
name|in
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"PB encoded HRegionInfo expected"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Serializes given HRegionInfo's as a byte array. Use this instead of {@link #toByteArray()} when    * writing to a stream and you want to use the pb mergeDelimitedFrom (w/o the delimiter, pb reads    * to EOF which may not be what you want). {@link #parseDelimitedFrom(byte[], int, int)} can    * be used to read back the instances.    * @param infos HRegionInfo objects to serialize    * @return This instance serialized as a delimited protobuf w/ a magic pb prefix.    * @throws IOException    * @see #toByteArray()    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use {@link RegionInfo#toDelimitedByteArray(RegionInfo...)}.    */
annotation|@
name|Deprecated
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|static
name|byte
index|[]
name|toDelimitedByteArray
parameter_list|(
name|HRegionInfo
modifier|...
name|infos
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|RegionInfo
operator|.
name|toDelimitedByteArray
argument_list|(
name|infos
argument_list|)
return|;
block|}
comment|/**    * Parses all the HRegionInfo instances from the passed in stream until EOF. Presumes the    * HRegionInfo's were serialized to the stream with {@link #toDelimitedByteArray()}    * @param bytes serialized bytes    * @param offset the start offset into the byte[] buffer    * @param length how far we should read into the byte[] buffer    * @return All the hregioninfos that are in the byte array. Keeps reading till we hit the end.    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use {@link RegionInfo#parseDelimitedFrom(byte[], int, int)}.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|parseDelimitedFrom
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|bytes
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Can't build an object with empty bytes array"
argument_list|)
throw|;
block|}
name|DataInputBuffer
name|in
init|=
operator|new
name|DataInputBuffer
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|hris
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
try|try
block|{
name|in
operator|.
name|reset
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
while|while
condition|(
name|in
operator|.
name|available
argument_list|()
operator|>
literal|0
condition|)
block|{
name|HRegionInfo
name|hri
init|=
name|parseFrom
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|hris
operator|.
name|add
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|hris
return|;
block|}
comment|/**    * Check whether two regions are adjacent    * @param regionA    * @param regionB    * @return true if two regions are adjacent    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             Use {@link org.apache.hadoop.hbase.client.RegionInfo#areAdjacent(RegionInfo, RegionInfo)}.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|boolean
name|areAdjacent
parameter_list|(
name|HRegionInfo
name|regionA
parameter_list|,
name|HRegionInfo
name|regionB
parameter_list|)
block|{
return|return
name|RegionInfo
operator|.
name|areAdjacent
argument_list|(
name|regionA
argument_list|,
name|regionB
argument_list|)
return|;
block|}
block|}
end_class

end_unit

