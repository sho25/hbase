begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ConcurrentMapUtils
operator|.
name|computeIfAbsent
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentNavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArraySet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|RegionLocations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|types
operator|.
name|CopyOnWriteArrayMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * A cache implementation for region locations from meta.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|MetaCache
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MetaCache
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Map of table to table {@link HRegionLocation}s.    */
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|TableName
argument_list|,
name|ConcurrentNavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|RegionLocations
argument_list|>
argument_list|>
name|cachedRegionLocations
init|=
operator|new
name|CopyOnWriteArrayMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// The presence of a server in the map implies it's likely that there is an
comment|// entry in cachedRegionLocations that map to this server; but the absence
comment|// of a server in this map guarantees that there is no entry in cache that
comment|// maps to the absent server.
comment|// The access to this attribute must be protected by a lock on cachedRegionLocations
specifier|private
specifier|final
name|Set
argument_list|<
name|ServerName
argument_list|>
name|cachedServers
init|=
operator|new
name|CopyOnWriteArraySet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|MetricsConnection
name|metrics
decl_stmt|;
specifier|public
name|MetaCache
parameter_list|(
name|MetricsConnection
name|metrics
parameter_list|)
block|{
name|this
operator|.
name|metrics
operator|=
name|metrics
expr_stmt|;
block|}
comment|/**    * Search the cache for a location that fits our table and row key.    * Return null if no suitable region is located.    *    * @return Null or region location found in cache.    */
specifier|public
name|RegionLocations
name|getCachedLocation
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|)
block|{
name|ConcurrentNavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|RegionLocations
argument_list|>
name|tableLocations
init|=
name|getTableLocations
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|RegionLocations
argument_list|>
name|e
init|=
name|tableLocations
operator|.
name|floorEntry
argument_list|(
name|row
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
name|metrics
operator|.
name|incrMetaCacheMiss
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
name|RegionLocations
name|possibleRegion
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// make sure that the end key is greater than the row we're looking
comment|// for, otherwise the row actually belongs in the next region, not
comment|// this one. the exception case is when the endkey is
comment|// HConstants.EMPTY_END_ROW, signifying that the region we're
comment|// checking is actually the last region in the table.
name|byte
index|[]
name|endKey
init|=
name|possibleRegion
operator|.
name|getRegionLocation
argument_list|()
operator|.
name|getRegion
argument_list|()
operator|.
name|getEndKey
argument_list|()
decl_stmt|;
comment|// Here we do direct Bytes.compareTo and not doing CellComparator/MetaCellComparator path.
comment|// MetaCellComparator is for comparing against data in META table which need special handling.
comment|// Not doing that is ok for this case because
comment|// 1. We are getting the Region location for the given row in non META tables only. The compare
comment|// checks the given row is within the end key of the found region. So META regions are not
comment|// coming in here.
comment|// 2. Even if META region comes in, its end key will be empty byte[] and so Bytes.equals(endKey,
comment|// HConstants.EMPTY_END_ROW) check itself will pass.
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|endKey
argument_list|,
name|HConstants
operator|.
name|EMPTY_END_ROW
argument_list|)
operator|||
name|Bytes
operator|.
name|compareTo
argument_list|(
name|endKey
argument_list|,
literal|0
argument_list|,
name|endKey
operator|.
name|length
argument_list|,
name|row
argument_list|,
literal|0
argument_list|,
name|row
operator|.
name|length
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
name|metrics
operator|.
name|incrMetaCacheHit
argument_list|()
expr_stmt|;
return|return
name|possibleRegion
return|;
block|}
comment|// Passed all the way through, so we got nothing - complete cache miss
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
name|metrics
operator|.
name|incrMetaCacheMiss
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/**    * Put a newly discovered HRegionLocation into the cache.    * @param tableName The table name.    * @param source the source of the new location    * @param location the new location    */
specifier|public
name|void
name|cacheLocation
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|ServerName
name|source
parameter_list|,
specifier|final
name|HRegionLocation
name|location
parameter_list|)
block|{
assert|assert
name|source
operator|!=
literal|null
assert|;
name|byte
index|[]
name|startKey
init|=
name|location
operator|.
name|getRegion
argument_list|()
operator|.
name|getStartKey
argument_list|()
decl_stmt|;
name|ConcurrentMap
argument_list|<
name|byte
index|[]
argument_list|,
name|RegionLocations
argument_list|>
name|tableLocations
init|=
name|getTableLocations
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|RegionLocations
name|locations
init|=
operator|new
name|RegionLocations
argument_list|(
operator|new
name|HRegionLocation
index|[]
block|{
name|location
block|}
argument_list|)
decl_stmt|;
name|RegionLocations
name|oldLocations
init|=
name|tableLocations
operator|.
name|putIfAbsent
argument_list|(
name|startKey
argument_list|,
name|locations
argument_list|)
decl_stmt|;
name|boolean
name|isNewCacheEntry
init|=
operator|(
name|oldLocations
operator|==
literal|null
operator|)
decl_stmt|;
if|if
condition|(
name|isNewCacheEntry
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Cached location: "
operator|+
name|location
argument_list|)
expr_stmt|;
block|}
name|addToCachedServers
argument_list|(
name|locations
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// If the server in cache sends us a redirect, assume it's always valid.
name|HRegionLocation
name|oldLocation
init|=
name|oldLocations
operator|.
name|getRegionLocation
argument_list|(
name|location
operator|.
name|getRegion
argument_list|()
operator|.
name|getReplicaId
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|force
init|=
name|oldLocation
operator|!=
literal|null
operator|&&
name|oldLocation
operator|.
name|getServerName
argument_list|()
operator|!=
literal|null
operator|&&
name|oldLocation
operator|.
name|getServerName
argument_list|()
operator|.
name|equals
argument_list|(
name|source
argument_list|)
decl_stmt|;
comment|// For redirect if the number is equal to previous
comment|// record, the most common case is that first the region was closed with seqNum, and then
comment|// opened with the same seqNum; hence we will ignore the redirect.
comment|// There are so many corner cases with various combinations of opens and closes that
comment|// an additional counter on top of seqNum would be necessary to handle them all.
name|RegionLocations
name|updatedLocations
init|=
name|oldLocations
operator|.
name|updateLocation
argument_list|(
name|location
argument_list|,
literal|false
argument_list|,
name|force
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldLocations
operator|!=
name|updatedLocations
condition|)
block|{
name|boolean
name|replaced
init|=
name|tableLocations
operator|.
name|replace
argument_list|(
name|startKey
argument_list|,
name|oldLocations
argument_list|,
name|updatedLocations
argument_list|)
decl_stmt|;
if|if
condition|(
name|replaced
operator|&&
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Changed cached location to: "
operator|+
name|location
argument_list|)
expr_stmt|;
block|}
name|addToCachedServers
argument_list|(
name|updatedLocations
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Put a newly discovered HRegionLocation into the cache.    * @param tableName The table name.    * @param locations the new locations    */
specifier|public
name|void
name|cacheLocation
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|RegionLocations
name|locations
parameter_list|)
block|{
name|byte
index|[]
name|startKey
init|=
name|locations
operator|.
name|getRegionLocation
argument_list|()
operator|.
name|getRegion
argument_list|()
operator|.
name|getStartKey
argument_list|()
decl_stmt|;
name|ConcurrentMap
argument_list|<
name|byte
index|[]
argument_list|,
name|RegionLocations
argument_list|>
name|tableLocations
init|=
name|getTableLocations
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|RegionLocations
name|oldLocation
init|=
name|tableLocations
operator|.
name|putIfAbsent
argument_list|(
name|startKey
argument_list|,
name|locations
argument_list|)
decl_stmt|;
name|boolean
name|isNewCacheEntry
init|=
operator|(
name|oldLocation
operator|==
literal|null
operator|)
decl_stmt|;
if|if
condition|(
name|isNewCacheEntry
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Cached location: "
operator|+
name|locations
argument_list|)
expr_stmt|;
block|}
name|addToCachedServers
argument_list|(
name|locations
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// merge old and new locations and add it to the cache
comment|// Meta record might be stale - some (probably the same) server has closed the region
comment|// with later seqNum and told us about the new location.
name|RegionLocations
name|mergedLocation
init|=
name|oldLocation
operator|.
name|mergeLocations
argument_list|(
name|locations
argument_list|)
decl_stmt|;
name|boolean
name|replaced
init|=
name|tableLocations
operator|.
name|replace
argument_list|(
name|startKey
argument_list|,
name|oldLocation
argument_list|,
name|mergedLocation
argument_list|)
decl_stmt|;
if|if
condition|(
name|replaced
operator|&&
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Merged cached locations: "
operator|+
name|mergedLocation
argument_list|)
expr_stmt|;
block|}
name|addToCachedServers
argument_list|(
name|locations
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addToCachedServers
parameter_list|(
name|RegionLocations
name|locations
parameter_list|)
block|{
for|for
control|(
name|HRegionLocation
name|loc
range|:
name|locations
operator|.
name|getRegionLocations
argument_list|()
control|)
block|{
if|if
condition|(
name|loc
operator|!=
literal|null
condition|)
block|{
name|cachedServers
operator|.
name|add
argument_list|(
name|loc
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * @param tableName    * @return Map of cached locations for passed<code>tableName</code>    */
specifier|private
name|ConcurrentNavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|RegionLocations
argument_list|>
name|getTableLocations
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
block|{
comment|// find the map of cached locations for this table
return|return
name|computeIfAbsent
argument_list|(
name|cachedRegionLocations
argument_list|,
name|tableName
argument_list|,
parameter_list|()
lambda|->
operator|new
name|CopyOnWriteArrayMap
argument_list|<>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Check the region cache to see whether a region is cached yet or not.    * @param tableName tableName    * @param row row    * @return Region cached or not.    */
specifier|public
name|boolean
name|isRegionCached
parameter_list|(
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|)
block|{
name|RegionLocations
name|location
init|=
name|getCachedLocation
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|)
decl_stmt|;
return|return
name|location
operator|!=
literal|null
return|;
block|}
comment|/**    * Return the number of cached region for a table. It will only be called    * from a unit test.    */
specifier|public
name|int
name|getNumberOfCachedRegionLocations
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
block|{
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|RegionLocations
argument_list|>
name|tableLocs
init|=
name|this
operator|.
name|cachedRegionLocations
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|tableLocs
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
name|int
name|numRegions
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RegionLocations
name|tableLoc
range|:
name|tableLocs
operator|.
name|values
argument_list|()
control|)
block|{
name|numRegions
operator|+=
name|tableLoc
operator|.
name|numNonNullElements
argument_list|()
expr_stmt|;
block|}
return|return
name|numRegions
return|;
block|}
comment|/**    * Delete all cached entries.    */
specifier|public
name|void
name|clearCache
parameter_list|()
block|{
name|this
operator|.
name|cachedRegionLocations
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|cachedServers
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * Delete all cached entries of a server.    */
specifier|public
name|void
name|clearCache
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|cachedServers
operator|.
name|contains
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
return|return;
block|}
name|boolean
name|deletedSomething
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|cachedServers
init|)
block|{
comment|// We block here, because if there is an error on a server, it's likely that multiple
comment|//  threads will get the error  simultaneously. If there are hundreds of thousand of
comment|//  region location to check, it's better to do this only once. A better pattern would
comment|//  be to check if the server is dead when we get the region location.
if|if
condition|(
operator|!
name|this
operator|.
name|cachedServers
operator|.
name|contains
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
return|return;
block|}
for|for
control|(
name|ConcurrentMap
argument_list|<
name|byte
index|[]
argument_list|,
name|RegionLocations
argument_list|>
name|tableLocations
range|:
name|cachedRegionLocations
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|RegionLocations
argument_list|>
name|e
range|:
name|tableLocations
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|RegionLocations
name|regionLocations
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|regionLocations
operator|!=
literal|null
condition|)
block|{
name|RegionLocations
name|updatedLocations
init|=
name|regionLocations
operator|.
name|removeByServer
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
if|if
condition|(
name|updatedLocations
operator|!=
name|regionLocations
condition|)
block|{
if|if
condition|(
name|updatedLocations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|deletedSomething
operator||=
name|tableLocations
operator|.
name|remove
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|regionLocations
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|deletedSomething
operator||=
name|tableLocations
operator|.
name|replace
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|regionLocations
argument_list|,
name|updatedLocations
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|this
operator|.
name|cachedServers
operator|.
name|remove
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|deletedSomething
condition|)
block|{
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|incrMetaCacheNumClearServer
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Removed all cached region locations that map to "
operator|+
name|serverName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Delete all cached entries of a table.    */
specifier|public
name|void
name|clearCache
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Removed all cached region locations for table "
operator|+
name|tableName
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|cachedRegionLocations
operator|.
name|remove
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete a cached location, no matter what it is. Called when we were told to not use cache.    * @param tableName tableName    * @param row    */
specifier|public
name|void
name|clearCache
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|)
block|{
name|ConcurrentMap
argument_list|<
name|byte
index|[]
argument_list|,
name|RegionLocations
argument_list|>
name|tableLocations
init|=
name|getTableLocations
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|RegionLocations
name|regionLocations
init|=
name|getCachedLocation
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionLocations
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|startKey
init|=
name|regionLocations
operator|.
name|getRegionLocation
argument_list|()
operator|.
name|getRegion
argument_list|()
operator|.
name|getStartKey
argument_list|()
decl_stmt|;
name|boolean
name|removed
init|=
name|tableLocations
operator|.
name|remove
argument_list|(
name|startKey
argument_list|,
name|regionLocations
argument_list|)
decl_stmt|;
if|if
condition|(
name|removed
condition|)
block|{
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|incrMetaCacheNumClearRegion
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Removed "
operator|+
name|regionLocations
operator|+
literal|" from cache"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Delete a cached location with specific replicaId.    * @param tableName tableName    * @param row row key    * @param replicaId region replica id    */
specifier|public
name|void
name|clearCache
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
name|int
name|replicaId
parameter_list|)
block|{
name|ConcurrentMap
argument_list|<
name|byte
index|[]
argument_list|,
name|RegionLocations
argument_list|>
name|tableLocations
init|=
name|getTableLocations
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|RegionLocations
name|regionLocations
init|=
name|getCachedLocation
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionLocations
operator|!=
literal|null
condition|)
block|{
name|HRegionLocation
name|toBeRemoved
init|=
name|regionLocations
operator|.
name|getRegionLocation
argument_list|(
name|replicaId
argument_list|)
decl_stmt|;
if|if
condition|(
name|toBeRemoved
operator|!=
literal|null
condition|)
block|{
name|RegionLocations
name|updatedLocations
init|=
name|regionLocations
operator|.
name|remove
argument_list|(
name|replicaId
argument_list|)
decl_stmt|;
name|byte
index|[]
name|startKey
init|=
name|regionLocations
operator|.
name|getRegionLocation
argument_list|()
operator|.
name|getRegion
argument_list|()
operator|.
name|getStartKey
argument_list|()
decl_stmt|;
name|boolean
name|removed
decl_stmt|;
if|if
condition|(
name|updatedLocations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|removed
operator|=
name|tableLocations
operator|.
name|remove
argument_list|(
name|startKey
argument_list|,
name|regionLocations
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|removed
operator|=
name|tableLocations
operator|.
name|replace
argument_list|(
name|startKey
argument_list|,
name|regionLocations
argument_list|,
name|updatedLocations
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|removed
condition|)
block|{
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|incrMetaCacheNumClearRegion
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Removed "
operator|+
name|toBeRemoved
operator|+
literal|" from cache"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**    * Delete a cached location for a table, row and server    */
specifier|public
name|void
name|clearCache
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
name|ServerName
name|serverName
parameter_list|)
block|{
name|ConcurrentMap
argument_list|<
name|byte
index|[]
argument_list|,
name|RegionLocations
argument_list|>
name|tableLocations
init|=
name|getTableLocations
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|RegionLocations
name|regionLocations
init|=
name|getCachedLocation
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionLocations
operator|!=
literal|null
condition|)
block|{
name|RegionLocations
name|updatedLocations
init|=
name|regionLocations
operator|.
name|removeByServer
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
if|if
condition|(
name|updatedLocations
operator|!=
name|regionLocations
condition|)
block|{
name|byte
index|[]
name|startKey
init|=
name|regionLocations
operator|.
name|getRegionLocation
argument_list|()
operator|.
name|getRegion
argument_list|()
operator|.
name|getStartKey
argument_list|()
decl_stmt|;
name|boolean
name|removed
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|updatedLocations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|removed
operator|=
name|tableLocations
operator|.
name|remove
argument_list|(
name|startKey
argument_list|,
name|regionLocations
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|removed
operator|=
name|tableLocations
operator|.
name|replace
argument_list|(
name|startKey
argument_list|,
name|regionLocations
argument_list|,
name|updatedLocations
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|removed
condition|)
block|{
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|incrMetaCacheNumClearRegion
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Removed locations of table: "
operator|+
name|tableName
operator|+
literal|" ,row: "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|row
argument_list|)
operator|+
literal|" mapping to server: "
operator|+
name|serverName
operator|+
literal|" from cache"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**    * Deletes the cached location of the region if necessary, based on some error from source.    * @param hri The region in question.    */
specifier|public
name|void
name|clearCache
parameter_list|(
name|RegionInfo
name|hri
parameter_list|)
block|{
name|ConcurrentMap
argument_list|<
name|byte
index|[]
argument_list|,
name|RegionLocations
argument_list|>
name|tableLocations
init|=
name|getTableLocations
argument_list|(
name|hri
operator|.
name|getTable
argument_list|()
argument_list|)
decl_stmt|;
name|RegionLocations
name|regionLocations
init|=
name|tableLocations
operator|.
name|get
argument_list|(
name|hri
operator|.
name|getStartKey
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionLocations
operator|!=
literal|null
condition|)
block|{
name|HRegionLocation
name|oldLocation
init|=
name|regionLocations
operator|.
name|getRegionLocation
argument_list|(
name|hri
operator|.
name|getReplicaId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldLocation
operator|==
literal|null
condition|)
return|return;
name|RegionLocations
name|updatedLocations
init|=
name|regionLocations
operator|.
name|remove
argument_list|(
name|oldLocation
argument_list|)
decl_stmt|;
name|boolean
name|removed
decl_stmt|;
if|if
condition|(
name|updatedLocations
operator|!=
name|regionLocations
condition|)
block|{
if|if
condition|(
name|updatedLocations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|removed
operator|=
name|tableLocations
operator|.
name|remove
argument_list|(
name|hri
operator|.
name|getStartKey
argument_list|()
argument_list|,
name|regionLocations
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|removed
operator|=
name|tableLocations
operator|.
name|replace
argument_list|(
name|hri
operator|.
name|getStartKey
argument_list|()
argument_list|,
name|regionLocations
argument_list|,
name|updatedLocations
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|removed
condition|)
block|{
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|incrMetaCacheNumClearRegion
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Removed "
operator|+
name|oldLocation
operator|+
literal|" from cache"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
specifier|public
name|void
name|clearCache
parameter_list|(
specifier|final
name|HRegionLocation
name|location
parameter_list|)
block|{
if|if
condition|(
name|location
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|TableName
name|tableName
init|=
name|location
operator|.
name|getRegion
argument_list|()
operator|.
name|getTable
argument_list|()
decl_stmt|;
name|ConcurrentMap
argument_list|<
name|byte
index|[]
argument_list|,
name|RegionLocations
argument_list|>
name|tableLocations
init|=
name|getTableLocations
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|RegionLocations
name|regionLocations
init|=
name|tableLocations
operator|.
name|get
argument_list|(
name|location
operator|.
name|getRegion
argument_list|()
operator|.
name|getStartKey
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionLocations
operator|!=
literal|null
condition|)
block|{
name|RegionLocations
name|updatedLocations
init|=
name|regionLocations
operator|.
name|remove
argument_list|(
name|location
argument_list|)
decl_stmt|;
name|boolean
name|removed
decl_stmt|;
if|if
condition|(
name|updatedLocations
operator|!=
name|regionLocations
condition|)
block|{
if|if
condition|(
name|updatedLocations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|removed
operator|=
name|tableLocations
operator|.
name|remove
argument_list|(
name|location
operator|.
name|getRegion
argument_list|()
operator|.
name|getStartKey
argument_list|()
argument_list|,
name|regionLocations
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|removed
operator|=
name|tableLocations
operator|.
name|replace
argument_list|(
name|location
operator|.
name|getRegion
argument_list|()
operator|.
name|getStartKey
argument_list|()
argument_list|,
name|regionLocations
argument_list|,
name|updatedLocations
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|removed
condition|)
block|{
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|incrMetaCacheNumClearRegion
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Removed "
operator|+
name|location
operator|+
literal|" from cache"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

