begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Abortable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HColumnDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NamespaceDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Admin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ConnectionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Delete
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Get
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Put
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ResultScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RowMutations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Scan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|CompareFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|SingleColumnValueFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|BloomType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|RetryCounter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|RetryCounterFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|sun
operator|.
name|reflect
operator|.
name|generics
operator|.
name|reflectiveObjects
operator|.
name|NotImplementedException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * This class provides an implementation of the ReplicationQueues interface using an HBase table  * "Replication Table". The basic schema of this table will store each individual queue as a  * seperate row. The row key will be a unique identifier of the creating server's name and the  * queueId. Each queue must have the following two columns:  *  COL_OWNER: tracks which server is currently responsible for tracking the queue  *  COL_QUEUE_ID: tracks the queue's id as stored in ReplicationSource  * They will also have columns mapping [WAL filename : offset]  * One key difference from the ReplicationQueuesZkImpl is that when queues are reclaimed we  * simply return its HBase row key as its new "queueId"  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|ReplicationQueuesHBaseImpl
extends|extends
name|ReplicationStateZKBase
implements|implements
name|ReplicationQueues
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ReplicationQueuesHBaseImpl
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** Name of the HBase Table used for tracking replication*/
specifier|public
specifier|static
specifier|final
name|TableName
name|REPLICATION_TABLE_NAME
init|=
name|TableName
operator|.
name|valueOf
argument_list|(
name|NamespaceDescriptor
operator|.
name|SYSTEM_NAMESPACE_NAME_STR
argument_list|,
literal|"replication"
argument_list|)
decl_stmt|;
comment|// Column family and column names for the Replication Table
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|CF
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"r"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|COL_OWNER
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"o"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|COL_OWNER_HISTORY
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"h"
argument_list|)
decl_stmt|;
comment|// The value used to delimit the queueId and server name inside of a queue's row key. Currently a
comment|// hyphen, because it is guaranteed that queueId (which is a cluster id) cannot contain hyphens.
comment|// See HBASE-11394.
specifier|private
specifier|static
name|String
name|ROW_KEY_DELIMITER
init|=
literal|"-"
decl_stmt|;
comment|// Column Descriptor for the Replication Table
specifier|private
specifier|static
specifier|final
name|HColumnDescriptor
name|REPLICATION_COL_DESCRIPTOR
init|=
operator|new
name|HColumnDescriptor
argument_list|(
name|CF
argument_list|)
operator|.
name|setMaxVersions
argument_list|(
literal|1
argument_list|)
operator|.
name|setInMemory
argument_list|(
literal|true
argument_list|)
operator|.
name|setScope
argument_list|(
name|HConstants
operator|.
name|REPLICATION_SCOPE_LOCAL
argument_list|)
comment|// TODO: Figure out which bloom filter to use
operator|.
name|setBloomFilterType
argument_list|(
name|BloomType
operator|.
name|NONE
argument_list|)
operator|.
name|setCacheDataInL1
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|// Common byte values used in replication offset tracking
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|INITIAL_OFFSET_BYTES
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|0L
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|EMPTY_STRING_BYTES
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|""
argument_list|)
decl_stmt|;
comment|/*    * Make sure that HBase table operations for replication have a high number of retries. This is    * because the server is aborted if any HBase table operation fails. Each RPC will be attempted    * 3600 times before exiting. This provides each operation with 2 hours of retries    * before the server is aborted.    */
specifier|private
specifier|static
specifier|final
name|int
name|CLIENT_RETRIES
init|=
literal|3600
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|RPC_TIMEOUT
init|=
literal|2000
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|OPERATION_TIMEOUT
init|=
name|CLIENT_RETRIES
operator|*
name|RPC_TIMEOUT
decl_stmt|;
specifier|private
name|Configuration
name|modifiedConf
decl_stmt|;
specifier|private
name|Admin
name|admin
decl_stmt|;
specifier|private
name|Connection
name|connection
decl_stmt|;
specifier|private
name|Table
name|replicationTable
decl_stmt|;
specifier|private
name|String
name|serverName
init|=
literal|null
decl_stmt|;
specifier|private
name|byte
index|[]
name|serverNameBytes
init|=
literal|null
decl_stmt|;
specifier|public
name|ReplicationQueuesHBaseImpl
parameter_list|(
name|ReplicationQueuesArguments
name|args
parameter_list|)
block|{
name|this
argument_list|(
name|args
operator|.
name|getConf
argument_list|()
argument_list|,
name|args
operator|.
name|getAbortable
argument_list|()
argument_list|,
name|args
operator|.
name|getZk
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|ReplicationQueuesHBaseImpl
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Abortable
name|abort
parameter_list|,
name|ZooKeeperWatcher
name|zkw
parameter_list|)
block|{
name|super
argument_list|(
name|zkw
argument_list|,
name|conf
argument_list|,
name|abort
argument_list|)
expr_stmt|;
name|modifiedConf
operator|=
operator|new
name|Configuration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|modifiedConf
operator|.
name|setInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_RETRIES_NUMBER
argument_list|,
name|CLIENT_RETRIES
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|init
parameter_list|(
name|String
name|serverName
parameter_list|)
throws|throws
name|ReplicationException
block|{
try|try
block|{
name|this
operator|.
name|serverName
operator|=
name|serverName
expr_stmt|;
name|this
operator|.
name|serverNameBytes
operator|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
comment|// Modify the connection's config so that the Replication Table it returns has a much higher
comment|// number of client retries
name|this
operator|.
name|connection
operator|=
name|ConnectionFactory
operator|.
name|createConnection
argument_list|(
name|modifiedConf
argument_list|)
expr_stmt|;
name|this
operator|.
name|admin
operator|=
name|connection
operator|.
name|getAdmin
argument_list|()
expr_stmt|;
name|replicationTable
operator|=
name|createAndGetReplicationTable
argument_list|()
expr_stmt|;
name|replicationTable
operator|.
name|setRpcTimeout
argument_list|(
name|RPC_TIMEOUT
argument_list|)
expr_stmt|;
name|replicationTable
operator|.
name|setOperationTimeout
argument_list|(
name|OPERATION_TIMEOUT
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ReplicationException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeQueue
parameter_list|(
name|String
name|queueId
parameter_list|)
block|{
try|try
block|{
name|byte
index|[]
name|rowKey
init|=
name|queueIdToRowKey
argument_list|(
name|queueId
argument_list|)
decl_stmt|;
name|Delete
name|deleteQueue
init|=
operator|new
name|Delete
argument_list|(
name|rowKey
argument_list|)
decl_stmt|;
name|safeQueueUpdate
argument_list|(
name|deleteQueue
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|ReplicationException
name|e
parameter_list|)
block|{
name|String
name|errMsg
init|=
literal|"Failed removing queue queueId="
operator|+
name|queueId
decl_stmt|;
name|abortable
operator|.
name|abort
argument_list|(
name|errMsg
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|addLog
parameter_list|(
name|String
name|queueId
parameter_list|,
name|String
name|filename
parameter_list|)
throws|throws
name|ReplicationException
block|{
try|try
block|{
if|if
condition|(
operator|!
name|checkQueueExists
argument_list|(
name|queueId
argument_list|)
condition|)
block|{
comment|// Each queue will have an Owner, OwnerHistory, and a collection of [WAL:offset] key values
name|Put
name|putNewQueue
init|=
operator|new
name|Put
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|buildQueueRowKey
argument_list|(
name|queueId
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|putNewQueue
operator|.
name|addColumn
argument_list|(
name|CF
argument_list|,
name|COL_OWNER
argument_list|,
name|serverNameBytes
argument_list|)
expr_stmt|;
name|putNewQueue
operator|.
name|addColumn
argument_list|(
name|CF
argument_list|,
name|COL_OWNER_HISTORY
argument_list|,
name|EMPTY_STRING_BYTES
argument_list|)
expr_stmt|;
name|putNewQueue
operator|.
name|addColumn
argument_list|(
name|CF
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|filename
argument_list|)
argument_list|,
name|INITIAL_OFFSET_BYTES
argument_list|)
expr_stmt|;
name|replicationTable
operator|.
name|put
argument_list|(
name|putNewQueue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Otherwise simply add the new log and offset as a new column
name|Put
name|putNewLog
init|=
operator|new
name|Put
argument_list|(
name|queueIdToRowKey
argument_list|(
name|queueId
argument_list|)
argument_list|)
decl_stmt|;
name|putNewLog
operator|.
name|addColumn
argument_list|(
name|CF
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|filename
argument_list|)
argument_list|,
name|INITIAL_OFFSET_BYTES
argument_list|)
expr_stmt|;
name|safeQueueUpdate
argument_list|(
name|putNewLog
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|ReplicationException
name|e
parameter_list|)
block|{
name|String
name|errMsg
init|=
literal|"Failed adding log queueId="
operator|+
name|queueId
operator|+
literal|" filename="
operator|+
name|filename
decl_stmt|;
name|abortable
operator|.
name|abort
argument_list|(
name|errMsg
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeLog
parameter_list|(
name|String
name|queueId
parameter_list|,
name|String
name|filename
parameter_list|)
block|{
try|try
block|{
name|byte
index|[]
name|rowKey
init|=
name|queueIdToRowKey
argument_list|(
name|queueId
argument_list|)
decl_stmt|;
name|Delete
name|delete
init|=
operator|new
name|Delete
argument_list|(
name|rowKey
argument_list|)
decl_stmt|;
name|delete
operator|.
name|addColumns
argument_list|(
name|CF
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|safeQueueUpdate
argument_list|(
name|delete
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|ReplicationException
name|e
parameter_list|)
block|{
name|String
name|errMsg
init|=
literal|"Failed removing log queueId="
operator|+
name|queueId
operator|+
literal|" filename="
operator|+
name|filename
decl_stmt|;
name|abortable
operator|.
name|abort
argument_list|(
name|errMsg
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|setLogPosition
parameter_list|(
name|String
name|queueId
parameter_list|,
name|String
name|filename
parameter_list|,
name|long
name|position
parameter_list|)
block|{
try|try
block|{
name|byte
index|[]
name|rowKey
init|=
name|queueIdToRowKey
argument_list|(
name|queueId
argument_list|)
decl_stmt|;
comment|// Check that the log exists. addLog() must have been called before setLogPosition().
name|Get
name|checkLogExists
init|=
operator|new
name|Get
argument_list|(
name|rowKey
argument_list|)
decl_stmt|;
name|checkLogExists
operator|.
name|addColumn
argument_list|(
name|CF
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|replicationTable
operator|.
name|exists
argument_list|(
name|checkLogExists
argument_list|)
condition|)
block|{
name|String
name|errMsg
init|=
literal|"Could not set position of non-existent log from queueId="
operator|+
name|queueId
operator|+
literal|", filename="
operator|+
name|filename
decl_stmt|;
name|abortable
operator|.
name|abort
argument_list|(
name|errMsg
argument_list|,
operator|new
name|ReplicationException
argument_list|(
name|errMsg
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Update the log offset if it exists
name|Put
name|walAndOffset
init|=
operator|new
name|Put
argument_list|(
name|rowKey
argument_list|)
decl_stmt|;
name|walAndOffset
operator|.
name|addColumn
argument_list|(
name|CF
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|filename
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|position
argument_list|)
argument_list|)
expr_stmt|;
name|safeQueueUpdate
argument_list|(
name|walAndOffset
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|ReplicationException
name|e
parameter_list|)
block|{
name|String
name|errMsg
init|=
literal|"Failed writing log position queueId="
operator|+
name|queueId
operator|+
literal|"filename="
operator|+
name|filename
operator|+
literal|" position="
operator|+
name|position
decl_stmt|;
name|abortable
operator|.
name|abort
argument_list|(
name|errMsg
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|long
name|getLogPosition
parameter_list|(
name|String
name|queueId
parameter_list|,
name|String
name|filename
parameter_list|)
throws|throws
name|ReplicationException
block|{
try|try
block|{
name|byte
index|[]
name|rowKey
init|=
name|queueIdToRowKey
argument_list|(
name|queueId
argument_list|)
decl_stmt|;
name|Get
name|getOffset
init|=
operator|new
name|Get
argument_list|(
name|rowKey
argument_list|)
decl_stmt|;
name|getOffset
operator|.
name|addColumn
argument_list|(
name|CF
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|Result
name|result
init|=
name|getResultIfOwner
argument_list|(
name|getOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
operator|||
operator|!
name|result
operator|.
name|containsColumn
argument_list|(
name|CF
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|filename
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ReplicationException
argument_list|(
literal|"Could not read empty result while getting log position "
operator|+
literal|"queueId="
operator|+
name|queueId
operator|+
literal|", filename="
operator|+
name|filename
argument_list|)
throw|;
block|}
return|return
name|Bytes
operator|.
name|toLong
argument_list|(
name|result
operator|.
name|getValue
argument_list|(
name|CF
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|filename
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ReplicationException
argument_list|(
literal|"Could not get position in log for queueId="
operator|+
name|queueId
operator|+
literal|", filename="
operator|+
name|filename
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeAllQueues
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|myQueueIds
init|=
name|getAllQueues
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|queueId
range|:
name|myQueueIds
control|)
block|{
name|removeQueue
argument_list|(
name|queueId
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getLogsInQueue
parameter_list|(
name|String
name|queueId
parameter_list|)
block|{
name|byte
index|[]
name|rowKey
init|=
name|queueIdToRowKey
argument_list|(
name|queueId
argument_list|)
decl_stmt|;
return|return
name|getLogsInQueue
argument_list|(
name|rowKey
argument_list|)
return|;
block|}
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getLogsInQueue
parameter_list|(
name|byte
index|[]
name|rowKey
parameter_list|)
block|{
name|String
name|errMsg
init|=
literal|"Could not get logs in queue queueId="
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|rowKey
argument_list|)
decl_stmt|;
try|try
block|{
name|Get
name|getQueue
init|=
operator|new
name|Get
argument_list|(
name|rowKey
argument_list|)
decl_stmt|;
name|Result
name|queue
init|=
name|getResultIfOwner
argument_list|(
name|getQueue
argument_list|)
decl_stmt|;
comment|// The returned queue could be null if we have lost ownership of it
if|if
condition|(
name|queue
operator|==
literal|null
condition|)
block|{
name|abortable
operator|.
name|abort
argument_list|(
name|errMsg
argument_list|,
operator|new
name|ReplicationException
argument_list|(
name|errMsg
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|readWALsFromResult
argument_list|(
name|queue
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|abortable
operator|.
name|abort
argument_list|(
name|errMsg
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getAllQueues
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|allQueues
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ResultScanner
name|queueScanner
init|=
literal|null
decl_stmt|;
try|try
block|{
name|queueScanner
operator|=
name|this
operator|.
name|getQueuesBelongingToServer
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
for|for
control|(
name|Result
name|queue
range|:
name|queueScanner
control|)
block|{
name|String
name|rowKey
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|queue
operator|.
name|getRow
argument_list|()
argument_list|)
decl_stmt|;
comment|// If the queue does not have a Owner History, then we must be its original owner. So we
comment|// want to return its queueId in raw form
if|if
condition|(
name|Bytes
operator|.
name|toString
argument_list|(
name|queue
operator|.
name|getValue
argument_list|(
name|CF
argument_list|,
name|COL_OWNER_HISTORY
argument_list|)
argument_list|)
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|allQueues
operator|.
name|add
argument_list|(
name|getRawQueueIdFromRowKey
argument_list|(
name|rowKey
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|allQueues
operator|.
name|add
argument_list|(
name|rowKey
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|allQueues
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|String
name|errMsg
init|=
literal|"Failed getting list of all replication queues"
decl_stmt|;
name|abortable
operator|.
name|abort
argument_list|(
name|errMsg
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|queueScanner
operator|!=
literal|null
condition|)
block|{
name|queueScanner
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|claimQueues
parameter_list|(
name|String
name|regionserver
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|queues
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|isThisOurRegionServer
argument_list|(
name|regionserver
argument_list|)
condition|)
block|{
return|return
name|queues
return|;
block|}
name|ResultScanner
name|queuesToClaim
init|=
literal|null
decl_stmt|;
try|try
block|{
name|queuesToClaim
operator|=
name|this
operator|.
name|getQueuesBelongingToServer
argument_list|(
name|regionserver
argument_list|)
expr_stmt|;
for|for
control|(
name|Result
name|queue
range|:
name|queuesToClaim
control|)
block|{
if|if
condition|(
name|attemptToClaimQueue
argument_list|(
name|queue
argument_list|,
name|regionserver
argument_list|)
condition|)
block|{
name|String
name|rowKey
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|queue
operator|.
name|getRow
argument_list|()
argument_list|)
decl_stmt|;
name|ReplicationQueueInfo
name|replicationQueueInfo
init|=
operator|new
name|ReplicationQueueInfo
argument_list|(
name|rowKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|peerExists
argument_list|(
name|replicationQueueInfo
operator|.
name|getPeerId
argument_list|()
argument_list|)
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|sortedLogs
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|logs
init|=
name|getLogsInQueue
argument_list|(
name|queue
operator|.
name|getRow
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|log
range|:
name|logs
control|)
block|{
name|sortedLogs
operator|.
name|add
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|}
name|queues
operator|.
name|put
argument_list|(
name|rowKey
argument_list|,
name|sortedLogs
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|serverName
operator|+
literal|" has claimed queue "
operator|+
name|rowKey
operator|+
literal|" from "
operator|+
name|regionserver
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Delete orphaned queues
name|removeQueue
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|queue
operator|.
name|getRow
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|serverName
operator|+
literal|" has deleted abandoned queue "
operator|+
name|rowKey
operator|+
literal|" from "
operator|+
name|regionserver
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|KeeperException
name|e
parameter_list|)
block|{
name|String
name|errMsg
init|=
literal|"Failed claiming queues for regionserver="
operator|+
name|regionserver
decl_stmt|;
name|abortable
operator|.
name|abort
argument_list|(
name|errMsg
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|queues
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|queuesToClaim
operator|!=
literal|null
condition|)
block|{
name|queuesToClaim
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|queues
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getListOfReplicators
parameter_list|()
block|{
comment|// scan all of the queues and return a list of all unique OWNER values
name|Set
argument_list|<
name|String
argument_list|>
name|peerServers
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ResultScanner
name|allQueuesInCluster
init|=
literal|null
decl_stmt|;
try|try
block|{
name|Scan
name|scan
init|=
operator|new
name|Scan
argument_list|()
decl_stmt|;
name|scan
operator|.
name|addColumn
argument_list|(
name|CF
argument_list|,
name|COL_OWNER
argument_list|)
expr_stmt|;
name|allQueuesInCluster
operator|=
name|replicationTable
operator|.
name|getScanner
argument_list|(
name|scan
argument_list|)
expr_stmt|;
for|for
control|(
name|Result
name|queue
range|:
name|allQueuesInCluster
control|)
block|{
name|peerServers
operator|.
name|add
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|queue
operator|.
name|getValue
argument_list|(
name|CF
argument_list|,
name|COL_OWNER
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|String
name|errMsg
init|=
literal|"Failed getting list of replicators"
decl_stmt|;
name|abortable
operator|.
name|abort
argument_list|(
name|errMsg
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|allQueuesInCluster
operator|!=
literal|null
condition|)
block|{
name|allQueuesInCluster
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|peerServers
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isThisOurRegionServer
parameter_list|(
name|String
name|regionserver
parameter_list|)
block|{
return|return
name|this
operator|.
name|serverName
operator|.
name|equals
argument_list|(
name|regionserver
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addPeerToHFileRefs
parameter_list|(
name|String
name|peerId
parameter_list|)
throws|throws
name|ReplicationException
block|{
comment|// TODO
throw|throw
operator|new
name|NotImplementedException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|removePeerFromHFileRefs
parameter_list|(
name|String
name|peerId
parameter_list|)
block|{
comment|// TODO
throw|throw
operator|new
name|NotImplementedException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addHFileRefs
parameter_list|(
name|String
name|peerId
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|files
parameter_list|)
throws|throws
name|ReplicationException
block|{
comment|// TODO
throw|throw
operator|new
name|NotImplementedException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeHFileRefs
parameter_list|(
name|String
name|peerId
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|files
parameter_list|)
block|{
comment|// TODO
throw|throw
operator|new
name|NotImplementedException
argument_list|()
throw|;
block|}
comment|/**    * Gets the Replication Table. Builds and blocks until the table is available if the Replication    * Table does not exist.    *    * @return the Replication Table    * @throws IOException if the Replication Table takes too long to build    */
specifier|private
name|Table
name|createAndGetReplicationTable
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|replicationTableExists
argument_list|()
condition|)
block|{
name|createReplicationTable
argument_list|()
expr_stmt|;
block|}
name|int
name|maxRetries
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"replication.queues.createtable.retries.number"
argument_list|,
literal|100
argument_list|)
decl_stmt|;
name|RetryCounterFactory
name|counterFactory
init|=
operator|new
name|RetryCounterFactory
argument_list|(
name|maxRetries
argument_list|,
literal|100
argument_list|)
decl_stmt|;
name|RetryCounter
name|retryCounter
init|=
name|counterFactory
operator|.
name|create
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|replicationTableExists
argument_list|()
condition|)
block|{
try|try
block|{
name|retryCounter
operator|.
name|sleepUntilNextRetry
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|retryCounter
operator|.
name|shouldRetry
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to acquire the Replication Table"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
return|return
name|connection
operator|.
name|getTable
argument_list|(
name|REPLICATION_TABLE_NAME
argument_list|)
return|;
block|}
comment|/**    * Checks whether the Replication Table exists yet    *    * @return whether the Replication Table exists    * @throws IOException    */
specifier|private
name|boolean
name|replicationTableExists
parameter_list|()
block|{
try|try
block|{
return|return
name|admin
operator|.
name|tableExists
argument_list|(
name|REPLICATION_TABLE_NAME
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Create the replication table with the provided HColumnDescriptor REPLICATION_COL_DESCRIPTOR    * in ReplicationQueuesHBaseImpl    *    * @throws IOException    */
specifier|private
name|void
name|createReplicationTable
parameter_list|()
throws|throws
name|IOException
block|{
name|HTableDescriptor
name|replicationTableDescriptor
init|=
operator|new
name|HTableDescriptor
argument_list|(
name|REPLICATION_TABLE_NAME
argument_list|)
decl_stmt|;
name|replicationTableDescriptor
operator|.
name|addFamily
argument_list|(
name|REPLICATION_COL_DESCRIPTOR
argument_list|)
expr_stmt|;
name|admin
operator|.
name|createTable
argument_list|(
name|replicationTableDescriptor
argument_list|)
expr_stmt|;
block|}
comment|/**    * Build the row key for the given queueId. This will uniquely identify it from all other queues    * in the cluster.    * @param serverName The owner of the queue    * @param queueId String identifier of the queue    * @return String representation of the queue's row key    */
specifier|private
name|String
name|buildQueueRowKey
parameter_list|(
name|String
name|serverName
parameter_list|,
name|String
name|queueId
parameter_list|)
block|{
return|return
name|queueId
operator|+
name|ROW_KEY_DELIMITER
operator|+
name|serverName
return|;
block|}
specifier|private
name|String
name|buildQueueRowKey
parameter_list|(
name|String
name|queueId
parameter_list|)
block|{
return|return
name|buildQueueRowKey
argument_list|(
name|serverName
argument_list|,
name|queueId
argument_list|)
return|;
block|}
comment|/**    * Parse the original queueId from a row key    * @param rowKey String representation of a queue's row key    * @return the original queueId    */
specifier|private
name|String
name|getRawQueueIdFromRowKey
parameter_list|(
name|String
name|rowKey
parameter_list|)
block|{
return|return
name|rowKey
operator|.
name|split
argument_list|(
name|ROW_KEY_DELIMITER
argument_list|)
index|[
literal|0
index|]
return|;
block|}
comment|/**    * See safeQueueUpdate(RowMutations mutate)    *    * @param put Row mutation to perform on the queue    */
specifier|private
name|void
name|safeQueueUpdate
parameter_list|(
name|Put
name|put
parameter_list|)
throws|throws
name|ReplicationException
throws|,
name|IOException
block|{
name|RowMutations
name|mutations
init|=
operator|new
name|RowMutations
argument_list|(
name|put
operator|.
name|getRow
argument_list|()
argument_list|)
decl_stmt|;
name|mutations
operator|.
name|add
argument_list|(
name|put
argument_list|)
expr_stmt|;
name|safeQueueUpdate
argument_list|(
name|mutations
argument_list|)
expr_stmt|;
block|}
comment|/**    * See safeQueueUpdate(RowMutations mutate)    *    * @param delete Row mutation to perform on the queue    */
specifier|private
name|void
name|safeQueueUpdate
parameter_list|(
name|Delete
name|delete
parameter_list|)
throws|throws
name|ReplicationException
throws|,
name|IOException
block|{
name|RowMutations
name|mutations
init|=
operator|new
name|RowMutations
argument_list|(
name|delete
operator|.
name|getRow
argument_list|()
argument_list|)
decl_stmt|;
name|mutations
operator|.
name|add
argument_list|(
name|delete
argument_list|)
expr_stmt|;
name|safeQueueUpdate
argument_list|(
name|mutations
argument_list|)
expr_stmt|;
block|}
comment|/**    * Attempt to mutate a given queue in the Replication Table with a checkAndPut on the OWNER column    * of the queue. Abort the server if this checkAndPut fails: which means we have somehow lost    * ownership of the column or an IO Exception has occurred during the transaction.    *    * @param mutate Mutation to perform on a given queue    */
specifier|private
name|void
name|safeQueueUpdate
parameter_list|(
name|RowMutations
name|mutate
parameter_list|)
throws|throws
name|ReplicationException
throws|,
name|IOException
block|{
name|boolean
name|updateSuccess
init|=
name|replicationTable
operator|.
name|checkAndMutate
argument_list|(
name|mutate
operator|.
name|getRow
argument_list|()
argument_list|,
name|CF
argument_list|,
name|COL_OWNER
argument_list|,
name|CompareFilter
operator|.
name|CompareOp
operator|.
name|EQUAL
argument_list|,
name|serverNameBytes
argument_list|,
name|mutate
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|updateSuccess
condition|)
block|{
throw|throw
operator|new
name|ReplicationException
argument_list|(
literal|"Failed to update Replication Table because we lost queue "
operator|+
literal|" ownership"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns a queue's row key given either its raw or reclaimed queueId    *    * @param queueId queueId of the queue    * @return byte representation of the queue's row key    */
specifier|private
name|byte
index|[]
name|queueIdToRowKey
parameter_list|(
name|String
name|queueId
parameter_list|)
block|{
comment|// Cluster id's are guaranteed to have no hyphens, so if the passed in queueId has no hyphen
comment|// then this is not a reclaimed queue.
if|if
condition|(
operator|!
name|queueId
operator|.
name|contains
argument_list|(
name|ROW_KEY_DELIMITER
argument_list|)
condition|)
block|{
return|return
name|Bytes
operator|.
name|toBytes
argument_list|(
name|buildQueueRowKey
argument_list|(
name|queueId
argument_list|)
argument_list|)
return|;
comment|// If the queueId contained some hyphen it was reclaimed. In this case, the queueId is the
comment|// queue's row key
block|}
else|else
block|{
return|return
name|Bytes
operator|.
name|toBytes
argument_list|(
name|queueId
argument_list|)
return|;
block|}
block|}
comment|/**    * Get the QueueIds belonging to the named server from the ReplicationTable    *    * @param server name of the server    * @return a ResultScanner over the QueueIds belonging to the server    * @throws IOException    */
specifier|private
name|ResultScanner
name|getQueuesBelongingToServer
parameter_list|(
name|String
name|server
parameter_list|)
throws|throws
name|IOException
block|{
name|Scan
name|scan
init|=
operator|new
name|Scan
argument_list|()
decl_stmt|;
name|SingleColumnValueFilter
name|filterMyQueues
init|=
operator|new
name|SingleColumnValueFilter
argument_list|(
name|CF
argument_list|,
name|COL_OWNER
argument_list|,
name|CompareFilter
operator|.
name|CompareOp
operator|.
name|EQUAL
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|server
argument_list|)
argument_list|)
decl_stmt|;
name|scan
operator|.
name|setFilter
argument_list|(
name|filterMyQueues
argument_list|)
expr_stmt|;
name|scan
operator|.
name|addColumn
argument_list|(
name|CF
argument_list|,
name|COL_OWNER
argument_list|)
expr_stmt|;
name|scan
operator|.
name|addColumn
argument_list|(
name|CF
argument_list|,
name|COL_OWNER_HISTORY
argument_list|)
expr_stmt|;
name|ResultScanner
name|results
init|=
name|replicationTable
operator|.
name|getScanner
argument_list|(
name|scan
argument_list|)
decl_stmt|;
return|return
name|results
return|;
block|}
comment|/**    * Check if the queue specified by queueId is stored in HBase    *    * @param queueId Either raw or reclaimed format of the queueId    * @return Whether the queue is stored in HBase    * @throws IOException    */
specifier|private
name|boolean
name|checkQueueExists
parameter_list|(
name|String
name|queueId
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|rowKey
init|=
name|queueIdToRowKey
argument_list|(
name|queueId
argument_list|)
decl_stmt|;
return|return
name|replicationTable
operator|.
name|exists
argument_list|(
operator|new
name|Get
argument_list|(
name|rowKey
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Read all of the WAL's from a queue into a list    *    * @param queue HBase query result containing the queue    * @return a list of all the WAL filenames    */
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|readWALsFromResult
parameter_list|(
name|Result
name|queue
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|wals
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|familyMap
init|=
name|queue
operator|.
name|getFamilyMap
argument_list|(
name|CF
argument_list|)
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|cQualifier
range|:
name|familyMap
operator|.
name|keySet
argument_list|()
control|)
block|{
comment|// Ignore the meta data fields of the queue
if|if
condition|(
name|Arrays
operator|.
name|equals
argument_list|(
name|cQualifier
argument_list|,
name|COL_OWNER
argument_list|)
operator|||
name|Arrays
operator|.
name|equals
argument_list|(
name|cQualifier
argument_list|,
name|COL_OWNER_HISTORY
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|wals
operator|.
name|add
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|cQualifier
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|wals
return|;
block|}
comment|/**    * Attempt to claim the given queue with a checkAndPut on the OWNER column. We check that the    * recently killed server is still the OWNER before we claim it.    *    * @param queue The queue that we are trying to claim    * @param originalServer The server that originally owned the queue    * @return Whether we successfully claimed the queue    * @throws IOException    */
specifier|private
name|boolean
name|attemptToClaimQueue
parameter_list|(
name|Result
name|queue
parameter_list|,
name|String
name|originalServer
parameter_list|)
throws|throws
name|IOException
block|{
name|Put
name|putQueueNameAndHistory
init|=
operator|new
name|Put
argument_list|(
name|queue
operator|.
name|getRow
argument_list|()
argument_list|)
decl_stmt|;
name|putQueueNameAndHistory
operator|.
name|addColumn
argument_list|(
name|CF
argument_list|,
name|COL_OWNER
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|serverName
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|newOwnerHistory
init|=
name|buildClaimedQueueHistory
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|queue
operator|.
name|getValue
argument_list|(
name|CF
argument_list|,
name|COL_OWNER_HISTORY
argument_list|)
argument_list|)
argument_list|,
name|originalServer
argument_list|)
decl_stmt|;
name|putQueueNameAndHistory
operator|.
name|addColumn
argument_list|(
name|CF
argument_list|,
name|COL_OWNER_HISTORY
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|newOwnerHistory
argument_list|)
argument_list|)
expr_stmt|;
name|RowMutations
name|claimAndRenameQueue
init|=
operator|new
name|RowMutations
argument_list|(
name|queue
operator|.
name|getRow
argument_list|()
argument_list|)
decl_stmt|;
name|claimAndRenameQueue
operator|.
name|add
argument_list|(
name|putQueueNameAndHistory
argument_list|)
expr_stmt|;
comment|// Attempt to claim ownership for this queue by checking if the current OWNER is the original
comment|// server. If it is not then another RS has already claimed it. If it is we set ourselves as the
comment|// new owner and update the queue's history
name|boolean
name|success
init|=
name|replicationTable
operator|.
name|checkAndMutate
argument_list|(
name|queue
operator|.
name|getRow
argument_list|()
argument_list|,
name|CF
argument_list|,
name|COL_OWNER
argument_list|,
name|CompareFilter
operator|.
name|CompareOp
operator|.
name|EQUAL
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|originalServer
argument_list|)
argument_list|,
name|claimAndRenameQueue
argument_list|)
decl_stmt|;
return|return
name|success
return|;
block|}
comment|/**    * Creates a "|" delimited record of the queue's past region server owners.    *    * @param originalHistory the queue's original owner history    * @param oldServer the name of the server that used to own the queue    * @return the queue's new owner history    */
specifier|private
name|String
name|buildClaimedQueueHistory
parameter_list|(
name|String
name|originalHistory
parameter_list|,
name|String
name|oldServer
parameter_list|)
block|{
return|return
name|originalHistory
operator|+
literal|"|"
operator|+
name|oldServer
return|;
block|}
comment|/**    * Attempts to run a Get on some queue. Will only return a non-null result if we currently own    * the queue.    *    * @param get The get that we want to query    * @return The result of the get if this server is the owner of the queue. Else it returns null    * @throws IOException    */
specifier|private
name|Result
name|getResultIfOwner
parameter_list|(
name|Get
name|get
parameter_list|)
throws|throws
name|IOException
block|{
name|Scan
name|scan
init|=
operator|new
name|Scan
argument_list|(
name|get
argument_list|)
decl_stmt|;
comment|// Check if the Get currently contains all columns or only specific columns
if|if
condition|(
name|scan
operator|.
name|getFamilyMap
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Add the OWNER column if the scan is already only over specific columns
name|scan
operator|.
name|addColumn
argument_list|(
name|CF
argument_list|,
name|COL_OWNER
argument_list|)
expr_stmt|;
block|}
name|scan
operator|.
name|setMaxResultSize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|SingleColumnValueFilter
name|checkOwner
init|=
operator|new
name|SingleColumnValueFilter
argument_list|(
name|CF
argument_list|,
name|COL_OWNER
argument_list|,
name|CompareFilter
operator|.
name|CompareOp
operator|.
name|EQUAL
argument_list|,
name|serverNameBytes
argument_list|)
decl_stmt|;
name|scan
operator|.
name|setFilter
argument_list|(
name|checkOwner
argument_list|)
expr_stmt|;
name|ResultScanner
name|scanner
init|=
literal|null
decl_stmt|;
try|try
block|{
name|scanner
operator|=
name|replicationTable
operator|.
name|getScanner
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|Result
name|result
init|=
name|scanner
operator|.
name|next
argument_list|()
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|||
name|result
operator|.
name|isEmpty
argument_list|()
operator|)
condition|?
literal|null
else|:
name|result
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|scanner
operator|!=
literal|null
condition|)
block|{
name|scanner
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

