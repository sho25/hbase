begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Abortable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HColumnDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NamespaceDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Admin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ConnectionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Delete
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Get
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Put
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ResultScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RowMutations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Scan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|CompareFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|FilterList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|FirstKeyOnlyFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|SingleColumnValueFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|BloomType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|RetryCounter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|RetryCounterFactory
import|;
end_import

begin_import
import|import
name|sun
operator|.
name|reflect
operator|.
name|generics
operator|.
name|reflectiveObjects
operator|.
name|NotImplementedException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|ReplicationQueuesHBaseImpl
implements|implements
name|ReplicationQueues
block|{
comment|/** Name of the HBase Table used for tracking replication*/
specifier|public
specifier|static
specifier|final
name|TableName
name|REPLICATION_TABLE_NAME
init|=
name|TableName
operator|.
name|valueOf
argument_list|(
name|NamespaceDescriptor
operator|.
name|SYSTEM_NAMESPACE_NAME_STR
argument_list|,
literal|"replication"
argument_list|)
decl_stmt|;
comment|// Column family and column names for the Replication Table
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|CF
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"r"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|COL_OWNER
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"o"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|COL_QUEUE_ID
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"q"
argument_list|)
decl_stmt|;
comment|// Column Descriptor for the Replication Table
specifier|private
specifier|static
specifier|final
name|HColumnDescriptor
name|REPLICATION_COL_DESCRIPTOR
init|=
operator|new
name|HColumnDescriptor
argument_list|(
name|CF
argument_list|)
operator|.
name|setMaxVersions
argument_list|(
literal|1
argument_list|)
operator|.
name|setInMemory
argument_list|(
literal|true
argument_list|)
operator|.
name|setScope
argument_list|(
name|HConstants
operator|.
name|REPLICATION_SCOPE_LOCAL
argument_list|)
comment|// TODO: Figure out which bloom filter to use
operator|.
name|setBloomFilterType
argument_list|(
name|BloomType
operator|.
name|NONE
argument_list|)
operator|.
name|setCacheDataInL1
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|// Common byte values used in replication offset tracking
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|INITIAL_OFFSET
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|0L
argument_list|)
decl_stmt|;
comment|/*    * Make sure that HBase table operations for replication have a high number of retries. This is    * because the server is aborted if any HBase table operation fails. Each RPC will be attempted    * 3600 times before exiting. This provides each operation with 2 hours of retries    * before the server is aborted.    */
specifier|private
specifier|static
specifier|final
name|int
name|CLIENT_RETRIES
init|=
literal|3600
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|RPC_TIMEOUT
init|=
literal|2000
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|OPERATION_TIMEOUT
init|=
name|CLIENT_RETRIES
operator|*
name|RPC_TIMEOUT
decl_stmt|;
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
specifier|private
specifier|final
name|Admin
name|admin
decl_stmt|;
specifier|private
specifier|final
name|Connection
name|connection
decl_stmt|;
specifier|private
specifier|final
name|Table
name|replicationTable
decl_stmt|;
specifier|private
specifier|final
name|Abortable
name|abortable
decl_stmt|;
specifier|private
name|String
name|serverName
init|=
literal|null
decl_stmt|;
specifier|private
name|byte
index|[]
name|serverNameBytes
init|=
literal|null
decl_stmt|;
specifier|public
name|ReplicationQueuesHBaseImpl
parameter_list|(
name|ReplicationQueuesArguments
name|args
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|args
operator|.
name|getConf
argument_list|()
argument_list|,
name|args
operator|.
name|getAbort
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|ReplicationQueuesHBaseImpl
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Abortable
name|abort
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|conf
operator|=
operator|new
name|Configuration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// Modify the connection's config so that the Replication Table it returns has a much higher
comment|// number of client retries
name|conf
operator|.
name|setInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_RETRIES_NUMBER
argument_list|,
name|CLIENT_RETRIES
argument_list|)
expr_stmt|;
name|this
operator|.
name|connection
operator|=
name|ConnectionFactory
operator|.
name|createConnection
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|admin
operator|=
name|connection
operator|.
name|getAdmin
argument_list|()
expr_stmt|;
name|this
operator|.
name|abortable
operator|=
name|abort
expr_stmt|;
name|replicationTable
operator|=
name|createAndGetReplicationTable
argument_list|()
expr_stmt|;
name|replicationTable
operator|.
name|setRpcTimeout
argument_list|(
name|RPC_TIMEOUT
argument_list|)
expr_stmt|;
name|replicationTable
operator|.
name|setOperationTimeout
argument_list|(
name|OPERATION_TIMEOUT
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|init
parameter_list|(
name|String
name|serverName
parameter_list|)
throws|throws
name|ReplicationException
block|{
name|this
operator|.
name|serverName
operator|=
name|serverName
expr_stmt|;
name|this
operator|.
name|serverNameBytes
operator|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeQueue
parameter_list|(
name|String
name|queueId
parameter_list|)
block|{
try|try
block|{
name|byte
index|[]
name|rowKey
init|=
name|this
operator|.
name|queueIdToRowKey
argument_list|(
name|queueId
argument_list|)
decl_stmt|;
comment|// The rowkey will be null if the queue cannot be found in the Replication Table
if|if
condition|(
name|rowKey
operator|==
literal|null
condition|)
block|{
name|String
name|errMsg
init|=
literal|"Could not remove non-existent queue with queueId="
operator|+
name|queueId
decl_stmt|;
name|abortable
operator|.
name|abort
argument_list|(
name|errMsg
argument_list|,
operator|new
name|ReplicationException
argument_list|(
name|errMsg
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|Delete
name|deleteQueue
init|=
operator|new
name|Delete
argument_list|(
name|rowKey
argument_list|)
decl_stmt|;
name|safeQueueUpdate
argument_list|(
name|deleteQueue
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|abortable
operator|.
name|abort
argument_list|(
literal|"Could not remove queue with queueId="
operator|+
name|queueId
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|addLog
parameter_list|(
name|String
name|queueId
parameter_list|,
name|String
name|filename
parameter_list|)
throws|throws
name|ReplicationException
block|{
try|try
block|{
comment|// Check if the queue info (Owner, QueueId) is currently stored in the Replication Table
if|if
condition|(
name|this
operator|.
name|queueIdToRowKey
argument_list|(
name|queueId
argument_list|)
operator|==
literal|null
condition|)
block|{
comment|// Each queue will have an Owner, QueueId, and a collection of [WAL:offset] key values.
name|Put
name|putNewQueue
init|=
operator|new
name|Put
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|buildServerQueueName
argument_list|(
name|queueId
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|putNewQueue
operator|.
name|addColumn
argument_list|(
name|CF
argument_list|,
name|COL_OWNER
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|serverName
argument_list|)
argument_list|)
expr_stmt|;
name|putNewQueue
operator|.
name|addColumn
argument_list|(
name|CF
argument_list|,
name|COL_QUEUE_ID
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|queueId
argument_list|)
argument_list|)
expr_stmt|;
name|putNewQueue
operator|.
name|addColumn
argument_list|(
name|CF
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|filename
argument_list|)
argument_list|,
name|INITIAL_OFFSET
argument_list|)
expr_stmt|;
name|replicationTable
operator|.
name|put
argument_list|(
name|putNewQueue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Otherwise simply add the new log and offset as a new column
name|Put
name|putNewLog
init|=
operator|new
name|Put
argument_list|(
name|this
operator|.
name|queueIdToRowKey
argument_list|(
name|queueId
argument_list|)
argument_list|)
decl_stmt|;
name|putNewLog
operator|.
name|addColumn
argument_list|(
name|CF
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|filename
argument_list|)
argument_list|,
name|INITIAL_OFFSET
argument_list|)
expr_stmt|;
name|safeQueueUpdate
argument_list|(
name|putNewLog
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|abortable
operator|.
name|abort
argument_list|(
literal|"Could not add queue queueId="
operator|+
name|queueId
operator|+
literal|" filename="
operator|+
name|filename
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeLog
parameter_list|(
name|String
name|queueId
parameter_list|,
name|String
name|filename
parameter_list|)
block|{
try|try
block|{
name|byte
index|[]
name|rowKey
init|=
name|this
operator|.
name|queueIdToRowKey
argument_list|(
name|queueId
argument_list|)
decl_stmt|;
if|if
condition|(
name|rowKey
operator|==
literal|null
condition|)
block|{
name|String
name|errMsg
init|=
literal|"Could not remove log from non-existent queueId="
operator|+
name|queueId
operator|+
literal|", filename="
operator|+
name|filename
decl_stmt|;
name|abortable
operator|.
name|abort
argument_list|(
name|errMsg
argument_list|,
operator|new
name|ReplicationException
argument_list|(
name|errMsg
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|Delete
name|delete
init|=
operator|new
name|Delete
argument_list|(
name|rowKey
argument_list|)
decl_stmt|;
name|delete
operator|.
name|addColumns
argument_list|(
name|CF
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|safeQueueUpdate
argument_list|(
name|delete
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|abortable
operator|.
name|abort
argument_list|(
literal|"Could not remove log from queueId="
operator|+
name|queueId
operator|+
literal|", filename="
operator|+
name|filename
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|setLogPosition
parameter_list|(
name|String
name|queueId
parameter_list|,
name|String
name|filename
parameter_list|,
name|long
name|position
parameter_list|)
block|{
try|try
block|{
name|byte
index|[]
name|rowKey
init|=
name|this
operator|.
name|queueIdToRowKey
argument_list|(
name|queueId
argument_list|)
decl_stmt|;
if|if
condition|(
name|rowKey
operator|==
literal|null
condition|)
block|{
name|String
name|errMsg
init|=
literal|"Could not set position of log from non-existent queueId="
operator|+
name|queueId
operator|+
literal|", filename="
operator|+
name|filename
decl_stmt|;
name|abortable
operator|.
name|abort
argument_list|(
name|errMsg
argument_list|,
operator|new
name|ReplicationException
argument_list|(
name|errMsg
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Check that the log exists. addLog() must have been called before setLogPosition().
name|Get
name|checkLogExists
init|=
operator|new
name|Get
argument_list|(
name|rowKey
argument_list|)
decl_stmt|;
name|checkLogExists
operator|.
name|addColumn
argument_list|(
name|CF
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|replicationTable
operator|.
name|exists
argument_list|(
name|checkLogExists
argument_list|)
condition|)
block|{
name|String
name|errMsg
init|=
literal|"Could not set position of non-existent log from queueId="
operator|+
name|queueId
operator|+
literal|", filename="
operator|+
name|filename
decl_stmt|;
name|abortable
operator|.
name|abort
argument_list|(
name|errMsg
argument_list|,
operator|new
name|ReplicationException
argument_list|(
name|errMsg
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Update the log offset if it exists
name|Put
name|walAndOffset
init|=
operator|new
name|Put
argument_list|(
name|rowKey
argument_list|)
decl_stmt|;
name|walAndOffset
operator|.
name|addColumn
argument_list|(
name|CF
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|filename
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|position
argument_list|)
argument_list|)
expr_stmt|;
name|safeQueueUpdate
argument_list|(
name|walAndOffset
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|abortable
operator|.
name|abort
argument_list|(
literal|"Failed to write replication wal position (filename="
operator|+
name|filename
operator|+
literal|", position="
operator|+
name|position
operator|+
literal|")"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|long
name|getLogPosition
parameter_list|(
name|String
name|queueId
parameter_list|,
name|String
name|filename
parameter_list|)
throws|throws
name|ReplicationException
block|{
try|try
block|{
name|byte
index|[]
name|rowKey
init|=
name|this
operator|.
name|queueIdToRowKey
argument_list|(
name|queueId
argument_list|)
decl_stmt|;
if|if
condition|(
name|rowKey
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ReplicationException
argument_list|(
literal|"Could not get position in log for non-existent queue "
operator|+
literal|"queueId="
operator|+
name|queueId
operator|+
literal|", filename="
operator|+
name|filename
argument_list|)
throw|;
block|}
name|Get
name|getOffset
init|=
operator|new
name|Get
argument_list|(
name|rowKey
argument_list|)
decl_stmt|;
name|getOffset
operator|.
name|addColumn
argument_list|(
name|CF
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|Result
name|result
init|=
name|replicationTable
operator|.
name|get
argument_list|(
name|getOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ReplicationException
argument_list|(
literal|"Could not read empty result while getting log position "
operator|+
literal|"queueId="
operator|+
name|queueId
operator|+
literal|", filename="
operator|+
name|filename
argument_list|)
throw|;
block|}
return|return
name|Bytes
operator|.
name|toLong
argument_list|(
name|result
operator|.
name|getValue
argument_list|(
name|CF
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|filename
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ReplicationException
argument_list|(
literal|"Could not get position in log for queueId="
operator|+
name|queueId
operator|+
literal|", filename="
operator|+
name|filename
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeAllQueues
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|myQueueIds
init|=
name|getAllQueues
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|queueId
range|:
name|myQueueIds
control|)
block|{
name|removeQueue
argument_list|(
name|queueId
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getLogsInQueue
parameter_list|(
name|String
name|queueId
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|logs
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|byte
index|[]
name|rowKey
init|=
name|this
operator|.
name|queueIdToRowKey
argument_list|(
name|queueId
argument_list|)
decl_stmt|;
if|if
condition|(
name|rowKey
operator|==
literal|null
condition|)
block|{
name|String
name|errMsg
init|=
literal|"Could not get logs from non-existent queueId="
operator|+
name|queueId
decl_stmt|;
name|abortable
operator|.
name|abort
argument_list|(
name|errMsg
argument_list|,
operator|new
name|ReplicationException
argument_list|(
name|errMsg
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|Get
name|getQueue
init|=
operator|new
name|Get
argument_list|(
name|rowKey
argument_list|)
decl_stmt|;
name|Result
name|queue
init|=
name|replicationTable
operator|.
name|get
argument_list|(
name|getQueue
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|familyMap
init|=
name|queue
operator|.
name|getFamilyMap
argument_list|(
name|CF
argument_list|)
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|cQualifier
range|:
name|familyMap
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|Arrays
operator|.
name|equals
argument_list|(
name|cQualifier
argument_list|,
name|COL_OWNER
argument_list|)
operator|||
name|Arrays
operator|.
name|equals
argument_list|(
name|cQualifier
argument_list|,
name|COL_QUEUE_ID
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|logs
operator|.
name|add
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|cQualifier
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|abortable
operator|.
name|abort
argument_list|(
literal|"Could not get logs from queue queueId="
operator|+
name|queueId
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|logs
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getAllQueues
parameter_list|()
block|{
try|try
block|{
return|return
name|this
operator|.
name|getQueuesBelongingToServer
argument_list|(
name|serverName
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|abortable
operator|.
name|abort
argument_list|(
literal|"Could not get all replication queues"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|SortedMap
argument_list|<
name|String
argument_list|,
name|SortedSet
argument_list|<
name|String
argument_list|>
argument_list|>
name|claimQueues
parameter_list|(
name|String
name|regionserver
parameter_list|)
block|{
comment|// TODO
throw|throw
operator|new
name|NotImplementedException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getListOfReplicators
parameter_list|()
block|{
comment|// TODO
throw|throw
operator|new
name|NotImplementedException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isThisOurRegionServer
parameter_list|(
name|String
name|regionserver
parameter_list|)
block|{
return|return
name|this
operator|.
name|serverName
operator|.
name|equals
argument_list|(
name|regionserver
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addPeerToHFileRefs
parameter_list|(
name|String
name|peerId
parameter_list|)
throws|throws
name|ReplicationException
block|{
comment|// TODO
throw|throw
operator|new
name|NotImplementedException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addHFileRefs
parameter_list|(
name|String
name|peerId
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|files
parameter_list|)
throws|throws
name|ReplicationException
block|{
comment|// TODO
throw|throw
operator|new
name|NotImplementedException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeHFileRefs
parameter_list|(
name|String
name|peerId
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|files
parameter_list|)
block|{
comment|// TODO
throw|throw
operator|new
name|NotImplementedException
argument_list|()
throw|;
block|}
comment|/**    * Gets the Replication Table. Builds and blocks until the table is available if the Replication    * Table does not exist.    *    * @return the Replication Table    * @throws IOException if the Replication Table takes too long to build    */
specifier|private
name|Table
name|createAndGetReplicationTable
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|replicationTableExists
argument_list|()
condition|)
block|{
name|createReplicationTable
argument_list|()
expr_stmt|;
block|}
name|int
name|maxRetries
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"replication.queues.createtable.retries.number"
argument_list|,
literal|100
argument_list|)
decl_stmt|;
name|RetryCounterFactory
name|counterFactory
init|=
operator|new
name|RetryCounterFactory
argument_list|(
name|maxRetries
argument_list|,
literal|100
argument_list|)
decl_stmt|;
name|RetryCounter
name|retryCounter
init|=
name|counterFactory
operator|.
name|create
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|replicationTableExists
argument_list|()
condition|)
block|{
try|try
block|{
name|retryCounter
operator|.
name|sleepUntilNextRetry
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|retryCounter
operator|.
name|shouldRetry
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to acquire the Replication Table"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
return|return
name|connection
operator|.
name|getTable
argument_list|(
name|REPLICATION_TABLE_NAME
argument_list|)
return|;
block|}
comment|/**    * Checks whether the Replication Table exists yet    *    * @return whether the Replication Table exists    * @throws IOException    */
specifier|private
name|boolean
name|replicationTableExists
parameter_list|()
block|{
try|try
block|{
return|return
name|admin
operator|.
name|tableExists
argument_list|(
name|REPLICATION_TABLE_NAME
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Create the replication table with the provided HColumnDescriptor REPLICATION_COL_DESCRIPTOR    * in ReplicationQueuesHBaseImpl    * @throws IOException    */
specifier|private
name|void
name|createReplicationTable
parameter_list|()
throws|throws
name|IOException
block|{
name|HTableDescriptor
name|replicationTableDescriptor
init|=
operator|new
name|HTableDescriptor
argument_list|(
name|REPLICATION_TABLE_NAME
argument_list|)
decl_stmt|;
name|replicationTableDescriptor
operator|.
name|addFamily
argument_list|(
name|REPLICATION_COL_DESCRIPTOR
argument_list|)
expr_stmt|;
name|admin
operator|.
name|createTable
argument_list|(
name|replicationTableDescriptor
argument_list|)
expr_stmt|;
block|}
comment|/**    * Builds the unique identifier for a queue in the Replication table by appending the queueId to    * the servername    *    * @param queueId a String that identifies the queue    * @return unique identifier for a queue in the Replication table    */
specifier|private
name|String
name|buildServerQueueName
parameter_list|(
name|String
name|queueId
parameter_list|)
block|{
return|return
name|serverName
operator|+
literal|"-"
operator|+
name|queueId
return|;
block|}
comment|/**    * See safeQueueUpdate(RowMutations mutate)    * @param put Row mutation to perform on the queue    */
specifier|private
name|void
name|safeQueueUpdate
parameter_list|(
name|Put
name|put
parameter_list|)
block|{
name|RowMutations
name|mutations
init|=
operator|new
name|RowMutations
argument_list|(
name|put
operator|.
name|getRow
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|mutations
operator|.
name|add
argument_list|(
name|put
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|abortable
operator|.
name|abort
argument_list|(
literal|"Failed to update Replication Table because of IOException"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|safeQueueUpdate
argument_list|(
name|mutations
argument_list|)
expr_stmt|;
block|}
comment|/**    * See safeQueueUpdate(RowMutations mutate)    * @param delete Row mutation to perform on the queue    */
specifier|private
name|void
name|safeQueueUpdate
parameter_list|(
name|Delete
name|delete
parameter_list|)
block|{
name|RowMutations
name|mutations
init|=
operator|new
name|RowMutations
argument_list|(
name|delete
operator|.
name|getRow
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|mutations
operator|.
name|add
argument_list|(
name|delete
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|abortable
operator|.
name|abort
argument_list|(
literal|"Failed to update Replication Table because of IOException"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|safeQueueUpdate
argument_list|(
name|mutations
argument_list|)
expr_stmt|;
block|}
comment|/**    * Attempt to mutate a given queue in the Replication Table with a checkAndPut on the OWNER column    * of the queue. Abort the server if this checkAndPut fails: which means we have somehow lost    * ownership of the column or an IO Exception has occurred during the transaction.    *    * @param mutate Mutation to perform on a given queue    */
specifier|private
name|void
name|safeQueueUpdate
parameter_list|(
name|RowMutations
name|mutate
parameter_list|)
block|{
try|try
block|{
name|boolean
name|updateSuccess
init|=
name|replicationTable
operator|.
name|checkAndMutate
argument_list|(
name|mutate
operator|.
name|getRow
argument_list|()
argument_list|,
name|CF
argument_list|,
name|COL_OWNER
argument_list|,
name|CompareFilter
operator|.
name|CompareOp
operator|.
name|EQUAL
argument_list|,
name|serverNameBytes
argument_list|,
name|mutate
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|updateSuccess
condition|)
block|{
name|String
name|errMsg
init|=
literal|"Failed to update Replication Table because we lost queue ownership"
decl_stmt|;
name|abortable
operator|.
name|abort
argument_list|(
name|errMsg
argument_list|,
operator|new
name|ReplicationException
argument_list|(
name|errMsg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|abortable
operator|.
name|abort
argument_list|(
literal|"Failed to update Replication Table because of IOException"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get the QueueIds belonging to the named server from the ReplicationTable    *    * @param server name of the server    * @return a list of the QueueIds belonging to the server    * @throws IOException    */
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getQueuesBelongingToServer
parameter_list|(
name|String
name|server
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|queues
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Scan
name|scan
init|=
operator|new
name|Scan
argument_list|()
decl_stmt|;
name|SingleColumnValueFilter
name|filterMyQueues
init|=
operator|new
name|SingleColumnValueFilter
argument_list|(
name|CF
argument_list|,
name|COL_OWNER
argument_list|,
name|CompareFilter
operator|.
name|CompareOp
operator|.
name|EQUAL
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|server
argument_list|)
argument_list|)
decl_stmt|;
name|scan
operator|.
name|setFilter
argument_list|(
name|filterMyQueues
argument_list|)
expr_stmt|;
name|scan
operator|.
name|addColumn
argument_list|(
name|CF
argument_list|,
name|COL_QUEUE_ID
argument_list|)
expr_stmt|;
name|scan
operator|.
name|addColumn
argument_list|(
name|CF
argument_list|,
name|COL_OWNER
argument_list|)
expr_stmt|;
name|ResultScanner
name|results
init|=
name|replicationTable
operator|.
name|getScanner
argument_list|(
name|scan
argument_list|)
decl_stmt|;
for|for
control|(
name|Result
name|result
range|:
name|results
control|)
block|{
name|queues
operator|.
name|add
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|result
operator|.
name|getValue
argument_list|(
name|CF
argument_list|,
name|COL_QUEUE_ID
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|results
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|queues
return|;
block|}
comment|/**    * Finds the row key of the HBase row corresponding to the provided queue. This has to be done,    * because the row key is [original server name + "-" + queueId0]. And the original server will    * make calls to getLog(), getQueue(), etc. with the argument queueId = queueId0.    * On the original server we can build the row key by concatenating servername + queueId0.    * Yet if the queue is claimed by another server, future calls to getLog(), getQueue(), etc.    * will be made with the argument queueId = queueId0 + "-" + pastOwner0 + "-" + pastOwner1 ...    * so we need a way to look up rows by their modified queueId's.    *    * TODO: Consider updating the queueId passed to getLog, getQueue()... inside of ReplicationSource    * TODO: and ReplicationSourceManager or the parsing of the passed in queueId's so that we don't    * TODO have to scan the table for row keys for each update. See HBASE-15956.    *    * TODO: We can also cache queueId's if ReplicationQueuesHBaseImpl becomes a bottleneck. We    * TODO: currently perform scan's over all the rows looking for one with a matching QueueId.    *    * @param queueId string representation of the queue id    * @return the rowkey of the corresponding queue. This returns null if the corresponding queue    * cannot be found.    * @throws IOException    */
specifier|private
name|byte
index|[]
name|queueIdToRowKey
parameter_list|(
name|String
name|queueId
parameter_list|)
throws|throws
name|IOException
block|{
name|Scan
name|scan
init|=
operator|new
name|Scan
argument_list|()
decl_stmt|;
name|scan
operator|.
name|addColumn
argument_list|(
name|CF
argument_list|,
name|COL_QUEUE_ID
argument_list|)
expr_stmt|;
name|scan
operator|.
name|addColumn
argument_list|(
name|CF
argument_list|,
name|COL_OWNER
argument_list|)
expr_stmt|;
name|scan
operator|.
name|setMaxResultSize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// Search for the queue that matches this queueId
name|SingleColumnValueFilter
name|filterByQueueId
init|=
operator|new
name|SingleColumnValueFilter
argument_list|(
name|CF
argument_list|,
name|COL_QUEUE_ID
argument_list|,
name|CompareFilter
operator|.
name|CompareOp
operator|.
name|EQUAL
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|queueId
argument_list|)
argument_list|)
decl_stmt|;
comment|// Make sure that we are the owners of the queue. QueueId's may overlap.
name|SingleColumnValueFilter
name|filterByOwner
init|=
operator|new
name|SingleColumnValueFilter
argument_list|(
name|CF
argument_list|,
name|COL_OWNER
argument_list|,
name|CompareFilter
operator|.
name|CompareOp
operator|.
name|EQUAL
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|serverName
argument_list|)
argument_list|)
decl_stmt|;
comment|// We only want the row key
name|FirstKeyOnlyFilter
name|filterOutColumns
init|=
operator|new
name|FirstKeyOnlyFilter
argument_list|()
decl_stmt|;
name|FilterList
name|filterList
init|=
operator|new
name|FilterList
argument_list|(
name|filterByQueueId
argument_list|,
name|filterByOwner
argument_list|,
name|filterOutColumns
argument_list|)
decl_stmt|;
name|scan
operator|.
name|setFilter
argument_list|(
name|filterList
argument_list|)
expr_stmt|;
name|ResultScanner
name|results
init|=
name|replicationTable
operator|.
name|getScanner
argument_list|(
name|scan
argument_list|)
decl_stmt|;
name|Result
name|result
init|=
name|results
operator|.
name|next
argument_list|()
decl_stmt|;
name|results
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|result
operator|.
name|getRow
argument_list|()
return|;
block|}
block|}
end_class

end_unit

