begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|SynchronousQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Cell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValueUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|coprocessor
operator|.
name|Batch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|BinaryComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|CoprocessorRpcChannel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|PayloadCarryingRpcController
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|RegionCoprocessorRpcChannel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|RequestConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClientProtos
operator|.
name|MultiRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClientProtos
operator|.
name|MutateRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClientProtos
operator|.
name|MutateResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClientProtos
operator|.
name|RegionAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|CompareType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Service
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|ServiceException
import|;
end_import

begin_comment
comment|/**  *<p>Used to communicate with a single HBase table.  An implementation of  * {@link HTableInterface}.  Instances of this class can be constructed directly but it is  * encouraged that users get instances via {@link HConnection} and {@link HConnectionManager}.  * See {@link HConnectionManager} class comment for an example.  *  *<p>This class is not thread safe for reads nor write.  *  *<p>In case of writes (Put, Delete), the underlying write buffer can  * be corrupted if multiple threads contend over a single HTable instance.  *  *<p>In case of reads, some fields used by a Scan are shared among all threads.  * The HTable implementation can either not contract to be safe in case of a Get  *  *<p>Instances of HTable passed the same {@link Configuration} instance will  * share connections to servers out on the cluster and to the zookeeper ensemble  * as well as caches of region locations.  This is usually a *good* thing and it  * is recommended to reuse the same configuration object for all your tables.  * This happens because they will all share the same underlying  * {@link HConnection} instance. See {@link HConnectionManager} for more on  * how this mechanism works.  *  *<p>{@link HConnection} will read most of the  * configuration it needs from the passed {@link Configuration} on initial  * construction.  Thereafter, for settings such as  *<code>hbase.client.pause</code>,<code>hbase.client.retries.number</code>,  * and<code>hbase.client.rpc.maxattempts</code> updating their values in the  * passed {@link Configuration} subsequent to {@link HConnection} construction  * will go unnoticed.  To run with changed values, make a new  * {@link HTable} passing a new {@link Configuration} instance that has the  * new configuration.  *  *<p>Note that this class implements the {@link Closeable} interface. When a  * HTable instance is no longer required, it *should* be closed in order to ensure  * that the underlying resources are promptly released. Please note that the close  * method can throw java.io.IOException that must be handled.  *  * @see HBaseAdmin for create, drop, list, enable and disable of tables.  * @see HConnection  * @see HConnectionManager  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Stable
specifier|public
class|class
name|HTable
implements|implements
name|HTableInterface
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HTable
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|protected
name|HConnection
name|connection
decl_stmt|;
specifier|private
specifier|final
name|TableName
name|tableName
decl_stmt|;
specifier|private
specifier|volatile
name|Configuration
name|configuration
decl_stmt|;
specifier|protected
name|List
argument_list|<
name|Row
argument_list|>
name|writeAsyncBuffer
init|=
operator|new
name|LinkedList
argument_list|<
name|Row
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|long
name|writeBufferSize
decl_stmt|;
specifier|private
name|boolean
name|clearBufferOnFail
decl_stmt|;
specifier|private
name|boolean
name|autoFlush
decl_stmt|;
specifier|protected
name|long
name|currentWriteBufferSize
decl_stmt|;
specifier|protected
name|int
name|scannerCaching
decl_stmt|;
specifier|private
name|int
name|maxKeyValueSize
decl_stmt|;
specifier|private
name|ExecutorService
name|pool
decl_stmt|;
comment|// For Multi
specifier|private
name|boolean
name|closed
decl_stmt|;
specifier|private
name|int
name|operationTimeout
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|cleanupPoolOnClose
decl_stmt|;
comment|// shutdown the pool in close()
specifier|private
specifier|final
name|boolean
name|cleanupConnectionOnClose
decl_stmt|;
comment|// close the connection in close()
comment|/** The Async process for puts with autoflush set to false or multiputs */
specifier|protected
name|AsyncProcess
argument_list|<
name|Object
argument_list|>
name|ap
decl_stmt|;
specifier|private
name|RpcRetryingCallerFactory
name|rpcCallerFactory
decl_stmt|;
comment|/**    * Creates an object to access a HBase table.    * Shares zookeeper connection and other resources with other HTable instances    * created with the same<code>conf</code> instance.  Uses already-populated    * region cache if one is available, populated by any other HTable instances    * sharing this<code>conf</code> instance.  Recommended.    * @param conf Configuration object to use.    * @param tableName Name of the table.    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|HTable
parameter_list|(
name|Configuration
name|conf
parameter_list|,
specifier|final
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|conf
argument_list|,
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates an object to access a HBase table.    * Shares zookeeper connection and other resources with other HTable instances    * created with the same<code>conf</code> instance.  Uses already-populated    * region cache if one is available, populated by any other HTable instances    * sharing this<code>conf</code> instance.  Recommended.    * @param conf Configuration object to use.    * @param tableName Name of the table.    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|HTable
parameter_list|(
name|Configuration
name|conf
parameter_list|,
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|conf
argument_list|,
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates an object to access a HBase table.    * Shares zookeeper connection and other resources with other HTable instances    * created with the same<code>conf</code> instance.  Uses already-populated    * region cache if one is available, populated by any other HTable instances    * sharing this<code>conf</code> instance.  Recommended.    * @param conf Configuration object to use.    * @param tableName table name pojo    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|HTable
parameter_list|(
name|Configuration
name|conf
parameter_list|,
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|tableName
operator|=
name|tableName
expr_stmt|;
name|this
operator|.
name|cleanupPoolOnClose
operator|=
name|this
operator|.
name|cleanupConnectionOnClose
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|conf
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|connection
operator|=
literal|null
expr_stmt|;
return|return;
block|}
name|this
operator|.
name|connection
operator|=
name|HConnectionManager
operator|.
name|getConnection
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|configuration
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|pool
operator|=
name|getDefaultExecutor
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|finishSetup
argument_list|()
expr_stmt|;
block|}
comment|/**    * Creates an object to access a HBase table. Shares zookeeper connection and other resources with    * other HTable instances created with the same<code>connection</code> instance. Use this    * constructor when the HConnection instance is externally managed.    * @param tableName Name of the table.    * @param connection HConnection to be used.    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|HTable
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|HConnection
name|connection
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|tableName
operator|=
name|tableName
expr_stmt|;
name|this
operator|.
name|cleanupPoolOnClose
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|cleanupConnectionOnClose
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|connection
operator|=
name|connection
expr_stmt|;
name|this
operator|.
name|configuration
operator|=
name|connection
operator|.
name|getConfiguration
argument_list|()
expr_stmt|;
name|this
operator|.
name|pool
operator|=
name|getDefaultExecutor
argument_list|(
name|this
operator|.
name|configuration
argument_list|)
expr_stmt|;
name|this
operator|.
name|finishSetup
argument_list|()
expr_stmt|;
block|}
specifier|public
specifier|static
name|ThreadPoolExecutor
name|getDefaultExecutor
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|int
name|maxThreads
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.htable.threads.max"
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxThreads
operator|==
literal|0
condition|)
block|{
name|maxThreads
operator|=
literal|1
expr_stmt|;
comment|// is there a better default?
block|}
name|long
name|keepAliveTime
init|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.htable.threads.keepalivetime"
argument_list|,
literal|60
argument_list|)
decl_stmt|;
comment|// Using the "direct handoff" approach, new threads will only be created
comment|// if it is necessary and will grow unbounded. This could be bad but in HCM
comment|// we only create as many Runnables as there are region servers. It means
comment|// it also scales when new region servers are added.
name|ThreadPoolExecutor
name|pool
init|=
operator|new
name|ThreadPoolExecutor
argument_list|(
literal|1
argument_list|,
name|maxThreads
argument_list|,
name|keepAliveTime
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
operator|new
name|SynchronousQueue
argument_list|<
name|Runnable
argument_list|>
argument_list|()
argument_list|,
name|Threads
operator|.
name|newDaemonThreadFactory
argument_list|(
literal|"htable"
argument_list|)
argument_list|)
decl_stmt|;
operator|(
operator|(
name|ThreadPoolExecutor
operator|)
name|pool
operator|)
operator|.
name|allowCoreThreadTimeOut
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|pool
return|;
block|}
comment|/**    * Creates an object to access a HBase table.    * Shares zookeeper connection and other resources with other HTable instances    * created with the same<code>conf</code> instance.  Uses already-populated    * region cache if one is available, populated by any other HTable instances    * sharing this<code>conf</code> instance.    * Use this constructor when the ExecutorService is externally managed.    * @param conf Configuration object to use.    * @param tableName Name of the table.    * @param pool ExecutorService to be used.    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|HTable
parameter_list|(
name|Configuration
name|conf
parameter_list|,
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|ExecutorService
name|pool
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|conf
argument_list|,
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates an object to access a HBase table.    * Shares zookeeper connection and other resources with other HTable instances    * created with the same<code>conf</code> instance.  Uses already-populated    * region cache if one is available, populated by any other HTable instances    * sharing this<code>conf</code> instance.    * Use this constructor when the ExecutorService is externally managed.    * @param conf Configuration object to use.    * @param tableName Name of the table.    * @param pool ExecutorService to be used.    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|HTable
parameter_list|(
name|Configuration
name|conf
parameter_list|,
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|ExecutorService
name|pool
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|connection
operator|=
name|HConnectionManager
operator|.
name|getConnection
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|configuration
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|this
operator|.
name|tableName
operator|=
name|tableName
expr_stmt|;
name|this
operator|.
name|cleanupPoolOnClose
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|cleanupConnectionOnClose
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|finishSetup
argument_list|()
expr_stmt|;
block|}
comment|/**    * Creates an object to access a HBase table.    * Shares zookeeper connection and other resources with other HTable instances    * created with the same<code>connection</code> instance.    * Use this constructor when the ExecutorService and HConnection instance are    * externally managed.    * @param tableName Name of the table.    * @param connection HConnection to be used.    * @param pool ExecutorService to be used.    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|HTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|HConnection
name|connection
parameter_list|,
specifier|final
name|ExecutorService
name|pool
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|connection
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates an object to access a HBase table.    * Shares zookeeper connection and other resources with other HTable instances    * created with the same<code>connection</code> instance.    * Use this constructor when the ExecutorService and HConnection instance are    * externally managed.    * @param tableName Name of the table.    * @param connection HConnection to be used.    * @param pool ExecutorService to be used.    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|HTable
parameter_list|(
name|TableName
name|tableName
parameter_list|,
specifier|final
name|HConnection
name|connection
parameter_list|,
specifier|final
name|ExecutorService
name|pool
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|connection
operator|==
literal|null
operator|||
name|connection
operator|.
name|isClosed
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Connection is null or closed."
argument_list|)
throw|;
block|}
name|this
operator|.
name|tableName
operator|=
name|tableName
expr_stmt|;
name|this
operator|.
name|cleanupPoolOnClose
operator|=
name|this
operator|.
name|cleanupConnectionOnClose
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|connection
operator|=
name|connection
expr_stmt|;
name|this
operator|.
name|configuration
operator|=
name|connection
operator|.
name|getConfiguration
argument_list|()
expr_stmt|;
name|this
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|this
operator|.
name|finishSetup
argument_list|()
expr_stmt|;
block|}
comment|/**    * For internal testing.    */
specifier|protected
name|HTable
parameter_list|()
block|{
name|tableName
operator|=
literal|null
expr_stmt|;
name|cleanupPoolOnClose
operator|=
literal|false
expr_stmt|;
name|cleanupConnectionOnClose
operator|=
literal|false
expr_stmt|;
block|}
comment|/**    * setup this HTable's parameter based on the passed configuration    */
specifier|private
name|void
name|finishSetup
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|connection
operator|.
name|locateRegion
argument_list|(
name|tableName
argument_list|,
name|HConstants
operator|.
name|EMPTY_START_ROW
argument_list|)
expr_stmt|;
name|this
operator|.
name|operationTimeout
operator|=
name|tableName
operator|.
name|isSystemTable
argument_list|()
condition|?
name|this
operator|.
name|configuration
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_META_OPERATION_TIMEOUT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_OPERATION_TIMEOUT
argument_list|)
else|:
name|this
operator|.
name|configuration
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_OPERATION_TIMEOUT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_OPERATION_TIMEOUT
argument_list|)
expr_stmt|;
name|this
operator|.
name|writeBufferSize
operator|=
name|this
operator|.
name|configuration
operator|.
name|getLong
argument_list|(
literal|"hbase.client.write.buffer"
argument_list|,
literal|2097152
argument_list|)
expr_stmt|;
name|this
operator|.
name|clearBufferOnFail
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|autoFlush
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|currentWriteBufferSize
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|scannerCaching
operator|=
name|this
operator|.
name|configuration
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_SCANNER_CACHING
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_SCANNER_CACHING
argument_list|)
expr_stmt|;
name|this
operator|.
name|rpcCallerFactory
operator|=
name|RpcRetryingCallerFactory
operator|.
name|instantiate
argument_list|(
name|configuration
argument_list|)
expr_stmt|;
name|ap
operator|=
operator|new
name|AsyncProcess
argument_list|<
name|Object
argument_list|>
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|,
name|pool
argument_list|,
literal|null
argument_list|,
name|configuration
argument_list|,
name|rpcCallerFactory
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxKeyValueSize
operator|=
name|this
operator|.
name|configuration
operator|.
name|getInt
argument_list|(
literal|"hbase.client.keyvalue.maxsize"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|this
operator|.
name|closed
operator|=
literal|false
expr_stmt|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|Configuration
name|getConfiguration
parameter_list|()
block|{
return|return
name|configuration
return|;
block|}
comment|/**    * Tells whether or not a table is enabled or not. This method creates a    * new HBase configuration, so it might make your unit tests fail due to    * incorrect ZK client port.    * @param tableName Name of table to check.    * @return {@code true} if table is online.    * @throws IOException if a remote or network exception occurs 	* @deprecated use {@link HBaseAdmin#isTableEnabled(byte[])}    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|boolean
name|isTableEnabled
parameter_list|(
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isTableEnabled
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Tells whether or not a table is enabled or not. This method creates a    * new HBase configuration, so it might make your unit tests fail due to    * incorrect ZK client port.    * @param tableName Name of table to check.    * @return {@code true} if table is online.    * @throws IOException if a remote or network exception occurs 	* @deprecated use {@link HBaseAdmin#isTableEnabled(byte[])}    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|boolean
name|isTableEnabled
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isTableEnabled
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Tells whether or not a table is enabled or not. This method creates a    * new HBase configuration, so it might make your unit tests fail due to    * incorrect ZK client port.    * @param tableName Name of table to check.    * @return {@code true} if table is online.    * @throws IOException if a remote or network exception occurs    * @deprecated use {@link HBaseAdmin#isTableEnabled(byte[])}    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|boolean
name|isTableEnabled
parameter_list|(
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isTableEnabled
argument_list|(
name|HBaseConfiguration
operator|.
name|create
argument_list|()
argument_list|,
name|tableName
argument_list|)
return|;
block|}
comment|/**    * Tells whether or not a table is enabled or not.    * @param conf The Configuration object to use.    * @param tableName Name of table to check.    * @return {@code true} if table is online.    * @throws IOException if a remote or network exception occurs 	 * @deprecated use {@link HBaseAdmin#isTableEnabled(byte[])}    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|boolean
name|isTableEnabled
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isTableEnabled
argument_list|(
name|conf
argument_list|,
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Tells whether or not a table is enabled or not.    * @param conf The Configuration object to use.    * @param tableName Name of table to check.    * @return {@code true} if table is online.    * @throws IOException if a remote or network exception occurs 	 * @deprecated use {@link HBaseAdmin#isTableEnabled(byte[])}    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|boolean
name|isTableEnabled
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isTableEnabled
argument_list|(
name|conf
argument_list|,
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Tells whether or not a table is enabled or not.    * @param conf The Configuration object to use.    * @param tableName Name of table to check.    * @return {@code true} if table is online.    * @throws IOException if a remote or network exception occurs    * @deprecated use {@link HBaseAdmin#isTableEnabled(org.apache.hadoop.hbase.TableName tableName)}    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|boolean
name|isTableEnabled
parameter_list|(
name|Configuration
name|conf
parameter_list|,
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|HConnectionManager
operator|.
name|execute
argument_list|(
operator|new
name|HConnectable
argument_list|<
name|Boolean
argument_list|>
argument_list|(
name|conf
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|connect
parameter_list|(
name|HConnection
name|connection
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|connection
operator|.
name|isTableEnabled
argument_list|(
name|tableName
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Find region location hosting passed row using cached info    * @param row Row to find.    * @return The location of the given row.    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|HRegionLocation
name|getRegionLocation
parameter_list|(
specifier|final
name|String
name|row
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|connection
operator|.
name|getRegionLocation
argument_list|(
name|tableName
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|row
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Finds the region on which the given row is being served. Does not reload the cache.    * @param row Row to find.    * @return Location of the row.    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|HRegionLocation
name|getRegionLocation
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|connection
operator|.
name|getRegionLocation
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Finds the region on which the given row is being served.    * @param row Row to find.    * @param reload true to reload information or false to use cached information    * @return Location of the row.    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|HRegionLocation
name|getRegionLocation
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
name|boolean
name|reload
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|connection
operator|.
name|getRegionLocation
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|,
name|reload
argument_list|)
return|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|getTableName
parameter_list|()
block|{
return|return
name|this
operator|.
name|tableName
operator|.
name|getName
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|TableName
name|getName
parameter_list|()
block|{
return|return
name|tableName
return|;
block|}
comment|/**    *<em>INTERNAL</em> Used by unit tests and tools to do low-level    * manipulations.    * @return An HConnection instance.    * @deprecated This method will be changed from public to package protected.    */
comment|// TODO(tsuna): Remove this.  Unit tests shouldn't require public helpers.
annotation|@
name|Deprecated
specifier|public
name|HConnection
name|getConnection
parameter_list|()
block|{
return|return
name|this
operator|.
name|connection
return|;
block|}
comment|/**    * Gets the number of rows that a scanner will fetch at once.    *<p>    * The default value comes from {@code hbase.client.scanner.caching}.    * @deprecated Use {@link Scan#setCaching(int)} and {@link Scan#getCaching()}    */
annotation|@
name|Deprecated
specifier|public
name|int
name|getScannerCaching
parameter_list|()
block|{
return|return
name|scannerCaching
return|;
block|}
comment|/**    * Kept in 0.96 for backward compatibility    * @deprecated  since 0.96. This is an internal buffer that should not be read nor write.    */
annotation|@
name|Deprecated
specifier|public
name|List
argument_list|<
name|Row
argument_list|>
name|getWriteBuffer
parameter_list|()
block|{
return|return
name|writeAsyncBuffer
return|;
block|}
comment|/**    * Sets the number of rows that a scanner will fetch at once.    *<p>    * This will override the value specified by    * {@code hbase.client.scanner.caching}.    * Increasing this value will reduce the amount of work needed each time    * {@code next()} is called on a scanner, at the expense of memory use    * (since more rows will need to be maintained in memory by the scanners).    * @param scannerCaching the number of rows a scanner will fetch at once.    * @deprecated Use {@link Scan#setCaching(int)}    */
annotation|@
name|Deprecated
specifier|public
name|void
name|setScannerCaching
parameter_list|(
name|int
name|scannerCaching
parameter_list|)
block|{
name|this
operator|.
name|scannerCaching
operator|=
name|scannerCaching
expr_stmt|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|HTableDescriptor
name|getTableDescriptor
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|UnmodifyableHTableDescriptor
argument_list|(
name|this
operator|.
name|connection
operator|.
name|getHTableDescriptor
argument_list|(
name|this
operator|.
name|tableName
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Gets the starting row key for every region in the currently open table.    *<p>    * This is mainly useful for the MapReduce integration.    * @return Array of region starting row keys    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|byte
index|[]
index|[]
name|getStartKeys
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getStartEndKeys
argument_list|()
operator|.
name|getFirst
argument_list|()
return|;
block|}
comment|/**    * Gets the ending row key for every region in the currently open table.    *<p>    * This is mainly useful for the MapReduce integration.    * @return Array of region ending row keys    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|byte
index|[]
index|[]
name|getEndKeys
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getStartEndKeys
argument_list|()
operator|.
name|getSecond
argument_list|()
return|;
block|}
comment|/**    * Gets the starting and ending row keys for every region in the currently    * open table.    *<p>    * This is mainly useful for the MapReduce integration.    * @return Pair of arrays of region starting and ending row keys    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|Pair
argument_list|<
name|byte
index|[]
index|[]
argument_list|,
name|byte
index|[]
index|[]
argument_list|>
name|getStartEndKeys
parameter_list|()
throws|throws
name|IOException
block|{
name|NavigableMap
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|regions
init|=
name|getRegionLocations
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|startKeyList
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|(
name|regions
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|endKeyList
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|(
name|regions
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|HRegionInfo
name|region
range|:
name|regions
operator|.
name|keySet
argument_list|()
control|)
block|{
name|startKeyList
operator|.
name|add
argument_list|(
name|region
operator|.
name|getStartKey
argument_list|()
argument_list|)
expr_stmt|;
name|endKeyList
operator|.
name|add
argument_list|(
name|region
operator|.
name|getEndKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|Pair
argument_list|<
name|byte
index|[]
index|[]
argument_list|,
name|byte
index|[]
index|[]
argument_list|>
argument_list|(
name|startKeyList
operator|.
name|toArray
argument_list|(
operator|new
name|byte
index|[
name|startKeyList
operator|.
name|size
argument_list|()
index|]
index|[]
argument_list|)
argument_list|,
name|endKeyList
operator|.
name|toArray
argument_list|(
operator|new
name|byte
index|[
name|endKeyList
operator|.
name|size
argument_list|()
index|]
index|[]
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Gets all the regions and their address for this table.    *<p>    * This is mainly useful for the MapReduce integration.    * @return A map of HRegionInfo with it's server address    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|NavigableMap
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|getRegionLocations
parameter_list|()
throws|throws
name|IOException
block|{
comment|// TODO: Odd that this returns a Map of HRI to SN whereas getRegionLocation, singular, returns an HRegionLocation.
return|return
name|MetaScanner
operator|.
name|allTableRegions
argument_list|(
name|getConfiguration
argument_list|()
argument_list|,
name|this
operator|.
name|connection
argument_list|,
name|getName
argument_list|()
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Get the corresponding regions for an arbitrary range of keys.    *<p>    * @param startKey Starting row in range, inclusive    * @param endKey Ending row in range, exclusive    * @return A list of HRegionLocations corresponding to the regions that    * contain the specified range    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|List
argument_list|<
name|HRegionLocation
argument_list|>
name|getRegionsInRange
parameter_list|(
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|byte
index|[]
name|endKey
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getRegionsInRange
argument_list|(
name|startKey
argument_list|,
name|endKey
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Get the corresponding regions for an arbitrary range of keys.    *<p>    * @param startKey Starting row in range, inclusive    * @param endKey Ending row in range, exclusive    * @param reload true to reload information or false to use cached information    * @return A list of HRegionLocations corresponding to the regions that    * contain the specified range    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|List
argument_list|<
name|HRegionLocation
argument_list|>
name|getRegionsInRange
parameter_list|(
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|byte
index|[]
name|endKey
parameter_list|,
specifier|final
name|boolean
name|reload
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getKeysAndRegionsInRange
argument_list|(
name|startKey
argument_list|,
name|endKey
argument_list|,
literal|false
argument_list|,
name|reload
argument_list|)
operator|.
name|getSecond
argument_list|()
return|;
block|}
comment|/**    * Get the corresponding start keys and regions for an arbitrary range of    * keys.    *<p>    * @param startKey Starting row in range, inclusive    * @param endKey Ending row in range    * @param includeEndKey true if endRow is inclusive, false if exclusive    * @return A pair of list of start keys and list of HRegionLocations that    *         contain the specified range    * @throws IOException if a remote or network exception occurs    */
specifier|private
name|Pair
argument_list|<
name|List
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|,
name|List
argument_list|<
name|HRegionLocation
argument_list|>
argument_list|>
name|getKeysAndRegionsInRange
parameter_list|(
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|byte
index|[]
name|endKey
parameter_list|,
specifier|final
name|boolean
name|includeEndKey
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getKeysAndRegionsInRange
argument_list|(
name|startKey
argument_list|,
name|endKey
argument_list|,
name|includeEndKey
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Get the corresponding start keys and regions for an arbitrary range of    * keys.    *<p>    * @param startKey Starting row in range, inclusive    * @param endKey Ending row in range    * @param includeEndKey true if endRow is inclusive, false if exclusive    * @param reload true to reload information or false to use cached information    * @return A pair of list of start keys and list of HRegionLocations that    *         contain the specified range    * @throws IOException if a remote or network exception occurs    */
specifier|private
name|Pair
argument_list|<
name|List
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|,
name|List
argument_list|<
name|HRegionLocation
argument_list|>
argument_list|>
name|getKeysAndRegionsInRange
parameter_list|(
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|byte
index|[]
name|endKey
parameter_list|,
specifier|final
name|boolean
name|includeEndKey
parameter_list|,
specifier|final
name|boolean
name|reload
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|boolean
name|endKeyIsEndOfTable
init|=
name|Bytes
operator|.
name|equals
argument_list|(
name|endKey
argument_list|,
name|HConstants
operator|.
name|EMPTY_END_ROW
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|startKey
argument_list|,
name|endKey
argument_list|)
operator|>
literal|0
operator|)
operator|&&
operator|!
name|endKeyIsEndOfTable
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid range: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|startKey
argument_list|)
operator|+
literal|"> "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|endKey
argument_list|)
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|keysInRange
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|HRegionLocation
argument_list|>
name|regionsInRange
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionLocation
argument_list|>
argument_list|()
decl_stmt|;
name|byte
index|[]
name|currentKey
init|=
name|startKey
decl_stmt|;
do|do
block|{
name|HRegionLocation
name|regionLocation
init|=
name|getRegionLocation
argument_list|(
name|currentKey
argument_list|,
name|reload
argument_list|)
decl_stmt|;
name|keysInRange
operator|.
name|add
argument_list|(
name|currentKey
argument_list|)
expr_stmt|;
name|regionsInRange
operator|.
name|add
argument_list|(
name|regionLocation
argument_list|)
expr_stmt|;
name|currentKey
operator|=
name|regionLocation
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEndKey
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|currentKey
argument_list|,
name|HConstants
operator|.
name|EMPTY_END_ROW
argument_list|)
operator|&&
operator|(
name|endKeyIsEndOfTable
operator|||
name|Bytes
operator|.
name|compareTo
argument_list|(
name|currentKey
argument_list|,
name|endKey
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|includeEndKey
operator|&&
name|Bytes
operator|.
name|compareTo
argument_list|(
name|currentKey
argument_list|,
name|endKey
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
do|;
return|return
operator|new
name|Pair
argument_list|<
name|List
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|,
name|List
argument_list|<
name|HRegionLocation
argument_list|>
argument_list|>
argument_list|(
name|keysInRange
argument_list|,
name|regionsInRange
argument_list|)
return|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|Result
name|getRowOrBefore
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|)
throws|throws
name|IOException
block|{
name|RegionServerCallable
argument_list|<
name|Result
argument_list|>
name|callable
init|=
operator|new
name|RegionServerCallable
argument_list|<
name|Result
argument_list|>
argument_list|(
name|this
operator|.
name|connection
argument_list|,
name|tableName
argument_list|,
name|row
argument_list|)
block|{
specifier|public
name|Result
name|call
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|ProtobufUtil
operator|.
name|getRowOrBefore
argument_list|(
name|getStub
argument_list|()
argument_list|,
name|getLocation
argument_list|()
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|row
argument_list|,
name|family
argument_list|)
return|;
block|}
block|}
decl_stmt|;
return|return
name|rpcCallerFactory
operator|.
expr|<
name|Result
operator|>
name|newCaller
argument_list|()
operator|.
name|callWithRetries
argument_list|(
name|callable
argument_list|,
name|this
operator|.
name|operationTimeout
argument_list|)
return|;
block|}
comment|/**     * {@inheritDoc}     */
annotation|@
name|Override
specifier|public
name|ResultScanner
name|getScanner
parameter_list|(
specifier|final
name|Scan
name|scan
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|scan
operator|.
name|getCaching
argument_list|()
operator|<=
literal|0
condition|)
block|{
name|scan
operator|.
name|setCaching
argument_list|(
name|getScannerCaching
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scan
operator|.
name|isSmall
argument_list|()
operator|&&
operator|!
name|scan
operator|.
name|isReversed
argument_list|()
condition|)
block|{
return|return
operator|new
name|ClientSmallScanner
argument_list|(
name|getConfiguration
argument_list|()
argument_list|,
name|scan
argument_list|,
name|getName
argument_list|()
argument_list|,
name|this
operator|.
name|connection
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|scan
operator|.
name|isReversed
argument_list|()
condition|)
block|{
return|return
operator|new
name|ReversedClientScanner
argument_list|(
name|getConfiguration
argument_list|()
argument_list|,
name|scan
argument_list|,
name|getName
argument_list|()
argument_list|,
name|this
operator|.
name|connection
argument_list|)
return|;
block|}
return|return
operator|new
name|ClientScanner
argument_list|(
name|getConfiguration
argument_list|()
argument_list|,
name|scan
argument_list|,
name|getName
argument_list|()
argument_list|,
name|this
operator|.
name|connection
argument_list|)
return|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|ResultScanner
name|getScanner
parameter_list|(
name|byte
index|[]
name|family
parameter_list|)
throws|throws
name|IOException
block|{
name|Scan
name|scan
init|=
operator|new
name|Scan
argument_list|()
decl_stmt|;
name|scan
operator|.
name|addFamily
argument_list|(
name|family
argument_list|)
expr_stmt|;
return|return
name|getScanner
argument_list|(
name|scan
argument_list|)
return|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|ResultScanner
name|getScanner
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
throws|throws
name|IOException
block|{
name|Scan
name|scan
init|=
operator|new
name|Scan
argument_list|()
decl_stmt|;
name|scan
operator|.
name|addColumn
argument_list|(
name|family
argument_list|,
name|qualifier
argument_list|)
expr_stmt|;
return|return
name|getScanner
argument_list|(
name|scan
argument_list|)
return|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|Result
name|get
parameter_list|(
specifier|final
name|Get
name|get
parameter_list|)
throws|throws
name|IOException
block|{
name|RegionServerCallable
argument_list|<
name|Result
argument_list|>
name|callable
init|=
operator|new
name|RegionServerCallable
argument_list|<
name|Result
argument_list|>
argument_list|(
name|this
operator|.
name|connection
argument_list|,
name|getName
argument_list|()
argument_list|,
name|get
operator|.
name|getRow
argument_list|()
argument_list|)
block|{
specifier|public
name|Result
name|call
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|ProtobufUtil
operator|.
name|get
argument_list|(
name|getStub
argument_list|()
argument_list|,
name|getLocation
argument_list|()
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|get
argument_list|)
return|;
block|}
block|}
decl_stmt|;
return|return
name|rpcCallerFactory
operator|.
expr|<
name|Result
operator|>
name|newCaller
argument_list|()
operator|.
name|callWithRetries
argument_list|(
name|callable
argument_list|,
name|this
operator|.
name|operationTimeout
argument_list|)
return|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|Result
index|[]
name|get
parameter_list|(
name|List
argument_list|<
name|Get
argument_list|>
name|gets
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|gets
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
operator|new
name|Result
index|[]
block|{
name|get
argument_list|(
name|gets
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
block|}
return|;
block|}
try|try
block|{
name|Object
index|[]
name|r1
init|=
name|batch
argument_list|(
operator|(
name|List
operator|)
name|gets
argument_list|)
decl_stmt|;
comment|// translate.
name|Result
index|[]
name|results
init|=
operator|new
name|Result
index|[
name|r1
operator|.
name|length
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
name|r1
control|)
block|{
comment|// batch ensures if there is a failure we get an exception instead
name|results
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|Result
operator|)
name|o
expr_stmt|;
block|}
return|return
name|results
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|batch
parameter_list|(
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|Row
argument_list|>
name|actions
parameter_list|,
specifier|final
name|Object
index|[]
name|results
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|IOException
block|{
name|batchCallback
argument_list|(
name|actions
argument_list|,
name|results
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * {@inheritDoc}    * @deprecated If any exception is thrown by one of the actions, there is no way to    * retrieve the partially executed results. Use {@link #batch(List, Object[])} instead.    */
annotation|@
name|Override
specifier|public
name|Object
index|[]
name|batch
parameter_list|(
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|Row
argument_list|>
name|actions
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|IOException
block|{
return|return
name|batchCallback
argument_list|(
name|actions
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
parameter_list|<
name|R
parameter_list|>
name|void
name|batchCallback
parameter_list|(
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|Row
argument_list|>
name|actions
parameter_list|,
specifier|final
name|Object
index|[]
name|results
parameter_list|,
specifier|final
name|Batch
operator|.
name|Callback
argument_list|<
name|R
argument_list|>
name|callback
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|connection
operator|.
name|processBatchCallback
argument_list|(
name|actions
argument_list|,
name|tableName
argument_list|,
name|pool
argument_list|,
name|results
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
comment|/**    * {@inheritDoc}    * @deprecated If any exception is thrown by one of the actions, there is no way to    * retrieve the partially executed results. Use    * {@link #batchCallback(List, Object[], org.apache.hadoop.hbase.client.coprocessor.Batch.Callback)}    * instead.    */
annotation|@
name|Override
specifier|public
parameter_list|<
name|R
parameter_list|>
name|Object
index|[]
name|batchCallback
parameter_list|(
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|Row
argument_list|>
name|actions
parameter_list|,
specifier|final
name|Batch
operator|.
name|Callback
argument_list|<
name|R
argument_list|>
name|callback
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|Object
index|[]
name|results
init|=
operator|new
name|Object
index|[
name|actions
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|batchCallback
argument_list|(
name|actions
argument_list|,
name|results
argument_list|,
name|callback
argument_list|)
expr_stmt|;
return|return
name|results
return|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|delete
parameter_list|(
specifier|final
name|Delete
name|delete
parameter_list|)
throws|throws
name|IOException
block|{
name|RegionServerCallable
argument_list|<
name|Boolean
argument_list|>
name|callable
init|=
operator|new
name|RegionServerCallable
argument_list|<
name|Boolean
argument_list|>
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|,
name|delete
operator|.
name|getRow
argument_list|()
argument_list|)
block|{
specifier|public
name|Boolean
name|call
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|MutateRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildMutateRequest
argument_list|(
name|getLocation
argument_list|()
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|delete
argument_list|)
decl_stmt|;
name|MutateResponse
name|response
init|=
name|getStub
argument_list|()
operator|.
name|mutate
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
decl_stmt|;
return|return
name|Boolean
operator|.
name|valueOf
argument_list|(
name|response
operator|.
name|getProcessed
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
block|}
block|}
decl_stmt|;
name|rpcCallerFactory
operator|.
expr|<
name|Boolean
operator|>
name|newCaller
argument_list|()
operator|.
name|callWithRetries
argument_list|(
name|callable
argument_list|,
name|this
operator|.
name|operationTimeout
argument_list|)
expr_stmt|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|delete
parameter_list|(
specifier|final
name|List
argument_list|<
name|Delete
argument_list|>
name|deletes
parameter_list|)
throws|throws
name|IOException
block|{
name|Object
index|[]
name|results
init|=
operator|new
name|Object
index|[
name|deletes
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
try|try
block|{
name|batch
argument_list|(
name|deletes
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
comment|// mutate list so that it is empty for complete success, or contains only failed records
comment|// results are returned in the same order as the requests in list
comment|// walk the list backwards, so we can remove from list without impacting the indexes of earlier members
for|for
control|(
name|int
name|i
init|=
name|results
operator|.
name|length
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|// if result is not null, it succeeded
if|if
condition|(
name|results
index|[
name|i
index|]
operator|instanceof
name|Result
condition|)
block|{
name|deletes
operator|.
name|remove
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|put
parameter_list|(
specifier|final
name|Put
name|put
parameter_list|)
throws|throws
name|InterruptedIOException
throws|,
name|RetriesExhaustedWithDetailsException
block|{
name|doPut
argument_list|(
name|put
argument_list|)
expr_stmt|;
if|if
condition|(
name|autoFlush
condition|)
block|{
name|flushCommits
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|put
parameter_list|(
specifier|final
name|List
argument_list|<
name|Put
argument_list|>
name|puts
parameter_list|)
throws|throws
name|InterruptedIOException
throws|,
name|RetriesExhaustedWithDetailsException
block|{
for|for
control|(
name|Put
name|put
range|:
name|puts
control|)
block|{
name|doPut
argument_list|(
name|put
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|autoFlush
condition|)
block|{
name|flushCommits
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Add the put to the buffer. If the buffer is already too large, sends the buffer to the    *  cluster.    * @throws RetriesExhaustedWithDetailsException if there is an error on the cluster.    * @throws InterruptedIOException if we were interrupted.    */
specifier|private
name|void
name|doPut
parameter_list|(
name|Put
name|put
parameter_list|)
throws|throws
name|InterruptedIOException
throws|,
name|RetriesExhaustedWithDetailsException
block|{
if|if
condition|(
name|ap
operator|.
name|hasError
argument_list|()
condition|)
block|{
name|writeAsyncBuffer
operator|.
name|add
argument_list|(
name|put
argument_list|)
expr_stmt|;
name|backgroundFlushCommits
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|validatePut
argument_list|(
name|put
argument_list|)
expr_stmt|;
name|currentWriteBufferSize
operator|+=
name|put
operator|.
name|heapSize
argument_list|()
expr_stmt|;
name|writeAsyncBuffer
operator|.
name|add
argument_list|(
name|put
argument_list|)
expr_stmt|;
while|while
condition|(
name|currentWriteBufferSize
operator|>
name|writeBufferSize
condition|)
block|{
name|backgroundFlushCommits
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Send the operations in the buffer to the servers. Does not wait for the server's answer.    * If the is an error (max retried reach from a previous flush or bad operation), it tries to    * send all operations in the buffer and sends an exception.    * @param synchronous - if true, sends all the writes and wait for all of them to finish before    *                     returning.    */
specifier|private
name|void
name|backgroundFlushCommits
parameter_list|(
name|boolean
name|synchronous
parameter_list|)
throws|throws
name|InterruptedIOException
throws|,
name|RetriesExhaustedWithDetailsException
block|{
try|try
block|{
do|do
block|{
name|ap
operator|.
name|submit
argument_list|(
name|writeAsyncBuffer
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|synchronous
operator|&&
operator|!
name|writeAsyncBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
do|;
if|if
condition|(
name|synchronous
condition|)
block|{
name|ap
operator|.
name|waitUntilDone
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|.
name|hasError
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|tableName
operator|+
literal|": One or more of the operations have failed -"
operator|+
literal|" waiting for all operation in progress to finish (successfully or not)"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|writeAsyncBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ap
operator|.
name|submit
argument_list|(
name|writeAsyncBuffer
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|ap
operator|.
name|waitUntilDone
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|clearBufferOnFail
condition|)
block|{
comment|// if clearBufferOnFailed is not set, we're supposed to keep the failed operation in the
comment|//  write buffer. This is a questionable feature kept here for backward compatibility
name|writeAsyncBuffer
operator|.
name|addAll
argument_list|(
name|ap
operator|.
name|getFailedOperations
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|RetriesExhaustedWithDetailsException
name|e
init|=
name|ap
operator|.
name|getErrors
argument_list|()
decl_stmt|;
name|ap
operator|.
name|clearErrors
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
finally|finally
block|{
name|currentWriteBufferSize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|Row
name|mut
range|:
name|writeAsyncBuffer
control|)
block|{
if|if
condition|(
name|mut
operator|instanceof
name|Mutation
condition|)
block|{
name|currentWriteBufferSize
operator|+=
operator|(
operator|(
name|Mutation
operator|)
name|mut
operator|)
operator|.
name|heapSize
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|mutateRow
parameter_list|(
specifier|final
name|RowMutations
name|rm
parameter_list|)
throws|throws
name|IOException
block|{
name|RegionServerCallable
argument_list|<
name|Void
argument_list|>
name|callable
init|=
operator|new
name|RegionServerCallable
argument_list|<
name|Void
argument_list|>
argument_list|(
name|connection
argument_list|,
name|getName
argument_list|()
argument_list|,
name|rm
operator|.
name|getRow
argument_list|()
argument_list|)
block|{
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|RegionAction
operator|.
name|Builder
name|regionMutationBuilder
init|=
name|RequestConverter
operator|.
name|buildRegionAction
argument_list|(
name|getLocation
argument_list|()
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|rm
argument_list|)
decl_stmt|;
name|regionMutationBuilder
operator|.
name|setAtomic
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|MultiRequest
name|request
init|=
name|MultiRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|addRegionAction
argument_list|(
name|regionMutationBuilder
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|PayloadCarryingRpcController
name|pcrc
init|=
operator|new
name|PayloadCarryingRpcController
argument_list|()
decl_stmt|;
name|pcrc
operator|.
name|setPriority
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|getStub
argument_list|()
operator|.
name|multi
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
block|}
decl_stmt|;
name|rpcCallerFactory
operator|.
expr|<
name|Void
operator|>
name|newCaller
argument_list|()
operator|.
name|callWithRetries
argument_list|(
name|callable
argument_list|,
name|this
operator|.
name|operationTimeout
argument_list|)
expr_stmt|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|Result
name|append
parameter_list|(
specifier|final
name|Append
name|append
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|append
operator|.
name|numFamilies
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid arguments to append, no columns specified"
argument_list|)
throw|;
block|}
name|NonceGenerator
name|ng
init|=
name|this
operator|.
name|connection
operator|.
name|getNonceGenerator
argument_list|()
decl_stmt|;
specifier|final
name|long
name|nonceGroup
init|=
name|ng
operator|.
name|getNonceGroup
argument_list|()
decl_stmt|,
name|nonce
init|=
name|ng
operator|.
name|newNonce
argument_list|()
decl_stmt|;
name|RegionServerCallable
argument_list|<
name|Result
argument_list|>
name|callable
init|=
operator|new
name|RegionServerCallable
argument_list|<
name|Result
argument_list|>
argument_list|(
name|this
operator|.
name|connection
argument_list|,
name|getName
argument_list|()
argument_list|,
name|append
operator|.
name|getRow
argument_list|()
argument_list|)
block|{
specifier|public
name|Result
name|call
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|MutateRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildMutateRequest
argument_list|(
name|getLocation
argument_list|()
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|append
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
decl_stmt|;
name|PayloadCarryingRpcController
name|rpcController
init|=
operator|new
name|PayloadCarryingRpcController
argument_list|()
decl_stmt|;
name|rpcController
operator|.
name|setPriority
argument_list|(
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
name|MutateResponse
name|response
init|=
name|getStub
argument_list|()
operator|.
name|mutate
argument_list|(
name|rpcController
argument_list|,
name|request
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|response
operator|.
name|hasResult
argument_list|()
condition|)
return|return
literal|null
return|;
return|return
name|ProtobufUtil
operator|.
name|toResult
argument_list|(
name|response
operator|.
name|getResult
argument_list|()
argument_list|,
name|rpcController
operator|.
name|cellScanner
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
block|}
block|}
decl_stmt|;
return|return
name|rpcCallerFactory
operator|.
expr|<
name|Result
operator|>
name|newCaller
argument_list|()
operator|.
name|callWithRetries
argument_list|(
name|callable
argument_list|,
name|this
operator|.
name|operationTimeout
argument_list|)
return|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|Result
name|increment
parameter_list|(
specifier|final
name|Increment
name|increment
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|increment
operator|.
name|hasFamilies
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid arguments to increment, no columns specified"
argument_list|)
throw|;
block|}
name|NonceGenerator
name|ng
init|=
name|this
operator|.
name|connection
operator|.
name|getNonceGenerator
argument_list|()
decl_stmt|;
specifier|final
name|long
name|nonceGroup
init|=
name|ng
operator|.
name|getNonceGroup
argument_list|()
decl_stmt|,
name|nonce
init|=
name|ng
operator|.
name|newNonce
argument_list|()
decl_stmt|;
name|RegionServerCallable
argument_list|<
name|Result
argument_list|>
name|callable
init|=
operator|new
name|RegionServerCallable
argument_list|<
name|Result
argument_list|>
argument_list|(
name|this
operator|.
name|connection
argument_list|,
name|getName
argument_list|()
argument_list|,
name|increment
operator|.
name|getRow
argument_list|()
argument_list|)
block|{
specifier|public
name|Result
name|call
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|MutateRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildMutateRequest
argument_list|(
name|getLocation
argument_list|()
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|increment
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
decl_stmt|;
name|PayloadCarryingRpcController
name|rpcController
init|=
operator|new
name|PayloadCarryingRpcController
argument_list|()
decl_stmt|;
name|rpcController
operator|.
name|setPriority
argument_list|(
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
name|MutateResponse
name|response
init|=
name|getStub
argument_list|()
operator|.
name|mutate
argument_list|(
name|rpcController
argument_list|,
name|request
argument_list|)
decl_stmt|;
return|return
name|ProtobufUtil
operator|.
name|toResult
argument_list|(
name|response
operator|.
name|getResult
argument_list|()
argument_list|,
name|rpcController
operator|.
name|cellScanner
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
block|}
block|}
decl_stmt|;
return|return
name|rpcCallerFactory
operator|.
expr|<
name|Result
operator|>
name|newCaller
argument_list|()
operator|.
name|callWithRetries
argument_list|(
name|callable
argument_list|,
name|this
operator|.
name|operationTimeout
argument_list|)
return|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|long
name|incrementColumnValue
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|long
name|amount
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|incrementColumnValue
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|amount
argument_list|,
name|Durability
operator|.
name|SYNC_WAL
argument_list|)
return|;
block|}
comment|/**    * @deprecated Use {@link #incrementColumnValue(byte[], byte[], byte[], long, Durability)}    */
annotation|@
name|Deprecated
annotation|@
name|Override
specifier|public
name|long
name|incrementColumnValue
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|long
name|amount
parameter_list|,
specifier|final
name|boolean
name|writeToWAL
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|incrementColumnValue
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|amount
argument_list|,
name|writeToWAL
condition|?
name|Durability
operator|.
name|SKIP_WAL
else|:
name|Durability
operator|.
name|USE_DEFAULT
argument_list|)
return|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|long
name|incrementColumnValue
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|long
name|amount
parameter_list|,
specifier|final
name|Durability
name|durability
parameter_list|)
throws|throws
name|IOException
block|{
name|NullPointerException
name|npe
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|row
operator|==
literal|null
condition|)
block|{
name|npe
operator|=
operator|new
name|NullPointerException
argument_list|(
literal|"row is null"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|family
operator|==
literal|null
condition|)
block|{
name|npe
operator|=
operator|new
name|NullPointerException
argument_list|(
literal|"family is null"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qualifier
operator|==
literal|null
condition|)
block|{
name|npe
operator|=
operator|new
name|NullPointerException
argument_list|(
literal|"qualifier is null"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|npe
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid arguments to incrementColumnValue"
argument_list|,
name|npe
argument_list|)
throw|;
block|}
name|NonceGenerator
name|ng
init|=
name|this
operator|.
name|connection
operator|.
name|getNonceGenerator
argument_list|()
decl_stmt|;
specifier|final
name|long
name|nonceGroup
init|=
name|ng
operator|.
name|getNonceGroup
argument_list|()
decl_stmt|,
name|nonce
init|=
name|ng
operator|.
name|newNonce
argument_list|()
decl_stmt|;
name|RegionServerCallable
argument_list|<
name|Long
argument_list|>
name|callable
init|=
operator|new
name|RegionServerCallable
argument_list|<
name|Long
argument_list|>
argument_list|(
name|connection
argument_list|,
name|getName
argument_list|()
argument_list|,
name|row
argument_list|)
block|{
specifier|public
name|Long
name|call
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|MutateRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildIncrementRequest
argument_list|(
name|getLocation
argument_list|()
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|amount
argument_list|,
name|durability
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
decl_stmt|;
name|PayloadCarryingRpcController
name|rpcController
init|=
operator|new
name|PayloadCarryingRpcController
argument_list|()
decl_stmt|;
name|rpcController
operator|.
name|setPriority
argument_list|(
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
name|MutateResponse
name|response
init|=
name|getStub
argument_list|()
operator|.
name|mutate
argument_list|(
name|rpcController
argument_list|,
name|request
argument_list|)
decl_stmt|;
name|Result
name|result
init|=
name|ProtobufUtil
operator|.
name|toResult
argument_list|(
name|response
operator|.
name|getResult
argument_list|()
argument_list|,
name|rpcController
operator|.
name|cellScanner
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|Long
operator|.
name|valueOf
argument_list|(
name|Bytes
operator|.
name|toLong
argument_list|(
name|result
operator|.
name|getValue
argument_list|(
name|family
argument_list|,
name|qualifier
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
block|}
block|}
decl_stmt|;
return|return
name|rpcCallerFactory
operator|.
expr|<
name|Long
operator|>
name|newCaller
argument_list|()
operator|.
name|callWithRetries
argument_list|(
name|callable
argument_list|,
name|this
operator|.
name|operationTimeout
argument_list|)
return|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|boolean
name|checkAndPut
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|Put
name|put
parameter_list|)
throws|throws
name|IOException
block|{
name|RegionServerCallable
argument_list|<
name|Boolean
argument_list|>
name|callable
init|=
operator|new
name|RegionServerCallable
argument_list|<
name|Boolean
argument_list|>
argument_list|(
name|connection
argument_list|,
name|getName
argument_list|()
argument_list|,
name|row
argument_list|)
block|{
specifier|public
name|Boolean
name|call
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|MutateRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildMutateRequest
argument_list|(
name|getLocation
argument_list|()
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
operator|new
name|BinaryComparator
argument_list|(
name|value
argument_list|)
argument_list|,
name|CompareType
operator|.
name|EQUAL
argument_list|,
name|put
argument_list|)
decl_stmt|;
name|MutateResponse
name|response
init|=
name|getStub
argument_list|()
operator|.
name|mutate
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
decl_stmt|;
return|return
name|Boolean
operator|.
name|valueOf
argument_list|(
name|response
operator|.
name|getProcessed
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
block|}
block|}
decl_stmt|;
return|return
name|rpcCallerFactory
operator|.
expr|<
name|Boolean
operator|>
name|newCaller
argument_list|()
operator|.
name|callWithRetries
argument_list|(
name|callable
argument_list|,
name|this
operator|.
name|operationTimeout
argument_list|)
return|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|boolean
name|checkAndDelete
parameter_list|(
specifier|final
name|byte
index|[]
name|row
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|byte
index|[]
name|value
parameter_list|,
specifier|final
name|Delete
name|delete
parameter_list|)
throws|throws
name|IOException
block|{
name|RegionServerCallable
argument_list|<
name|Boolean
argument_list|>
name|callable
init|=
operator|new
name|RegionServerCallable
argument_list|<
name|Boolean
argument_list|>
argument_list|(
name|connection
argument_list|,
name|getName
argument_list|()
argument_list|,
name|row
argument_list|)
block|{
specifier|public
name|Boolean
name|call
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|MutateRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildMutateRequest
argument_list|(
name|getLocation
argument_list|()
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
operator|new
name|BinaryComparator
argument_list|(
name|value
argument_list|)
argument_list|,
name|CompareType
operator|.
name|EQUAL
argument_list|,
name|delete
argument_list|)
decl_stmt|;
name|MutateResponse
name|response
init|=
name|getStub
argument_list|()
operator|.
name|mutate
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
decl_stmt|;
return|return
name|Boolean
operator|.
name|valueOf
argument_list|(
name|response
operator|.
name|getProcessed
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
block|}
block|}
decl_stmt|;
return|return
name|rpcCallerFactory
operator|.
expr|<
name|Boolean
operator|>
name|newCaller
argument_list|()
operator|.
name|callWithRetries
argument_list|(
name|callable
argument_list|,
name|this
operator|.
name|operationTimeout
argument_list|)
return|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|boolean
name|exists
parameter_list|(
specifier|final
name|Get
name|get
parameter_list|)
throws|throws
name|IOException
block|{
name|get
operator|.
name|setCheckExistenceOnly
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Result
name|r
init|=
name|get
argument_list|(
name|get
argument_list|)
decl_stmt|;
assert|assert
name|r
operator|.
name|getExists
argument_list|()
operator|!=
literal|null
assert|;
return|return
name|r
operator|.
name|getExists
argument_list|()
return|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|Boolean
index|[]
name|exists
parameter_list|(
specifier|final
name|List
argument_list|<
name|Get
argument_list|>
name|gets
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|gets
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
operator|new
name|Boolean
index|[]
block|{}
return|;
if|if
condition|(
name|gets
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
return|return
operator|new
name|Boolean
index|[]
block|{
name|exists
argument_list|(
name|gets
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
block|}
return|;
for|for
control|(
name|Get
name|g
range|:
name|gets
control|)
block|{
name|g
operator|.
name|setCheckExistenceOnly
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|Object
index|[]
name|r1
decl_stmt|;
try|try
block|{
name|r1
operator|=
name|batch
argument_list|(
name|gets
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// translate.
name|Boolean
index|[]
name|results
init|=
operator|new
name|Boolean
index|[
name|r1
operator|.
name|length
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
name|r1
control|)
block|{
comment|// batch ensures if there is a failure we get an exception instead
name|results
index|[
name|i
operator|++
index|]
operator|=
operator|(
operator|(
name|Result
operator|)
name|o
operator|)
operator|.
name|getExists
argument_list|()
expr_stmt|;
block|}
return|return
name|results
return|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|flushCommits
parameter_list|()
throws|throws
name|InterruptedIOException
throws|,
name|RetriesExhaustedWithDetailsException
block|{
comment|// As we can have an operation in progress even if the buffer is empty, we call
comment|//  backgroundFlushCommits at least one time.
name|backgroundFlushCommits
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Process a mixed batch of Get, Put and Delete actions. All actions for a    * RegionServer are forwarded in one RPC call. Queries are executed in parallel.    *    * @param list The collection of actions.    * @param results An empty array, same size as list. If an exception is thrown,    * you can test here for partial results, and to determine which actions    * processed successfully.    * @throws IOException if there are problems talking to META. Per-item    * exceptions are stored in the results array.    */
specifier|public
parameter_list|<
name|R
parameter_list|>
name|void
name|processBatchCallback
parameter_list|(
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|Row
argument_list|>
name|list
parameter_list|,
specifier|final
name|Object
index|[]
name|results
parameter_list|,
specifier|final
name|Batch
operator|.
name|Callback
argument_list|<
name|R
argument_list|>
name|callback
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|this
operator|.
name|batchCallback
argument_list|(
name|list
argument_list|,
name|results
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
comment|/**    * Parameterized batch processing, allowing varying return types for different    * {@link Row} implementations.    */
specifier|public
name|void
name|processBatch
parameter_list|(
specifier|final
name|List
argument_list|<
name|?
extends|extends
name|Row
argument_list|>
name|list
parameter_list|,
specifier|final
name|Object
index|[]
name|results
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|this
operator|.
name|processBatchCallback
argument_list|(
name|list
argument_list|,
name|results
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|closed
condition|)
block|{
return|return;
block|}
name|flushCommits
argument_list|()
expr_stmt|;
if|if
condition|(
name|cleanupPoolOnClose
condition|)
block|{
name|this
operator|.
name|pool
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cleanupConnectionOnClose
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|connection
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
name|this
operator|.
name|closed
operator|=
literal|true
expr_stmt|;
block|}
comment|// validate for well-formedness
specifier|public
name|void
name|validatePut
parameter_list|(
specifier|final
name|Put
name|put
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|put
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"No columns to insert"
argument_list|)
throw|;
block|}
if|if
condition|(
name|maxKeyValueSize
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|List
argument_list|<
name|Cell
argument_list|>
name|list
range|:
name|put
operator|.
name|getFamilyCellMap
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|Cell
name|cell
range|:
name|list
control|)
block|{
comment|// KeyValue v1 expectation.  Cast for now.
name|KeyValue
name|kv
init|=
name|KeyValueUtil
operator|.
name|ensureKeyValue
argument_list|(
name|cell
argument_list|)
decl_stmt|;
if|if
condition|(
name|kv
operator|.
name|getLength
argument_list|()
operator|>
name|maxKeyValueSize
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"KeyValue size too large"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|boolean
name|isAutoFlush
parameter_list|()
block|{
return|return
name|autoFlush
return|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Deprecated
annotation|@
name|Override
specifier|public
name|void
name|setAutoFlush
parameter_list|(
name|boolean
name|autoFlush
parameter_list|)
block|{
name|setAutoFlush
argument_list|(
name|autoFlush
argument_list|,
name|autoFlush
argument_list|)
expr_stmt|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|setAutoFlushTo
parameter_list|(
name|boolean
name|autoFlush
parameter_list|)
block|{
name|setAutoFlush
argument_list|(
name|autoFlush
argument_list|,
name|clearBufferOnFail
argument_list|)
expr_stmt|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|setAutoFlush
parameter_list|(
name|boolean
name|autoFlush
parameter_list|,
name|boolean
name|clearBufferOnFail
parameter_list|)
block|{
name|this
operator|.
name|autoFlush
operator|=
name|autoFlush
expr_stmt|;
name|this
operator|.
name|clearBufferOnFail
operator|=
name|autoFlush
operator|||
name|clearBufferOnFail
expr_stmt|;
block|}
comment|/**    * Returns the maximum size in bytes of the write buffer for this HTable.    *<p>    * The default value comes from the configuration parameter    * {@code hbase.client.write.buffer}.    * @return The size of the write buffer in bytes.    */
annotation|@
name|Override
specifier|public
name|long
name|getWriteBufferSize
parameter_list|()
block|{
return|return
name|writeBufferSize
return|;
block|}
comment|/**    * Sets the size of the buffer in bytes.    *<p>    * If the new size is less than the current amount of data in the    * write buffer, the buffer gets flushed.    * @param writeBufferSize The new write buffer size, in bytes.    * @throws IOException if a remote or network exception occurs.    */
specifier|public
name|void
name|setWriteBufferSize
parameter_list|(
name|long
name|writeBufferSize
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|writeBufferSize
operator|=
name|writeBufferSize
expr_stmt|;
if|if
condition|(
name|currentWriteBufferSize
operator|>
name|writeBufferSize
condition|)
block|{
name|flushCommits
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * The pool is used for mutli requests for this HTable    * @return the pool used for mutli    */
name|ExecutorService
name|getPool
parameter_list|()
block|{
return|return
name|this
operator|.
name|pool
return|;
block|}
comment|/**    * Enable or disable region cache prefetch for the table. It will be    * applied for the given table's all HTable instances who share the same    * connection. By default, the cache prefetch is enabled.    * @param tableName name of table to configure.    * @param enable Set to true to enable region cache prefetch. Or set to    * false to disable it.    * @throws IOException    */
specifier|public
specifier|static
name|void
name|setRegionCachePrefetch
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|boolean
name|enable
parameter_list|)
throws|throws
name|IOException
block|{
name|setRegionCachePrefetch
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|enable
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|setRegionCachePrefetch
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|boolean
name|enable
parameter_list|)
throws|throws
name|IOException
block|{
name|HConnectionManager
operator|.
name|execute
argument_list|(
operator|new
name|HConnectable
argument_list|<
name|Void
argument_list|>
argument_list|(
name|HBaseConfiguration
operator|.
name|create
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|connect
parameter_list|(
name|HConnection
name|connection
parameter_list|)
throws|throws
name|IOException
block|{
name|connection
operator|.
name|setRegionCachePrefetch
argument_list|(
name|tableName
argument_list|,
name|enable
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Enable or disable region cache prefetch for the table. It will be    * applied for the given table's all HTable instances who share the same    * connection. By default, the cache prefetch is enabled.    * @param conf The Configuration object to use.    * @param tableName name of table to configure.    * @param enable Set to true to enable region cache prefetch. Or set to    * false to disable it.    * @throws IOException    */
specifier|public
specifier|static
name|void
name|setRegionCachePrefetch
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|boolean
name|enable
parameter_list|)
throws|throws
name|IOException
block|{
name|setRegionCachePrefetch
argument_list|(
name|conf
argument_list|,
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|enable
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|setRegionCachePrefetch
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|boolean
name|enable
parameter_list|)
throws|throws
name|IOException
block|{
name|HConnectionManager
operator|.
name|execute
argument_list|(
operator|new
name|HConnectable
argument_list|<
name|Void
argument_list|>
argument_list|(
name|conf
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|connect
parameter_list|(
name|HConnection
name|connection
parameter_list|)
throws|throws
name|IOException
block|{
name|connection
operator|.
name|setRegionCachePrefetch
argument_list|(
name|tableName
argument_list|,
name|enable
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check whether region cache prefetch is enabled or not for the table.    * @param conf The Configuration object to use.    * @param tableName name of table to check    * @return true if table's region cache prefecth is enabled. Otherwise    * it is disabled.    * @throws IOException    */
specifier|public
specifier|static
name|boolean
name|getRegionCachePrefetch
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getRegionCachePrefetch
argument_list|(
name|conf
argument_list|,
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|getRegionCachePrefetch
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|HConnectionManager
operator|.
name|execute
argument_list|(
operator|new
name|HConnectable
argument_list|<
name|Boolean
argument_list|>
argument_list|(
name|conf
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|connect
parameter_list|(
name|HConnection
name|connection
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|connection
operator|.
name|getRegionCachePrefetch
argument_list|(
name|tableName
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Check whether region cache prefetch is enabled or not for the table.    * @param tableName name of table to check    * @return true if table's region cache prefecth is enabled. Otherwise    * it is disabled.    * @throws IOException    */
specifier|public
specifier|static
name|boolean
name|getRegionCachePrefetch
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getRegionCachePrefetch
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|getRegionCachePrefetch
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|HConnectionManager
operator|.
name|execute
argument_list|(
operator|new
name|HConnectable
argument_list|<
name|Boolean
argument_list|>
argument_list|(
name|HBaseConfiguration
operator|.
name|create
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|connect
parameter_list|(
name|HConnection
name|connection
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|connection
operator|.
name|getRegionCachePrefetch
argument_list|(
name|tableName
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Explicitly clears the region cache to fetch the latest value from META.    * This is a power user function: avoid unless you know the ramifications.    */
specifier|public
name|void
name|clearRegionCache
parameter_list|()
block|{
name|this
operator|.
name|connection
operator|.
name|clearRegionCache
argument_list|()
expr_stmt|;
block|}
comment|/**    * {@inheritDoc}    */
specifier|public
name|CoprocessorRpcChannel
name|coprocessorService
parameter_list|(
name|byte
index|[]
name|row
parameter_list|)
block|{
return|return
operator|new
name|RegionCoprocessorRpcChannel
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|,
name|row
argument_list|)
return|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Service
parameter_list|,
name|R
parameter_list|>
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|R
argument_list|>
name|coprocessorService
parameter_list|(
specifier|final
name|Class
argument_list|<
name|T
argument_list|>
name|service
parameter_list|,
name|byte
index|[]
name|startKey
parameter_list|,
name|byte
index|[]
name|endKey
parameter_list|,
specifier|final
name|Batch
operator|.
name|Call
argument_list|<
name|T
argument_list|,
name|R
argument_list|>
name|callable
parameter_list|)
throws|throws
name|ServiceException
throws|,
name|Throwable
block|{
specifier|final
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|R
argument_list|>
name|results
init|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|R
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
argument_list|)
decl_stmt|;
name|coprocessorService
argument_list|(
name|service
argument_list|,
name|startKey
argument_list|,
name|endKey
argument_list|,
name|callable
argument_list|,
operator|new
name|Batch
operator|.
name|Callback
argument_list|<
name|R
argument_list|>
argument_list|()
block|{
specifier|public
name|void
name|update
parameter_list|(
name|byte
index|[]
name|region
parameter_list|,
name|byte
index|[]
name|row
parameter_list|,
name|R
name|value
parameter_list|)
block|{
name|results
operator|.
name|put
argument_list|(
name|region
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|results
return|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
extends|extends
name|Service
parameter_list|,
name|R
parameter_list|>
name|void
name|coprocessorService
parameter_list|(
specifier|final
name|Class
argument_list|<
name|T
argument_list|>
name|service
parameter_list|,
name|byte
index|[]
name|startKey
parameter_list|,
name|byte
index|[]
name|endKey
parameter_list|,
specifier|final
name|Batch
operator|.
name|Call
argument_list|<
name|T
argument_list|,
name|R
argument_list|>
name|callable
parameter_list|,
specifier|final
name|Batch
operator|.
name|Callback
argument_list|<
name|R
argument_list|>
name|callback
parameter_list|)
throws|throws
name|ServiceException
throws|,
name|Throwable
block|{
comment|// get regions covered by the row range
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|keys
init|=
name|getStartKeysInRange
argument_list|(
name|startKey
argument_list|,
name|endKey
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|Future
argument_list|<
name|R
argument_list|>
argument_list|>
name|futures
init|=
operator|new
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|Future
argument_list|<
name|R
argument_list|>
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|byte
index|[]
name|r
range|:
name|keys
control|)
block|{
specifier|final
name|RegionCoprocessorRpcChannel
name|channel
init|=
operator|new
name|RegionCoprocessorRpcChannel
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|,
name|r
argument_list|)
decl_stmt|;
name|Future
argument_list|<
name|R
argument_list|>
name|future
init|=
name|pool
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|R
argument_list|>
argument_list|()
block|{
specifier|public
name|R
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|T
name|instance
init|=
name|ProtobufUtil
operator|.
name|newServiceStub
argument_list|(
name|service
argument_list|,
name|channel
argument_list|)
decl_stmt|;
name|R
name|result
init|=
name|callable
operator|.
name|call
argument_list|(
name|instance
argument_list|)
decl_stmt|;
name|byte
index|[]
name|region
init|=
name|channel
operator|.
name|getLastRegion
argument_list|()
decl_stmt|;
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
block|{
name|callback
operator|.
name|update
argument_list|(
name|region
argument_list|,
name|r
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|futures
operator|.
name|put
argument_list|(
name|r
argument_list|,
name|future
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|Future
argument_list|<
name|R
argument_list|>
argument_list|>
name|e
range|:
name|futures
operator|.
name|entrySet
argument_list|()
control|)
block|{
try|try
block|{
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|ee
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error calling coprocessor service "
operator|+
name|service
operator|.
name|getName
argument_list|()
operator|+
literal|" for row "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|,
name|ee
argument_list|)
expr_stmt|;
throw|throw
name|ee
operator|.
name|getCause
argument_list|()
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|InterruptedIOException
argument_list|(
literal|"Interrupted calling coprocessor service "
operator|+
name|service
operator|.
name|getName
argument_list|()
operator|+
literal|" for row "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
operator|.
name|initCause
argument_list|(
name|ie
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|getStartKeysInRange
parameter_list|(
name|byte
index|[]
name|start
parameter_list|,
name|byte
index|[]
name|end
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|start
operator|==
literal|null
condition|)
block|{
name|start
operator|=
name|HConstants
operator|.
name|EMPTY_START_ROW
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|==
literal|null
condition|)
block|{
name|end
operator|=
name|HConstants
operator|.
name|EMPTY_END_ROW
expr_stmt|;
block|}
return|return
name|getKeysAndRegionsInRange
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
literal|true
argument_list|)
operator|.
name|getFirst
argument_list|()
return|;
block|}
specifier|public
name|void
name|setOperationTimeout
parameter_list|(
name|int
name|operationTimeout
parameter_list|)
block|{
name|this
operator|.
name|operationTimeout
operator|=
name|operationTimeout
expr_stmt|;
block|}
specifier|public
name|int
name|getOperationTimeout
parameter_list|()
block|{
return|return
name|operationTimeout
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|tableName
operator|+
literal|";"
operator|+
name|connection
return|;
block|}
comment|/**    * Run basic test.    * @param args Pass table name and row and will get the content.    * @throws IOException    */
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|IOException
block|{
name|HTable
name|t
init|=
operator|new
name|HTable
argument_list|(
name|HBaseConfiguration
operator|.
name|create
argument_list|()
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
try|try
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|t
operator|.
name|get
argument_list|(
operator|new
name|Get
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|t
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

