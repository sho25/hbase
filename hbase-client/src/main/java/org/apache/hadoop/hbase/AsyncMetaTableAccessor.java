begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FutureUtils
operator|.
name|addListener
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CompletableFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MetaTableAccessor
operator|.
name|CollectingVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MetaTableAccessor
operator|.
name|QueryType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MetaTableAccessor
operator|.
name|Visitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|AdvancedScanResultConsumer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|AsyncTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Consistency
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Get
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionReplicaUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Scan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Scan
operator|.
name|ReadType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|TableState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|DeserializationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * The asynchronous meta table accessor. Used to read/write region and assignment information store  * in<code>hbase:meta</code>.  * @since 2.0.0  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|AsyncMetaTableAccessor
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|AsyncMetaTableAccessor
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** The delimiter for meta columns for replicaIds&gt; 0 */
specifier|private
specifier|static
specifier|final
name|char
name|META_REPLICA_ID_DELIMITER
init|=
literal|'_'
decl_stmt|;
comment|/** A regex for parsing server columns from meta. See above javadoc for meta layout */
specifier|private
specifier|static
specifier|final
name|Pattern
name|SERVER_COLUMN_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^server(_[0-9a-fA-F]{4})?$"
argument_list|)
decl_stmt|;
specifier|public
specifier|static
name|CompletableFuture
argument_list|<
name|Boolean
argument_list|>
name|tableExists
parameter_list|(
name|AsyncTable
argument_list|<
name|?
argument_list|>
name|metaTable
parameter_list|,
name|TableName
name|tableName
parameter_list|)
block|{
return|return
name|getTableState
argument_list|(
name|metaTable
argument_list|,
name|tableName
argument_list|)
operator|.
name|thenApply
argument_list|(
name|Optional
operator|::
name|isPresent
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|CompletableFuture
argument_list|<
name|Optional
argument_list|<
name|TableState
argument_list|>
argument_list|>
name|getTableState
parameter_list|(
name|AsyncTable
argument_list|<
name|?
argument_list|>
name|metaTable
parameter_list|,
name|TableName
name|tableName
parameter_list|)
block|{
name|CompletableFuture
argument_list|<
name|Optional
argument_list|<
name|TableState
argument_list|>
argument_list|>
name|future
init|=
operator|new
name|CompletableFuture
argument_list|<>
argument_list|()
decl_stmt|;
name|Get
name|get
init|=
operator|new
name|Get
argument_list|(
name|tableName
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|addColumn
argument_list|(
name|getTableFamily
argument_list|()
argument_list|,
name|getStateColumn
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|time
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
decl_stmt|;
try|try
block|{
name|get
operator|.
name|setTimeRange
argument_list|(
literal|0
argument_list|,
name|time
argument_list|)
expr_stmt|;
name|addListener
argument_list|(
name|metaTable
operator|.
name|get
argument_list|(
name|get
argument_list|)
argument_list|,
parameter_list|(
name|result
parameter_list|,
name|error
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|error
operator|!=
literal|null
condition|)
block|{
name|future
operator|.
name|completeExceptionally
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
try|try
block|{
name|future
operator|.
name|complete
argument_list|(
name|getTableState
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|future
operator|.
name|completeExceptionally
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|future
operator|.
name|completeExceptionally
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
return|return
name|future
return|;
block|}
comment|/**    * Returns the HRegionLocation from meta for the given region    * @param metaTable    * @param regionName region we're looking for    * @return HRegionLocation for the given region    */
specifier|public
specifier|static
name|CompletableFuture
argument_list|<
name|Optional
argument_list|<
name|HRegionLocation
argument_list|>
argument_list|>
name|getRegionLocation
parameter_list|(
name|AsyncTable
argument_list|<
name|?
argument_list|>
name|metaTable
parameter_list|,
name|byte
index|[]
name|regionName
parameter_list|)
block|{
name|CompletableFuture
argument_list|<
name|Optional
argument_list|<
name|HRegionLocation
argument_list|>
argument_list|>
name|future
init|=
operator|new
name|CompletableFuture
argument_list|<>
argument_list|()
decl_stmt|;
try|try
block|{
name|RegionInfo
name|parsedRegionInfo
init|=
name|MetaTableAccessor
operator|.
name|parseRegionInfoFromRegionName
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|addListener
argument_list|(
name|metaTable
operator|.
name|get
argument_list|(
operator|new
name|Get
argument_list|(
name|MetaTableAccessor
operator|.
name|getMetaKeyForRegion
argument_list|(
name|parsedRegionInfo
argument_list|)
argument_list|)
operator|.
name|addFamily
argument_list|(
name|HConstants
operator|.
name|CATALOG_FAMILY
argument_list|)
argument_list|)
argument_list|,
parameter_list|(
name|r
parameter_list|,
name|err
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|err
operator|!=
literal|null
condition|)
block|{
name|future
operator|.
name|completeExceptionally
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return;
block|}
name|future
operator|.
name|complete
argument_list|(
name|getRegionLocations
argument_list|(
name|r
argument_list|)
operator|.
name|map
argument_list|(
name|locations
lambda|->
name|locations
operator|.
name|getRegionLocation
argument_list|(
name|parsedRegionInfo
operator|.
name|getReplicaId
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|parseEx
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to parse the passed region name: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionName
argument_list|)
argument_list|)
expr_stmt|;
name|future
operator|.
name|completeExceptionally
argument_list|(
name|parseEx
argument_list|)
expr_stmt|;
block|}
return|return
name|future
return|;
block|}
comment|/**    * Returns the HRegionLocation from meta for the given encoded region name    * @param metaTable    * @param encodedRegionName region we're looking for    * @return HRegionLocation for the given region    */
specifier|public
specifier|static
name|CompletableFuture
argument_list|<
name|Optional
argument_list|<
name|HRegionLocation
argument_list|>
argument_list|>
name|getRegionLocationWithEncodedName
parameter_list|(
name|AsyncTable
argument_list|<
name|?
argument_list|>
name|metaTable
parameter_list|,
name|byte
index|[]
name|encodedRegionName
parameter_list|)
block|{
name|CompletableFuture
argument_list|<
name|Optional
argument_list|<
name|HRegionLocation
argument_list|>
argument_list|>
name|future
init|=
operator|new
name|CompletableFuture
argument_list|<>
argument_list|()
decl_stmt|;
name|addListener
argument_list|(
name|metaTable
operator|.
name|scanAll
argument_list|(
operator|new
name|Scan
argument_list|()
operator|.
name|setReadType
argument_list|(
name|ReadType
operator|.
name|PREAD
argument_list|)
operator|.
name|addFamily
argument_list|(
name|HConstants
operator|.
name|CATALOG_FAMILY
argument_list|)
argument_list|)
argument_list|,
parameter_list|(
name|results
parameter_list|,
name|err
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|err
operator|!=
literal|null
condition|)
block|{
name|future
operator|.
name|completeExceptionally
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return;
block|}
name|String
name|encodedRegionNameStr
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|encodedRegionName
argument_list|)
decl_stmt|;
name|results
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|result
lambda|->
operator|!
name|result
operator|.
name|isEmpty
argument_list|()
argument_list|)
operator|.
name|filter
argument_list|(
name|result
lambda|->
name|MetaTableAccessor
operator|.
name|getRegionInfo
argument_list|(
name|result
argument_list|)
operator|!=
literal|null
argument_list|)
operator|.
name|forEach
argument_list|(
name|result
lambda|->
block|{
name|getRegionLocations
argument_list|(
name|result
argument_list|)
operator|.
name|ifPresent
argument_list|(
name|locations
lambda|->
block|{
lambda|for (HRegionLocation location : locations.getRegionLocations(
argument_list|)
argument_list|)
block|{
if|if
condition|(
name|location
operator|!=
literal|null
operator|&&
name|encodedRegionNameStr
operator|.
name|equals
argument_list|(
name|location
operator|.
name|getRegion
argument_list|()
operator|.
name|getEncodedName
argument_list|()
argument_list|)
condition|)
block|{
name|future
operator|.
name|complete
argument_list|(
name|Optional
operator|.
name|of
argument_list|(
name|location
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_class

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_empty_stmt
unit|})
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|future
operator|.
name|complete
argument_list|(
name|Optional
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_empty_stmt
unit|})
empty_stmt|;
end_empty_stmt

begin_return
return|return
name|future
return|;
end_return

begin_function
unit|}    private
specifier|static
name|Optional
argument_list|<
name|TableState
argument_list|>
name|getTableState
parameter_list|(
name|Result
name|r
parameter_list|)
throws|throws
name|IOException
block|{
name|Cell
name|cell
init|=
name|r
operator|.
name|getColumnLatestCell
argument_list|(
name|getTableFamily
argument_list|()
argument_list|,
name|getStateColumn
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cell
operator|==
literal|null
condition|)
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
try|try
block|{
return|return
name|Optional
operator|.
name|of
argument_list|(
name|TableState
operator|.
name|parseFrom
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|r
operator|.
name|getRow
argument_list|()
argument_list|)
argument_list|,
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|cell
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getValueOffset
argument_list|()
operator|+
name|cell
operator|.
name|getValueLength
argument_list|()
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to parse table state from result: "
operator|+
name|r
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
end_function

begin_comment
comment|/**    * Used to get all region locations for the specific table.    * @param metaTable    * @param tableName table we're looking for, can be null for getting all regions    * @return the list of region locations. The return value will be wrapped by a    *         {@link CompletableFuture}.    */
end_comment

begin_function
specifier|public
specifier|static
name|CompletableFuture
argument_list|<
name|List
argument_list|<
name|HRegionLocation
argument_list|>
argument_list|>
name|getTableHRegionLocations
parameter_list|(
name|AsyncTable
argument_list|<
name|AdvancedScanResultConsumer
argument_list|>
name|metaTable
parameter_list|,
name|Optional
argument_list|<
name|TableName
argument_list|>
name|tableName
parameter_list|)
block|{
name|CompletableFuture
argument_list|<
name|List
argument_list|<
name|HRegionLocation
argument_list|>
argument_list|>
name|future
init|=
operator|new
name|CompletableFuture
argument_list|<>
argument_list|()
decl_stmt|;
name|addListener
argument_list|(
name|getTableRegionsAndLocations
argument_list|(
name|metaTable
argument_list|,
name|tableName
argument_list|,
literal|true
argument_list|)
argument_list|,
parameter_list|(
name|locations
parameter_list|,
name|err
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|err
operator|!=
literal|null
condition|)
block|{
name|future
operator|.
name|completeExceptionally
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|locations
operator|==
literal|null
operator|||
name|locations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|future
operator|.
name|complete
argument_list|(
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|List
argument_list|<
name|HRegionLocation
argument_list|>
name|regionLocations
init|=
name|locations
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|loc
lambda|->
operator|new
name|HRegionLocation
argument_list|(
name|loc
operator|.
name|getFirst
argument_list|()
argument_list|,
name|loc
operator|.
name|getSecond
argument_list|()
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
name|future
operator|.
name|complete
argument_list|(
name|regionLocations
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|future
return|;
block|}
end_function

begin_comment
comment|/**    * Used to get table regions' info and server.    * @param metaTable    * @param tableName table we're looking for, can be null for getting all regions    * @param excludeOfflinedSplitParents don't return split parents    * @return the list of regioninfos and server. The return value will be wrapped by a    *         {@link CompletableFuture}.    */
end_comment

begin_function
specifier|private
specifier|static
name|CompletableFuture
argument_list|<
name|List
argument_list|<
name|Pair
argument_list|<
name|RegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|>
argument_list|>
name|getTableRegionsAndLocations
parameter_list|(
name|AsyncTable
argument_list|<
name|AdvancedScanResultConsumer
argument_list|>
name|metaTable
parameter_list|,
specifier|final
name|Optional
argument_list|<
name|TableName
argument_list|>
name|tableName
parameter_list|,
specifier|final
name|boolean
name|excludeOfflinedSplitParents
parameter_list|)
block|{
name|CompletableFuture
argument_list|<
name|List
argument_list|<
name|Pair
argument_list|<
name|RegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|>
argument_list|>
name|future
init|=
operator|new
name|CompletableFuture
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|tableName
operator|.
name|filter
argument_list|(
parameter_list|(
lambda|t
argument_list|)
operator|->
name|t
operator|.
name|equals
argument_list|(
name|TableName
operator|.
name|META_TABLE_NAME
argument_list|)
condition|)
operator|.
name|isPresent
argument_list|()
block|)
block|{
name|future
operator|.
name|completeExceptionally
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"This method can't be used to locate meta regions;"
operator|+
literal|" use MetaTableLocator instead"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Make a version of CollectingVisitor that collects RegionInfo and ServerAddress
end_comment

begin_decl_stmt
name|CollectingVisitor
argument_list|<
name|Pair
argument_list|<
name|RegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|>
name|visitor
init|=
operator|new
name|CollectingVisitor
argument_list|<
name|Pair
argument_list|<
name|RegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|private
name|Optional
argument_list|<
name|RegionLocations
argument_list|>
name|current
init|=
literal|null
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|visit
parameter_list|(
name|Result
name|r
parameter_list|)
throws|throws
name|IOException
block|{
name|current
operator|=
name|getRegionLocations
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current
operator|.
name|isPresent
argument_list|()
operator|||
name|current
operator|.
name|get
argument_list|()
operator|.
name|getRegionLocation
argument_list|()
operator|.
name|getRegion
argument_list|()
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No serialized RegionInfo in "
operator|+
name|r
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|RegionInfo
name|hri
init|=
name|current
operator|.
name|get
argument_list|()
operator|.
name|getRegionLocation
argument_list|()
operator|.
name|getRegion
argument_list|()
decl_stmt|;
if|if
condition|(
name|excludeOfflinedSplitParents
operator|&&
name|hri
operator|.
name|isSplitParent
argument_list|()
condition|)
return|return
literal|true
return|;
comment|// Else call super and add this Result to the collection.
return|return
name|super
operator|.
name|visit
argument_list|(
name|r
argument_list|)
return|;
block|}
annotation|@
name|Override
name|void
name|add
parameter_list|(
name|Result
name|r
parameter_list|)
block|{
if|if
condition|(
operator|!
name|current
operator|.
name|isPresent
argument_list|()
condition|)
block|{
return|return;
block|}
for|for
control|(
name|HRegionLocation
name|loc
range|:
name|current
operator|.
name|get
argument_list|()
operator|.
name|getRegionLocations
argument_list|()
control|)
block|{
if|if
condition|(
name|loc
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|results
operator|.
name|add
argument_list|(
operator|new
name|Pair
argument_list|<
name|RegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|(
name|loc
operator|.
name|getRegion
argument_list|()
argument_list|,
name|loc
operator|.
name|getServerName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|addListener
argument_list|(
name|scanMeta
argument_list|(
name|metaTable
argument_list|,
name|tableName
argument_list|,
name|QueryType
operator|.
name|REGION
argument_list|,
name|visitor
argument_list|)
argument_list|,
parameter_list|(
name|v
parameter_list|,
name|error
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|error
operator|!=
literal|null
condition|)
block|{
name|future
operator|.
name|completeExceptionally
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
name|future
operator|.
name|complete
argument_list|(
name|visitor
operator|.
name|getResults
argument_list|()
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|future
return|;
end_return

begin_comment
unit|}
comment|/**    * Performs a scan of META table for given table.    * @param metaTable    * @param tableName table withing we scan    * @param type scanned part of meta    * @param visitor Visitor invoked against each row    */
end_comment

begin_function
unit|private
specifier|static
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|scanMeta
parameter_list|(
name|AsyncTable
argument_list|<
name|AdvancedScanResultConsumer
argument_list|>
name|metaTable
parameter_list|,
name|Optional
argument_list|<
name|TableName
argument_list|>
name|tableName
parameter_list|,
name|QueryType
name|type
parameter_list|,
specifier|final
name|Visitor
name|visitor
parameter_list|)
block|{
return|return
name|scanMeta
argument_list|(
name|metaTable
argument_list|,
name|getTableStartRowForMeta
argument_list|(
name|tableName
argument_list|,
name|type
argument_list|)
argument_list|,
name|getTableStopRowForMeta
argument_list|(
name|tableName
argument_list|,
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
name|visitor
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Performs a scan of META table for given table.    * @param metaTable    * @param startRow Where to start the scan    * @param stopRow Where to stop the scan    * @param type scanned part of meta    * @param maxRows maximum rows to return    * @param visitor Visitor invoked against each row    */
end_comment

begin_function
specifier|private
specifier|static
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|scanMeta
parameter_list|(
name|AsyncTable
argument_list|<
name|AdvancedScanResultConsumer
argument_list|>
name|metaTable
parameter_list|,
name|Optional
argument_list|<
name|byte
index|[]
argument_list|>
name|startRow
parameter_list|,
name|Optional
argument_list|<
name|byte
index|[]
argument_list|>
name|stopRow
parameter_list|,
name|QueryType
name|type
parameter_list|,
name|int
name|maxRows
parameter_list|,
specifier|final
name|Visitor
name|visitor
parameter_list|)
block|{
name|int
name|rowUpperLimit
init|=
name|maxRows
operator|>
literal|0
condition|?
name|maxRows
else|:
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
name|Scan
name|scan
init|=
name|getMetaScan
argument_list|(
name|metaTable
argument_list|,
name|rowUpperLimit
argument_list|)
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|family
range|:
name|type
operator|.
name|getFamilies
argument_list|()
control|)
block|{
name|scan
operator|.
name|addFamily
argument_list|(
name|family
argument_list|)
expr_stmt|;
block|}
name|startRow
operator|.
name|ifPresent
argument_list|(
name|scan
operator|::
name|withStartRow
argument_list|)
expr_stmt|;
name|stopRow
operator|.
name|ifPresent
argument_list|(
name|scan
operator|::
name|withStopRow
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Scanning META"
operator|+
literal|" starting at row="
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|scan
operator|.
name|getStartRow
argument_list|()
argument_list|)
operator|+
literal|" stopping at row="
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|scan
operator|.
name|getStopRow
argument_list|()
argument_list|)
operator|+
literal|" for max="
operator|+
name|rowUpperLimit
operator|+
literal|" with caching="
operator|+
name|scan
operator|.
name|getCaching
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|future
init|=
operator|new
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
argument_list|()
decl_stmt|;
name|metaTable
operator|.
name|scan
argument_list|(
name|scan
argument_list|,
operator|new
name|MetaTableScanResultConsumer
argument_list|(
name|rowUpperLimit
argument_list|,
name|visitor
argument_list|,
name|future
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|future
return|;
block|}
end_function

begin_class
specifier|private
specifier|static
specifier|final
class|class
name|MetaTableScanResultConsumer
implements|implements
name|AdvancedScanResultConsumer
block|{
specifier|private
name|int
name|currentRowCount
decl_stmt|;
specifier|private
specifier|final
name|int
name|rowUpperLimit
decl_stmt|;
specifier|private
specifier|final
name|Visitor
name|visitor
decl_stmt|;
specifier|private
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|future
decl_stmt|;
name|MetaTableScanResultConsumer
parameter_list|(
name|int
name|rowUpperLimit
parameter_list|,
name|Visitor
name|visitor
parameter_list|,
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|future
parameter_list|)
block|{
name|this
operator|.
name|rowUpperLimit
operator|=
name|rowUpperLimit
expr_stmt|;
name|this
operator|.
name|visitor
operator|=
name|visitor
expr_stmt|;
name|this
operator|.
name|future
operator|=
name|future
expr_stmt|;
name|this
operator|.
name|currentRowCount
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onError
parameter_list|(
name|Throwable
name|error
parameter_list|)
block|{
name|future
operator|.
name|completeExceptionally
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"NP_NONNULL_PARAM_VIOLATION"
argument_list|,
name|justification
operator|=
literal|"https://github.com/findbugsproject/findbugs/issues/79"
argument_list|)
specifier|public
name|void
name|onComplete
parameter_list|()
block|{
name|future
operator|.
name|complete
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onNext
parameter_list|(
name|Result
index|[]
name|results
parameter_list|,
name|ScanController
name|controller
parameter_list|)
block|{
name|boolean
name|terminateScan
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Result
name|result
range|:
name|results
control|)
block|{
try|try
block|{
if|if
condition|(
operator|!
name|visitor
operator|.
name|visit
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|terminateScan
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|future
operator|.
name|completeExceptionally
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|terminateScan
operator|=
literal|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|++
name|currentRowCount
operator|>=
name|rowUpperLimit
condition|)
block|{
name|terminateScan
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|terminateScan
condition|)
block|{
name|controller
operator|.
name|terminate
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

begin_function
specifier|private
specifier|static
name|Scan
name|getMetaScan
parameter_list|(
name|AsyncTable
argument_list|<
name|?
argument_list|>
name|metaTable
parameter_list|,
name|int
name|rowUpperLimit
parameter_list|)
block|{
name|Scan
name|scan
init|=
operator|new
name|Scan
argument_list|()
decl_stmt|;
name|int
name|scannerCaching
init|=
name|metaTable
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_META_SCANNER_CACHING
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_META_SCANNER_CACHING
argument_list|)
decl_stmt|;
if|if
condition|(
name|metaTable
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getBoolean
argument_list|(
name|HConstants
operator|.
name|USE_META_REPLICAS
argument_list|,
name|HConstants
operator|.
name|DEFAULT_USE_META_REPLICAS
argument_list|)
condition|)
block|{
name|scan
operator|.
name|setConsistency
argument_list|(
name|Consistency
operator|.
name|TIMELINE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rowUpperLimit
operator|<=
name|scannerCaching
condition|)
block|{
name|scan
operator|.
name|setLimit
argument_list|(
name|rowUpperLimit
argument_list|)
expr_stmt|;
block|}
name|int
name|rows
init|=
name|Math
operator|.
name|min
argument_list|(
name|rowUpperLimit
argument_list|,
name|scannerCaching
argument_list|)
decl_stmt|;
name|scan
operator|.
name|setCaching
argument_list|(
name|rows
argument_list|)
expr_stmt|;
return|return
name|scan
return|;
block|}
end_function

begin_comment
comment|/**    * Returns an HRegionLocationList extracted from the result.    * @return an HRegionLocationList containing all locations for the region range or null if we    *         can't deserialize the result.    */
end_comment

begin_function
specifier|private
specifier|static
name|Optional
argument_list|<
name|RegionLocations
argument_list|>
name|getRegionLocations
parameter_list|(
specifier|final
name|Result
name|r
parameter_list|)
block|{
if|if
condition|(
name|r
operator|==
literal|null
condition|)
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
name|Optional
argument_list|<
name|RegionInfo
argument_list|>
name|regionInfo
init|=
name|getHRegionInfo
argument_list|(
name|r
argument_list|,
name|getRegionInfoColumn
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|regionInfo
operator|.
name|isPresent
argument_list|()
condition|)
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
name|List
argument_list|<
name|HRegionLocation
argument_list|>
name|locations
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionLocation
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|familyMap
init|=
name|r
operator|.
name|getNoVersionMap
argument_list|()
decl_stmt|;
name|locations
operator|.
name|add
argument_list|(
name|getRegionLocation
argument_list|(
name|r
argument_list|,
name|regionInfo
operator|.
name|get
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|infoMap
init|=
name|familyMap
operator|.
name|get
argument_list|(
name|getCatalogFamily
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|infoMap
operator|==
literal|null
condition|)
return|return
name|Optional
operator|.
name|of
argument_list|(
operator|new
name|RegionLocations
argument_list|(
name|locations
argument_list|)
argument_list|)
return|;
comment|// iterate until all serverName columns are seen
name|int
name|replicaId
init|=
literal|0
decl_stmt|;
name|byte
index|[]
name|serverColumn
init|=
name|getServerColumn
argument_list|(
name|replicaId
argument_list|)
decl_stmt|;
name|SortedMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|serverMap
init|=
literal|null
decl_stmt|;
name|serverMap
operator|=
name|infoMap
operator|.
name|tailMap
argument_list|(
name|serverColumn
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|serverMap
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|Optional
operator|.
name|of
argument_list|(
operator|new
name|RegionLocations
argument_list|(
name|locations
argument_list|)
argument_list|)
return|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|entry
range|:
name|serverMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|replicaId
operator|=
name|parseReplicaIdFromServerColumn
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|replicaId
operator|<
literal|0
condition|)
block|{
break|break;
block|}
name|HRegionLocation
name|location
init|=
name|getRegionLocation
argument_list|(
name|r
argument_list|,
name|regionInfo
operator|.
name|get
argument_list|()
argument_list|,
name|replicaId
argument_list|)
decl_stmt|;
comment|// In case the region replica is newly created, it's location might be null. We usually do not
comment|// have HRL's in RegionLocations object with null ServerName. They are handled as null HRLs.
if|if
condition|(
name|location
operator|==
literal|null
operator|||
name|location
operator|.
name|getServerName
argument_list|()
operator|==
literal|null
condition|)
block|{
name|locations
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|locations
operator|.
name|add
argument_list|(
name|location
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Optional
operator|.
name|of
argument_list|(
operator|new
name|RegionLocations
argument_list|(
name|locations
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns the HRegionLocation parsed from the given meta row Result    * for the given regionInfo and replicaId. The regionInfo can be the default region info    * for the replica.    * @param r the meta row result    * @param regionInfo RegionInfo for default replica    * @param replicaId the replicaId for the HRegionLocation    * @return HRegionLocation parsed from the given meta row Result for the given replicaId    */
end_comment

begin_function
specifier|private
specifier|static
name|HRegionLocation
name|getRegionLocation
parameter_list|(
specifier|final
name|Result
name|r
parameter_list|,
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|,
specifier|final
name|int
name|replicaId
parameter_list|)
block|{
name|Optional
argument_list|<
name|ServerName
argument_list|>
name|serverName
init|=
name|getServerName
argument_list|(
name|r
argument_list|,
name|replicaId
argument_list|)
decl_stmt|;
name|long
name|seqNum
init|=
name|getSeqNumDuringOpen
argument_list|(
name|r
argument_list|,
name|replicaId
argument_list|)
decl_stmt|;
name|RegionInfo
name|replicaInfo
init|=
name|RegionReplicaUtil
operator|.
name|getRegionInfoForReplica
argument_list|(
name|regionInfo
argument_list|,
name|replicaId
argument_list|)
decl_stmt|;
return|return
operator|new
name|HRegionLocation
argument_list|(
name|replicaInfo
argument_list|,
name|serverName
operator|.
name|orElse
argument_list|(
literal|null
argument_list|)
argument_list|,
name|seqNum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns a {@link ServerName} from catalog table {@link Result}.    * @param r Result to pull from    * @return A ServerName instance.    */
end_comment

begin_function
specifier|private
specifier|static
name|Optional
argument_list|<
name|ServerName
argument_list|>
name|getServerName
parameter_list|(
specifier|final
name|Result
name|r
parameter_list|,
specifier|final
name|int
name|replicaId
parameter_list|)
block|{
name|byte
index|[]
name|serverColumn
init|=
name|getServerColumn
argument_list|(
name|replicaId
argument_list|)
decl_stmt|;
name|Cell
name|cell
init|=
name|r
operator|.
name|getColumnLatestCell
argument_list|(
name|getCatalogFamily
argument_list|()
argument_list|,
name|serverColumn
argument_list|)
decl_stmt|;
if|if
condition|(
name|cell
operator|==
literal|null
operator|||
name|cell
operator|.
name|getValueLength
argument_list|()
operator|==
literal|0
condition|)
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
name|String
name|hostAndPort
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|cell
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getValueLength
argument_list|()
argument_list|)
decl_stmt|;
name|byte
index|[]
name|startcodeColumn
init|=
name|getStartCodeColumn
argument_list|(
name|replicaId
argument_list|)
decl_stmt|;
name|cell
operator|=
name|r
operator|.
name|getColumnLatestCell
argument_list|(
name|getCatalogFamily
argument_list|()
argument_list|,
name|startcodeColumn
argument_list|)
expr_stmt|;
if|if
condition|(
name|cell
operator|==
literal|null
operator|||
name|cell
operator|.
name|getValueLength
argument_list|()
operator|==
literal|0
condition|)
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
try|try
block|{
return|return
name|Optional
operator|.
name|of
argument_list|(
name|ServerName
operator|.
name|valueOf
argument_list|(
name|hostAndPort
argument_list|,
name|Bytes
operator|.
name|toLong
argument_list|(
name|cell
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getValueLength
argument_list|()
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Ignoring invalid region for server "
operator|+
name|hostAndPort
operator|+
literal|"; cell="
operator|+
name|cell
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
block|}
end_function

begin_comment
comment|/**    * The latest seqnum that the server writing to meta observed when opening the region.    * E.g. the seqNum when the result of {@link #getServerName(Result, int)} was written.    * @param r Result to pull the seqNum from    * @return SeqNum, or HConstants.NO_SEQNUM if there's no value written.    */
end_comment

begin_function
specifier|private
specifier|static
name|long
name|getSeqNumDuringOpen
parameter_list|(
specifier|final
name|Result
name|r
parameter_list|,
specifier|final
name|int
name|replicaId
parameter_list|)
block|{
name|Cell
name|cell
init|=
name|r
operator|.
name|getColumnLatestCell
argument_list|(
name|getCatalogFamily
argument_list|()
argument_list|,
name|getSeqNumColumn
argument_list|(
name|replicaId
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cell
operator|==
literal|null
operator|||
name|cell
operator|.
name|getValueLength
argument_list|()
operator|==
literal|0
condition|)
return|return
name|HConstants
operator|.
name|NO_SEQNUM
return|;
return|return
name|Bytes
operator|.
name|toLong
argument_list|(
name|cell
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getValueLength
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * @param tableName table we're working with    * @return start row for scanning META according to query type    */
end_comment

begin_function
specifier|private
specifier|static
name|Optional
argument_list|<
name|byte
index|[]
argument_list|>
name|getTableStartRowForMeta
parameter_list|(
name|Optional
argument_list|<
name|TableName
argument_list|>
name|tableName
parameter_list|,
name|QueryType
name|type
parameter_list|)
block|{
return|return
name|tableName
operator|.
name|map
argument_list|(
parameter_list|(
name|table
parameter_list|)
lambda|->
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|REGION
case|:
case|case
name|REPLICATION
case|:
name|byte
index|[]
name|startRow
init|=
operator|new
name|byte
index|[
name|table
operator|.
name|getName
argument_list|()
operator|.
name|length
operator|+
literal|2
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|table
operator|.
name|getName
argument_list|()
argument_list|,
literal|0
argument_list|,
name|startRow
argument_list|,
literal|0
argument_list|,
name|table
operator|.
name|getName
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|startRow
index|[
name|startRow
operator|.
name|length
operator|-
literal|2
index|]
operator|=
name|HConstants
operator|.
name|DELIMITER
expr_stmt|;
name|startRow
index|[
name|startRow
operator|.
name|length
operator|-
literal|1
index|]
operator|=
name|HConstants
operator|.
name|DELIMITER
expr_stmt|;
return|return
name|startRow
return|;
case|case
name|ALL
case|:
case|case
name|TABLE
case|:
default|default:
return|return
name|table
operator|.
name|getName
argument_list|()
return|;
block|}
block|}
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * @param tableName table we're working with    * @return stop row for scanning META according to query type    */
end_comment

begin_function
specifier|private
specifier|static
name|Optional
argument_list|<
name|byte
index|[]
argument_list|>
name|getTableStopRowForMeta
parameter_list|(
name|Optional
argument_list|<
name|TableName
argument_list|>
name|tableName
parameter_list|,
name|QueryType
name|type
parameter_list|)
block|{
return|return
name|tableName
operator|.
name|map
argument_list|(
parameter_list|(
name|table
parameter_list|)
lambda|->
block|{
specifier|final
name|byte
index|[]
name|stopRow
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|REGION
case|:
case|case
name|REPLICATION
case|:
name|stopRow
operator|=
operator|new
name|byte
index|[
name|table
operator|.
name|getName
argument_list|()
operator|.
name|length
operator|+
literal|3
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|table
operator|.
name|getName
argument_list|()
argument_list|,
literal|0
argument_list|,
name|stopRow
argument_list|,
literal|0
argument_list|,
name|table
operator|.
name|getName
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|stopRow
index|[
name|stopRow
operator|.
name|length
operator|-
literal|3
index|]
operator|=
literal|' '
expr_stmt|;
name|stopRow
index|[
name|stopRow
operator|.
name|length
operator|-
literal|2
index|]
operator|=
name|HConstants
operator|.
name|DELIMITER
expr_stmt|;
name|stopRow
index|[
name|stopRow
operator|.
name|length
operator|-
literal|1
index|]
operator|=
name|HConstants
operator|.
name|DELIMITER
expr_stmt|;
break|break;
case|case
name|ALL
case|:
case|case
name|TABLE
case|:
default|default:
name|stopRow
operator|=
operator|new
name|byte
index|[
name|table
operator|.
name|getName
argument_list|()
operator|.
name|length
operator|+
literal|1
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|table
operator|.
name|getName
argument_list|()
argument_list|,
literal|0
argument_list|,
name|stopRow
argument_list|,
literal|0
argument_list|,
name|table
operator|.
name|getName
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|stopRow
index|[
name|stopRow
operator|.
name|length
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
break|break;
block|}
return|return
name|stopRow
return|;
block|}
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns the RegionInfo object from the column {@link HConstants#CATALOG_FAMILY} and    *<code>qualifier</code> of the catalog table result.    * @param r a Result object from the catalog table scan    * @param qualifier Column family qualifier    * @return An RegionInfo instance.    */
end_comment

begin_function
specifier|private
specifier|static
name|Optional
argument_list|<
name|RegionInfo
argument_list|>
name|getHRegionInfo
parameter_list|(
specifier|final
name|Result
name|r
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
name|Cell
name|cell
init|=
name|r
operator|.
name|getColumnLatestCell
argument_list|(
name|getCatalogFamily
argument_list|()
argument_list|,
name|qualifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|cell
operator|==
literal|null
condition|)
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
return|return
name|Optional
operator|.
name|ofNullable
argument_list|(
name|RegionInfo
operator|.
name|parseFromOrNull
argument_list|(
name|cell
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getValueLength
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns the column family used for meta columns.    * @return HConstants.CATALOG_FAMILY.    */
end_comment

begin_function
specifier|private
specifier|static
name|byte
index|[]
name|getCatalogFamily
parameter_list|()
block|{
return|return
name|HConstants
operator|.
name|CATALOG_FAMILY
return|;
block|}
end_function

begin_comment
comment|/**    * Returns the column family used for table columns.    * @return HConstants.TABLE_FAMILY.    */
end_comment

begin_function
specifier|private
specifier|static
name|byte
index|[]
name|getTableFamily
parameter_list|()
block|{
return|return
name|HConstants
operator|.
name|TABLE_FAMILY
return|;
block|}
end_function

begin_comment
comment|/**    * Returns the column qualifier for serialized region info    * @return HConstants.REGIONINFO_QUALIFIER    */
end_comment

begin_function
specifier|private
specifier|static
name|byte
index|[]
name|getRegionInfoColumn
parameter_list|()
block|{
return|return
name|HConstants
operator|.
name|REGIONINFO_QUALIFIER
return|;
block|}
end_function

begin_comment
comment|/**    * Returns the column qualifier for serialized table state    * @return HConstants.TABLE_STATE_QUALIFIER    */
end_comment

begin_function
specifier|private
specifier|static
name|byte
index|[]
name|getStateColumn
parameter_list|()
block|{
return|return
name|HConstants
operator|.
name|TABLE_STATE_QUALIFIER
return|;
block|}
end_function

begin_comment
comment|/**    * Returns the column qualifier for server column for replicaId    * @param replicaId the replicaId of the region    * @return a byte[] for server column qualifier    */
end_comment

begin_function
specifier|private
specifier|static
name|byte
index|[]
name|getServerColumn
parameter_list|(
name|int
name|replicaId
parameter_list|)
block|{
return|return
name|replicaId
operator|==
literal|0
condition|?
name|HConstants
operator|.
name|SERVER_QUALIFIER
else|:
name|Bytes
operator|.
name|toBytes
argument_list|(
name|HConstants
operator|.
name|SERVER_QUALIFIER_STR
operator|+
name|META_REPLICA_ID_DELIMITER
operator|+
name|String
operator|.
name|format
argument_list|(
name|RegionInfo
operator|.
name|REPLICA_ID_FORMAT
argument_list|,
name|replicaId
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns the column qualifier for server start code column for replicaId    * @param replicaId the replicaId of the region    * @return a byte[] for server start code column qualifier    */
end_comment

begin_function
specifier|private
specifier|static
name|byte
index|[]
name|getStartCodeColumn
parameter_list|(
name|int
name|replicaId
parameter_list|)
block|{
return|return
name|replicaId
operator|==
literal|0
condition|?
name|HConstants
operator|.
name|STARTCODE_QUALIFIER
else|:
name|Bytes
operator|.
name|toBytes
argument_list|(
name|HConstants
operator|.
name|STARTCODE_QUALIFIER_STR
operator|+
name|META_REPLICA_ID_DELIMITER
operator|+
name|String
operator|.
name|format
argument_list|(
name|RegionInfo
operator|.
name|REPLICA_ID_FORMAT
argument_list|,
name|replicaId
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Returns the column qualifier for seqNum column for replicaId    * @param replicaId the replicaId of the region    * @return a byte[] for seqNum column qualifier    */
end_comment

begin_function
specifier|private
specifier|static
name|byte
index|[]
name|getSeqNumColumn
parameter_list|(
name|int
name|replicaId
parameter_list|)
block|{
return|return
name|replicaId
operator|==
literal|0
condition|?
name|HConstants
operator|.
name|SEQNUM_QUALIFIER
else|:
name|Bytes
operator|.
name|toBytes
argument_list|(
name|HConstants
operator|.
name|SEQNUM_QUALIFIER_STR
operator|+
name|META_REPLICA_ID_DELIMITER
operator|+
name|String
operator|.
name|format
argument_list|(
name|RegionInfo
operator|.
name|REPLICA_ID_FORMAT
argument_list|,
name|replicaId
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**    * Parses the replicaId from the server column qualifier. See top of the class javadoc    * for the actual meta layout    * @param serverColumn the column qualifier    * @return an int for the replicaId    */
end_comment

begin_function
specifier|private
specifier|static
name|int
name|parseReplicaIdFromServerColumn
parameter_list|(
name|byte
index|[]
name|serverColumn
parameter_list|)
block|{
name|String
name|serverStr
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|serverColumn
argument_list|)
decl_stmt|;
name|Matcher
name|matcher
init|=
name|SERVER_COLUMN_PATTERN
operator|.
name|matcher
argument_list|(
name|serverStr
argument_list|)
decl_stmt|;
if|if
condition|(
name|matcher
operator|.
name|matches
argument_list|()
operator|&&
name|matcher
operator|.
name|groupCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|String
name|group
init|=
name|matcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|group
operator|!=
literal|null
operator|&&
name|group
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|group
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|16
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

unit|}
end_unit

