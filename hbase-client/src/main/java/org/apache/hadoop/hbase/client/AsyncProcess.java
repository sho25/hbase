begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|DoNotRetryIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|RejectedExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_comment
comment|/**  * This class  allows a continuous flow of requests. It's written to be compatible with a  * synchronous caller such as HTable.  *<p>  * The caller sends a buffer of operation, by calling submit. This class extract from this list  * the operations it can send, i.e. the operations that are on region that are not considered  * as busy. The process is asynchronous, i.e. it returns immediately when if has finished to  * iterate on the list. If, and only if, the maximum number of current task is reached, the call  * to submit will block.  *</p>  *<p>  * The class manages internally the retries.  *</p>  *<p>  * The class includes an error marker: it allows to know if an operation has failed or not, and  * to get the exception details, i.e. the full list of throwables for each attempt. This marker  * is here to help the backward compatibility in HTable. In most (new) cases, it should be  * managed by the callbacks.  *</p>  *<p>  * A callback is available, in order to:<list>  *<li>Get the result of the operation (failure or success)</li>  *<li>When an operation fails but could be retried, allows or not to retry</li>  *<li>When an operation fails for good (can't be retried or already retried the maximum number  * time), register the error or not.  *</list>  *<p>  * This class is not thread safe externally; only one thread should submit operations at a time.  * Internally, the class is thread safe enough to manage simultaneously new submission and results  * arising from older operations.  *</p>  *<p>  * Internally, this class works with {@link Row}, this mean it could be theoretically used for  * gets as well.  *</p>  */
end_comment

begin_class
class|class
name|AsyncProcess
parameter_list|<
name|CResult
parameter_list|>
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|AsyncProcess
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|protected
specifier|final
name|HConnection
name|hConnection
decl_stmt|;
specifier|protected
specifier|final
name|byte
index|[]
name|tableName
decl_stmt|;
specifier|protected
specifier|final
name|ExecutorService
name|pool
decl_stmt|;
specifier|protected
specifier|final
name|AsyncProcessCallback
argument_list|<
name|CResult
argument_list|>
name|callback
decl_stmt|;
specifier|protected
specifier|final
name|BatchErrors
name|errors
init|=
operator|new
name|BatchErrors
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|BatchErrors
name|retriedErrors
init|=
operator|new
name|BatchErrors
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|AtomicBoolean
name|hasError
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|protected
specifier|final
name|AtomicLong
name|tasksSent
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|protected
specifier|final
name|AtomicLong
name|tasksDone
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|protected
specifier|final
name|ConcurrentMap
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
name|taskCounterPerRegion
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|AtomicInteger
argument_list|>
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|int
name|maxTotalConcurrentTasks
decl_stmt|;
specifier|protected
specifier|final
name|int
name|maxConcurrentTasksPerRegion
decl_stmt|;
specifier|protected
specifier|final
name|long
name|pause
decl_stmt|;
specifier|protected
name|int
name|numTries
decl_stmt|;
specifier|protected
specifier|final
name|boolean
name|useServerTrackerForRetries
decl_stmt|;
specifier|protected
name|int
name|serverTrackerTimeout
decl_stmt|;
comment|/**    * This interface allows to keep the interface of the previous synchronous interface, that uses    * an array of object to return the result.    *<p/>    * This interface allows the caller to specify the behavior on errors:<list>    *<li>If we have not yet reach the maximum number of retries, the user can nevertheless    * specify if this specific operation should be retried or not.    *</li>    *<li>If an operation fails (i.e. is not retried or fails after all retries), the user can    * specify is we should mark this AsyncProcess as in error or not.    *</li>    *</list>    */
specifier|static
interface|interface
name|AsyncProcessCallback
parameter_list|<
name|CResult
parameter_list|>
block|{
comment|/**      * Called on success. originalIndex holds the index in the action list.      */
name|void
name|success
parameter_list|(
name|int
name|originalIndex
parameter_list|,
name|byte
index|[]
name|region
parameter_list|,
name|Row
name|row
parameter_list|,
name|CResult
name|result
parameter_list|)
function_decl|;
comment|/**      * called on failure, if we don't retry (i.e. called once per failed operation).      *      * @return true if we should store the error and tag this async process as being in error.      *         false if the failure of this operation can be safely ignored, and does not require      *         the current process to be stopped without proceeding with the other operations in      *         the queue.      */
name|boolean
name|failure
parameter_list|(
name|int
name|originalIndex
parameter_list|,
name|byte
index|[]
name|region
parameter_list|,
name|Row
name|row
parameter_list|,
name|Throwable
name|t
parameter_list|)
function_decl|;
comment|/**      * Called on a failure we plan to retry. This allows the user to stop retrying. Will be      * called multiple times for a single action if it fails multiple times.      *      * @return false if we should retry, true otherwise.      */
name|boolean
name|retriableFailure
parameter_list|(
name|int
name|originalIndex
parameter_list|,
name|Row
name|row
parameter_list|,
name|byte
index|[]
name|region
parameter_list|,
name|Throwable
name|exception
parameter_list|)
function_decl|;
block|}
specifier|private
specifier|static
class|class
name|BatchErrors
block|{
specifier|private
name|List
argument_list|<
name|Throwable
argument_list|>
name|throwables
init|=
operator|new
name|ArrayList
argument_list|<
name|Throwable
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Row
argument_list|>
name|actions
init|=
operator|new
name|ArrayList
argument_list|<
name|Row
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|addresses
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
name|void
name|add
parameter_list|(
name|Throwable
name|ex
parameter_list|,
name|Row
name|row
parameter_list|,
name|HRegionLocation
name|location
parameter_list|)
block|{
name|throwables
operator|.
name|add
argument_list|(
name|ex
argument_list|)
expr_stmt|;
name|actions
operator|.
name|add
argument_list|(
name|row
argument_list|)
expr_stmt|;
name|addresses
operator|.
name|add
argument_list|(
name|location
operator|!=
literal|null
condition|?
name|location
operator|.
name|getHostnamePort
argument_list|()
else|:
literal|"null location"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|RetriesExhaustedWithDetailsException
name|makeException
parameter_list|()
block|{
return|return
operator|new
name|RetriesExhaustedWithDetailsException
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|Throwable
argument_list|>
argument_list|(
name|throwables
argument_list|)
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|Row
argument_list|>
argument_list|(
name|actions
argument_list|)
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|addresses
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|throwables
operator|.
name|clear
argument_list|()
expr_stmt|;
name|actions
operator|.
name|clear
argument_list|()
expr_stmt|;
name|addresses
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|AsyncProcess
parameter_list|(
name|HConnection
name|hc
parameter_list|,
name|byte
index|[]
name|tableName
parameter_list|,
name|ExecutorService
name|pool
parameter_list|,
name|AsyncProcessCallback
argument_list|<
name|CResult
argument_list|>
name|callback
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|hConnection
operator|=
name|hc
expr_stmt|;
name|this
operator|.
name|tableName
operator|=
name|tableName
expr_stmt|;
name|this
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|this
operator|.
name|callback
operator|=
name|callback
expr_stmt|;
name|this
operator|.
name|pause
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_PAUSE
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_PAUSE
argument_list|)
expr_stmt|;
name|this
operator|.
name|numTries
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_RETRIES_NUMBER
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_RETRIES_NUMBER
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxTotalConcurrentTasks
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.client.max.total.tasks"
argument_list|,
literal|200
argument_list|)
expr_stmt|;
comment|// With one, we ensure that the ordering of the queries is respected: we don't start
comment|//  a set of operations on a region before the previous one is done. As well, this limits
comment|//  the pressure we put on the region server.
name|this
operator|.
name|maxConcurrentTasksPerRegion
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.client.max.perregion.tasks"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|this
operator|.
name|useServerTrackerForRetries
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|HConnectionManager
operator|.
name|RETRIES_BY_SERVER_KEY
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|useServerTrackerForRetries
condition|)
block|{
comment|// Server tracker allows us to do faster, and yet useful (hopefully), retries.
comment|// However, if we are too useful, we might fail very quickly due to retry count limit.
comment|// To avoid this, we are going to cheat for now (see HBASE-7659), and calculate maximum
comment|// retry time if normal retries were used. Then we will retry until this time runs out.
comment|// If we keep hitting one server, the net effect will be the incremental backoff, and
comment|// essentially the same number of retries as planned. If we have to do faster retries,
comment|// we will do more retries in aggregate, but the user will be none the wiser.
name|this
operator|.
name|serverTrackerTimeout
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|this
operator|.
name|numTries
condition|;
operator|++
name|i
control|)
block|{
name|serverTrackerTimeout
operator|+=
name|ConnectionUtils
operator|.
name|getPauseTime
argument_list|(
name|this
operator|.
name|pause
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Extract from the rows list what we can submit. The rows we can not submit are kept in the    * list.    *    * @param rows - the submitted row. Modified by the method: we remove the rows we took.    * @param atLeastOne true if we should submit at least a subset.    */
specifier|public
name|void
name|submit
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|Row
argument_list|>
name|rows
parameter_list|,
name|boolean
name|atLeastOne
parameter_list|)
throws|throws
name|InterruptedIOException
block|{
if|if
condition|(
name|rows
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|Map
argument_list|<
name|HRegionLocation
argument_list|,
name|MultiAction
argument_list|<
name|Row
argument_list|>
argument_list|>
name|actionsByServer
init|=
operator|new
name|HashMap
argument_list|<
name|HRegionLocation
argument_list|,
name|MultiAction
argument_list|<
name|Row
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Action
argument_list|<
name|Row
argument_list|>
argument_list|>
name|retainedActions
init|=
operator|new
name|ArrayList
argument_list|<
name|Action
argument_list|<
name|Row
argument_list|>
argument_list|>
argument_list|(
name|rows
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
do|do
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
name|regionIncluded
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
argument_list|()
decl_stmt|;
name|long
name|currentTaskNumber
init|=
name|waitForMaximumCurrentTasks
argument_list|(
name|maxTotalConcurrentTasks
argument_list|)
decl_stmt|;
name|int
name|posInList
init|=
operator|-
literal|1
decl_stmt|;
name|Iterator
argument_list|<
name|?
extends|extends
name|Row
argument_list|>
name|it
init|=
name|rows
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Row
name|r
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|HRegionLocation
name|loc
init|=
name|findDestLocation
argument_list|(
name|r
argument_list|,
literal|1
argument_list|,
name|posInList
argument_list|,
literal|false
argument_list|,
name|regionIncluded
argument_list|)
decl_stmt|;
if|if
condition|(
name|loc
operator|!=
literal|null
condition|)
block|{
comment|// loc is null if the dest is too busy or there is an error
name|Action
argument_list|<
name|Row
argument_list|>
name|action
init|=
operator|new
name|Action
argument_list|<
name|Row
argument_list|>
argument_list|(
name|r
argument_list|,
operator|++
name|posInList
argument_list|)
decl_stmt|;
name|retainedActions
operator|.
name|add
argument_list|(
name|action
argument_list|)
expr_stmt|;
name|addAction
argument_list|(
name|loc
argument_list|,
name|action
argument_list|,
name|actionsByServer
argument_list|)
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|retainedActions
operator|.
name|isEmpty
argument_list|()
operator|&&
name|atLeastOne
operator|&&
operator|!
name|hasError
argument_list|()
condition|)
block|{
name|waitForNextTaskDone
argument_list|(
name|currentTaskNumber
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|retainedActions
operator|.
name|isEmpty
argument_list|()
operator|&&
name|atLeastOne
operator|&&
operator|!
name|hasError
argument_list|()
condition|)
do|;
name|HConnectionManager
operator|.
name|ServerErrorTracker
name|errorsByServer
init|=
name|createServerErrorTracker
argument_list|()
decl_stmt|;
name|sendMultiAction
argument_list|(
name|retainedActions
argument_list|,
name|actionsByServer
argument_list|,
literal|1
argument_list|,
name|errorsByServer
argument_list|)
expr_stmt|;
block|}
comment|/**    * Group the actions per region server.    *    * @param loc - the destination. Must not be null.    * @param action - the action to add to the multiaction    * @param actionsByServer the multiaction per server    */
specifier|private
name|void
name|addAction
parameter_list|(
name|HRegionLocation
name|loc
parameter_list|,
name|Action
argument_list|<
name|Row
argument_list|>
name|action
parameter_list|,
name|Map
argument_list|<
name|HRegionLocation
argument_list|,
name|MultiAction
argument_list|<
name|Row
argument_list|>
argument_list|>
name|actionsByServer
parameter_list|)
block|{
specifier|final
name|byte
index|[]
name|regionName
init|=
name|loc
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
decl_stmt|;
name|MultiAction
argument_list|<
name|Row
argument_list|>
name|multiAction
init|=
name|actionsByServer
operator|.
name|get
argument_list|(
name|loc
argument_list|)
decl_stmt|;
if|if
condition|(
name|multiAction
operator|==
literal|null
condition|)
block|{
name|multiAction
operator|=
operator|new
name|MultiAction
argument_list|<
name|Row
argument_list|>
argument_list|()
expr_stmt|;
name|actionsByServer
operator|.
name|put
argument_list|(
name|loc
argument_list|,
name|multiAction
argument_list|)
expr_stmt|;
block|}
name|multiAction
operator|.
name|add
argument_list|(
name|regionName
argument_list|,
name|action
argument_list|)
expr_stmt|;
block|}
comment|/**    * Find the destination, if this destination is not considered as busy.    *    * @param row          the row    * @param numAttempt   the num attempt    * @param posInList    the position in the list    * @param force        if we must submit whatever the server load    * @param regionStatus the    * @return null if we should not submit, the destination otherwise.    */
specifier|private
name|HRegionLocation
name|findDestLocation
parameter_list|(
name|Row
name|row
parameter_list|,
name|int
name|numAttempt
parameter_list|,
name|int
name|posInList
parameter_list|,
name|boolean
name|force
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
name|regionStatus
parameter_list|)
block|{
name|HRegionLocation
name|loc
init|=
literal|null
decl_stmt|;
name|IOException
name|locationException
init|=
literal|null
decl_stmt|;
try|try
block|{
name|loc
operator|=
name|hConnection
operator|.
name|locateRegion
argument_list|(
name|this
operator|.
name|tableName
argument_list|,
name|row
operator|.
name|getRow
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|==
literal|null
condition|)
block|{
name|locationException
operator|=
operator|new
name|IOException
argument_list|(
literal|"No location found, aborting submit for"
operator|+
literal|" tableName="
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
operator|+
literal|" rowkey="
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|row
operator|.
name|getRow
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|locationException
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
name|locationException
operator|!=
literal|null
condition|)
block|{
comment|// There are multiple retries in locateRegion already. No need to add new.
comment|// We can't continue with this row, hence it's the last retry.
name|manageError
argument_list|(
name|numAttempt
argument_list|,
name|posInList
argument_list|,
name|row
argument_list|,
literal|false
argument_list|,
name|locationException
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|force
condition|)
block|{
return|return
name|loc
return|;
block|}
name|String
name|regionName
init|=
name|loc
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
name|Boolean
name|addIt
init|=
name|regionStatus
operator|.
name|get
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|addIt
operator|==
literal|null
condition|)
block|{
name|addIt
operator|=
name|canTakeNewOperations
argument_list|(
name|regionName
argument_list|)
expr_stmt|;
name|regionStatus
operator|.
name|put
argument_list|(
name|regionName
argument_list|,
name|addIt
argument_list|)
expr_stmt|;
block|}
return|return
name|addIt
condition|?
name|loc
else|:
literal|null
return|;
block|}
comment|/**    * Check if we should send new operations to this region.    *    * @param encodedRegionName region name    * @return true if this region is considered as busy.    */
specifier|protected
name|boolean
name|canTakeNewOperations
parameter_list|(
name|String
name|encodedRegionName
parameter_list|)
block|{
name|AtomicInteger
name|ct
init|=
name|taskCounterPerRegion
operator|.
name|get
argument_list|(
name|encodedRegionName
argument_list|)
decl_stmt|;
return|return
name|ct
operator|==
literal|null
operator|||
name|ct
operator|.
name|get
argument_list|()
operator|<
name|maxConcurrentTasksPerRegion
return|;
block|}
comment|/**    * Submit immediately the list of rows, whatever the server status. Kept for backward    * compatibility: it allows to be used with the batch interface that return an array of objects.    *    * @param rows the list of rows.    */
specifier|public
name|void
name|submitAll
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|Row
argument_list|>
name|rows
parameter_list|)
block|{
name|List
argument_list|<
name|Action
argument_list|<
name|Row
argument_list|>
argument_list|>
name|actions
init|=
operator|new
name|ArrayList
argument_list|<
name|Action
argument_list|<
name|Row
argument_list|>
argument_list|>
argument_list|(
name|rows
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// The position will be used by the processBatch to match the object array returned.
name|int
name|posInList
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|Row
name|r
range|:
name|rows
control|)
block|{
name|posInList
operator|++
expr_stmt|;
name|Action
argument_list|<
name|Row
argument_list|>
name|action
init|=
operator|new
name|Action
argument_list|<
name|Row
argument_list|>
argument_list|(
name|r
argument_list|,
name|posInList
argument_list|)
decl_stmt|;
name|actions
operator|.
name|add
argument_list|(
name|action
argument_list|)
expr_stmt|;
block|}
name|HConnectionManager
operator|.
name|ServerErrorTracker
name|errorsByServer
init|=
name|createServerErrorTracker
argument_list|()
decl_stmt|;
name|submit
argument_list|(
name|actions
argument_list|,
name|actions
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|,
name|errorsByServer
argument_list|)
expr_stmt|;
block|}
comment|/**    * Group a list of actions per region servers, and send them. The created MultiActions are    * added to the inProgress list.    *    * @param initialActions - the full list of the actions in progress    * @param currentActions - the list of row to submit    * @param numAttempt - the current numAttempt (first attempt is 1)    * @param force - true if we submit the rowList without taking into account the server load    */
specifier|private
name|void
name|submit
parameter_list|(
name|List
argument_list|<
name|Action
argument_list|<
name|Row
argument_list|>
argument_list|>
name|initialActions
parameter_list|,
name|List
argument_list|<
name|Action
argument_list|<
name|Row
argument_list|>
argument_list|>
name|currentActions
parameter_list|,
name|int
name|numAttempt
parameter_list|,
name|boolean
name|force
parameter_list|,
specifier|final
name|HConnectionManager
operator|.
name|ServerErrorTracker
name|errorsByServer
parameter_list|)
block|{
comment|// group per location => regions server
specifier|final
name|Map
argument_list|<
name|HRegionLocation
argument_list|,
name|MultiAction
argument_list|<
name|Row
argument_list|>
argument_list|>
name|actionsByServer
init|=
operator|new
name|HashMap
argument_list|<
name|HRegionLocation
argument_list|,
name|MultiAction
argument_list|<
name|Row
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// We have the same policy for a single region per call to submit: we don't want
comment|//  to send half of the actions because the status changed in the middle. So we keep the
comment|//  status
name|Map
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
name|regionIncluded
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Action
argument_list|<
name|Row
argument_list|>
name|action
range|:
name|currentActions
control|)
block|{
name|HRegionLocation
name|loc
init|=
name|findDestLocation
argument_list|(
name|action
operator|.
name|getAction
argument_list|()
argument_list|,
literal|1
argument_list|,
name|action
operator|.
name|getOriginalIndex
argument_list|()
argument_list|,
name|force
argument_list|,
name|regionIncluded
argument_list|)
decl_stmt|;
if|if
condition|(
name|loc
operator|!=
literal|null
condition|)
block|{
name|addAction
argument_list|(
name|loc
argument_list|,
name|action
argument_list|,
name|actionsByServer
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|actionsByServer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|sendMultiAction
argument_list|(
name|initialActions
argument_list|,
name|actionsByServer
argument_list|,
name|numAttempt
argument_list|,
name|errorsByServer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Send a multi action structure to the servers, after a delay depending on the attempt    * number. Asynchronous.    *    * @param initialActions  the list of the actions, flat.    * @param actionsByServer the actions structured by regions    * @param numAttempt      the attempt number.    */
specifier|public
name|void
name|sendMultiAction
parameter_list|(
specifier|final
name|List
argument_list|<
name|Action
argument_list|<
name|Row
argument_list|>
argument_list|>
name|initialActions
parameter_list|,
name|Map
argument_list|<
name|HRegionLocation
argument_list|,
name|MultiAction
argument_list|<
name|Row
argument_list|>
argument_list|>
name|actionsByServer
parameter_list|,
specifier|final
name|int
name|numAttempt
parameter_list|,
specifier|final
name|HConnectionManager
operator|.
name|ServerErrorTracker
name|errorsByServer
parameter_list|)
block|{
comment|// Send the queries and add them to the inProgress list
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|HRegionLocation
argument_list|,
name|MultiAction
argument_list|<
name|Row
argument_list|>
argument_list|>
name|e
range|:
name|actionsByServer
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|HRegionLocation
name|loc
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
specifier|final
name|MultiAction
argument_list|<
name|Row
argument_list|>
name|multi
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
specifier|final
name|String
name|regionName
init|=
name|loc
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedName
argument_list|()
decl_stmt|;
name|incTaskCounters
argument_list|(
name|regionName
argument_list|)
expr_stmt|;
name|Runnable
name|runnable
init|=
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|MultiResponse
name|res
decl_stmt|;
try|try
block|{
name|ServerCallable
argument_list|<
name|MultiResponse
argument_list|>
name|callable
init|=
name|createCallable
argument_list|(
name|loc
argument_list|,
name|multi
argument_list|)
decl_stmt|;
try|try
block|{
name|res
operator|=
name|callable
operator|.
name|withoutRetries
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The call to the RS failed, we don't know where we stand. location="
operator|+
name|loc
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|resubmitAll
argument_list|(
name|initialActions
argument_list|,
name|multi
argument_list|,
name|loc
argument_list|,
name|numAttempt
operator|+
literal|1
argument_list|,
name|e
argument_list|,
name|errorsByServer
argument_list|)
expr_stmt|;
return|return;
block|}
name|receiveMultiAction
argument_list|(
name|initialActions
argument_list|,
name|multi
argument_list|,
name|loc
argument_list|,
name|res
argument_list|,
name|numAttempt
argument_list|,
name|errorsByServer
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|decTaskCounters
argument_list|(
name|regionName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
try|try
block|{
name|this
operator|.
name|pool
operator|.
name|submit
argument_list|(
name|runnable
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RejectedExecutionException
name|ree
parameter_list|)
block|{
comment|// This should never happen. But as the pool is provided by the end user, let's secure
comment|//  this a little.
name|decTaskCounters
argument_list|(
name|regionName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"The task was rejected by the pool. This is unexpected. "
operator|+
literal|"location="
operator|+
name|loc
argument_list|,
name|ree
argument_list|)
expr_stmt|;
comment|// We're likely to fail again, but this will increment the attempt counter, so it will
comment|//  finish.
name|resubmitAll
argument_list|(
name|initialActions
argument_list|,
name|multi
argument_list|,
name|loc
argument_list|,
name|numAttempt
operator|+
literal|1
argument_list|,
name|ree
argument_list|,
name|errorsByServer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Create a callable. Isolated to be easily overridden in the tests.    */
specifier|protected
name|ServerCallable
argument_list|<
name|MultiResponse
argument_list|>
name|createCallable
parameter_list|(
specifier|final
name|HRegionLocation
name|loc
parameter_list|,
specifier|final
name|MultiAction
argument_list|<
name|Row
argument_list|>
name|multi
parameter_list|)
block|{
return|return
operator|new
name|MultiServerCallable
argument_list|<
name|Row
argument_list|>
argument_list|(
name|hConnection
argument_list|,
name|tableName
argument_list|,
name|loc
argument_list|,
name|multi
argument_list|)
return|;
block|}
comment|/**    * Check that we can retry acts accordingly: logs, set the error status, call the callbacks.    *    * @param numAttempt    the number of this attempt    * @param originalIndex the position in the list sent    * @param row           the row    * @param canRetry      if false, we won't retry whatever the settings.    * @param throwable     the throwable, if any (can be null)    * @param location      the location, if any (can be null)    * @return true if the action can be retried, false otherwise.    */
specifier|private
name|boolean
name|manageError
parameter_list|(
name|int
name|numAttempt
parameter_list|,
name|int
name|originalIndex
parameter_list|,
name|Row
name|row
parameter_list|,
name|boolean
name|canRetry
parameter_list|,
name|Throwable
name|throwable
parameter_list|,
name|HRegionLocation
name|location
parameter_list|)
block|{
if|if
condition|(
name|canRetry
condition|)
block|{
if|if
condition|(
name|numAttempt
operator|>=
name|numTries
operator|||
operator|(
name|throwable
operator|!=
literal|null
operator|&&
name|throwable
operator|instanceof
name|DoNotRetryIOException
operator|)
condition|)
block|{
name|canRetry
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|byte
index|[]
name|region
init|=
name|location
operator|==
literal|null
condition|?
literal|null
else|:
name|location
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedNameAsBytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|canRetry
operator|&&
name|callback
operator|!=
literal|null
condition|)
block|{
name|canRetry
operator|=
name|callback
operator|.
name|retriableFailure
argument_list|(
name|originalIndex
argument_list|,
name|row
argument_list|,
name|region
argument_list|,
name|throwable
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|canRetry
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|retriedErrors
operator|.
name|add
argument_list|(
name|throwable
argument_list|,
name|row
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
block|{
name|callback
operator|.
name|failure
argument_list|(
name|originalIndex
argument_list|,
name|region
argument_list|,
name|row
argument_list|,
name|throwable
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|hasError
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|errors
operator|.
name|add
argument_list|(
name|throwable
argument_list|,
name|row
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
return|return
name|canRetry
return|;
block|}
comment|/**    * Resubmit all the actions from this multiaction after a failure.    *    * @param initialActions the full initial action list    * @param rsActions  the actions still to do from the initial list    * @param location   the destination    * @param numAttempt the number of attempts so far    * @param t the throwable (if any) that caused the resubmit    */
specifier|private
name|void
name|resubmitAll
parameter_list|(
name|List
argument_list|<
name|Action
argument_list|<
name|Row
argument_list|>
argument_list|>
name|initialActions
parameter_list|,
name|MultiAction
argument_list|<
name|Row
argument_list|>
name|rsActions
parameter_list|,
name|HRegionLocation
name|location
parameter_list|,
name|int
name|numAttempt
parameter_list|,
name|Throwable
name|t
parameter_list|,
name|HConnectionManager
operator|.
name|ServerErrorTracker
name|errorsByServer
parameter_list|)
block|{
comment|// Do not use the exception for updating cache because it might be coming from
comment|// any of the regions in the MultiAction.
name|hConnection
operator|.
name|updateCachedLocations
argument_list|(
name|tableName
argument_list|,
name|rsActions
operator|.
name|actions
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getAction
argument_list|()
operator|.
name|getRow
argument_list|()
argument_list|,
literal|null
argument_list|,
name|location
argument_list|)
expr_stmt|;
name|errorsByServer
operator|.
name|reportServerError
argument_list|(
name|location
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Action
argument_list|<
name|Row
argument_list|>
argument_list|>
name|toReplay
init|=
operator|new
name|ArrayList
argument_list|<
name|Action
argument_list|<
name|Row
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|Action
argument_list|<
name|Row
argument_list|>
argument_list|>
name|actions
range|:
name|rsActions
operator|.
name|actions
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|Action
argument_list|<
name|Row
argument_list|>
name|action
range|:
name|actions
control|)
block|{
if|if
condition|(
name|manageError
argument_list|(
name|numAttempt
argument_list|,
name|action
operator|.
name|getOriginalIndex
argument_list|()
argument_list|,
name|action
operator|.
name|getAction
argument_list|()
argument_list|,
literal|true
argument_list|,
name|t
argument_list|,
name|location
argument_list|)
condition|)
block|{
name|toReplay
operator|.
name|add
argument_list|(
name|action
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|toReplay
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Attempt #"
operator|+
name|numAttempt
operator|+
literal|"/"
operator|+
name|numTries
operator|+
literal|" failed for all ("
operator|+
name|initialActions
operator|.
name|size
argument_list|()
operator|+
literal|") operations on server "
operator|+
name|location
operator|.
name|getServerName
argument_list|()
operator|+
literal|" NOT resubmitting, tableName="
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
operator|+
literal|", location="
operator|+
name|location
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|submit
argument_list|(
name|initialActions
argument_list|,
name|toReplay
argument_list|,
name|numAttempt
argument_list|,
literal|true
argument_list|,
name|errorsByServer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Called when we receive the result of a server query.    *    * @param initialActions - the whole action list    * @param rsActions      - the actions for this location    * @param location       - the location    * @param responses      - the response, if any    * @param numAttempt     - the attempt    */
specifier|private
name|void
name|receiveMultiAction
parameter_list|(
name|List
argument_list|<
name|Action
argument_list|<
name|Row
argument_list|>
argument_list|>
name|initialActions
parameter_list|,
name|MultiAction
argument_list|<
name|Row
argument_list|>
name|rsActions
parameter_list|,
name|HRegionLocation
name|location
parameter_list|,
name|MultiResponse
name|responses
parameter_list|,
name|int
name|numAttempt
parameter_list|,
name|HConnectionManager
operator|.
name|ServerErrorTracker
name|errorsByServer
parameter_list|)
block|{
if|if
condition|(
name|responses
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Attempt #"
operator|+
name|numAttempt
operator|+
literal|"/"
operator|+
name|numTries
operator|+
literal|" failed for all operations"
operator|+
literal|" on server "
operator|+
name|location
operator|.
name|getServerName
argument_list|()
operator|+
literal|" , trying to resubmit,"
operator|+
literal|" tableName="
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
operator|+
literal|", location="
operator|+
name|location
argument_list|)
expr_stmt|;
name|resubmitAll
argument_list|(
name|initialActions
argument_list|,
name|rsActions
argument_list|,
name|location
argument_list|,
name|numAttempt
operator|+
literal|1
argument_list|,
literal|null
argument_list|,
name|errorsByServer
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Success or partial success
comment|// Analyze detailed results. We can still have individual failures to be redo.
comment|// two specific throwables are managed:
comment|//  - DoNotRetryIOException: we continue to retry for other actions
comment|//  - RegionMovedException: we update the cache with the new region location
name|List
argument_list|<
name|Action
argument_list|<
name|Row
argument_list|>
argument_list|>
name|toReplay
init|=
operator|new
name|ArrayList
argument_list|<
name|Action
argument_list|<
name|Row
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Throwable
name|throwable
init|=
literal|null
decl_stmt|;
name|int
name|failureCount
init|=
literal|0
decl_stmt|;
name|boolean
name|canRetry
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Object
argument_list|>
argument_list|>
argument_list|>
name|resultsForRS
range|:
name|responses
operator|.
name|getResults
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
for|for
control|(
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Object
argument_list|>
name|regionResult
range|:
name|resultsForRS
operator|.
name|getValue
argument_list|()
control|)
block|{
name|Object
name|result
init|=
name|regionResult
operator|.
name|getSecond
argument_list|()
decl_stmt|;
comment|// Failure: retry if it's make sense else update the errors lists
if|if
condition|(
name|result
operator|==
literal|null
operator|||
name|result
operator|instanceof
name|Throwable
condition|)
block|{
name|throwable
operator|=
operator|(
name|Throwable
operator|)
name|result
expr_stmt|;
name|Action
argument_list|<
name|Row
argument_list|>
name|correspondingAction
init|=
name|initialActions
operator|.
name|get
argument_list|(
name|regionResult
operator|.
name|getFirst
argument_list|()
argument_list|)
decl_stmt|;
name|Row
name|row
init|=
name|correspondingAction
operator|.
name|getAction
argument_list|()
decl_stmt|;
if|if
condition|(
name|failureCount
operator|++
operator|==
literal|0
condition|)
block|{
comment|// We're doing this once per location.
name|hConnection
operator|.
name|updateCachedLocations
argument_list|(
name|this
operator|.
name|tableName
argument_list|,
name|row
operator|.
name|getRow
argument_list|()
argument_list|,
name|result
argument_list|,
name|location
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorsByServer
operator|!=
literal|null
condition|)
block|{
name|errorsByServer
operator|.
name|reportServerError
argument_list|(
name|location
argument_list|)
expr_stmt|;
name|canRetry
operator|=
name|errorsByServer
operator|.
name|canRetryMore
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|manageError
argument_list|(
name|numAttempt
argument_list|,
name|correspondingAction
operator|.
name|getOriginalIndex
argument_list|()
argument_list|,
name|row
argument_list|,
name|canRetry
argument_list|,
name|throwable
argument_list|,
name|location
argument_list|)
condition|)
block|{
name|toReplay
operator|.
name|add
argument_list|(
name|correspondingAction
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// success
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
block|{
name|Action
argument_list|<
name|Row
argument_list|>
name|correspondingAction
init|=
name|initialActions
operator|.
name|get
argument_list|(
name|regionResult
operator|.
name|getFirst
argument_list|()
argument_list|)
decl_stmt|;
name|Row
name|row
init|=
name|correspondingAction
operator|.
name|getAction
argument_list|()
decl_stmt|;
comment|//noinspection unchecked
name|this
operator|.
name|callback
operator|.
name|success
argument_list|(
name|correspondingAction
operator|.
name|getOriginalIndex
argument_list|()
argument_list|,
name|resultsForRS
operator|.
name|getKey
argument_list|()
argument_list|,
name|row
argument_list|,
operator|(
name|CResult
operator|)
name|result
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|toReplay
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|long
name|backOffTime
init|=
operator|(
name|errorsByServer
operator|!=
literal|null
condition|?
name|errorsByServer
operator|.
name|calculateBackoffTime
argument_list|(
name|location
argument_list|,
name|pause
argument_list|)
else|:
name|ConnectionUtils
operator|.
name|getPauseTime
argument_list|(
name|pause
argument_list|,
name|numAttempt
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|numAttempt
operator|>
literal|3
operator|&&
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
comment|// We use this value to have some logs when we have multiple failures, but not too many
comment|//  logs as errors are to be expected wehn region moves, split and so on
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempt #"
operator|+
name|numAttempt
operator|+
literal|"/"
operator|+
name|numTries
operator|+
literal|" failed for "
operator|+
name|failureCount
operator|+
literal|" operations on server "
operator|+
name|location
operator|.
name|getServerName
argument_list|()
operator|+
literal|", resubmitting "
operator|+
name|toReplay
operator|.
name|size
argument_list|()
operator|+
literal|", tableName="
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
operator|+
literal|", location="
operator|+
name|location
operator|+
literal|", last exception was: "
operator|+
name|throwable
operator|+
literal|" - sleeping "
operator|+
name|backOffTime
operator|+
literal|" ms."
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|backOffTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Not sent: "
operator|+
name|toReplay
operator|.
name|size
argument_list|()
operator|+
literal|" operations,  tableName="
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
operator|+
literal|", location="
operator|+
name|location
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|interrupted
argument_list|()
expr_stmt|;
return|return;
block|}
name|submit
argument_list|(
name|initialActions
argument_list|,
name|toReplay
argument_list|,
name|numAttempt
operator|+
literal|1
argument_list|,
literal|true
argument_list|,
name|errorsByServer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|failureCount
operator|!=
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Attempt #"
operator|+
name|numAttempt
operator|+
literal|"/"
operator|+
name|numTries
operator|+
literal|" failed for "
operator|+
name|failureCount
operator|+
literal|" operations on server "
operator|+
name|location
operator|.
name|getServerName
argument_list|()
operator|+
literal|" NOT resubmitting."
operator|+
literal|", tableName="
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
operator|+
literal|", location="
operator|+
name|location
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Waits for another task to finish.    * @param currentNumberOfTask - the number of task finished when calling the method.    */
specifier|protected
name|void
name|waitForNextTaskDone
parameter_list|(
name|long
name|currentNumberOfTask
parameter_list|)
throws|throws
name|InterruptedIOException
block|{
while|while
condition|(
name|currentNumberOfTask
operator|==
name|tasksDone
operator|.
name|get
argument_list|()
condition|)
block|{
try|try
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|tasksDone
init|)
block|{
name|this
operator|.
name|tasksDone
operator|.
name|wait
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InterruptedIOException
argument_list|(
literal|"Interrupted."
operator|+
literal|" currentNumberOfTask="
operator|+
name|currentNumberOfTask
operator|+
literal|",  tableName="
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
operator|+
literal|", tasksDone="
operator|+
name|tasksDone
operator|.
name|get
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Wait until the async does not have more than max tasks in progress.    */
specifier|private
name|long
name|waitForMaximumCurrentTasks
parameter_list|(
name|int
name|max
parameter_list|)
throws|throws
name|InterruptedIOException
block|{
name|long
name|lastLog
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|long
name|currentTasksDone
init|=
name|this
operator|.
name|tasksDone
operator|.
name|get
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|tasksSent
operator|.
name|get
argument_list|()
operator|-
name|currentTasksDone
operator|)
operator|>
name|max
condition|)
block|{
name|long
name|now
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|now
operator|>
name|lastLog
operator|+
literal|10000
condition|)
block|{
name|lastLog
operator|=
name|now
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|": Waiting for the global number of running tasks to be equals or less than "
operator|+
name|max
operator|+
literal|", tasksSent="
operator|+
name|tasksSent
operator|.
name|get
argument_list|()
operator|+
literal|", tasksDone="
operator|+
name|tasksDone
operator|.
name|get
argument_list|()
operator|+
literal|", currentTasksDone="
operator|+
name|currentTasksDone
operator|+
literal|", tableName="
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|waitForNextTaskDone
argument_list|(
name|currentTasksDone
argument_list|)
expr_stmt|;
name|currentTasksDone
operator|=
name|this
operator|.
name|tasksDone
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
return|return
name|currentTasksDone
return|;
block|}
comment|/**    * Wait until all tasks are executed, successfully or not.    */
specifier|public
name|void
name|waitUntilDone
parameter_list|()
throws|throws
name|InterruptedIOException
block|{
name|waitForMaximumCurrentTasks
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|hasError
parameter_list|()
block|{
return|return
name|hasError
operator|.
name|get
argument_list|()
return|;
block|}
specifier|public
name|List
argument_list|<
name|?
extends|extends
name|Row
argument_list|>
name|getFailedOperations
parameter_list|()
block|{
return|return
name|errors
operator|.
name|actions
return|;
block|}
comment|/**    * Clean the errors stacks. Should be called only when there are no actions in progress.    */
specifier|public
name|void
name|clearErrors
parameter_list|()
block|{
name|errors
operator|.
name|clear
argument_list|()
expr_stmt|;
name|retriedErrors
operator|.
name|clear
argument_list|()
expr_stmt|;
name|hasError
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|public
name|RetriesExhaustedWithDetailsException
name|getErrors
parameter_list|()
block|{
return|return
name|errors
operator|.
name|makeException
argument_list|()
return|;
block|}
comment|/**    * incrementer the tasks counters for a given region. MT safe.    */
specifier|protected
name|void
name|incTaskCounters
parameter_list|(
name|String
name|encodedRegionName
parameter_list|)
block|{
name|tasksSent
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|AtomicInteger
name|counterPerServer
init|=
name|taskCounterPerRegion
operator|.
name|get
argument_list|(
name|encodedRegionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|counterPerServer
operator|==
literal|null
condition|)
block|{
name|taskCounterPerRegion
operator|.
name|putIfAbsent
argument_list|(
name|encodedRegionName
argument_list|,
operator|new
name|AtomicInteger
argument_list|()
argument_list|)
expr_stmt|;
name|counterPerServer
operator|=
name|taskCounterPerRegion
operator|.
name|get
argument_list|(
name|encodedRegionName
argument_list|)
expr_stmt|;
block|}
name|counterPerServer
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|/**    * Decrements the counters for a given region    */
specifier|protected
name|void
name|decTaskCounters
parameter_list|(
name|String
name|encodedRegionName
parameter_list|)
block|{
name|AtomicInteger
name|counterPerServer
init|=
name|taskCounterPerRegion
operator|.
name|get
argument_list|(
name|encodedRegionName
argument_list|)
decl_stmt|;
name|counterPerServer
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
name|tasksDone
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|tasksDone
init|)
block|{
name|tasksDone
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Creates the server error tracker to use inside process.    * Currently, to preserve the main assumption about current retries, and to work well with    * the retry-limit-based calculation, the calculation is local per Process object.    * We may benefit from connection-wide tracking of server errors.    * @return ServerErrorTracker to use, null if there is no ServerErrorTracker on this connection    */
specifier|protected
name|HConnectionManager
operator|.
name|ServerErrorTracker
name|createServerErrorTracker
parameter_list|()
block|{
if|if
condition|(
name|useServerTrackerForRetries
condition|)
block|{
return|return
operator|new
name|HConnectionManager
operator|.
name|ServerErrorTracker
argument_list|(
name|this
operator|.
name|serverTrackerTimeout
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
end_class

end_unit

