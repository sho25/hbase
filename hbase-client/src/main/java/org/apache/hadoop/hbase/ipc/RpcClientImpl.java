begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|BlockingRpcChannel
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Descriptors
operator|.
name|MethodDescriptor
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Message
operator|.
name|Builder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|RpcCallback
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|RpcController
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|ServiceException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|DoNotRetryIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|codec
operator|.
name|Codec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|ConnectionClosingException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AuthenticationProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|CellBlockMeta
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|ConnectionHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|ExceptionResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|RequestHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|ResponseHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|UserInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|TracingProtos
operator|.
name|RPCTInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|AuthMethod
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|HBaseSaslRpcClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|SaslUtil
operator|.
name|QualityOfProtection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|SecurityInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|User
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|UserProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|token
operator|.
name|AuthenticationTokenSelector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ExceptionUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|PoolMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|CompressionCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|SecurityUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenSelector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|htrace
operator|.
name|Span
import|;
end_import

begin_import
import|import
name|org
operator|.
name|htrace
operator|.
name|Trace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|htrace
operator|.
name|TraceScope
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|net
operator|.
name|SocketFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|sasl
operator|.
name|SaslException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|ConnectException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Socket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketTimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ArrayBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentSkipListMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_comment
comment|/**  * Does RPC against a cluster.  Manages connections per regionserver in the cluster.  *<p>See HBaseServer  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|RpcClientImpl
extends|extends
name|AbstractRpcClient
block|{
specifier|protected
specifier|final
name|AtomicInteger
name|callIdCnt
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|PoolMap
argument_list|<
name|ConnectionId
argument_list|,
name|Connection
argument_list|>
name|connections
decl_stmt|;
specifier|protected
specifier|final
name|AtomicBoolean
name|running
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|// if client runs
specifier|protected
specifier|final
name|FailedServers
name|failedServers
decl_stmt|;
specifier|protected
specifier|final
name|SocketFactory
name|socketFactory
decl_stmt|;
comment|// how to create sockets
specifier|protected
specifier|final
specifier|static
name|Map
argument_list|<
name|AuthenticationProtos
operator|.
name|TokenIdentifier
operator|.
name|Kind
argument_list|,
name|TokenSelector
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
argument_list|>
name|tokenHandlers
init|=
operator|new
name|HashMap
argument_list|<
name|AuthenticationProtos
operator|.
name|TokenIdentifier
operator|.
name|Kind
argument_list|,
name|TokenSelector
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|tokenHandlers
operator|.
name|put
argument_list|(
name|AuthenticationProtos
operator|.
name|TokenIdentifier
operator|.
name|Kind
operator|.
name|HBASE_AUTH_TOKEN
argument_list|,
operator|new
name|AuthenticationTokenSelector
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a connection. Can be overridden by a subclass for testing.    * @param remoteId - the ConnectionId to use for the connection creation.    */
specifier|protected
name|Connection
name|createConnection
parameter_list|(
name|ConnectionId
name|remoteId
parameter_list|,
specifier|final
name|Codec
name|codec
parameter_list|,
specifier|final
name|CompressionCodec
name|compressor
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|Connection
argument_list|(
name|remoteId
argument_list|,
name|codec
argument_list|,
name|compressor
argument_list|)
return|;
block|}
comment|/**    * see {@link RpcClientImpl.Connection.CallSender}    */
specifier|private
specifier|static
class|class
name|CallFuture
block|{
specifier|final
name|Call
name|call
decl_stmt|;
specifier|final
name|int
name|priority
decl_stmt|;
specifier|final
name|Span
name|span
decl_stmt|;
comment|// We will use this to stop the writer
specifier|final
specifier|static
name|CallFuture
name|DEATH_PILL
init|=
operator|new
name|CallFuture
argument_list|(
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|CallFuture
parameter_list|(
name|Call
name|call
parameter_list|,
name|int
name|priority
parameter_list|,
name|Span
name|span
parameter_list|)
block|{
name|this
operator|.
name|call
operator|=
name|call
expr_stmt|;
name|this
operator|.
name|priority
operator|=
name|priority
expr_stmt|;
name|this
operator|.
name|span
operator|=
name|span
expr_stmt|;
block|}
block|}
comment|/** Thread that reads responses and notifies callers.  Each connection owns a    * socket connected to a remote address.  Calls are multiplexed through this    * socket: responses may be delivered out of order. */
specifier|protected
class|class
name|Connection
extends|extends
name|Thread
block|{
specifier|private
name|ConnectionHeader
name|header
decl_stmt|;
comment|// connection header
specifier|protected
name|ConnectionId
name|remoteId
decl_stmt|;
specifier|protected
name|Socket
name|socket
init|=
literal|null
decl_stmt|;
comment|// connected socket
specifier|protected
name|DataInputStream
name|in
decl_stmt|;
specifier|protected
name|DataOutputStream
name|out
decl_stmt|;
specifier|private
name|Object
name|outLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
name|InetSocketAddress
name|server
decl_stmt|;
comment|// server ip:port
specifier|private
name|String
name|serverPrincipal
decl_stmt|;
comment|// server's krb5 principal name
specifier|private
name|AuthMethod
name|authMethod
decl_stmt|;
comment|// authentication method
specifier|private
name|boolean
name|useSasl
decl_stmt|;
specifier|private
name|Token
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|token
decl_stmt|;
specifier|private
name|HBaseSaslRpcClient
name|saslRpcClient
decl_stmt|;
specifier|private
name|int
name|reloginMaxBackoff
decl_stmt|;
comment|// max pause before relogin on sasl failure
specifier|private
specifier|final
name|Codec
name|codec
decl_stmt|;
specifier|private
specifier|final
name|CompressionCodec
name|compressor
decl_stmt|;
comment|// currently active calls
specifier|protected
specifier|final
name|ConcurrentSkipListMap
argument_list|<
name|Integer
argument_list|,
name|Call
argument_list|>
name|calls
init|=
operator|new
name|ConcurrentSkipListMap
argument_list|<
name|Integer
argument_list|,
name|Call
argument_list|>
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|AtomicBoolean
name|shouldCloseConnection
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|CallSender
name|callSender
decl_stmt|;
comment|/**      * If the client wants to interrupt its calls easily (i.e. call Thread#interrupt),      *  it gets into a java issue: an interruption during a write closes the socket/channel.      * A way to avoid this is to use a different thread for writing. This way, on interruptions,      *  we either cancel the writes or ignore the answer if the write is already done, but we      *  don't stop the write in the middle.      * This adds a thread per region server in the client, so it's kept as an option.      *<p>      * The implementation is simple: the client threads adds their call to the queue, and then      *  wait for an answer. The CallSender blocks on the queue, and writes the calls one      *  after the other. On interruption, the client cancels its call. The CallSender checks that      *  the call has not been canceled before writing it.      *</p>      * When the connection closes, all the calls not yet sent are dismissed. The client thread      *  is notified with an appropriate exception, as if the call was already sent but the answer      *  not yet received.      *</p>      */
specifier|private
class|class
name|CallSender
extends|extends
name|Thread
implements|implements
name|Closeable
block|{
specifier|protected
specifier|final
name|BlockingQueue
argument_list|<
name|CallFuture
argument_list|>
name|callsToWrite
decl_stmt|;
specifier|public
name|CallFuture
name|sendCall
parameter_list|(
name|Call
name|call
parameter_list|,
name|int
name|priority
parameter_list|,
name|Span
name|span
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|IOException
block|{
name|CallFuture
name|cts
init|=
operator|new
name|CallFuture
argument_list|(
name|call
argument_list|,
name|priority
argument_list|,
name|span
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|callsToWrite
operator|.
name|offer
argument_list|(
name|cts
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can't add the call "
operator|+
name|call
operator|.
name|id
operator|+
literal|" to the write queue. callsToWrite.size()="
operator|+
name|callsToWrite
operator|.
name|size
argument_list|()
argument_list|)
throw|;
block|}
name|checkIsOpen
argument_list|()
expr_stmt|;
comment|// We check after the put, to be sure that the call we added won't stay
comment|//  in the list while the cleanup was already done.
return|return
name|cts
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{
assert|assert
name|shouldCloseConnection
operator|.
name|get
argument_list|()
assert|;
name|callsToWrite
operator|.
name|offer
argument_list|(
name|CallFuture
operator|.
name|DEATH_PILL
argument_list|)
expr_stmt|;
comment|// We don't care if we can't add the death pill to the queue: the writer
comment|//  won't be blocked in the 'take', as its queue is full.
block|}
name|CallSender
parameter_list|(
name|String
name|name
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|int
name|queueSize
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.client.write.queueSize"
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
name|callsToWrite
operator|=
operator|new
name|ArrayBlockingQueue
argument_list|<
name|CallFuture
argument_list|>
argument_list|(
name|queueSize
argument_list|)
expr_stmt|;
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|setName
argument_list|(
name|name
operator|+
literal|" - writer"
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|remove
parameter_list|(
name|CallFuture
name|cts
parameter_list|)
block|{
name|callsToWrite
operator|.
name|remove
argument_list|(
name|cts
argument_list|)
expr_stmt|;
comment|// By removing the call from the expected call list, we make the list smaller, but
comment|//  it means as well that we don't know how many calls we cancelled.
name|calls
operator|.
name|remove
argument_list|(
name|cts
operator|.
name|call
operator|.
name|id
argument_list|)
expr_stmt|;
name|cts
operator|.
name|call
operator|.
name|callComplete
argument_list|()
expr_stmt|;
block|}
comment|/**        * Reads the call from the queue, write them on the socket.        */
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
operator|!
name|shouldCloseConnection
operator|.
name|get
argument_list|()
condition|)
block|{
name|CallFuture
name|cts
init|=
literal|null
decl_stmt|;
try|try
block|{
name|cts
operator|=
name|callsToWrite
operator|.
name|take
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|markClosed
argument_list|(
operator|new
name|InterruptedIOException
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cts
operator|==
literal|null
operator|||
name|cts
operator|==
name|CallFuture
operator|.
name|DEATH_PILL
condition|)
block|{
assert|assert
name|shouldCloseConnection
operator|.
name|get
argument_list|()
assert|;
break|break;
block|}
if|if
condition|(
name|cts
operator|.
name|call
operator|.
name|done
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|cts
operator|.
name|call
operator|.
name|checkAndSetTimeout
argument_list|()
condition|)
block|{
continue|continue;
block|}
try|try
block|{
name|Connection
operator|.
name|this
operator|.
name|tracedWriteRequest
argument_list|(
name|cts
operator|.
name|call
argument_list|,
name|cts
operator|.
name|priority
argument_list|,
name|cts
operator|.
name|span
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"call write error for call #"
operator|+
name|cts
operator|.
name|call
operator|.
name|id
operator|+
literal|", message ="
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|cts
operator|.
name|call
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|markClosed
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|cleanup
argument_list|()
expr_stmt|;
block|}
comment|/**        * Cleans the call not yet sent when we finish.        */
specifier|private
name|void
name|cleanup
parameter_list|()
block|{
assert|assert
name|shouldCloseConnection
operator|.
name|get
argument_list|()
assert|;
name|IOException
name|ie
init|=
operator|new
name|ConnectionClosingException
argument_list|(
literal|"Connection to "
operator|+
name|server
operator|+
literal|" is closing."
argument_list|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|CallFuture
name|cts
init|=
name|callsToWrite
operator|.
name|poll
argument_list|()
decl_stmt|;
if|if
condition|(
name|cts
operator|==
literal|null
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|cts
operator|.
name|call
operator|!=
literal|null
operator|&&
operator|!
name|cts
operator|.
name|call
operator|.
name|done
condition|)
block|{
name|cts
operator|.
name|call
operator|.
name|setException
argument_list|(
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|Connection
parameter_list|(
name|ConnectionId
name|remoteId
parameter_list|,
specifier|final
name|Codec
name|codec
parameter_list|,
specifier|final
name|CompressionCodec
name|compressor
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|remoteId
operator|.
name|getAddress
argument_list|()
operator|.
name|isUnresolved
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnknownHostException
argument_list|(
literal|"unknown host: "
operator|+
name|remoteId
operator|.
name|getAddress
argument_list|()
operator|.
name|getHostName
argument_list|()
argument_list|)
throw|;
block|}
name|this
operator|.
name|server
operator|=
name|remoteId
operator|.
name|getAddress
argument_list|()
expr_stmt|;
name|this
operator|.
name|codec
operator|=
name|codec
expr_stmt|;
name|this
operator|.
name|compressor
operator|=
name|compressor
expr_stmt|;
name|UserGroupInformation
name|ticket
init|=
name|remoteId
operator|.
name|getTicket
argument_list|()
operator|.
name|getUGI
argument_list|()
decl_stmt|;
name|SecurityInfo
name|securityInfo
init|=
name|SecurityInfo
operator|.
name|getInfo
argument_list|(
name|remoteId
operator|.
name|getServiceName
argument_list|()
argument_list|)
decl_stmt|;
name|this
operator|.
name|useSasl
operator|=
name|userProvider
operator|.
name|isHBaseSecurityEnabled
argument_list|()
expr_stmt|;
if|if
condition|(
name|useSasl
operator|&&
name|securityInfo
operator|!=
literal|null
condition|)
block|{
name|AuthenticationProtos
operator|.
name|TokenIdentifier
operator|.
name|Kind
name|tokenKind
init|=
name|securityInfo
operator|.
name|getTokenKind
argument_list|()
decl_stmt|;
if|if
condition|(
name|tokenKind
operator|!=
literal|null
condition|)
block|{
name|TokenSelector
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|tokenSelector
init|=
name|tokenHandlers
operator|.
name|get
argument_list|(
name|tokenKind
argument_list|)
decl_stmt|;
if|if
condition|(
name|tokenSelector
operator|!=
literal|null
condition|)
block|{
name|token
operator|=
name|tokenSelector
operator|.
name|selectToken
argument_list|(
operator|new
name|Text
argument_list|(
name|clusterId
argument_list|)
argument_list|,
name|ticket
operator|.
name|getTokens
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No token selector found for type "
operator|+
name|tokenKind
argument_list|)
expr_stmt|;
block|}
block|}
name|String
name|serverKey
init|=
name|securityInfo
operator|.
name|getServerPrincipal
argument_list|()
decl_stmt|;
if|if
condition|(
name|serverKey
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can't obtain server Kerberos config key from SecurityInfo"
argument_list|)
throw|;
block|}
name|serverPrincipal
operator|=
name|SecurityUtil
operator|.
name|getServerPrincipal
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|serverKey
argument_list|)
argument_list|,
name|server
operator|.
name|getAddress
argument_list|()
operator|.
name|getCanonicalHostName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"RPC Server Kerberos principal name for service="
operator|+
name|remoteId
operator|.
name|getServiceName
argument_list|()
operator|+
literal|" is "
operator|+
name|serverPrincipal
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|useSasl
condition|)
block|{
name|authMethod
operator|=
name|AuthMethod
operator|.
name|SIMPLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|!=
literal|null
condition|)
block|{
name|authMethod
operator|=
name|AuthMethod
operator|.
name|DIGEST
expr_stmt|;
block|}
else|else
block|{
name|authMethod
operator|=
name|AuthMethod
operator|.
name|KERBEROS
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Use "
operator|+
name|authMethod
operator|+
literal|" authentication for service "
operator|+
name|remoteId
operator|.
name|serviceName
operator|+
literal|", sasl="
operator|+
name|useSasl
argument_list|)
expr_stmt|;
block|}
name|reloginMaxBackoff
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.security.relogin.maxbackoff"
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
name|this
operator|.
name|remoteId
operator|=
name|remoteId
expr_stmt|;
name|ConnectionHeader
operator|.
name|Builder
name|builder
init|=
name|ConnectionHeader
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|setServiceName
argument_list|(
name|remoteId
operator|.
name|getServiceName
argument_list|()
argument_list|)
expr_stmt|;
name|UserInformation
name|userInfoPB
init|=
name|getUserInfo
argument_list|(
name|ticket
argument_list|)
decl_stmt|;
if|if
condition|(
name|userInfoPB
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setUserInfo
argument_list|(
name|userInfoPB
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|codec
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setCellBlockCodecClass
argument_list|(
name|this
operator|.
name|codec
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|compressor
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setCellBlockCompressorClass
argument_list|(
name|this
operator|.
name|compressor
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|header
operator|=
name|builder
operator|.
name|build
argument_list|()
expr_stmt|;
name|this
operator|.
name|setName
argument_list|(
literal|"IPC Client ("
operator|+
name|socketFactory
operator|.
name|hashCode
argument_list|()
operator|+
literal|") connection to "
operator|+
name|remoteId
operator|.
name|getAddress
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
operator|(
operator|(
name|ticket
operator|==
literal|null
operator|)
condition|?
literal|" from an unknown user"
else|:
operator|(
literal|" from "
operator|+
name|ticket
operator|.
name|getUserName
argument_list|()
operator|)
operator|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|SPECIFIC_WRITE_THREAD
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|callSender
operator|=
operator|new
name|CallSender
argument_list|(
name|getName
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|callSender
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|callSender
operator|=
literal|null
expr_stmt|;
block|}
block|}
specifier|private
name|UserInformation
name|getUserInfo
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|)
block|{
if|if
condition|(
name|ugi
operator|==
literal|null
operator|||
name|authMethod
operator|==
name|AuthMethod
operator|.
name|DIGEST
condition|)
block|{
comment|// Don't send user for token auth
return|return
literal|null
return|;
block|}
name|UserInformation
operator|.
name|Builder
name|userInfoPB
init|=
name|UserInformation
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|authMethod
operator|==
name|AuthMethod
operator|.
name|KERBEROS
condition|)
block|{
comment|// Send effective user for Kerberos auth
name|userInfoPB
operator|.
name|setEffectiveUser
argument_list|(
name|ugi
operator|.
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|authMethod
operator|==
name|AuthMethod
operator|.
name|SIMPLE
condition|)
block|{
comment|//Send both effective user and real user for simple auth
name|userInfoPB
operator|.
name|setEffectiveUser
argument_list|(
name|ugi
operator|.
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ugi
operator|.
name|getRealUser
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|userInfoPB
operator|.
name|setRealUser
argument_list|(
name|ugi
operator|.
name|getRealUser
argument_list|()
operator|.
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|userInfoPB
operator|.
name|build
argument_list|()
return|;
block|}
specifier|protected
specifier|synchronized
name|void
name|setupConnection
parameter_list|()
throws|throws
name|IOException
block|{
name|short
name|ioFailures
init|=
literal|0
decl_stmt|;
name|short
name|timeoutFailures
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|this
operator|.
name|socket
operator|=
name|socketFactory
operator|.
name|createSocket
argument_list|()
expr_stmt|;
name|this
operator|.
name|socket
operator|.
name|setTcpNoDelay
argument_list|(
name|tcpNoDelay
argument_list|)
expr_stmt|;
name|this
operator|.
name|socket
operator|.
name|setKeepAlive
argument_list|(
name|tcpKeepAlive
argument_list|)
expr_stmt|;
if|if
condition|(
name|localAddr
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|socket
operator|.
name|bind
argument_list|(
name|localAddr
argument_list|)
expr_stmt|;
block|}
name|NetUtils
operator|.
name|connect
argument_list|(
name|this
operator|.
name|socket
argument_list|,
name|remoteId
operator|.
name|getAddress
argument_list|()
argument_list|,
name|connectTO
argument_list|)
expr_stmt|;
name|this
operator|.
name|socket
operator|.
name|setSoTimeout
argument_list|(
name|readTO
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|SocketTimeoutException
name|toe
parameter_list|)
block|{
comment|/* The max number of retries is 45,            * which amounts to 20s*45 = 15 minutes retries.            */
name|handleConnectionFailure
argument_list|(
name|timeoutFailures
operator|++
argument_list|,
name|maxRetries
argument_list|,
name|toe
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|handleConnectionFailure
argument_list|(
name|ioFailures
operator|++
argument_list|,
name|maxRetries
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|protected
specifier|synchronized
name|void
name|closeConnection
parameter_list|()
block|{
if|if
condition|(
name|socket
operator|==
literal|null
condition|)
block|{
return|return;
block|}
comment|// close the current connection
try|try
block|{
if|if
condition|(
name|socket
operator|.
name|getOutputStream
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|socket
operator|.
name|getOutputStream
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ignored
parameter_list|)
block|{
comment|// Can happen if the socket is already closed
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|trace
argument_list|(
literal|"ignored"
argument_list|,
name|ignored
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|socket
operator|.
name|getInputStream
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|socket
operator|.
name|getInputStream
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ignored
parameter_list|)
block|{
comment|// Can happen if the socket is already closed
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|trace
argument_list|(
literal|"ignored"
argument_list|,
name|ignored
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|socket
operator|.
name|getChannel
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|socket
operator|.
name|getChannel
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ignored
parameter_list|)
block|{
comment|// Can happen if the socket is already closed
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|trace
argument_list|(
literal|"ignored"
argument_list|,
name|ignored
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|socket
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Not able to close a socket"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// set socket to null so that the next call to setupIOstreams
comment|// can start the process of connect all over again.
name|socket
operator|=
literal|null
expr_stmt|;
block|}
comment|/**      *  Handle connection failures      *      * If the current number of retries is equal to the max number of retries,      * stop retrying and throw the exception; Otherwise backoff N seconds and      * try connecting again.      *      * This Method is only called from inside setupIOstreams(), which is      * synchronized. Hence the sleep is synchronized; the locks will be retained.      *      * @param curRetries current number of retries      * @param maxRetries max number of retries allowed      * @param ioe failure reason      * @throws IOException if max number of retries is reached      */
specifier|private
name|void
name|handleConnectionFailure
parameter_list|(
name|int
name|curRetries
parameter_list|,
name|int
name|maxRetries
parameter_list|,
name|IOException
name|ioe
parameter_list|)
throws|throws
name|IOException
block|{
name|closeConnection
argument_list|()
expr_stmt|;
comment|// throw the exception if the maximum number of retries is reached
if|if
condition|(
name|curRetries
operator|>=
name|maxRetries
operator|||
name|ExceptionUtil
operator|.
name|isInterrupt
argument_list|(
name|ioe
argument_list|)
condition|)
block|{
throw|throw
name|ioe
throw|;
block|}
comment|// otherwise back off and retry
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|failureSleep
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|ExceptionUtil
operator|.
name|rethrowIfInterrupt
argument_list|(
name|ie
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Retrying connect to server: "
operator|+
name|remoteId
operator|.
name|getAddress
argument_list|()
operator|+
literal|" after sleeping "
operator|+
name|failureSleep
operator|+
literal|"ms. Already tried "
operator|+
name|curRetries
operator|+
literal|" time(s)."
argument_list|)
expr_stmt|;
block|}
comment|/**      * @throws IOException if the connection is not open.      */
specifier|private
name|void
name|checkIsOpen
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|shouldCloseConnection
operator|.
name|get
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ConnectionClosingException
argument_list|(
name|getName
argument_list|()
operator|+
literal|" is closing"
argument_list|)
throw|;
block|}
block|}
comment|/* wait till someone signals us to start reading RPC response or      * it is idle too long, it is marked as to be closed,      * or the client is marked as not running.      *      * @return true if it is time to read a response; false otherwise.      */
specifier|protected
specifier|synchronized
name|boolean
name|waitForWork
parameter_list|()
throws|throws
name|InterruptedException
block|{
comment|// beware of the concurrent access to the calls list: we can add calls, but as well
comment|//  remove them.
name|long
name|waitUntil
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|+
name|minIdleTimeBeforeClose
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|shouldCloseConnection
operator|.
name|get
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|running
operator|.
name|get
argument_list|()
condition|)
block|{
name|markClosed
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"stopped with "
operator|+
name|calls
operator|.
name|size
argument_list|()
operator|+
literal|" pending request(s)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|calls
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// shouldCloseConnection can be set to true by a parallel thread here. The caller
comment|//  will need to check anyway.
return|return
literal|true
return|;
block|}
if|if
condition|(
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|>=
name|waitUntil
condition|)
block|{
comment|// Connection is idle.
comment|// We expect the number of calls to be zero here, but actually someone can
comment|//  adds a call at the any moment, as there is no synchronization between this task
comment|//  and adding new calls. It's not a big issue, but it will get an exception.
name|markClosed
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"idle connection closed with "
operator|+
name|calls
operator|.
name|size
argument_list|()
operator|+
literal|" pending request(s)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|wait
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|minIdleTimeBeforeClose
argument_list|,
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|InetSocketAddress
name|getRemoteAddress
parameter_list|()
block|{
return|return
name|remoteId
operator|.
name|getAddress
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|getName
argument_list|()
operator|+
literal|": starting, connections "
operator|+
name|connections
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
while|while
condition|(
name|waitForWork
argument_list|()
condition|)
block|{
comment|// Wait here for work - read or close connection
name|readResponse
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|t
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|getName
argument_list|()
operator|+
literal|": interrupted while waiting for call responses"
argument_list|)
expr_stmt|;
block|}
name|markClosed
argument_list|(
name|ExceptionUtil
operator|.
name|asInterrupt
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|": unexpected throwable while waiting for call responses"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|markClosed
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"Unexpected throwable while waiting call responses"
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|getName
argument_list|()
operator|+
literal|": stopped, connections "
operator|+
name|connections
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|synchronized
name|void
name|disposeSasl
parameter_list|()
block|{
if|if
condition|(
name|saslRpcClient
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|saslRpcClient
operator|.
name|dispose
argument_list|()
expr_stmt|;
name|saslRpcClient
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error disposing of SASL client"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|synchronized
name|boolean
name|shouldAuthenticateOverKrb
parameter_list|()
throws|throws
name|IOException
block|{
name|UserGroupInformation
name|loginUser
init|=
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
decl_stmt|;
name|UserGroupInformation
name|currentUser
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
decl_stmt|;
name|UserGroupInformation
name|realUser
init|=
name|currentUser
operator|.
name|getRealUser
argument_list|()
decl_stmt|;
return|return
name|authMethod
operator|==
name|AuthMethod
operator|.
name|KERBEROS
operator|&&
name|loginUser
operator|!=
literal|null
operator|&&
comment|//Make sure user logged in using Kerberos either keytab or TGT
name|loginUser
operator|.
name|hasKerberosCredentials
argument_list|()
operator|&&
comment|// relogin only in case it is the login user (e.g. JT)
comment|// or superuser (like oozie).
operator|(
name|loginUser
operator|.
name|equals
argument_list|(
name|currentUser
argument_list|)
operator|||
name|loginUser
operator|.
name|equals
argument_list|(
name|realUser
argument_list|)
operator|)
return|;
block|}
specifier|private
specifier|synchronized
name|boolean
name|setupSaslConnection
parameter_list|(
specifier|final
name|InputStream
name|in2
parameter_list|,
specifier|final
name|OutputStream
name|out2
parameter_list|)
throws|throws
name|IOException
block|{
name|saslRpcClient
operator|=
operator|new
name|HBaseSaslRpcClient
argument_list|(
name|authMethod
argument_list|,
name|token
argument_list|,
name|serverPrincipal
argument_list|,
name|fallbackAllowed
argument_list|,
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.rpc.protection"
argument_list|,
name|QualityOfProtection
operator|.
name|AUTHENTICATION
operator|.
name|name
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|saslRpcClient
operator|.
name|saslConnect
argument_list|(
name|in2
argument_list|,
name|out2
argument_list|)
return|;
block|}
comment|/**      * If multiple clients with the same principal try to connect      * to the same server at the same time, the server assumes a      * replay attack is in progress. This is a feature of kerberos.      * In order to work around this, what is done is that the client      * backs off randomly and tries to initiate the connection      * again.      * The other problem is to do with ticket expiry. To handle that,      * a relogin is attempted.      *<p>      * The retry logic is governed by the {@link #shouldAuthenticateOverKrb}      * method. In case when the user doesn't have valid credentials, we don't      * need to retry (from cache or ticket). In such cases, it is prudent to      * throw a runtime exception when we receive a SaslException from the      * underlying authentication implementation, so there is no retry from      * other high level (for eg, HCM or HBaseAdmin).      *</p>      */
specifier|private
specifier|synchronized
name|void
name|handleSaslConnectionFailure
parameter_list|(
specifier|final
name|int
name|currRetries
parameter_list|,
specifier|final
name|int
name|maxRetries
parameter_list|,
specifier|final
name|Exception
name|ex
parameter_list|,
specifier|final
name|Random
name|rand
parameter_list|,
specifier|final
name|UserGroupInformation
name|user
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|user
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|closeConnection
argument_list|()
expr_stmt|;
if|if
condition|(
name|shouldAuthenticateOverKrb
argument_list|()
condition|)
block|{
if|if
condition|(
name|currRetries
operator|<
name|maxRetries
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception encountered while connecting to "
operator|+
literal|"the server : "
operator|+
name|ex
argument_list|)
expr_stmt|;
block|}
comment|//try re-login
if|if
condition|(
name|UserGroupInformation
operator|.
name|isLoginKeytabBased
argument_list|()
condition|)
block|{
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
operator|.
name|reloginFromKeytab
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
operator|.
name|reloginFromTicketCache
argument_list|()
expr_stmt|;
block|}
name|disposeSasl
argument_list|()
expr_stmt|;
comment|//have granularity of milliseconds
comment|//we are sleeping with the Connection lock held but since this
comment|//connection instance is being used for connecting to the server
comment|//in question, it is okay
name|Thread
operator|.
name|sleep
argument_list|(
operator|(
name|rand
operator|.
name|nextInt
argument_list|(
name|reloginMaxBackoff
argument_list|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
name|String
name|msg
init|=
literal|"Couldn't setup connection for "
operator|+
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
operator|.
name|getUserName
argument_list|()
operator|+
literal|" to "
operator|+
name|serverPrincipal
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|(
name|IOException
operator|)
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
operator|.
name|initCause
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception encountered while connecting to "
operator|+
literal|"the server : "
operator|+
name|ex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ex
operator|instanceof
name|RemoteException
condition|)
block|{
throw|throw
operator|(
name|RemoteException
operator|)
name|ex
throw|;
block|}
if|if
condition|(
name|ex
operator|instanceof
name|SaslException
condition|)
block|{
name|String
name|msg
init|=
literal|"SASL authentication failed."
operator|+
literal|" The most likely cause is missing or invalid credentials."
operator|+
literal|" Consider 'kinit'."
decl_stmt|;
name|LOG
operator|.
name|fatal
argument_list|(
name|msg
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|msg
argument_list|,
name|ex
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|protected
specifier|synchronized
name|void
name|setupIOstreams
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|socket
operator|!=
literal|null
condition|)
block|{
comment|// The connection is already available. Perfect.
return|return;
block|}
if|if
condition|(
name|shouldCloseConnection
operator|.
name|get
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ConnectionClosingException
argument_list|(
literal|"This connection is closing"
argument_list|)
throw|;
block|}
if|if
condition|(
name|failedServers
operator|.
name|isFailedServer
argument_list|(
name|remoteId
operator|.
name|getAddress
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Not trying to connect to "
operator|+
name|server
operator|+
literal|" this server is in the failed servers list"
argument_list|)
expr_stmt|;
block|}
name|IOException
name|e
init|=
operator|new
name|FailedServerException
argument_list|(
literal|"This server is in the failed servers list: "
operator|+
name|server
argument_list|)
decl_stmt|;
name|markClosed
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Connecting to "
operator|+
name|server
argument_list|)
expr_stmt|;
block|}
name|short
name|numRetries
init|=
literal|0
decl_stmt|;
specifier|final
name|short
name|MAX_RETRIES
init|=
literal|5
decl_stmt|;
name|Random
name|rand
init|=
literal|null
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|setupConnection
argument_list|()
expr_stmt|;
name|InputStream
name|inStream
init|=
name|NetUtils
operator|.
name|getInputStream
argument_list|(
name|socket
argument_list|)
decl_stmt|;
comment|// This creates a socket with a write timeout. This timeout cannot be changed.
name|OutputStream
name|outStream
init|=
name|NetUtils
operator|.
name|getOutputStream
argument_list|(
name|socket
argument_list|,
name|writeTO
argument_list|)
decl_stmt|;
comment|// Write out the preamble -- MAGIC, version, and auth to use.
name|writeConnectionHeaderPreamble
argument_list|(
name|outStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|useSasl
condition|)
block|{
specifier|final
name|InputStream
name|in2
init|=
name|inStream
decl_stmt|;
specifier|final
name|OutputStream
name|out2
init|=
name|outStream
decl_stmt|;
name|UserGroupInformation
name|ticket
init|=
name|remoteId
operator|.
name|getTicket
argument_list|()
operator|.
name|getUGI
argument_list|()
decl_stmt|;
if|if
condition|(
name|authMethod
operator|==
name|AuthMethod
operator|.
name|KERBEROS
condition|)
block|{
if|if
condition|(
name|ticket
operator|!=
literal|null
operator|&&
name|ticket
operator|.
name|getRealUser
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|ticket
operator|=
name|ticket
operator|.
name|getRealUser
argument_list|()
expr_stmt|;
block|}
block|}
name|boolean
name|continueSasl
decl_stmt|;
if|if
condition|(
name|ticket
operator|==
literal|null
condition|)
throw|throw
operator|new
name|FatalConnectionException
argument_list|(
literal|"ticket/user is null"
argument_list|)
throw|;
try|try
block|{
name|continueSasl
operator|=
name|ticket
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|run
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|setupSaslConnection
argument_list|(
name|in2
argument_list|,
name|out2
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|ExceptionUtil
operator|.
name|rethrowIfInterrupt
argument_list|(
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rand
operator|==
literal|null
condition|)
block|{
name|rand
operator|=
operator|new
name|Random
argument_list|()
expr_stmt|;
block|}
name|handleSaslConnectionFailure
argument_list|(
name|numRetries
operator|++
argument_list|,
name|MAX_RETRIES
argument_list|,
name|ex
argument_list|,
name|rand
argument_list|,
name|ticket
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|continueSasl
condition|)
block|{
comment|// Sasl connect is successful. Let's set up Sasl i/o streams.
name|inStream
operator|=
name|saslRpcClient
operator|.
name|getInputStream
argument_list|(
name|inStream
argument_list|)
expr_stmt|;
name|outStream
operator|=
name|saslRpcClient
operator|.
name|getOutputStream
argument_list|(
name|outStream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// fall back to simple auth because server told us so.
name|authMethod
operator|=
name|AuthMethod
operator|.
name|SIMPLE
expr_stmt|;
name|useSasl
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|this
operator|.
name|in
operator|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
name|inStream
argument_list|)
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|outLock
init|)
block|{
name|this
operator|.
name|out
operator|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|outStream
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Now write out the connection header
name|writeConnectionHeader
argument_list|()
expr_stmt|;
comment|// start the receiver thread after the socket connection has been set up
name|start
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|IOException
name|e
init|=
name|ExceptionUtil
operator|.
name|asInterrupt
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
name|failedServers
operator|.
name|addToFailedServers
argument_list|(
name|remoteId
operator|.
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|LinkageError
condition|)
block|{
comment|// probably the hbase hadoop version does not match the running hadoop version
name|e
operator|=
operator|new
name|DoNotRetryIOException
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|instanceof
name|IOException
condition|)
block|{
name|e
operator|=
operator|(
name|IOException
operator|)
name|t
expr_stmt|;
block|}
else|else
block|{
name|e
operator|=
operator|new
name|IOException
argument_list|(
literal|"Could not set up IO Streams to "
operator|+
name|server
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
name|markClosed
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**      * Write the RPC header:<MAGIC WORD -- 'HBas'><ONEBYTE_VERSION><ONEBYTE_AUTH_TYPE>      */
specifier|private
name|void
name|writeConnectionHeaderPreamble
parameter_list|(
name|OutputStream
name|outStream
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Assemble the preamble up in a buffer first and then send it.  Writing individual elements,
comment|// they are getting sent across piecemeal according to wireshark and then server is messing
comment|// up the reading on occasion (the passed in stream is not buffered yet).
comment|// Preamble is six bytes -- 'HBas' + VERSION + AUTH_CODE
name|int
name|rpcHeaderLen
init|=
name|HConstants
operator|.
name|RPC_HEADER
operator|.
name|array
argument_list|()
operator|.
name|length
decl_stmt|;
name|byte
index|[]
name|preamble
init|=
operator|new
name|byte
index|[
name|rpcHeaderLen
operator|+
literal|2
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|HConstants
operator|.
name|RPC_HEADER
operator|.
name|array
argument_list|()
argument_list|,
literal|0
argument_list|,
name|preamble
argument_list|,
literal|0
argument_list|,
name|rpcHeaderLen
argument_list|)
expr_stmt|;
name|preamble
index|[
name|rpcHeaderLen
index|]
operator|=
name|HConstants
operator|.
name|RPC_CURRENT_VERSION
expr_stmt|;
name|preamble
index|[
name|rpcHeaderLen
operator|+
literal|1
index|]
operator|=
name|authMethod
operator|.
name|code
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|preamble
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**      * Write the connection header.      */
specifier|private
specifier|synchronized
name|void
name|writeConnectionHeader
parameter_list|()
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|outLock
init|)
block|{
name|this
operator|.
name|out
operator|.
name|writeInt
argument_list|(
name|this
operator|.
name|header
operator|.
name|getSerializedSize
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|header
operator|.
name|writeTo
argument_list|(
name|this
operator|.
name|out
argument_list|)
expr_stmt|;
name|this
operator|.
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Close the connection. */
specifier|protected
specifier|synchronized
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
operator|!
name|shouldCloseConnection
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|getName
argument_list|()
operator|+
literal|": the connection is not in the closed state"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// release the resources
comment|// first thing to do;take the connection out of the connection list
synchronized|synchronized
init|(
name|connections
init|)
block|{
name|connections
operator|.
name|removeValue
argument_list|(
name|remoteId
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
comment|// close the streams and therefore the socket
synchronized|synchronized
init|(
name|this
operator|.
name|outLock
init|)
block|{
if|if
condition|(
name|this
operator|.
name|out
operator|!=
literal|null
condition|)
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|this
operator|.
name|out
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|this
operator|.
name|in
operator|=
literal|null
expr_stmt|;
name|disposeSasl
argument_list|()
expr_stmt|;
comment|// log the info
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|getName
argument_list|()
operator|+
literal|": closing ipc connection to "
operator|+
name|server
argument_list|)
expr_stmt|;
block|}
name|cleanupCalls
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|getName
argument_list|()
operator|+
literal|": ipc connection to "
operator|+
name|server
operator|+
literal|" closed"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|tracedWriteRequest
parameter_list|(
name|Call
name|call
parameter_list|,
name|int
name|priority
parameter_list|,
name|Span
name|span
parameter_list|)
throws|throws
name|IOException
block|{
name|TraceScope
name|ts
init|=
name|Trace
operator|.
name|continueSpan
argument_list|(
name|span
argument_list|)
decl_stmt|;
try|try
block|{
name|writeRequest
argument_list|(
name|call
argument_list|,
name|priority
argument_list|,
name|span
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|ts
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Initiates a call by sending the parameter to the remote server.      * Note: this is not called from the Connection thread, but by other      * threads.      * @see #readResponse()      */
specifier|private
name|void
name|writeRequest
parameter_list|(
name|Call
name|call
parameter_list|,
specifier|final
name|int
name|priority
parameter_list|,
name|Span
name|span
parameter_list|)
throws|throws
name|IOException
block|{
name|RequestHeader
operator|.
name|Builder
name|builder
init|=
name|RequestHeader
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|setCallId
argument_list|(
name|call
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|span
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setTraceInfo
argument_list|(
name|RPCTInfo
operator|.
name|newBuilder
argument_list|()
operator|.
name|setParentId
argument_list|(
name|span
operator|.
name|getSpanId
argument_list|()
argument_list|)
operator|.
name|setTraceId
argument_list|(
name|span
operator|.
name|getTraceId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|setMethodName
argument_list|(
name|call
operator|.
name|md
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setRequestParam
argument_list|(
name|call
operator|.
name|param
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|ByteBuffer
name|cellBlock
init|=
name|ipcUtil
operator|.
name|buildCellBlock
argument_list|(
name|this
operator|.
name|codec
argument_list|,
name|this
operator|.
name|compressor
argument_list|,
name|call
operator|.
name|cells
argument_list|)
decl_stmt|;
if|if
condition|(
name|cellBlock
operator|!=
literal|null
condition|)
block|{
name|CellBlockMeta
operator|.
name|Builder
name|cellBlockBuilder
init|=
name|CellBlockMeta
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|cellBlockBuilder
operator|.
name|setLength
argument_list|(
name|cellBlock
operator|.
name|limit
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setCellBlockMeta
argument_list|(
name|cellBlockBuilder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Only pass priority if there one.  Let zero be same as no priority.
if|if
condition|(
name|priority
operator|!=
literal|0
condition|)
name|builder
operator|.
name|setPriority
argument_list|(
name|priority
argument_list|)
expr_stmt|;
name|RequestHeader
name|header
init|=
name|builder
operator|.
name|build
argument_list|()
decl_stmt|;
name|setupIOstreams
argument_list|()
expr_stmt|;
comment|// Now we're going to write the call. We take the lock, then check that the connection
comment|//  is still valid, and, if so we do the write to the socket. If the write fails, we don't
comment|//  know where we stand, we have to close the connection.
name|checkIsOpen
argument_list|()
expr_stmt|;
name|IOException
name|writeException
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|outLock
init|)
block|{
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
throw|throw
operator|new
name|InterruptedIOException
argument_list|()
throw|;
name|calls
operator|.
name|put
argument_list|(
name|call
operator|.
name|id
argument_list|,
name|call
argument_list|)
expr_stmt|;
comment|// We put first as we don't want the connection to become idle.
name|checkIsOpen
argument_list|()
expr_stmt|;
comment|// Now we're checking that it didn't became idle in between.
try|try
block|{
name|IPCUtil
operator|.
name|write
argument_list|(
name|this
operator|.
name|out
argument_list|,
name|header
argument_list|,
name|call
operator|.
name|param
argument_list|,
name|cellBlock
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// We set the value inside the synchronized block, this way the next in line
comment|//  won't even try to write
name|shouldCloseConnection
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|writeException
operator|=
name|e
expr_stmt|;
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
comment|// We added a call, and may be started the connection close. In both cases, we
comment|//  need to notify the reader.
synchronized|synchronized
init|(
name|this
init|)
block|{
name|notifyAll
argument_list|()
expr_stmt|;
block|}
comment|// Now that we notified, we can rethrow the exception if any. Otherwise we're good.
if|if
condition|(
name|writeException
operator|!=
literal|null
condition|)
throw|throw
name|writeException
throw|;
block|}
comment|/* Receive a response.      * Because only one receiver, so no synchronization on in.      */
specifier|protected
name|void
name|readResponse
parameter_list|()
block|{
if|if
condition|(
name|shouldCloseConnection
operator|.
name|get
argument_list|()
condition|)
return|return;
name|Call
name|call
init|=
literal|null
decl_stmt|;
name|boolean
name|expectedCall
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// See HBaseServer.Call.setResponse for where we write out the response.
comment|// Total size of the response.  Unused.  But have to read it in anyways.
name|int
name|totalSize
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
comment|// Read the header
name|ResponseHeader
name|responseHeader
init|=
name|ResponseHeader
operator|.
name|parseDelimitedFrom
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|int
name|id
init|=
name|responseHeader
operator|.
name|getCallId
argument_list|()
decl_stmt|;
name|call
operator|=
name|calls
operator|.
name|remove
argument_list|(
name|id
argument_list|)
expr_stmt|;
comment|// call.done have to be set before leaving this method
name|expectedCall
operator|=
operator|(
name|call
operator|!=
literal|null
operator|&&
operator|!
name|call
operator|.
name|done
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|expectedCall
condition|)
block|{
comment|// So we got a response for which we have no corresponding 'call' here on the client-side.
comment|// We probably timed out waiting, cleaned up all references, and now the server decides
comment|// to return a response.  There is nothing we can do w/ the response at this stage. Clean
comment|// out the wire of the response so its out of the way and we can get other responses on
comment|// this connection.
name|int
name|readSoFar
init|=
name|IPCUtil
operator|.
name|getTotalSizeWhenWrittenDelimited
argument_list|(
name|responseHeader
argument_list|)
decl_stmt|;
name|int
name|whatIsLeftToRead
init|=
name|totalSize
operator|-
name|readSoFar
decl_stmt|;
name|IOUtils
operator|.
name|skipFully
argument_list|(
name|in
argument_list|,
name|whatIsLeftToRead
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|responseHeader
operator|.
name|hasException
argument_list|()
condition|)
block|{
name|ExceptionResponse
name|exceptionResponse
init|=
name|responseHeader
operator|.
name|getException
argument_list|()
decl_stmt|;
name|RemoteException
name|re
init|=
name|createRemoteException
argument_list|(
name|exceptionResponse
argument_list|)
decl_stmt|;
name|call
operator|.
name|setException
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFatalConnectionException
argument_list|(
name|exceptionResponse
argument_list|)
condition|)
block|{
name|markClosed
argument_list|(
name|re
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Message
name|value
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|responseDefaultType
operator|!=
literal|null
condition|)
block|{
name|Builder
name|builder
init|=
name|call
operator|.
name|responseDefaultType
operator|.
name|newBuilderForType
argument_list|()
decl_stmt|;
name|builder
operator|.
name|mergeDelimitedFrom
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|value
operator|=
name|builder
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
name|CellScanner
name|cellBlockScanner
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|responseHeader
operator|.
name|hasCellBlockMeta
argument_list|()
condition|)
block|{
name|int
name|size
init|=
name|responseHeader
operator|.
name|getCellBlockMeta
argument_list|()
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|byte
index|[]
name|cellBlock
init|=
operator|new
name|byte
index|[
name|size
index|]
decl_stmt|;
name|IOUtils
operator|.
name|readFully
argument_list|(
name|this
operator|.
name|in
argument_list|,
name|cellBlock
argument_list|,
literal|0
argument_list|,
name|cellBlock
operator|.
name|length
argument_list|)
expr_stmt|;
name|cellBlockScanner
operator|=
name|ipcUtil
operator|.
name|createCellScanner
argument_list|(
name|this
operator|.
name|codec
argument_list|,
name|this
operator|.
name|compressor
argument_list|,
name|cellBlock
argument_list|)
expr_stmt|;
block|}
name|call
operator|.
name|setResponse
argument_list|(
name|value
argument_list|,
name|cellBlockScanner
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|expectedCall
condition|)
name|call
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|SocketTimeoutException
condition|)
block|{
comment|// Clean up open calls but don't treat this as a fatal condition,
comment|// since we expect certain responses to not make it by the specified
comment|// {@link ConnectionId#rpcTimeout}.
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|trace
argument_list|(
literal|"ignored"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Treat this as a fatal condition and close this connection
name|markClosed
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|cleanupCalls
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * @return True if the exception is a fatal connection exception.      */
specifier|private
name|boolean
name|isFatalConnectionException
parameter_list|(
specifier|final
name|ExceptionResponse
name|e
parameter_list|)
block|{
return|return
name|e
operator|.
name|getExceptionClassName
argument_list|()
operator|.
name|equals
argument_list|(
name|FatalConnectionException
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * @param e exception to be wrapped      * @return RemoteException made from passed<code>e</code>      */
specifier|private
name|RemoteException
name|createRemoteException
parameter_list|(
specifier|final
name|ExceptionResponse
name|e
parameter_list|)
block|{
name|String
name|innerExceptionClassName
init|=
name|e
operator|.
name|getExceptionClassName
argument_list|()
decl_stmt|;
name|boolean
name|doNotRetry
init|=
name|e
operator|.
name|getDoNotRetry
argument_list|()
decl_stmt|;
return|return
name|e
operator|.
name|hasHostname
argument_list|()
condition|?
comment|// If a hostname then add it to the RemoteWithExtrasException
operator|new
name|RemoteWithExtrasException
argument_list|(
name|innerExceptionClassName
argument_list|,
name|e
operator|.
name|getStackTrace
argument_list|()
argument_list|,
name|e
operator|.
name|getHostname
argument_list|()
argument_list|,
name|e
operator|.
name|getPort
argument_list|()
argument_list|,
name|doNotRetry
argument_list|)
else|:
operator|new
name|RemoteWithExtrasException
argument_list|(
name|innerExceptionClassName
argument_list|,
name|e
operator|.
name|getStackTrace
argument_list|()
argument_list|,
name|doNotRetry
argument_list|)
return|;
block|}
specifier|protected
specifier|synchronized
name|void
name|markClosed
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
if|if
condition|(
name|shouldCloseConnection
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|getName
argument_list|()
operator|+
literal|": marking at should close, reason: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callSender
operator|!=
literal|null
condition|)
block|{
name|callSender
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Cleanup the calls older than a given timeout, in milli seconds.      * @param allCalls true for all calls, false for only the calls in timeout      */
specifier|protected
specifier|synchronized
name|void
name|cleanupCalls
parameter_list|(
name|boolean
name|allCalls
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|Integer
argument_list|,
name|Call
argument_list|>
argument_list|>
name|itor
init|=
name|calls
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|itor
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Call
name|c
init|=
name|itor
operator|.
name|next
argument_list|()
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|done
condition|)
block|{
comment|// To catch the calls without timeout that were cancelled.
name|itor
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|allCalls
condition|)
block|{
name|long
name|waitTime
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|-
name|c
operator|.
name|getStartTime
argument_list|()
decl_stmt|;
name|IOException
name|ie
init|=
operator|new
name|ConnectionClosingException
argument_list|(
literal|"Connection to "
operator|+
name|getRemoteAddress
argument_list|()
operator|+
literal|" is closing. Call id="
operator|+
name|c
operator|.
name|id
operator|+
literal|", waitTime="
operator|+
name|waitTime
argument_list|)
decl_stmt|;
name|c
operator|.
name|setException
argument_list|(
name|ie
argument_list|)
expr_stmt|;
name|itor
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|.
name|checkAndSetTimeout
argument_list|()
condition|)
block|{
name|itor
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// We expect the call to be ordered by timeout. It may not be the case, but stopping
comment|//  at the first valid call allows to be sure that we still have something to do without
comment|//  spending too much time by reading the full list.
break|break;
block|}
block|}
block|}
block|}
comment|/**    * Construct an IPC cluster client whose values are of the {@link Message} class.    * @param conf configuration    * @param clusterId the cluster id    * @param factory socket factory    */
name|RpcClientImpl
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|clusterId
parameter_list|,
name|SocketFactory
name|factory
parameter_list|)
block|{
name|this
argument_list|(
name|conf
argument_list|,
name|clusterId
argument_list|,
name|factory
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct an IPC cluster client whose values are of the {@link Message} class.    * @param conf configuration    * @param clusterId the cluster id    * @param factory socket factory    * @param localAddr client socket bind address    */
name|RpcClientImpl
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|clusterId
parameter_list|,
name|SocketFactory
name|factory
parameter_list|,
name|SocketAddress
name|localAddr
parameter_list|)
block|{
name|super
argument_list|(
name|conf
argument_list|,
name|clusterId
argument_list|,
name|localAddr
argument_list|)
expr_stmt|;
name|this
operator|.
name|socketFactory
operator|=
name|factory
expr_stmt|;
name|this
operator|.
name|connections
operator|=
operator|new
name|PoolMap
argument_list|<
name|ConnectionId
argument_list|,
name|Connection
argument_list|>
argument_list|(
name|getPoolType
argument_list|(
name|conf
argument_list|)
argument_list|,
name|getPoolSize
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|failedServers
operator|=
operator|new
name|FailedServers
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct an IPC client for the cluster<code>clusterId</code> with the default SocketFactory    * @param conf configuration    * @param clusterId the cluster id    */
specifier|public
name|RpcClientImpl
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|clusterId
parameter_list|)
block|{
name|this
argument_list|(
name|conf
argument_list|,
name|clusterId
argument_list|,
name|NetUtils
operator|.
name|getDefaultSocketFactory
argument_list|(
name|conf
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct an IPC client for the cluster<code>clusterId</code> with the default SocketFactory    *    * This method is called with reflection by the RpcClientFactory to create an instance    *    * @param conf configuration    * @param clusterId the cluster id    * @param localAddr client socket bind address.    */
specifier|public
name|RpcClientImpl
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|clusterId
parameter_list|,
name|SocketAddress
name|localAddr
parameter_list|)
block|{
name|this
argument_list|(
name|conf
argument_list|,
name|clusterId
argument_list|,
name|NetUtils
operator|.
name|getDefaultSocketFactory
argument_list|(
name|conf
argument_list|)
argument_list|,
name|localAddr
argument_list|)
expr_stmt|;
block|}
comment|/** Stop all threads related to this client.  No further calls may be made    * using this client. */
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"Stopping rpc client"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|running
operator|.
name|compareAndSet
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
condition|)
return|return;
comment|// wake up all connections
synchronized|synchronized
init|(
name|connections
init|)
block|{
for|for
control|(
name|Connection
name|conn
range|:
name|connections
operator|.
name|values
argument_list|()
control|)
block|{
name|conn
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
comment|// wait until all connections are closed
while|while
condition|(
operator|!
name|connections
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Interrupted while stopping the client. We still have "
operator|+
name|connections
operator|.
name|size
argument_list|()
operator|+
literal|" connections."
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
name|Pair
argument_list|<
name|Message
argument_list|,
name|CellScanner
argument_list|>
name|call
parameter_list|(
name|PayloadCarryingRpcController
name|pcrc
parameter_list|,
name|MethodDescriptor
name|md
parameter_list|,
name|Message
name|param
parameter_list|,
name|CellScanner
name|cells
parameter_list|,
name|Message
name|returnType
parameter_list|,
name|User
name|ticket
parameter_list|,
name|InetSocketAddress
name|addr
parameter_list|,
name|int
name|rpcTimeout
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|IOException
block|{
return|return
name|call
argument_list|(
name|pcrc
argument_list|,
name|md
argument_list|,
name|param
argument_list|,
name|cells
argument_list|,
name|returnType
argument_list|,
name|ticket
argument_list|,
name|addr
argument_list|,
name|rpcTimeout
argument_list|,
name|HConstants
operator|.
name|NORMAL_QOS
argument_list|)
return|;
block|}
comment|/** Make a call, passing<code>param</code>, to the IPC server running at    *<code>address</code> which is servicing the<code>protocol</code> protocol,    * with the<code>ticket</code> credentials, returning the value.    * Throws exceptions if there are network problems or if the remote code    * threw an exception.    * @param ticket Be careful which ticket you pass. A new user will mean a new Connection.    *          {@link UserProvider#getCurrent()} makes a new instance of User each time so will be a    *          new Connection each time.    * @return A pair with the Message response and the Cell data (if any).    * @throws InterruptedException    * @throws IOException    */
name|Pair
argument_list|<
name|Message
argument_list|,
name|CellScanner
argument_list|>
name|call
parameter_list|(
name|PayloadCarryingRpcController
name|pcrc
parameter_list|,
name|MethodDescriptor
name|md
parameter_list|,
name|Message
name|param
parameter_list|,
name|CellScanner
name|cells
parameter_list|,
name|Message
name|returnType
parameter_list|,
name|User
name|ticket
parameter_list|,
name|InetSocketAddress
name|addr
parameter_list|,
name|int
name|callTimeout
parameter_list|,
name|int
name|priority
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
specifier|final
name|Call
name|call
init|=
operator|new
name|Call
argument_list|(
name|this
operator|.
name|callIdCnt
operator|.
name|getAndIncrement
argument_list|()
argument_list|,
name|md
argument_list|,
name|param
argument_list|,
name|cells
argument_list|,
name|returnType
argument_list|,
name|callTimeout
argument_list|)
decl_stmt|;
specifier|final
name|Connection
name|connection
init|=
name|getConnection
argument_list|(
name|ticket
argument_list|,
name|call
argument_list|,
name|addr
argument_list|,
name|this
operator|.
name|codec
argument_list|,
name|this
operator|.
name|compressor
argument_list|)
decl_stmt|;
specifier|final
name|CallFuture
name|cts
decl_stmt|;
if|if
condition|(
name|connection
operator|.
name|callSender
operator|!=
literal|null
condition|)
block|{
name|cts
operator|=
name|connection
operator|.
name|callSender
operator|.
name|sendCall
argument_list|(
name|call
argument_list|,
name|priority
argument_list|,
name|Trace
operator|.
name|currentSpan
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcrc
operator|!=
literal|null
condition|)
block|{
name|pcrc
operator|.
name|notifyOnCancel
argument_list|(
operator|new
name|RpcCallback
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|(
name|Object
name|parameter
parameter_list|)
block|{
name|connection
operator|.
name|callSender
operator|.
name|remove
argument_list|(
name|cts
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcrc
operator|.
name|isCanceled
argument_list|()
condition|)
block|{
comment|// To finish if the call was cancelled before we set the notification (race condition)
name|call
operator|.
name|callComplete
argument_list|()
expr_stmt|;
return|return
operator|new
name|Pair
argument_list|<
name|Message
argument_list|,
name|CellScanner
argument_list|>
argument_list|(
name|call
operator|.
name|response
argument_list|,
name|call
operator|.
name|cells
argument_list|)
return|;
block|}
block|}
block|}
else|else
block|{
name|cts
operator|=
literal|null
expr_stmt|;
name|connection
operator|.
name|tracedWriteRequest
argument_list|(
name|call
argument_list|,
name|priority
argument_list|,
name|Trace
operator|.
name|currentSpan
argument_list|()
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|call
operator|.
name|done
condition|)
block|{
if|if
condition|(
name|call
operator|.
name|checkAndSetTimeout
argument_list|()
condition|)
block|{
if|if
condition|(
name|cts
operator|!=
literal|null
condition|)
name|connection
operator|.
name|callSender
operator|.
name|remove
argument_list|(
name|cts
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|connection
operator|.
name|shouldCloseConnection
operator|.
name|get
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ConnectionClosingException
argument_list|(
literal|"Call id="
operator|+
name|call
operator|.
name|id
operator|+
literal|" on server "
operator|+
name|addr
operator|+
literal|" aborted: connection is closing"
argument_list|)
throw|;
block|}
try|try
block|{
synchronized|synchronized
init|(
name|call
init|)
block|{
if|if
condition|(
name|call
operator|.
name|done
condition|)
break|break;
name|call
operator|.
name|wait
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|call
operator|.
name|remainingTime
argument_list|()
argument_list|,
literal|1000
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|call
operator|.
name|setException
argument_list|(
operator|new
name|InterruptedIOException
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|cts
operator|!=
literal|null
condition|)
name|connection
operator|.
name|callSender
operator|.
name|remove
argument_list|(
name|cts
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
if|if
condition|(
name|call
operator|.
name|error
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|call
operator|.
name|error
operator|instanceof
name|RemoteException
condition|)
block|{
name|call
operator|.
name|error
operator|.
name|fillInStackTrace
argument_list|()
expr_stmt|;
throw|throw
name|call
operator|.
name|error
throw|;
block|}
comment|// local exception
throw|throw
name|wrapException
argument_list|(
name|addr
argument_list|,
name|call
operator|.
name|error
argument_list|)
throw|;
block|}
return|return
operator|new
name|Pair
argument_list|<
name|Message
argument_list|,
name|CellScanner
argument_list|>
argument_list|(
name|call
operator|.
name|response
argument_list|,
name|call
operator|.
name|cells
argument_list|)
return|;
block|}
comment|/**    * Take an IOException and the address we were trying to connect to    * and return an IOException with the input exception as the cause.    * The new exception provides the stack trace of the place where    * the exception is thrown and some extra diagnostics information.    * If the exception is ConnectException or SocketTimeoutException,    * return a new one of the same type; Otherwise return an IOException.    *    * @param addr target address    * @param exception the relevant exception    * @return an exception to throw    */
specifier|protected
name|IOException
name|wrapException
parameter_list|(
name|InetSocketAddress
name|addr
parameter_list|,
name|IOException
name|exception
parameter_list|)
block|{
if|if
condition|(
name|exception
operator|instanceof
name|ConnectException
condition|)
block|{
comment|//connection refused; include the host:port in the error
return|return
operator|(
name|ConnectException
operator|)
operator|new
name|ConnectException
argument_list|(
literal|"Call to "
operator|+
name|addr
operator|+
literal|" failed on connection exception: "
operator|+
name|exception
argument_list|)
operator|.
name|initCause
argument_list|(
name|exception
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|exception
operator|instanceof
name|SocketTimeoutException
condition|)
block|{
return|return
operator|(
name|SocketTimeoutException
operator|)
operator|new
name|SocketTimeoutException
argument_list|(
literal|"Call to "
operator|+
name|addr
operator|+
literal|" failed because "
operator|+
name|exception
argument_list|)
operator|.
name|initCause
argument_list|(
name|exception
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|exception
operator|instanceof
name|ConnectionClosingException
condition|)
block|{
return|return
operator|(
name|ConnectionClosingException
operator|)
operator|new
name|ConnectionClosingException
argument_list|(
literal|"Call to "
operator|+
name|addr
operator|+
literal|" failed on local exception: "
operator|+
name|exception
argument_list|)
operator|.
name|initCause
argument_list|(
name|exception
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|IOException
operator|)
operator|new
name|IOException
argument_list|(
literal|"Call to "
operator|+
name|addr
operator|+
literal|" failed on local exception: "
operator|+
name|exception
argument_list|)
operator|.
name|initCause
argument_list|(
name|exception
argument_list|)
return|;
block|}
block|}
comment|/**    * Interrupt the connections to the given ip:port server. This should be called if the server    *  is known as actually dead. This will not prevent current operation to be retried, and,    *  depending on their own behavior, they may retry on the same server. This can be a feature,    *  for example at startup. In any case, they're likely to get connection refused (if the    *  process died) or no route to host: i.e. their next retries should be faster and with a    *  safe exception.    */
annotation|@
name|Override
specifier|public
name|void
name|cancelConnections
parameter_list|(
name|ServerName
name|sn
parameter_list|)
block|{
synchronized|synchronized
init|(
name|connections
init|)
block|{
for|for
control|(
name|Connection
name|connection
range|:
name|connections
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|connection
operator|.
name|isAlive
argument_list|()
operator|&&
name|connection
operator|.
name|getRemoteAddress
argument_list|()
operator|.
name|getPort
argument_list|()
operator|==
name|sn
operator|.
name|getPort
argument_list|()
operator|&&
name|connection
operator|.
name|getRemoteAddress
argument_list|()
operator|.
name|getHostName
argument_list|()
operator|.
name|equals
argument_list|(
name|sn
operator|.
name|getHostname
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"The server on "
operator|+
name|sn
operator|.
name|toString
argument_list|()
operator|+
literal|" is dead - stopping the connection "
operator|+
name|connection
operator|.
name|remoteId
argument_list|)
expr_stmt|;
name|connection
operator|.
name|interrupt
argument_list|()
expr_stmt|;
comment|// We're interrupting a Reader. It means we want it to finish.
comment|// This will close the connection as well.
block|}
block|}
block|}
block|}
comment|/**    *  Get a connection from the pool, or create a new one and add it to the    * pool. Connections to a given host/port are reused.    */
specifier|protected
name|Connection
name|getConnection
parameter_list|(
name|User
name|ticket
parameter_list|,
name|Call
name|call
parameter_list|,
name|InetSocketAddress
name|addr
parameter_list|,
specifier|final
name|Codec
name|codec
parameter_list|,
specifier|final
name|CompressionCodec
name|compressor
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|running
operator|.
name|get
argument_list|()
condition|)
throw|throw
operator|new
name|StoppedRpcClientException
argument_list|()
throw|;
name|Connection
name|connection
decl_stmt|;
name|ConnectionId
name|remoteId
init|=
operator|new
name|ConnectionId
argument_list|(
name|ticket
argument_list|,
name|call
operator|.
name|md
operator|.
name|getService
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|addr
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|connections
init|)
block|{
name|connection
operator|=
name|connections
operator|.
name|get
argument_list|(
name|remoteId
argument_list|)
expr_stmt|;
if|if
condition|(
name|connection
operator|==
literal|null
condition|)
block|{
name|connection
operator|=
name|createConnection
argument_list|(
name|remoteId
argument_list|,
name|this
operator|.
name|codec
argument_list|,
name|this
operator|.
name|compressor
argument_list|)
expr_stmt|;
name|connections
operator|.
name|put
argument_list|(
name|remoteId
argument_list|,
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|connection
return|;
block|}
comment|/**    * Make a blocking call. Throws exceptions if there are network problems or if the remote code    * threw an exception.    * @param ticket Be careful which ticket you pass. A new user will mean a new Connection.    *          {@link UserProvider#getCurrent()} makes a new instance of User each time so will be a    *          new Connection each time.    * @return A pair with the Message response and the Cell data (if any).    */
name|Message
name|callBlockingMethod
parameter_list|(
name|MethodDescriptor
name|md
parameter_list|,
name|PayloadCarryingRpcController
name|pcrc
parameter_list|,
name|Message
name|param
parameter_list|,
name|Message
name|returnType
parameter_list|,
specifier|final
name|User
name|ticket
parameter_list|,
specifier|final
name|InetSocketAddress
name|isa
parameter_list|)
throws|throws
name|ServiceException
block|{
name|long
name|startTime
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|startTime
operator|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
expr_stmt|;
block|}
name|int
name|callTimeout
init|=
literal|0
decl_stmt|;
name|CellScanner
name|cells
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|pcrc
operator|!=
literal|null
condition|)
block|{
name|callTimeout
operator|=
name|pcrc
operator|.
name|getCallTimeout
argument_list|()
expr_stmt|;
name|cells
operator|=
name|pcrc
operator|.
name|cellScanner
argument_list|()
expr_stmt|;
comment|// Clear it here so we don't by mistake try and these cells processing results.
name|pcrc
operator|.
name|setCellScanner
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
name|Pair
argument_list|<
name|Message
argument_list|,
name|CellScanner
argument_list|>
name|val
decl_stmt|;
try|try
block|{
name|val
operator|=
name|call
argument_list|(
name|pcrc
argument_list|,
name|md
argument_list|,
name|param
argument_list|,
name|cells
argument_list|,
name|returnType
argument_list|,
name|ticket
argument_list|,
name|isa
argument_list|,
name|callTimeout
argument_list|,
name|pcrc
operator|!=
literal|null
condition|?
name|pcrc
operator|.
name|getPriority
argument_list|()
else|:
name|HConstants
operator|.
name|NORMAL_QOS
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcrc
operator|!=
literal|null
condition|)
block|{
comment|// Shove the results into controller so can be carried across the proxy/pb service void.
if|if
condition|(
name|val
operator|.
name|getSecond
argument_list|()
operator|!=
literal|null
condition|)
name|pcrc
operator|.
name|setCellScanner
argument_list|(
name|val
operator|.
name|getSecond
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|.
name|getSecond
argument_list|()
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|ServiceException
argument_list|(
literal|"Client dropping data on the floor!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|long
name|callTime
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|-
name|startTime
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Call: "
operator|+
name|md
operator|.
name|getName
argument_list|()
operator|+
literal|", callTime: "
operator|+
name|callTime
operator|+
literal|"ms"
argument_list|)
expr_stmt|;
block|}
return|return
name|val
operator|.
name|getFirst
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ServiceException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Creates a "channel" that can be used by a blocking protobuf service.  Useful setting up    * protobuf blocking stubs.    * @return A blocking rpc channel that goes via this rpc client instance.    */
annotation|@
name|Override
specifier|public
name|BlockingRpcChannel
name|createBlockingRpcChannel
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|,
specifier|final
name|User
name|ticket
parameter_list|,
name|int
name|defaultOperationTimeout
parameter_list|)
block|{
return|return
operator|new
name|BlockingRpcChannelImplementation
argument_list|(
name|this
argument_list|,
name|sn
argument_list|,
name|ticket
argument_list|,
name|defaultOperationTimeout
argument_list|)
return|;
block|}
comment|/**    * Blocking rpc channel that goes via hbase rpc.    */
annotation|@
name|VisibleForTesting
specifier|public
specifier|static
class|class
name|BlockingRpcChannelImplementation
implements|implements
name|BlockingRpcChannel
block|{
specifier|private
specifier|final
name|InetSocketAddress
name|isa
decl_stmt|;
specifier|private
specifier|final
name|RpcClientImpl
name|rpcClient
decl_stmt|;
specifier|private
specifier|final
name|User
name|ticket
decl_stmt|;
specifier|private
specifier|final
name|int
name|defaultOperationTimeout
decl_stmt|;
comment|/**      * @param defaultOperationTimeout - the default timeout when no timeout is given      *                                   by the caller.      */
specifier|protected
name|BlockingRpcChannelImplementation
parameter_list|(
specifier|final
name|RpcClientImpl
name|rpcClient
parameter_list|,
specifier|final
name|ServerName
name|sn
parameter_list|,
specifier|final
name|User
name|ticket
parameter_list|,
name|int
name|defaultOperationTimeout
parameter_list|)
block|{
name|this
operator|.
name|isa
operator|=
operator|new
name|InetSocketAddress
argument_list|(
name|sn
operator|.
name|getHostname
argument_list|()
argument_list|,
name|sn
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|rpcClient
operator|=
name|rpcClient
expr_stmt|;
name|this
operator|.
name|ticket
operator|=
name|ticket
expr_stmt|;
name|this
operator|.
name|defaultOperationTimeout
operator|=
name|defaultOperationTimeout
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Message
name|callBlockingMethod
parameter_list|(
name|MethodDescriptor
name|md
parameter_list|,
name|RpcController
name|controller
parameter_list|,
name|Message
name|param
parameter_list|,
name|Message
name|returnType
parameter_list|)
throws|throws
name|ServiceException
block|{
name|PayloadCarryingRpcController
name|pcrc
decl_stmt|;
if|if
condition|(
name|controller
operator|!=
literal|null
condition|)
block|{
name|pcrc
operator|=
operator|(
name|PayloadCarryingRpcController
operator|)
name|controller
expr_stmt|;
if|if
condition|(
operator|!
name|pcrc
operator|.
name|hasCallTimeout
argument_list|()
condition|)
block|{
name|pcrc
operator|.
name|setCallTimeout
argument_list|(
name|defaultOperationTimeout
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|pcrc
operator|=
operator|new
name|PayloadCarryingRpcController
argument_list|()
expr_stmt|;
name|pcrc
operator|.
name|setCallTimeout
argument_list|(
name|defaultOperationTimeout
argument_list|)
expr_stmt|;
block|}
return|return
name|this
operator|.
name|rpcClient
operator|.
name|callBlockingMethod
argument_list|(
name|md
argument_list|,
name|pcrc
argument_list|,
name|param
argument_list|,
name|returnType
argument_list|,
name|this
operator|.
name|ticket
argument_list|,
name|this
operator|.
name|isa
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

