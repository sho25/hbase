begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|IPCUtil
operator|.
name|toIOE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|IPCUtil
operator|.
name|wrapException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CacheBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CacheLoader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|LoadingCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|BlockingRpcChannel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Descriptors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|RpcChannel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|RpcController
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|ServiceException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|RpcCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|util
operator|.
name|HashedWheelTimer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MetricsConnection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|codec
operator|.
name|Codec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|codec
operator|.
name|KeyValueCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AuthenticationProtos
operator|.
name|TokenIdentifier
operator|.
name|Kind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|User
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|UserProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|token
operator|.
name|AuthenticationTokenSelector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|PoolMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|CompressionCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenSelector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClientProtos
import|;
end_import

begin_comment
comment|/**  * Provides the basics for a RpcClient implementation like configuration and Logging.  *<p>  * Locking schema of the current IPC implementation  *<ul>  *<li>There is a lock in {@link AbstractRpcClient} to protect the fetching or creating  * connection.</li>  *<li>There is a lock in {@link Call} to make sure that we can only finish the call once.</li>  *<li>The same for {@link HBaseRpcController} as {@link Call}. And see the comment of  * {@link HBaseRpcController#notifyOnCancel(RpcCallback, HBaseRpcController.CancellationCallback)}  * of how to deal with cancel.</li>  *<li>For connection implementation, the construction of a connection should be as fast as possible  * because the creation is protected under a lock. Connect to remote side when needed. There is no  * forced locking schema for a connection implementation.</li>  *<li>For the locking order, the {@link Call} and {@link HBaseRpcController}'s lock should be held  * at last. So the callbacks in {@link Call} and {@link HBaseRpcController} should be execute  * outside the lock in {@link Call} and {@link HBaseRpcController} which means the implementations  * of the callbacks are free to hold any lock.</li>  *</ul>  * @since 2.0.0  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|abstract
class|class
name|AbstractRpcClient
parameter_list|<
name|T
extends|extends
name|RpcConnection
parameter_list|>
implements|implements
name|RpcClient
block|{
comment|// Log level is being changed in tests
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|AbstractRpcClient
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|HashedWheelTimer
name|WHEEL_TIMER
init|=
operator|new
name|HashedWheelTimer
argument_list|(
name|Threads
operator|.
name|newDaemonThreadFactory
argument_list|(
literal|"RpcClient-timer"
argument_list|)
argument_list|,
literal|10
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|ScheduledExecutorService
name|IDLE_CONN_SWEEPER
init|=
name|Executors
operator|.
name|newScheduledThreadPool
argument_list|(
literal|1
argument_list|,
name|Threads
operator|.
name|newDaemonThreadFactory
argument_list|(
literal|"Idle-Rpc-Conn-Sweeper"
argument_list|)
argument_list|)
decl_stmt|;
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"MS_MUTABLE_COLLECTION_PKGPROTECT"
argument_list|,
name|justification
operator|=
literal|"the rest of the system which live in the different package can use"
argument_list|)
specifier|protected
specifier|final
specifier|static
name|Map
argument_list|<
name|Kind
argument_list|,
name|TokenSelector
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
argument_list|>
name|TOKEN_HANDLERS
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
static|static
block|{
name|TOKEN_HANDLERS
operator|.
name|put
argument_list|(
name|Kind
operator|.
name|HBASE_AUTH_TOKEN
argument_list|,
operator|new
name|AuthenticationTokenSelector
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|boolean
name|running
init|=
literal|true
decl_stmt|;
comment|// if client runs
specifier|protected
specifier|final
name|Configuration
name|conf
decl_stmt|;
specifier|protected
specifier|final
name|String
name|clusterId
decl_stmt|;
specifier|protected
specifier|final
name|SocketAddress
name|localAddr
decl_stmt|;
specifier|protected
specifier|final
name|MetricsConnection
name|metrics
decl_stmt|;
specifier|protected
specifier|final
name|UserProvider
name|userProvider
decl_stmt|;
specifier|protected
specifier|final
name|CellBlockBuilder
name|cellBlockBuilder
decl_stmt|;
specifier|protected
specifier|final
name|int
name|minIdleTimeBeforeClose
decl_stmt|;
comment|// if the connection is idle for more than this
comment|// time (in ms), it will be closed at any moment.
specifier|protected
specifier|final
name|int
name|maxRetries
decl_stmt|;
comment|// the max. no. of retries for socket connections
specifier|protected
specifier|final
name|long
name|failureSleep
decl_stmt|;
comment|// Time to sleep before retry on failure.
specifier|protected
specifier|final
name|boolean
name|tcpNoDelay
decl_stmt|;
comment|// if T then disable Nagle's Algorithm
specifier|protected
specifier|final
name|boolean
name|tcpKeepAlive
decl_stmt|;
comment|// if T then use keepalives
specifier|protected
specifier|final
name|Codec
name|codec
decl_stmt|;
specifier|protected
specifier|final
name|CompressionCodec
name|compressor
decl_stmt|;
specifier|protected
specifier|final
name|boolean
name|fallbackAllowed
decl_stmt|;
specifier|protected
specifier|final
name|FailedServers
name|failedServers
decl_stmt|;
specifier|protected
specifier|final
name|int
name|connectTO
decl_stmt|;
specifier|protected
specifier|final
name|int
name|readTO
decl_stmt|;
specifier|protected
specifier|final
name|int
name|writeTO
decl_stmt|;
specifier|protected
specifier|final
name|PoolMap
argument_list|<
name|ConnectionId
argument_list|,
name|T
argument_list|>
name|connections
decl_stmt|;
specifier|private
specifier|final
name|AtomicInteger
name|callIdCnt
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|ScheduledFuture
argument_list|<
name|?
argument_list|>
name|cleanupIdleConnectionTask
decl_stmt|;
specifier|private
name|int
name|maxConcurrentCallsPerServer
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|LoadingCache
argument_list|<
name|InetSocketAddress
argument_list|,
name|AtomicInteger
argument_list|>
name|concurrentCounterCache
init|=
name|CacheBuilder
operator|.
name|newBuilder
argument_list|()
operator|.
name|expireAfterAccess
argument_list|(
literal|1
argument_list|,
name|TimeUnit
operator|.
name|HOURS
argument_list|)
operator|.
name|build
argument_list|(
operator|new
name|CacheLoader
argument_list|<
name|InetSocketAddress
argument_list|,
name|AtomicInteger
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|AtomicInteger
name|load
parameter_list|(
name|InetSocketAddress
name|key
parameter_list|)
throws|throws
name|Exception
block|{
return|return
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
comment|/**    * Construct an IPC client for the cluster<code>clusterId</code>    * @param conf configuration    * @param clusterId the cluster id    * @param localAddr client socket bind address.    * @param metrics the connection metrics    */
specifier|public
name|AbstractRpcClient
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|clusterId
parameter_list|,
name|SocketAddress
name|localAddr
parameter_list|,
name|MetricsConnection
name|metrics
parameter_list|)
block|{
name|this
operator|.
name|userProvider
operator|=
name|UserProvider
operator|.
name|instantiate
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|localAddr
operator|=
name|localAddr
expr_stmt|;
name|this
operator|.
name|tcpKeepAlive
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.ipc.client.tcpkeepalive"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|clusterId
operator|=
name|clusterId
operator|!=
literal|null
condition|?
name|clusterId
else|:
name|HConstants
operator|.
name|CLUSTER_ID_DEFAULT
expr_stmt|;
name|this
operator|.
name|failureSleep
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_PAUSE
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_PAUSE
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxRetries
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.client.connect.max.retries"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|tcpNoDelay
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.ipc.client.tcpnodelay"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|cellBlockBuilder
operator|=
operator|new
name|CellBlockBuilder
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|minIdleTimeBeforeClose
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|IDLE_TIME
argument_list|,
literal|120000
argument_list|)
expr_stmt|;
comment|// 2 minutes
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|codec
operator|=
name|getCodec
argument_list|()
expr_stmt|;
name|this
operator|.
name|compressor
operator|=
name|getCompressor
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|fallbackAllowed
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|IPC_CLIENT_FALLBACK_TO_SIMPLE_AUTH_ALLOWED_KEY
argument_list|,
name|IPC_CLIENT_FALLBACK_TO_SIMPLE_AUTH_ALLOWED_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|failedServers
operator|=
operator|new
name|FailedServers
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|connectTO
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|SOCKET_TIMEOUT_CONNECT
argument_list|,
name|DEFAULT_SOCKET_TIMEOUT_CONNECT
argument_list|)
expr_stmt|;
name|this
operator|.
name|readTO
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|SOCKET_TIMEOUT_READ
argument_list|,
name|DEFAULT_SOCKET_TIMEOUT_READ
argument_list|)
expr_stmt|;
name|this
operator|.
name|writeTO
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|SOCKET_TIMEOUT_WRITE
argument_list|,
name|DEFAULT_SOCKET_TIMEOUT_WRITE
argument_list|)
expr_stmt|;
name|this
operator|.
name|metrics
operator|=
name|metrics
expr_stmt|;
name|this
operator|.
name|maxConcurrentCallsPerServer
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_PERSERVER_REQUESTS_THRESHOLD
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_PERSERVER_REQUESTS_THRESHOLD
argument_list|)
expr_stmt|;
name|this
operator|.
name|connections
operator|=
operator|new
name|PoolMap
argument_list|<>
argument_list|(
name|getPoolType
argument_list|(
name|conf
argument_list|)
argument_list|,
name|getPoolSize
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|cleanupIdleConnectionTask
operator|=
name|IDLE_CONN_SWEEPER
operator|.
name|scheduleAtFixedRate
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|cleanupIdleConnections
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|,
name|minIdleTimeBeforeClose
argument_list|,
name|minIdleTimeBeforeClose
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Codec="
operator|+
name|this
operator|.
name|codec
operator|+
literal|", compressor="
operator|+
name|this
operator|.
name|compressor
operator|+
literal|", tcpKeepAlive="
operator|+
name|this
operator|.
name|tcpKeepAlive
operator|+
literal|", tcpNoDelay="
operator|+
name|this
operator|.
name|tcpNoDelay
operator|+
literal|", connectTO="
operator|+
name|this
operator|.
name|connectTO
operator|+
literal|", readTO="
operator|+
name|this
operator|.
name|readTO
operator|+
literal|", writeTO="
operator|+
name|this
operator|.
name|writeTO
operator|+
literal|", minIdleTimeBeforeClose="
operator|+
name|this
operator|.
name|minIdleTimeBeforeClose
operator|+
literal|", maxRetries="
operator|+
name|this
operator|.
name|maxRetries
operator|+
literal|", fallbackAllowed="
operator|+
name|this
operator|.
name|fallbackAllowed
operator|+
literal|", bind address="
operator|+
operator|(
name|this
operator|.
name|localAddr
operator|!=
literal|null
condition|?
name|this
operator|.
name|localAddr
else|:
literal|"null"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|cleanupIdleConnections
parameter_list|()
block|{
name|long
name|closeBeforeTime
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|-
name|minIdleTimeBeforeClose
decl_stmt|;
synchronized|synchronized
init|(
name|connections
init|)
block|{
for|for
control|(
name|T
name|conn
range|:
name|connections
operator|.
name|values
argument_list|()
control|)
block|{
comment|// Remove connection if it has not been chosen by anyone for more than maxIdleTime, and the
comment|// connection itself has already shutdown. The latter check is because we may still
comment|// have some pending calls on connection so we should not shutdown the connection outside.
comment|// The connection itself will disconnect if there is no pending call for maxIdleTime.
if|if
condition|(
name|conn
operator|.
name|getLastTouched
argument_list|()
operator|<
name|closeBeforeTime
operator|&&
operator|!
name|conn
operator|.
name|isActive
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|trace
argument_list|(
literal|"Cleanup idle connection to "
operator|+
name|conn
operator|.
name|remoteId
argument_list|()
operator|.
name|address
argument_list|)
expr_stmt|;
name|connections
operator|.
name|removeValue
argument_list|(
name|conn
operator|.
name|remoteId
argument_list|()
argument_list|,
name|conn
argument_list|)
expr_stmt|;
name|conn
operator|.
name|cleanupConnection
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|public
specifier|static
name|String
name|getDefaultCodec
parameter_list|(
specifier|final
name|Configuration
name|c
parameter_list|)
block|{
comment|// If "hbase.client.default.rpc.codec" is empty string -- you can't set it to null because
comment|// Configuration will complain -- then no default codec (and we'll pb everything). Else
comment|// default is KeyValueCodec
return|return
name|c
operator|.
name|get
argument_list|(
name|DEFAULT_CODEC_CLASS
argument_list|,
name|KeyValueCodec
operator|.
name|class
operator|.
name|getCanonicalName
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Encapsulate the ugly casting and RuntimeException conversion in private method.    * @return Codec to use on this client.    */
name|Codec
name|getCodec
parameter_list|()
block|{
comment|// For NO CODEC, "hbase.client.rpc.codec" must be configured with empty string AND
comment|// "hbase.client.default.rpc.codec" also -- because default is to do cell block encoding.
name|String
name|className
init|=
name|conf
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|RPC_CODEC_CONF_KEY
argument_list|,
name|getDefaultCodec
argument_list|(
name|this
operator|.
name|conf
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|className
operator|==
literal|null
operator|||
name|className
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
try|try
block|{
return|return
operator|(
name|Codec
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|className
argument_list|)
operator|.
name|getDeclaredConstructor
argument_list|()
operator|.
name|newInstance
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Failed getting codec "
operator|+
name|className
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasCellBlockSupport
parameter_list|()
block|{
return|return
name|this
operator|.
name|codec
operator|!=
literal|null
return|;
block|}
comment|// for writing tests that want to throw exception when connecting.
annotation|@
name|VisibleForTesting
name|boolean
name|isTcpNoDelay
parameter_list|()
block|{
return|return
name|tcpNoDelay
return|;
block|}
comment|/**    * Encapsulate the ugly casting and RuntimeException conversion in private method.    * @param conf configuration    * @return The compressor to use on this client.    */
specifier|private
specifier|static
name|CompressionCodec
name|getCompressor
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|className
init|=
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.client.rpc.compressor"
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|className
operator|==
literal|null
operator|||
name|className
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
try|try
block|{
return|return
operator|(
name|CompressionCodec
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|className
argument_list|)
operator|.
name|getDeclaredConstructor
argument_list|()
operator|.
name|newInstance
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Failed getting compressor "
operator|+
name|className
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Return the pool type specified in the configuration, which must be set to either    * {@link org.apache.hadoop.hbase.util.PoolMap.PoolType#RoundRobin} or    * {@link org.apache.hadoop.hbase.util.PoolMap.PoolType#ThreadLocal}, otherwise default to the    * former. For applications with many user threads, use a small round-robin pool. For applications    * with few user threads, you may want to try using a thread-local pool. In any case, the number    * of {@link org.apache.hadoop.hbase.ipc.RpcClient} instances should not exceed the operating    * system's hard limit on the number of connections.    * @param config configuration    * @return either a {@link org.apache.hadoop.hbase.util.PoolMap.PoolType#RoundRobin} or    *         {@link org.apache.hadoop.hbase.util.PoolMap.PoolType#ThreadLocal}    */
specifier|private
specifier|static
name|PoolMap
operator|.
name|PoolType
name|getPoolType
parameter_list|(
name|Configuration
name|config
parameter_list|)
block|{
return|return
name|PoolMap
operator|.
name|PoolType
operator|.
name|valueOf
argument_list|(
name|config
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_IPC_POOL_TYPE
argument_list|)
argument_list|,
name|PoolMap
operator|.
name|PoolType
operator|.
name|RoundRobin
argument_list|,
name|PoolMap
operator|.
name|PoolType
operator|.
name|ThreadLocal
argument_list|)
return|;
block|}
comment|/**    * Return the pool size specified in the configuration, which is applicable only if the pool type    * is {@link org.apache.hadoop.hbase.util.PoolMap.PoolType#RoundRobin}.    * @param config configuration    * @return the maximum pool size    */
specifier|private
specifier|static
name|int
name|getPoolSize
parameter_list|(
name|Configuration
name|config
parameter_list|)
block|{
return|return
name|config
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_IPC_POOL_SIZE
argument_list|,
literal|1
argument_list|)
return|;
block|}
specifier|private
name|int
name|nextCallId
parameter_list|()
block|{
name|int
name|id
decl_stmt|,
name|next
decl_stmt|;
do|do
block|{
name|id
operator|=
name|callIdCnt
operator|.
name|get
argument_list|()
expr_stmt|;
name|next
operator|=
name|id
operator|<
name|Integer
operator|.
name|MAX_VALUE
condition|?
name|id
operator|+
literal|1
else|:
literal|0
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|callIdCnt
operator|.
name|compareAndSet
argument_list|(
name|id
argument_list|,
name|next
argument_list|)
condition|)
do|;
return|return
name|id
return|;
block|}
comment|/**    * Make a blocking call. Throws exceptions if there are network problems or if the remote code    * threw an exception.    * @param ticket Be careful which ticket you pass. A new user will mean a new Connection.    *          {@link UserProvider#getCurrent()} makes a new instance of User each time so will be a    *          new Connection each time.    * @return A pair with the Message response and the Cell data (if any).    */
specifier|private
name|Message
name|callBlockingMethod
parameter_list|(
name|Descriptors
operator|.
name|MethodDescriptor
name|md
parameter_list|,
name|HBaseRpcController
name|hrc
parameter_list|,
name|Message
name|param
parameter_list|,
name|Message
name|returnType
parameter_list|,
specifier|final
name|User
name|ticket
parameter_list|,
specifier|final
name|InetSocketAddress
name|isa
parameter_list|)
throws|throws
name|ServiceException
block|{
name|BlockingRpcCallback
argument_list|<
name|Message
argument_list|>
name|done
init|=
operator|new
name|BlockingRpcCallback
argument_list|<>
argument_list|()
decl_stmt|;
name|callMethod
argument_list|(
name|md
argument_list|,
name|hrc
argument_list|,
name|param
argument_list|,
name|returnType
argument_list|,
name|ticket
argument_list|,
name|isa
argument_list|,
name|done
argument_list|)
expr_stmt|;
name|Message
name|val
decl_stmt|;
try|try
block|{
name|val
operator|=
name|done
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ServiceException
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|hrc
operator|.
name|failed
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ServiceException
argument_list|(
name|hrc
operator|.
name|getFailed
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
return|return
name|val
return|;
block|}
block|}
comment|/**    * Get a connection from the pool, or create a new one and add it to the pool. Connections to a    * given host/port are reused.    */
specifier|private
name|T
name|getConnection
parameter_list|(
name|ConnectionId
name|remoteId
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|failedServers
operator|.
name|isFailedServer
argument_list|(
name|remoteId
operator|.
name|getAddress
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Not trying to connect to "
operator|+
name|remoteId
operator|.
name|address
operator|+
literal|" this server is in the failed servers list"
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|FailedServerException
argument_list|(
literal|"This server is in the failed servers list: "
operator|+
name|remoteId
operator|.
name|address
argument_list|)
throw|;
block|}
name|T
name|conn
decl_stmt|;
synchronized|synchronized
init|(
name|connections
init|)
block|{
if|if
condition|(
operator|!
name|running
condition|)
block|{
throw|throw
operator|new
name|StoppedRpcClientException
argument_list|()
throw|;
block|}
name|conn
operator|=
name|connections
operator|.
name|get
argument_list|(
name|remoteId
argument_list|)
expr_stmt|;
if|if
condition|(
name|conn
operator|==
literal|null
condition|)
block|{
name|conn
operator|=
name|createConnection
argument_list|(
name|remoteId
argument_list|)
expr_stmt|;
name|connections
operator|.
name|put
argument_list|(
name|remoteId
argument_list|,
name|conn
argument_list|)
expr_stmt|;
block|}
name|conn
operator|.
name|setLastTouched
argument_list|(
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|conn
return|;
block|}
comment|/**    * Not connected.    */
specifier|protected
specifier|abstract
name|T
name|createConnection
parameter_list|(
name|ConnectionId
name|remoteId
parameter_list|)
throws|throws
name|IOException
function_decl|;
specifier|private
name|void
name|onCallFinished
parameter_list|(
name|Call
name|call
parameter_list|,
name|HBaseRpcController
name|hrc
parameter_list|,
name|InetSocketAddress
name|addr
parameter_list|,
name|RpcCallback
argument_list|<
name|Message
argument_list|>
name|callback
parameter_list|)
block|{
name|call
operator|.
name|callStats
operator|.
name|setCallTimeMs
argument_list|(
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|-
name|call
operator|.
name|getStartTime
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|updateRpc
argument_list|(
name|call
operator|.
name|md
argument_list|,
name|call
operator|.
name|param
argument_list|,
name|call
operator|.
name|callStats
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Call: "
operator|+
name|call
operator|.
name|md
operator|.
name|getName
argument_list|()
operator|+
literal|", callTime: "
operator|+
name|call
operator|.
name|callStats
operator|.
name|getCallTimeMs
argument_list|()
operator|+
literal|"ms"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|call
operator|.
name|error
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|call
operator|.
name|error
operator|instanceof
name|RemoteException
condition|)
block|{
name|call
operator|.
name|error
operator|.
name|fillInStackTrace
argument_list|()
expr_stmt|;
name|hrc
operator|.
name|setFailed
argument_list|(
name|call
operator|.
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hrc
operator|.
name|setFailed
argument_list|(
name|wrapException
argument_list|(
name|addr
argument_list|,
name|call
operator|.
name|error
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|callback
operator|.
name|run
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hrc
operator|.
name|setDone
argument_list|(
name|call
operator|.
name|cells
argument_list|)
expr_stmt|;
name|callback
operator|.
name|run
argument_list|(
name|call
operator|.
name|response
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|callMethod
parameter_list|(
specifier|final
name|Descriptors
operator|.
name|MethodDescriptor
name|md
parameter_list|,
specifier|final
name|HBaseRpcController
name|hrc
parameter_list|,
specifier|final
name|Message
name|param
parameter_list|,
name|Message
name|returnType
parameter_list|,
specifier|final
name|User
name|ticket
parameter_list|,
specifier|final
name|InetSocketAddress
name|addr
parameter_list|,
specifier|final
name|RpcCallback
argument_list|<
name|Message
argument_list|>
name|callback
parameter_list|)
block|{
specifier|final
name|MetricsConnection
operator|.
name|CallStats
name|cs
init|=
name|MetricsConnection
operator|.
name|newCallStats
argument_list|()
decl_stmt|;
name|cs
operator|.
name|setStartTime
argument_list|(
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|param
operator|instanceof
name|ClientProtos
operator|.
name|MultiRequest
condition|)
block|{
name|ClientProtos
operator|.
name|MultiRequest
name|req
init|=
operator|(
name|ClientProtos
operator|.
name|MultiRequest
operator|)
name|param
decl_stmt|;
name|int
name|numActions
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ClientProtos
operator|.
name|RegionAction
name|regionAction
range|:
name|req
operator|.
name|getRegionActionList
argument_list|()
control|)
block|{
name|numActions
operator|+=
name|regionAction
operator|.
name|getActionCount
argument_list|()
expr_stmt|;
block|}
name|cs
operator|.
name|setNumActionsPerServer
argument_list|(
name|numActions
argument_list|)
expr_stmt|;
block|}
specifier|final
name|AtomicInteger
name|counter
init|=
name|concurrentCounterCache
operator|.
name|getUnchecked
argument_list|(
name|addr
argument_list|)
decl_stmt|;
name|Call
name|call
init|=
operator|new
name|Call
argument_list|(
name|nextCallId
argument_list|()
argument_list|,
name|md
argument_list|,
name|param
argument_list|,
name|hrc
operator|.
name|cellScanner
argument_list|()
argument_list|,
name|returnType
argument_list|,
name|hrc
operator|.
name|getCallTimeout
argument_list|()
argument_list|,
name|hrc
operator|.
name|getPriority
argument_list|()
argument_list|,
operator|new
name|RpcCallback
argument_list|<
name|Call
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|(
name|Call
name|call
parameter_list|)
block|{
name|counter
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
name|onCallFinished
argument_list|(
name|call
argument_list|,
name|hrc
argument_list|,
name|addr
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|,
name|cs
argument_list|)
decl_stmt|;
name|ConnectionId
name|remoteId
init|=
operator|new
name|ConnectionId
argument_list|(
name|ticket
argument_list|,
name|md
operator|.
name|getService
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|int
name|count
init|=
name|counter
operator|.
name|incrementAndGet
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|count
operator|>
name|maxConcurrentCallsPerServer
condition|)
block|{
throw|throw
operator|new
name|ServerTooBusyException
argument_list|(
name|addr
argument_list|,
name|count
argument_list|)
throw|;
block|}
name|cs
operator|.
name|setConcurrentCallsPerServer
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|T
name|connection
init|=
name|getConnection
argument_list|(
name|remoteId
argument_list|)
decl_stmt|;
name|connection
operator|.
name|sendRequest
argument_list|(
name|call
argument_list|,
name|hrc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|call
operator|.
name|setException
argument_list|(
name|toIOE
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|InetSocketAddress
name|createAddr
parameter_list|(
name|ServerName
name|sn
parameter_list|)
throws|throws
name|UnknownHostException
block|{
name|InetSocketAddress
name|addr
init|=
operator|new
name|InetSocketAddress
argument_list|(
name|sn
operator|.
name|getHostname
argument_list|()
argument_list|,
name|sn
operator|.
name|getPort
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
operator|.
name|isUnresolved
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnknownHostException
argument_list|(
literal|"can not resolve "
operator|+
name|sn
operator|.
name|getServerName
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|addr
return|;
block|}
comment|/**    * Interrupt the connections to the given ip:port server. This should be called if the server is    * known as actually dead. This will not prevent current operation to be retried, and, depending    * on their own behavior, they may retry on the same server. This can be a feature, for example at    * startup. In any case, they're likely to get connection refused (if the process died) or no    * route to host: i.e. their next retries should be faster and with a safe exception.    */
annotation|@
name|Override
specifier|public
name|void
name|cancelConnections
parameter_list|(
name|ServerName
name|sn
parameter_list|)
block|{
synchronized|synchronized
init|(
name|connections
init|)
block|{
for|for
control|(
name|T
name|connection
range|:
name|connections
operator|.
name|values
argument_list|()
control|)
block|{
name|ConnectionId
name|remoteId
init|=
name|connection
operator|.
name|remoteId
argument_list|()
decl_stmt|;
if|if
condition|(
name|remoteId
operator|.
name|address
operator|.
name|getPort
argument_list|()
operator|==
name|sn
operator|.
name|getPort
argument_list|()
operator|&&
name|remoteId
operator|.
name|address
operator|.
name|getHostName
argument_list|()
operator|.
name|equals
argument_list|(
name|sn
operator|.
name|getHostname
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"The server on "
operator|+
name|sn
operator|.
name|toString
argument_list|()
operator|+
literal|" is dead - stopping the connection "
operator|+
name|connection
operator|.
name|remoteId
argument_list|)
expr_stmt|;
name|connections
operator|.
name|removeValue
argument_list|(
name|remoteId
argument_list|,
name|connection
argument_list|)
expr_stmt|;
name|connection
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Configure an hbase rpccontroller    * @param controller to configure    * @param channelOperationTimeout timeout for operation    * @return configured controller    */
specifier|static
name|HBaseRpcController
name|configureHBaseRpcController
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|int
name|channelOperationTimeout
parameter_list|)
block|{
name|HBaseRpcController
name|hrc
decl_stmt|;
if|if
condition|(
name|controller
operator|!=
literal|null
operator|&&
name|controller
operator|instanceof
name|HBaseRpcController
condition|)
block|{
name|hrc
operator|=
operator|(
name|HBaseRpcController
operator|)
name|controller
expr_stmt|;
if|if
condition|(
operator|!
name|hrc
operator|.
name|hasCallTimeout
argument_list|()
condition|)
block|{
name|hrc
operator|.
name|setCallTimeout
argument_list|(
name|channelOperationTimeout
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|hrc
operator|=
operator|new
name|HBaseRpcControllerImpl
argument_list|()
expr_stmt|;
name|hrc
operator|.
name|setCallTimeout
argument_list|(
name|channelOperationTimeout
argument_list|)
expr_stmt|;
block|}
return|return
name|hrc
return|;
block|}
specifier|protected
specifier|abstract
name|void
name|closeInternal
parameter_list|()
function_decl|;
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Stopping rpc client"
argument_list|)
expr_stmt|;
block|}
name|Collection
argument_list|<
name|T
argument_list|>
name|connToClose
decl_stmt|;
synchronized|synchronized
init|(
name|connections
init|)
block|{
if|if
condition|(
operator|!
name|running
condition|)
block|{
return|return;
block|}
name|running
operator|=
literal|false
expr_stmt|;
name|connToClose
operator|=
name|connections
operator|.
name|values
argument_list|()
expr_stmt|;
name|connections
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|cleanupIdleConnectionTask
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|T
name|conn
range|:
name|connToClose
control|)
block|{
name|conn
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
name|closeInternal
argument_list|()
expr_stmt|;
for|for
control|(
name|T
name|conn
range|:
name|connToClose
control|)
block|{
name|conn
operator|.
name|cleanupConnection
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|BlockingRpcChannel
name|createBlockingRpcChannel
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|,
specifier|final
name|User
name|ticket
parameter_list|,
name|int
name|rpcTimeout
parameter_list|)
throws|throws
name|UnknownHostException
block|{
return|return
operator|new
name|BlockingRpcChannelImplementation
argument_list|(
name|this
argument_list|,
name|createAddr
argument_list|(
name|sn
argument_list|)
argument_list|,
name|ticket
argument_list|,
name|rpcTimeout
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RpcChannel
name|createRpcChannel
parameter_list|(
name|ServerName
name|sn
parameter_list|,
name|User
name|user
parameter_list|,
name|int
name|rpcTimeout
parameter_list|)
throws|throws
name|UnknownHostException
block|{
return|return
operator|new
name|RpcChannelImplementation
argument_list|(
name|this
argument_list|,
name|createAddr
argument_list|(
name|sn
argument_list|)
argument_list|,
name|user
argument_list|,
name|rpcTimeout
argument_list|)
return|;
block|}
specifier|private
specifier|static
class|class
name|AbstractRpcChannel
block|{
specifier|protected
specifier|final
name|InetSocketAddress
name|addr
decl_stmt|;
specifier|protected
specifier|final
name|AbstractRpcClient
argument_list|<
name|?
argument_list|>
name|rpcClient
decl_stmt|;
specifier|protected
specifier|final
name|User
name|ticket
decl_stmt|;
specifier|protected
specifier|final
name|int
name|rpcTimeout
decl_stmt|;
specifier|protected
name|AbstractRpcChannel
parameter_list|(
name|AbstractRpcClient
argument_list|<
name|?
argument_list|>
name|rpcClient
parameter_list|,
name|InetSocketAddress
name|addr
parameter_list|,
name|User
name|ticket
parameter_list|,
name|int
name|rpcTimeout
parameter_list|)
block|{
name|this
operator|.
name|addr
operator|=
name|addr
expr_stmt|;
name|this
operator|.
name|rpcClient
operator|=
name|rpcClient
expr_stmt|;
name|this
operator|.
name|ticket
operator|=
name|ticket
expr_stmt|;
name|this
operator|.
name|rpcTimeout
operator|=
name|rpcTimeout
expr_stmt|;
block|}
comment|/**      * Configure an rpc controller      * @param controller to configure      * @return configured rpc controller      */
specifier|protected
name|HBaseRpcController
name|configureRpcController
parameter_list|(
name|RpcController
name|controller
parameter_list|)
block|{
name|HBaseRpcController
name|hrc
decl_stmt|;
comment|// TODO: Ideally we should not use an RpcController other than HBaseRpcController at client
comment|// side. And now we may use ServerRpcController.
if|if
condition|(
name|controller
operator|!=
literal|null
operator|&&
name|controller
operator|instanceof
name|HBaseRpcController
condition|)
block|{
name|hrc
operator|=
operator|(
name|HBaseRpcController
operator|)
name|controller
expr_stmt|;
if|if
condition|(
operator|!
name|hrc
operator|.
name|hasCallTimeout
argument_list|()
condition|)
block|{
name|hrc
operator|.
name|setCallTimeout
argument_list|(
name|rpcTimeout
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|hrc
operator|=
operator|new
name|HBaseRpcControllerImpl
argument_list|()
expr_stmt|;
name|hrc
operator|.
name|setCallTimeout
argument_list|(
name|rpcTimeout
argument_list|)
expr_stmt|;
block|}
return|return
name|hrc
return|;
block|}
block|}
comment|/**    * Blocking rpc channel that goes via hbase rpc.    */
annotation|@
name|VisibleForTesting
specifier|public
specifier|static
class|class
name|BlockingRpcChannelImplementation
extends|extends
name|AbstractRpcChannel
implements|implements
name|BlockingRpcChannel
block|{
specifier|protected
name|BlockingRpcChannelImplementation
parameter_list|(
name|AbstractRpcClient
argument_list|<
name|?
argument_list|>
name|rpcClient
parameter_list|,
name|InetSocketAddress
name|addr
parameter_list|,
name|User
name|ticket
parameter_list|,
name|int
name|rpcTimeout
parameter_list|)
block|{
name|super
argument_list|(
name|rpcClient
argument_list|,
name|addr
argument_list|,
name|ticket
argument_list|,
name|rpcTimeout
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Message
name|callBlockingMethod
parameter_list|(
name|Descriptors
operator|.
name|MethodDescriptor
name|md
parameter_list|,
name|RpcController
name|controller
parameter_list|,
name|Message
name|param
parameter_list|,
name|Message
name|returnType
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|rpcClient
operator|.
name|callBlockingMethod
argument_list|(
name|md
argument_list|,
name|configureRpcController
argument_list|(
name|controller
argument_list|)
argument_list|,
name|param
argument_list|,
name|returnType
argument_list|,
name|ticket
argument_list|,
name|addr
argument_list|)
return|;
block|}
block|}
comment|/**    * Async rpc channel that goes via hbase rpc.    */
specifier|public
specifier|static
class|class
name|RpcChannelImplementation
extends|extends
name|AbstractRpcChannel
implements|implements
name|RpcChannel
block|{
specifier|protected
name|RpcChannelImplementation
parameter_list|(
name|AbstractRpcClient
argument_list|<
name|?
argument_list|>
name|rpcClient
parameter_list|,
name|InetSocketAddress
name|addr
parameter_list|,
name|User
name|ticket
parameter_list|,
name|int
name|rpcTimeout
parameter_list|)
throws|throws
name|UnknownHostException
block|{
name|super
argument_list|(
name|rpcClient
argument_list|,
name|addr
argument_list|,
name|ticket
argument_list|,
name|rpcTimeout
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|callMethod
parameter_list|(
name|Descriptors
operator|.
name|MethodDescriptor
name|md
parameter_list|,
name|RpcController
name|controller
parameter_list|,
name|Message
name|param
parameter_list|,
name|Message
name|returnType
parameter_list|,
name|RpcCallback
argument_list|<
name|Message
argument_list|>
name|done
parameter_list|)
block|{
comment|// This method does not throw any exceptions, so the caller must provide a
comment|// HBaseRpcController which is used to pass the exceptions.
name|this
operator|.
name|rpcClient
operator|.
name|callMethod
argument_list|(
name|md
argument_list|,
name|configureRpcController
argument_list|(
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|controller
argument_list|,
literal|"RpcController can not be null for async rpc call"
argument_list|)
argument_list|)
argument_list|,
name|param
argument_list|,
name|returnType
argument_list|,
name|ticket
argument_list|,
name|addr
argument_list|,
name|done
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

