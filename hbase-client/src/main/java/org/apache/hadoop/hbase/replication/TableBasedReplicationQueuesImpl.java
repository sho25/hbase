begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|NotImplementedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Abortable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Delete
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Get
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Put
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ResultScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RowMutations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Scan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|CompareFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
operator|.
name|SingleColumnValueFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_comment
comment|/**  * This class provides an implementation of the ReplicationQueues interface using an HBase table  * "Replication Table". It utilizes the ReplicationTableBase to access the Replication Table.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|TableBasedReplicationQueuesImpl
extends|extends
name|ReplicationTableBase
implements|implements
name|ReplicationQueues
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TableBasedReplicationQueuesImpl
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Common byte values used in replication offset tracking
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|INITIAL_OFFSET_BYTES
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|0L
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|EMPTY_STRING_BYTES
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|""
argument_list|)
decl_stmt|;
specifier|private
name|String
name|serverName
init|=
literal|null
decl_stmt|;
specifier|private
name|byte
index|[]
name|serverNameBytes
init|=
literal|null
decl_stmt|;
comment|// TODO: Only use this variable temporarily. Eventually we want to use HBase to store all
comment|// TODO: replication information
specifier|private
name|ReplicationStateZKBase
name|replicationState
decl_stmt|;
specifier|public
name|TableBasedReplicationQueuesImpl
parameter_list|(
name|ReplicationQueuesArguments
name|args
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|args
operator|.
name|getConf
argument_list|()
argument_list|,
name|args
operator|.
name|getAbortable
argument_list|()
argument_list|,
name|args
operator|.
name|getZk
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|TableBasedReplicationQueuesImpl
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Abortable
name|abort
parameter_list|,
name|ZooKeeperWatcher
name|zkw
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|conf
argument_list|,
name|abort
argument_list|)
expr_stmt|;
name|replicationState
operator|=
operator|new
name|ReplicationStateZKBase
argument_list|(
name|zkw
argument_list|,
name|conf
argument_list|,
name|abort
argument_list|)
block|{}
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|init
parameter_list|(
name|String
name|serverName
parameter_list|)
throws|throws
name|ReplicationException
block|{
name|this
operator|.
name|serverName
operator|=
name|serverName
expr_stmt|;
name|this
operator|.
name|serverNameBytes
operator|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getListOfReplicators
parameter_list|()
block|{
return|return
name|super
operator|.
name|getListOfReplicators
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeQueue
parameter_list|(
name|String
name|queueId
parameter_list|)
block|{
try|try
block|{
name|byte
index|[]
name|rowKey
init|=
name|queueIdToRowKey
argument_list|(
name|queueId
argument_list|)
decl_stmt|;
if|if
condition|(
name|checkQueueExists
argument_list|(
name|queueId
argument_list|)
condition|)
block|{
name|Delete
name|deleteQueue
init|=
operator|new
name|Delete
argument_list|(
name|rowKey
argument_list|)
decl_stmt|;
name|safeQueueUpdate
argument_list|(
name|deleteQueue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No logs were registered for queue id="
operator|+
name|queueId
operator|+
literal|" so no rows were removed "
operator|+
literal|"from the replication table while removing the queue"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|ReplicationException
name|e
parameter_list|)
block|{
name|String
name|errMsg
init|=
literal|"Failed removing queue queueId="
operator|+
name|queueId
decl_stmt|;
name|abortable
operator|.
name|abort
argument_list|(
name|errMsg
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|addLog
parameter_list|(
name|String
name|queueId
parameter_list|,
name|String
name|filename
parameter_list|)
throws|throws
name|ReplicationException
block|{
try|try
init|(
name|Table
name|replicationTable
init|=
name|getOrBlockOnReplicationTable
argument_list|()
init|)
block|{
if|if
condition|(
operator|!
name|checkQueueExists
argument_list|(
name|queueId
argument_list|)
condition|)
block|{
comment|// Each queue will have an Owner, OwnerHistory, and a collection of [WAL:offset] key values
name|Put
name|putNewQueue
init|=
operator|new
name|Put
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|buildQueueRowKey
argument_list|(
name|queueId
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|putNewQueue
operator|.
name|addColumn
argument_list|(
name|CF_QUEUE
argument_list|,
name|COL_QUEUE_OWNER
argument_list|,
name|serverNameBytes
argument_list|)
expr_stmt|;
name|putNewQueue
operator|.
name|addColumn
argument_list|(
name|CF_QUEUE
argument_list|,
name|COL_QUEUE_OWNER_HISTORY
argument_list|,
name|EMPTY_STRING_BYTES
argument_list|)
expr_stmt|;
name|putNewQueue
operator|.
name|addColumn
argument_list|(
name|CF_QUEUE
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|filename
argument_list|)
argument_list|,
name|INITIAL_OFFSET_BYTES
argument_list|)
expr_stmt|;
name|replicationTable
operator|.
name|put
argument_list|(
name|putNewQueue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Otherwise simply add the new log and offset as a new column
name|Put
name|putNewLog
init|=
operator|new
name|Put
argument_list|(
name|queueIdToRowKey
argument_list|(
name|queueId
argument_list|)
argument_list|)
decl_stmt|;
name|putNewLog
operator|.
name|addColumn
argument_list|(
name|CF_QUEUE
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|filename
argument_list|)
argument_list|,
name|INITIAL_OFFSET_BYTES
argument_list|)
expr_stmt|;
name|safeQueueUpdate
argument_list|(
name|putNewLog
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|ReplicationException
name|e
parameter_list|)
block|{
name|String
name|errMsg
init|=
literal|"Failed adding log queueId="
operator|+
name|queueId
operator|+
literal|" filename="
operator|+
name|filename
decl_stmt|;
name|abortable
operator|.
name|abort
argument_list|(
name|errMsg
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeLog
parameter_list|(
name|String
name|queueId
parameter_list|,
name|String
name|filename
parameter_list|)
block|{
try|try
block|{
name|byte
index|[]
name|rowKey
init|=
name|queueIdToRowKey
argument_list|(
name|queueId
argument_list|)
decl_stmt|;
name|Delete
name|delete
init|=
operator|new
name|Delete
argument_list|(
name|rowKey
argument_list|)
decl_stmt|;
name|delete
operator|.
name|addColumns
argument_list|(
name|CF_QUEUE
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|safeQueueUpdate
argument_list|(
name|delete
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|ReplicationException
name|e
parameter_list|)
block|{
name|String
name|errMsg
init|=
literal|"Failed removing log queueId="
operator|+
name|queueId
operator|+
literal|" filename="
operator|+
name|filename
decl_stmt|;
name|abortable
operator|.
name|abort
argument_list|(
name|errMsg
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|setLogPosition
parameter_list|(
name|String
name|queueId
parameter_list|,
name|String
name|filename
parameter_list|,
name|long
name|position
parameter_list|)
block|{
try|try
init|(
name|Table
name|replicationTable
init|=
name|getOrBlockOnReplicationTable
argument_list|()
init|)
block|{
name|byte
index|[]
name|rowKey
init|=
name|queueIdToRowKey
argument_list|(
name|queueId
argument_list|)
decl_stmt|;
comment|// Check that the log exists. addLog() must have been called before setLogPosition().
name|Get
name|checkLogExists
init|=
operator|new
name|Get
argument_list|(
name|rowKey
argument_list|)
decl_stmt|;
name|checkLogExists
operator|.
name|addColumn
argument_list|(
name|CF_QUEUE
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|replicationTable
operator|.
name|exists
argument_list|(
name|checkLogExists
argument_list|)
condition|)
block|{
name|String
name|errMsg
init|=
literal|"Could not set position of non-existent log from queueId="
operator|+
name|queueId
operator|+
literal|", filename="
operator|+
name|filename
decl_stmt|;
name|abortable
operator|.
name|abort
argument_list|(
name|errMsg
argument_list|,
operator|new
name|ReplicationException
argument_list|(
name|errMsg
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Update the log offset if it exists
name|Put
name|walAndOffset
init|=
operator|new
name|Put
argument_list|(
name|rowKey
argument_list|)
decl_stmt|;
name|walAndOffset
operator|.
name|addColumn
argument_list|(
name|CF_QUEUE
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|filename
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|position
argument_list|)
argument_list|)
expr_stmt|;
name|safeQueueUpdate
argument_list|(
name|walAndOffset
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|ReplicationException
name|e
parameter_list|)
block|{
name|String
name|errMsg
init|=
literal|"Failed writing log position queueId="
operator|+
name|queueId
operator|+
literal|"filename="
operator|+
name|filename
operator|+
literal|" position="
operator|+
name|position
decl_stmt|;
name|abortable
operator|.
name|abort
argument_list|(
name|errMsg
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|long
name|getLogPosition
parameter_list|(
name|String
name|queueId
parameter_list|,
name|String
name|filename
parameter_list|)
throws|throws
name|ReplicationException
block|{
try|try
block|{
name|byte
index|[]
name|rowKey
init|=
name|queueIdToRowKey
argument_list|(
name|queueId
argument_list|)
decl_stmt|;
name|Get
name|getOffset
init|=
operator|new
name|Get
argument_list|(
name|rowKey
argument_list|)
decl_stmt|;
name|getOffset
operator|.
name|addColumn
argument_list|(
name|CF_QUEUE
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|Result
name|result
init|=
name|getResultIfOwner
argument_list|(
name|getOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
operator|||
operator|!
name|result
operator|.
name|containsColumn
argument_list|(
name|CF_QUEUE
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|filename
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ReplicationException
argument_list|(
literal|"Could not read empty result while getting log position "
operator|+
literal|"queueId="
operator|+
name|queueId
operator|+
literal|", filename="
operator|+
name|filename
argument_list|)
throw|;
block|}
return|return
name|Bytes
operator|.
name|toLong
argument_list|(
name|result
operator|.
name|getValue
argument_list|(
name|CF_QUEUE
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|filename
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ReplicationException
argument_list|(
literal|"Could not get position in log for queueId="
operator|+
name|queueId
operator|+
literal|", filename="
operator|+
name|filename
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeAllQueues
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|myQueueIds
init|=
name|getAllQueues
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|queueId
range|:
name|myQueueIds
control|)
block|{
name|removeQueue
argument_list|(
name|queueId
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getLogsInQueue
parameter_list|(
name|String
name|queueId
parameter_list|)
block|{
name|String
name|errMsg
init|=
literal|"Failed getting logs in queue queueId="
operator|+
name|queueId
decl_stmt|;
name|byte
index|[]
name|rowKey
init|=
name|queueIdToRowKey
argument_list|(
name|queueId
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|logs
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|Get
name|getQueue
init|=
operator|new
name|Get
argument_list|(
name|rowKey
argument_list|)
decl_stmt|;
name|Result
name|queue
init|=
name|getResultIfOwner
argument_list|(
name|getQueue
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
operator|||
name|queue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|String
name|errMsgLostOwnership
init|=
literal|"Failed getting logs for queue queueId="
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|rowKey
argument_list|)
operator|+
literal|" because the queue was missing or we lost ownership"
decl_stmt|;
name|abortable
operator|.
name|abort
argument_list|(
name|errMsg
argument_list|,
operator|new
name|ReplicationException
argument_list|(
name|errMsgLostOwnership
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|familyMap
init|=
name|queue
operator|.
name|getFamilyMap
argument_list|(
name|CF_QUEUE
argument_list|)
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|cQualifier
range|:
name|familyMap
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|Arrays
operator|.
name|equals
argument_list|(
name|cQualifier
argument_list|,
name|COL_QUEUE_OWNER
argument_list|)
operator|||
name|Arrays
operator|.
name|equals
argument_list|(
name|cQualifier
argument_list|,
name|COL_QUEUE_OWNER_HISTORY
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|logs
operator|.
name|add
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|cQualifier
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|abortable
operator|.
name|abort
argument_list|(
name|errMsg
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|logs
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getAllQueues
parameter_list|()
block|{
return|return
name|getAllQueues
argument_list|(
name|serverName
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getUnClaimedQueueIds
parameter_list|(
name|String
name|regionserver
parameter_list|)
block|{
if|if
condition|(
name|isThisOurRegionServer
argument_list|(
name|regionserver
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
try|try
init|(
name|ResultScanner
name|queuesToClaim
init|=
name|getQueuesBelongingToServer
argument_list|(
name|regionserver
argument_list|)
init|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|res
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Result
name|queue
range|:
name|queuesToClaim
control|)
block|{
name|String
name|rowKey
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|queue
operator|.
name|getRow
argument_list|()
argument_list|)
decl_stmt|;
name|res
operator|.
name|add
argument_list|(
name|rowKey
argument_list|)
expr_stmt|;
block|}
return|return
name|res
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|res
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|String
name|errMsg
init|=
literal|"Failed getUnClaimedQueueIds"
decl_stmt|;
name|abortable
operator|.
name|abort
argument_list|(
name|errMsg
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeReplicatorIfQueueIsEmpty
parameter_list|(
name|String
name|regionserver
parameter_list|)
block|{
comment|// Do nothing here
block|}
annotation|@
name|Override
specifier|public
name|Pair
argument_list|<
name|String
argument_list|,
name|SortedSet
argument_list|<
name|String
argument_list|>
argument_list|>
name|claimQueue
parameter_list|(
name|String
name|regionserver
parameter_list|,
name|String
name|queueId
parameter_list|)
block|{
if|if
condition|(
name|isThisOurRegionServer
argument_list|(
name|regionserver
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
try|try
init|(
name|ResultScanner
name|queuesToClaim
init|=
name|getQueuesBelongingToServer
argument_list|(
name|regionserver
argument_list|)
init|)
block|{
for|for
control|(
name|Result
name|queue
range|:
name|queuesToClaim
control|)
block|{
name|String
name|rowKey
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|queue
operator|.
name|getRow
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rowKey
operator|.
name|equals
argument_list|(
name|queueId
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|attemptToClaimQueue
argument_list|(
name|queue
argument_list|,
name|regionserver
argument_list|)
condition|)
block|{
name|ReplicationQueueInfo
name|replicationQueueInfo
init|=
operator|new
name|ReplicationQueueInfo
argument_list|(
name|rowKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicationState
operator|.
name|peerExists
argument_list|(
name|replicationQueueInfo
operator|.
name|getPeerId
argument_list|()
argument_list|)
condition|)
block|{
name|SortedSet
argument_list|<
name|String
argument_list|>
name|sortedLogs
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|logs
init|=
name|getLogsInQueue
argument_list|(
name|queue
operator|.
name|getRow
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|log
range|:
name|logs
control|)
block|{
name|sortedLogs
operator|.
name|add
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|serverName
operator|+
literal|" has claimed queue "
operator|+
name|rowKey
operator|+
literal|" from "
operator|+
name|regionserver
argument_list|)
expr_stmt|;
return|return
operator|new
name|Pair
argument_list|<>
argument_list|(
name|rowKey
argument_list|,
name|sortedLogs
argument_list|)
return|;
block|}
else|else
block|{
comment|// Delete orphaned queues
name|removeQueue
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|queue
operator|.
name|getRow
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|serverName
operator|+
literal|" has deleted abandoned queue "
operator|+
name|queueId
operator|+
literal|" from "
operator|+
name|regionserver
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|KeeperException
name|e
parameter_list|)
block|{
name|String
name|errMsg
init|=
literal|"Failed claiming queues for regionserver="
operator|+
name|regionserver
decl_stmt|;
name|abortable
operator|.
name|abort
argument_list|(
name|errMsg
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isThisOurRegionServer
parameter_list|(
name|String
name|regionserver
parameter_list|)
block|{
return|return
name|this
operator|.
name|serverName
operator|.
name|equals
argument_list|(
name|regionserver
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addPeerToHFileRefs
parameter_list|(
name|String
name|peerId
parameter_list|)
throws|throws
name|ReplicationException
block|{
comment|// TODO
throw|throw
operator|new
name|NotImplementedException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|removePeerFromHFileRefs
parameter_list|(
name|String
name|peerId
parameter_list|)
block|{
comment|// TODO
throw|throw
operator|new
name|NotImplementedException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addHFileRefs
parameter_list|(
name|String
name|peerId
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|files
parameter_list|)
throws|throws
name|ReplicationException
block|{
comment|// TODO
throw|throw
operator|new
name|NotImplementedException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeHFileRefs
parameter_list|(
name|String
name|peerId
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|files
parameter_list|)
block|{
comment|// TODO
throw|throw
operator|new
name|NotImplementedException
argument_list|()
throw|;
block|}
specifier|private
name|String
name|buildQueueRowKey
parameter_list|(
name|String
name|queueId
parameter_list|)
block|{
return|return
name|buildQueueRowKey
argument_list|(
name|serverName
argument_list|,
name|queueId
argument_list|)
return|;
block|}
comment|/**    * Convenience method that gets the row key of the queue specified by queueId    * @param queueId queueId of a queue in this server    * @return the row key of the queue in the Replication Table    */
specifier|private
name|byte
index|[]
name|queueIdToRowKey
parameter_list|(
name|String
name|queueId
parameter_list|)
block|{
return|return
name|queueIdToRowKey
argument_list|(
name|serverName
argument_list|,
name|queueId
argument_list|)
return|;
block|}
comment|/**    * See safeQueueUpdate(RowMutations mutate)    *    * @param put Row mutation to perform on the queue    */
specifier|private
name|void
name|safeQueueUpdate
parameter_list|(
name|Put
name|put
parameter_list|)
throws|throws
name|ReplicationException
throws|,
name|IOException
block|{
name|RowMutations
name|mutations
init|=
operator|new
name|RowMutations
argument_list|(
name|put
operator|.
name|getRow
argument_list|()
argument_list|)
decl_stmt|;
name|mutations
operator|.
name|add
argument_list|(
name|put
argument_list|)
expr_stmt|;
name|safeQueueUpdate
argument_list|(
name|mutations
argument_list|)
expr_stmt|;
block|}
comment|/**    * See safeQueueUpdate(RowMutations mutate)    *    * @param delete Row mutation to perform on the queue    */
specifier|private
name|void
name|safeQueueUpdate
parameter_list|(
name|Delete
name|delete
parameter_list|)
throws|throws
name|ReplicationException
throws|,
name|IOException
block|{
name|RowMutations
name|mutations
init|=
operator|new
name|RowMutations
argument_list|(
name|delete
operator|.
name|getRow
argument_list|()
argument_list|)
decl_stmt|;
name|mutations
operator|.
name|add
argument_list|(
name|delete
argument_list|)
expr_stmt|;
name|safeQueueUpdate
argument_list|(
name|mutations
argument_list|)
expr_stmt|;
block|}
comment|/**    * Attempt to mutate a given queue in the Replication Table with a checkAndPut on the OWNER column    * of the queue. Abort the server if this checkAndPut fails: which means we have somehow lost    * ownership of the column or an IO Exception has occurred during the transaction.    *    * @param mutate Mutation to perform on a given queue    */
specifier|private
name|void
name|safeQueueUpdate
parameter_list|(
name|RowMutations
name|mutate
parameter_list|)
throws|throws
name|ReplicationException
throws|,
name|IOException
block|{
try|try
init|(
name|Table
name|replicationTable
init|=
name|getOrBlockOnReplicationTable
argument_list|()
init|)
block|{
name|boolean
name|updateSuccess
init|=
name|replicationTable
operator|.
name|checkAndMutate
argument_list|(
name|mutate
operator|.
name|getRow
argument_list|()
argument_list|,
name|CF_QUEUE
argument_list|,
name|COL_QUEUE_OWNER
argument_list|,
name|CompareFilter
operator|.
name|CompareOp
operator|.
name|EQUAL
argument_list|,
name|serverNameBytes
argument_list|,
name|mutate
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|updateSuccess
condition|)
block|{
throw|throw
operator|new
name|ReplicationException
argument_list|(
literal|"Failed to update Replication Table because we lost queue "
operator|+
literal|" ownership"
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Check if the queue specified by queueId is stored in HBase    *    * @param queueId Either raw or reclaimed format of the queueId    * @return Whether the queue is stored in HBase    * @throws IOException    */
specifier|private
name|boolean
name|checkQueueExists
parameter_list|(
name|String
name|queueId
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|Table
name|replicationTable
init|=
name|getOrBlockOnReplicationTable
argument_list|()
init|)
block|{
name|byte
index|[]
name|rowKey
init|=
name|queueIdToRowKey
argument_list|(
name|queueId
argument_list|)
decl_stmt|;
return|return
name|replicationTable
operator|.
name|exists
argument_list|(
operator|new
name|Get
argument_list|(
name|rowKey
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**    * Attempt to claim the given queue with a checkAndPut on the OWNER column. We check that the    * recently killed server is still the OWNER before we claim it.    *    * @param queue The queue that we are trying to claim    * @param originalServer The server that originally owned the queue    * @return Whether we successfully claimed the queue    * @throws IOException    */
specifier|private
name|boolean
name|attemptToClaimQueue
parameter_list|(
name|Result
name|queue
parameter_list|,
name|String
name|originalServer
parameter_list|)
throws|throws
name|IOException
block|{
name|Put
name|putQueueNameAndHistory
init|=
operator|new
name|Put
argument_list|(
name|queue
operator|.
name|getRow
argument_list|()
argument_list|)
decl_stmt|;
name|putQueueNameAndHistory
operator|.
name|addColumn
argument_list|(
name|CF_QUEUE
argument_list|,
name|COL_QUEUE_OWNER
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|serverName
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|newOwnerHistory
init|=
name|buildClaimedQueueHistory
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|queue
operator|.
name|getValue
argument_list|(
name|CF_QUEUE
argument_list|,
name|COL_QUEUE_OWNER_HISTORY
argument_list|)
argument_list|)
argument_list|,
name|originalServer
argument_list|)
decl_stmt|;
name|putQueueNameAndHistory
operator|.
name|addColumn
argument_list|(
name|CF_QUEUE
argument_list|,
name|COL_QUEUE_OWNER_HISTORY
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|newOwnerHistory
argument_list|)
argument_list|)
expr_stmt|;
name|RowMutations
name|claimAndRenameQueue
init|=
operator|new
name|RowMutations
argument_list|(
name|queue
operator|.
name|getRow
argument_list|()
argument_list|)
decl_stmt|;
name|claimAndRenameQueue
operator|.
name|add
argument_list|(
name|putQueueNameAndHistory
argument_list|)
expr_stmt|;
comment|// Attempt to claim ownership for this queue by checking if the current OWNER is the original
comment|// server. If it is not then another RS has already claimed it. If it is we set ourselves as the
comment|// new owner and update the queue's history
try|try
init|(
name|Table
name|replicationTable
init|=
name|getOrBlockOnReplicationTable
argument_list|()
init|)
block|{
name|boolean
name|success
init|=
name|replicationTable
operator|.
name|checkAndMutate
argument_list|(
name|queue
operator|.
name|getRow
argument_list|()
argument_list|,
name|CF_QUEUE
argument_list|,
name|COL_QUEUE_OWNER
argument_list|,
name|CompareFilter
operator|.
name|CompareOp
operator|.
name|EQUAL
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|originalServer
argument_list|)
argument_list|,
name|claimAndRenameQueue
argument_list|)
decl_stmt|;
return|return
name|success
return|;
block|}
block|}
comment|/**    * Attempts to run a Get on some queue. Will only return a non-null result if we currently own    * the queue.    *    * @param get The Get that we want to query    * @return The result of the Get if this server is the owner of the queue. Else it returns null.    * @throws IOException    */
specifier|private
name|Result
name|getResultIfOwner
parameter_list|(
name|Get
name|get
parameter_list|)
throws|throws
name|IOException
block|{
name|Scan
name|scan
init|=
operator|new
name|Scan
argument_list|(
name|get
argument_list|)
decl_stmt|;
comment|// Check if the Get currently contains all columns or only specific columns
if|if
condition|(
name|scan
operator|.
name|getFamilyMap
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Add the OWNER column if the scan is already only over specific columns
name|scan
operator|.
name|addColumn
argument_list|(
name|CF_QUEUE
argument_list|,
name|COL_QUEUE_OWNER
argument_list|)
expr_stmt|;
block|}
name|scan
operator|.
name|setMaxResultSize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|SingleColumnValueFilter
name|checkOwner
init|=
operator|new
name|SingleColumnValueFilter
argument_list|(
name|CF_QUEUE
argument_list|,
name|COL_QUEUE_OWNER
argument_list|,
name|CompareFilter
operator|.
name|CompareOp
operator|.
name|EQUAL
argument_list|,
name|serverNameBytes
argument_list|)
decl_stmt|;
name|scan
operator|.
name|setFilter
argument_list|(
name|checkOwner
argument_list|)
expr_stmt|;
name|ResultScanner
name|scanner
init|=
literal|null
decl_stmt|;
try|try
init|(
name|Table
name|replicationTable
init|=
name|getOrBlockOnReplicationTable
argument_list|()
init|)
block|{
name|scanner
operator|=
name|replicationTable
operator|.
name|getScanner
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|Result
name|result
init|=
name|scanner
operator|.
name|next
argument_list|()
decl_stmt|;
return|return
operator|(
name|result
operator|==
literal|null
operator|||
name|result
operator|.
name|isEmpty
argument_list|()
operator|)
condition|?
literal|null
else|:
name|result
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|scanner
operator|!=
literal|null
condition|)
block|{
name|scanner
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

