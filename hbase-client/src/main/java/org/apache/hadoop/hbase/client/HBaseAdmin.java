begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketTimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Abortable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ClusterStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|DoNotRetryIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HColumnDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MasterNotRunningException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MetaTableAccessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NamespaceDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NotServingRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|RegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|RegionLocations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotDisabledException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotEnabledException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|UnknownRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ZooKeeperConnectionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MetaScanner
operator|.
name|MetaScannerVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MetaScanner
operator|.
name|MetaScannerVisitorBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|DeserializationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|CoprocessorRpcChannel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|MasterCoprocessorRpcChannel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|RegionServerCoprocessorRpcChannel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|RequestConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|AdminService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|CloseRegionRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|CloseRegionResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|CompactRegionRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|FlushRegionRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|GetRegionInfoRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|GetRegionInfoResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|GetRegionInfoResponse
operator|.
name|CompactionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|RollWALWriterRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|RollWALWriterResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|StopServerRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|UpdateConfigurationRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|NameStringPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|ProcedureDescription
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|RegionSpecifier
operator|.
name|RegionSpecifierType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|SnapshotDescription
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|TableSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|AddColumnRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|AssignRegionRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|CreateNamespaceRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|CreateTableRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|DeleteColumnRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|DeleteNamespaceRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|DeleteSnapshotRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|DeleteTableRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|DisableTableRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|DispatchMergingRegionsRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|EnableTableRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|ExecProcedureRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|ExecProcedureResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|GetClusterStatusRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|GetCompletedSnapshotsRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|GetNamespaceDescriptorRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|GetSchemaAlterStatusRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|GetSchemaAlterStatusResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|GetTableDescriptorsRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|GetTableDescriptorsResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|GetTableNamesRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|IsProcedureDoneRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|IsProcedureDoneResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|IsRestoreSnapshotDoneRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|IsRestoreSnapshotDoneResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|IsSnapshotDoneRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|IsSnapshotDoneResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|ListNamespaceDescriptorsRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|ListTableDescriptorsByNamespaceRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|ListTableNamesByNamespaceRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|MajorCompactionTimestampForRegionRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|MajorCompactionTimestampRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|ModifyColumnRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|ModifyNamespaceRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|ModifyTableRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|MoveRegionRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|RestoreSnapshotRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|RestoreSnapshotResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|SetBalancerRunningRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|ShutdownRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|SnapshotRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|SnapshotResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|StopMasterRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|TruncateTableRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|UnassignRegionRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
operator|.
name|QuotaFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
operator|.
name|QuotaRetriever
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
operator|.
name|QuotaSettings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|wal
operator|.
name|FailedLogCloseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|snapshot
operator|.
name|ClientSnapshotDescriptionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|snapshot
operator|.
name|HBaseSnapshotException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|snapshot
operator|.
name|RestoreSnapshotException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|snapshot
operator|.
name|SnapshotCreationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|snapshot
operator|.
name|UnknownSnapshotException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Addressing
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|MasterAddressTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|MetaTableLocator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|ByteString
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|ServiceException
import|;
end_import

begin_comment
comment|/**  * HBaseAdmin is no longer a client API. It is marked InterfaceAudience.Private indicating that  * this is an HBase-internal class as defined in  * https://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/InterfaceClassification.html  * There are no guarantees for backwards source / binary compatibility and methods or class can  * change or go away without deprecation.  * Use {@link Connection#getAdmin()} to obtain an instance of {@link Admin} instead of constructing  * an HBaseAdmin directly.  *  *<p>Connection should be an<i>unmanaged</i> connection obtained via  * {@link ConnectionFactory#createConnection(Configuration)}  *  * @see ConnectionFactory  * @see Connection  * @see Admin  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
class|class
name|HBaseAdmin
implements|implements
name|Admin
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HBaseAdmin
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|ZK_IDENTIFIER_PREFIX
init|=
literal|"hbase-admin-on-"
decl_stmt|;
specifier|private
name|ClusterConnection
name|connection
decl_stmt|;
specifier|private
specifier|volatile
name|Configuration
name|conf
decl_stmt|;
specifier|private
specifier|final
name|long
name|pause
decl_stmt|;
specifier|private
specifier|final
name|int
name|numRetries
decl_stmt|;
comment|// Some operations can take a long time such as disable of big table.
comment|// numRetries is for 'normal' stuff... Multiply by this factor when
comment|// want to wait a long time.
specifier|private
specifier|final
name|int
name|retryLongerMultiplier
decl_stmt|;
specifier|private
name|boolean
name|aborted
decl_stmt|;
specifier|private
name|boolean
name|cleanupConnectionOnClose
init|=
literal|false
decl_stmt|;
comment|// close the connection in close()
specifier|private
name|boolean
name|closed
init|=
literal|false
decl_stmt|;
specifier|private
name|int
name|operationTimeout
decl_stmt|;
specifier|private
name|RpcRetryingCallerFactory
name|rpcCallerFactory
decl_stmt|;
comment|/**    * Constructor.    * See {@link #HBaseAdmin(Connection connection)}    *    * @param c Configuration object. Copied internally.    * @deprecated Constructing HBaseAdmin objects manually has been deprecated.    * Use {@link Connection#getAdmin()} to obtain an instance of {@link Admin} instead.    */
annotation|@
name|Deprecated
specifier|public
name|HBaseAdmin
parameter_list|(
name|Configuration
name|c
parameter_list|)
throws|throws
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
throws|,
name|IOException
block|{
comment|// Will not leak connections, as the new implementation of the constructor
comment|// does not throw exceptions anymore.
name|this
argument_list|(
name|ConnectionManager
operator|.
name|getConnectionInternal
argument_list|(
operator|new
name|Configuration
argument_list|(
name|c
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|cleanupConnectionOnClose
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getOperationTimeout
parameter_list|()
block|{
return|return
name|operationTimeout
return|;
block|}
comment|/**    * Constructor for externally managed Connections.    * The connection to master will be created when required by admin functions.    *    * @param connection The Connection instance to use    * @throws MasterNotRunningException, ZooKeeperConnectionException are not    *  thrown anymore but kept into the interface for backward api compatibility    * @deprecated Constructing HBaseAdmin objects manually has been deprecated.    * Use {@link Connection#getAdmin()} to obtain an instance of {@link Admin} instead.    */
annotation|@
name|Deprecated
specifier|public
name|HBaseAdmin
parameter_list|(
name|Connection
name|connection
parameter_list|)
throws|throws
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
block|{
name|this
argument_list|(
operator|(
name|ClusterConnection
operator|)
name|connection
argument_list|)
expr_stmt|;
block|}
name|HBaseAdmin
parameter_list|(
name|ClusterConnection
name|connection
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|connection
operator|.
name|getConfiguration
argument_list|()
expr_stmt|;
name|this
operator|.
name|connection
operator|=
name|connection
expr_stmt|;
name|this
operator|.
name|pause
operator|=
name|this
operator|.
name|conf
operator|.
name|getLong
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_PAUSE
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_PAUSE
argument_list|)
expr_stmt|;
name|this
operator|.
name|numRetries
operator|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_RETRIES_NUMBER
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_RETRIES_NUMBER
argument_list|)
expr_stmt|;
name|this
operator|.
name|retryLongerMultiplier
operator|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.client.retries.longer.multiplier"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|this
operator|.
name|operationTimeout
operator|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_OPERATION_TIMEOUT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_OPERATION_TIMEOUT
argument_list|)
expr_stmt|;
name|this
operator|.
name|rpcCallerFactory
operator|=
name|RpcRetryingCallerFactory
operator|.
name|instantiate
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|abort
parameter_list|(
name|String
name|why
parameter_list|,
name|Throwable
name|e
parameter_list|)
block|{
comment|// Currently does nothing but throw the passed message and exception
name|this
operator|.
name|aborted
operator|=
literal|true
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|why
argument_list|,
name|e
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isAborted
parameter_list|()
block|{
return|return
name|this
operator|.
name|aborted
return|;
block|}
comment|/** @return HConnection used by this object. */
annotation|@
name|Override
specifier|public
name|HConnection
name|getConnection
parameter_list|()
block|{
return|return
name|connection
return|;
block|}
comment|/** @return - true if the master server is running. Throws an exception    *  otherwise.    * @throws ZooKeeperConnectionException    * @throws MasterNotRunningException    * @deprecated this has been deprecated without a replacement    */
annotation|@
name|Deprecated
specifier|public
name|boolean
name|isMasterRunning
parameter_list|()
throws|throws
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
block|{
return|return
name|connection
operator|.
name|isMasterRunning
argument_list|()
return|;
block|}
comment|/**    * @param tableName Table to check.    * @return True if table exists already.    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|boolean
name|tableExists
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|executeCallable
argument_list|(
operator|new
name|ConnectionCallable
argument_list|<
name|Boolean
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
throws|,
name|IOException
block|{
return|return
name|MetaTableAccessor
operator|.
name|tableExists
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|tableExists
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|tableExists
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|tableExists
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|tableExists
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|HTableDescriptor
index|[]
name|listTables
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|listTables
argument_list|(
operator|(
name|Pattern
operator|)
literal|null
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|HTableDescriptor
index|[]
name|listTables
parameter_list|(
name|Pattern
name|pattern
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|listTables
argument_list|(
name|pattern
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|HTableDescriptor
index|[]
name|listTables
parameter_list|(
name|String
name|regex
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|listTables
argument_list|(
name|Pattern
operator|.
name|compile
argument_list|(
name|regex
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|HTableDescriptor
index|[]
name|listTables
parameter_list|(
specifier|final
name|Pattern
name|pattern
parameter_list|,
specifier|final
name|boolean
name|includeSysTables
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|HTableDescriptor
index|[]
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|HTableDescriptor
index|[]
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
name|GetTableDescriptorsRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildGetTableDescriptorsRequest
argument_list|(
name|pattern
argument_list|,
name|includeSysTables
argument_list|)
decl_stmt|;
return|return
name|ProtobufUtil
operator|.
name|getHTableDescriptorArray
argument_list|(
name|master
operator|.
name|getTableDescriptors
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|HTableDescriptor
index|[]
name|listTables
parameter_list|(
name|String
name|regex
parameter_list|,
name|boolean
name|includeSysTables
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|listTables
argument_list|(
name|Pattern
operator|.
name|compile
argument_list|(
name|regex
argument_list|)
argument_list|,
name|includeSysTables
argument_list|)
return|;
block|}
comment|/**    * List all of the names of userspace tables.    * @return String[] table names    * @throws IOException if a remote or network exception occurs    * @deprecated Use {@link Admin#listTableNames()} instead    */
annotation|@
name|Deprecated
specifier|public
name|String
index|[]
name|getTableNames
parameter_list|()
throws|throws
name|IOException
block|{
name|TableName
index|[]
name|tableNames
init|=
name|listTableNames
argument_list|()
decl_stmt|;
name|String
index|[]
name|result
init|=
operator|new
name|String
index|[
name|tableNames
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tableNames
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|result
index|[
name|i
index|]
operator|=
name|tableNames
index|[
name|i
index|]
operator|.
name|getNameAsString
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * List all of the names of userspace tables matching the given regular expression.    * @param pattern The regular expression to match against    * @return String[] table names    * @throws IOException if a remote or network exception occurs    * @deprecated Use {@link Admin#listTableNames(Pattern)} instead.    */
annotation|@
name|Deprecated
specifier|public
name|String
index|[]
name|getTableNames
parameter_list|(
name|Pattern
name|pattern
parameter_list|)
throws|throws
name|IOException
block|{
name|TableName
index|[]
name|tableNames
init|=
name|listTableNames
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
name|String
index|[]
name|result
init|=
operator|new
name|String
index|[
name|tableNames
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tableNames
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|result
index|[
name|i
index|]
operator|=
name|tableNames
index|[
name|i
index|]
operator|.
name|getNameAsString
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * List all of the names of userspace tables matching the given regular expression.    * @param regex The regular expression to match against    * @return String[] table names    * @throws IOException if a remote or network exception occurs    * @deprecated Use {@link Admin#listTableNames(Pattern)} instead.    */
annotation|@
name|Deprecated
specifier|public
name|String
index|[]
name|getTableNames
parameter_list|(
name|String
name|regex
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getTableNames
argument_list|(
name|Pattern
operator|.
name|compile
argument_list|(
name|regex
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|TableName
index|[]
name|listTableNames
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|listTableNames
argument_list|(
operator|(
name|Pattern
operator|)
literal|null
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|TableName
index|[]
name|listTableNames
parameter_list|(
name|Pattern
name|pattern
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|listTableNames
argument_list|(
name|pattern
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|TableName
index|[]
name|listTableNames
parameter_list|(
name|String
name|regex
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|listTableNames
argument_list|(
name|Pattern
operator|.
name|compile
argument_list|(
name|regex
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|TableName
index|[]
name|listTableNames
parameter_list|(
specifier|final
name|Pattern
name|pattern
parameter_list|,
specifier|final
name|boolean
name|includeSysTables
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|TableName
index|[]
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|TableName
index|[]
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
name|GetTableNamesRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildGetTableNamesRequest
argument_list|(
name|pattern
argument_list|,
name|includeSysTables
argument_list|)
decl_stmt|;
return|return
name|ProtobufUtil
operator|.
name|getTableNameArray
argument_list|(
name|master
operator|.
name|getTableNames
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
operator|.
name|getTableNamesList
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|TableName
index|[]
name|listTableNames
parameter_list|(
specifier|final
name|String
name|regex
parameter_list|,
specifier|final
name|boolean
name|includeSysTables
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|listTableNames
argument_list|(
name|Pattern
operator|.
name|compile
argument_list|(
name|regex
argument_list|)
argument_list|,
name|includeSysTables
argument_list|)
return|;
block|}
comment|/**    * Method for getting the tableDescriptor    * @param tableName as a byte []    * @return the tableDescriptor    * @throws TableNotFoundException    * @throws IOException if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
name|HTableDescriptor
name|getTableDescriptor
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|TableNotFoundException
throws|,
name|IOException
block|{
if|if
condition|(
name|tableName
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|HTableDescriptor
name|htd
init|=
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|HTableDescriptor
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|HTableDescriptor
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
name|GetTableDescriptorsResponse
name|htds
decl_stmt|;
name|GetTableDescriptorsRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildGetTableDescriptorsRequest
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|htds
operator|=
name|master
operator|.
name|getTableDescriptors
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htds
operator|.
name|getTableSchemaList
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|HTableDescriptor
operator|.
name|convert
argument_list|(
name|htds
operator|.
name|getTableSchemaList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
decl_stmt|;
if|if
condition|(
name|htd
operator|!=
literal|null
condition|)
block|{
return|return
name|htd
return|;
block|}
throw|throw
operator|new
name|TableNotFoundException
argument_list|(
name|tableName
operator|.
name|getNameAsString
argument_list|()
argument_list|)
throw|;
block|}
specifier|public
name|HTableDescriptor
name|getTableDescriptor
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|TableNotFoundException
throws|,
name|IOException
block|{
return|return
name|getTableDescriptor
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|long
name|getPauseTime
parameter_list|(
name|int
name|tries
parameter_list|)
block|{
name|int
name|triesCount
init|=
name|tries
decl_stmt|;
if|if
condition|(
name|triesCount
operator|>=
name|HConstants
operator|.
name|RETRY_BACKOFF
operator|.
name|length
condition|)
block|{
name|triesCount
operator|=
name|HConstants
operator|.
name|RETRY_BACKOFF
operator|.
name|length
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|this
operator|.
name|pause
operator|*
name|HConstants
operator|.
name|RETRY_BACKOFF
index|[
name|triesCount
index|]
return|;
block|}
comment|/**    * Creates a new table.    * Synchronous operation.    *    * @param desc table descriptor for table    *    * @throws IllegalArgumentException if the table name is reserved    * @throws MasterNotRunningException if master is not running    * @throws TableExistsException if table already exists (If concurrent    * threads, the table may have been created between test-for-existence    * and attempt-at-creation).    * @throws IOException if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
name|void
name|createTable
parameter_list|(
name|HTableDescriptor
name|desc
parameter_list|)
throws|throws
name|IOException
block|{
name|createTable
argument_list|(
name|desc
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a new table with the specified number of regions.  The start key    * specified will become the end key of the first region of the table, and    * the end key specified will become the start key of the last region of the    * table (the first region has a null start key and the last region has a    * null end key).    *    * BigInteger math will be used to divide the key range specified into    * enough segments to make the required number of total regions.    *    * Synchronous operation.    *    * @param desc table descriptor for table    * @param startKey beginning of key range    * @param endKey end of key range    * @param numRegions the total number of regions to create    *    * @throws IllegalArgumentException if the table name is reserved    * @throws MasterNotRunningException if master is not running    * @throws org.apache.hadoop.hbase.TableExistsException if table already exists (If concurrent    * threads, the table may have been created between test-for-existence    * and attempt-at-creation).    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|void
name|createTable
parameter_list|(
name|HTableDescriptor
name|desc
parameter_list|,
name|byte
index|[]
name|startKey
parameter_list|,
name|byte
index|[]
name|endKey
parameter_list|,
name|int
name|numRegions
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|numRegions
operator|<
literal|3
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Must create at least three regions"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|startKey
argument_list|,
name|endKey
argument_list|)
operator|>=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Start key must be smaller than end key"
argument_list|)
throw|;
block|}
if|if
condition|(
name|numRegions
operator|==
literal|3
condition|)
block|{
name|createTable
argument_list|(
name|desc
argument_list|,
operator|new
name|byte
index|[]
index|[]
block|{
name|startKey
block|,
name|endKey
block|}
argument_list|)
expr_stmt|;
return|return;
block|}
name|byte
index|[]
index|[]
name|splitKeys
init|=
name|Bytes
operator|.
name|split
argument_list|(
name|startKey
argument_list|,
name|endKey
argument_list|,
name|numRegions
operator|-
literal|3
argument_list|)
decl_stmt|;
if|if
condition|(
name|splitKeys
operator|==
literal|null
operator|||
name|splitKeys
operator|.
name|length
operator|!=
name|numRegions
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unable to split key range into enough regions"
argument_list|)
throw|;
block|}
name|createTable
argument_list|(
name|desc
argument_list|,
name|splitKeys
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a new table with an initial set of empty regions defined by the    * specified split keys.  The total number of regions created will be the    * number of split keys plus one. Synchronous operation.    * Note : Avoid passing empty split key.    *    * @param desc table descriptor for table    * @param splitKeys array of split keys for the initial regions of the table    *    * @throws IllegalArgumentException if the table name is reserved, if the split keys    * are repeated and if the split key has empty byte array.    * @throws MasterNotRunningException if master is not running    * @throws org.apache.hadoop.hbase.TableExistsException if table already exists (If concurrent    * threads, the table may have been created between test-for-existence    * and attempt-at-creation).    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|void
name|createTable
parameter_list|(
specifier|final
name|HTableDescriptor
name|desc
parameter_list|,
name|byte
index|[]
index|[]
name|splitKeys
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|createTableAsync
argument_list|(
name|desc
argument_list|,
name|splitKeys
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SocketTimeoutException
name|ste
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Creating "
operator|+
name|desc
operator|.
name|getTableName
argument_list|()
operator|+
literal|" took too long"
argument_list|,
name|ste
argument_list|)
expr_stmt|;
block|}
name|int
name|numRegs
init|=
operator|(
name|splitKeys
operator|==
literal|null
condition|?
literal|1
else|:
name|splitKeys
operator|.
name|length
operator|+
literal|1
operator|)
operator|*
name|desc
operator|.
name|getRegionReplication
argument_list|()
decl_stmt|;
name|int
name|prevRegCount
init|=
literal|0
decl_stmt|;
name|boolean
name|tableWasEnabled
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
name|this
operator|.
name|numRetries
operator|*
name|this
operator|.
name|retryLongerMultiplier
condition|;
operator|++
name|tries
control|)
block|{
if|if
condition|(
name|tableWasEnabled
condition|)
block|{
comment|// Wait all table regions comes online
specifier|final
name|AtomicInteger
name|actualRegCount
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|MetaScannerVisitor
name|visitor
init|=
operator|new
name|MetaScannerVisitorBase
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|processRow
parameter_list|(
name|Result
name|rowResult
parameter_list|)
throws|throws
name|IOException
block|{
name|RegionLocations
name|list
init|=
name|MetaTableAccessor
operator|.
name|getRegionLocations
argument_list|(
name|rowResult
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No serialized HRegionInfo in "
operator|+
name|rowResult
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|HRegionLocation
name|l
init|=
name|list
operator|.
name|getRegionLocation
argument_list|()
decl_stmt|;
if|if
condition|(
name|l
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|l
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getTable
argument_list|()
operator|.
name|equals
argument_list|(
name|desc
operator|.
name|getTableName
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|l
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isOffline
argument_list|()
operator|||
name|l
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isSplit
argument_list|()
condition|)
return|return
literal|true
return|;
name|HRegionLocation
index|[]
name|locations
init|=
name|list
operator|.
name|getRegionLocations
argument_list|()
decl_stmt|;
for|for
control|(
name|HRegionLocation
name|location
range|:
name|locations
control|)
block|{
if|if
condition|(
name|location
operator|==
literal|null
condition|)
continue|continue;
name|ServerName
name|serverName
init|=
name|location
operator|.
name|getServerName
argument_list|()
decl_stmt|;
comment|// Make sure that regions are assigned to server
if|if
condition|(
name|serverName
operator|!=
literal|null
operator|&&
name|serverName
operator|.
name|getHostAndPort
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|actualRegCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
decl_stmt|;
name|MetaScanner
operator|.
name|metaScan
argument_list|(
name|connection
argument_list|,
name|visitor
argument_list|,
name|desc
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|actualRegCount
operator|.
name|get
argument_list|()
operator|<
name|numRegs
condition|)
block|{
if|if
condition|(
name|tries
operator|==
name|this
operator|.
name|numRetries
operator|*
name|this
operator|.
name|retryLongerMultiplier
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|RegionOfflineException
argument_list|(
literal|"Only "
operator|+
name|actualRegCount
operator|.
name|get
argument_list|()
operator|+
literal|" of "
operator|+
name|numRegs
operator|+
literal|" regions are online; retries exhausted."
argument_list|)
throw|;
block|}
try|try
block|{
comment|// Sleep
name|Thread
operator|.
name|sleep
argument_list|(
name|getPauseTime
argument_list|(
name|tries
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InterruptedIOException
argument_list|(
literal|"Interrupted when opening"
operator|+
literal|" regions; "
operator|+
name|actualRegCount
operator|.
name|get
argument_list|()
operator|+
literal|" of "
operator|+
name|numRegs
operator|+
literal|" regions processed so far"
argument_list|)
throw|;
block|}
if|if
condition|(
name|actualRegCount
operator|.
name|get
argument_list|()
operator|>
name|prevRegCount
condition|)
block|{
comment|// Making progress
name|prevRegCount
operator|=
name|actualRegCount
operator|.
name|get
argument_list|()
expr_stmt|;
name|tries
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
return|return;
block|}
block|}
else|else
block|{
try|try
block|{
name|tableWasEnabled
operator|=
name|isTableAvailable
argument_list|(
name|desc
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TableNotFoundException
name|tnfe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Table "
operator|+
name|desc
operator|.
name|getTableName
argument_list|()
operator|+
literal|" was not enabled, sleeping, still "
operator|+
name|numRetries
operator|+
literal|" retries left"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tableWasEnabled
condition|)
block|{
comment|// no we will scan meta to ensure all regions are online
name|tries
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
comment|// Sleep
name|Thread
operator|.
name|sleep
argument_list|(
name|getPauseTime
argument_list|(
name|tries
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InterruptedIOException
argument_list|(
literal|"Interrupted when waiting"
operator|+
literal|" for table to be enabled; meta scan was done"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
throw|throw
operator|new
name|TableNotEnabledException
argument_list|(
literal|"Retries exhausted while still waiting for table: "
operator|+
name|desc
operator|.
name|getTableName
argument_list|()
operator|+
literal|" to be enabled"
argument_list|)
throw|;
block|}
comment|/**    * Creates a new table but does not block and wait for it to come online.    * Asynchronous operation.  To check if the table exists, use    * {@link #isTableAvailable} -- it is not safe to create an HTable    * instance to this table before it is available.    * Note : Avoid passing empty split key.    * @param desc table descriptor for table    *    * @throws IllegalArgumentException Bad table name, if the split keys    * are repeated and if the split key has empty byte array.    * @throws MasterNotRunningException if master is not running    * @throws org.apache.hadoop.hbase.TableExistsException if table already exists (If concurrent    * threads, the table may have been created between test-for-existence    * and attempt-at-creation).    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|void
name|createTableAsync
parameter_list|(
specifier|final
name|HTableDescriptor
name|desc
parameter_list|,
specifier|final
name|byte
index|[]
index|[]
name|splitKeys
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|desc
operator|.
name|getTableName
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"TableName cannot be null"
argument_list|)
throw|;
block|}
if|if
condition|(
name|splitKeys
operator|!=
literal|null
operator|&&
name|splitKeys
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|splitKeys
argument_list|,
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
expr_stmt|;
comment|// Verify there are no duplicate split keys
name|byte
index|[]
name|lastKey
init|=
literal|null
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|splitKey
range|:
name|splitKeys
control|)
block|{
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|splitKey
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|)
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Empty split key must not be passed in the split keys."
argument_list|)
throw|;
block|}
if|if
condition|(
name|lastKey
operator|!=
literal|null
operator|&&
name|Bytes
operator|.
name|equals
argument_list|(
name|splitKey
argument_list|,
name|lastKey
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"All split keys must be unique, "
operator|+
literal|"found duplicate: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|splitKey
argument_list|)
operator|+
literal|", "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|lastKey
argument_list|)
argument_list|)
throw|;
block|}
name|lastKey
operator|=
name|splitKey
expr_stmt|;
block|}
block|}
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Void
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
name|CreateTableRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildCreateTableRequest
argument_list|(
name|desc
argument_list|,
name|splitKeys
argument_list|)
decl_stmt|;
name|master
operator|.
name|createTable
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|deleteTable
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|deleteTable
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|deleteTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|deleteTable
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Deletes a table.    * Synchronous operation.    *    * @param tableName name of table to delete    * @throws IOException if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
name|void
name|deleteTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|tableExists
init|=
literal|true
decl_stmt|;
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Void
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
name|DeleteTableRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildDeleteTableRequest
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|master
operator|.
name|deleteTable
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|int
name|failures
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
operator|(
name|this
operator|.
name|numRetries
operator|*
name|this
operator|.
name|retryLongerMultiplier
operator|)
condition|;
name|tries
operator|++
control|)
block|{
try|try
block|{
name|tableExists
operator|=
name|tableExists
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tableExists
condition|)
break|break;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|failures
operator|++
expr_stmt|;
if|if
condition|(
name|failures
operator|>=
name|numRetries
operator|-
literal|1
condition|)
block|{
comment|// no more tries left
if|if
condition|(
name|ex
operator|instanceof
name|RemoteException
condition|)
block|{
throw|throw
operator|(
operator|(
name|RemoteException
operator|)
name|ex
operator|)
operator|.
name|unwrapRemoteException
argument_list|()
throw|;
block|}
else|else
block|{
throw|throw
name|ex
throw|;
block|}
block|}
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|getPauseTime
argument_list|(
name|tries
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InterruptedIOException
argument_list|(
literal|"Interrupted when waiting"
operator|+
literal|" for table to be deleted"
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|tableExists
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Retries exhausted, it took too long to wait"
operator|+
literal|" for the table "
operator|+
name|tableName
operator|+
literal|" to be deleted."
argument_list|)
throw|;
block|}
comment|// Delete cached information to prevent clients from using old locations
name|this
operator|.
name|connection
operator|.
name|clearRegionCache
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleted "
operator|+
name|tableName
argument_list|)
expr_stmt|;
block|}
comment|/**    * Deletes tables matching the passed in pattern and wait on completion.    *    * Warning: Use this method carefully, there is no prompting and the effect is    * immediate. Consider using {@link #listTables(java.lang.String)} and    * {@link #deleteTable(byte[])}    *    * @param regex The regular expression to match table names against    * @return Table descriptors for tables that couldn't be deleted    * @throws IOException    * @see #deleteTables(java.util.regex.Pattern)    * @see #deleteTable(java.lang.String)    */
annotation|@
name|Override
specifier|public
name|HTableDescriptor
index|[]
name|deleteTables
parameter_list|(
name|String
name|regex
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|deleteTables
argument_list|(
name|Pattern
operator|.
name|compile
argument_list|(
name|regex
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Delete tables matching the passed in pattern and wait on completion.    *    * Warning: Use this method carefully, there is no prompting and the effect is    * immediate. Consider using {@link #listTables(java.util.regex.Pattern) } and    * {@link #deleteTable(byte[])}    *    * @param pattern The pattern to match table names against    * @return Table descriptors for tables that couldn't be deleted    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|HTableDescriptor
index|[]
name|deleteTables
parameter_list|(
name|Pattern
name|pattern
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|HTableDescriptor
argument_list|>
name|failed
init|=
operator|new
name|LinkedList
argument_list|<
name|HTableDescriptor
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|HTableDescriptor
name|table
range|:
name|listTables
argument_list|(
name|pattern
argument_list|)
control|)
block|{
try|try
block|{
name|deleteTable
argument_list|(
name|table
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to delete table "
operator|+
name|table
operator|.
name|getTableName
argument_list|()
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|failed
operator|.
name|add
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|failed
operator|.
name|toArray
argument_list|(
operator|new
name|HTableDescriptor
index|[
name|failed
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**    * Truncate a table.    * Synchronous operation.    *    * @param tableName name of table to truncate    * @param preserveSplits True if the splits should be preserved    * @throws IOException if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
name|void
name|truncateTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|boolean
name|preserveSplits
parameter_list|)
throws|throws
name|IOException
block|{
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Void
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
name|TruncateTableRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildTruncateTableRequest
argument_list|(
name|tableName
argument_list|,
name|preserveSplits
argument_list|)
decl_stmt|;
name|master
operator|.
name|truncateTable
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Enable a table.  May timeout.  Use {@link #enableTableAsync(byte[])}    * and {@link #isTableEnabled(byte[])} instead.    * The table has to be in disabled state for it to be enabled.    * @param tableName name of the table    * @throws IOException if a remote or network exception occurs    * There could be couple types of IOException    * TableNotFoundException means the table doesn't exist.    * TableNotDisabledException means the table isn't in disabled state.    * @see #isTableEnabled(byte[])    * @see #disableTable(byte[])    * @see #enableTableAsync(byte[])    */
annotation|@
name|Override
specifier|public
name|void
name|enableTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|enableTableAsync
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
comment|// Wait until all regions are enabled
name|waitUntilTableIsEnabled
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Enabled table "
operator|+
name|tableName
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|enableTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|enableTable
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|enableTable
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|enableTable
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Wait for the table to be enabled and available    * If enabling the table exceeds the retry period, an exception is thrown.    * @param tableName name of the table    * @throws IOException if a remote or network exception occurs or    *    table is not enabled after the retries period.    */
specifier|private
name|void
name|waitUntilTableIsEnabled
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|enabled
init|=
literal|false
decl_stmt|;
name|long
name|start
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
operator|(
name|this
operator|.
name|numRetries
operator|*
name|this
operator|.
name|retryLongerMultiplier
operator|)
condition|;
name|tries
operator|++
control|)
block|{
try|try
block|{
name|enabled
operator|=
name|isTableEnabled
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TableNotFoundException
name|tnfe
parameter_list|)
block|{
comment|// wait for table to be created
name|enabled
operator|=
literal|false
expr_stmt|;
block|}
name|enabled
operator|=
name|enabled
operator|&&
name|isTableAvailable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
if|if
condition|(
name|enabled
condition|)
block|{
break|break;
block|}
name|long
name|sleep
init|=
name|getPauseTime
argument_list|(
name|tries
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sleeping= "
operator|+
name|sleep
operator|+
literal|"ms, waiting for all regions to be "
operator|+
literal|"enabled in "
operator|+
name|tableName
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleep
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// Do this conversion rather than let it out because do not want to
comment|// change the method signature.
throw|throw
operator|(
name|InterruptedIOException
operator|)
operator|new
name|InterruptedIOException
argument_list|(
literal|"Interrupted"
argument_list|)
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|enabled
condition|)
block|{
name|long
name|msec
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|-
name|start
decl_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Table '"
operator|+
name|tableName
operator|+
literal|"' not yet enabled, after "
operator|+
name|msec
operator|+
literal|"ms."
argument_list|)
throw|;
block|}
block|}
comment|/**    * Brings a table on-line (enables it).  Method returns immediately though    * enable of table may take some time to complete, especially if the table    * is large (All regions are opened as part of enabling process).  Check    * {@link #isTableEnabled(byte[])} to learn when table is fully online.  If    * table is taking too long to online, check server logs.    * @param tableName    * @throws IOException    * @since 0.90.0    */
annotation|@
name|Override
specifier|public
name|void
name|enableTableAsync
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|TableName
operator|.
name|isLegalFullyQualifiedTableName
argument_list|(
name|tableName
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Void
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Started enable of "
operator|+
name|tableName
argument_list|)
expr_stmt|;
name|EnableTableRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildEnableTableRequest
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|master
operator|.
name|enableTable
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|enableTableAsync
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|enableTable
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|enableTableAsync
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|enableTableAsync
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Enable tables matching the passed in pattern and wait on completion.    *    * Warning: Use this method carefully, there is no prompting and the effect is    * immediate. Consider using {@link #listTables(java.lang.String)} and    * {@link #enableTable(byte[])}    *    * @param regex The regular expression to match table names against    * @throws IOException    * @see #enableTables(java.util.regex.Pattern)    * @see #enableTable(java.lang.String)    */
annotation|@
name|Override
specifier|public
name|HTableDescriptor
index|[]
name|enableTables
parameter_list|(
name|String
name|regex
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|enableTables
argument_list|(
name|Pattern
operator|.
name|compile
argument_list|(
name|regex
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Enable tables matching the passed in pattern and wait on completion.    *    * Warning: Use this method carefully, there is no prompting and the effect is    * immediate. Consider using {@link #listTables(java.util.regex.Pattern) } and    * {@link #enableTable(byte[])}    *    * @param pattern The pattern to match table names against    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|HTableDescriptor
index|[]
name|enableTables
parameter_list|(
name|Pattern
name|pattern
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|HTableDescriptor
argument_list|>
name|failed
init|=
operator|new
name|LinkedList
argument_list|<
name|HTableDescriptor
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|HTableDescriptor
name|table
range|:
name|listTables
argument_list|(
name|pattern
argument_list|)
control|)
block|{
if|if
condition|(
name|isTableDisabled
argument_list|(
name|table
operator|.
name|getTableName
argument_list|()
argument_list|)
condition|)
block|{
try|try
block|{
name|enableTable
argument_list|(
name|table
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to enable table "
operator|+
name|table
operator|.
name|getTableName
argument_list|()
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|failed
operator|.
name|add
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|failed
operator|.
name|toArray
argument_list|(
operator|new
name|HTableDescriptor
index|[
name|failed
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**    * Starts the disable of a table.  If it is being served, the master    * will tell the servers to stop serving it.  This method returns immediately.    * The disable of a table can take some time if the table is large (all    * regions are closed as part of table disable operation).    * Call {@link #isTableDisabled(byte[])} to check for when disable completes.    * If table is taking too long to online, check server logs.    * @param tableName name of table    * @throws IOException if a remote or network exception occurs    * @see #isTableDisabled(byte[])    * @see #isTableEnabled(byte[])    * @since 0.90.0    */
annotation|@
name|Override
specifier|public
name|void
name|disableTableAsync
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|TableName
operator|.
name|isLegalFullyQualifiedTableName
argument_list|(
name|tableName
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Void
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Started disable of "
operator|+
name|tableName
argument_list|)
expr_stmt|;
name|DisableTableRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildDisableTableRequest
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|master
operator|.
name|disableTable
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|disableTableAsync
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|disableTableAsync
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|disableTableAsync
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|disableTableAsync
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Disable table and wait on completion.  May timeout eventually.  Use    * {@link #disableTableAsync(byte[])} and {@link #isTableDisabled(String)}    * instead.    * The table has to be in enabled state for it to be disabled.    * @param tableName    * @throws IOException    * There could be couple types of IOException    * TableNotFoundException means the table doesn't exist.    * TableNotEnabledException means the table isn't in enabled state.    */
annotation|@
name|Override
specifier|public
name|void
name|disableTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|disableTableAsync
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
comment|// Wait until table is disabled
name|boolean
name|disabled
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
name|tries
operator|<
operator|(
name|this
operator|.
name|numRetries
operator|*
name|this
operator|.
name|retryLongerMultiplier
operator|)
condition|;
name|tries
operator|++
control|)
block|{
name|disabled
operator|=
name|isTableDisabled
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
if|if
condition|(
name|disabled
condition|)
block|{
break|break;
block|}
name|long
name|sleep
init|=
name|getPauseTime
argument_list|(
name|tries
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sleeping= "
operator|+
name|sleep
operator|+
literal|"ms, waiting for all regions to be "
operator|+
literal|"disabled in "
operator|+
name|tableName
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleep
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// Do this conversion rather than let it out because do not want to
comment|// change the method signature.
throw|throw
operator|(
name|InterruptedIOException
operator|)
operator|new
name|InterruptedIOException
argument_list|(
literal|"Interrupted"
argument_list|)
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|disabled
condition|)
block|{
throw|throw
operator|new
name|RegionException
argument_list|(
literal|"Retries exhausted, it took too long to wait"
operator|+
literal|" for the table "
operator|+
name|tableName
operator|+
literal|" to be disabled."
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Disabled "
operator|+
name|tableName
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|disableTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|disableTable
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|disableTable
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|disableTable
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Disable tables matching the passed in pattern and wait on completion.    *    * Warning: Use this method carefully, there is no prompting and the effect is    * immediate. Consider using {@link #listTables(java.lang.String)} and    * {@link #disableTable(byte[])}    *    * @param regex The regular expression to match table names against    * @return Table descriptors for tables that couldn't be disabled    * @throws IOException    * @see #disableTables(java.util.regex.Pattern)    * @see #disableTable(java.lang.String)    */
annotation|@
name|Override
specifier|public
name|HTableDescriptor
index|[]
name|disableTables
parameter_list|(
name|String
name|regex
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|disableTables
argument_list|(
name|Pattern
operator|.
name|compile
argument_list|(
name|regex
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Disable tables matching the passed in pattern and wait on completion.    *    * Warning: Use this method carefully, there is no prompting and the effect is    * immediate. Consider using {@link #listTables(java.util.regex.Pattern) } and    * {@link #disableTable(byte[])}    *    * @param pattern The pattern to match table names against    * @return Table descriptors for tables that couldn't be disabled    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|HTableDescriptor
index|[]
name|disableTables
parameter_list|(
name|Pattern
name|pattern
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|HTableDescriptor
argument_list|>
name|failed
init|=
operator|new
name|LinkedList
argument_list|<
name|HTableDescriptor
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|HTableDescriptor
name|table
range|:
name|listTables
argument_list|(
name|pattern
argument_list|)
control|)
block|{
if|if
condition|(
name|isTableEnabled
argument_list|(
name|table
operator|.
name|getTableName
argument_list|()
argument_list|)
condition|)
block|{
try|try
block|{
name|disableTable
argument_list|(
name|table
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to disable table "
operator|+
name|table
operator|.
name|getTableName
argument_list|()
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|failed
operator|.
name|add
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|failed
operator|.
name|toArray
argument_list|(
operator|new
name|HTableDescriptor
index|[
name|failed
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/*    * Checks whether table exists. If not, throws TableNotFoundException    * @param tableName    */
specifier|private
name|void
name|checkTableExistence
parameter_list|(
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|tableExists
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TableNotFoundException
argument_list|(
name|tableName
argument_list|)
throw|;
block|}
block|}
comment|/**    * @param tableName name of table to check    * @return true if table is on-line    * @throws IOException if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
name|boolean
name|isTableEnabled
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|checkTableExistence
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
return|return
name|executeCallable
argument_list|(
operator|new
name|ConnectionCallable
argument_list|<
name|Boolean
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
throws|,
name|IOException
block|{
name|TableState
name|tableState
init|=
name|MetaTableAccessor
operator|.
name|getTableState
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|tableState
operator|==
literal|null
condition|)
throw|throw
operator|new
name|TableNotFoundException
argument_list|(
name|tableName
argument_list|)
throw|;
return|return
name|tableState
operator|.
name|inStates
argument_list|(
name|TableState
operator|.
name|State
operator|.
name|ENABLED
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isTableEnabled
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isTableEnabled
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isTableEnabled
parameter_list|(
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isTableEnabled
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @param tableName name of table to check    * @return true if table is off-line    * @throws IOException if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
name|boolean
name|isTableDisabled
parameter_list|(
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|checkTableExistence
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
return|return
name|connection
operator|.
name|isTableDisabled
argument_list|(
name|tableName
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isTableDisabled
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isTableDisabled
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isTableDisabled
parameter_list|(
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isTableDisabled
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @param tableName name of table to check    * @return true if all regions of the table are available    * @throws IOException if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
name|boolean
name|isTableAvailable
parameter_list|(
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|connection
operator|.
name|isTableAvailable
argument_list|(
name|tableName
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isTableAvailable
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isTableAvailable
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isTableAvailable
parameter_list|(
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isTableAvailable
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Use this api to check if the table has been created with the specified number of    * splitkeys which was used while creating the given table.    * Note : If this api is used after a table's region gets splitted, the api may return    * false.    * @param tableName    *          name of table to check    * @param splitKeys    *          keys to check if the table has been created with all split keys    * @throws IOException    *           if a remote or network excpetion occurs    */
annotation|@
name|Override
specifier|public
name|boolean
name|isTableAvailable
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|byte
index|[]
index|[]
name|splitKeys
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|connection
operator|.
name|isTableAvailable
argument_list|(
name|tableName
argument_list|,
name|splitKeys
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isTableAvailable
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|,
name|byte
index|[]
index|[]
name|splitKeys
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isTableAvailable
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|splitKeys
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isTableAvailable
parameter_list|(
name|String
name|tableName
parameter_list|,
name|byte
index|[]
index|[]
name|splitKeys
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isTableAvailable
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|splitKeys
argument_list|)
return|;
block|}
comment|/**    * Get the status of alter command - indicates how many regions have received    * the updated schema Asynchronous operation.    *    * @param tableName TableName instance    * @return Pair indicating the number of regions updated Pair.getFirst() is the    *         regions that are yet to be updated Pair.getSecond() is the total number    *         of regions of the table    * @throws IOException    *           if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|getAlterStatus
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
name|GetSchemaAlterStatusRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildGetSchemaAlterStatusRequest
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|GetSchemaAlterStatusResponse
name|ret
init|=
name|master
operator|.
name|getSchemaAlterStatus
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
decl_stmt|;
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|pair
init|=
operator|new
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|ret
operator|.
name|getYetToUpdateRegions
argument_list|()
argument_list|)
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|ret
operator|.
name|getTotalRegions
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|pair
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Get the status of alter command - indicates how many regions have received    * the updated schema Asynchronous operation.    *    * @param tableName    *          name of the table to get the status of    * @return Pair indicating the number of regions updated Pair.getFirst() is the    *         regions that are yet to be updated Pair.getSecond() is the total number    *         of regions of the table    * @throws IOException    *           if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|getAlterStatus
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getAlterStatus
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Add a column to an existing table.    * Asynchronous operation.    *    * @param tableName name of the table to add column to    * @param column column descriptor of column to be added    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|addColumn
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
name|HColumnDescriptor
name|column
parameter_list|)
throws|throws
name|IOException
block|{
name|addColumn
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|column
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a column to an existing table.    * Asynchronous operation.    *    * @param tableName name of the table to add column to    * @param column column descriptor of column to be added    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|addColumn
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|,
name|HColumnDescriptor
name|column
parameter_list|)
throws|throws
name|IOException
block|{
name|addColumn
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|column
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a column to an existing table.    * Asynchronous operation.    *    * @param tableName name of the table to add column to    * @param column column descriptor of column to be added    * @throws IOException if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
name|void
name|addColumn
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|HColumnDescriptor
name|column
parameter_list|)
throws|throws
name|IOException
block|{
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Void
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
name|AddColumnRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildAddColumnRequest
argument_list|(
name|tableName
argument_list|,
name|column
argument_list|)
decl_stmt|;
name|master
operator|.
name|addColumn
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete a column from a table.    * Asynchronous operation.    *    * @param tableName name of table    * @param columnName name of column to be deleted    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|deleteColumn
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|String
name|columnName
parameter_list|)
throws|throws
name|IOException
block|{
name|deleteColumn
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|columnName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete a column from a table.    * Asynchronous operation.    *    * @param tableName name of table    * @param columnName name of column to be deleted    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|deleteColumn
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|,
specifier|final
name|String
name|columnName
parameter_list|)
throws|throws
name|IOException
block|{
name|deleteColumn
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|columnName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete a column from a table.    * Asynchronous operation.    *    * @param tableName name of table    * @param columnName name of column to be deleted    * @throws IOException if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
name|void
name|deleteColumn
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|columnName
parameter_list|)
throws|throws
name|IOException
block|{
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Void
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
name|DeleteColumnRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildDeleteColumnRequest
argument_list|(
name|tableName
argument_list|,
name|columnName
argument_list|)
decl_stmt|;
name|master
operator|.
name|deleteColumn
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Modify an existing column family on a table.    * Asynchronous operation.    *    * @param tableName name of table    * @param descriptor new column descriptor to use    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|modifyColumn
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|,
name|HColumnDescriptor
name|descriptor
parameter_list|)
throws|throws
name|IOException
block|{
name|modifyColumn
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|descriptor
argument_list|)
expr_stmt|;
block|}
comment|/**    * Modify an existing column family on a table.    * Asynchronous operation.    *    * @param tableName name of table    * @param descriptor new column descriptor to use    * @throws IOException if a remote or network exception occurs    */
specifier|public
name|void
name|modifyColumn
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
name|HColumnDescriptor
name|descriptor
parameter_list|)
throws|throws
name|IOException
block|{
name|modifyColumn
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|descriptor
argument_list|)
expr_stmt|;
block|}
comment|/**    * Modify an existing column family on a table.    * Asynchronous operation.    *    * @param tableName name of table    * @param descriptor new column descriptor to use    * @throws IOException if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
name|void
name|modifyColumn
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|HColumnDescriptor
name|descriptor
parameter_list|)
throws|throws
name|IOException
block|{
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Void
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
name|ModifyColumnRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildModifyColumnRequest
argument_list|(
name|tableName
argument_list|,
name|descriptor
argument_list|)
decl_stmt|;
name|master
operator|.
name|modifyColumn
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Close a region. For expert-admins.  Runs close on the regionserver.  The    * master will not be informed of the close.    * @param regionname region name to close    * @param serverName If supplied, we'll use this location rather than    * the one currently in<code>hbase:meta</code>    * @throws IOException if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
name|void
name|closeRegion
parameter_list|(
specifier|final
name|String
name|regionname
parameter_list|,
specifier|final
name|String
name|serverName
parameter_list|)
throws|throws
name|IOException
block|{
name|closeRegion
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|regionname
argument_list|)
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
block|}
comment|/**    * Close a region.  For expert-admins  Runs close on the regionserver.  The    * master will not be informed of the close.    * @param regionname region name to close    * @param serverName The servername of the regionserver.  If passed null we    * will use servername found in the hbase:meta table. A server name    * is made of host, port and startcode.  Here is an example:    *<code> host187.example.com,60020,1289493121758</code>    * @throws IOException if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
name|void
name|closeRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|regionname
parameter_list|,
specifier|final
name|String
name|serverName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|serverName
operator|!=
literal|null
condition|)
block|{
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
init|=
name|MetaTableAccessor
operator|.
name|getRegion
argument_list|(
name|connection
argument_list|,
name|regionname
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
literal|null
operator|||
name|pair
operator|.
name|getFirst
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownRegionException
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionname
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
name|closeRegion
argument_list|(
name|ServerName
operator|.
name|valueOf
argument_list|(
name|serverName
argument_list|)
argument_list|,
name|pair
operator|.
name|getFirst
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
init|=
name|MetaTableAccessor
operator|.
name|getRegion
argument_list|(
name|connection
argument_list|,
name|regionname
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownRegionException
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionname
argument_list|)
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|pair
operator|.
name|getSecond
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoServerForRegionException
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionname
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
name|closeRegion
argument_list|(
name|pair
operator|.
name|getSecond
argument_list|()
argument_list|,
name|pair
operator|.
name|getFirst
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * For expert-admins. Runs close on the regionserver. Closes a region based on    * the encoded region name. The region server name is mandatory. If the    * servername is provided then based on the online regions in the specified    * regionserver the specified region will be closed. The master will not be    * informed of the close. Note that the regionname is the encoded regionname.    *    * @param encodedRegionName    *          The encoded region name; i.e. the hash that makes up the region    *          name suffix: e.g. if regionname is    *<code>TestTable,0094429456,1289497600452.527db22f95c8a9e0116f0cc13c680396.</code>    *          , then the encoded region name is:    *<code>527db22f95c8a9e0116f0cc13c680396</code>.    * @param serverName    *          The servername of the regionserver. A server name is made of host,    *          port and startcode. This is mandatory. Here is an example:    *<code> host187.example.com,60020,1289493121758</code>    * @return true if the region was closed, false if not.    * @throws IOException    *           if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
name|boolean
name|closeRegionWithEncodedRegionName
parameter_list|(
specifier|final
name|String
name|encodedRegionName
parameter_list|,
specifier|final
name|String
name|serverName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
literal|null
operator|==
name|serverName
operator|||
operator|(
literal|""
operator|)
operator|.
name|equals
argument_list|(
name|serverName
operator|.
name|trim
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The servername cannot be null or empty."
argument_list|)
throw|;
block|}
name|ServerName
name|sn
init|=
name|ServerName
operator|.
name|valueOf
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
name|AdminService
operator|.
name|BlockingInterface
name|admin
init|=
name|this
operator|.
name|connection
operator|.
name|getAdmin
argument_list|(
name|sn
argument_list|)
decl_stmt|;
comment|// Close the region without updating zk state.
name|CloseRegionRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildCloseRegionRequest
argument_list|(
name|sn
argument_list|,
name|encodedRegionName
argument_list|)
decl_stmt|;
try|try
block|{
name|CloseRegionResponse
name|response
init|=
name|admin
operator|.
name|closeRegion
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
decl_stmt|;
name|boolean
name|isRegionClosed
init|=
name|response
operator|.
name|getClosed
argument_list|()
decl_stmt|;
if|if
condition|(
literal|false
operator|==
name|isRegionClosed
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Not able to close the region "
operator|+
name|encodedRegionName
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
return|return
name|isRegionClosed
return|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
block|}
comment|/**    * Close a region.  For expert-admins  Runs close on the regionserver.  The    * master will not be informed of the close.    * @param sn    * @param hri    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|void
name|closeRegion
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|,
specifier|final
name|HRegionInfo
name|hri
parameter_list|)
throws|throws
name|IOException
block|{
name|AdminService
operator|.
name|BlockingInterface
name|admin
init|=
name|this
operator|.
name|connection
operator|.
name|getAdmin
argument_list|(
name|sn
argument_list|)
decl_stmt|;
comment|// Close the region without updating zk state.
name|ProtobufUtil
operator|.
name|closeRegion
argument_list|(
name|admin
argument_list|,
name|sn
argument_list|,
name|hri
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get all the online regions on a region server.    */
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|getOnlineRegions
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|)
throws|throws
name|IOException
block|{
name|AdminService
operator|.
name|BlockingInterface
name|admin
init|=
name|this
operator|.
name|connection
operator|.
name|getAdmin
argument_list|(
name|sn
argument_list|)
decl_stmt|;
return|return
name|ProtobufUtil
operator|.
name|getOnlineRegions
argument_list|(
name|admin
argument_list|)
return|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|flush
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|checkTableExists
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
if|if
condition|(
name|isTableDisabled
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Table is disabled: "
operator|+
name|tableName
operator|.
name|getNameAsString
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|execProcedure
argument_list|(
literal|"flush-table-proc"
argument_list|,
name|tableName
operator|.
name|getNameAsString
argument_list|()
argument_list|,
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|flushRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|IOException
block|{
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|regionServerPair
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionServerPair
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown regionname: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionName
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|regionServerPair
operator|.
name|getSecond
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoServerForRegionException
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionName
argument_list|)
argument_list|)
throw|;
block|}
name|flush
argument_list|(
name|regionServerPair
operator|.
name|getSecond
argument_list|()
argument_list|,
name|regionServerPair
operator|.
name|getFirst
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * @deprecated Use {@link #flush(org.apache.hadoop.hbase.TableName)} or {@link #flushRegion    * (byte[])} instead.    */
annotation|@
name|Deprecated
specifier|public
name|void
name|flush
parameter_list|(
specifier|final
name|String
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|flush
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * @deprecated Use {@link #flush(org.apache.hadoop.hbase.TableName)} or {@link #flushRegion    * (byte[])} instead.    */
annotation|@
name|Deprecated
specifier|public
name|void
name|flush
parameter_list|(
specifier|final
name|byte
index|[]
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
try|try
block|{
name|flushRegion
argument_list|(
name|tableNameOrRegionName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|// Unknown region.  Try table.
name|flush
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|flush
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|,
specifier|final
name|HRegionInfo
name|hri
parameter_list|)
throws|throws
name|IOException
block|{
name|AdminService
operator|.
name|BlockingInterface
name|admin
init|=
name|this
operator|.
name|connection
operator|.
name|getAdmin
argument_list|(
name|sn
argument_list|)
decl_stmt|;
name|FlushRegionRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildFlushRegionRequest
argument_list|(
name|hri
operator|.
name|getRegionName
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|admin
operator|.
name|flushRegion
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|compact
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|compact
argument_list|(
name|tableName
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|compactRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|IOException
block|{
name|compactRegion
argument_list|(
name|regionName
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * @deprecated Use {@link #compact(org.apache.hadoop.hbase.TableName)} or {@link #compactRegion    * (byte[])} instead.    */
annotation|@
name|Deprecated
specifier|public
name|void
name|compact
parameter_list|(
specifier|final
name|String
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
block|{
name|compact
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * @deprecated Use {@link #compact(org.apache.hadoop.hbase.TableName)} or {@link #compactRegion    * (byte[])} instead.    */
annotation|@
name|Deprecated
specifier|public
name|void
name|compact
parameter_list|(
specifier|final
name|byte
index|[]
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|compactRegion
argument_list|(
name|tableNameOrRegionName
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|compact
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|compact
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|columnFamily
parameter_list|)
throws|throws
name|IOException
block|{
name|compact
argument_list|(
name|tableName
argument_list|,
name|columnFamily
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|compactRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|byte
index|[]
name|columnFamily
parameter_list|)
throws|throws
name|IOException
block|{
name|compactRegion
argument_list|(
name|regionName
argument_list|,
name|columnFamily
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * @deprecated Use {@link #compact(org.apache.hadoop.hbase.TableName)} or {@link #compactRegion    * (byte[], byte[])} instead.    */
annotation|@
name|Deprecated
specifier|public
name|void
name|compact
parameter_list|(
name|String
name|tableOrRegionName
parameter_list|,
name|String
name|columnFamily
parameter_list|)
throws|throws
name|IOException
block|{
name|compact
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableOrRegionName
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|columnFamily
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * @deprecated Use {@link #compact(org.apache.hadoop.hbase.TableName)} or {@link #compactRegion    * (byte[], byte[])} instead.    */
annotation|@
name|Deprecated
specifier|public
name|void
name|compact
parameter_list|(
specifier|final
name|byte
index|[]
name|tableNameOrRegionName
parameter_list|,
specifier|final
name|byte
index|[]
name|columnFamily
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|compactRegion
argument_list|(
name|tableNameOrRegionName
argument_list|,
name|columnFamily
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|// Bad region, try table
name|compact
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|,
name|columnFamily
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|compactRegionServer
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|,
name|boolean
name|major
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
for|for
control|(
name|HRegionInfo
name|region
range|:
name|getOnlineRegions
argument_list|(
name|sn
argument_list|)
control|)
block|{
name|compact
argument_list|(
name|sn
argument_list|,
name|region
argument_list|,
name|major
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|majorCompact
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|compact
argument_list|(
name|tableName
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|majorCompactRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|IOException
block|{
name|compactRegion
argument_list|(
name|regionName
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * @deprecated Use {@link #majorCompact(org.apache.hadoop.hbase.TableName)} or {@link    * #majorCompactRegion(byte[])} instead.    */
annotation|@
name|Deprecated
specifier|public
name|void
name|majorCompact
parameter_list|(
specifier|final
name|String
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
block|{
name|majorCompact
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * @deprecated Use {@link #majorCompact(org.apache.hadoop.hbase.TableName)} or {@link    * #majorCompactRegion(byte[])} instead.    */
annotation|@
name|Deprecated
specifier|public
name|void
name|majorCompact
parameter_list|(
specifier|final
name|byte
index|[]
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|compactRegion
argument_list|(
name|tableNameOrRegionName
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|// Invalid region, try table
name|compact
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|majorCompact
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|columnFamily
parameter_list|)
throws|throws
name|IOException
block|{
name|compact
argument_list|(
name|tableName
argument_list|,
name|columnFamily
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|majorCompactRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|byte
index|[]
name|columnFamily
parameter_list|)
throws|throws
name|IOException
block|{
name|compactRegion
argument_list|(
name|regionName
argument_list|,
name|columnFamily
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * @deprecated Use {@link #majorCompact(org.apache.hadoop.hbase.TableName,    * byte[])} or {@link #majorCompactRegion(byte[], byte[])} instead.    */
annotation|@
name|Deprecated
specifier|public
name|void
name|majorCompact
parameter_list|(
specifier|final
name|String
name|tableNameOrRegionName
parameter_list|,
specifier|final
name|String
name|columnFamily
parameter_list|)
throws|throws
name|IOException
block|{
name|majorCompact
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|columnFamily
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * @deprecated Use {@link #majorCompact(org.apache.hadoop.hbase.TableName,    * byte[])} or {@link #majorCompactRegion(byte[], byte[])} instead.    */
annotation|@
name|Deprecated
specifier|public
name|void
name|majorCompact
parameter_list|(
specifier|final
name|byte
index|[]
name|tableNameOrRegionName
parameter_list|,
specifier|final
name|byte
index|[]
name|columnFamily
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|compactRegion
argument_list|(
name|tableNameOrRegionName
argument_list|,
name|columnFamily
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|// Invalid region, try table
name|compact
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|,
name|columnFamily
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Compact a table.    * Asynchronous operation.    *    * @param tableName table or region to compact    * @param columnFamily column family within a table or region    * @param major True if we are to do a major compaction.    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException    */
specifier|private
name|void
name|compact
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|columnFamily
parameter_list|,
specifier|final
name|boolean
name|major
parameter_list|)
throws|throws
name|IOException
block|{
name|ZooKeeperWatcher
name|zookeeper
init|=
literal|null
decl_stmt|;
try|try
block|{
name|checkTableExists
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|zookeeper
operator|=
operator|new
name|ZooKeeperWatcher
argument_list|(
name|conf
argument_list|,
name|ZK_IDENTIFIER_PREFIX
operator|+
name|connection
operator|.
name|toString
argument_list|()
argument_list|,
operator|new
name|ThrowableAbortable
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|>
name|pairs
decl_stmt|;
if|if
condition|(
name|TableName
operator|.
name|META_TABLE_NAME
operator|.
name|equals
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|pairs
operator|=
operator|new
name|MetaTableLocator
argument_list|()
operator|.
name|getMetaRegionsAndLocations
argument_list|(
name|zookeeper
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pairs
operator|=
name|MetaTableAccessor
operator|.
name|getTableRegionsAndLocations
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
if|if
condition|(
name|pair
operator|.
name|getFirst
argument_list|()
operator|.
name|isOffline
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|pair
operator|.
name|getSecond
argument_list|()
operator|==
literal|null
condition|)
continue|continue;
try|try
block|{
name|compact
argument_list|(
name|pair
operator|.
name|getSecond
argument_list|()
argument_list|,
name|pair
operator|.
name|getFirst
argument_list|()
argument_list|,
name|major
argument_list|,
name|columnFamily
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotServingRegionException
name|e
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Trying to"
operator|+
operator|(
name|major
condition|?
literal|" major"
else|:
literal|""
operator|)
operator|+
literal|" compact "
operator|+
name|pair
operator|.
name|getFirst
argument_list|()
operator|+
literal|": "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|zookeeper
operator|!=
literal|null
condition|)
block|{
name|zookeeper
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Compact an individual region.    * Asynchronous operation.    *    * @param regionName region to compact    * @param columnFamily column family within a table or region    * @param major True if we are to do a major compaction.    * @throws IOException if a remote or network exception occurs    * @throws InterruptedException    */
specifier|private
name|void
name|compactRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|byte
index|[]
name|columnFamily
parameter_list|,
specifier|final
name|boolean
name|major
parameter_list|)
throws|throws
name|IOException
block|{
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|regionServerPair
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionServerPair
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid region: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionName
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|regionServerPair
operator|.
name|getSecond
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoServerForRegionException
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionName
argument_list|)
argument_list|)
throw|;
block|}
name|compact
argument_list|(
name|regionServerPair
operator|.
name|getSecond
argument_list|()
argument_list|,
name|regionServerPair
operator|.
name|getFirst
argument_list|()
argument_list|,
name|major
argument_list|,
name|columnFamily
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|compact
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|,
specifier|final
name|HRegionInfo
name|hri
parameter_list|,
specifier|final
name|boolean
name|major
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|)
throws|throws
name|IOException
block|{
name|AdminService
operator|.
name|BlockingInterface
name|admin
init|=
name|this
operator|.
name|connection
operator|.
name|getAdmin
argument_list|(
name|sn
argument_list|)
decl_stmt|;
name|CompactRegionRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildCompactRegionRequest
argument_list|(
name|hri
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|major
argument_list|,
name|family
argument_list|)
decl_stmt|;
try|try
block|{
name|admin
operator|.
name|compactRegion
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
block|}
comment|/**    * Move the region<code>r</code> to<code>dest</code>.    * @param encodedRegionName The encoded region name; i.e. the hash that makes    * up the region name suffix: e.g. if regionname is    *<code>TestTable,0094429456,1289497600452.527db22f95c8a9e0116f0cc13c680396.</code>,    * then the encoded region name is:<code>527db22f95c8a9e0116f0cc13c680396</code>.    * @param destServerName The servername of the destination regionserver.  If    * passed the empty byte array we'll assign to a random server.  A server name    * is made of host, port and startcode.  Here is an example:    *<code> host187.example.com,60020,1289493121758</code>    * @throws UnknownRegionException Thrown if we can't find a region named    *<code>encodedRegionName</code>    */
annotation|@
name|Override
specifier|public
name|void
name|move
parameter_list|(
specifier|final
name|byte
index|[]
name|encodedRegionName
parameter_list|,
specifier|final
name|byte
index|[]
name|destServerName
parameter_list|)
throws|throws
name|IOException
block|{
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Void
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
try|try
block|{
name|MoveRegionRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildMoveRegionRequest
argument_list|(
name|encodedRegionName
argument_list|,
name|destServerName
argument_list|)
decl_stmt|;
name|master
operator|.
name|moveRegion
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|de
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Could not parse destination server name: "
operator|+
name|de
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ServiceException
argument_list|(
operator|new
name|DoNotRetryIOException
argument_list|(
name|de
argument_list|)
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param regionName    *          Region name to assign.    * @throws MasterNotRunningException    * @throws ZooKeeperConnectionException    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|void
name|assign
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
throws|,
name|IOException
block|{
specifier|final
name|byte
index|[]
name|toBeAssigned
init|=
name|getRegionName
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Void
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
name|AssignRegionRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildAssignRegionRequest
argument_list|(
name|toBeAssigned
argument_list|)
decl_stmt|;
name|master
operator|.
name|assignRegion
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Unassign a region from current hosting regionserver.  Region will then be    * assigned to a regionserver chosen at random.  Region could be reassigned    * back to the same server.  Use {@link #move(byte[], byte[])} if you want    * to control the region movement.    * @param regionName Region to unassign. Will clear any existing RegionPlan    * if one found.    * @param force If true, force unassign (Will remove region from    * regions-in-transition too if present. If results in double assignment    * use hbck -fix to resolve. To be used by experts).    * @throws MasterNotRunningException    * @throws ZooKeeperConnectionException    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|void
name|unassign
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|boolean
name|force
parameter_list|)
throws|throws
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
throws|,
name|IOException
block|{
specifier|final
name|byte
index|[]
name|toBeUnassigned
init|=
name|getRegionName
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Void
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
name|UnassignRegionRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildUnassignRegionRequest
argument_list|(
name|toBeUnassigned
argument_list|,
name|force
argument_list|)
decl_stmt|;
name|master
operator|.
name|unassignRegion
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Offline specified region from master's in-memory state. It will not attempt to reassign the    * region as in unassign. This API can be used when a region not served by any region server and    * still online as per Master's in memory state. If this API is incorrectly used on active region    * then master will loose track of that region.    *    * This is a special method that should be used by experts or hbck.    *    * @param regionName    *          Region to offline.    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|void
name|offline
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|IOException
block|{
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Void
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
name|master
operator|.
name|offlineRegion
argument_list|(
literal|null
argument_list|,
name|RequestConverter
operator|.
name|buildOfflineRegionRequest
argument_list|(
name|regionName
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Turn the load balancer on or off.    * @param on If true, enable balancer. If false, disable balancer.    * @param synchronous If true, it waits until current balance() call, if outstanding, to return.    * @return Previous balancer value    */
annotation|@
name|Override
specifier|public
name|boolean
name|setBalancerRunning
parameter_list|(
specifier|final
name|boolean
name|on
parameter_list|,
specifier|final
name|boolean
name|synchronous
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Boolean
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
name|SetBalancerRunningRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildSetBalancerRunningRequest
argument_list|(
name|on
argument_list|,
name|synchronous
argument_list|)
decl_stmt|;
return|return
name|master
operator|.
name|setBalancerRunning
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
operator|.
name|getPrevBalanceValue
argument_list|()
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Invoke the balancer.  Will run the balancer and if regions to move, it will    * go ahead and do the reassignments.  Can NOT run for various reasons.  Check    * logs.    * @return True if balancer ran, false otherwise.    */
annotation|@
name|Override
specifier|public
name|boolean
name|balancer
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Boolean
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|master
operator|.
name|balance
argument_list|(
literal|null
argument_list|,
name|RequestConverter
operator|.
name|buildBalanceRequest
argument_list|()
argument_list|)
operator|.
name|getBalancerRan
argument_list|()
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Enable/Disable the catalog janitor    * @param enable if true enables the catalog janitor    * @return the previous state    * @throws MasterNotRunningException    */
annotation|@
name|Override
specifier|public
name|boolean
name|enableCatalogJanitor
parameter_list|(
specifier|final
name|boolean
name|enable
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Boolean
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|master
operator|.
name|enableCatalogJanitor
argument_list|(
literal|null
argument_list|,
name|RequestConverter
operator|.
name|buildEnableCatalogJanitorRequest
argument_list|(
name|enable
argument_list|)
argument_list|)
operator|.
name|getPrevValue
argument_list|()
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Ask for a scan of the catalog table    * @return the number of entries cleaned    * @throws MasterNotRunningException    */
annotation|@
name|Override
specifier|public
name|int
name|runCatalogScan
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Integer
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Integer
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|master
operator|.
name|runCatalogScan
argument_list|(
literal|null
argument_list|,
name|RequestConverter
operator|.
name|buildCatalogScanRequest
argument_list|()
argument_list|)
operator|.
name|getScanResult
argument_list|()
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Query on the catalog janitor state (Enabled/Disabled?)    * @throws org.apache.hadoop.hbase.MasterNotRunningException    */
annotation|@
name|Override
specifier|public
name|boolean
name|isCatalogJanitorEnabled
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Boolean
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|master
operator|.
name|isCatalogJanitorEnabled
argument_list|(
literal|null
argument_list|,
name|RequestConverter
operator|.
name|buildIsCatalogJanitorEnabledRequest
argument_list|()
argument_list|)
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Merge two regions. Asynchronous operation.    * @param encodedNameOfRegionA encoded name of region a    * @param encodedNameOfRegionB encoded name of region b    * @param forcible true if do a compulsory merge, otherwise we will only merge    *          two adjacent regions    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|void
name|mergeRegions
parameter_list|(
specifier|final
name|byte
index|[]
name|encodedNameOfRegionA
parameter_list|,
specifier|final
name|byte
index|[]
name|encodedNameOfRegionB
parameter_list|,
specifier|final
name|boolean
name|forcible
parameter_list|)
throws|throws
name|IOException
block|{
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
init|=
name|getRegion
argument_list|(
name|encodedNameOfRegionA
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|!=
literal|null
operator|&&
name|pair
operator|.
name|getFirst
argument_list|()
operator|.
name|getReplicaId
argument_list|()
operator|!=
name|HRegionInfo
operator|.
name|DEFAULT_REPLICA_ID
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Can't invoke merge on non-default regions directly"
argument_list|)
throw|;
name|pair
operator|=
name|getRegion
argument_list|(
name|encodedNameOfRegionB
argument_list|)
expr_stmt|;
if|if
condition|(
name|pair
operator|!=
literal|null
operator|&&
name|pair
operator|.
name|getFirst
argument_list|()
operator|.
name|getReplicaId
argument_list|()
operator|!=
name|HRegionInfo
operator|.
name|DEFAULT_REPLICA_ID
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Can't invoke merge on non-default regions directly"
argument_list|)
throw|;
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Void
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
try|try
block|{
name|DispatchMergingRegionsRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildDispatchMergingRegionsRequest
argument_list|(
name|encodedNameOfRegionA
argument_list|,
name|encodedNameOfRegionB
argument_list|,
name|forcible
argument_list|)
decl_stmt|;
name|master
operator|.
name|dispatchMergingRegions
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|de
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Could not parse destination server name: "
operator|+
name|de
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|split
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|split
argument_list|(
name|tableName
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|splitRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|IOException
block|{
name|splitRegion
argument_list|(
name|regionName
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * @deprecated Use {@link #split(org.apache.hadoop.hbase.TableName)} or {@link #splitRegion    * (byte[])} instead.    */
annotation|@
name|Deprecated
specifier|public
name|void
name|split
parameter_list|(
specifier|final
name|String
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|split
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * @deprecated Use {@link #split(org.apache.hadoop.hbase.TableName)} or {@link #splitRegion    * (byte[])} instead.    */
annotation|@
name|Deprecated
specifier|public
name|void
name|split
parameter_list|(
specifier|final
name|byte
index|[]
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|split
argument_list|(
name|tableNameOrRegionName
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|split
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|splitPoint
parameter_list|)
throws|throws
name|IOException
block|{
name|ZooKeeperWatcher
name|zookeeper
init|=
literal|null
decl_stmt|;
try|try
block|{
name|checkTableExists
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|zookeeper
operator|=
operator|new
name|ZooKeeperWatcher
argument_list|(
name|conf
argument_list|,
name|ZK_IDENTIFIER_PREFIX
operator|+
name|connection
operator|.
name|toString
argument_list|()
argument_list|,
operator|new
name|ThrowableAbortable
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|>
name|pairs
decl_stmt|;
if|if
condition|(
name|TableName
operator|.
name|META_TABLE_NAME
operator|.
name|equals
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|pairs
operator|=
operator|new
name|MetaTableLocator
argument_list|()
operator|.
name|getMetaRegionsAndLocations
argument_list|(
name|zookeeper
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pairs
operator|=
name|MetaTableAccessor
operator|.
name|getTableRegionsAndLocations
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
comment|// May not be a server for a particular row
if|if
condition|(
name|pair
operator|.
name|getSecond
argument_list|()
operator|==
literal|null
condition|)
continue|continue;
name|HRegionInfo
name|r
init|=
name|pair
operator|.
name|getFirst
argument_list|()
decl_stmt|;
comment|// check for parents
if|if
condition|(
name|r
operator|.
name|isSplitParent
argument_list|()
condition|)
continue|continue;
comment|// if a split point given, only split that particular region
if|if
condition|(
name|r
operator|.
name|getReplicaId
argument_list|()
operator|!=
name|HRegionInfo
operator|.
name|DEFAULT_REPLICA_ID
operator|||
operator|(
name|splitPoint
operator|!=
literal|null
operator|&&
operator|!
name|r
operator|.
name|containsRow
argument_list|(
name|splitPoint
argument_list|)
operator|)
condition|)
continue|continue;
comment|// call out to region server to do split now
name|split
argument_list|(
name|pair
operator|.
name|getSecond
argument_list|()
argument_list|,
name|pair
operator|.
name|getFirst
argument_list|()
argument_list|,
name|splitPoint
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|zookeeper
operator|!=
literal|null
condition|)
block|{
name|zookeeper
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|splitRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|,
specifier|final
name|byte
index|[]
name|splitPoint
parameter_list|)
throws|throws
name|IOException
block|{
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|regionServerPair
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionServerPair
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid region: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionName
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|regionServerPair
operator|.
name|getFirst
argument_list|()
operator|!=
literal|null
operator|&&
name|regionServerPair
operator|.
name|getFirst
argument_list|()
operator|.
name|getReplicaId
argument_list|()
operator|!=
name|HRegionInfo
operator|.
name|DEFAULT_REPLICA_ID
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Can't split replicas directly. "
operator|+
literal|"Replicas are auto-split when their primary is split."
argument_list|)
throw|;
block|}
if|if
condition|(
name|regionServerPair
operator|.
name|getSecond
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoServerForRegionException
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionName
argument_list|)
argument_list|)
throw|;
block|}
name|split
argument_list|(
name|regionServerPair
operator|.
name|getSecond
argument_list|()
argument_list|,
name|regionServerPair
operator|.
name|getFirst
argument_list|()
argument_list|,
name|splitPoint
argument_list|)
expr_stmt|;
block|}
comment|/**    * @deprecated Use {@link #split(org.apache.hadoop.hbase.TableName,    * byte[])} or {@link #splitRegion(byte[], byte[])} instead.    */
annotation|@
name|Deprecated
specifier|public
name|void
name|split
parameter_list|(
specifier|final
name|String
name|tableNameOrRegionName
parameter_list|,
specifier|final
name|String
name|splitPoint
parameter_list|)
throws|throws
name|IOException
block|{
name|split
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|splitPoint
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * @deprecated Use {@link #split(org.apache.hadoop.hbase.TableName,    * byte[])} or {@link #splitRegion(byte[], byte[])} instead.    */
annotation|@
name|Deprecated
specifier|public
name|void
name|split
parameter_list|(
specifier|final
name|byte
index|[]
name|tableNameOrRegionName
parameter_list|,
specifier|final
name|byte
index|[]
name|splitPoint
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|splitRegion
argument_list|(
name|tableNameOrRegionName
argument_list|,
name|splitPoint
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|// Bad region, try table
name|split
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|,
name|splitPoint
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|void
name|split
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|,
specifier|final
name|HRegionInfo
name|hri
parameter_list|,
name|byte
index|[]
name|splitPoint
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|hri
operator|.
name|getStartKey
argument_list|()
operator|!=
literal|null
operator|&&
name|splitPoint
operator|!=
literal|null
operator|&&
name|Bytes
operator|.
name|compareTo
argument_list|(
name|hri
operator|.
name|getStartKey
argument_list|()
argument_list|,
name|splitPoint
argument_list|)
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"should not give a splitkey which equals to startkey!"
argument_list|)
throw|;
block|}
comment|// TODO: This is not executed via retries
name|AdminService
operator|.
name|BlockingInterface
name|admin
init|=
name|this
operator|.
name|connection
operator|.
name|getAdmin
argument_list|(
name|sn
argument_list|)
decl_stmt|;
name|ProtobufUtil
operator|.
name|split
argument_list|(
name|admin
argument_list|,
name|hri
argument_list|,
name|splitPoint
argument_list|)
expr_stmt|;
block|}
comment|/**    * Modify an existing table, more IRB friendly version.    * Asynchronous operation.  This means that it may be a while before your    * schema change is updated across all of the table.    *    * @param tableName name of table.    * @param htd modified description of the table    * @throws IOException if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
name|void
name|modifyTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|HTableDescriptor
name|htd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|tableName
operator|.
name|equals
argument_list|(
name|htd
operator|.
name|getTableName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"the specified table name '"
operator|+
name|tableName
operator|+
literal|"' doesn't match with the HTD one: "
operator|+
name|htd
operator|.
name|getTableName
argument_list|()
argument_list|)
throw|;
block|}
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Void
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
name|ModifyTableRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildModifyTableRequest
argument_list|(
name|tableName
argument_list|,
name|htd
argument_list|)
decl_stmt|;
name|master
operator|.
name|modifyTable
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|modifyTable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|HTableDescriptor
name|htd
parameter_list|)
throws|throws
name|IOException
block|{
name|modifyTable
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|htd
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|modifyTable
parameter_list|(
specifier|final
name|String
name|tableName
parameter_list|,
specifier|final
name|HTableDescriptor
name|htd
parameter_list|)
throws|throws
name|IOException
block|{
name|modifyTable
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|htd
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param regionName Name of a region.    * @return a pair of HRegionInfo and ServerName if<code>regionName</code> is    *  a verified region name (we call {@link    *  MetaTableAccessor#getRegion(HConnection, byte[])}    *  else null.    * Throw IllegalArgumentException if<code>regionName</code> is null.    * @throws IOException    */
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|getRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|regionName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Pass a table name or region name"
argument_list|)
throw|;
block|}
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
init|=
name|MetaTableAccessor
operator|.
name|getRegion
argument_list|(
name|connection
argument_list|,
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
literal|null
condition|)
block|{
specifier|final
name|AtomicReference
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|AtomicReference
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|>
argument_list|(
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|String
name|encodedName
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
name|MetaScannerVisitor
name|visitor
init|=
operator|new
name|MetaScannerVisitorBase
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|processRow
parameter_list|(
name|Result
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegionInfo
name|info
init|=
name|HRegionInfo
operator|.
name|getHRegionInfo
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No serialized HRegionInfo in "
operator|+
name|data
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|RegionLocations
name|rl
init|=
name|MetaTableAccessor
operator|.
name|getRegionLocations
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|boolean
name|matched
init|=
literal|false
decl_stmt|;
name|ServerName
name|sn
init|=
literal|null
decl_stmt|;
for|for
control|(
name|HRegionLocation
name|h
range|:
name|rl
operator|.
name|getRegionLocations
argument_list|()
control|)
block|{
if|if
condition|(
name|h
operator|!=
literal|null
operator|&&
name|encodedName
operator|.
name|equals
argument_list|(
name|h
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEncodedName
argument_list|()
argument_list|)
condition|)
block|{
name|sn
operator|=
name|h
operator|.
name|getServerName
argument_list|()
expr_stmt|;
name|info
operator|=
name|h
operator|.
name|getRegionInfo
argument_list|()
expr_stmt|;
name|matched
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|matched
condition|)
return|return
literal|true
return|;
name|result
operator|.
name|set
argument_list|(
operator|new
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|(
name|info
argument_list|,
name|sn
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
comment|// found the region, stop
block|}
block|}
decl_stmt|;
name|MetaScanner
operator|.
name|metaScan
argument_list|(
name|connection
argument_list|,
name|visitor
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|pair
operator|=
name|result
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
return|return
name|pair
return|;
block|}
comment|/**    * If the input is a region name, it is returned as is. If it's an    * encoded region name, the corresponding region is found from meta    * and its region name is returned. If we can't find any region in    * meta matching the input as either region name or encoded region    * name, the input is returned as is. We don't throw unknown    * region exception.    */
specifier|private
name|byte
index|[]
name|getRegionName
parameter_list|(
specifier|final
name|byte
index|[]
name|regionNameOrEncodedRegionName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|regionNameOrEncodedRegionName
argument_list|,
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
operator|.
name|getRegionName
argument_list|()
argument_list|)
operator|||
name|Bytes
operator|.
name|equals
argument_list|(
name|regionNameOrEncodedRegionName
argument_list|,
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
operator|.
name|getEncodedNameAsBytes
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
operator|.
name|getRegionName
argument_list|()
return|;
block|}
name|byte
index|[]
name|tmp
init|=
name|regionNameOrEncodedRegionName
decl_stmt|;
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|regionServerPair
init|=
name|getRegion
argument_list|(
name|regionNameOrEncodedRegionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionServerPair
operator|!=
literal|null
operator|&&
name|regionServerPair
operator|.
name|getFirst
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|tmp
operator|=
name|regionServerPair
operator|.
name|getFirst
argument_list|()
operator|.
name|getRegionName
argument_list|()
expr_stmt|;
block|}
return|return
name|tmp
return|;
block|}
comment|/**    * Check if table exists or not    * @param tableName Name of a table.    * @return tableName instance    * @throws IOException if a remote or network exception occurs.    * @throws TableNotFoundException if table does not exist.    */
specifier|private
name|TableName
name|checkTableExists
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|executeCallable
argument_list|(
operator|new
name|ConnectionCallable
argument_list|<
name|TableName
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|TableName
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
throws|,
name|IOException
block|{
if|if
condition|(
operator|!
name|MetaTableAccessor
operator|.
name|tableExists
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TableNotFoundException
argument_list|(
name|tableName
argument_list|)
throw|;
block|}
return|return
name|tableName
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Shuts down the HBase cluster    * @throws IOException if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|shutdown
parameter_list|()
throws|throws
name|IOException
block|{
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Void
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
name|master
operator|.
name|shutdown
argument_list|(
literal|null
argument_list|,
name|ShutdownRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Shuts down the current HBase master only.    * Does not shutdown the cluster.    * @see #shutdown()    * @throws IOException if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|stopMaster
parameter_list|()
throws|throws
name|IOException
block|{
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Void
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
name|master
operator|.
name|stopMaster
argument_list|(
literal|null
argument_list|,
name|StopMasterRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Stop the designated regionserver    * @param hostnamePort Hostname and port delimited by a<code>:</code> as in    *<code>example.org:1234</code>    * @throws IOException if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|stopRegionServer
parameter_list|(
specifier|final
name|String
name|hostnamePort
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|hostname
init|=
name|Addressing
operator|.
name|parseHostname
argument_list|(
name|hostnamePort
argument_list|)
decl_stmt|;
name|int
name|port
init|=
name|Addressing
operator|.
name|parsePort
argument_list|(
name|hostnamePort
argument_list|)
decl_stmt|;
name|AdminService
operator|.
name|BlockingInterface
name|admin
init|=
name|this
operator|.
name|connection
operator|.
name|getAdmin
argument_list|(
name|ServerName
operator|.
name|valueOf
argument_list|(
name|hostname
argument_list|,
name|port
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|StopServerRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildStopServerRequest
argument_list|(
literal|"Called by admin client "
operator|+
name|this
operator|.
name|connection
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|admin
operator|.
name|stopServer
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
block|}
comment|/**    * @return cluster status    * @throws IOException if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
name|ClusterStatus
name|getClusterStatus
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|ClusterStatus
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|ClusterStatus
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
name|GetClusterStatusRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildGetClusterStatusRequest
argument_list|()
decl_stmt|;
return|return
name|ClusterStatus
operator|.
name|convert
argument_list|(
name|master
operator|.
name|getClusterStatus
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
operator|.
name|getClusterStatus
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * @return Configuration used by the instance.    */
annotation|@
name|Override
specifier|public
name|Configuration
name|getConfiguration
parameter_list|()
block|{
return|return
name|this
operator|.
name|conf
return|;
block|}
comment|/**    * Create a new namespace    * @param descriptor descriptor which describes the new namespace    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|void
name|createNamespace
parameter_list|(
specifier|final
name|NamespaceDescriptor
name|descriptor
parameter_list|)
throws|throws
name|IOException
block|{
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Void
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|Exception
block|{
name|master
operator|.
name|createNamespace
argument_list|(
literal|null
argument_list|,
name|CreateNamespaceRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|setNamespaceDescriptor
argument_list|(
name|ProtobufUtil
operator|.
name|toProtoNamespaceDescriptor
argument_list|(
name|descriptor
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Modify an existing namespace    * @param descriptor descriptor which describes the new namespace    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|void
name|modifyNamespace
parameter_list|(
specifier|final
name|NamespaceDescriptor
name|descriptor
parameter_list|)
throws|throws
name|IOException
block|{
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Void
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|Exception
block|{
name|master
operator|.
name|modifyNamespace
argument_list|(
literal|null
argument_list|,
name|ModifyNamespaceRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|setNamespaceDescriptor
argument_list|(
name|ProtobufUtil
operator|.
name|toProtoNamespaceDescriptor
argument_list|(
name|descriptor
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete an existing namespace. Only empty namespaces (no tables) can be removed.    * @param name namespace name    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|void
name|deleteNamespace
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Void
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|Exception
block|{
name|master
operator|.
name|deleteNamespace
argument_list|(
literal|null
argument_list|,
name|DeleteNamespaceRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|setNamespaceName
argument_list|(
name|name
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get a namespace descriptor by name    * @param name name of namespace descriptor    * @return A descriptor    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|NamespaceDescriptor
name|getNamespaceDescriptor
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|NamespaceDescriptor
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|NamespaceDescriptor
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|ProtobufUtil
operator|.
name|toNamespaceDescriptor
argument_list|(
name|master
operator|.
name|getNamespaceDescriptor
argument_list|(
literal|null
argument_list|,
name|GetNamespaceDescriptorRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|setNamespaceName
argument_list|(
name|name
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|getNamespaceDescriptor
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * List available namespace descriptors    * @return List of descriptors    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|NamespaceDescriptor
index|[]
name|listNamespaceDescriptors
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|NamespaceDescriptor
index|[]
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|NamespaceDescriptor
index|[]
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|HBaseProtos
operator|.
name|NamespaceDescriptor
argument_list|>
name|list
init|=
name|master
operator|.
name|listNamespaceDescriptors
argument_list|(
literal|null
argument_list|,
name|ListNamespaceDescriptorsRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|getNamespaceDescriptorList
argument_list|()
decl_stmt|;
name|NamespaceDescriptor
index|[]
name|res
init|=
operator|new
name|NamespaceDescriptor
index|[
name|list
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|res
index|[
name|i
index|]
operator|=
name|ProtobufUtil
operator|.
name|toNamespaceDescriptor
argument_list|(
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Get list of table descriptors by namespace    * @param name namespace name    * @return A descriptor    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|HTableDescriptor
index|[]
name|listTableDescriptorsByNamespace
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|HTableDescriptor
index|[]
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|HTableDescriptor
index|[]
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|TableSchema
argument_list|>
name|list
init|=
name|master
operator|.
name|listTableDescriptorsByNamespace
argument_list|(
literal|null
argument_list|,
name|ListTableDescriptorsByNamespaceRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|setNamespaceName
argument_list|(
name|name
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|getTableSchemaList
argument_list|()
decl_stmt|;
name|HTableDescriptor
index|[]
name|res
init|=
operator|new
name|HTableDescriptor
index|[
name|list
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|res
index|[
name|i
index|]
operator|=
name|HTableDescriptor
operator|.
name|convert
argument_list|(
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Get list of table names by namespace    * @param name namespace name    * @return The list of table names in the namespace    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|TableName
index|[]
name|listTableNamesByNamespace
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|TableName
index|[]
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|TableName
index|[]
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|HBaseProtos
operator|.
name|TableName
argument_list|>
name|tableNames
init|=
name|master
operator|.
name|listTableNamesByNamespace
argument_list|(
literal|null
argument_list|,
name|ListTableNamesByNamespaceRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|setNamespaceName
argument_list|(
name|name
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|getTableNameList
argument_list|()
decl_stmt|;
name|TableName
index|[]
name|result
init|=
operator|new
name|TableName
index|[
name|tableNames
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tableNames
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|result
index|[
name|i
index|]
operator|=
name|ProtobufUtil
operator|.
name|toTableName
argument_list|(
name|tableNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Check to see if HBase is running. Throw an exception if not.    * @param conf system configuration    * @throws MasterNotRunningException if the master is not running    * @throws ZooKeeperConnectionException if unable to connect to zookeeper    */
comment|// Used by tests and by the Merge tool. Merge tool uses it to figure if HBase is up or not.
specifier|public
specifier|static
name|void
name|checkHBaseAvailable
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
throws|,
name|ServiceException
throws|,
name|IOException
block|{
name|Configuration
name|copyOfConf
init|=
name|HBaseConfiguration
operator|.
name|create
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// We set it to make it fail as soon as possible if HBase is not available
name|copyOfConf
operator|.
name|setInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_RETRIES_NUMBER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|copyOfConf
operator|.
name|setInt
argument_list|(
literal|"zookeeper.recovery.retry"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
try|try
init|(
name|ClusterConnection
name|connection
init|=
operator|(
name|ClusterConnection
operator|)
name|ConnectionFactory
operator|.
name|createConnection
argument_list|(
name|copyOfConf
argument_list|)
init|)
block|{
comment|// Check ZK first.
comment|// If the connection exists, we may have a connection to ZK that does not work anymore
name|ZooKeeperKeepAliveConnection
name|zkw
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// This is NASTY. FIX!!!! Dependent on internal implementation! TODO
name|zkw
operator|=
operator|(
operator|(
name|ConnectionManager
operator|.
name|HConnectionImplementation
operator|)
name|connection
operator|)
operator|.
name|getKeepAliveZooKeeperWatcher
argument_list|()
expr_stmt|;
name|zkw
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|getZooKeeper
argument_list|()
operator|.
name|exists
argument_list|(
name|zkw
operator|.
name|baseZNode
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ZooKeeperConnectionException
argument_list|(
literal|"Can't connect to ZooKeeper"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|(
name|InterruptedIOException
operator|)
operator|new
name|InterruptedIOException
argument_list|(
literal|"Can't connect to ZooKeeper"
argument_list|)
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ZooKeeperConnectionException
argument_list|(
literal|"Can't connect to ZooKeeper"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|zkw
operator|!=
literal|null
condition|)
block|{
name|zkw
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
name|connection
operator|.
name|isMasterRunning
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * get the regions of a given table.    *    * @param tableName the name of the table    * @return Ordered list of {@link HRegionInfo}.    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|getTableRegions
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|ZooKeeperWatcher
name|zookeeper
init|=
operator|new
name|ZooKeeperWatcher
argument_list|(
name|conf
argument_list|,
name|ZK_IDENTIFIER_PREFIX
operator|+
name|connection
operator|.
name|toString
argument_list|()
argument_list|,
operator|new
name|ThrowableAbortable
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|regions
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|TableName
operator|.
name|META_TABLE_NAME
operator|.
name|equals
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|regions
operator|=
operator|new
name|MetaTableLocator
argument_list|()
operator|.
name|getMetaRegions
argument_list|(
name|zookeeper
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|regions
operator|=
name|MetaTableAccessor
operator|.
name|getTableRegions
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|zookeeper
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|regions
return|;
block|}
specifier|public
name|List
argument_list|<
name|HRegionInfo
argument_list|>
name|getTableRegions
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getTableRegions
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|cleanupConnectionOnClose
operator|&&
name|this
operator|.
name|connection
operator|!=
literal|null
operator|&&
operator|!
name|this
operator|.
name|closed
condition|)
block|{
name|this
operator|.
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
name|this
operator|.
name|closed
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/**    * Get tableDescriptors    * @param tableNames List of table names    * @return HTD[] the tableDescriptor    * @throws IOException if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
name|HTableDescriptor
index|[]
name|getTableDescriptorsByTableName
parameter_list|(
specifier|final
name|List
argument_list|<
name|TableName
argument_list|>
name|tableNames
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|HTableDescriptor
index|[]
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|HTableDescriptor
index|[]
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|Exception
block|{
name|GetTableDescriptorsRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildGetTableDescriptorsRequest
argument_list|(
name|tableNames
argument_list|)
decl_stmt|;
return|return
name|ProtobufUtil
operator|.
name|getHTableDescriptorArray
argument_list|(
name|master
operator|.
name|getTableDescriptors
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Get tableDescriptor    * @param tableName one table name    * @return HTD the HTableDescriptor or null if the table not exists    * @throws IOException if a remote or network exception occurs    */
specifier|private
name|HTableDescriptor
name|getTableDescriptorByTableName
parameter_list|(
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|TableName
argument_list|>
name|tableNames
init|=
operator|new
name|ArrayList
argument_list|<
name|TableName
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|tableNames
operator|.
name|add
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|HTableDescriptor
index|[]
name|htdl
init|=
name|getTableDescriptorsByTableName
argument_list|(
name|tableNames
argument_list|)
decl_stmt|;
if|if
condition|(
name|htdl
operator|==
literal|null
operator|||
name|htdl
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|htdl
index|[
literal|0
index|]
return|;
block|}
block|}
comment|/**    * Get tableDescriptors    * @param names List of table names    * @return HTD[] the tableDescriptor    * @throws IOException if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
name|HTableDescriptor
index|[]
name|getTableDescriptors
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|names
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|TableName
argument_list|>
name|tableNames
init|=
operator|new
name|ArrayList
argument_list|<
name|TableName
argument_list|>
argument_list|(
name|names
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|names
control|)
block|{
name|tableNames
operator|.
name|add
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|getTableDescriptorsByTableName
argument_list|(
name|tableNames
argument_list|)
return|;
block|}
specifier|private
name|RollWALWriterResponse
name|rollWALWriterImpl
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|)
throws|throws
name|IOException
throws|,
name|FailedLogCloseException
block|{
name|AdminService
operator|.
name|BlockingInterface
name|admin
init|=
name|this
operator|.
name|connection
operator|.
name|getAdmin
argument_list|(
name|sn
argument_list|)
decl_stmt|;
name|RollWALWriterRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildRollWALWriterRequest
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|admin
operator|.
name|rollWALWriter
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
block|}
comment|/**    * Roll the log writer. I.e. when using a file system based write ahead log,    * start writing log messages to a new file.    *    * Note that when talking to a version 1.0+ HBase deployment, the rolling is asynchronous.    * This method will return as soon as the roll is requested and the return value will    * always be null. Additionally, the named region server may schedule store flushes at the    * request of the wal handling the roll request.    *    * When talking to a 0.98 or older HBase deployment, the rolling is synchronous and the    * return value may be either null or a list of encoded region names.    *    * @param serverName    *          The servername of the regionserver. A server name is made of host,    *          port and startcode. This is mandatory. Here is an example:    *<code> host187.example.com,60020,1289493121758</code>    * @return a set of {@link HRegionInfo#getEncodedName()} that would allow the wal to    *         clean up some underlying files. null if there's nothing to flush.    * @throws IOException if a remote or network exception occurs    * @throws FailedLogCloseException    * @deprecated use {@link #rollWALWriter(ServerName)}    */
annotation|@
name|Deprecated
specifier|public
specifier|synchronized
name|byte
index|[]
index|[]
name|rollHLogWriter
parameter_list|(
name|String
name|serverName
parameter_list|)
throws|throws
name|IOException
throws|,
name|FailedLogCloseException
block|{
name|ServerName
name|sn
init|=
name|ServerName
operator|.
name|valueOf
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
specifier|final
name|RollWALWriterResponse
name|response
init|=
name|rollWALWriterImpl
argument_list|(
name|sn
argument_list|)
decl_stmt|;
name|int
name|regionCount
init|=
name|response
operator|.
name|getRegionToFlushCount
argument_list|()
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|regionCount
condition|)
block|{
return|return
literal|null
return|;
block|}
name|byte
index|[]
index|[]
name|regionsToFlush
init|=
operator|new
name|byte
index|[
name|regionCount
index|]
index|[]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|regionCount
condition|;
name|i
operator|++
control|)
block|{
name|ByteString
name|region
init|=
name|response
operator|.
name|getRegionToFlush
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|regionsToFlush
index|[
name|i
index|]
operator|=
name|region
operator|.
name|toByteArray
argument_list|()
expr_stmt|;
block|}
return|return
name|regionsToFlush
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|rollWALWriter
parameter_list|(
name|ServerName
name|serverName
parameter_list|)
throws|throws
name|IOException
throws|,
name|FailedLogCloseException
block|{
name|rollWALWriterImpl
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
index|[]
name|getMasterCoprocessors
parameter_list|()
block|{
try|try
block|{
return|return
name|getClusterStatus
argument_list|()
operator|.
name|getMasterCoprocessors
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Could not getClusterStatus()"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|CompactionState
name|getCompactionState
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|CompactionState
name|state
init|=
name|CompactionState
operator|.
name|NONE
decl_stmt|;
name|ZooKeeperWatcher
name|zookeeper
init|=
operator|new
name|ZooKeeperWatcher
argument_list|(
name|conf
argument_list|,
name|ZK_IDENTIFIER_PREFIX
operator|+
name|connection
operator|.
name|toString
argument_list|()
argument_list|,
operator|new
name|ThrowableAbortable
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|checkTableExists
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|>
name|pairs
decl_stmt|;
if|if
condition|(
name|TableName
operator|.
name|META_TABLE_NAME
operator|.
name|equals
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|pairs
operator|=
operator|new
name|MetaTableLocator
argument_list|()
operator|.
name|getMetaRegionsAndLocations
argument_list|(
name|zookeeper
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pairs
operator|=
name|MetaTableAccessor
operator|.
name|getTableRegionsAndLocations
argument_list|(
name|connection
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
range|:
name|pairs
control|)
block|{
if|if
condition|(
name|pair
operator|.
name|getFirst
argument_list|()
operator|.
name|isOffline
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|pair
operator|.
name|getSecond
argument_list|()
operator|==
literal|null
condition|)
continue|continue;
try|try
block|{
name|ServerName
name|sn
init|=
name|pair
operator|.
name|getSecond
argument_list|()
decl_stmt|;
name|AdminService
operator|.
name|BlockingInterface
name|admin
init|=
name|this
operator|.
name|connection
operator|.
name|getAdmin
argument_list|(
name|sn
argument_list|)
decl_stmt|;
name|GetRegionInfoRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildGetRegionInfoRequest
argument_list|(
name|pair
operator|.
name|getFirst
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|GetRegionInfoResponse
name|response
init|=
name|admin
operator|.
name|getRegionInfo
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|response
operator|.
name|getCompactionState
argument_list|()
condition|)
block|{
case|case
name|MAJOR_AND_MINOR
case|:
return|return
name|CompactionState
operator|.
name|MAJOR_AND_MINOR
return|;
case|case
name|MAJOR
case|:
if|if
condition|(
name|state
operator|==
name|CompactionState
operator|.
name|MINOR
condition|)
block|{
return|return
name|CompactionState
operator|.
name|MAJOR_AND_MINOR
return|;
block|}
name|state
operator|=
name|CompactionState
operator|.
name|MAJOR
expr_stmt|;
break|break;
case|case
name|MINOR
case|:
if|if
condition|(
name|state
operator|==
name|CompactionState
operator|.
name|MAJOR
condition|)
block|{
return|return
name|CompactionState
operator|.
name|MAJOR_AND_MINOR
return|;
block|}
name|state
operator|=
name|CompactionState
operator|.
name|MINOR
expr_stmt|;
break|break;
case|case
name|NONE
case|:
default|default:
comment|// nothing, continue
block|}
block|}
catch|catch
parameter_list|(
name|NotServingRegionException
name|e
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Trying to get compaction state of "
operator|+
name|pair
operator|.
name|getFirst
argument_list|()
operator|+
literal|": "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|indexOf
argument_list|(
name|NotServingRegionException
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Trying to get compaction state of "
operator|+
name|pair
operator|.
name|getFirst
argument_list|()
operator|+
literal|": "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
finally|finally
block|{
name|zookeeper
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|state
return|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|CompactionState
name|getCompactionStateForRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|regionServerPair
init|=
name|getRegion
argument_list|(
name|regionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionServerPair
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid region: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionName
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|regionServerPair
operator|.
name|getSecond
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoServerForRegionException
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionName
argument_list|)
argument_list|)
throw|;
block|}
name|ServerName
name|sn
init|=
name|regionServerPair
operator|.
name|getSecond
argument_list|()
decl_stmt|;
name|AdminService
operator|.
name|BlockingInterface
name|admin
init|=
name|this
operator|.
name|connection
operator|.
name|getAdmin
argument_list|(
name|sn
argument_list|)
decl_stmt|;
name|GetRegionInfoRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildGetRegionInfoRequest
argument_list|(
name|regionServerPair
operator|.
name|getFirst
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|GetRegionInfoResponse
name|response
init|=
name|admin
operator|.
name|getRegionInfo
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
decl_stmt|;
return|return
name|response
operator|.
name|getCompactionState
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
block|}
comment|/**    * @deprecated Use {@link #getCompactionState(org.apache.hadoop.hbase.TableName)} or {@link    * #getCompactionStateForRegion(byte[])} instead.    */
annotation|@
name|Deprecated
specifier|public
name|CompactionState
name|getCompactionState
parameter_list|(
specifier|final
name|String
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|getCompactionState
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @deprecated Use {@link #getCompactionState(org.apache.hadoop.hbase.TableName)} or {@link    * #getCompactionStateForRegion(byte[])} instead.    */
annotation|@
name|Deprecated
specifier|public
name|CompactionState
name|getCompactionState
parameter_list|(
specifier|final
name|byte
index|[]
name|tableNameOrRegionName
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
try|try
block|{
return|return
name|getCompactionStateForRegion
argument_list|(
name|tableNameOrRegionName
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|// Invalid region, try table
return|return
name|getCompactionState
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableNameOrRegionName
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**    * Take a snapshot for the given table. If the table is enabled, a FLUSH-type snapshot will be    * taken. If the table is disabled, an offline snapshot is taken.    *<p>    * Snapshots are considered unique based on<b>the name of the snapshot</b>. Attempts to take a    * snapshot with the same name (even a different type or with different parameters) will fail with    * a {@link SnapshotCreationException} indicating the duplicate naming.    *<p>    * Snapshot names follow the same naming constraints as tables in HBase. See    * {@link org.apache.hadoop.hbase.TableName#isLegalFullyQualifiedTableName(byte[])}.    * @param snapshotName name of the snapshot to be created    * @param tableName name of the table for which snapshot is created    * @throws IOException if a remote or network exception occurs    * @throws SnapshotCreationException if snapshot creation failed    * @throws IllegalArgumentException if the snapshot request is formatted incorrectly    */
annotation|@
name|Override
specifier|public
name|void
name|snapshot
parameter_list|(
specifier|final
name|String
name|snapshotName
parameter_list|,
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
throws|,
name|SnapshotCreationException
throws|,
name|IllegalArgumentException
block|{
name|snapshot
argument_list|(
name|snapshotName
argument_list|,
name|tableName
argument_list|,
name|SnapshotDescription
operator|.
name|Type
operator|.
name|FLUSH
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|snapshot
parameter_list|(
specifier|final
name|String
name|snapshotName
parameter_list|,
specifier|final
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
throws|,
name|SnapshotCreationException
throws|,
name|IllegalArgumentException
block|{
name|snapshot
argument_list|(
name|snapshotName
argument_list|,
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|SnapshotDescription
operator|.
name|Type
operator|.
name|FLUSH
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create snapshot for the given table of given flush type.    *<p>    * Snapshots are considered unique based on<b>the name of the snapshot</b>. Attempts to take a    * snapshot with the same name (even a different type or with different parameters) will fail with    * a {@link SnapshotCreationException} indicating the duplicate naming.    *<p>    * Snapshot names follow the same naming constraints as tables in HBase.    * @param snapshotName name of the snapshot to be created    * @param tableName name of the table for which snapshot is created    * @param flushType if the snapshot should be taken without flush memstore first    * @throws IOException if a remote or network exception occurs    * @throws SnapshotCreationException if snapshot creation failed    * @throws IllegalArgumentException if the snapshot request is formatted incorrectly    */
specifier|public
name|void
name|snapshot
parameter_list|(
specifier|final
name|byte
index|[]
name|snapshotName
parameter_list|,
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|SnapshotDescription
operator|.
name|Type
name|flushType
parameter_list|)
throws|throws
name|IOException
throws|,
name|SnapshotCreationException
throws|,
name|IllegalArgumentException
block|{
name|snapshot
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|snapshotName
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|flushType
argument_list|)
expr_stmt|;
block|}
comment|/**    public void snapshot(final String snapshotName,     * Create a timestamp consistent snapshot for the given table.                         final byte[] tableName) throws IOException,     *<p>     * Snapshots are considered unique based on<b>the name of the snapshot</b>. Attempts to take a     * snapshot with the same name (even a different type or with different parameters) will fail     * with a {@link SnapshotCreationException} indicating the duplicate naming.     *<p>     * Snapshot names follow the same naming constraints as tables in HBase.     * @param snapshotName name of the snapshot to be created     * @param tableName name of the table for which snapshot is created     * @throws IOException if a remote or network exception occurs     * @throws SnapshotCreationException if snapshot creation failed     * @throws IllegalArgumentException if the snapshot request is formatted incorrectly     */
annotation|@
name|Override
specifier|public
name|void
name|snapshot
parameter_list|(
specifier|final
name|byte
index|[]
name|snapshotName
parameter_list|,
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
throws|,
name|SnapshotCreationException
throws|,
name|IllegalArgumentException
block|{
name|snapshot
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|snapshotName
argument_list|)
argument_list|,
name|tableName
argument_list|,
name|SnapshotDescription
operator|.
name|Type
operator|.
name|FLUSH
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|snapshot
parameter_list|(
specifier|final
name|byte
index|[]
name|snapshotName
parameter_list|,
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
throws|,
name|SnapshotCreationException
throws|,
name|IllegalArgumentException
block|{
name|snapshot
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|snapshotName
argument_list|)
argument_list|,
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|SnapshotDescription
operator|.
name|Type
operator|.
name|FLUSH
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create typed snapshot of the table.    *<p>    * Snapshots are considered unique based on<b>the name of the snapshot</b>. Attempts to take a    * snapshot with the same name (even a different type or with different parameters) will fail with    * a {@link SnapshotCreationException} indicating the duplicate naming.    *<p>    * Snapshot names follow the same naming constraints as tables in HBase. See    * {@link org.apache.hadoop.hbase.TableName#isLegalFullyQualifiedTableName(byte[])}.    *<p>    * @param snapshotName name to give the snapshot on the filesystem. Must be unique from all other    *          snapshots stored on the cluster    * @param tableName name of the table to snapshot    * @param type type of snapshot to take    * @throws IOException we fail to reach the master    * @throws SnapshotCreationException if snapshot creation failed    * @throws IllegalArgumentException if the snapshot request is formatted incorrectly    */
annotation|@
name|Override
specifier|public
name|void
name|snapshot
parameter_list|(
specifier|final
name|String
name|snapshotName
parameter_list|,
specifier|final
name|TableName
name|tableName
parameter_list|,
name|SnapshotDescription
operator|.
name|Type
name|type
parameter_list|)
throws|throws
name|IOException
throws|,
name|SnapshotCreationException
throws|,
name|IllegalArgumentException
block|{
name|SnapshotDescription
operator|.
name|Builder
name|builder
init|=
name|SnapshotDescription
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|setTable
argument_list|(
name|tableName
operator|.
name|getNameAsString
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setName
argument_list|(
name|snapshotName
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setType
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|snapshot
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|snapshot
parameter_list|(
specifier|final
name|String
name|snapshotName
parameter_list|,
specifier|final
name|String
name|tableName
parameter_list|,
name|SnapshotDescription
operator|.
name|Type
name|type
parameter_list|)
throws|throws
name|IOException
throws|,
name|SnapshotCreationException
throws|,
name|IllegalArgumentException
block|{
name|snapshot
argument_list|(
name|snapshotName
argument_list|,
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|snapshot
parameter_list|(
specifier|final
name|String
name|snapshotName
parameter_list|,
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
name|SnapshotDescription
operator|.
name|Type
name|type
parameter_list|)
throws|throws
name|IOException
throws|,
name|SnapshotCreationException
throws|,
name|IllegalArgumentException
block|{
name|snapshot
argument_list|(
name|snapshotName
argument_list|,
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
comment|/**    * Take a snapshot and wait for the server to complete that snapshot (blocking).    *<p>    * Only a single snapshot should be taken at a time for an instance of HBase, or results may be    * undefined (you can tell multiple HBase clusters to snapshot at the same time, but only one at a    * time for a single cluster).    *<p>    * Snapshots are considered unique based on<b>the name of the snapshot</b>. Attempts to take a    * snapshot with the same name (even a different type or with different parameters) will fail with    * a {@link SnapshotCreationException} indicating the duplicate naming.    *<p>    * Snapshot names follow the same naming constraints as tables in HBase. See    * {@link org.apache.hadoop.hbase.TableName#isLegalFullyQualifiedTableName(byte[])}.    *<p>    * You should probably use {@link #snapshot(String, String)} or {@link #snapshot(byte[], byte[])}    * unless you are sure about the type of snapshot that you want to take.    * @param snapshot snapshot to take    * @throws IOException or we lose contact with the master.    * @throws SnapshotCreationException if snapshot failed to be taken    * @throws IllegalArgumentException if the snapshot request is formatted incorrectly    */
annotation|@
name|Override
specifier|public
name|void
name|snapshot
parameter_list|(
name|SnapshotDescription
name|snapshot
parameter_list|)
throws|throws
name|IOException
throws|,
name|SnapshotCreationException
throws|,
name|IllegalArgumentException
block|{
comment|// actually take the snapshot
name|SnapshotResponse
name|response
init|=
name|takeSnapshotAsync
argument_list|(
name|snapshot
argument_list|)
decl_stmt|;
specifier|final
name|IsSnapshotDoneRequest
name|request
init|=
name|IsSnapshotDoneRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|setSnapshot
argument_list|(
name|snapshot
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|IsSnapshotDoneResponse
name|done
init|=
literal|null
decl_stmt|;
name|long
name|start
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
decl_stmt|;
name|long
name|max
init|=
name|response
operator|.
name|getExpectedTimeout
argument_list|()
decl_stmt|;
name|long
name|maxPauseTime
init|=
name|max
operator|/
name|this
operator|.
name|numRetries
decl_stmt|;
name|int
name|tries
init|=
literal|0
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting a max of "
operator|+
name|max
operator|+
literal|" ms for snapshot '"
operator|+
name|ClientSnapshotDescriptionUtils
operator|.
name|toString
argument_list|(
name|snapshot
argument_list|)
operator|+
literal|"'' to complete. (max "
operator|+
name|maxPauseTime
operator|+
literal|" ms per retry)"
argument_list|)
expr_stmt|;
while|while
condition|(
name|tries
operator|==
literal|0
operator|||
operator|(
operator|(
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|-
name|start
operator|)
operator|<
name|max
operator|&&
operator|!
name|done
operator|.
name|getDone
argument_list|()
operator|)
condition|)
block|{
try|try
block|{
comment|// sleep a backoff<= pauseTime amount
name|long
name|sleep
init|=
name|getPauseTime
argument_list|(
name|tries
operator|++
argument_list|)
decl_stmt|;
name|sleep
operator|=
name|sleep
operator|>
name|maxPauseTime
condition|?
name|maxPauseTime
else|:
name|sleep
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"(#"
operator|+
name|tries
operator|+
literal|") Sleeping: "
operator|+
name|sleep
operator|+
literal|"ms while waiting for snapshot completion."
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|sleep
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|(
name|InterruptedIOException
operator|)
operator|new
name|InterruptedIOException
argument_list|(
literal|"Interrupted"
argument_list|)
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Getting current status of snapshot from master..."
argument_list|)
expr_stmt|;
name|done
operator|=
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|IsSnapshotDoneResponse
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|IsSnapshotDoneResponse
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|master
operator|.
name|isSnapshotDone
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|done
operator|.
name|getDone
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SnapshotCreationException
argument_list|(
literal|"Snapshot '"
operator|+
name|snapshot
operator|.
name|getName
argument_list|()
operator|+
literal|"' wasn't completed in expectedTime:"
operator|+
name|max
operator|+
literal|" ms"
argument_list|,
name|snapshot
argument_list|)
throw|;
block|}
block|}
comment|/**    * Take a snapshot without waiting for the server to complete that snapshot (asynchronous)    *<p>    * Only a single snapshot should be taken at a time, or results may be undefined.    * @param snapshot snapshot to take    * @return response from the server indicating the max time to wait for the snapshot    * @throws IOException if the snapshot did not succeed or we lose contact with the master.    * @throws SnapshotCreationException if snapshot creation failed    * @throws IllegalArgumentException if the snapshot request is formatted incorrectly    */
annotation|@
name|Override
specifier|public
name|SnapshotResponse
name|takeSnapshotAsync
parameter_list|(
name|SnapshotDescription
name|snapshot
parameter_list|)
throws|throws
name|IOException
throws|,
name|SnapshotCreationException
block|{
name|ClientSnapshotDescriptionUtils
operator|.
name|assertSnapshotRequestIsValid
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
specifier|final
name|SnapshotRequest
name|request
init|=
name|SnapshotRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|setSnapshot
argument_list|(
name|snapshot
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// run the snapshot on the master
return|return
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|SnapshotResponse
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|SnapshotResponse
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|master
operator|.
name|snapshot
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Check the current state of the passed snapshot.    *<p>    * There are three possible states:    *<ol>    *<li>running - returns<tt>false</tt></li>    *<li>finished - returns<tt>true</tt></li>    *<li>finished with error - throws the exception that caused the snapshot to fail</li>    *</ol>    *<p>    * The cluster only knows about the most recent snapshot. Therefore, if another snapshot has been    * run/started since the snapshot your are checking, you will recieve an    * {@link UnknownSnapshotException}.    * @param snapshot description of the snapshot to check    * @return<tt>true</tt> if the snapshot is completed,<tt>false</tt> if the snapshot is still    *         running    * @throws IOException if we have a network issue    * @throws HBaseSnapshotException if the snapshot failed    * @throws UnknownSnapshotException if the requested snapshot is unknown    */
annotation|@
name|Override
specifier|public
name|boolean
name|isSnapshotFinished
parameter_list|(
specifier|final
name|SnapshotDescription
name|snapshot
parameter_list|)
throws|throws
name|IOException
throws|,
name|HBaseSnapshotException
throws|,
name|UnknownSnapshotException
block|{
return|return
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|IsSnapshotDoneResponse
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|IsSnapshotDoneResponse
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|master
operator|.
name|isSnapshotDone
argument_list|(
literal|null
argument_list|,
name|IsSnapshotDoneRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|setSnapshot
argument_list|(
name|snapshot
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
operator|.
name|getDone
argument_list|()
return|;
block|}
comment|/**    * Restore the specified snapshot on the original table. (The table must be disabled)    * If the "hbase.snapshot.restore.take.failsafe.snapshot" configuration property    * is set to true, a snapshot of the current table is taken    * before executing the restore operation.    * In case of restore failure, the failsafe snapshot will be restored.    * If the restore completes without problem the failsafe snapshot is deleted.    *    * @param snapshotName name of the snapshot to restore    * @throws IOException if a remote or network exception occurs    * @throws RestoreSnapshotException if snapshot failed to be restored    * @throws IllegalArgumentException if the restore request is formatted incorrectly    */
annotation|@
name|Override
specifier|public
name|void
name|restoreSnapshot
parameter_list|(
specifier|final
name|byte
index|[]
name|snapshotName
parameter_list|)
throws|throws
name|IOException
throws|,
name|RestoreSnapshotException
block|{
name|restoreSnapshot
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|snapshotName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Restore the specified snapshot on the original table. (The table must be disabled)    * If the "hbase.snapshot.restore.take.failsafe.snapshot" configuration property    * is set to true, a snapshot of the current table is taken    * before executing the restore operation.    * In case of restore failure, the failsafe snapshot will be restored.    * If the restore completes without problem the failsafe snapshot is deleted.    *    * @param snapshotName name of the snapshot to restore    * @throws IOException if a remote or network exception occurs    * @throws RestoreSnapshotException if snapshot failed to be restored    * @throws IllegalArgumentException if the restore request is formatted incorrectly    */
annotation|@
name|Override
specifier|public
name|void
name|restoreSnapshot
parameter_list|(
specifier|final
name|String
name|snapshotName
parameter_list|)
throws|throws
name|IOException
throws|,
name|RestoreSnapshotException
block|{
name|boolean
name|takeFailSafeSnapshot
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.snapshot.restore.take.failsafe.snapshot"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|restoreSnapshot
argument_list|(
name|snapshotName
argument_list|,
name|takeFailSafeSnapshot
argument_list|)
expr_stmt|;
block|}
comment|/**    * Restore the specified snapshot on the original table. (The table must be disabled)    * If 'takeFailSafeSnapshot' is set to true, a snapshot of the current table is taken    * before executing the restore operation.    * In case of restore failure, the failsafe snapshot will be restored.    * If the restore completes without problem the failsafe snapshot is deleted.    *    * The failsafe snapshot name is configurable by using the property    * "hbase.snapshot.restore.failsafe.name".    *    * @param snapshotName name of the snapshot to restore    * @param takeFailSafeSnapshot true if the failsafe snapshot should be taken    * @throws IOException if a remote or network exception occurs    * @throws RestoreSnapshotException if snapshot failed to be restored    * @throws IllegalArgumentException if the restore request is formatted incorrectly    */
annotation|@
name|Override
specifier|public
name|void
name|restoreSnapshot
parameter_list|(
specifier|final
name|byte
index|[]
name|snapshotName
parameter_list|,
specifier|final
name|boolean
name|takeFailSafeSnapshot
parameter_list|)
throws|throws
name|IOException
throws|,
name|RestoreSnapshotException
block|{
name|restoreSnapshot
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|snapshotName
argument_list|)
argument_list|,
name|takeFailSafeSnapshot
argument_list|)
expr_stmt|;
block|}
comment|/**    * Restore the specified snapshot on the original table. (The table must be disabled)    * If 'takeFailSafeSnapshot' is set to true, a snapshot of the current table is taken    * before executing the restore operation.    * In case of restore failure, the failsafe snapshot will be restored.    * If the restore completes without problem the failsafe snapshot is deleted.    *    * The failsafe snapshot name is configurable by using the property    * "hbase.snapshot.restore.failsafe.name".    *    * @param snapshotName name of the snapshot to restore    * @param takeFailSafeSnapshot true if the failsafe snapshot should be taken    * @throws IOException if a remote or network exception occurs    * @throws RestoreSnapshotException if snapshot failed to be restored    * @throws IllegalArgumentException if the restore request is formatted incorrectly    */
annotation|@
name|Override
specifier|public
name|void
name|restoreSnapshot
parameter_list|(
specifier|final
name|String
name|snapshotName
parameter_list|,
name|boolean
name|takeFailSafeSnapshot
parameter_list|)
throws|throws
name|IOException
throws|,
name|RestoreSnapshotException
block|{
name|TableName
name|tableName
init|=
literal|null
decl_stmt|;
for|for
control|(
name|SnapshotDescription
name|snapshotInfo
range|:
name|listSnapshots
argument_list|()
control|)
block|{
if|if
condition|(
name|snapshotInfo
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|snapshotName
argument_list|)
condition|)
block|{
name|tableName
operator|=
name|TableName
operator|.
name|valueOf
argument_list|(
name|snapshotInfo
operator|.
name|getTable
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|tableName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RestoreSnapshotException
argument_list|(
literal|"Unable to find the table name for snapshot="
operator|+
name|snapshotName
argument_list|)
throw|;
block|}
comment|// The table does not exists, switch to clone.
if|if
condition|(
operator|!
name|tableExists
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|cloneSnapshot
argument_list|(
name|snapshotName
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Check if the table is disabled
if|if
condition|(
operator|!
name|isTableDisabled
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TableNotDisabledException
argument_list|(
name|tableName
argument_list|)
throw|;
block|}
comment|// Take a snapshot of the current state
name|String
name|failSafeSnapshotSnapshotName
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|takeFailSafeSnapshot
condition|)
block|{
name|failSafeSnapshotSnapshotName
operator|=
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.snapshot.restore.failsafe.name"
argument_list|,
literal|"hbase-failsafe-{snapshot.name}-{restore.timestamp}"
argument_list|)
expr_stmt|;
name|failSafeSnapshotSnapshotName
operator|=
name|failSafeSnapshotSnapshotName
operator|.
name|replace
argument_list|(
literal|"{snapshot.name}"
argument_list|,
name|snapshotName
argument_list|)
operator|.
name|replace
argument_list|(
literal|"{table.name}"
argument_list|,
name|tableName
operator|.
name|toString
argument_list|()
operator|.
name|replace
argument_list|(
name|TableName
operator|.
name|NAMESPACE_DELIM
argument_list|,
literal|'.'
argument_list|)
argument_list|)
operator|.
name|replace
argument_list|(
literal|"{restore.timestamp}"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Taking restore-failsafe snapshot: "
operator|+
name|failSafeSnapshotSnapshotName
argument_list|)
expr_stmt|;
name|snapshot
argument_list|(
name|failSafeSnapshotSnapshotName
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
block|}
try|try
block|{
comment|// Restore snapshot
name|internalRestoreSnapshot
argument_list|(
name|snapshotName
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Somthing went wrong during the restore...
comment|// if the pre-restore snapshot is available try to rollback
if|if
condition|(
name|takeFailSafeSnapshot
condition|)
block|{
try|try
block|{
name|internalRestoreSnapshot
argument_list|(
name|failSafeSnapshotSnapshotName
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
name|String
name|msg
init|=
literal|"Restore snapshot="
operator|+
name|snapshotName
operator|+
literal|" failed. Rollback to snapshot="
operator|+
name|failSafeSnapshotSnapshotName
operator|+
literal|" succeeded."
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RestoreSnapshotException
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"Failed to restore and rollback to snapshot="
operator|+
name|failSafeSnapshotSnapshotName
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RestoreSnapshotException
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|RestoreSnapshotException
argument_list|(
literal|"Failed to restore snapshot="
operator|+
name|snapshotName
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|// If the restore is succeeded, delete the pre-restore snapshot
if|if
condition|(
name|takeFailSafeSnapshot
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleting restore-failsafe snapshot: "
operator|+
name|failSafeSnapshotSnapshotName
argument_list|)
expr_stmt|;
name|deleteSnapshot
argument_list|(
name|failSafeSnapshotSnapshotName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to remove the failsafe snapshot: "
operator|+
name|failSafeSnapshotSnapshotName
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Create a new table by cloning the snapshot content.    *    * @param snapshotName name of the snapshot to be cloned    * @param tableName name of the table where the snapshot will be restored    * @throws IOException if a remote or network exception occurs    * @throws TableExistsException if table to be created already exists    * @throws RestoreSnapshotException if snapshot failed to be cloned    * @throws IllegalArgumentException if the specified table has not a valid name    */
specifier|public
name|void
name|cloneSnapshot
parameter_list|(
specifier|final
name|byte
index|[]
name|snapshotName
parameter_list|,
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
throws|,
name|TableExistsException
throws|,
name|RestoreSnapshotException
block|{
name|cloneSnapshot
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|snapshotName
argument_list|)
argument_list|,
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a new table by cloning the snapshot content.    *    * @param snapshotName name of the snapshot to be cloned    * @param tableName name of the table where the snapshot will be restored    * @throws IOException if a remote or network exception occurs    * @throws TableExistsException if table to be created already exists    * @throws RestoreSnapshotException if snapshot failed to be cloned    * @throws IllegalArgumentException if the specified table has not a valid name    */
annotation|@
name|Override
specifier|public
name|void
name|cloneSnapshot
parameter_list|(
specifier|final
name|byte
index|[]
name|snapshotName
parameter_list|,
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
throws|,
name|TableExistsException
throws|,
name|RestoreSnapshotException
block|{
name|cloneSnapshot
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|snapshotName
argument_list|)
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a new table by cloning the snapshot content.    *    * @param snapshotName name of the snapshot to be cloned    * @param tableName name of the table where the snapshot will be restored    * @throws IOException if a remote or network exception occurs    * @throws TableExistsException if table to be created already exists    * @throws RestoreSnapshotException if snapshot failed to be cloned    * @throws IllegalArgumentException if the specified table has not a valid name    */
specifier|public
name|void
name|cloneSnapshot
parameter_list|(
specifier|final
name|String
name|snapshotName
parameter_list|,
specifier|final
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
throws|,
name|TableExistsException
throws|,
name|RestoreSnapshotException
throws|,
name|InterruptedException
block|{
name|cloneSnapshot
argument_list|(
name|snapshotName
argument_list|,
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a new table by cloning the snapshot content.    *    * @param snapshotName name of the snapshot to be cloned    * @param tableName name of the table where the snapshot will be restored    * @throws IOException if a remote or network exception occurs    * @throws TableExistsException if table to be created already exists    * @throws RestoreSnapshotException if snapshot failed to be cloned    * @throws IllegalArgumentException if the specified table has not a valid name    */
annotation|@
name|Override
specifier|public
name|void
name|cloneSnapshot
parameter_list|(
specifier|final
name|String
name|snapshotName
parameter_list|,
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
throws|,
name|TableExistsException
throws|,
name|RestoreSnapshotException
block|{
if|if
condition|(
name|tableExists
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TableExistsException
argument_list|(
name|tableName
argument_list|)
throw|;
block|}
name|internalRestoreSnapshot
argument_list|(
name|snapshotName
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
name|waitUntilTableIsEnabled
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
comment|/**    * Execute a distributed procedure on a cluster synchronously with return data    *    * @param signature A distributed procedure is uniquely identified    * by its signature (default the root ZK node name of the procedure).    * @param instance The instance name of the procedure. For some procedures, this parameter is    * optional.    * @param props Property/Value pairs of properties passing to the procedure    * @return data returned after procedure execution. null if no return data.    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|execProcedureWithRet
parameter_list|(
name|String
name|signature
parameter_list|,
name|String
name|instance
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|props
parameter_list|)
throws|throws
name|IOException
block|{
name|ProcedureDescription
operator|.
name|Builder
name|builder
init|=
name|ProcedureDescription
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|setSignature
argument_list|(
name|signature
argument_list|)
operator|.
name|setInstance
argument_list|(
name|instance
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|props
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|NameStringPair
name|pair
init|=
name|NameStringPair
operator|.
name|newBuilder
argument_list|()
operator|.
name|setName
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|setValue
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addConfiguration
argument_list|(
name|pair
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ExecProcedureRequest
name|request
init|=
name|ExecProcedureRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|setProcedure
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// run the procedure on the master
name|ExecProcedureResponse
name|response
init|=
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|ExecProcedureResponse
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|ExecProcedureResponse
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|master
operator|.
name|execProcedureWithRet
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
return|return
name|response
operator|.
name|hasReturnData
argument_list|()
condition|?
name|response
operator|.
name|getReturnData
argument_list|()
operator|.
name|toByteArray
argument_list|()
else|:
literal|null
return|;
block|}
comment|/**    * Execute a distributed procedure on a cluster.    *    * @param signature A distributed procedure is uniquely identified    * by its signature (default the root ZK node name of the procedure).    * @param instance The instance name of the procedure. For some procedures, this parameter is    * optional.    * @param props Property/Value pairs of properties passing to the procedure    * @throws IOException    */
annotation|@
name|Override
specifier|public
name|void
name|execProcedure
parameter_list|(
name|String
name|signature
parameter_list|,
name|String
name|instance
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|props
parameter_list|)
throws|throws
name|IOException
block|{
name|ProcedureDescription
operator|.
name|Builder
name|builder
init|=
name|ProcedureDescription
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|setSignature
argument_list|(
name|signature
argument_list|)
operator|.
name|setInstance
argument_list|(
name|instance
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|props
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|NameStringPair
name|pair
init|=
name|NameStringPair
operator|.
name|newBuilder
argument_list|()
operator|.
name|setName
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|setValue
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addConfiguration
argument_list|(
name|pair
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ExecProcedureRequest
name|request
init|=
name|ExecProcedureRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|setProcedure
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// run the procedure on the master
name|ExecProcedureResponse
name|response
init|=
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|ExecProcedureResponse
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|ExecProcedureResponse
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|master
operator|.
name|execProcedure
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|long
name|start
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
decl_stmt|;
name|long
name|max
init|=
name|response
operator|.
name|getExpectedTimeout
argument_list|()
decl_stmt|;
name|long
name|maxPauseTime
init|=
name|max
operator|/
name|this
operator|.
name|numRetries
decl_stmt|;
name|int
name|tries
init|=
literal|0
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting a max of "
operator|+
name|max
operator|+
literal|" ms for procedure '"
operator|+
name|signature
operator|+
literal|" : "
operator|+
name|instance
operator|+
literal|"'' to complete. (max "
operator|+
name|maxPauseTime
operator|+
literal|" ms per retry)"
argument_list|)
expr_stmt|;
name|boolean
name|done
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|tries
operator|==
literal|0
operator|||
operator|(
operator|(
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|-
name|start
operator|)
operator|<
name|max
operator|&&
operator|!
name|done
operator|)
condition|)
block|{
try|try
block|{
comment|// sleep a backoff<= pauseTime amount
name|long
name|sleep
init|=
name|getPauseTime
argument_list|(
name|tries
operator|++
argument_list|)
decl_stmt|;
name|sleep
operator|=
name|sleep
operator|>
name|maxPauseTime
condition|?
name|maxPauseTime
else|:
name|sleep
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"(#"
operator|+
name|tries
operator|+
literal|") Sleeping: "
operator|+
name|sleep
operator|+
literal|"ms while waiting for procedure completion."
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|sleep
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|(
name|InterruptedIOException
operator|)
operator|new
name|InterruptedIOException
argument_list|(
literal|"Interrupted"
argument_list|)
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Getting current status of procedure from master..."
argument_list|)
expr_stmt|;
name|done
operator|=
name|isProcedureFinished
argument_list|(
name|signature
argument_list|,
name|instance
argument_list|,
name|props
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|done
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Procedure '"
operator|+
name|signature
operator|+
literal|" : "
operator|+
name|instance
operator|+
literal|"' wasn't completed in expectedTime:"
operator|+
name|max
operator|+
literal|" ms"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Check the current state of the specified procedure.    *<p>    * There are three possible states:    *<ol>    *<li>running - returns<tt>false</tt></li>    *<li>finished - returns<tt>true</tt></li>    *<li>finished with error - throws the exception that caused the procedure to fail</li>    *</ol>    *<p>    *    * @param signature The signature that uniquely identifies a procedure    * @param instance The instance name of the procedure    * @param props Property/Value pairs of properties passing to the procedure    * @return true if the specified procedure is finished successfully, false if it is still running    * @throws IOException if the specified procedure finished with error    */
annotation|@
name|Override
specifier|public
name|boolean
name|isProcedureFinished
parameter_list|(
name|String
name|signature
parameter_list|,
name|String
name|instance
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|props
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|ProcedureDescription
operator|.
name|Builder
name|builder
init|=
name|ProcedureDescription
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|setSignature
argument_list|(
name|signature
argument_list|)
operator|.
name|setInstance
argument_list|(
name|instance
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|props
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|NameStringPair
name|pair
init|=
name|NameStringPair
operator|.
name|newBuilder
argument_list|()
operator|.
name|setName
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|setValue
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|builder
operator|.
name|addConfiguration
argument_list|(
name|pair
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ProcedureDescription
name|desc
init|=
name|builder
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|IsProcedureDoneResponse
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|IsProcedureDoneResponse
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|master
operator|.
name|isProcedureDone
argument_list|(
literal|null
argument_list|,
name|IsProcedureDoneRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|setProcedure
argument_list|(
name|desc
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
operator|.
name|getDone
argument_list|()
return|;
block|}
comment|/**    * Execute Restore/Clone snapshot and wait for the server to complete (blocking).    * To check if the cloned table exists, use {@link #isTableAvailable} -- it is not safe to    * create an HTable instance to this table before it is available.    * @param snapshotName snapshot to restore    * @param tableName table name to restore the snapshot on    * @throws IOException if a remote or network exception occurs    * @throws RestoreSnapshotException if snapshot failed to be restored    * @throws IllegalArgumentException if the restore request is formatted incorrectly    */
specifier|private
name|void
name|internalRestoreSnapshot
parameter_list|(
specifier|final
name|String
name|snapshotName
parameter_list|,
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
throws|,
name|RestoreSnapshotException
block|{
name|SnapshotDescription
name|snapshot
init|=
name|SnapshotDescription
operator|.
name|newBuilder
argument_list|()
operator|.
name|setName
argument_list|(
name|snapshotName
argument_list|)
operator|.
name|setTable
argument_list|(
name|tableName
operator|.
name|getNameAsString
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// actually restore the snapshot
name|internalRestoreSnapshotAsync
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
specifier|final
name|IsRestoreSnapshotDoneRequest
name|request
init|=
name|IsRestoreSnapshotDoneRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|setSnapshot
argument_list|(
name|snapshot
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|IsRestoreSnapshotDoneResponse
name|done
init|=
name|IsRestoreSnapshotDoneResponse
operator|.
name|newBuilder
argument_list|()
operator|.
name|setDone
argument_list|(
literal|false
argument_list|)
operator|.
name|buildPartial
argument_list|()
decl_stmt|;
specifier|final
name|long
name|maxPauseTime
init|=
literal|5000
decl_stmt|;
name|int
name|tries
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|done
operator|.
name|getDone
argument_list|()
condition|)
block|{
try|try
block|{
comment|// sleep a backoff<= pauseTime amount
name|long
name|sleep
init|=
name|getPauseTime
argument_list|(
name|tries
operator|++
argument_list|)
decl_stmt|;
name|sleep
operator|=
name|sleep
operator|>
name|maxPauseTime
condition|?
name|maxPauseTime
else|:
name|sleep
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|tries
operator|+
literal|") Sleeping: "
operator|+
name|sleep
operator|+
literal|" ms while we wait for snapshot restore to complete."
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|sleep
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|(
name|InterruptedIOException
operator|)
operator|new
name|InterruptedIOException
argument_list|(
literal|"Interrupted"
argument_list|)
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Getting current status of snapshot restore from master..."
argument_list|)
expr_stmt|;
name|done
operator|=
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|IsRestoreSnapshotDoneResponse
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|IsRestoreSnapshotDoneResponse
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|master
operator|.
name|isRestoreSnapshotDone
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|done
operator|.
name|getDone
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RestoreSnapshotException
argument_list|(
literal|"Snapshot '"
operator|+
name|snapshot
operator|.
name|getName
argument_list|()
operator|+
literal|"' wasn't restored."
argument_list|)
throw|;
block|}
block|}
comment|/**    * Execute Restore/Clone snapshot and wait for the server to complete (asynchronous)    *<p>    * Only a single snapshot should be restored at a time, or results may be undefined.    * @param snapshot snapshot to restore    * @return response from the server indicating the max time to wait for the snapshot    * @throws IOException if a remote or network exception occurs    * @throws RestoreSnapshotException if snapshot failed to be restored    * @throws IllegalArgumentException if the restore request is formatted incorrectly    */
specifier|private
name|RestoreSnapshotResponse
name|internalRestoreSnapshotAsync
parameter_list|(
specifier|final
name|SnapshotDescription
name|snapshot
parameter_list|)
throws|throws
name|IOException
throws|,
name|RestoreSnapshotException
block|{
name|ClientSnapshotDescriptionUtils
operator|.
name|assertSnapshotRequestIsValid
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
specifier|final
name|RestoreSnapshotRequest
name|request
init|=
name|RestoreSnapshotRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|setSnapshot
argument_list|(
name|snapshot
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|// run the snapshot restore on the master
return|return
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|RestoreSnapshotResponse
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|RestoreSnapshotResponse
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|master
operator|.
name|restoreSnapshot
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * List completed snapshots.    * @return a list of snapshot descriptors for completed snapshots    * @throws IOException if a network error occurs    */
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|SnapshotDescription
argument_list|>
name|listSnapshots
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|List
argument_list|<
name|SnapshotDescription
argument_list|>
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|SnapshotDescription
argument_list|>
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|master
operator|.
name|getCompletedSnapshots
argument_list|(
literal|null
argument_list|,
name|GetCompletedSnapshotsRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|getSnapshotsList
argument_list|()
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * List all the completed snapshots matching the given regular expression.    *    * @param regex The regular expression to match against    * @return - returns a List of SnapshotDescription    * @throws IOException if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|SnapshotDescription
argument_list|>
name|listSnapshots
parameter_list|(
name|String
name|regex
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|listSnapshots
argument_list|(
name|Pattern
operator|.
name|compile
argument_list|(
name|regex
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * List all the completed snapshots matching the given pattern.    *    * @param pattern The compiled regular expression to match against    * @return - returns a List of SnapshotDescription    * @throws IOException if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|SnapshotDescription
argument_list|>
name|listSnapshots
parameter_list|(
name|Pattern
name|pattern
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|SnapshotDescription
argument_list|>
name|matched
init|=
operator|new
name|LinkedList
argument_list|<
name|SnapshotDescription
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|SnapshotDescription
argument_list|>
name|snapshots
init|=
name|listSnapshots
argument_list|()
decl_stmt|;
for|for
control|(
name|SnapshotDescription
name|snapshot
range|:
name|snapshots
control|)
block|{
if|if
condition|(
name|pattern
operator|.
name|matcher
argument_list|(
name|snapshot
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
name|matched
operator|.
name|add
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|matched
return|;
block|}
comment|/**    * Delete an existing snapshot.    * @param snapshotName name of the snapshot    * @throws IOException if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
name|void
name|deleteSnapshot
parameter_list|(
specifier|final
name|byte
index|[]
name|snapshotName
parameter_list|)
throws|throws
name|IOException
block|{
name|deleteSnapshot
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|snapshotName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete an existing snapshot.    * @param snapshotName name of the snapshot    * @throws IOException if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
name|void
name|deleteSnapshot
parameter_list|(
specifier|final
name|String
name|snapshotName
parameter_list|)
throws|throws
name|IOException
block|{
comment|// make sure the snapshot is possibly valid
name|TableName
operator|.
name|isLegalFullyQualifiedTableName
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|snapshotName
argument_list|)
argument_list|)
expr_stmt|;
comment|// do the delete
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Void
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
name|master
operator|.
name|deleteSnapshot
argument_list|(
literal|null
argument_list|,
name|DeleteSnapshotRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|setSnapshot
argument_list|(
name|SnapshotDescription
operator|.
name|newBuilder
argument_list|()
operator|.
name|setName
argument_list|(
name|snapshotName
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete existing snapshots whose names match the pattern passed.    * @param regex The regular expression to match against    * @throws IOException if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
name|void
name|deleteSnapshots
parameter_list|(
specifier|final
name|String
name|regex
parameter_list|)
throws|throws
name|IOException
block|{
name|deleteSnapshots
argument_list|(
name|Pattern
operator|.
name|compile
argument_list|(
name|regex
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete existing snapshots whose names match the pattern passed.    * @param pattern pattern for names of the snapshot to match    * @throws IOException if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
name|void
name|deleteSnapshots
parameter_list|(
specifier|final
name|Pattern
name|pattern
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|SnapshotDescription
argument_list|>
name|snapshots
init|=
name|listSnapshots
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|SnapshotDescription
name|snapshot
range|:
name|snapshots
control|)
block|{
try|try
block|{
name|internalDeleteSnapshot
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to delete snapshot "
operator|+
name|snapshot
operator|.
name|getName
argument_list|()
operator|+
literal|" for table "
operator|+
name|snapshot
operator|.
name|getTable
argument_list|()
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|internalDeleteSnapshot
parameter_list|(
specifier|final
name|SnapshotDescription
name|snapshot
parameter_list|)
throws|throws
name|IOException
block|{
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Void
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
name|this
operator|.
name|master
operator|.
name|deleteSnapshot
argument_list|(
literal|null
argument_list|,
name|DeleteSnapshotRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|setSnapshot
argument_list|(
name|snapshot
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Apply the new quota settings.    *    * @param quota the quota settings    * @throws IOException if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
name|void
name|setQuota
parameter_list|(
specifier|final
name|QuotaSettings
name|quota
parameter_list|)
throws|throws
name|IOException
block|{
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Void
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Void
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
name|this
operator|.
name|master
operator|.
name|setQuota
argument_list|(
literal|null
argument_list|,
name|QuotaSettings
operator|.
name|buildSetQuotaRequestProto
argument_list|(
name|quota
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return a Quota Scanner to list the quotas based on the filter.    *    * @param filter the quota settings filter    * @return the quota scanner    * @throws IOException if a remote or network exception occurs    */
annotation|@
name|Override
specifier|public
name|QuotaRetriever
name|getQuotaRetriever
parameter_list|(
specifier|final
name|QuotaFilter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|QuotaRetriever
operator|.
name|open
argument_list|(
name|conf
argument_list|,
name|filter
argument_list|)
return|;
block|}
specifier|private
parameter_list|<
name|C
extends|extends
name|RetryingCallable
argument_list|<
name|V
argument_list|>
operator|&
name|Closeable
parameter_list|,
name|V
parameter_list|>
name|V
name|executeCallable
parameter_list|(
name|C
name|callable
parameter_list|)
throws|throws
name|IOException
block|{
name|RpcRetryingCaller
argument_list|<
name|V
argument_list|>
name|caller
init|=
name|rpcCallerFactory
operator|.
name|newCaller
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|caller
operator|.
name|callWithRetries
argument_list|(
name|callable
argument_list|,
name|operationTimeout
argument_list|)
return|;
block|}
finally|finally
block|{
name|callable
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Creates and returns a {@link com.google.protobuf.RpcChannel} instance    * connected to the active master.    *    *<p>    * The obtained {@link com.google.protobuf.RpcChannel} instance can be used to access a published    * coprocessor {@link com.google.protobuf.Service} using standard protobuf service invocations:    *</p>    *    *<div style="background-color: #cccccc; padding: 2px">    *<blockquote><pre>    * CoprocessorRpcChannel channel = myAdmin.coprocessorService();    * MyService.BlockingInterface service = MyService.newBlockingStub(channel);    * MyCallRequest request = MyCallRequest.newBuilder()    *     ...    *     .build();    * MyCallResponse response = service.myCall(null, request);    *</pre></blockquote></div>    *    * @return A MasterCoprocessorRpcChannel instance    */
annotation|@
name|Override
specifier|public
name|CoprocessorRpcChannel
name|coprocessorService
parameter_list|()
block|{
return|return
operator|new
name|MasterCoprocessorRpcChannel
argument_list|(
name|connection
argument_list|)
return|;
block|}
comment|/**    * Simple {@link Abortable}, throwing RuntimeException on abort.    */
specifier|private
specifier|static
class|class
name|ThrowableAbortable
implements|implements
name|Abortable
block|{
annotation|@
name|Override
specifier|public
name|void
name|abort
parameter_list|(
name|String
name|why
parameter_list|,
name|Throwable
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|why
argument_list|,
name|e
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isAborted
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Creates and returns a {@link com.google.protobuf.RpcChannel} instance    * connected to the passed region server.    *    *<p>    * The obtained {@link com.google.protobuf.RpcChannel} instance can be used to access a published    * coprocessor {@link com.google.protobuf.Service} using standard protobuf service invocations:    *</p>    *    *<div style="background-color: #cccccc; padding: 2px">    *<blockquote><pre>    * CoprocessorRpcChannel channel = myAdmin.coprocessorService(serverName);    * MyService.BlockingInterface service = MyService.newBlockingStub(channel);    * MyCallRequest request = MyCallRequest.newBuilder()    *     ...    *     .build();    * MyCallResponse response = service.myCall(null, request);    *</pre></blockquote></div>    *    * @param sn the server name to which the endpoint call is made    * @return A RegionServerCoprocessorRpcChannel instance    */
annotation|@
name|Override
specifier|public
name|CoprocessorRpcChannel
name|coprocessorService
parameter_list|(
name|ServerName
name|sn
parameter_list|)
block|{
return|return
operator|new
name|RegionServerCoprocessorRpcChannel
argument_list|(
name|connection
argument_list|,
name|sn
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|updateConfiguration
parameter_list|(
name|ServerName
name|server
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|this
operator|.
name|connection
operator|.
name|getAdmin
argument_list|(
name|server
argument_list|)
operator|.
name|updateConfiguration
argument_list|(
literal|null
argument_list|,
name|UpdateConfigurationRequest
operator|.
name|getDefaultInstance
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|e
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|updateConfiguration
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|ServerName
name|server
range|:
name|this
operator|.
name|getClusterStatus
argument_list|()
operator|.
name|getServers
argument_list|()
control|)
block|{
name|updateConfiguration
argument_list|(
name|server
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|getMasterInfoPort
parameter_list|()
throws|throws
name|IOException
block|{
comment|// TODO: Fix!  Reaching into internal implementation!!!!
name|ConnectionManager
operator|.
name|HConnectionImplementation
name|connection
init|=
operator|(
name|ConnectionManager
operator|.
name|HConnectionImplementation
operator|)
name|this
operator|.
name|connection
decl_stmt|;
name|ZooKeeperKeepAliveConnection
name|zkw
init|=
name|connection
operator|.
name|getKeepAliveZooKeeperWatcher
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|MasterAddressTracker
operator|.
name|getMasterInfoPort
argument_list|(
name|zkw
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to get master info port from MasterAddressTracker"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|long
name|getLastMajorCompactionTimestamp
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Long
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Long
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
name|MajorCompactionTimestampRequest
name|req
init|=
name|MajorCompactionTimestampRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|setTableName
argument_list|(
name|ProtobufUtil
operator|.
name|toProtoTableName
argument_list|(
name|tableName
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|master
operator|.
name|getLastMajorCompactionTimestamp
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
operator|.
name|getCompactionTimestamp
argument_list|()
return|;
block|}
block|}
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getLastMajorCompactionTimestampForRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|executeCallable
argument_list|(
operator|new
name|MasterCallable
argument_list|<
name|Long
argument_list|>
argument_list|(
name|getConnection
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Long
name|call
parameter_list|(
name|int
name|callTimeout
parameter_list|)
throws|throws
name|ServiceException
block|{
name|MajorCompactionTimestampForRegionRequest
name|req
init|=
name|MajorCompactionTimestampForRegionRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|setRegion
argument_list|(
name|RequestConverter
operator|.
name|buildRegionSpecifier
argument_list|(
name|RegionSpecifierType
operator|.
name|REGION_NAME
argument_list|,
name|regionName
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|master
operator|.
name|getLastMajorCompactionTimestampForRegion
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
operator|.
name|getCompactionTimestamp
argument_list|()
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|compactMob
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|columnFamily
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|checkTableNameNotNull
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|checkFamilyNameNotNull
argument_list|(
name|columnFamily
argument_list|)
expr_stmt|;
name|validateMobColumnFamily
argument_list|(
name|tableName
argument_list|,
name|columnFamily
argument_list|)
expr_stmt|;
name|compactMob
argument_list|(
name|tableName
argument_list|,
name|columnFamily
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|compactMob
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|checkTableNameNotNull
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|compactMob
argument_list|(
name|tableName
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|majorCompactMob
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|columnFamily
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|checkTableNameNotNull
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|checkFamilyNameNotNull
argument_list|(
name|columnFamily
argument_list|)
expr_stmt|;
name|validateMobColumnFamily
argument_list|(
name|tableName
argument_list|,
name|columnFamily
argument_list|)
expr_stmt|;
name|compactMob
argument_list|(
name|tableName
argument_list|,
name|columnFamily
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|majorCompactMob
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|checkTableNameNotNull
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|compactMob
argument_list|(
name|tableName
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|CompactionState
name|getMobCompactionState
parameter_list|(
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|checkTableNameNotNull
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
try|try
block|{
name|ServerName
name|master
init|=
name|getClusterStatus
argument_list|()
operator|.
name|getMaster
argument_list|()
decl_stmt|;
name|HRegionInfo
name|info
init|=
operator|new
name|HRegionInfo
argument_list|(
name|tableName
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|".mob"
argument_list|)
argument_list|,
name|HConstants
operator|.
name|EMPTY_END_ROW
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|GetRegionInfoRequest
name|request
init|=
name|RequestConverter
operator|.
name|buildGetRegionInfoRequest
argument_list|(
name|info
operator|.
name|getRegionName
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|GetRegionInfoResponse
name|response
init|=
name|this
operator|.
name|connection
operator|.
name|getAdmin
argument_list|(
name|master
argument_list|)
operator|.
name|getRegionInfo
argument_list|(
literal|null
argument_list|,
name|request
argument_list|)
decl_stmt|;
return|return
name|response
operator|.
name|getCompactionState
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
block|}
comment|/**    * Compacts the mob files in a mob-enabled column family. Asynchronous operation.    * @param tableName The table to compact.    * @param columnFamily The column family to compact. If it is null, all the mob-enabled    *        column families in this table will be compacted.    * @param major Whether to select all the mob files in the compaction.    * @throws IOException    * @throws InterruptedException    */
specifier|private
name|void
name|compactMob
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|columnFamily
parameter_list|,
name|boolean
name|major
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
comment|// get the mob region info, this is a dummy region.
name|HRegionInfo
name|info
init|=
operator|new
name|HRegionInfo
argument_list|(
name|tableName
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|".mob"
argument_list|)
argument_list|,
name|HConstants
operator|.
name|EMPTY_END_ROW
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ServerName
name|master
init|=
name|getClusterStatus
argument_list|()
operator|.
name|getMaster
argument_list|()
decl_stmt|;
name|compact
argument_list|(
name|master
argument_list|,
name|info
argument_list|,
name|major
argument_list|,
name|columnFamily
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkTableNameNotNull
parameter_list|(
name|TableName
name|tableName
parameter_list|)
block|{
if|if
condition|(
name|tableName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"TableName cannot be null"
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|checkFamilyNameNotNull
parameter_list|(
name|byte
index|[]
name|columnFamily
parameter_list|)
block|{
if|if
condition|(
name|columnFamily
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The column family name cannot be null"
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|validateMobColumnFamily
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|byte
index|[]
name|columnFamily
parameter_list|)
throws|throws
name|IOException
block|{
name|HTableDescriptor
name|htd
init|=
name|getTableDescriptor
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|HColumnDescriptor
name|family
init|=
name|htd
operator|.
name|getFamily
argument_list|(
name|columnFamily
argument_list|)
decl_stmt|;
if|if
condition|(
name|family
operator|==
literal|null
operator|||
operator|!
name|family
operator|.
name|isMobEnabled
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Column family "
operator|+
name|columnFamily
operator|+
literal|" is not a mob column family"
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

