begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ConnectionUtils
operator|.
name|SLEEP_DELTA_NS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ConnectionUtils
operator|.
name|getPauseTime
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ConnectionUtils
operator|.
name|incRPCCallsMetrics
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ConnectionUtils
operator|.
name|incRPCRetriesMetrics
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ConnectionUtils
operator|.
name|noMoreResultsForReverseScan
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ConnectionUtils
operator|.
name|noMoreResultsForScan
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ConnectionUtils
operator|.
name|resetController
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ConnectionUtils
operator|.
name|translateException
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ConnectionUtils
operator|.
name|updateResultsMetrics
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ConnectionUtils
operator|.
name|updateServerSideMetrics
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CompletableFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|DoNotRetryIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NotServingRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|UnknownScannerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|AdvancedScanResultConsumer
operator|.
name|ScanResumer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|metrics
operator|.
name|ScanMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|OutOfOrderScannerNextException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|ScannerResetException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HBaseRpcController
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RegionServerStoppedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|util
operator|.
name|Timeout
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|util
operator|.
name|Timer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|RequestConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|ResponseConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClientProtos
operator|.
name|ClientService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClientProtos
operator|.
name|ClientService
operator|.
name|Interface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClientProtos
operator|.
name|ScanRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClientProtos
operator|.
name|ScanResponse
import|;
end_import

begin_comment
comment|/**  * Retry caller for scanning a region.  *<p>  * We will modify the {@link Scan} object passed in directly. The upper layer should store the  * reference of this object and use it to open new single region scanners.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
class|class
name|AsyncScanSingleRegionRpcRetryingCaller
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|AsyncScanSingleRegionRpcRetryingCaller
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|Timer
name|retryTimer
decl_stmt|;
specifier|private
specifier|final
name|Scan
name|scan
decl_stmt|;
specifier|private
specifier|final
name|ScanMetrics
name|scanMetrics
decl_stmt|;
specifier|private
specifier|final
name|long
name|scannerId
decl_stmt|;
specifier|private
specifier|final
name|ScanResultCache
name|resultCache
decl_stmt|;
specifier|private
specifier|final
name|AdvancedScanResultConsumer
name|consumer
decl_stmt|;
specifier|private
specifier|final
name|ClientService
operator|.
name|Interface
name|stub
decl_stmt|;
specifier|private
specifier|final
name|HRegionLocation
name|loc
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|regionServerRemote
decl_stmt|;
specifier|private
specifier|final
name|long
name|scannerLeaseTimeoutPeriodNs
decl_stmt|;
specifier|private
specifier|final
name|long
name|pauseNs
decl_stmt|;
specifier|private
specifier|final
name|int
name|maxAttempts
decl_stmt|;
specifier|private
specifier|final
name|long
name|scanTimeoutNs
decl_stmt|;
specifier|private
specifier|final
name|long
name|rpcTimeoutNs
decl_stmt|;
specifier|private
specifier|final
name|int
name|startLogErrorsCnt
decl_stmt|;
specifier|private
specifier|final
name|Runnable
name|completeWhenNoMoreResultsInRegion
decl_stmt|;
specifier|private
specifier|final
name|CompletableFuture
argument_list|<
name|Boolean
argument_list|>
name|future
decl_stmt|;
specifier|private
specifier|final
name|HBaseRpcController
name|controller
decl_stmt|;
specifier|private
name|byte
index|[]
name|nextStartRowWhenError
decl_stmt|;
specifier|private
name|boolean
name|includeNextStartRowWhenError
decl_stmt|;
specifier|private
name|long
name|nextCallStartNs
decl_stmt|;
specifier|private
name|int
name|tries
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|RetriesExhaustedException
operator|.
name|ThrowableWithExtraContext
argument_list|>
name|exceptions
decl_stmt|;
specifier|private
name|long
name|nextCallSeq
init|=
operator|-
literal|1L
decl_stmt|;
specifier|private
enum|enum
name|ScanControllerState
block|{
name|INITIALIZED
block|,
name|SUSPENDED
block|,
name|TERMINATED
block|,
name|DESTROYED
block|}
comment|// Since suspend and terminate should only be called within onNext or onHeartbeat(see the comments
comment|// of RawScanResultConsumer.onNext and onHeartbeat), we need to add some check to prevent invalid
comment|// usage. We use two things to prevent invalid usage:
comment|// 1. Record the thread that construct the ScanControllerImpl instance. We will throw an
comment|// IllegalStateException if the caller thread is not this thread.
comment|// 2. The ControllerState. The initial state is INITIALIZED, if you call suspend, the state will
comment|// be transformed to SUSPENDED, and if you call terminate, the state will be transformed to
comment|// TERMINATED. And when we are back from onNext or onHeartbeat in the onComplete method, we will
comment|// call destroy to get the current state and set the state to DESTROYED. And when user calls
comment|// suspend or terminate, we will check if the current state is INITIALIZED, if not we will throw
comment|// an IllegalStateException. Notice that the DESTROYED state is necessary as you may not call
comment|// suspend or terminate so the state will still be INITIALIZED when back from onNext or
comment|// onHeartbeat. We need another state to replace the INITIALIZED state to prevent the controller
comment|// to be used in the future.
comment|// Notice that, the public methods of this class is supposed to be called by upper layer only, and
comment|// package private methods can only be called within the implementation of
comment|// AsyncScanSingleRegionRpcRetryingCaller.
specifier|private
specifier|final
class|class
name|ScanControllerImpl
implements|implements
name|AdvancedScanResultConsumer
operator|.
name|ScanController
block|{
comment|// Make sure the methods are only called in this thread.
specifier|private
specifier|final
name|Thread
name|callerThread
decl_stmt|;
specifier|private
specifier|final
name|Optional
argument_list|<
name|Cursor
argument_list|>
name|cursor
decl_stmt|;
comment|// INITIALIZED -> SUSPENDED -> DESTROYED
comment|// INITIALIZED -> TERMINATED -> DESTROYED
comment|// INITIALIZED -> DESTROYED
comment|// If the state is incorrect we will throw IllegalStateException.
specifier|private
name|ScanControllerState
name|state
init|=
name|ScanControllerState
operator|.
name|INITIALIZED
decl_stmt|;
specifier|private
name|ScanResumerImpl
name|resumer
decl_stmt|;
specifier|public
name|ScanControllerImpl
parameter_list|(
name|Optional
argument_list|<
name|Cursor
argument_list|>
name|cursor
parameter_list|)
block|{
name|this
operator|.
name|callerThread
operator|=
name|Thread
operator|.
name|currentThread
argument_list|()
expr_stmt|;
name|this
operator|.
name|cursor
operator|=
name|cursor
expr_stmt|;
block|}
specifier|private
name|void
name|preCheck
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|==
name|callerThread
argument_list|,
literal|"The current thread is %s, expected thread is %s, "
operator|+
literal|"you should not call this method outside onNext or onHeartbeat"
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|,
name|callerThread
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|state
operator|.
name|equals
argument_list|(
name|ScanControllerState
operator|.
name|INITIALIZED
argument_list|)
argument_list|,
literal|"Invalid Stopper state %s"
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|ScanResumer
name|suspend
parameter_list|()
block|{
name|preCheck
argument_list|()
expr_stmt|;
name|state
operator|=
name|ScanControllerState
operator|.
name|SUSPENDED
expr_stmt|;
name|ScanResumerImpl
name|resumer
init|=
operator|new
name|ScanResumerImpl
argument_list|()
decl_stmt|;
name|this
operator|.
name|resumer
operator|=
name|resumer
expr_stmt|;
return|return
name|resumer
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|terminate
parameter_list|()
block|{
name|preCheck
argument_list|()
expr_stmt|;
name|state
operator|=
name|ScanControllerState
operator|.
name|TERMINATED
expr_stmt|;
block|}
comment|// return the current state, and set the state to DESTROYED.
name|ScanControllerState
name|destroy
parameter_list|()
block|{
name|ScanControllerState
name|state
init|=
name|this
operator|.
name|state
decl_stmt|;
name|this
operator|.
name|state
operator|=
name|ScanControllerState
operator|.
name|DESTROYED
expr_stmt|;
return|return
name|state
return|;
block|}
annotation|@
name|Override
specifier|public
name|Optional
argument_list|<
name|Cursor
argument_list|>
name|cursor
parameter_list|()
block|{
return|return
name|cursor
return|;
block|}
block|}
specifier|private
enum|enum
name|ScanResumerState
block|{
name|INITIALIZED
block|,
name|SUSPENDED
block|,
name|RESUMED
block|}
comment|// The resume method is allowed to be called in another thread so here we also use the
comment|// ResumerState to prevent race. The initial state is INITIALIZED, and in most cases, when back
comment|// from onNext or onHeartbeat, we will call the prepare method to change the state to SUSPENDED,
comment|// and when user calls resume method, we will change the state to RESUMED. But the resume method
comment|// could be called in other thread, and in fact, user could just do this:
comment|// controller.suspend().resume()
comment|// This is strange but valid. This means the scan could be resumed before we call the prepare
comment|// method to do the actual suspend work. So in the resume method, we will check if the state is
comment|// INTIALIZED, if it is, then we will just set the state to RESUMED and return. And in prepare
comment|// method, if the state is RESUMED already, we will just return an let the scan go on.
comment|// Notice that, the public methods of this class is supposed to be called by upper layer only, and
comment|// package private methods can only be called within the implementation of
comment|// AsyncScanSingleRegionRpcRetryingCaller.
specifier|private
specifier|final
class|class
name|ScanResumerImpl
implements|implements
name|AdvancedScanResultConsumer
operator|.
name|ScanResumer
block|{
comment|// INITIALIZED -> SUSPENDED -> RESUMED
comment|// INITIALIZED -> RESUMED
specifier|private
name|ScanResumerState
name|state
init|=
name|ScanResumerState
operator|.
name|INITIALIZED
decl_stmt|;
specifier|private
name|ScanResponse
name|resp
decl_stmt|;
specifier|private
name|int
name|numberOfCompleteRows
decl_stmt|;
comment|// If the scan is suspended successfully, we need to do lease renewal to prevent it being closed
comment|// by RS due to lease expire. It is a one-time timer task so we need to schedule a new task
comment|// every time when the previous task is finished. There could also be race as the renewal is
comment|// executed in the timer thread, so we also need to check the state before lease renewal. If the
comment|// state is RESUMED already, we will give up lease renewal and also not schedule the next lease
comment|// renewal task.
specifier|private
name|Timeout
name|leaseRenewer
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|resume
parameter_list|()
block|{
comment|// just used to fix findbugs warnings. In fact, if resume is called before prepare, then we
comment|// just return at the first if condition without loading the resp and numValidResuls field. If
comment|// resume is called after suspend, then it is also safe to just reference resp and
comment|// numValidResults after the synchronized block as no one will change it anymore.
name|ScanResponse
name|localResp
decl_stmt|;
name|int
name|localNumberOfCompleteRows
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|state
operator|==
name|ScanResumerState
operator|.
name|INITIALIZED
condition|)
block|{
comment|// user calls this method before we call prepare, so just set the state to
comment|// RESUMED, the implementation will just go on.
name|state
operator|=
name|ScanResumerState
operator|.
name|RESUMED
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|state
operator|==
name|ScanResumerState
operator|.
name|RESUMED
condition|)
block|{
comment|// already resumed, give up.
return|return;
block|}
name|state
operator|=
name|ScanResumerState
operator|.
name|RESUMED
expr_stmt|;
if|if
condition|(
name|leaseRenewer
operator|!=
literal|null
condition|)
block|{
name|leaseRenewer
operator|.
name|cancel
argument_list|()
expr_stmt|;
block|}
name|localResp
operator|=
name|this
operator|.
name|resp
expr_stmt|;
name|localNumberOfCompleteRows
operator|=
name|this
operator|.
name|numberOfCompleteRows
expr_stmt|;
block|}
name|completeOrNext
argument_list|(
name|localResp
argument_list|,
name|localNumberOfCompleteRows
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|scheduleRenewLeaseTask
parameter_list|()
block|{
name|leaseRenewer
operator|=
name|retryTimer
operator|.
name|newTimeout
argument_list|(
name|t
lambda|->
name|tryRenewLease
argument_list|()
argument_list|,
name|scannerLeaseTimeoutPeriodNs
operator|/
literal|2
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|synchronized
name|void
name|tryRenewLease
parameter_list|()
block|{
comment|// the scan has already been resumed, give up
if|if
condition|(
name|state
operator|==
name|ScanResumerState
operator|.
name|RESUMED
condition|)
block|{
return|return;
block|}
name|renewLease
argument_list|()
expr_stmt|;
comment|// schedule the next renew lease task again as this is a one-time task.
name|scheduleRenewLeaseTask
argument_list|()
expr_stmt|;
block|}
comment|// return false if the scan has already been resumed. See the comment above for ScanResumerImpl
comment|// for more details.
specifier|synchronized
name|boolean
name|prepare
parameter_list|(
name|ScanResponse
name|resp
parameter_list|,
name|int
name|numberOfCompleteRows
parameter_list|)
block|{
if|if
condition|(
name|state
operator|==
name|ScanResumerState
operator|.
name|RESUMED
condition|)
block|{
comment|// user calls resume before we actually suspend the scan, just continue;
return|return
literal|false
return|;
block|}
name|state
operator|=
name|ScanResumerState
operator|.
name|SUSPENDED
expr_stmt|;
name|this
operator|.
name|resp
operator|=
name|resp
expr_stmt|;
name|this
operator|.
name|numberOfCompleteRows
operator|=
name|numberOfCompleteRows
expr_stmt|;
comment|// if there are no more results in region then the scanner at RS side will be closed
comment|// automatically so we do not need to renew lease.
if|if
condition|(
name|resp
operator|.
name|getMoreResultsInRegion
argument_list|()
condition|)
block|{
comment|// schedule renew lease task
name|scheduleRenewLeaseTask
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
specifier|public
name|AsyncScanSingleRegionRpcRetryingCaller
parameter_list|(
name|Timer
name|retryTimer
parameter_list|,
name|AsyncConnectionImpl
name|conn
parameter_list|,
name|Scan
name|scan
parameter_list|,
name|ScanMetrics
name|scanMetrics
parameter_list|,
name|long
name|scannerId
parameter_list|,
name|ScanResultCache
name|resultCache
parameter_list|,
name|AdvancedScanResultConsumer
name|consumer
parameter_list|,
name|Interface
name|stub
parameter_list|,
name|HRegionLocation
name|loc
parameter_list|,
name|boolean
name|isRegionServerRemote
parameter_list|,
name|long
name|scannerLeaseTimeoutPeriodNs
parameter_list|,
name|long
name|pauseNs
parameter_list|,
name|int
name|maxAttempts
parameter_list|,
name|long
name|scanTimeoutNs
parameter_list|,
name|long
name|rpcTimeoutNs
parameter_list|,
name|int
name|startLogErrorsCnt
parameter_list|)
block|{
name|this
operator|.
name|retryTimer
operator|=
name|retryTimer
expr_stmt|;
name|this
operator|.
name|scan
operator|=
name|scan
expr_stmt|;
name|this
operator|.
name|scanMetrics
operator|=
name|scanMetrics
expr_stmt|;
name|this
operator|.
name|scannerId
operator|=
name|scannerId
expr_stmt|;
name|this
operator|.
name|resultCache
operator|=
name|resultCache
expr_stmt|;
name|this
operator|.
name|consumer
operator|=
name|consumer
expr_stmt|;
name|this
operator|.
name|stub
operator|=
name|stub
expr_stmt|;
name|this
operator|.
name|loc
operator|=
name|loc
expr_stmt|;
name|this
operator|.
name|regionServerRemote
operator|=
name|isRegionServerRemote
expr_stmt|;
name|this
operator|.
name|scannerLeaseTimeoutPeriodNs
operator|=
name|scannerLeaseTimeoutPeriodNs
expr_stmt|;
name|this
operator|.
name|pauseNs
operator|=
name|pauseNs
expr_stmt|;
name|this
operator|.
name|maxAttempts
operator|=
name|maxAttempts
expr_stmt|;
name|this
operator|.
name|scanTimeoutNs
operator|=
name|scanTimeoutNs
expr_stmt|;
name|this
operator|.
name|rpcTimeoutNs
operator|=
name|rpcTimeoutNs
expr_stmt|;
name|this
operator|.
name|startLogErrorsCnt
operator|=
name|startLogErrorsCnt
expr_stmt|;
if|if
condition|(
name|scan
operator|.
name|isReversed
argument_list|()
condition|)
block|{
name|completeWhenNoMoreResultsInRegion
operator|=
name|this
operator|::
name|completeReversedWhenNoMoreResultsInRegion
expr_stmt|;
block|}
else|else
block|{
name|completeWhenNoMoreResultsInRegion
operator|=
name|this
operator|::
name|completeWhenNoMoreResultsInRegion
expr_stmt|;
block|}
name|this
operator|.
name|future
operator|=
operator|new
name|CompletableFuture
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|controller
operator|=
name|conn
operator|.
name|rpcControllerFactory
operator|.
name|newController
argument_list|()
expr_stmt|;
name|this
operator|.
name|exceptions
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
specifier|private
name|long
name|elapsedMs
parameter_list|()
block|{
return|return
name|TimeUnit
operator|.
name|NANOSECONDS
operator|.
name|toMillis
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|nextCallStartNs
argument_list|)
return|;
block|}
specifier|private
name|long
name|remainingTimeNs
parameter_list|()
block|{
return|return
name|scanTimeoutNs
operator|-
operator|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|nextCallStartNs
operator|)
return|;
block|}
specifier|private
name|void
name|closeScanner
parameter_list|()
block|{
name|incRPCCallsMetrics
argument_list|(
name|scanMetrics
argument_list|,
name|regionServerRemote
argument_list|)
expr_stmt|;
name|resetController
argument_list|(
name|controller
argument_list|,
name|rpcTimeoutNs
argument_list|)
expr_stmt|;
name|ScanRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildScanRequest
argument_list|(
name|this
operator|.
name|scannerId
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|stub
operator|.
name|scan
argument_list|(
name|controller
argument_list|,
name|req
argument_list|,
name|resp
lambda|->
block|{
if|if
condition|(
name|controller
operator|.
name|failed
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Call to "
operator|+
name|loc
operator|.
name|getServerName
argument_list|()
operator|+
literal|" for closing scanner id = "
operator|+
name|scannerId
operator|+
literal|" for "
operator|+
name|loc
operator|.
name|getRegion
argument_list|()
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" of "
operator|+
name|loc
operator|.
name|getRegion
argument_list|()
operator|.
name|getTable
argument_list|()
operator|+
literal|" failed, ignore, probably already closed"
argument_list|,
name|controller
operator|.
name|getFailed
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|completeExceptionally
parameter_list|(
name|boolean
name|closeScanner
parameter_list|)
block|{
name|resultCache
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|closeScanner
condition|)
block|{
name|closeScanner
argument_list|()
expr_stmt|;
block|}
name|future
operator|.
name|completeExceptionally
argument_list|(
operator|new
name|RetriesExhaustedException
argument_list|(
name|tries
operator|-
literal|1
argument_list|,
name|exceptions
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|completeNoMoreResults
parameter_list|()
block|{
name|future
operator|.
name|complete
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|completeWithNextStartRow
parameter_list|(
name|byte
index|[]
name|row
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
block|{
name|scan
operator|.
name|withStartRow
argument_list|(
name|row
argument_list|,
name|inclusive
argument_list|)
expr_stmt|;
name|future
operator|.
name|complete
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|completeWhenError
parameter_list|(
name|boolean
name|closeScanner
parameter_list|)
block|{
name|incRPCRetriesMetrics
argument_list|(
name|scanMetrics
argument_list|,
name|closeScanner
argument_list|)
expr_stmt|;
name|resultCache
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|closeScanner
condition|)
block|{
name|closeScanner
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|nextStartRowWhenError
operator|!=
literal|null
condition|)
block|{
name|scan
operator|.
name|withStartRow
argument_list|(
name|nextStartRowWhenError
argument_list|,
name|includeNextStartRowWhenError
argument_list|)
expr_stmt|;
block|}
name|future
operator|.
name|complete
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|onError
parameter_list|(
name|Throwable
name|error
parameter_list|)
block|{
name|error
operator|=
name|translateException
argument_list|(
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|tries
operator|>
name|startLogErrorsCnt
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Call to "
operator|+
name|loc
operator|.
name|getServerName
argument_list|()
operator|+
literal|" for scanner id = "
operator|+
name|scannerId
operator|+
literal|" for "
operator|+
name|loc
operator|.
name|getRegion
argument_list|()
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" of "
operator|+
name|loc
operator|.
name|getRegion
argument_list|()
operator|.
name|getTable
argument_list|()
operator|+
literal|" failed, , tries = "
operator|+
name|tries
operator|+
literal|", maxAttempts = "
operator|+
name|maxAttempts
operator|+
literal|", timeout = "
operator|+
name|TimeUnit
operator|.
name|NANOSECONDS
operator|.
name|toMillis
argument_list|(
name|scanTimeoutNs
argument_list|)
operator|+
literal|" ms, time elapsed = "
operator|+
name|elapsedMs
argument_list|()
operator|+
literal|" ms"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|boolean
name|scannerClosed
init|=
name|error
operator|instanceof
name|UnknownScannerException
operator|||
name|error
operator|instanceof
name|NotServingRegionException
operator|||
name|error
operator|instanceof
name|RegionServerStoppedException
decl_stmt|;
name|RetriesExhaustedException
operator|.
name|ThrowableWithExtraContext
name|qt
init|=
operator|new
name|RetriesExhaustedException
operator|.
name|ThrowableWithExtraContext
argument_list|(
name|error
argument_list|,
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|exceptions
operator|.
name|add
argument_list|(
name|qt
argument_list|)
expr_stmt|;
if|if
condition|(
name|tries
operator|>=
name|maxAttempts
condition|)
block|{
name|completeExceptionally
argument_list|(
operator|!
name|scannerClosed
argument_list|)
expr_stmt|;
return|return;
block|}
name|long
name|delayNs
decl_stmt|;
if|if
condition|(
name|scanTimeoutNs
operator|>
literal|0
condition|)
block|{
name|long
name|maxDelayNs
init|=
name|remainingTimeNs
argument_list|()
operator|-
name|SLEEP_DELTA_NS
decl_stmt|;
if|if
condition|(
name|maxDelayNs
operator|<=
literal|0
condition|)
block|{
name|completeExceptionally
argument_list|(
operator|!
name|scannerClosed
argument_list|)
expr_stmt|;
return|return;
block|}
name|delayNs
operator|=
name|Math
operator|.
name|min
argument_list|(
name|maxDelayNs
argument_list|,
name|getPauseTime
argument_list|(
name|pauseNs
argument_list|,
name|tries
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|delayNs
operator|=
name|getPauseTime
argument_list|(
name|pauseNs
argument_list|,
name|tries
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scannerClosed
condition|)
block|{
name|completeWhenError
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|error
operator|instanceof
name|OutOfOrderScannerNextException
operator|||
name|error
operator|instanceof
name|ScannerResetException
condition|)
block|{
name|completeWhenError
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|error
operator|instanceof
name|DoNotRetryIOException
condition|)
block|{
name|completeExceptionally
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
name|tries
operator|++
expr_stmt|;
name|retryTimer
operator|.
name|newTimeout
argument_list|(
name|t
lambda|->
name|call
argument_list|()
argument_list|,
name|delayNs
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|updateNextStartRowWhenError
parameter_list|(
name|Result
name|result
parameter_list|)
block|{
name|nextStartRowWhenError
operator|=
name|result
operator|.
name|getRow
argument_list|()
expr_stmt|;
name|includeNextStartRowWhenError
operator|=
name|result
operator|.
name|mayHaveMoreCellsInRow
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|completeWhenNoMoreResultsInRegion
parameter_list|()
block|{
if|if
condition|(
name|noMoreResultsForScan
argument_list|(
name|scan
argument_list|,
name|loc
operator|.
name|getRegion
argument_list|()
argument_list|)
condition|)
block|{
name|completeNoMoreResults
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|completeWithNextStartRow
argument_list|(
name|loc
operator|.
name|getRegion
argument_list|()
operator|.
name|getEndKey
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|completeReversedWhenNoMoreResultsInRegion
parameter_list|()
block|{
if|if
condition|(
name|noMoreResultsForReverseScan
argument_list|(
name|scan
argument_list|,
name|loc
operator|.
name|getRegion
argument_list|()
argument_list|)
condition|)
block|{
name|completeNoMoreResults
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|completeWithNextStartRow
argument_list|(
name|loc
operator|.
name|getRegion
argument_list|()
operator|.
name|getStartKey
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|completeOrNext
parameter_list|(
name|ScanResponse
name|resp
parameter_list|,
name|int
name|numberOfCompleteRows
parameter_list|)
block|{
if|if
condition|(
name|resp
operator|.
name|hasMoreResults
argument_list|()
operator|&&
operator|!
name|resp
operator|.
name|getMoreResults
argument_list|()
condition|)
block|{
comment|// RS tells us there is no more data for the whole scan
name|completeNoMoreResults
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|scan
operator|.
name|getLimit
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// The RS should have set the moreResults field in ScanResponse to false when we have reached
comment|// the limit, so we add an assert here.
name|int
name|newLimit
init|=
name|scan
operator|.
name|getLimit
argument_list|()
operator|-
name|numberOfCompleteRows
decl_stmt|;
assert|assert
name|newLimit
operator|>
literal|0
assert|;
name|scan
operator|.
name|setLimit
argument_list|(
name|newLimit
argument_list|)
expr_stmt|;
block|}
comment|// as in 2.0 this value will always be set
if|if
condition|(
operator|!
name|resp
operator|.
name|getMoreResultsInRegion
argument_list|()
condition|)
block|{
name|completeWhenNoMoreResultsInRegion
operator|.
name|run
argument_list|()
expr_stmt|;
return|return;
block|}
name|next
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|onComplete
parameter_list|(
name|HBaseRpcController
name|controller
parameter_list|,
name|ScanResponse
name|resp
parameter_list|)
block|{
if|if
condition|(
name|controller
operator|.
name|failed
argument_list|()
condition|)
block|{
name|onError
argument_list|(
name|controller
operator|.
name|getFailed
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|updateServerSideMetrics
argument_list|(
name|scanMetrics
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|boolean
name|isHeartbeatMessage
init|=
name|resp
operator|.
name|hasHeartbeatMessage
argument_list|()
operator|&&
name|resp
operator|.
name|getHeartbeatMessage
argument_list|()
decl_stmt|;
name|Result
index|[]
name|rawResults
decl_stmt|;
name|Result
index|[]
name|results
decl_stmt|;
name|int
name|numberOfCompleteRowsBefore
init|=
name|resultCache
operator|.
name|numberOfCompleteRows
argument_list|()
decl_stmt|;
try|try
block|{
name|rawResults
operator|=
name|ResponseConverter
operator|.
name|getResults
argument_list|(
name|controller
operator|.
name|cellScanner
argument_list|()
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|updateResultsMetrics
argument_list|(
name|scanMetrics
argument_list|,
name|rawResults
argument_list|,
name|isHeartbeatMessage
argument_list|)
expr_stmt|;
name|results
operator|=
name|resultCache
operator|.
name|addAndGet
argument_list|(
name|Optional
operator|.
name|ofNullable
argument_list|(
name|rawResults
argument_list|)
operator|.
name|orElse
argument_list|(
name|ScanResultCache
operator|.
name|EMPTY_RESULT_ARRAY
argument_list|)
argument_list|,
name|isHeartbeatMessage
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// We can not retry here. The server has responded normally and the call sequence has been
comment|// increased so a new scan with the same call sequence will cause an
comment|// OutOfOrderScannerNextException. Let the upper layer open a new scanner.
name|LOG
operator|.
name|warn
argument_list|(
literal|"decode scan response failed"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|completeWhenError
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
name|ScanControllerImpl
name|scanController
decl_stmt|;
if|if
condition|(
name|results
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|scanController
operator|=
operator|new
name|ScanControllerImpl
argument_list|(
name|resp
operator|.
name|hasCursor
argument_list|()
condition|?
name|Optional
operator|.
name|of
argument_list|(
name|ProtobufUtil
operator|.
name|toCursor
argument_list|(
name|resp
operator|.
name|getCursor
argument_list|()
argument_list|)
argument_list|)
else|:
name|Optional
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
name|updateNextStartRowWhenError
argument_list|(
name|results
index|[
name|results
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|consumer
operator|.
name|onNext
argument_list|(
name|results
argument_list|,
name|scanController
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Optional
argument_list|<
name|Cursor
argument_list|>
name|cursor
init|=
name|Optional
operator|.
name|empty
argument_list|()
decl_stmt|;
if|if
condition|(
name|resp
operator|.
name|hasCursor
argument_list|()
condition|)
block|{
name|cursor
operator|=
name|Optional
operator|.
name|of
argument_list|(
name|ProtobufUtil
operator|.
name|toCursor
argument_list|(
name|resp
operator|.
name|getCursor
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scan
operator|.
name|isNeedCursorResult
argument_list|()
operator|&&
name|rawResults
operator|.
name|length
operator|>
literal|0
condition|)
block|{
comment|// It is size limit exceed and we need to return the last Result's row.
comment|// When user setBatch and the scanner is reopened, the server may return Results that
comment|// user has seen and the last Result can not be seen because the number is not enough.
comment|// So the row keys of results may not be same, we must use the last one.
name|cursor
operator|=
name|Optional
operator|.
name|of
argument_list|(
operator|new
name|Cursor
argument_list|(
name|rawResults
index|[
name|rawResults
operator|.
name|length
operator|-
literal|1
index|]
operator|.
name|getRow
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|scanController
operator|=
operator|new
name|ScanControllerImpl
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|isHeartbeatMessage
operator|||
name|cursor
operator|.
name|isPresent
argument_list|()
condition|)
block|{
comment|// only call onHeartbeat if server tells us explicitly this is a heartbeat message, or we
comment|// want to pass a cursor to upper layer.
name|consumer
operator|.
name|onHeartbeat
argument_list|(
name|scanController
argument_list|)
expr_stmt|;
block|}
block|}
name|ScanControllerState
name|state
init|=
name|scanController
operator|.
name|destroy
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|ScanControllerState
operator|.
name|TERMINATED
condition|)
block|{
if|if
condition|(
name|resp
operator|.
name|getMoreResultsInRegion
argument_list|()
condition|)
block|{
comment|// we have more results in region but user request to stop the scan, so we need to close the
comment|// scanner explicitly.
name|closeScanner
argument_list|()
expr_stmt|;
block|}
name|completeNoMoreResults
argument_list|()
expr_stmt|;
return|return;
block|}
name|int
name|numberOfCompleteRows
init|=
name|resultCache
operator|.
name|numberOfCompleteRows
argument_list|()
operator|-
name|numberOfCompleteRowsBefore
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|ScanControllerState
operator|.
name|SUSPENDED
condition|)
block|{
if|if
condition|(
name|scanController
operator|.
name|resumer
operator|.
name|prepare
argument_list|(
name|resp
argument_list|,
name|numberOfCompleteRows
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
name|completeOrNext
argument_list|(
name|resp
argument_list|,
name|numberOfCompleteRows
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|call
parameter_list|()
block|{
comment|// As we have a call sequence for scan, it is useless to have a different rpc timeout which is
comment|// less than the scan timeout. If the server does not respond in time(usually this will not
comment|// happen as we have heartbeat now), we will get an OutOfOrderScannerNextException when
comment|// resending the next request and the only way to fix this is to close the scanner and open a
comment|// new one.
name|long
name|callTimeoutNs
decl_stmt|;
if|if
condition|(
name|scanTimeoutNs
operator|>
literal|0
condition|)
block|{
name|long
name|remainingNs
init|=
name|scanTimeoutNs
operator|-
operator|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|nextCallStartNs
operator|)
decl_stmt|;
if|if
condition|(
name|remainingNs
operator|<=
literal|0
condition|)
block|{
name|completeExceptionally
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
name|callTimeoutNs
operator|=
name|remainingNs
expr_stmt|;
block|}
else|else
block|{
name|callTimeoutNs
operator|=
literal|0L
expr_stmt|;
block|}
name|incRPCCallsMetrics
argument_list|(
name|scanMetrics
argument_list|,
name|regionServerRemote
argument_list|)
expr_stmt|;
if|if
condition|(
name|tries
operator|>
literal|1
condition|)
block|{
name|incRPCRetriesMetrics
argument_list|(
name|scanMetrics
argument_list|,
name|regionServerRemote
argument_list|)
expr_stmt|;
block|}
name|resetController
argument_list|(
name|controller
argument_list|,
name|callTimeoutNs
argument_list|)
expr_stmt|;
name|ScanRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildScanRequest
argument_list|(
name|scannerId
argument_list|,
name|scan
operator|.
name|getCaching
argument_list|()
argument_list|,
literal|false
argument_list|,
name|nextCallSeq
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|scan
operator|.
name|getLimit
argument_list|()
argument_list|)
decl_stmt|;
name|stub
operator|.
name|scan
argument_list|(
name|controller
argument_list|,
name|req
argument_list|,
name|resp
lambda|->
name|onComplete
argument_list|(
name|controller
argument_list|,
name|resp
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|next
parameter_list|()
block|{
name|nextCallSeq
operator|++
expr_stmt|;
name|tries
operator|=
literal|1
expr_stmt|;
name|exceptions
operator|.
name|clear
argument_list|()
expr_stmt|;
name|nextCallStartNs
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|call
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|renewLease
parameter_list|()
block|{
name|incRPCCallsMetrics
argument_list|(
name|scanMetrics
argument_list|,
name|regionServerRemote
argument_list|)
expr_stmt|;
name|nextCallSeq
operator|++
expr_stmt|;
name|resetController
argument_list|(
name|controller
argument_list|,
name|rpcTimeoutNs
argument_list|)
expr_stmt|;
name|ScanRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildScanRequest
argument_list|(
name|scannerId
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|,
name|nextCallSeq
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|stub
operator|.
name|scan
argument_list|(
name|controller
argument_list|,
name|req
argument_list|,
name|resp
lambda|->
block|{     }
argument_list|)
expr_stmt|;
block|}
comment|/**    * Now we will also fetch some cells along with the scanner id when opening a scanner, so we also    * need to process the ScanResponse for the open scanner request. The HBaseRpcController for the    * open scanner request is also needed because we may have some data in the CellScanner which is    * contained in the controller.    * @return {@code true} if we should continue, otherwise {@code false}.    */
specifier|public
name|CompletableFuture
argument_list|<
name|Boolean
argument_list|>
name|start
parameter_list|(
name|HBaseRpcController
name|controller
parameter_list|,
name|ScanResponse
name|respWhenOpen
parameter_list|)
block|{
name|onComplete
argument_list|(
name|controller
argument_list|,
name|respWhenOpen
argument_list|)
expr_stmt|;
return|return
name|future
return|;
block|}
block|}
end_class

end_unit

