begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|IPCUtil
operator|.
name|buildRequestHeader
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|IPCUtil
operator|.
name|createRemoteException
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|IPCUtil
operator|.
name|getTotalSizeWhenWrittenDelimited
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|IPCUtil
operator|.
name|isFatalConnectionException
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|IPCUtil
operator|.
name|setCancelled
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|IPCUtil
operator|.
name|write
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Socket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketTimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadLocalRandom
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|sasl
operator|.
name|SaslException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|DoNotRetryIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|ConnectionClosingException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HBaseRpcController
operator|.
name|CancellationCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|HBaseSaslRpcClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|SaslUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|SaslUtil
operator|.
name|QualityOfProtection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|trace
operator|.
name|TraceUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ExceptionUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|core
operator|.
name|TraceScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Message
operator|.
name|Builder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|RpcCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|CellBlockMeta
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|ConnectionHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|ExceptionResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|RequestHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|ResponseHeader
import|;
end_import

begin_comment
comment|/**  * Thread that reads responses and notifies callers. Each connection owns a socket connected to a  * remote address. Calls are multiplexed through this socket: responses may be delivered out of  * order.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
class|class
name|BlockingRpcConnection
extends|extends
name|RpcConnection
implements|implements
name|Runnable
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|BlockingRpcConnection
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|BlockingRpcClient
name|rpcClient
decl_stmt|;
specifier|private
specifier|final
name|String
name|threadName
decl_stmt|;
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"IS2_INCONSISTENT_SYNC"
argument_list|,
name|justification
operator|=
literal|"We are always under lock actually"
argument_list|)
specifier|private
name|Thread
name|thread
decl_stmt|;
comment|// connected socket. protected for writing UT.
specifier|protected
name|Socket
name|socket
init|=
literal|null
decl_stmt|;
specifier|private
name|DataInputStream
name|in
decl_stmt|;
specifier|private
name|DataOutputStream
name|out
decl_stmt|;
specifier|private
name|HBaseSaslRpcClient
name|saslRpcClient
decl_stmt|;
comment|// currently active calls
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|Integer
argument_list|,
name|Call
argument_list|>
name|calls
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|CallSender
name|callSender
decl_stmt|;
specifier|private
name|boolean
name|closed
init|=
literal|false
decl_stmt|;
specifier|private
name|byte
index|[]
name|connectionHeaderPreamble
decl_stmt|;
specifier|private
name|byte
index|[]
name|connectionHeaderWithLength
decl_stmt|;
specifier|private
name|boolean
name|waitingConnectionHeaderResponse
init|=
literal|false
decl_stmt|;
comment|/**    * If the client wants to interrupt its calls easily (i.e. call Thread#interrupt), it gets into a    * java issue: an interruption during a write closes the socket/channel. A way to avoid this is to    * use a different thread for writing. This way, on interruptions, we either cancel the writes or    * ignore the answer if the write is already done, but we don't stop the write in the middle. This    * adds a thread per region server in the client, so it's kept as an option.    *<p>    * The implementation is simple: the client threads adds their call to the queue, and then wait    * for an answer. The CallSender blocks on the queue, and writes the calls one after the other. On    * interruption, the client cancels its call. The CallSender checks that the call has not been    * canceled before writing it.    *</p>    * When the connection closes, all the calls not yet sent are dismissed. The client thread is    * notified with an appropriate exception, as if the call was already sent but the answer not yet    * received.    *</p>    */
specifier|private
class|class
name|CallSender
extends|extends
name|Thread
block|{
specifier|private
specifier|final
name|Queue
argument_list|<
name|Call
argument_list|>
name|callsToWrite
decl_stmt|;
specifier|private
specifier|final
name|int
name|maxQueueSize
decl_stmt|;
specifier|public
name|CallSender
parameter_list|(
name|String
name|name
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|int
name|queueSize
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.ipc.client.write.queueSize"
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
name|callsToWrite
operator|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|(
name|queueSize
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxQueueSize
operator|=
name|queueSize
expr_stmt|;
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|setName
argument_list|(
name|name
operator|+
literal|" - writer"
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|sendCall
parameter_list|(
specifier|final
name|Call
name|call
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|callsToWrite
operator|.
name|size
argument_list|()
operator|>=
name|maxQueueSize
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can't add the call "
operator|+
name|call
operator|.
name|id
operator|+
literal|" to the write queue. callsToWrite.size()="
operator|+
name|callsToWrite
operator|.
name|size
argument_list|()
argument_list|)
throw|;
block|}
name|callsToWrite
operator|.
name|offer
argument_list|(
name|call
argument_list|)
expr_stmt|;
name|BlockingRpcConnection
operator|.
name|this
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|remove
parameter_list|(
name|Call
name|call
parameter_list|)
block|{
name|callsToWrite
operator|.
name|remove
argument_list|(
name|call
argument_list|)
expr_stmt|;
comment|// By removing the call from the expected call list, we make the list smaller, but
comment|// it means as well that we don't know how many calls we cancelled.
name|calls
operator|.
name|remove
argument_list|(
name|call
operator|.
name|id
argument_list|)
expr_stmt|;
name|call
operator|.
name|setException
argument_list|(
operator|new
name|CallCancelledException
argument_list|(
literal|"Call id="
operator|+
name|call
operator|.
name|id
operator|+
literal|", waitTime="
operator|+
operator|(
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|-
name|call
operator|.
name|getStartTime
argument_list|()
operator|)
operator|+
literal|", rpcTimeout="
operator|+
name|call
operator|.
name|timeout
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Reads the call from the queue, write them on the socket.      */
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
synchronized|synchronized
init|(
name|BlockingRpcConnection
operator|.
name|this
init|)
block|{
while|while
condition|(
operator|!
name|closed
condition|)
block|{
if|if
condition|(
name|callsToWrite
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// We should use another monitor object here for better performance since the read
comment|// thread also uses ConnectionImpl.this. But this makes the locking schema more
comment|// complicated, can do it later as an optimization.
try|try
block|{
name|BlockingRpcConnection
operator|.
name|this
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{             }
comment|// check if we need to quit, so continue the main loop instead of fallback.
continue|continue;
block|}
name|Call
name|call
init|=
name|callsToWrite
operator|.
name|poll
argument_list|()
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|isDone
argument_list|()
condition|)
block|{
continue|continue;
block|}
try|try
block|{
name|tracedWriteRequest
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// exception here means the call has not been added to the pendingCalls yet, so we need
comment|// to fail it by our own.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"call write error for call #"
operator|+
name|call
operator|.
name|id
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|call
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|closeConn
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Cleans the call not yet sent when we finish.      */
specifier|public
name|void
name|cleanup
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|IOException
name|ie
init|=
operator|new
name|ConnectionClosingException
argument_list|(
literal|"Connection to "
operator|+
name|remoteId
operator|.
name|address
operator|+
literal|" is closing."
argument_list|)
decl_stmt|;
for|for
control|(
name|Call
name|call
range|:
name|callsToWrite
control|)
block|{
name|call
operator|.
name|setException
argument_list|(
name|ie
argument_list|)
expr_stmt|;
block|}
name|callsToWrite
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
name|BlockingRpcConnection
parameter_list|(
name|BlockingRpcClient
name|rpcClient
parameter_list|,
name|ConnectionId
name|remoteId
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|rpcClient
operator|.
name|conf
argument_list|,
name|AbstractRpcClient
operator|.
name|WHEEL_TIMER
argument_list|,
name|remoteId
argument_list|,
name|rpcClient
operator|.
name|clusterId
argument_list|,
name|rpcClient
operator|.
name|userProvider
operator|.
name|isHBaseSecurityEnabled
argument_list|()
argument_list|,
name|rpcClient
operator|.
name|codec
argument_list|,
name|rpcClient
operator|.
name|compressor
argument_list|)
expr_stmt|;
name|this
operator|.
name|rpcClient
operator|=
name|rpcClient
expr_stmt|;
if|if
condition|(
name|remoteId
operator|.
name|getAddress
argument_list|()
operator|.
name|isUnresolved
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnknownHostException
argument_list|(
literal|"unknown host: "
operator|+
name|remoteId
operator|.
name|getAddress
argument_list|()
operator|.
name|getHostName
argument_list|()
argument_list|)
throw|;
block|}
name|this
operator|.
name|connectionHeaderPreamble
operator|=
name|getConnectionHeaderPreamble
argument_list|()
expr_stmt|;
name|ConnectionHeader
name|header
init|=
name|getConnectionHeader
argument_list|()
decl_stmt|;
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
literal|4
operator|+
name|header
operator|.
name|getSerializedSize
argument_list|()
argument_list|)
decl_stmt|;
name|DataOutputStream
name|dos
init|=
operator|new
name|DataOutputStream
argument_list|(
name|baos
argument_list|)
decl_stmt|;
name|dos
operator|.
name|writeInt
argument_list|(
name|header
operator|.
name|getSerializedSize
argument_list|()
argument_list|)
expr_stmt|;
name|header
operator|.
name|writeTo
argument_list|(
name|dos
argument_list|)
expr_stmt|;
assert|assert
name|baos
operator|.
name|size
argument_list|()
operator|==
literal|4
operator|+
name|header
operator|.
name|getSerializedSize
argument_list|()
assert|;
name|this
operator|.
name|connectionHeaderWithLength
operator|=
name|baos
operator|.
name|getBuffer
argument_list|()
expr_stmt|;
name|UserGroupInformation
name|ticket
init|=
name|remoteId
operator|.
name|ticket
operator|.
name|getUGI
argument_list|()
decl_stmt|;
name|this
operator|.
name|threadName
operator|=
literal|"IPC Client ("
operator|+
name|this
operator|.
name|rpcClient
operator|.
name|socketFactory
operator|.
name|hashCode
argument_list|()
operator|+
literal|") connection to "
operator|+
name|remoteId
operator|.
name|getAddress
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
operator|(
operator|(
name|ticket
operator|==
literal|null
operator|)
condition|?
literal|" from an unknown user"
else|:
operator|(
literal|" from "
operator|+
name|ticket
operator|.
name|getUserName
argument_list|()
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|rpcClient
operator|.
name|conf
operator|.
name|getBoolean
argument_list|(
name|BlockingRpcClient
operator|.
name|SPECIFIC_WRITE_THREAD
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|callSender
operator|=
operator|new
name|CallSender
argument_list|(
name|threadName
argument_list|,
name|this
operator|.
name|rpcClient
operator|.
name|conf
argument_list|)
expr_stmt|;
name|callSender
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|callSender
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// protected for write UT.
specifier|protected
name|void
name|setupConnection
parameter_list|()
throws|throws
name|IOException
block|{
name|short
name|ioFailures
init|=
literal|0
decl_stmt|;
name|short
name|timeoutFailures
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|this
operator|.
name|socket
operator|=
name|this
operator|.
name|rpcClient
operator|.
name|socketFactory
operator|.
name|createSocket
argument_list|()
expr_stmt|;
name|this
operator|.
name|socket
operator|.
name|setTcpNoDelay
argument_list|(
name|this
operator|.
name|rpcClient
operator|.
name|isTcpNoDelay
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|socket
operator|.
name|setKeepAlive
argument_list|(
name|this
operator|.
name|rpcClient
operator|.
name|tcpKeepAlive
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|rpcClient
operator|.
name|localAddr
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|socket
operator|.
name|bind
argument_list|(
name|this
operator|.
name|rpcClient
operator|.
name|localAddr
argument_list|)
expr_stmt|;
block|}
name|NetUtils
operator|.
name|connect
argument_list|(
name|this
operator|.
name|socket
argument_list|,
name|remoteId
operator|.
name|getAddress
argument_list|()
argument_list|,
name|this
operator|.
name|rpcClient
operator|.
name|connectTO
argument_list|)
expr_stmt|;
name|this
operator|.
name|socket
operator|.
name|setSoTimeout
argument_list|(
name|this
operator|.
name|rpcClient
operator|.
name|readTO
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|SocketTimeoutException
name|toe
parameter_list|)
block|{
comment|/*          * The max number of retries is 45, which amounts to 20s*45 = 15 minutes retries.          */
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Received exception in connection setup.\n"
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|toe
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|handleConnectionFailure
argument_list|(
name|timeoutFailures
operator|++
argument_list|,
name|this
operator|.
name|rpcClient
operator|.
name|maxRetries
argument_list|,
name|toe
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Received exception in connection setup.\n"
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ie
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|handleConnectionFailure
argument_list|(
name|ioFailures
operator|++
argument_list|,
name|this
operator|.
name|rpcClient
operator|.
name|maxRetries
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Handle connection failures If the current number of retries is equal to the max number of    * retries, stop retrying and throw the exception; Otherwise backoff N seconds and try connecting    * again. This Method is only called from inside setupIOstreams(), which is synchronized. Hence    * the sleep is synchronized; the locks will be retained.    * @param curRetries current number of retries    * @param maxRetries max number of retries allowed    * @param ioe failure reason    * @throws IOException if max number of retries is reached    */
specifier|private
name|void
name|handleConnectionFailure
parameter_list|(
name|int
name|curRetries
parameter_list|,
name|int
name|maxRetries
parameter_list|,
name|IOException
name|ioe
parameter_list|)
throws|throws
name|IOException
block|{
name|closeSocket
argument_list|()
expr_stmt|;
comment|// throw the exception if the maximum number of retries is reached
if|if
condition|(
name|curRetries
operator|>=
name|maxRetries
operator|||
name|ExceptionUtil
operator|.
name|isInterrupt
argument_list|(
name|ioe
argument_list|)
condition|)
block|{
throw|throw
name|ioe
throw|;
block|}
comment|// otherwise back off and retry
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|this
operator|.
name|rpcClient
operator|.
name|failureSleep
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|ExceptionUtil
operator|.
name|rethrowIfInterrupt
argument_list|(
name|ie
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Retrying connect to server: "
operator|+
name|remoteId
operator|.
name|getAddress
argument_list|()
operator|+
literal|" after sleeping "
operator|+
name|this
operator|.
name|rpcClient
operator|.
name|failureSleep
operator|+
literal|"ms. Already tried "
operator|+
name|curRetries
operator|+
literal|" time(s)."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * wait till someone signals us to start reading RPC response or it is idle too long, it is marked    * as to be closed, or the client is marked as not running.    * @return true if it is time to read a response; false otherwise.    */
specifier|private
specifier|synchronized
name|boolean
name|waitForWork
parameter_list|()
block|{
comment|// beware of the concurrent access to the calls list: we can add calls, but as well
comment|// remove them.
name|long
name|waitUntil
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|+
name|this
operator|.
name|rpcClient
operator|.
name|minIdleTimeBeforeClose
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|thread
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|calls
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|>=
name|waitUntil
condition|)
block|{
name|closeConn
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"idle connection closed with "
operator|+
name|calls
operator|.
name|size
argument_list|()
operator|+
literal|" pending request(s)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
try|try
block|{
name|wait
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|this
operator|.
name|rpcClient
operator|.
name|minIdleTimeBeforeClose
argument_list|,
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{       }
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|threadName
operator|+
literal|": starting, connections "
operator|+
name|this
operator|.
name|rpcClient
operator|.
name|connections
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|waitForWork
argument_list|()
condition|)
block|{
name|readResponse
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|threadName
operator|+
literal|": stopped, connections "
operator|+
name|this
operator|.
name|rpcClient
operator|.
name|connections
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|disposeSasl
parameter_list|()
block|{
if|if
condition|(
name|saslRpcClient
operator|!=
literal|null
condition|)
block|{
name|saslRpcClient
operator|.
name|dispose
argument_list|()
expr_stmt|;
name|saslRpcClient
operator|=
literal|null
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|setupSaslConnection
parameter_list|(
specifier|final
name|InputStream
name|in2
parameter_list|,
specifier|final
name|OutputStream
name|out2
parameter_list|)
throws|throws
name|IOException
block|{
name|saslRpcClient
operator|=
operator|new
name|HBaseSaslRpcClient
argument_list|(
name|authMethod
argument_list|,
name|token
argument_list|,
name|serverPrincipal
argument_list|,
name|this
operator|.
name|rpcClient
operator|.
name|fallbackAllowed
argument_list|,
name|this
operator|.
name|rpcClient
operator|.
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.rpc.protection"
argument_list|,
name|QualityOfProtection
operator|.
name|AUTHENTICATION
operator|.
name|name
argument_list|()
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
argument_list|)
argument_list|,
name|this
operator|.
name|rpcClient
operator|.
name|conf
operator|.
name|getBoolean
argument_list|(
name|CRYPTO_AES_ENABLED_KEY
argument_list|,
name|CRYPTO_AES_ENABLED_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|saslRpcClient
operator|.
name|saslConnect
argument_list|(
name|in2
argument_list|,
name|out2
argument_list|)
return|;
block|}
comment|/**    * If multiple clients with the same principal try to connect to the same server at the same time,    * the server assumes a replay attack is in progress. This is a feature of kerberos. In order to    * work around this, what is done is that the client backs off randomly and tries to initiate the    * connection again. The other problem is to do with ticket expiry. To handle that, a relogin is    * attempted.    *<p>    * The retry logic is governed by the {@link #shouldAuthenticateOverKrb} method. In case when the    * user doesn't have valid credentials, we don't need to retry (from cache or ticket). In such    * cases, it is prudent to throw a runtime exception when we receive a SaslException from the    * underlying authentication implementation, so there is no retry from other high level (for eg,    * HCM or HBaseAdmin).    *</p>    */
specifier|private
name|void
name|handleSaslConnectionFailure
parameter_list|(
specifier|final
name|int
name|currRetries
parameter_list|,
specifier|final
name|int
name|maxRetries
parameter_list|,
specifier|final
name|Exception
name|ex
parameter_list|,
specifier|final
name|UserGroupInformation
name|user
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|closeSocket
argument_list|()
expr_stmt|;
name|user
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|shouldAuthenticateOverKrb
argument_list|()
condition|)
block|{
if|if
condition|(
name|currRetries
operator|<
name|maxRetries
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception encountered while connecting to "
operator|+
literal|"the server : "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ex
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// try re-login
name|relogin
argument_list|()
expr_stmt|;
name|disposeSasl
argument_list|()
expr_stmt|;
comment|// have granularity of milliseconds
comment|// we are sleeping with the Connection lock held but since this
comment|// connection instance is being used for connecting to the server
comment|// in question, it is okay
name|Thread
operator|.
name|sleep
argument_list|(
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextInt
argument_list|(
name|reloginMaxBackoff
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
name|String
name|msg
init|=
literal|"Couldn't setup connection for "
operator|+
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
operator|.
name|getUserName
argument_list|()
operator|+
literal|" to "
operator|+
name|serverPrincipal
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|(
name|IOException
operator|)
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
operator|.
name|initCause
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception encountered while connecting to "
operator|+
literal|"the server : "
operator|+
name|ex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ex
operator|instanceof
name|RemoteException
condition|)
block|{
throw|throw
operator|(
name|RemoteException
operator|)
name|ex
throw|;
block|}
if|if
condition|(
name|ex
operator|instanceof
name|SaslException
condition|)
block|{
name|String
name|msg
init|=
literal|"SASL authentication failed."
operator|+
literal|" The most likely cause is missing or invalid credentials."
operator|+
literal|" Consider 'kinit'."
decl_stmt|;
name|LOG
operator|.
name|fatal
argument_list|(
name|msg
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|msg
argument_list|,
name|ex
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|setupIOstreams
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|socket
operator|!=
literal|null
condition|)
block|{
comment|// The connection is already available. Perfect.
return|return;
block|}
if|if
condition|(
name|this
operator|.
name|rpcClient
operator|.
name|failedServers
operator|.
name|isFailedServer
argument_list|(
name|remoteId
operator|.
name|getAddress
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Not trying to connect to "
operator|+
name|remoteId
operator|.
name|address
operator|+
literal|" this server is in the failed servers list"
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|FailedServerException
argument_list|(
literal|"This server is in the failed servers list: "
operator|+
name|remoteId
operator|.
name|address
argument_list|)
throw|;
block|}
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Connecting to "
operator|+
name|remoteId
operator|.
name|address
argument_list|)
expr_stmt|;
block|}
name|short
name|numRetries
init|=
literal|0
decl_stmt|;
specifier|final
name|short
name|MAX_RETRIES
init|=
literal|5
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|setupConnection
argument_list|()
expr_stmt|;
name|InputStream
name|inStream
init|=
name|NetUtils
operator|.
name|getInputStream
argument_list|(
name|socket
argument_list|)
decl_stmt|;
comment|// This creates a socket with a write timeout. This timeout cannot be changed.
name|OutputStream
name|outStream
init|=
name|NetUtils
operator|.
name|getOutputStream
argument_list|(
name|socket
argument_list|,
name|this
operator|.
name|rpcClient
operator|.
name|writeTO
argument_list|)
decl_stmt|;
comment|// Write out the preamble -- MAGIC, version, and auth to use.
name|writeConnectionHeaderPreamble
argument_list|(
name|outStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|useSasl
condition|)
block|{
specifier|final
name|InputStream
name|in2
init|=
name|inStream
decl_stmt|;
specifier|final
name|OutputStream
name|out2
init|=
name|outStream
decl_stmt|;
name|UserGroupInformation
name|ticket
init|=
name|getUGI
argument_list|()
decl_stmt|;
name|boolean
name|continueSasl
decl_stmt|;
if|if
condition|(
name|ticket
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FatalConnectionException
argument_list|(
literal|"ticket/user is null"
argument_list|)
throw|;
block|}
try|try
block|{
name|continueSasl
operator|=
name|ticket
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|run
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|setupSaslConnection
argument_list|(
name|in2
argument_list|,
name|out2
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|ExceptionUtil
operator|.
name|rethrowIfInterrupt
argument_list|(
name|ex
argument_list|)
expr_stmt|;
name|handleSaslConnectionFailure
argument_list|(
name|numRetries
operator|++
argument_list|,
name|MAX_RETRIES
argument_list|,
name|ex
argument_list|,
name|ticket
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|continueSasl
condition|)
block|{
comment|// Sasl connect is successful. Let's set up Sasl i/o streams.
name|inStream
operator|=
name|saslRpcClient
operator|.
name|getInputStream
argument_list|()
expr_stmt|;
name|outStream
operator|=
name|saslRpcClient
operator|.
name|getOutputStream
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// fall back to simple auth because server told us so.
comment|// do not change authMethod and useSasl here, we should start from secure when
comment|// reconnecting because regionserver may change its sasl config after restart.
block|}
block|}
name|this
operator|.
name|in
operator|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
name|inStream
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|out
operator|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|outStream
argument_list|)
argument_list|)
expr_stmt|;
comment|// Now write out the connection header
name|writeConnectionHeader
argument_list|()
expr_stmt|;
comment|// process the response from server for connection header if necessary
name|processResponseForConnectionHeader
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|closeSocket
argument_list|()
expr_stmt|;
name|IOException
name|e
init|=
name|ExceptionUtil
operator|.
name|asInterrupt
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|rpcClient
operator|.
name|failedServers
operator|.
name|addToFailedServers
argument_list|(
name|remoteId
operator|.
name|address
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|LinkageError
condition|)
block|{
comment|// probably the hbase hadoop version does not match the running hadoop version
name|e
operator|=
operator|new
name|DoNotRetryIOException
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|instanceof
name|IOException
condition|)
block|{
name|e
operator|=
operator|(
name|IOException
operator|)
name|t
expr_stmt|;
block|}
else|else
block|{
name|e
operator|=
operator|new
name|IOException
argument_list|(
literal|"Could not set up IO Streams to "
operator|+
name|remoteId
operator|.
name|address
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
throw|throw
name|e
throw|;
block|}
comment|// start the receiver thread after the socket connection has been set up
name|thread
operator|=
operator|new
name|Thread
argument_list|(
name|this
argument_list|,
name|threadName
argument_list|)
expr_stmt|;
name|thread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|thread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|/**    * Write the RPC header: {@code<MAGIC WORD -- 'HBas'><ONEBYTE_VERSION><ONEBYTE_AUTH_TYPE>}    */
specifier|private
name|void
name|writeConnectionHeaderPreamble
parameter_list|(
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|write
argument_list|(
name|connectionHeaderPreamble
argument_list|)
expr_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**    * Write the connection header.    */
specifier|private
name|void
name|writeConnectionHeader
parameter_list|()
throws|throws
name|IOException
block|{
name|boolean
name|isCryptoAesEnable
init|=
literal|false
decl_stmt|;
comment|// check if Crypto AES is enabled
if|if
condition|(
name|saslRpcClient
operator|!=
literal|null
condition|)
block|{
name|boolean
name|saslEncryptionEnabled
init|=
name|SaslUtil
operator|.
name|QualityOfProtection
operator|.
name|PRIVACY
operator|.
name|getSaslQop
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|saslRpcClient
operator|.
name|getSaslQOP
argument_list|()
argument_list|)
decl_stmt|;
name|isCryptoAesEnable
operator|=
name|saslEncryptionEnabled
operator|&&
name|conf
operator|.
name|getBoolean
argument_list|(
name|CRYPTO_AES_ENABLED_KEY
argument_list|,
name|CRYPTO_AES_ENABLED_DEFAULT
argument_list|)
expr_stmt|;
block|}
comment|// if Crypto AES is enabled, set transformation and negotiate with server
if|if
condition|(
name|isCryptoAesEnable
condition|)
block|{
name|waitingConnectionHeaderResponse
operator|=
literal|true
expr_stmt|;
block|}
name|this
operator|.
name|out
operator|.
name|write
argument_list|(
name|connectionHeaderWithLength
argument_list|)
expr_stmt|;
name|this
operator|.
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|processResponseForConnectionHeader
parameter_list|()
throws|throws
name|IOException
block|{
comment|// if no response excepted, return
if|if
condition|(
operator|!
name|waitingConnectionHeaderResponse
condition|)
return|return;
try|try
block|{
comment|// read the ConnectionHeaderResponse from server
name|int
name|len
init|=
name|this
operator|.
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|byte
index|[]
name|buff
init|=
operator|new
name|byte
index|[
name|len
index|]
decl_stmt|;
name|int
name|readSize
init|=
name|this
operator|.
name|in
operator|.
name|read
argument_list|(
name|buff
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Length of response for connection header:"
operator|+
name|readSize
argument_list|)
expr_stmt|;
block|}
name|RPCProtos
operator|.
name|ConnectionHeaderResponse
name|connectionHeaderResponse
init|=
name|RPCProtos
operator|.
name|ConnectionHeaderResponse
operator|.
name|parseFrom
argument_list|(
name|buff
argument_list|)
decl_stmt|;
comment|// Get the CryptoCipherMeta, update the HBaseSaslRpcClient for Crypto Cipher
if|if
condition|(
name|connectionHeaderResponse
operator|.
name|hasCryptoCipherMeta
argument_list|()
condition|)
block|{
name|negotiateCryptoAes
argument_list|(
name|connectionHeaderResponse
operator|.
name|getCryptoCipherMeta
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|waitingConnectionHeaderResponse
operator|=
literal|false
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SocketTimeoutException
name|ste
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Can't get the connection header response for rpc timeout, please check if"
operator|+
literal|" server has the correct configuration to support the additional function."
argument_list|,
name|ste
argument_list|)
expr_stmt|;
comment|// timeout when waiting the connection header response, ignore the additional function
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Timeout while waiting connection header response"
argument_list|,
name|ste
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|negotiateCryptoAes
parameter_list|(
name|RPCProtos
operator|.
name|CryptoCipherMeta
name|cryptoCipherMeta
parameter_list|)
throws|throws
name|IOException
block|{
comment|// initilize the Crypto AES with CryptoCipherMeta
name|saslRpcClient
operator|.
name|initCryptoCipher
argument_list|(
name|cryptoCipherMeta
argument_list|,
name|this
operator|.
name|rpcClient
operator|.
name|conf
argument_list|)
expr_stmt|;
comment|// reset the inputStream/outputStream for Crypto AES encryption
name|this
operator|.
name|in
operator|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
name|saslRpcClient
operator|.
name|getInputStream
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|out
operator|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|saslRpcClient
operator|.
name|getOutputStream
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|tracedWriteRequest
parameter_list|(
name|Call
name|call
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|TraceScope
name|ignored
init|=
name|TraceUtil
operator|.
name|createTrace
argument_list|(
literal|"RpcClientImpl.tracedWriteRequest"
argument_list|,
name|call
operator|.
name|span
argument_list|)
init|)
block|{
name|writeRequest
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Initiates a call by sending the parameter to the remote server. Note: this is not called from    * the Connection thread, but by other threads.    * @see #readResponse()    */
specifier|private
name|void
name|writeRequest
parameter_list|(
name|Call
name|call
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteBuffer
name|cellBlock
init|=
name|this
operator|.
name|rpcClient
operator|.
name|cellBlockBuilder
operator|.
name|buildCellBlock
argument_list|(
name|this
operator|.
name|codec
argument_list|,
name|this
operator|.
name|compressor
argument_list|,
name|call
operator|.
name|cells
argument_list|)
decl_stmt|;
name|CellBlockMeta
name|cellBlockMeta
decl_stmt|;
if|if
condition|(
name|cellBlock
operator|!=
literal|null
condition|)
block|{
name|cellBlockMeta
operator|=
name|CellBlockMeta
operator|.
name|newBuilder
argument_list|()
operator|.
name|setLength
argument_list|(
name|cellBlock
operator|.
name|limit
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|cellBlockMeta
operator|=
literal|null
expr_stmt|;
block|}
name|RequestHeader
name|requestHeader
init|=
name|buildRequestHeader
argument_list|(
name|call
argument_list|,
name|cellBlockMeta
argument_list|)
decl_stmt|;
name|setupIOstreams
argument_list|()
expr_stmt|;
comment|// Now we're going to write the call. We take the lock, then check that the connection
comment|// is still valid, and, if so we do the write to the socket. If the write fails, we don't
comment|// know where we stand, we have to close the connection.
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|InterruptedIOException
argument_list|()
throw|;
block|}
name|calls
operator|.
name|put
argument_list|(
name|call
operator|.
name|id
argument_list|,
name|call
argument_list|)
expr_stmt|;
comment|// We put first as we don't want the connection to become idle.
comment|// from here, we do not throw any exception to upper layer as the call has been tracked in the
comment|// pending calls map.
try|try
block|{
name|call
operator|.
name|callStats
operator|.
name|setRequestSizeBytes
argument_list|(
name|write
argument_list|(
name|this
operator|.
name|out
argument_list|,
name|requestHeader
argument_list|,
name|call
operator|.
name|param
argument_list|,
name|cellBlock
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Error while writing call, call_id:"
operator|+
name|call
operator|.
name|id
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|IOException
name|e
init|=
name|IPCUtil
operator|.
name|toIOE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|closeConn
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
name|notifyAll
argument_list|()
expr_stmt|;
block|}
comment|/*    * Receive a response. Because only one receiver, so no synchronization on in.    */
specifier|private
name|void
name|readResponse
parameter_list|()
block|{
name|Call
name|call
init|=
literal|null
decl_stmt|;
name|boolean
name|expectedCall
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// See HBaseServer.Call.setResponse for where we write out the response.
comment|// Total size of the response. Unused. But have to read it in anyways.
name|int
name|totalSize
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
comment|// Read the header
name|ResponseHeader
name|responseHeader
init|=
name|ResponseHeader
operator|.
name|parseDelimitedFrom
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|int
name|id
init|=
name|responseHeader
operator|.
name|getCallId
argument_list|()
decl_stmt|;
name|call
operator|=
name|calls
operator|.
name|remove
argument_list|(
name|id
argument_list|)
expr_stmt|;
comment|// call.done have to be set before leaving this method
name|expectedCall
operator|=
operator|(
name|call
operator|!=
literal|null
operator|&&
operator|!
name|call
operator|.
name|isDone
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|expectedCall
condition|)
block|{
comment|// So we got a response for which we have no corresponding 'call' here on the client-side.
comment|// We probably timed out waiting, cleaned up all references, and now the server decides
comment|// to return a response. There is nothing we can do w/ the response at this stage. Clean
comment|// out the wire of the response so its out of the way and we can get other responses on
comment|// this connection.
name|int
name|readSoFar
init|=
name|getTotalSizeWhenWrittenDelimited
argument_list|(
name|responseHeader
argument_list|)
decl_stmt|;
name|int
name|whatIsLeftToRead
init|=
name|totalSize
operator|-
name|readSoFar
decl_stmt|;
name|IOUtils
operator|.
name|skipFully
argument_list|(
name|in
argument_list|,
name|whatIsLeftToRead
argument_list|)
expr_stmt|;
if|if
condition|(
name|call
operator|!=
literal|null
condition|)
block|{
name|call
operator|.
name|callStats
operator|.
name|setResponseSizeBytes
argument_list|(
name|totalSize
argument_list|)
expr_stmt|;
name|call
operator|.
name|callStats
operator|.
name|setCallTimeMs
argument_list|(
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|-
name|call
operator|.
name|callStats
operator|.
name|getStartTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|responseHeader
operator|.
name|hasException
argument_list|()
condition|)
block|{
name|ExceptionResponse
name|exceptionResponse
init|=
name|responseHeader
operator|.
name|getException
argument_list|()
decl_stmt|;
name|RemoteException
name|re
init|=
name|createRemoteException
argument_list|(
name|exceptionResponse
argument_list|)
decl_stmt|;
name|call
operator|.
name|setException
argument_list|(
name|re
argument_list|)
expr_stmt|;
name|call
operator|.
name|callStats
operator|.
name|setResponseSizeBytes
argument_list|(
name|totalSize
argument_list|)
expr_stmt|;
name|call
operator|.
name|callStats
operator|.
name|setCallTimeMs
argument_list|(
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|-
name|call
operator|.
name|callStats
operator|.
name|getStartTime
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFatalConnectionException
argument_list|(
name|exceptionResponse
argument_list|)
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|closeConn
argument_list|(
name|re
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|Message
name|value
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|responseDefaultType
operator|!=
literal|null
condition|)
block|{
name|Builder
name|builder
init|=
name|call
operator|.
name|responseDefaultType
operator|.
name|newBuilderForType
argument_list|()
decl_stmt|;
name|ProtobufUtil
operator|.
name|mergeDelimitedFrom
argument_list|(
name|builder
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|value
operator|=
name|builder
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
name|CellScanner
name|cellBlockScanner
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|responseHeader
operator|.
name|hasCellBlockMeta
argument_list|()
condition|)
block|{
name|int
name|size
init|=
name|responseHeader
operator|.
name|getCellBlockMeta
argument_list|()
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|byte
index|[]
name|cellBlock
init|=
operator|new
name|byte
index|[
name|size
index|]
decl_stmt|;
name|IOUtils
operator|.
name|readFully
argument_list|(
name|this
operator|.
name|in
argument_list|,
name|cellBlock
argument_list|,
literal|0
argument_list|,
name|cellBlock
operator|.
name|length
argument_list|)
expr_stmt|;
name|cellBlockScanner
operator|=
name|this
operator|.
name|rpcClient
operator|.
name|cellBlockBuilder
operator|.
name|createCellScanner
argument_list|(
name|this
operator|.
name|codec
argument_list|,
name|this
operator|.
name|compressor
argument_list|,
name|cellBlock
argument_list|)
expr_stmt|;
block|}
name|call
operator|.
name|setResponse
argument_list|(
name|value
argument_list|,
name|cellBlockScanner
argument_list|)
expr_stmt|;
name|call
operator|.
name|callStats
operator|.
name|setResponseSizeBytes
argument_list|(
name|totalSize
argument_list|)
expr_stmt|;
name|call
operator|.
name|callStats
operator|.
name|setCallTimeMs
argument_list|(
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|-
name|call
operator|.
name|callStats
operator|.
name|getStartTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|expectedCall
condition|)
block|{
name|call
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|instanceof
name|SocketTimeoutException
condition|)
block|{
comment|// Clean up open calls but don't treat this as a fatal condition,
comment|// since we expect certain responses to not make it by the specified
comment|// {@link ConnectionId#rpcTimeout}.
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"ignored"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|closeConn
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
specifier|protected
specifier|synchronized
name|void
name|callTimeout
parameter_list|(
name|Call
name|call
parameter_list|)
block|{
comment|// call sender
name|calls
operator|.
name|remove
argument_list|(
name|call
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
comment|// just close socket input and output.
specifier|private
name|void
name|closeSocket
parameter_list|()
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeSocket
argument_list|(
name|socket
argument_list|)
expr_stmt|;
name|out
operator|=
literal|null
expr_stmt|;
name|in
operator|=
literal|null
expr_stmt|;
name|socket
operator|=
literal|null
expr_stmt|;
block|}
comment|// close socket, reader, and clean up all pending calls.
specifier|private
name|void
name|closeConn
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|thread
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|thread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|thread
operator|=
literal|null
expr_stmt|;
name|closeSocket
argument_list|()
expr_stmt|;
if|if
condition|(
name|callSender
operator|!=
literal|null
condition|)
block|{
name|callSender
operator|.
name|cleanup
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Call
name|call
range|:
name|calls
operator|.
name|values
argument_list|()
control|)
block|{
name|call
operator|.
name|setException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|calls
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|// release all resources, the connection will not be used any more.
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|shutdown
parameter_list|()
block|{
name|closed
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|callSender
operator|!=
literal|null
condition|)
block|{
name|callSender
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
name|closeConn
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"connection to "
operator|+
name|remoteId
operator|.
name|address
operator|+
literal|" closed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|cleanupConnection
parameter_list|()
block|{
comment|// do nothing
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|sendRequest
parameter_list|(
specifier|final
name|Call
name|call
parameter_list|,
name|HBaseRpcController
name|pcrc
parameter_list|)
throws|throws
name|IOException
block|{
name|pcrc
operator|.
name|notifyOnCancel
argument_list|(
operator|new
name|RpcCallback
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|(
name|Object
name|parameter
parameter_list|)
block|{
name|setCancelled
argument_list|(
name|call
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|BlockingRpcConnection
operator|.
name|this
init|)
block|{
if|if
condition|(
name|callSender
operator|!=
literal|null
condition|)
block|{
name|callSender
operator|.
name|remove
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|calls
operator|.
name|remove
argument_list|(
name|call
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
argument_list|,
operator|new
name|CancellationCallback
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|(
name|boolean
name|cancelled
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|cancelled
condition|)
block|{
name|setCancelled
argument_list|(
name|call
argument_list|)
expr_stmt|;
return|return;
block|}
name|scheduleTimeoutTask
argument_list|(
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
name|callSender
operator|!=
literal|null
condition|)
block|{
name|callSender
operator|.
name|sendCall
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tracedWriteRequest
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|boolean
name|isActive
parameter_list|()
block|{
return|return
name|thread
operator|!=
literal|null
return|;
block|}
block|}
end_class

end_unit

