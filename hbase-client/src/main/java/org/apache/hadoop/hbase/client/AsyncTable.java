begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
package|;
end_package

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
operator|.
name|toList
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ConnectionUtils
operator|.
name|allOf
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ConnectionUtils
operator|.
name|toCheckExistenceOnly
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|RpcChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CompletableFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CompareOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_comment
comment|/**  * The interface for asynchronous version of Table. Obtain an instance from a  * {@link AsyncConnection}.  *<p>  * The implementation is required to be thread safe.  *<p>  * Usually the implementation will not throw any exception directly. You need to get the exception  * from the returned {@link CompletableFuture}.  * @since 2.0.0  */
end_comment

begin_interface
annotation|@
name|InterfaceAudience
operator|.
name|Public
specifier|public
interface|interface
name|AsyncTable
parameter_list|<
name|C
extends|extends
name|ScanResultConsumerBase
parameter_list|>
block|{
comment|/**    * Gets the fully qualified table name instance of this table.    */
name|TableName
name|getName
parameter_list|()
function_decl|;
comment|/**    * Returns the {@link org.apache.hadoop.conf.Configuration} object used by this instance.    *<p>    * The reference returned is not a copy, so any change made to it will affect this instance.    */
name|Configuration
name|getConfiguration
parameter_list|()
function_decl|;
comment|/**    * Get timeout of each rpc request in this Table instance. It will be overridden by a more    * specific rpc timeout config such as readRpcTimeout or writeRpcTimeout.    * @see #getReadRpcTimeout(TimeUnit)    * @see #getWriteRpcTimeout(TimeUnit)    * @param unit the unit of time the timeout to be represented in    * @return rpc timeout in the specified time unit    */
name|long
name|getRpcTimeout
parameter_list|(
name|TimeUnit
name|unit
parameter_list|)
function_decl|;
comment|/**    * Get timeout of each rpc read request in this Table instance.    * @param unit the unit of time the timeout to be represented in    * @return read rpc timeout in the specified time unit    */
name|long
name|getReadRpcTimeout
parameter_list|(
name|TimeUnit
name|unit
parameter_list|)
function_decl|;
comment|/**    * Get timeout of each rpc write request in this Table instance.    * @param unit the unit of time the timeout to be represented in    * @return write rpc timeout in the specified time unit    */
name|long
name|getWriteRpcTimeout
parameter_list|(
name|TimeUnit
name|unit
parameter_list|)
function_decl|;
comment|/**    * Get timeout of each operation in Table instance.    * @param unit the unit of time the timeout to be represented in    * @return operation rpc timeout in the specified time unit    */
name|long
name|getOperationTimeout
parameter_list|(
name|TimeUnit
name|unit
parameter_list|)
function_decl|;
comment|/**    * Get the timeout of a single operation in a scan. It works like operation timeout for other    * operations.    * @param unit the unit of time the timeout to be represented in    * @return scan rpc timeout in the specified time unit    */
name|long
name|getScanTimeout
parameter_list|(
name|TimeUnit
name|unit
parameter_list|)
function_decl|;
comment|/**    * Test for the existence of columns in the table, as specified by the Get.    *<p>    * This will return true if the Get matches one or more keys, false if not.    *<p>    * This is a server-side call so it prevents any data from being transfered to the client.    * @return true if the specified Get matches one or more keys, false if not. The return value will    *         be wrapped by a {@link CompletableFuture}.    */
specifier|default
name|CompletableFuture
argument_list|<
name|Boolean
argument_list|>
name|exists
parameter_list|(
name|Get
name|get
parameter_list|)
block|{
return|return
name|get
argument_list|(
name|toCheckExistenceOnly
argument_list|(
name|get
argument_list|)
argument_list|)
operator|.
name|thenApply
argument_list|(
name|r
lambda|->
name|r
operator|.
name|getExists
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Extracts certain cells from a given row.    * @param get The object that specifies what data to fetch and from which row.    * @return The data coming from the specified row, if it exists. If the row specified doesn't    *         exist, the {@link Result} instance returned won't contain any    *         {@link org.apache.hadoop.hbase.KeyValue}, as indicated by {@link Result#isEmpty()}. The    *         return value will be wrapped by a {@link CompletableFuture}.    */
name|CompletableFuture
argument_list|<
name|Result
argument_list|>
name|get
parameter_list|(
name|Get
name|get
parameter_list|)
function_decl|;
comment|/**    * Puts some data to the table.    * @param put The data to put.    * @return A {@link CompletableFuture} that always returns null when complete normally.    */
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|put
parameter_list|(
name|Put
name|put
parameter_list|)
function_decl|;
comment|/**    * Deletes the specified cells/row.    * @param delete The object that specifies what to delete.    * @return A {@link CompletableFuture} that always returns null when complete normally.    */
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|delete
parameter_list|(
name|Delete
name|delete
parameter_list|)
function_decl|;
comment|/**    * Appends values to one or more columns within a single row.    *<p>    * This operation does not appear atomic to readers. Appends are done under a single row lock, so    * write operations to a row are synchronized, but readers do not take row locks so get and scan    * operations can see this operation partially completed.    * @param append object that specifies the columns and amounts to be used for the increment    *          operations    * @return values of columns after the append operation (maybe null). The return value will be    *         wrapped by a {@link CompletableFuture}.    */
name|CompletableFuture
argument_list|<
name|Result
argument_list|>
name|append
parameter_list|(
name|Append
name|append
parameter_list|)
function_decl|;
comment|/**    * Increments one or more columns within a single row.    *<p>    * This operation does not appear atomic to readers. Increments are done under a single row lock,    * so write operations to a row are synchronized, but readers do not take row locks so get and    * scan operations can see this operation partially completed.    * @param increment object that specifies the columns and amounts to be used for the increment    *          operations    * @return values of columns after the increment. The return value will be wrapped by a    *         {@link CompletableFuture}.    */
name|CompletableFuture
argument_list|<
name|Result
argument_list|>
name|increment
parameter_list|(
name|Increment
name|increment
parameter_list|)
function_decl|;
comment|/**    * See {@link #incrementColumnValue(byte[], byte[], byte[], long, Durability)}    *<p>    * The {@link Durability} is defaulted to {@link Durability#SYNC_WAL}.    * @param row The row that contains the cell to increment.    * @param family The column family of the cell to increment.    * @param qualifier The column qualifier of the cell to increment.    * @param amount The amount to increment the cell with (or decrement, if the amount is negative).    * @return The new value, post increment. The return value will be wrapped by a    *         {@link CompletableFuture}.    */
specifier|default
name|CompletableFuture
argument_list|<
name|Long
argument_list|>
name|incrementColumnValue
parameter_list|(
name|byte
index|[]
name|row
parameter_list|,
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|long
name|amount
parameter_list|)
block|{
return|return
name|incrementColumnValue
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|amount
argument_list|,
name|Durability
operator|.
name|SYNC_WAL
argument_list|)
return|;
block|}
comment|/**    * Atomically increments a column value. If the column value already exists and is not a    * big-endian long, this could throw an exception. If the column value does not yet exist it is    * initialized to<code>amount</code> and written to the specified column.    *<p>    * Setting durability to {@link Durability#SKIP_WAL} means that in a fail scenario you will lose    * any increments that have not been flushed.    * @param row The row that contains the cell to increment.    * @param family The column family of the cell to increment.    * @param qualifier The column qualifier of the cell to increment.    * @param amount The amount to increment the cell with (or decrement, if the amount is negative).    * @param durability The persistence guarantee for this increment.    * @return The new value, post increment. The return value will be wrapped by a    *         {@link CompletableFuture}.    */
specifier|default
name|CompletableFuture
argument_list|<
name|Long
argument_list|>
name|incrementColumnValue
parameter_list|(
name|byte
index|[]
name|row
parameter_list|,
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|long
name|amount
parameter_list|,
name|Durability
name|durability
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|row
argument_list|,
literal|"row is null"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|family
argument_list|,
literal|"family is null"
argument_list|)
expr_stmt|;
return|return
name|increment
argument_list|(
operator|new
name|Increment
argument_list|(
name|row
argument_list|)
operator|.
name|addColumn
argument_list|(
name|family
argument_list|,
name|qualifier
argument_list|,
name|amount
argument_list|)
operator|.
name|setDurability
argument_list|(
name|durability
argument_list|)
argument_list|)
operator|.
name|thenApply
argument_list|(
name|r
lambda|->
name|Bytes
operator|.
name|toLong
argument_list|(
name|r
operator|.
name|getValue
argument_list|(
name|family
argument_list|,
name|qualifier
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Atomically checks if a row/family/qualifier value matches the expected value. If it does, it    * adds the Put/Delete/RowMutations.    *<p>    * Use the returned {@link CheckAndMutateBuilder} to construct your request and then execute it.    * This is a fluent style API, the code is like:    *    *<pre>    *<code>    * table.checkAndMutate(row, family).qualifier(qualifier).ifNotExists().thenPut(put)    *     .thenAccept(succ -> {    *       if (succ) {    *         System.out.println("Check and put succeeded");    *       } else {    *         System.out.println("Check and put failed");    *       }    *     });    *</code>    *</pre>    */
name|CheckAndMutateBuilder
name|checkAndMutate
parameter_list|(
name|byte
index|[]
name|row
parameter_list|,
name|byte
index|[]
name|family
parameter_list|)
function_decl|;
comment|/**    * A helper class for sending checkAndMutate request.    */
interface|interface
name|CheckAndMutateBuilder
block|{
comment|/**      * @param qualifier column qualifier to check.      */
name|CheckAndMutateBuilder
name|qualifier
parameter_list|(
name|byte
index|[]
name|qualifier
parameter_list|)
function_decl|;
comment|/**      * Check for lack of column.      */
name|CheckAndMutateBuilder
name|ifNotExists
parameter_list|()
function_decl|;
comment|/**      * Check for equality.      * @param value the expected value      */
specifier|default
name|CheckAndMutateBuilder
name|ifEquals
parameter_list|(
name|byte
index|[]
name|value
parameter_list|)
block|{
return|return
name|ifMatches
argument_list|(
name|CompareOperator
operator|.
name|EQUAL
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/**      * @param compareOp comparison operator to use      * @param value the expected value      */
name|CheckAndMutateBuilder
name|ifMatches
parameter_list|(
name|CompareOperator
name|compareOp
parameter_list|,
name|byte
index|[]
name|value
parameter_list|)
function_decl|;
comment|/**      * @param put data to put if check succeeds      * @return {@code true} if the new put was executed, {@code false} otherwise. The return value      *         will be wrapped by a {@link CompletableFuture}.      */
name|CompletableFuture
argument_list|<
name|Boolean
argument_list|>
name|thenPut
parameter_list|(
name|Put
name|put
parameter_list|)
function_decl|;
comment|/**      * @param delete data to delete if check succeeds      * @return {@code true} if the new delete was executed, {@code false} otherwise. The return      *         value will be wrapped by a {@link CompletableFuture}.      */
name|CompletableFuture
argument_list|<
name|Boolean
argument_list|>
name|thenDelete
parameter_list|(
name|Delete
name|delete
parameter_list|)
function_decl|;
comment|/**      * @param mutation mutations to perform if check succeeds      * @return true if the new mutation was executed, false otherwise. The return value will be      *         wrapped by a {@link CompletableFuture}.      */
name|CompletableFuture
argument_list|<
name|Boolean
argument_list|>
name|thenMutate
parameter_list|(
name|RowMutations
name|mutation
parameter_list|)
function_decl|;
block|}
comment|/**    * Performs multiple mutations atomically on a single row. Currently {@link Put} and    * {@link Delete} are supported.    * @param mutation object that specifies the set of mutations to perform atomically    * @return A {@link CompletableFuture} that always returns null when complete normally.    */
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|mutateRow
parameter_list|(
name|RowMutations
name|mutation
parameter_list|)
function_decl|;
comment|/**    * The scan API uses the observer pattern.    * @param scan A configured {@link Scan} object.    * @param consumer the consumer used to receive results.    * @see ScanResultConsumer    * @see AdvancedScanResultConsumer    */
name|void
name|scan
parameter_list|(
name|Scan
name|scan
parameter_list|,
name|C
name|consumer
parameter_list|)
function_decl|;
comment|/**    * Gets a scanner on the current table for the given family.    * @param family The column family to scan.    * @return A scanner.    */
specifier|default
name|ResultScanner
name|getScanner
parameter_list|(
name|byte
index|[]
name|family
parameter_list|)
block|{
return|return
name|getScanner
argument_list|(
operator|new
name|Scan
argument_list|()
operator|.
name|addFamily
argument_list|(
name|family
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Gets a scanner on the current table for the given family and qualifier.    * @param family The column family to scan.    * @param qualifier The column qualifier to scan.    * @return A scanner.    */
specifier|default
name|ResultScanner
name|getScanner
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
return|return
name|getScanner
argument_list|(
operator|new
name|Scan
argument_list|()
operator|.
name|addColumn
argument_list|(
name|family
argument_list|,
name|qualifier
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns a scanner on the current table as specified by the {@link Scan} object.    * @param scan A configured {@link Scan} object.    * @return A scanner.    */
name|ResultScanner
name|getScanner
parameter_list|(
name|Scan
name|scan
parameter_list|)
function_decl|;
comment|/**    * Return all the results that match the given scan object.    *<p>    * Notice that usually you should use this method with a {@link Scan} object that has limit set.    * For example, if you want to get the closest row after a given row, you could do this:    *<p>    *    *<pre>    *<code>    * table.scanAll(new Scan().withStartRow(row, false).setLimit(1)).thenAccept(results -> {    *   if (results.isEmpty()) {    *      System.out.println("No row after " + Bytes.toStringBinary(row));    *   } else {    *     System.out.println("The closest row after " + Bytes.toStringBinary(row) + " is "    *         + Bytes.toStringBinary(results.stream().findFirst().get().getRow()));    *   }    * });    *</code>    *</pre>    *<p>    * If your result set is very large, you should use other scan method to get a scanner or use    * callback to process the results. They will do chunking to prevent OOM. The scanAll method will    * fetch all the results and store them in a List and then return the list to you.    *<p>    * The scan metrics will be collected background if you enable it but you have no way to get it.    * Usually you can get scan metrics from {@code ResultScanner}, or through    * {@code ScanResultConsumer.onScanMetricsCreated} but this method only returns a list of results.    * So if you really care about scan metrics then you'd better use other scan methods which return    * a {@code ResultScanner} or let you pass in a {@code ScanResultConsumer}. There is no    * performance difference between these scan methods so do not worry.    * @param scan A configured {@link Scan} object. So if you use this method to fetch a really large    *          result set, it is likely to cause OOM.    * @return The results of this small scan operation. The return value will be wrapped by a    *         {@link CompletableFuture}.    */
name|CompletableFuture
argument_list|<
name|List
argument_list|<
name|Result
argument_list|>
argument_list|>
name|scanAll
parameter_list|(
name|Scan
name|scan
parameter_list|)
function_decl|;
comment|/**    * Test for the existence of columns in the table, as specified by the Gets.    *<p>    * This will return a list of booleans. Each value will be true if the related Get matches one or    * more keys, false if not.    *<p>    * This is a server-side call so it prevents any data from being transferred to the client.    * @param gets the Gets    * @return A list of {@link CompletableFuture}s that represent the existence for each get.    */
specifier|default
name|List
argument_list|<
name|CompletableFuture
argument_list|<
name|Boolean
argument_list|>
argument_list|>
name|exists
parameter_list|(
name|List
argument_list|<
name|Get
argument_list|>
name|gets
parameter_list|)
block|{
return|return
name|get
argument_list|(
name|toCheckExistenceOnly
argument_list|(
name|gets
argument_list|)
argument_list|)
operator|.
name|stream
argument_list|()
operator|.
operator|<
name|CompletableFuture
argument_list|<
name|Boolean
argument_list|>
operator|>
name|map
argument_list|(
name|f
lambda|->
name|f
operator|.
name|thenApply
argument_list|(
name|r
lambda|->
name|r
operator|.
name|getExists
argument_list|()
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|toList
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * A simple version for batch exists. It will fail if there are any failures and you will get the    * whole result boolean list at once if the operation is succeeded.    * @param gets the Gets    * @return A {@link CompletableFuture} that wrapper the result boolean list.    */
specifier|default
name|CompletableFuture
argument_list|<
name|List
argument_list|<
name|Boolean
argument_list|>
argument_list|>
name|existsAll
parameter_list|(
name|List
argument_list|<
name|Get
argument_list|>
name|gets
parameter_list|)
block|{
return|return
name|allOf
argument_list|(
name|exists
argument_list|(
name|gets
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Extracts certain cells from the given rows, in batch.    *<p>    * Notice that you may not get all the results with this function, which means some of the    * returned {@link CompletableFuture}s may succeed while some of the other returned    * {@link CompletableFuture}s may fail.    * @param gets The objects that specify what data to fetch and from which rows.    * @return A list of {@link CompletableFuture}s that represent the result for each get.    */
name|List
argument_list|<
name|CompletableFuture
argument_list|<
name|Result
argument_list|>
argument_list|>
name|get
parameter_list|(
name|List
argument_list|<
name|Get
argument_list|>
name|gets
parameter_list|)
function_decl|;
comment|/**    * A simple version for batch get. It will fail if there are any failures and you will get the    * whole result list at once if the operation is succeeded.    * @param gets The objects that specify what data to fetch and from which rows.    * @return A {@link CompletableFuture} that wrapper the result list.    */
specifier|default
name|CompletableFuture
argument_list|<
name|List
argument_list|<
name|Result
argument_list|>
argument_list|>
name|getAll
parameter_list|(
name|List
argument_list|<
name|Get
argument_list|>
name|gets
parameter_list|)
block|{
return|return
name|allOf
argument_list|(
name|get
argument_list|(
name|gets
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Puts some data in the table, in batch.    * @param puts The list of mutations to apply.    * @return A list of {@link CompletableFuture}s that represent the result for each put.    */
name|List
argument_list|<
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
argument_list|>
name|put
parameter_list|(
name|List
argument_list|<
name|Put
argument_list|>
name|puts
parameter_list|)
function_decl|;
comment|/**    * A simple version of batch put. It will fail if there are any failures.    * @param puts The list of mutations to apply.    * @return A {@link CompletableFuture} that always returns null when complete normally.    */
specifier|default
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|putAll
parameter_list|(
name|List
argument_list|<
name|Put
argument_list|>
name|puts
parameter_list|)
block|{
return|return
name|allOf
argument_list|(
name|put
argument_list|(
name|puts
argument_list|)
argument_list|)
operator|.
name|thenApply
argument_list|(
name|r
lambda|->
literal|null
argument_list|)
return|;
block|}
comment|/**    * Deletes the specified cells/rows in bulk.    * @param deletes list of things to delete.    * @return A list of {@link CompletableFuture}s that represent the result for each delete.    */
name|List
argument_list|<
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
argument_list|>
name|delete
parameter_list|(
name|List
argument_list|<
name|Delete
argument_list|>
name|deletes
parameter_list|)
function_decl|;
comment|/**    * A simple version of batch delete. It will fail if there are any failures.    * @param deletes list of things to delete.    * @return A {@link CompletableFuture} that always returns null when complete normally.    */
specifier|default
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|deleteAll
parameter_list|(
name|List
argument_list|<
name|Delete
argument_list|>
name|deletes
parameter_list|)
block|{
return|return
name|allOf
argument_list|(
name|delete
argument_list|(
name|deletes
argument_list|)
argument_list|)
operator|.
name|thenApply
argument_list|(
name|r
lambda|->
literal|null
argument_list|)
return|;
block|}
comment|/**    * Method that does a batch call on Deletes, Gets, Puts, Increments, Appends and RowMutations. The    * ordering of execution of the actions is not defined. Meaning if you do a Put and a Get in the    * same {@link #batch} call, you will not necessarily be guaranteed that the Get returns what the    * Put had put.    * @param actions list of Get, Put, Delete, Increment, Append, and RowMutations objects    * @return A list of {@link CompletableFuture}s that represent the result for each action.    */
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|CompletableFuture
argument_list|<
name|T
argument_list|>
argument_list|>
name|batch
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|Row
argument_list|>
name|actions
parameter_list|)
function_decl|;
comment|/**    * A simple version of batch. It will fail if there are any failures and you will get the whole    * result list at once if the operation is succeeded.    * @param actions list of Get, Put, Delete, Increment, Append and RowMutations objects    * @return A list of the result for the actions. Wrapped by a {@link CompletableFuture}.    */
specifier|default
parameter_list|<
name|T
parameter_list|>
name|CompletableFuture
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
name|batchAll
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|Row
argument_list|>
name|actions
parameter_list|)
block|{
return|return
name|allOf
argument_list|(
name|batch
argument_list|(
name|actions
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Execute the given coprocessor call on the region which contains the given {@code row}.    *<p>    * The {@code stubMaker} is just a delegation to the {@code newStub} call. Usually it is only a    * one line lambda expression, like:    *    *<pre>    *<code>    * channel -> xxxService.newStub(channel)    *</code>    *</pre>    *    * @param stubMaker a delegation to the actual {@code newStub} call.    * @param callable a delegation to the actual protobuf rpc call. See the comment of    *          {@link ServiceCaller} for more details.    * @param row The row key used to identify the remote region location    * @param<S> the type of the asynchronous stub    * @param<R> the type of the return value    * @return the return value of the protobuf rpc call, wrapped by a {@link CompletableFuture}.    * @see ServiceCaller    */
parameter_list|<
name|S
parameter_list|,
name|R
parameter_list|>
name|CompletableFuture
argument_list|<
name|R
argument_list|>
name|coprocessorService
parameter_list|(
name|Function
argument_list|<
name|RpcChannel
argument_list|,
name|S
argument_list|>
name|stubMaker
parameter_list|,
name|ServiceCaller
argument_list|<
name|S
argument_list|,
name|R
argument_list|>
name|callable
parameter_list|,
name|byte
index|[]
name|row
parameter_list|)
function_decl|;
comment|/**    * The callback when we want to execute a coprocessor call on a range of regions.    *<p>    * As the locating itself also takes some time, the implementation may want to send rpc calls on    * the fly, which means we do not know how many regions we have when we get the return value of    * the rpc calls, so we need an {@link #onComplete()} which is used to tell you that we have    * passed all the return values to you(through the {@link #onRegionComplete(RegionInfo, Object)}    * or {@link #onRegionError(RegionInfo, Throwable)} calls), i.e, there will be no    * {@link #onRegionComplete(RegionInfo, Object)} or {@link #onRegionError(RegionInfo, Throwable)}    * calls in the future.    *<p>    * Here is a pseudo code to describe a typical implementation of a range coprocessor service    * method to help you better understand how the {@link CoprocessorCallback} will be called. The    * {@code callback} in the pseudo code is our {@link CoprocessorCallback}. And notice that the    * {@code whenComplete} is {@code CompletableFuture.whenComplete}.    *    *<pre>    * locateThenCall(byte[] row) {    *   locate(row).whenComplete((location, locateError) -> {    *     if (locateError != null) {    *       callback.onError(locateError);    *       return;    *     }    *     incPendingCall();    *     region = location.getRegion();    *     if (region.getEndKey()> endKey) {    *       locateEnd = true;    *     } else {    *       locateThenCall(region.getEndKey());    *     }    *     sendCall().whenComplete((resp, error) -> {    *       if (error != null) {    *         callback.onRegionError(region, error);    *       } else {    *         callback.onRegionComplete(region, resp);    *       }    *       if (locateEnd&& decPendingCallAndGet() == 0) {    *         callback.onComplete();    *       }    *     });    *   });    * }    *</pre>    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
interface|interface
name|CoprocessorCallback
parameter_list|<
name|R
parameter_list|>
block|{
comment|/**      * @param region the region that the response belongs to      * @param resp the response of the coprocessor call      */
name|void
name|onRegionComplete
parameter_list|(
name|RegionInfo
name|region
parameter_list|,
name|R
name|resp
parameter_list|)
function_decl|;
comment|/**      * @param region the region that the error belongs to      * @param error the response error of the coprocessor call      */
name|void
name|onRegionError
parameter_list|(
name|RegionInfo
name|region
parameter_list|,
name|Throwable
name|error
parameter_list|)
function_decl|;
comment|/**      * Indicate that all responses of the regions have been notified by calling      * {@link #onRegionComplete(RegionInfo, Object)} or      * {@link #onRegionError(RegionInfo, Throwable)}.      */
name|void
name|onComplete
parameter_list|()
function_decl|;
comment|/**      * Indicate that we got an error which does not belong to any regions. Usually a locating error.      */
name|void
name|onError
parameter_list|(
name|Throwable
name|error
parameter_list|)
function_decl|;
block|}
comment|/**    * Helper class for sending coprocessorService request that executes a coprocessor call on regions    * which are covered by a range.    *<p>    * If {@code fromRow} is not specified the selection will start with the first table region. If    * {@code toRow} is not specified the selection will continue through the last table region.    * @param<S> the type of the protobuf Service you want to call.    * @param<R> the type of the return value.    */
interface|interface
name|CoprocessorServiceBuilder
parameter_list|<
name|S
parameter_list|,
name|R
parameter_list|>
block|{
comment|/**      * @param startKey start region selection with region containing this row, inclusive.      */
specifier|default
name|CoprocessorServiceBuilder
argument_list|<
name|S
argument_list|,
name|R
argument_list|>
name|fromRow
parameter_list|(
name|byte
index|[]
name|startKey
parameter_list|)
block|{
return|return
name|fromRow
argument_list|(
name|startKey
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * @param startKey start region selection with region containing this row      * @param inclusive whether to include the startKey      */
name|CoprocessorServiceBuilder
argument_list|<
name|S
argument_list|,
name|R
argument_list|>
name|fromRow
parameter_list|(
name|byte
index|[]
name|startKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
function_decl|;
comment|/**      * @param endKey select regions up to and including the region containing this row, exclusive.      */
specifier|default
name|CoprocessorServiceBuilder
argument_list|<
name|S
argument_list|,
name|R
argument_list|>
name|toRow
parameter_list|(
name|byte
index|[]
name|endKey
parameter_list|)
block|{
return|return
name|toRow
argument_list|(
name|endKey
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * @param endKey select regions up to and including the region containing this row      * @param inclusive whether to include the endKey      */
name|CoprocessorServiceBuilder
argument_list|<
name|S
argument_list|,
name|R
argument_list|>
name|toRow
parameter_list|(
name|byte
index|[]
name|endKey
parameter_list|,
name|boolean
name|inclusive
parameter_list|)
function_decl|;
comment|/**      * Execute the coprocessorService request. You can get the response through the      * {@link CoprocessorCallback}.      */
name|void
name|execute
parameter_list|()
function_decl|;
block|}
comment|/**    * Execute a coprocessor call on the regions which are covered by a range.    *<p>    * Use the returned {@link CoprocessorServiceBuilder} construct your request and then execute it.    *<p>    * The {@code stubMaker} is just a delegation to the {@code xxxService.newStub} call. Usually it    * is only a one line lambda expression, like:    *    *<pre>    *<code>    * channel -> xxxService.newStub(channel)    *</code>    *</pre>    *    * @param stubMaker a delegation to the actual {@code newStub} call.    * @param callable a delegation to the actual protobuf rpc call. See the comment of    *          {@link ServiceCaller} for more details.    * @param callback callback to get the response. See the comment of {@link CoprocessorCallback}    *          for more details.    */
parameter_list|<
name|S
parameter_list|,
name|R
parameter_list|>
name|CoprocessorServiceBuilder
argument_list|<
name|S
argument_list|,
name|R
argument_list|>
name|coprocessorService
parameter_list|(
name|Function
argument_list|<
name|RpcChannel
argument_list|,
name|S
argument_list|>
name|stubMaker
parameter_list|,
name|ServiceCaller
argument_list|<
name|S
argument_list|,
name|R
argument_list|>
name|callable
parameter_list|,
name|CoprocessorCallback
argument_list|<
name|R
argument_list|>
name|callback
parameter_list|)
function_decl|;
block|}
end_interface

end_unit

