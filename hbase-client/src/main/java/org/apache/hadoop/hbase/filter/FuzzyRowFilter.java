begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|filter
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Cell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|PrivateCellUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|DeserializationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|InvalidProtocolBufferException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|UnsafeByteOperations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|FilterProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|BytesBytesPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|UnsafeAccess
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|UnsafeAvailChecker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * This is optimized version of a standard FuzzyRowFilter Filters data based on fuzzy row key.  * Performs fast-forwards during scanning. It takes pairs (row key, fuzzy info) to match row keys.  * Where fuzzy info is a byte array with 0 or 1 as its values:  *<ul>  *<li>0 - means that this byte in provided row key is fixed, i.e. row key's byte at same position  * must match</li>  *<li>1 - means that this byte in provided row key is NOT fixed, i.e. row key's byte at this  * position can be different from the one in provided row key</li>  *</ul>  * Example: Let's assume row key format is userId_actionId_year_month. Length of userId is fixed and  * is 4, length of actionId is 2 and year and month are 4 and 2 bytes long respectively. Let's  * assume that we need to fetch all users that performed certain action (encoded as "99") in Jan of  * any year. Then the pair (row key, fuzzy info) would be the following: row key = "????_99_????_01"  * (one can use any value instead of "?") fuzzy info =  * "\x01\x01\x01\x01\x00\x00\x00\x00\x01\x01\x01\x01\x00\x00\x00" I.e. fuzzy info tells the matching  * mask is "????_99_????_01", where at ? can be any value.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
specifier|public
class|class
name|FuzzyRowFilter
extends|extends
name|FilterBase
block|{
specifier|private
specifier|static
specifier|final
name|boolean
name|UNSAFE_UNALIGNED
init|=
name|UnsafeAvailChecker
operator|.
name|unaligned
argument_list|()
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|fuzzyKeysData
decl_stmt|;
specifier|private
name|boolean
name|done
init|=
literal|false
decl_stmt|;
comment|/**    * The index of a last successfully found matching fuzzy string (in fuzzyKeysData). We will start    * matching next KV with this one. If they do not match then we will return back to the one-by-one    * iteration over fuzzyKeysData.    */
specifier|private
name|int
name|lastFoundIndex
init|=
operator|-
literal|1
decl_stmt|;
comment|/**    * Row tracker (keeps all next rows after SEEK_NEXT_USING_HINT was returned)    */
specifier|private
name|RowTracker
name|tracker
decl_stmt|;
specifier|public
name|FuzzyRowFilter
parameter_list|(
name|List
argument_list|<
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|fuzzyKeysData
parameter_list|)
block|{
name|List
argument_list|<
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|fuzzyKeyDataCopy
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|fuzzyKeysData
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|aFuzzyKeysData
range|:
name|fuzzyKeysData
control|)
block|{
if|if
condition|(
name|aFuzzyKeysData
operator|.
name|getFirst
argument_list|()
operator|.
name|length
operator|!=
name|aFuzzyKeysData
operator|.
name|getSecond
argument_list|()
operator|.
name|length
condition|)
block|{
name|Pair
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|readable
init|=
operator|new
name|Pair
argument_list|<>
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|aFuzzyKeysData
operator|.
name|getFirst
argument_list|()
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|aFuzzyKeysData
operator|.
name|getSecond
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Fuzzy pair lengths do not match: "
operator|+
name|readable
argument_list|)
throw|;
block|}
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|p
init|=
operator|new
name|Pair
argument_list|<>
argument_list|()
decl_stmt|;
comment|// create a copy of pair bytes so that they are not modified by the filter.
name|p
operator|.
name|setFirst
argument_list|(
name|Arrays
operator|.
name|copyOf
argument_list|(
name|aFuzzyKeysData
operator|.
name|getFirst
argument_list|()
argument_list|,
name|aFuzzyKeysData
operator|.
name|getFirst
argument_list|()
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|setSecond
argument_list|(
name|Arrays
operator|.
name|copyOf
argument_list|(
name|aFuzzyKeysData
operator|.
name|getSecond
argument_list|()
argument_list|,
name|aFuzzyKeysData
operator|.
name|getSecond
argument_list|()
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
comment|// update mask ( 0 -> -1 (0xff), 1 -> 2)
name|p
operator|.
name|setSecond
argument_list|(
name|preprocessMask
argument_list|(
name|p
operator|.
name|getSecond
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|preprocessSearchKey
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|fuzzyKeyDataCopy
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|fuzzyKeysData
operator|=
name|fuzzyKeyDataCopy
expr_stmt|;
name|this
operator|.
name|tracker
operator|=
operator|new
name|RowTracker
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|preprocessSearchKey
parameter_list|(
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|UNSAFE_UNALIGNED
condition|)
block|{
comment|// do nothing
return|return;
block|}
name|byte
index|[]
name|key
init|=
name|p
operator|.
name|getFirst
argument_list|()
decl_stmt|;
name|byte
index|[]
name|mask
init|=
name|p
operator|.
name|getSecond
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mask
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// set non-fixed part of a search key to 0.
if|if
condition|(
name|mask
index|[
name|i
index|]
operator|==
literal|2
condition|)
block|{
name|key
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/**    * We need to preprocess mask array, as since we treat 2's as unfixed positions and -1 (0xff) as    * fixed positions    * @param mask    * @return mask array    */
specifier|private
name|byte
index|[]
name|preprocessMask
parameter_list|(
name|byte
index|[]
name|mask
parameter_list|)
block|{
if|if
condition|(
operator|!
name|UNSAFE_UNALIGNED
condition|)
block|{
comment|// do nothing
return|return
name|mask
return|;
block|}
if|if
condition|(
name|isPreprocessedMask
argument_list|(
name|mask
argument_list|)
condition|)
return|return
name|mask
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mask
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|mask
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|// 0 -> -1
block|}
elseif|else
if|if
condition|(
name|mask
index|[
name|i
index|]
operator|==
literal|1
condition|)
block|{
name|mask
index|[
name|i
index|]
operator|=
literal|2
expr_stmt|;
comment|// 1 -> 2
block|}
block|}
return|return
name|mask
return|;
block|}
specifier|private
name|boolean
name|isPreprocessedMask
parameter_list|(
name|byte
index|[]
name|mask
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mask
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
index|[
name|i
index|]
operator|!=
operator|-
literal|1
operator|&&
name|mask
index|[
name|i
index|]
operator|!=
literal|2
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Deprecated
annotation|@
name|Override
specifier|public
name|ReturnCode
name|filterKeyValue
parameter_list|(
specifier|final
name|Cell
name|c
parameter_list|)
block|{
return|return
name|filterCell
argument_list|(
name|c
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|ReturnCode
name|filterCell
parameter_list|(
specifier|final
name|Cell
name|c
parameter_list|)
block|{
specifier|final
name|int
name|startIndex
init|=
name|lastFoundIndex
operator|>=
literal|0
condition|?
name|lastFoundIndex
else|:
literal|0
decl_stmt|;
specifier|final
name|int
name|size
init|=
name|fuzzyKeysData
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|startIndex
init|;
name|i
operator|<
name|size
operator|+
name|startIndex
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|index
init|=
name|i
operator|%
name|size
decl_stmt|;
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|fuzzyData
init|=
name|fuzzyKeysData
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
comment|// This shift is idempotent - always end up with 0 and -1 as mask values.
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|fuzzyData
operator|.
name|getSecond
argument_list|()
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|fuzzyData
operator|.
name|getSecond
argument_list|()
index|[
name|j
index|]
operator|>>=
literal|2
expr_stmt|;
block|}
name|SatisfiesCode
name|satisfiesCode
init|=
name|satisfies
argument_list|(
name|isReversed
argument_list|()
argument_list|,
name|c
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|c
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|c
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|fuzzyData
operator|.
name|getFirst
argument_list|()
argument_list|,
name|fuzzyData
operator|.
name|getSecond
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|satisfiesCode
operator|==
name|SatisfiesCode
operator|.
name|YES
condition|)
block|{
name|lastFoundIndex
operator|=
name|index
expr_stmt|;
return|return
name|ReturnCode
operator|.
name|INCLUDE
return|;
block|}
block|}
comment|// NOT FOUND -> seek next using hint
name|lastFoundIndex
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|ReturnCode
operator|.
name|SEEK_NEXT_USING_HINT
return|;
block|}
annotation|@
name|Override
specifier|public
name|Cell
name|getNextCellHint
parameter_list|(
name|Cell
name|currentCell
parameter_list|)
block|{
name|boolean
name|result
init|=
name|tracker
operator|.
name|updateTracker
argument_list|(
name|currentCell
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|false
condition|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
return|return
literal|null
return|;
block|}
name|byte
index|[]
name|nextRowKey
init|=
name|tracker
operator|.
name|nextRow
argument_list|()
decl_stmt|;
return|return
name|PrivateCellUtil
operator|.
name|createFirstOnRow
argument_list|(
name|nextRowKey
argument_list|,
literal|0
argument_list|,
operator|(
name|short
operator|)
name|nextRowKey
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * If we have multiple fuzzy keys, row tracker should improve overall performance. It calculates    * all next rows (one per every fuzzy key) and put them (the fuzzy key is bundled) into a priority    * queue so that the smallest row key always appears at queue head, which helps to decide the    * "Next Cell Hint". As scanning going on, the number of candidate rows in the RowTracker will    * remain the size of fuzzy keys until some of the fuzzy keys won't possibly have matches any    * more.    */
specifier|private
class|class
name|RowTracker
block|{
specifier|private
specifier|final
name|PriorityQueue
argument_list|<
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
argument_list|>
name|nextRows
decl_stmt|;
specifier|private
name|boolean
name|initialized
init|=
literal|false
decl_stmt|;
name|RowTracker
parameter_list|()
block|{
name|nextRows
operator|=
operator|new
name|PriorityQueue
argument_list|<>
argument_list|(
name|fuzzyKeysData
operator|.
name|size
argument_list|()
argument_list|,
operator|new
name|Comparator
argument_list|<
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|o1
parameter_list|,
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|o2
parameter_list|)
block|{
return|return
name|isReversed
argument_list|()
condition|?
name|Bytes
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|getFirst
argument_list|()
argument_list|,
name|o1
operator|.
name|getFirst
argument_list|()
argument_list|)
else|:
name|Bytes
operator|.
name|compareTo
argument_list|(
name|o1
operator|.
name|getFirst
argument_list|()
argument_list|,
name|o2
operator|.
name|getFirst
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|nextRow
parameter_list|()
block|{
if|if
condition|(
name|nextRows
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"NextRows should not be empty, make sure to call nextRow() after updateTracker() return true"
argument_list|)
throw|;
block|}
else|else
block|{
return|return
name|nextRows
operator|.
name|peek
argument_list|()
operator|.
name|getFirst
argument_list|()
return|;
block|}
block|}
name|boolean
name|updateTracker
parameter_list|(
name|Cell
name|currentCell
parameter_list|)
block|{
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
for|for
control|(
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|fuzzyData
range|:
name|fuzzyKeysData
control|)
block|{
name|updateWith
argument_list|(
name|currentCell
argument_list|,
name|fuzzyData
argument_list|)
expr_stmt|;
block|}
name|initialized
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|!
name|nextRows
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|lessThan
argument_list|(
name|currentCell
argument_list|,
name|nextRows
operator|.
name|peek
argument_list|()
operator|.
name|getFirst
argument_list|()
argument_list|)
condition|)
block|{
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|head
init|=
name|nextRows
operator|.
name|poll
argument_list|()
decl_stmt|;
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|fuzzyData
init|=
name|head
operator|.
name|getSecond
argument_list|()
decl_stmt|;
name|updateWith
argument_list|(
name|currentCell
argument_list|,
name|fuzzyData
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|!
name|nextRows
operator|.
name|isEmpty
argument_list|()
return|;
block|}
name|boolean
name|lessThan
parameter_list|(
name|Cell
name|currentCell
parameter_list|,
name|byte
index|[]
name|nextRowKey
parameter_list|)
block|{
name|int
name|compareResult
init|=
name|CellComparator
operator|.
name|getInstance
argument_list|()
operator|.
name|compareRows
argument_list|(
name|currentCell
argument_list|,
name|nextRowKey
argument_list|,
literal|0
argument_list|,
name|nextRowKey
operator|.
name|length
argument_list|)
decl_stmt|;
return|return
operator|(
operator|!
name|isReversed
argument_list|()
operator|&&
name|compareResult
operator|<
literal|0
operator|)
operator|||
operator|(
name|isReversed
argument_list|()
operator|&&
name|compareResult
operator|>
literal|0
operator|)
return|;
block|}
name|void
name|updateWith
parameter_list|(
name|Cell
name|currentCell
parameter_list|,
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|fuzzyData
parameter_list|)
block|{
name|byte
index|[]
name|nextRowKeyCandidate
init|=
name|getNextForFuzzyRule
argument_list|(
name|isReversed
argument_list|()
argument_list|,
name|currentCell
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|currentCell
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|currentCell
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|fuzzyData
operator|.
name|getFirst
argument_list|()
argument_list|,
name|fuzzyData
operator|.
name|getSecond
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|nextRowKeyCandidate
operator|!=
literal|null
condition|)
block|{
name|nextRows
operator|.
name|add
argument_list|(
operator|new
name|Pair
argument_list|<>
argument_list|(
name|nextRowKeyCandidate
argument_list|,
name|fuzzyData
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|filterAllRemaining
parameter_list|()
block|{
return|return
name|done
return|;
block|}
comment|/**    * @return The filter serialized using pb    */
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|toByteArray
parameter_list|()
block|{
name|FilterProtos
operator|.
name|FuzzyRowFilter
operator|.
name|Builder
name|builder
init|=
name|FilterProtos
operator|.
name|FuzzyRowFilter
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|fuzzyData
range|:
name|fuzzyKeysData
control|)
block|{
name|BytesBytesPair
operator|.
name|Builder
name|bbpBuilder
init|=
name|BytesBytesPair
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|bbpBuilder
operator|.
name|setFirst
argument_list|(
name|UnsafeByteOperations
operator|.
name|unsafeWrap
argument_list|(
name|fuzzyData
operator|.
name|getFirst
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|bbpBuilder
operator|.
name|setSecond
argument_list|(
name|UnsafeByteOperations
operator|.
name|unsafeWrap
argument_list|(
name|fuzzyData
operator|.
name|getSecond
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|addFuzzyKeysData
argument_list|(
name|bbpBuilder
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
operator|.
name|toByteArray
argument_list|()
return|;
block|}
comment|/**    * @param pbBytes A pb serialized {@link FuzzyRowFilter} instance    * @return An instance of {@link FuzzyRowFilter} made from<code>bytes</code>    * @throws DeserializationException    * @see #toByteArray    */
specifier|public
specifier|static
name|FuzzyRowFilter
name|parseFrom
parameter_list|(
specifier|final
name|byte
index|[]
name|pbBytes
parameter_list|)
throws|throws
name|DeserializationException
block|{
name|FilterProtos
operator|.
name|FuzzyRowFilter
name|proto
decl_stmt|;
try|try
block|{
name|proto
operator|=
name|FilterProtos
operator|.
name|FuzzyRowFilter
operator|.
name|parseFrom
argument_list|(
name|pbBytes
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidProtocolBufferException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DeserializationException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|int
name|count
init|=
name|proto
operator|.
name|getFuzzyKeysDataCount
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|fuzzyKeysData
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|count
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|BytesBytesPair
name|current
init|=
name|proto
operator|.
name|getFuzzyKeysData
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|byte
index|[]
name|keyBytes
init|=
name|current
operator|.
name|getFirst
argument_list|()
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
name|byte
index|[]
name|keyMeta
init|=
name|current
operator|.
name|getSecond
argument_list|()
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
name|fuzzyKeysData
operator|.
name|add
argument_list|(
operator|new
name|Pair
argument_list|<>
argument_list|(
name|keyBytes
argument_list|,
name|keyMeta
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|FuzzyRowFilter
argument_list|(
name|fuzzyKeysData
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"FuzzyRowFilter"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"{fuzzyKeysData="
argument_list|)
expr_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|fuzzyData
range|:
name|fuzzyKeysData
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
operator|.
name|append
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|fuzzyData
operator|.
name|getFirst
argument_list|()
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|fuzzyData
operator|.
name|getSecond
argument_list|()
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"}, "
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|// Utility methods
specifier|static
enum|enum
name|SatisfiesCode
block|{
comment|/** row satisfies fuzzy rule */
name|YES
block|,
comment|/** row doesn't satisfy fuzzy rule, but there's possible greater row that does */
name|NEXT_EXISTS
block|,
comment|/** row doesn't satisfy fuzzy rule and there's no greater row that does */
name|NO_NEXT
block|}
annotation|@
name|VisibleForTesting
specifier|static
name|SatisfiesCode
name|satisfies
parameter_list|(
name|byte
index|[]
name|row
parameter_list|,
name|byte
index|[]
name|fuzzyKeyBytes
parameter_list|,
name|byte
index|[]
name|fuzzyKeyMeta
parameter_list|)
block|{
return|return
name|satisfies
argument_list|(
literal|false
argument_list|,
name|row
argument_list|,
literal|0
argument_list|,
name|row
operator|.
name|length
argument_list|,
name|fuzzyKeyBytes
argument_list|,
name|fuzzyKeyMeta
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
specifier|static
name|SatisfiesCode
name|satisfies
parameter_list|(
name|boolean
name|reverse
parameter_list|,
name|byte
index|[]
name|row
parameter_list|,
name|byte
index|[]
name|fuzzyKeyBytes
parameter_list|,
name|byte
index|[]
name|fuzzyKeyMeta
parameter_list|)
block|{
return|return
name|satisfies
argument_list|(
name|reverse
argument_list|,
name|row
argument_list|,
literal|0
argument_list|,
name|row
operator|.
name|length
argument_list|,
name|fuzzyKeyBytes
argument_list|,
name|fuzzyKeyMeta
argument_list|)
return|;
block|}
specifier|static
name|SatisfiesCode
name|satisfies
parameter_list|(
name|boolean
name|reverse
parameter_list|,
name|byte
index|[]
name|row
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|byte
index|[]
name|fuzzyKeyBytes
parameter_list|,
name|byte
index|[]
name|fuzzyKeyMeta
parameter_list|)
block|{
if|if
condition|(
operator|!
name|UNSAFE_UNALIGNED
condition|)
block|{
return|return
name|satisfiesNoUnsafe
argument_list|(
name|reverse
argument_list|,
name|row
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|fuzzyKeyBytes
argument_list|,
name|fuzzyKeyMeta
argument_list|)
return|;
block|}
if|if
condition|(
name|row
operator|==
literal|null
condition|)
block|{
comment|// do nothing, let scan to proceed
return|return
name|SatisfiesCode
operator|.
name|YES
return|;
block|}
name|length
operator|=
name|Math
operator|.
name|min
argument_list|(
name|length
argument_list|,
name|fuzzyKeyBytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|int
name|numWords
init|=
name|length
operator|/
name|Bytes
operator|.
name|SIZEOF_LONG
decl_stmt|;
name|int
name|j
init|=
name|numWords
operator|<<
literal|3
decl_stmt|;
comment|// numWords * SIZEOF_LONG;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|+=
name|Bytes
operator|.
name|SIZEOF_LONG
control|)
block|{
name|long
name|fuzzyBytes
init|=
name|UnsafeAccess
operator|.
name|toLong
argument_list|(
name|fuzzyKeyBytes
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|long
name|fuzzyMeta
init|=
name|UnsafeAccess
operator|.
name|toLong
argument_list|(
name|fuzzyKeyMeta
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|long
name|rowValue
init|=
name|UnsafeAccess
operator|.
name|toLong
argument_list|(
name|row
argument_list|,
name|offset
operator|+
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|rowValue
operator|&
name|fuzzyMeta
operator|)
operator|!=
operator|(
name|fuzzyBytes
operator|)
condition|)
block|{
comment|// We always return NEXT_EXISTS
return|return
name|SatisfiesCode
operator|.
name|NEXT_EXISTS
return|;
block|}
block|}
name|int
name|off
init|=
name|j
decl_stmt|;
if|if
condition|(
name|length
operator|-
name|off
operator|>=
name|Bytes
operator|.
name|SIZEOF_INT
condition|)
block|{
name|int
name|fuzzyBytes
init|=
name|UnsafeAccess
operator|.
name|toInt
argument_list|(
name|fuzzyKeyBytes
argument_list|,
name|off
argument_list|)
decl_stmt|;
name|int
name|fuzzyMeta
init|=
name|UnsafeAccess
operator|.
name|toInt
argument_list|(
name|fuzzyKeyMeta
argument_list|,
name|off
argument_list|)
decl_stmt|;
name|int
name|rowValue
init|=
name|UnsafeAccess
operator|.
name|toInt
argument_list|(
name|row
argument_list|,
name|offset
operator|+
name|off
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|rowValue
operator|&
name|fuzzyMeta
operator|)
operator|!=
operator|(
name|fuzzyBytes
operator|)
condition|)
block|{
comment|// We always return NEXT_EXISTS
return|return
name|SatisfiesCode
operator|.
name|NEXT_EXISTS
return|;
block|}
name|off
operator|+=
name|Bytes
operator|.
name|SIZEOF_INT
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|-
name|off
operator|>=
name|Bytes
operator|.
name|SIZEOF_SHORT
condition|)
block|{
name|short
name|fuzzyBytes
init|=
name|UnsafeAccess
operator|.
name|toShort
argument_list|(
name|fuzzyKeyBytes
argument_list|,
name|off
argument_list|)
decl_stmt|;
name|short
name|fuzzyMeta
init|=
name|UnsafeAccess
operator|.
name|toShort
argument_list|(
name|fuzzyKeyMeta
argument_list|,
name|off
argument_list|)
decl_stmt|;
name|short
name|rowValue
init|=
name|UnsafeAccess
operator|.
name|toShort
argument_list|(
name|row
argument_list|,
name|offset
operator|+
name|off
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|rowValue
operator|&
name|fuzzyMeta
operator|)
operator|!=
operator|(
name|fuzzyBytes
operator|)
condition|)
block|{
comment|// We always return NEXT_EXISTS
comment|// even if it does not (in this case getNextForFuzzyRule
comment|// will return null)
return|return
name|SatisfiesCode
operator|.
name|NEXT_EXISTS
return|;
block|}
name|off
operator|+=
name|Bytes
operator|.
name|SIZEOF_SHORT
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|-
name|off
operator|>=
name|Bytes
operator|.
name|SIZEOF_BYTE
condition|)
block|{
name|int
name|fuzzyBytes
init|=
name|fuzzyKeyBytes
index|[
name|off
index|]
operator|&
literal|0xff
decl_stmt|;
name|int
name|fuzzyMeta
init|=
name|fuzzyKeyMeta
index|[
name|off
index|]
operator|&
literal|0xff
decl_stmt|;
name|int
name|rowValue
init|=
name|row
index|[
name|offset
operator|+
name|off
index|]
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
operator|(
name|rowValue
operator|&
name|fuzzyMeta
operator|)
operator|!=
operator|(
name|fuzzyBytes
operator|)
condition|)
block|{
comment|// We always return NEXT_EXISTS
return|return
name|SatisfiesCode
operator|.
name|NEXT_EXISTS
return|;
block|}
block|}
return|return
name|SatisfiesCode
operator|.
name|YES
return|;
block|}
specifier|static
name|SatisfiesCode
name|satisfiesNoUnsafe
parameter_list|(
name|boolean
name|reverse
parameter_list|,
name|byte
index|[]
name|row
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|byte
index|[]
name|fuzzyKeyBytes
parameter_list|,
name|byte
index|[]
name|fuzzyKeyMeta
parameter_list|)
block|{
if|if
condition|(
name|row
operator|==
literal|null
condition|)
block|{
comment|// do nothing, let scan to proceed
return|return
name|SatisfiesCode
operator|.
name|YES
return|;
block|}
name|Order
name|order
init|=
name|Order
operator|.
name|orderFor
argument_list|(
name|reverse
argument_list|)
decl_stmt|;
name|boolean
name|nextRowKeyCandidateExists
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fuzzyKeyMeta
operator|.
name|length
operator|&&
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// First, checking if this position is fixed and not equals the given one
name|boolean
name|byteAtPositionFixed
init|=
name|fuzzyKeyMeta
index|[
name|i
index|]
operator|==
literal|0
decl_stmt|;
name|boolean
name|fixedByteIncorrect
init|=
name|byteAtPositionFixed
operator|&&
name|fuzzyKeyBytes
index|[
name|i
index|]
operator|!=
name|row
index|[
name|i
operator|+
name|offset
index|]
decl_stmt|;
if|if
condition|(
name|fixedByteIncorrect
condition|)
block|{
comment|// in this case there's another row that satisfies fuzzy rule and bigger than this row
if|if
condition|(
name|nextRowKeyCandidateExists
condition|)
block|{
return|return
name|SatisfiesCode
operator|.
name|NEXT_EXISTS
return|;
block|}
comment|// If this row byte is less than fixed then there's a byte array bigger than
comment|// this row and which satisfies the fuzzy rule. Otherwise there's no such byte array:
comment|// this row is simply bigger than any byte array that satisfies the fuzzy rule
name|boolean
name|rowByteLessThanFixed
init|=
operator|(
name|row
index|[
name|i
operator|+
name|offset
index|]
operator|&
literal|0xFF
operator|)
operator|<
operator|(
name|fuzzyKeyBytes
index|[
name|i
index|]
operator|&
literal|0xFF
operator|)
decl_stmt|;
if|if
condition|(
name|rowByteLessThanFixed
operator|&&
operator|!
name|reverse
condition|)
block|{
return|return
name|SatisfiesCode
operator|.
name|NEXT_EXISTS
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|rowByteLessThanFixed
operator|&&
name|reverse
condition|)
block|{
return|return
name|SatisfiesCode
operator|.
name|NEXT_EXISTS
return|;
block|}
else|else
block|{
return|return
name|SatisfiesCode
operator|.
name|NO_NEXT
return|;
block|}
block|}
comment|// Second, checking if this position is not fixed and byte value is not the biggest. In this
comment|// case there's a byte array bigger than this row and which satisfies the fuzzy rule. To get
comment|// bigger byte array that satisfies the rule we need to just increase this byte
comment|// (see the code of getNextForFuzzyRule below) by one.
comment|// Note: if non-fixed byte is already at biggest value, this doesn't allow us to say there's
comment|// bigger one that satisfies the rule as it can't be increased.
if|if
condition|(
name|fuzzyKeyMeta
index|[
name|i
index|]
operator|==
literal|1
operator|&&
operator|!
name|order
operator|.
name|isMax
argument_list|(
name|fuzzyKeyBytes
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|nextRowKeyCandidateExists
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|SatisfiesCode
operator|.
name|YES
return|;
block|}
annotation|@
name|VisibleForTesting
specifier|static
name|byte
index|[]
name|getNextForFuzzyRule
parameter_list|(
name|byte
index|[]
name|row
parameter_list|,
name|byte
index|[]
name|fuzzyKeyBytes
parameter_list|,
name|byte
index|[]
name|fuzzyKeyMeta
parameter_list|)
block|{
return|return
name|getNextForFuzzyRule
argument_list|(
literal|false
argument_list|,
name|row
argument_list|,
literal|0
argument_list|,
name|row
operator|.
name|length
argument_list|,
name|fuzzyKeyBytes
argument_list|,
name|fuzzyKeyMeta
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
specifier|static
name|byte
index|[]
name|getNextForFuzzyRule
parameter_list|(
name|boolean
name|reverse
parameter_list|,
name|byte
index|[]
name|row
parameter_list|,
name|byte
index|[]
name|fuzzyKeyBytes
parameter_list|,
name|byte
index|[]
name|fuzzyKeyMeta
parameter_list|)
block|{
return|return
name|getNextForFuzzyRule
argument_list|(
name|reverse
argument_list|,
name|row
argument_list|,
literal|0
argument_list|,
name|row
operator|.
name|length
argument_list|,
name|fuzzyKeyBytes
argument_list|,
name|fuzzyKeyMeta
argument_list|)
return|;
block|}
comment|/** Abstracts directional comparisons based on scan direction. */
specifier|private
enum|enum
name|Order
block|{
name|ASC
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|lt
parameter_list|(
name|int
name|lhs
parameter_list|,
name|int
name|rhs
parameter_list|)
block|{
return|return
name|lhs
operator|<
name|rhs
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|gt
parameter_list|(
name|int
name|lhs
parameter_list|,
name|int
name|rhs
parameter_list|)
block|{
return|return
name|lhs
operator|>
name|rhs
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
name|inc
parameter_list|(
name|byte
name|val
parameter_list|)
block|{
comment|// TODO: what about over/underflow?
return|return
call|(
name|byte
call|)
argument_list|(
name|val
operator|+
literal|1
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isMax
parameter_list|(
name|byte
name|val
parameter_list|)
block|{
return|return
name|val
operator|==
operator|(
name|byte
operator|)
literal|0xff
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
name|min
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
block|}
block|,
name|DESC
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|lt
parameter_list|(
name|int
name|lhs
parameter_list|,
name|int
name|rhs
parameter_list|)
block|{
return|return
name|lhs
operator|>
name|rhs
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|gt
parameter_list|(
name|int
name|lhs
parameter_list|,
name|int
name|rhs
parameter_list|)
block|{
return|return
name|lhs
operator|<
name|rhs
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
name|inc
parameter_list|(
name|byte
name|val
parameter_list|)
block|{
comment|// TODO: what about over/underflow?
return|return
call|(
name|byte
call|)
argument_list|(
name|val
operator|-
literal|1
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isMax
parameter_list|(
name|byte
name|val
parameter_list|)
block|{
return|return
name|val
operator|==
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|byte
name|min
parameter_list|()
block|{
return|return
operator|(
name|byte
operator|)
literal|0xFF
return|;
block|}
block|}
block|;
specifier|public
specifier|static
name|Order
name|orderFor
parameter_list|(
name|boolean
name|reverse
parameter_list|)
block|{
return|return
name|reverse
condition|?
name|DESC
else|:
name|ASC
return|;
block|}
comment|/** Returns true when {@code lhs< rhs}. */
specifier|public
specifier|abstract
name|boolean
name|lt
parameter_list|(
name|int
name|lhs
parameter_list|,
name|int
name|rhs
parameter_list|)
function_decl|;
comment|/** Returns true when {@code lhs> rhs}. */
specifier|public
specifier|abstract
name|boolean
name|gt
parameter_list|(
name|int
name|lhs
parameter_list|,
name|int
name|rhs
parameter_list|)
function_decl|;
comment|/** Returns {@code val} incremented by 1. */
specifier|public
specifier|abstract
name|byte
name|inc
parameter_list|(
name|byte
name|val
parameter_list|)
function_decl|;
comment|/** Return true when {@code val} is the maximum value */
specifier|public
specifier|abstract
name|boolean
name|isMax
parameter_list|(
name|byte
name|val
parameter_list|)
function_decl|;
comment|/** Return the minimum value according to this ordering scheme. */
specifier|public
specifier|abstract
name|byte
name|min
parameter_list|()
function_decl|;
block|}
comment|/**    * @return greater byte array than given (row) which satisfies the fuzzy rule if it exists, null    *         otherwise    */
annotation|@
name|VisibleForTesting
specifier|static
name|byte
index|[]
name|getNextForFuzzyRule
parameter_list|(
name|boolean
name|reverse
parameter_list|,
name|byte
index|[]
name|row
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|byte
index|[]
name|fuzzyKeyBytes
parameter_list|,
name|byte
index|[]
name|fuzzyKeyMeta
parameter_list|)
block|{
comment|// To find out the next "smallest" byte array that satisfies fuzzy rule and "greater" than
comment|// the given one we do the following:
comment|// 1. setting values on all "fixed" positions to the values from fuzzyKeyBytes
comment|// 2. if during the first step given row did not increase, then we increase the value at
comment|// the first "non-fixed" position (where it is not maximum already)
comment|// It is easier to perform this by using fuzzyKeyBytes copy and setting "non-fixed" position
comment|// values than otherwise.
name|byte
index|[]
name|result
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|fuzzyKeyBytes
argument_list|,
name|length
operator|>
name|fuzzyKeyBytes
operator|.
name|length
condition|?
name|length
else|:
name|fuzzyKeyBytes
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|reverse
operator|&&
name|length
operator|>
name|fuzzyKeyBytes
operator|.
name|length
condition|)
block|{
comment|// we need trailing 0xff's instead of trailing 0x00's
for|for
control|(
name|int
name|i
init|=
name|fuzzyKeyBytes
operator|.
name|length
init|;
name|i
operator|<
name|result
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|result
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
literal|0xFF
expr_stmt|;
block|}
block|}
name|int
name|toInc
init|=
operator|-
literal|1
decl_stmt|;
specifier|final
name|Order
name|order
init|=
name|Order
operator|.
name|orderFor
argument_list|(
name|reverse
argument_list|)
decl_stmt|;
name|boolean
name|increased
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|result
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|fuzzyKeyMeta
operator|.
name|length
operator|||
name|fuzzyKeyMeta
index|[
name|i
index|]
operator|==
literal|0
comment|/* non-fixed */
condition|)
block|{
name|result
index|[
name|i
index|]
operator|=
name|row
index|[
name|offset
operator|+
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|order
operator|.
name|isMax
argument_list|(
name|row
index|[
name|offset
operator|+
name|i
index|]
argument_list|)
condition|)
block|{
comment|// this is "non-fixed" position and is not at max value, hence we can increase it
name|toInc
operator|=
name|i
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|<
name|fuzzyKeyMeta
operator|.
name|length
operator|&&
name|fuzzyKeyMeta
index|[
name|i
index|]
operator|==
operator|-
literal|1
comment|/* fixed */
condition|)
block|{
if|if
condition|(
name|order
operator|.
name|lt
argument_list|(
operator|(
name|row
index|[
name|i
operator|+
name|offset
index|]
operator|&
literal|0xFF
operator|)
argument_list|,
operator|(
name|fuzzyKeyBytes
index|[
name|i
index|]
operator|&
literal|0xFF
operator|)
argument_list|)
condition|)
block|{
comment|// if setting value for any fixed position increased the original array,
comment|// we are OK
name|increased
operator|=
literal|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|order
operator|.
name|gt
argument_list|(
operator|(
name|row
index|[
name|i
operator|+
name|offset
index|]
operator|&
literal|0xFF
operator|)
argument_list|,
operator|(
name|fuzzyKeyBytes
index|[
name|i
index|]
operator|&
literal|0xFF
operator|)
argument_list|)
condition|)
block|{
comment|// if setting value for any fixed position makes array "smaller", then just stop:
comment|// in case we found some non-fixed position to increase we will do it, otherwise
comment|// there's no "next" row key that satisfies fuzzy rule and "greater" than given row
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|increased
condition|)
block|{
if|if
condition|(
name|toInc
operator|<
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|result
index|[
name|toInc
index|]
operator|=
name|order
operator|.
name|inc
argument_list|(
name|result
index|[
name|toInc
index|]
argument_list|)
expr_stmt|;
comment|// Setting all "non-fixed" positions to zeroes to the right of the one we increased so
comment|// that found "next" row key is the smallest possible
for|for
control|(
name|int
name|i
init|=
name|toInc
operator|+
literal|1
init|;
name|i
operator|<
name|result
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|fuzzyKeyMeta
operator|.
name|length
operator|||
name|fuzzyKeyMeta
index|[
name|i
index|]
operator|==
literal|0
comment|/* non-fixed */
condition|)
block|{
name|result
index|[
name|i
index|]
operator|=
name|order
operator|.
name|min
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
name|reverse
condition|?
name|result
else|:
name|trimTrailingZeroes
argument_list|(
name|result
argument_list|,
name|fuzzyKeyMeta
argument_list|,
name|toInc
argument_list|)
return|;
block|}
comment|/**    * For forward scanner, next cell hint should  not contain any trailing zeroes    * unless they are part of fuzzyKeyMeta    * hint = '\x01\x01\x01\x00\x00'    * will skip valid row '\x01\x01\x01'    *     * @param result    * @param fuzzyKeyMeta    * @param toInc - position of incremented byte    * @return trimmed version of result    */
specifier|private
specifier|static
name|byte
index|[]
name|trimTrailingZeroes
parameter_list|(
name|byte
index|[]
name|result
parameter_list|,
name|byte
index|[]
name|fuzzyKeyMeta
parameter_list|,
name|int
name|toInc
parameter_list|)
block|{
name|int
name|off
init|=
name|fuzzyKeyMeta
operator|.
name|length
operator|>=
name|result
operator|.
name|length
condition|?
name|result
operator|.
name|length
operator|-
literal|1
else|:
name|fuzzyKeyMeta
operator|.
name|length
operator|-
literal|1
decl_stmt|;
for|for
control|(
init|;
name|off
operator|>=
literal|0
condition|;
name|off
operator|--
control|)
block|{
if|if
condition|(
name|fuzzyKeyMeta
index|[
name|off
index|]
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|off
operator|<
name|toInc
condition|)
name|off
operator|=
name|toInc
expr_stmt|;
name|byte
index|[]
name|retValue
init|=
operator|new
name|byte
index|[
name|off
operator|+
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
name|retValue
argument_list|,
literal|0
argument_list|,
name|retValue
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|retValue
return|;
block|}
comment|/**    * @return true if and only if the fields of the filter that are serialized are equal to the    *         corresponding fields in other. Used for testing.    */
annotation|@
name|Override
name|boolean
name|areSerializedFieldsEqual
parameter_list|(
name|Filter
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
name|this
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|FuzzyRowFilter
operator|)
condition|)
return|return
literal|false
return|;
name|FuzzyRowFilter
name|other
init|=
operator|(
name|FuzzyRowFilter
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|fuzzyKeysData
operator|.
name|size
argument_list|()
operator|!=
name|other
operator|.
name|fuzzyKeysData
operator|.
name|size
argument_list|()
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fuzzyKeysData
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|thisData
init|=
name|this
operator|.
name|fuzzyKeysData
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Pair
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|otherData
init|=
name|other
operator|.
name|fuzzyKeysData
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|Bytes
operator|.
name|equals
argument_list|(
name|thisData
operator|.
name|getFirst
argument_list|()
argument_list|,
name|otherData
operator|.
name|getFirst
argument_list|()
argument_list|)
operator|&&
name|Bytes
operator|.
name|equals
argument_list|(
name|thisData
operator|.
name|getSecond
argument_list|()
argument_list|,
name|otherData
operator|.
name|getSecond
argument_list|()
argument_list|)
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
name|obj
operator|instanceof
name|Filter
operator|&&
name|areSerializedFieldsEqual
argument_list|(
operator|(
name|Filter
operator|)
name|obj
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hash
argument_list|(
name|this
operator|.
name|fuzzyKeysData
argument_list|)
return|;
block|}
block|}
end_class

end_unit

