begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|UndeclaredThrowableException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentSkipListMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentSkipListSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArraySet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Chore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MasterNotRunningException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|RegionTooBusyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Stoppable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotEnabledException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ZooKeeperConnectionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MetaScanner
operator|.
name|MetaScannerVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MetaScanner
operator|.
name|MetaScannerVisitorBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|coprocessor
operator|.
name|Batch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|RegionMovedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|RegionOpeningException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|RpcClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|RequestConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|AdminService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClientProtos
operator|.
name|ClientService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClientProtos
operator|.
name|CoprocessorServiceRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClientProtos
operator|.
name|CoprocessorServiceResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|AddColumnResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|AssignRegionResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|BalanceResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|CreateTableResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|DeleteColumnResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|DeleteSnapshotResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|DeleteTableResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|DisableTableResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|DispatchMergingRegionsResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|EnableCatalogJanitorResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|EnableTableResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|GetCompletedSnapshotsResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|GetTableDescriptorsRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|GetTableDescriptorsResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|GetTableNamesRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|IsCatalogJanitorEnabledResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|IsMasterRunningRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|IsMasterRunningResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|IsRestoreSnapshotDoneResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|IsSnapshotDoneResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|ListTableNamesByNamespaceResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|MasterService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|ModifyColumnResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|ModifyNamespaceResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|ModifyTableResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|MoveRegionResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|OfflineRegionResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|RestoreSnapshotResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|RunCatalogScanResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|SetBalancerRunningResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|ShutdownResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|SnapshotResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|StopMasterResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|UnassignRegionResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|AddColumnRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|BalanceRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|MasterProtos
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RegionServerStoppedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|User
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|UserProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|MasterAddressTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|BlockingRpcChannel
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|RpcController
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|ServiceException
import|;
end_import

begin_comment
comment|/**  * A non-instantiable class that manages creation of {@link HConnection}s.  *<p>The simplest way to use this class is by using {@link #createConnection(Configuration)}.  * This creates a new {@link HConnection} to the cluster that is managed by the caller.  * From this {@link HConnection} {@link HTableInterface} implementations are retrieved  * with {@link HConnection#getTable(byte[])}. Example:  *<pre>  * {@code  * HConnection connection = HConnectionManager.createConnection(config);  * HTableInterface table = connection.getTable("table1");  * try {  *   // Use the table as needed, for a single operation and a single thread  * } finally {  *   table.close();  *   connection.close();  * }  * }</pre>  *<p>The following logic and API will be removed in the future:  *<p>This class has a static Map of {@link HConnection} instances keyed by  * {@link Configuration}; all invocations of {@link #getConnection(Configuration)}  * that pass the same {@link Configuration} instance will be returned the same  * {@link  HConnection} instance (Adding properties to a Configuration  * instance does not change its object identity; for more on how this is done see  * {@link HConnectionKey}).  Sharing {@link HConnection}  * instances is usually what you want; all clients of the {@link HConnection}  * instances share the HConnections' cache of Region locations rather than each  * having to discover for itself the location of meta, etc.  It makes  * sense for the likes of the pool of HTables class {@link HTablePool}, for  * instance (If concerned that a single {@link HConnection} is insufficient  * for sharing amongst clients in say an heavily-multithreaded environment,  * in practise its not proven to be an issue.  Besides, {@link HConnection} is  * implemented atop Hadoop RPC and as of this writing, Hadoop RPC does a  * connection per cluster-member, exclusively).  *  *<p>But sharing connections makes clean up of {@link HConnection} instances a little awkward.  * Currently, clients cleanup by calling {@link #deleteConnection(Configuration)}. This will  * shutdown the zookeeper connection the HConnection was using and clean up all  * HConnection resources as well as stopping proxies to servers out on the  * cluster. Not running the cleanup will not end the world; it'll  * just stall the closeup some and spew some zookeeper connection failed  * messages into the log.  Running the cleanup on a {@link HConnection} that is  * subsequently used by another will cause breakage so be careful running  * cleanup.  *<p>To create a {@link HConnection} that is not shared by others, you can  * create a new {@link Configuration} instance, pass this new instance to  * {@link #getConnection(Configuration)}, and then when done, close it up by  * doing something like the following:  *<pre>  * {@code  * Configuration newConfig = new Configuration(originalConf);  * HConnection connection = HConnectionManager.getConnection(newConfig);  * // Use the connection to your hearts' delight and then when done...  * HConnectionManager.deleteConnection(newConfig, true);  * }  *</pre>  *<p>Cleanup used to be done inside in a shutdown hook.  On startup we'd  * register a shutdown hook that called {@link #deleteAllConnections()}  * on its way out but the order in which shutdown hooks run is not defined so  * were problematic for clients of HConnection that wanted to register their  * own shutdown hooks so we removed ours though this shifts the onus for  * cleanup to the client.  */
end_comment

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
class|class
name|HConnectionManager
block|{
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HConnectionManager
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|RETRIES_BY_SERVER_KEY
init|=
literal|"hbase.client.retries.by.server"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|CLIENT_NONCES_ENABLED_KEY
init|=
literal|"hbase.client.nonces.enabled"
decl_stmt|;
comment|// An LRU Map of HConnectionKey -> HConnection (TableServer).  All
comment|// access must be synchronized.  This map is not private because tests
comment|// need to be able to tinker with it.
specifier|static
specifier|final
name|Map
argument_list|<
name|HConnectionKey
argument_list|,
name|HConnectionImplementation
argument_list|>
name|CONNECTION_INSTANCES
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|MAX_CACHED_CONNECTION_INSTANCES
decl_stmt|;
comment|/**    * Global nonceGenerator shared per client.Currently there's no reason to limit its scope.    * Once it's set under nonceGeneratorCreateLock, it is never unset or changed.    */
specifier|private
specifier|static
specifier|volatile
name|NonceGenerator
name|nonceGenerator
init|=
literal|null
decl_stmt|;
comment|/** The nonce generator lock. Only taken when creating HConnection, which gets a private copy. */
specifier|private
specifier|static
name|Object
name|nonceGeneratorCreateLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
static|static
block|{
comment|// We set instances to one more than the value specified for {@link
comment|// HConstants#ZOOKEEPER_MAX_CLIENT_CNXNS}. By default, the zk default max
comment|// connections to the ensemble from the one client is 30, so in that case we
comment|// should run into zk issues before the LRU hit this value of 31.
name|MAX_CACHED_CONNECTION_INSTANCES
operator|=
name|HBaseConfiguration
operator|.
name|create
argument_list|()
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|ZOOKEEPER_MAX_CLIENT_CNXNS
argument_list|,
name|HConstants
operator|.
name|DEFAULT_ZOOKEPER_MAX_CLIENT_CNXNS
argument_list|)
operator|+
literal|1
expr_stmt|;
name|CONNECTION_INSTANCES
operator|=
operator|new
name|LinkedHashMap
argument_list|<
name|HConnectionKey
argument_list|,
name|HConnectionImplementation
argument_list|>
argument_list|(
call|(
name|int
call|)
argument_list|(
name|MAX_CACHED_CONNECTION_INSTANCES
operator|/
literal|0.75F
argument_list|)
operator|+
literal|1
argument_list|,
literal|0.75F
argument_list|,
literal|true
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|boolean
name|removeEldestEntry
parameter_list|(
name|Map
operator|.
name|Entry
argument_list|<
name|HConnectionKey
argument_list|,
name|HConnectionImplementation
argument_list|>
name|eldest
parameter_list|)
block|{
return|return
name|size
argument_list|()
operator|>
name|MAX_CACHED_CONNECTION_INSTANCES
return|;
block|}
block|}
expr_stmt|;
block|}
comment|/*    * Non-instantiable.    */
specifier|private
name|HConnectionManager
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
comment|/**    * @param conn The connection for which to replace the generator.    * @param cnm Replaces the nonce generator used, for testing.    * @return old nonce generator.    */
annotation|@
name|VisibleForTesting
specifier|public
specifier|static
name|NonceGenerator
name|injectNonceGeneratorForTesting
parameter_list|(
name|HConnection
name|conn
parameter_list|,
name|NonceGenerator
name|cnm
parameter_list|)
block|{
name|NonceGenerator
name|ng
init|=
name|conn
operator|.
name|getNonceGenerator
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Nonce generator is being replaced by test code for "
operator|+
name|cnm
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
operator|(
operator|(
name|HConnectionImplementation
operator|)
name|conn
operator|)
operator|.
name|nonceGenerator
operator|=
name|cnm
expr_stmt|;
return|return
name|ng
return|;
block|}
comment|/**    * Get the connection that goes with the passed<code>conf</code> configuration instance.    * If no current connection exists, method creates a new connection and keys it using    * connection-specific properties from the passed {@link Configuration}; see    * {@link HConnectionKey}.    * @param conf configuration    * @return HConnection object for<code>conf</code>    * @throws ZooKeeperConnectionException    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|HConnection
name|getConnection
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|HConnectionKey
name|connectionKey
init|=
operator|new
name|HConnectionKey
argument_list|(
name|conf
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|CONNECTION_INSTANCES
init|)
block|{
name|HConnectionImplementation
name|connection
init|=
name|CONNECTION_INSTANCES
operator|.
name|get
argument_list|(
name|connectionKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|connection
operator|==
literal|null
condition|)
block|{
name|connection
operator|=
operator|(
name|HConnectionImplementation
operator|)
name|createConnection
argument_list|(
name|conf
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|CONNECTION_INSTANCES
operator|.
name|put
argument_list|(
name|connectionKey
argument_list|,
name|connection
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|connection
operator|.
name|isClosed
argument_list|()
condition|)
block|{
name|HConnectionManager
operator|.
name|deleteConnection
argument_list|(
name|connectionKey
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|connection
operator|=
operator|(
name|HConnectionImplementation
operator|)
name|createConnection
argument_list|(
name|conf
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|CONNECTION_INSTANCES
operator|.
name|put
argument_list|(
name|connectionKey
argument_list|,
name|connection
argument_list|)
expr_stmt|;
block|}
name|connection
operator|.
name|incCount
argument_list|()
expr_stmt|;
return|return
name|connection
return|;
block|}
block|}
comment|/**    * Create a new HConnection instance using the passed<code>conf</code> instance.    *<p>Note: This bypasses the usual HConnection life cycle management done by    * {@link #getConnection(Configuration)}. The caller is responsible for    * calling {@link HConnection#close()} on the returned connection instance.    *    * This is the recommended way to create HConnections.    * {@code    * HConnection connection = HConnectionManager.createConnection(conf);    * HTableInterface table = connection.getTable("mytable");    * table.get(...);    * ...    * table.close();    * connection.close();    * }    *    * @param conf configuration    * @return HConnection object for<code>conf</code>    * @throws ZooKeeperConnectionException    */
specifier|public
specifier|static
name|HConnection
name|createConnection
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|UserProvider
name|provider
init|=
name|UserProvider
operator|.
name|instantiate
argument_list|(
name|conf
argument_list|)
decl_stmt|;
return|return
name|createConnection
argument_list|(
name|conf
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|provider
operator|.
name|getCurrent
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Create a new HConnection instance using the passed<code>conf</code> instance.    *<p>Note: This bypasses the usual HConnection life cycle management done by    * {@link #getConnection(Configuration)}. The caller is responsible for    * calling {@link HConnection#close()} on the returned connection instance.    * This is the recommended way to create HConnections.    * {@code    * ExecutorService pool = ...;    * HConnection connection = HConnectionManager.createConnection(conf, pool);    * HTableInterface table = connection.getTable("mytable");    * table.get(...);    * ...    * table.close();    * connection.close();    * }    * @param conf configuration    * @param pool the thread pool to use for batch operation in HTables used via this HConnection    * @return HConnection object for<code>conf</code>    * @throws ZooKeeperConnectionException    */
specifier|public
specifier|static
name|HConnection
name|createConnection
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|ExecutorService
name|pool
parameter_list|)
throws|throws
name|IOException
block|{
name|UserProvider
name|provider
init|=
name|UserProvider
operator|.
name|instantiate
argument_list|(
name|conf
argument_list|)
decl_stmt|;
return|return
name|createConnection
argument_list|(
name|conf
argument_list|,
literal|false
argument_list|,
name|pool
argument_list|,
name|provider
operator|.
name|getCurrent
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Create a new HConnection instance using the passed<code>conf</code> instance.    *<p>Note: This bypasses the usual HConnection life cycle management done by    * {@link #getConnection(Configuration)}. The caller is responsible for    * calling {@link HConnection#close()} on the returned connection instance.    * This is the recommended way to create HConnections.    * {@code    * ExecutorService pool = ...;    * HConnection connection = HConnectionManager.createConnection(conf, pool);    * HTableInterface table = connection.getTable("mytable");    * table.get(...);    * ...    * table.close();    * connection.close();    * }    * @param conf configuration    * @param user the user the connection is for    * @return HConnection object for<code>conf</code>    * @throws ZooKeeperConnectionException    */
specifier|public
specifier|static
name|HConnection
name|createConnection
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|User
name|user
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createConnection
argument_list|(
name|conf
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|user
argument_list|)
return|;
block|}
comment|/**    * Create a new HConnection instance using the passed<code>conf</code> instance.    *<p>Note: This bypasses the usual HConnection life cycle management done by    * {@link #getConnection(Configuration)}. The caller is responsible for    * calling {@link HConnection#close()} on the returned connection instance.    * This is the recommended way to create HConnections.    * {@code    * ExecutorService pool = ...;    * HConnection connection = HConnectionManager.createConnection(conf, pool);    * HTableInterface table = connection.getTable("mytable");    * table.get(...);    * ...    * table.close();    * connection.close();    * }    * @param conf configuration    * @param pool the thread pool to use for batch operation in HTables used via this HConnection    * @param user the user the connection is for    * @return HConnection object for<code>conf</code>    * @throws ZooKeeperConnectionException    */
specifier|public
specifier|static
name|HConnection
name|createConnection
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|ExecutorService
name|pool
parameter_list|,
name|User
name|user
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createConnection
argument_list|(
name|conf
argument_list|,
literal|false
argument_list|,
name|pool
argument_list|,
name|user
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
specifier|static
name|HConnection
name|createConnection
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|boolean
name|managed
parameter_list|)
throws|throws
name|IOException
block|{
name|UserProvider
name|provider
init|=
name|UserProvider
operator|.
name|instantiate
argument_list|(
name|conf
argument_list|)
decl_stmt|;
return|return
name|createConnection
argument_list|(
name|conf
argument_list|,
name|managed
argument_list|,
literal|null
argument_list|,
name|provider
operator|.
name|getCurrent
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Deprecated
specifier|static
name|HConnection
name|createConnection
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|boolean
name|managed
parameter_list|,
specifier|final
name|ExecutorService
name|pool
parameter_list|,
specifier|final
name|User
name|user
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|className
init|=
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.client.connection.impl"
argument_list|,
name|HConnectionManager
operator|.
name|HConnectionImplementation
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
literal|null
decl_stmt|;
try|try
block|{
name|clazz
operator|=
name|Class
operator|.
name|forName
argument_list|(
name|className
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
try|try
block|{
comment|// Default HCM#HCI is not accessible; make it so before invoking.
name|Constructor
argument_list|<
name|?
argument_list|>
name|constructor
init|=
name|clazz
operator|.
name|getDeclaredConstructor
argument_list|(
name|Configuration
operator|.
name|class
argument_list|,
name|boolean
operator|.
name|class
argument_list|,
name|ExecutorService
operator|.
name|class
argument_list|,
name|User
operator|.
name|class
argument_list|)
decl_stmt|;
name|constructor
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
operator|(
name|HConnection
operator|)
name|constructor
operator|.
name|newInstance
argument_list|(
name|conf
argument_list|,
name|managed
argument_list|,
name|pool
argument_list|,
name|user
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Delete connection information for the instance specified by passed configuration.    * If there are no more references to the designated connection connection, this method will    * then close connection to the zookeeper ensemble and let go of all associated resources.    *    * @param conf configuration whose identity is used to find {@link HConnection} instance.    * @deprecated    */
specifier|public
specifier|static
name|void
name|deleteConnection
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|deleteConnection
argument_list|(
operator|new
name|HConnectionKey
argument_list|(
name|conf
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Cleanup a known stale connection.    * This will then close connection to the zookeeper ensemble and let go of all resources.    *    * @param connection    * @deprecated    */
specifier|public
specifier|static
name|void
name|deleteStaleConnection
parameter_list|(
name|HConnection
name|connection
parameter_list|)
block|{
name|deleteConnection
argument_list|(
name|connection
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete information for all connections. Close or not the connection, depending on the    *  staleConnection boolean and the ref count. By default, you should use it with    *  staleConnection to true.    * @deprecated    */
specifier|public
specifier|static
name|void
name|deleteAllConnections
parameter_list|(
name|boolean
name|staleConnection
parameter_list|)
block|{
synchronized|synchronized
init|(
name|CONNECTION_INSTANCES
init|)
block|{
name|Set
argument_list|<
name|HConnectionKey
argument_list|>
name|connectionKeys
init|=
operator|new
name|HashSet
argument_list|<
name|HConnectionKey
argument_list|>
argument_list|()
decl_stmt|;
name|connectionKeys
operator|.
name|addAll
argument_list|(
name|CONNECTION_INSTANCES
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|HConnectionKey
name|connectionKey
range|:
name|connectionKeys
control|)
block|{
name|deleteConnection
argument_list|(
name|connectionKey
argument_list|,
name|staleConnection
argument_list|)
expr_stmt|;
block|}
name|CONNECTION_INSTANCES
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Delete information for all connections..    * @deprecated kept for backward compatibility, but the behavior is broken. HBASE-8983    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|void
name|deleteAllConnections
parameter_list|()
block|{
name|deleteAllConnections
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Deprecated
specifier|private
specifier|static
name|void
name|deleteConnection
parameter_list|(
name|HConnection
name|connection
parameter_list|,
name|boolean
name|staleConnection
parameter_list|)
block|{
synchronized|synchronized
init|(
name|CONNECTION_INSTANCES
init|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|HConnectionKey
argument_list|,
name|HConnectionImplementation
argument_list|>
name|e
range|:
name|CONNECTION_INSTANCES
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getValue
argument_list|()
operator|==
name|connection
condition|)
block|{
name|deleteConnection
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|staleConnection
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
annotation|@
name|Deprecated
specifier|private
specifier|static
name|void
name|deleteConnection
parameter_list|(
name|HConnectionKey
name|connectionKey
parameter_list|,
name|boolean
name|staleConnection
parameter_list|)
block|{
synchronized|synchronized
init|(
name|CONNECTION_INSTANCES
init|)
block|{
name|HConnectionImplementation
name|connection
init|=
name|CONNECTION_INSTANCES
operator|.
name|get
argument_list|(
name|connectionKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|connection
operator|!=
literal|null
condition|)
block|{
name|connection
operator|.
name|decCount
argument_list|()
expr_stmt|;
if|if
condition|(
name|connection
operator|.
name|isZeroReference
argument_list|()
operator|||
name|staleConnection
condition|)
block|{
name|CONNECTION_INSTANCES
operator|.
name|remove
argument_list|(
name|connectionKey
argument_list|)
expr_stmt|;
name|connection
operator|.
name|internalClose
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Connection not found in the list, can't delete it "
operator|+
literal|"(connection key="
operator|+
name|connectionKey
operator|+
literal|"). May be the key was modified?"
argument_list|,
operator|new
name|Exception
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * It is provided for unit test cases which verify the behavior of region    * location cache prefetch.    * @return Number of cached regions for the table.    * @throws ZooKeeperConnectionException    */
specifier|static
name|int
name|getCachedRegionCount
parameter_list|(
name|Configuration
name|conf
parameter_list|,
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|execute
argument_list|(
operator|new
name|HConnectable
argument_list|<
name|Integer
argument_list|>
argument_list|(
name|conf
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Integer
name|connect
parameter_list|(
name|HConnection
name|connection
parameter_list|)
block|{
return|return
operator|(
operator|(
name|HConnectionImplementation
operator|)
name|connection
operator|)
operator|.
name|getNumberOfCachedRegionLocations
argument_list|(
name|tableName
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * It's provided for unit test cases which verify the behavior of region    * location cache prefetch.    * @return true if the region where the table and row reside is cached.    * @throws ZooKeeperConnectionException    */
specifier|static
name|boolean
name|isRegionCached
parameter_list|(
name|Configuration
name|conf
parameter_list|,
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|execute
argument_list|(
operator|new
name|HConnectable
argument_list|<
name|Boolean
argument_list|>
argument_list|(
name|conf
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|connect
parameter_list|(
name|HConnection
name|connection
parameter_list|)
block|{
return|return
operator|(
operator|(
name|HConnectionImplementation
operator|)
name|connection
operator|)
operator|.
name|isRegionCached
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * This convenience method invokes the given {@link HConnectable#connect}    * implementation using a {@link HConnection} instance that lasts just for the    * duration of the invocation.    *    * @param<T> the return type of the connect method    * @param connectable the {@link HConnectable} instance    * @return the value returned by the connect method    * @throws IOException    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|execute
parameter_list|(
name|HConnectable
argument_list|<
name|T
argument_list|>
name|connectable
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|connectable
operator|==
literal|null
operator|||
name|connectable
operator|.
name|conf
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Configuration
name|conf
init|=
name|connectable
operator|.
name|conf
decl_stmt|;
name|HConnection
name|connection
init|=
name|HConnectionManager
operator|.
name|getConnection
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|boolean
name|connectSucceeded
init|=
literal|false
decl_stmt|;
try|try
block|{
name|T
name|returnValue
init|=
name|connectable
operator|.
name|connect
argument_list|(
name|connection
argument_list|)
decl_stmt|;
name|connectSucceeded
operator|=
literal|true
expr_stmt|;
return|return
name|returnValue
return|;
block|}
finally|finally
block|{
try|try
block|{
name|connection
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|connectSucceeded
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The connection to "
operator|+
name|connection
operator|+
literal|" could not be deleted."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/** Encapsulates connection to zookeeper and regionservers.*/
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"AT_OPERATION_SEQUENCE_ON_CONCURRENT_ABSTRACTION"
argument_list|,
name|justification
operator|=
literal|"Access to the conncurrent hash map is under a lock so should be fine."
argument_list|)
specifier|static
class|class
name|HConnectionImplementation
implements|implements
name|HConnection
implements|,
name|Closeable
block|{
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HConnectionImplementation
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|long
name|pause
decl_stmt|;
specifier|private
specifier|final
name|int
name|numTries
decl_stmt|;
specifier|final
name|int
name|rpcTimeout
decl_stmt|;
specifier|private
name|NonceGenerator
name|nonceGenerator
init|=
literal|null
decl_stmt|;
specifier|private
specifier|final
name|int
name|prefetchRegionLimit
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|closed
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|aborted
decl_stmt|;
comment|// package protected for the tests
name|ClusterStatusListener
name|clusterStatusListener
decl_stmt|;
specifier|private
specifier|final
name|Object
name|userRegionLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
comment|// We have a single lock for master& zk to prevent deadlocks. Having
comment|//  one lock for ZK and one lock for master is not possible:
comment|//  When creating a connection to master, we need a connection to ZK to get
comment|//  its address. But another thread could have taken the ZK lock, and could
comment|//  be waiting for the master lock => deadlock.
specifier|private
specifier|final
name|Object
name|masterAndZKLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
name|long
name|keepZooKeeperWatcherAliveUntil
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
specifier|private
specifier|final
name|DelayedClosing
name|delayedClosing
init|=
name|DelayedClosing
operator|.
name|createAndStart
argument_list|(
name|this
argument_list|)
decl_stmt|;
comment|// thread executor shared by all HTableInterface instances created
comment|// by this connection
specifier|private
specifier|volatile
name|ExecutorService
name|batchPool
init|=
literal|null
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|cleanupPool
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
comment|// Client rpc instance.
specifier|private
name|RpcClient
name|rpcClient
decl_stmt|;
comment|/**       * Map of table to table {@link HRegionLocation}s.       */
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|TableName
argument_list|,
name|ConcurrentSkipListMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
argument_list|>
name|cachedRegionLocations
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|TableName
argument_list|,
name|ConcurrentSkipListMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// The presence of a server in the map implies it's likely that there is an
comment|// entry in cachedRegionLocations that map to this server; but the absence
comment|// of a server in this map guarentees that there is no entry in cache that
comment|// maps to the absent server.
comment|// The access to this attribute must be protected by a lock on cachedRegionLocations
specifier|private
specifier|final
name|Set
argument_list|<
name|ServerName
argument_list|>
name|cachedServers
init|=
operator|new
name|ConcurrentSkipListSet
argument_list|<
name|ServerName
argument_list|>
argument_list|()
decl_stmt|;
comment|// region cache prefetch is enabled by default. this set contains all
comment|// tables whose region cache prefetch are disabled.
specifier|private
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|regionCachePrefetchDisabledTables
init|=
operator|new
name|CopyOnWriteArraySet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|int
name|refCount
decl_stmt|;
comment|// indicates whether this connection's life cycle is managed (by us)
specifier|private
name|boolean
name|managed
decl_stmt|;
specifier|private
name|User
name|user
decl_stmt|;
comment|/**      * Cluster registry of basic info such as clusterid and meta region location.      */
name|Registry
name|registry
decl_stmt|;
name|HConnectionImplementation
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|managed
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|conf
argument_list|,
name|managed
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * constructor      * @param conf Configuration object      * @param managed If true, does not do full shutdown on close; i.e. cleanup of connection      * to zk and shutdown of all services; we just close down the resources this connection was      * responsible for and decrement usage counters.  It is up to the caller to do the full      * cleanup.  It is set when we want have connection sharing going on -- reuse of zk connection,      * and cached region locations, established regionserver connections, etc.  When connections      * are shared, we have reference counting going on and will only do full cleanup when no more      * users of an HConnectionImplementation instance.      */
name|HConnectionImplementation
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|managed
parameter_list|,
name|ExecutorService
name|pool
parameter_list|,
name|User
name|user
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|user
operator|=
name|user
expr_stmt|;
name|this
operator|.
name|batchPool
operator|=
name|pool
expr_stmt|;
name|this
operator|.
name|managed
operator|=
name|managed
expr_stmt|;
name|this
operator|.
name|registry
operator|=
name|setupRegistry
argument_list|()
expr_stmt|;
name|retrieveClusterId
argument_list|()
expr_stmt|;
name|this
operator|.
name|rpcClient
operator|=
operator|new
name|RpcClient
argument_list|(
name|this
operator|.
name|conf
argument_list|,
name|this
operator|.
name|clusterId
argument_list|)
expr_stmt|;
comment|// Do we publish the status?
name|boolean
name|shouldListen
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|HConstants
operator|.
name|STATUS_PUBLISHED
argument_list|,
name|HConstants
operator|.
name|STATUS_PUBLISHED_DEFAULT
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|ClusterStatusListener
operator|.
name|Listener
argument_list|>
name|listenerClass
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|ClusterStatusListener
operator|.
name|STATUS_LISTENER_CLASS
argument_list|,
name|ClusterStatusListener
operator|.
name|DEFAULT_STATUS_LISTENER_CLASS
argument_list|,
name|ClusterStatusListener
operator|.
name|Listener
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|shouldListen
condition|)
block|{
if|if
condition|(
name|listenerClass
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|HConstants
operator|.
name|STATUS_PUBLISHED
operator|+
literal|" is true, but "
operator|+
name|ClusterStatusListener
operator|.
name|STATUS_LISTENER_CLASS
operator|+
literal|" is not set - not listening status"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clusterStatusListener
operator|=
operator|new
name|ClusterStatusListener
argument_list|(
operator|new
name|ClusterStatusListener
operator|.
name|DeadServerHandler
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|newDead
parameter_list|(
name|ServerName
name|sn
parameter_list|)
block|{
name|clearCaches
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|rpcClient
operator|.
name|cancelConnections
argument_list|(
name|sn
operator|.
name|getHostname
argument_list|()
argument_list|,
name|sn
operator|.
name|getPort
argument_list|()
argument_list|,
operator|new
name|SocketException
argument_list|(
name|sn
operator|.
name|getServerName
argument_list|()
operator|+
literal|" is dead: closing its connection."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|,
name|conf
argument_list|,
name|listenerClass
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Dummy nonce generator for disabled nonces. */
specifier|private
specifier|static
class|class
name|NoNonceGenerator
implements|implements
name|NonceGenerator
block|{
annotation|@
name|Override
specifier|public
name|long
name|getNonceGroup
parameter_list|()
block|{
return|return
name|HConstants
operator|.
name|NO_NONCE
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|newNonce
parameter_list|()
block|{
return|return
name|HConstants
operator|.
name|NO_NONCE
return|;
block|}
block|}
comment|/**      * For tests.      */
specifier|protected
name|HConnectionImplementation
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|closed
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|pause
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_PAUSE
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_PAUSE
argument_list|)
expr_stmt|;
name|this
operator|.
name|numTries
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_RETRIES_NUMBER
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_RETRIES_NUMBER
argument_list|)
expr_stmt|;
name|this
operator|.
name|rpcTimeout
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_RPC_TIMEOUT_KEY
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_RPC_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|CLIENT_NONCES_ENABLED_KEY
argument_list|,
literal|true
argument_list|)
condition|)
block|{
synchronized|synchronized
init|(
name|HConnectionManager
operator|.
name|nonceGeneratorCreateLock
init|)
block|{
if|if
condition|(
name|HConnectionManager
operator|.
name|nonceGenerator
operator|==
literal|null
condition|)
block|{
name|HConnectionManager
operator|.
name|nonceGenerator
operator|=
operator|new
name|PerClientRandomNonceGenerator
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|nonceGenerator
operator|=
name|HConnectionManager
operator|.
name|nonceGenerator
expr_stmt|;
block|}
block|}
else|else
block|{
name|this
operator|.
name|nonceGenerator
operator|=
operator|new
name|NoNonceGenerator
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|prefetchRegionLimit
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_PREFETCH_LIMIT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_PREFETCH_LIMIT
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|HTableInterface
name|getTable
parameter_list|(
name|String
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getTable
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|HTableInterface
name|getTable
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getTable
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|HTableInterface
name|getTable
parameter_list|(
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getTable
argument_list|(
name|tableName
argument_list|,
name|getBatchPool
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|HTableInterface
name|getTable
parameter_list|(
name|String
name|tableName
parameter_list|,
name|ExecutorService
name|pool
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getTable
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|HTableInterface
name|getTable
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|,
name|ExecutorService
name|pool
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getTable
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|HTableInterface
name|getTable
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|ExecutorService
name|pool
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|managed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The connection has to be unmanaged."
argument_list|)
throw|;
block|}
return|return
operator|new
name|HTable
argument_list|(
name|tableName
argument_list|,
name|this
argument_list|,
name|pool
argument_list|)
return|;
block|}
specifier|private
name|ExecutorService
name|getBatchPool
parameter_list|()
block|{
if|if
condition|(
name|batchPool
operator|==
literal|null
condition|)
block|{
comment|// shared HTable thread executor not yet initialized
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|batchPool
operator|==
literal|null
condition|)
block|{
name|int
name|maxThreads
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.hconnection.threads.max"
argument_list|,
literal|256
argument_list|)
decl_stmt|;
name|int
name|coreThreads
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.hconnection.threads.core"
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxThreads
operator|==
literal|0
condition|)
block|{
name|maxThreads
operator|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|availableProcessors
argument_list|()
operator|*
literal|8
expr_stmt|;
block|}
name|long
name|keepAliveTime
init|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.hconnection.threads.keepalivetime"
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|LinkedBlockingQueue
argument_list|<
name|Runnable
argument_list|>
name|workQueue
init|=
operator|new
name|LinkedBlockingQueue
argument_list|<
name|Runnable
argument_list|>
argument_list|(
name|maxThreads
operator|*
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_MAX_TOTAL_TASKS
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_MAX_TOTAL_TASKS
argument_list|)
argument_list|)
decl_stmt|;
name|this
operator|.
name|batchPool
operator|=
operator|new
name|ThreadPoolExecutor
argument_list|(
name|coreThreads
argument_list|,
name|maxThreads
argument_list|,
name|keepAliveTime
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
name|workQueue
argument_list|,
name|Threads
operator|.
name|newDaemonThreadFactory
argument_list|(
name|toString
argument_list|()
operator|+
literal|"-shared-"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|cleanupPool
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|this
operator|.
name|batchPool
return|;
block|}
specifier|protected
name|ExecutorService
name|getCurrentBatchPool
parameter_list|()
block|{
return|return
name|batchPool
return|;
block|}
specifier|private
name|void
name|shutdownBatchPool
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|cleanupPool
operator|&&
name|this
operator|.
name|batchPool
operator|!=
literal|null
operator|&&
operator|!
name|this
operator|.
name|batchPool
operator|.
name|isShutdown
argument_list|()
condition|)
block|{
name|this
operator|.
name|batchPool
operator|.
name|shutdown
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|batchPool
operator|.
name|awaitTermination
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
name|this
operator|.
name|batchPool
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|this
operator|.
name|batchPool
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * @return The cluster registry implementation to use.      * @throws IOException      */
specifier|private
name|Registry
name|setupRegistry
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|registryClass
init|=
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.client.registry.impl"
argument_list|,
name|ZooKeeperRegistry
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|Registry
name|registry
init|=
literal|null
decl_stmt|;
try|try
block|{
name|registry
operator|=
operator|(
name|Registry
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|registryClass
argument_list|)
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|t
argument_list|)
throw|;
block|}
name|registry
operator|.
name|init
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|registry
return|;
block|}
comment|/**      * For tests only.      * @param rpcClient Client we should use instead.      * @return Previous rpcClient      */
name|RpcClient
name|setRpcClient
parameter_list|(
specifier|final
name|RpcClient
name|rpcClient
parameter_list|)
block|{
name|RpcClient
name|oldRpcClient
init|=
name|this
operator|.
name|rpcClient
decl_stmt|;
name|this
operator|.
name|rpcClient
operator|=
name|rpcClient
expr_stmt|;
return|return
name|oldRpcClient
return|;
block|}
comment|/**      * An identifier that will remain the same for a given connection.      * @return      */
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"hconnection-0x"
operator|+
name|Integer
operator|.
name|toHexString
argument_list|(
name|hashCode
argument_list|()
argument_list|)
return|;
block|}
specifier|protected
name|String
name|clusterId
init|=
literal|null
decl_stmt|;
name|void
name|retrieveClusterId
parameter_list|()
block|{
if|if
condition|(
name|clusterId
operator|!=
literal|null
condition|)
return|return;
name|this
operator|.
name|clusterId
operator|=
name|this
operator|.
name|registry
operator|.
name|getClusterId
argument_list|()
expr_stmt|;
if|if
condition|(
name|clusterId
operator|==
literal|null
condition|)
block|{
name|clusterId
operator|=
name|HConstants
operator|.
name|CLUSTER_ID_DEFAULT
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"clusterid came back null, using default "
operator|+
name|clusterId
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Configuration
name|getConfiguration
parameter_list|()
block|{
return|return
name|this
operator|.
name|conf
return|;
block|}
specifier|private
name|void
name|checkIfBaseNodeAvailable
parameter_list|(
name|ZooKeeperWatcher
name|zkw
parameter_list|)
throws|throws
name|MasterNotRunningException
block|{
name|String
name|errorMsg
decl_stmt|;
try|try
block|{
if|if
condition|(
name|ZKUtil
operator|.
name|checkExists
argument_list|(
name|zkw
argument_list|,
name|zkw
operator|.
name|baseZNode
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|errorMsg
operator|=
literal|"The node "
operator|+
name|zkw
operator|.
name|baseZNode
operator|+
literal|" is not in ZooKeeper. "
operator|+
literal|"It should have been written by the master. "
operator|+
literal|"Check the value configured in 'zookeeper.znode.parent'. "
operator|+
literal|"There could be a mismatch with the one configured in the master."
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|errorMsg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MasterNotRunningException
argument_list|(
name|errorMsg
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|errorMsg
operator|=
literal|"Can't get connection to ZooKeeper: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|errorMsg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MasterNotRunningException
argument_list|(
name|errorMsg
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * @return true if the master is running, throws an exception otherwise      * @throws MasterNotRunningException - if the master is not running      * @throws ZooKeeperConnectionException      */
annotation|@
name|Override
specifier|public
name|boolean
name|isMasterRunning
parameter_list|()
throws|throws
name|MasterNotRunningException
throws|,
name|ZooKeeperConnectionException
block|{
comment|// When getting the master connection, we check it's running,
comment|// so if there is no exception, it means we've been able to get a
comment|// connection on a running master
name|MasterKeepAliveConnection
name|m
init|=
name|getKeepAliveMasterService
argument_list|()
decl_stmt|;
name|m
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|HRegionLocation
name|getRegionLocation
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
name|boolean
name|reload
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|reload
condition|?
name|relocateRegion
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|)
else|:
name|locateRegion
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|HRegionLocation
name|getRegionLocation
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
name|boolean
name|reload
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getRegionLocation
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|row
argument_list|,
name|reload
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isTableEnabled
parameter_list|(
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|this
operator|.
name|registry
operator|.
name|isTableOnlineState
argument_list|(
name|tableName
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isTableEnabled
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isTableEnabled
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isTableDisabled
parameter_list|(
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|this
operator|.
name|registry
operator|.
name|isTableOnlineState
argument_list|(
name|tableName
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isTableDisabled
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isTableDisabled
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isTableAvailable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|AtomicBoolean
name|available
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|AtomicInteger
name|regionCount
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|MetaScannerVisitor
name|visitor
init|=
operator|new
name|MetaScannerVisitorBase
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|processRow
parameter_list|(
name|Result
name|row
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegionInfo
name|info
init|=
name|MetaScanner
operator|.
name|getHRegionInfo
argument_list|(
name|row
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
operator|&&
operator|!
name|info
operator|.
name|isSplitParent
argument_list|()
condition|)
block|{
if|if
condition|(
name|tableName
operator|.
name|equals
argument_list|(
name|info
operator|.
name|getTable
argument_list|()
argument_list|)
condition|)
block|{
name|ServerName
name|server
init|=
name|HRegionInfo
operator|.
name|getServerName
argument_list|(
name|row
argument_list|)
decl_stmt|;
if|if
condition|(
name|server
operator|==
literal|null
condition|)
block|{
name|available
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|regionCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tableName
operator|.
name|compareTo
argument_list|(
name|info
operator|.
name|getTable
argument_list|()
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|// Return if we are done with the current table
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
decl_stmt|;
name|MetaScanner
operator|.
name|metaScan
argument_list|(
name|conf
argument_list|,
name|this
argument_list|,
name|visitor
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
return|return
name|available
operator|.
name|get
argument_list|()
operator|&&
operator|(
name|regionCount
operator|.
name|get
argument_list|()
operator|>
literal|0
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isTableAvailable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isTableAvailable
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isTableAvailable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
index|[]
name|splitKeys
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|AtomicBoolean
name|available
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|AtomicInteger
name|regionCount
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|MetaScannerVisitor
name|visitor
init|=
operator|new
name|MetaScannerVisitorBase
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|processRow
parameter_list|(
name|Result
name|row
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegionInfo
name|info
init|=
name|MetaScanner
operator|.
name|getHRegionInfo
argument_list|(
name|row
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
operator|&&
operator|!
name|info
operator|.
name|isSplitParent
argument_list|()
condition|)
block|{
if|if
condition|(
name|tableName
operator|.
name|equals
argument_list|(
name|info
operator|.
name|getTable
argument_list|()
argument_list|)
condition|)
block|{
name|ServerName
name|server
init|=
name|HRegionInfo
operator|.
name|getServerName
argument_list|(
name|row
argument_list|)
decl_stmt|;
if|if
condition|(
name|server
operator|==
literal|null
condition|)
block|{
name|available
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|info
operator|.
name|getStartKey
argument_list|()
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|)
condition|)
block|{
for|for
control|(
name|byte
index|[]
name|splitKey
range|:
name|splitKeys
control|)
block|{
comment|// Just check if the splitkey is available
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|info
operator|.
name|getStartKey
argument_list|()
argument_list|,
name|splitKey
argument_list|)
condition|)
block|{
name|regionCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
comment|// Always empty start row should be counted
name|regionCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tableName
operator|.
name|compareTo
argument_list|(
name|info
operator|.
name|getTable
argument_list|()
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|// Return if we are done with the current table
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
decl_stmt|;
name|MetaScanner
operator|.
name|metaScan
argument_list|(
name|conf
argument_list|,
name|this
argument_list|,
name|visitor
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
comment|// +1 needs to be added so that the empty start row is also taken into account
return|return
name|available
operator|.
name|get
argument_list|()
operator|&&
operator|(
name|regionCount
operator|.
name|get
argument_list|()
operator|==
name|splitKeys
operator|.
name|length
operator|+
literal|1
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isTableAvailable
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
index|[]
name|splitKeys
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isTableAvailable
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|splitKeys
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|HRegionLocation
name|locateRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|locateRegion
argument_list|(
name|HRegionInfo
operator|.
name|getTable
argument_list|(
name|regionName
argument_list|)
argument_list|,
name|HRegionInfo
operator|.
name|getStartKey
argument_list|(
name|regionName
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isDeadServer
parameter_list|(
name|ServerName
name|sn
parameter_list|)
block|{
if|if
condition|(
name|clusterStatusListener
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|clusterStatusListener
operator|.
name|isDeadServer
argument_list|(
name|sn
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|HRegionLocation
argument_list|>
name|locateRegions
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|locateRegions
argument_list|(
name|tableName
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|HRegionLocation
argument_list|>
name|locateRegions
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|locateRegions
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|HRegionLocation
argument_list|>
name|locateRegions
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|boolean
name|useCache
parameter_list|,
specifier|final
name|boolean
name|offlined
parameter_list|)
throws|throws
name|IOException
block|{
name|NavigableMap
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|regions
init|=
name|MetaScanner
operator|.
name|allTableRegions
argument_list|(
name|conf
argument_list|,
name|this
argument_list|,
name|tableName
argument_list|,
name|offlined
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|HRegionLocation
argument_list|>
name|locations
init|=
operator|new
name|ArrayList
argument_list|<
name|HRegionLocation
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|HRegionInfo
name|regionInfo
range|:
name|regions
operator|.
name|keySet
argument_list|()
control|)
block|{
name|locations
operator|.
name|add
argument_list|(
name|locateRegion
argument_list|(
name|tableName
argument_list|,
name|regionInfo
operator|.
name|getStartKey
argument_list|()
argument_list|,
name|useCache
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|locations
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|HRegionLocation
argument_list|>
name|locateRegions
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|boolean
name|useCache
parameter_list|,
specifier|final
name|boolean
name|offlined
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|locateRegions
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|useCache
argument_list|,
name|offlined
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|HRegionLocation
name|locateRegion
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|locateRegion
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|HRegionLocation
name|locateRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|locateRegion
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|row
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|HRegionLocation
name|relocateRegion
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Since this is an explicit request not to use any caching, finding
comment|// disabled tables should not be desirable.  This will ensure that an exception is thrown when
comment|// the first time a disabled table is interacted with.
if|if
condition|(
name|isTableDisabled
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TableNotEnabledException
argument_list|(
name|tableName
operator|.
name|getNameAsString
argument_list|()
operator|+
literal|" is disabled."
argument_list|)
throw|;
block|}
return|return
name|locateRegion
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|HRegionLocation
name|relocateRegion
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|relocateRegion
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|row
argument_list|)
return|;
block|}
specifier|private
name|HRegionLocation
name|locateRegion
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
name|boolean
name|useCache
parameter_list|,
name|boolean
name|retry
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|closed
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
name|toString
argument_list|()
operator|+
literal|" closed"
argument_list|)
throw|;
if|if
condition|(
name|tableName
operator|==
literal|null
operator|||
name|tableName
operator|.
name|getName
argument_list|()
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"table name cannot be null or zero length"
argument_list|)
throw|;
block|}
if|if
condition|(
name|tableName
operator|.
name|equals
argument_list|(
name|TableName
operator|.
name|META_TABLE_NAME
argument_list|)
condition|)
block|{
return|return
name|this
operator|.
name|registry
operator|.
name|getMetaRegionLocation
argument_list|()
return|;
block|}
else|else
block|{
comment|// Region not in the cache - have to go to the meta RS
return|return
name|locateRegionInMeta
argument_list|(
name|TableName
operator|.
name|META_TABLE_NAME
argument_list|,
name|tableName
argument_list|,
name|row
argument_list|,
name|useCache
argument_list|,
name|userRegionLock
argument_list|,
name|retry
argument_list|)
return|;
block|}
block|}
comment|/*      * Search hbase:meta for the HRegionLocation info that contains the table and      * row we're seeking. It will prefetch certain number of regions info and      * save them to the global region cache.      */
specifier|private
name|void
name|prefetchRegionCache
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|)
block|{
comment|// Implement a new visitor for MetaScanner, and use it to walk through
comment|// the hbase:meta
name|MetaScannerVisitor
name|visitor
init|=
operator|new
name|MetaScannerVisitorBase
argument_list|()
block|{
specifier|public
name|boolean
name|processRow
parameter_list|(
name|Result
name|result
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|HRegionInfo
name|regionInfo
init|=
name|MetaScanner
operator|.
name|getHRegionInfo
argument_list|(
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionInfo
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// possible we got a region of a different table...
if|if
condition|(
operator|!
name|regionInfo
operator|.
name|getTable
argument_list|()
operator|.
name|equals
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
comment|// stop scanning
block|}
if|if
condition|(
name|regionInfo
operator|.
name|isOffline
argument_list|()
condition|)
block|{
comment|// don't cache offline regions
return|return
literal|true
return|;
block|}
name|ServerName
name|serverName
init|=
name|HRegionInfo
operator|.
name|getServerName
argument_list|(
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|serverName
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
comment|// don't cache it
block|}
comment|// instantiate the location
name|long
name|seqNum
init|=
name|HRegionInfo
operator|.
name|getSeqNumDuringOpen
argument_list|(
name|result
argument_list|)
decl_stmt|;
name|HRegionLocation
name|loc
init|=
operator|new
name|HRegionLocation
argument_list|(
name|regionInfo
argument_list|,
name|serverName
argument_list|,
name|seqNum
argument_list|)
decl_stmt|;
comment|// cache this meta entry
name|cacheLocation
argument_list|(
name|tableName
argument_list|,
literal|null
argument_list|,
name|loc
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
decl_stmt|;
try|try
block|{
comment|// pre-fetch certain number of regions info at region cache.
name|MetaScanner
operator|.
name|metaScan
argument_list|(
name|conf
argument_list|,
name|this
argument_list|,
name|visitor
argument_list|,
name|tableName
argument_list|,
name|row
argument_list|,
name|this
operator|.
name|prefetchRegionLimit
argument_list|,
name|TableName
operator|.
name|META_TABLE_NAME
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Encountered problems when prefetch hbase:meta table: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*       * Search the hbase:meta table for the HRegionLocation       * info that contains the table and row we're seeking.       */
specifier|private
name|HRegionLocation
name|locateRegionInMeta
parameter_list|(
specifier|final
name|TableName
name|parentTable
parameter_list|,
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|,
name|boolean
name|useCache
parameter_list|,
name|Object
name|regionLockObject
parameter_list|,
name|boolean
name|retry
parameter_list|)
throws|throws
name|IOException
block|{
name|HRegionLocation
name|location
decl_stmt|;
comment|// If we are supposed to be using the cache, look in the cache to see if
comment|// we already have the region.
if|if
condition|(
name|useCache
condition|)
block|{
name|location
operator|=
name|getCachedLocation
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
literal|null
condition|)
block|{
return|return
name|location
return|;
block|}
block|}
name|int
name|localNumRetries
init|=
name|retry
condition|?
name|numTries
else|:
literal|1
decl_stmt|;
comment|// build the key of the meta region we should be looking for.
comment|// the extra 9's on the end are necessary to allow "exact" matches
comment|// without knowing the precise region names.
name|byte
index|[]
name|metaKey
init|=
name|HRegionInfo
operator|.
name|createRegionName
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|,
name|HConstants
operator|.
name|NINES
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|tries
init|=
literal|0
init|;
literal|true
condition|;
name|tries
operator|++
control|)
block|{
if|if
condition|(
name|tries
operator|>=
name|localNumRetries
condition|)
block|{
throw|throw
operator|new
name|NoServerForRegionException
argument_list|(
literal|"Unable to find region for "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|row
argument_list|)
operator|+
literal|" after "
operator|+
name|numTries
operator|+
literal|" tries."
argument_list|)
throw|;
block|}
name|HRegionLocation
name|metaLocation
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// locate the meta region
name|metaLocation
operator|=
name|locateRegion
argument_list|(
name|parentTable
argument_list|,
name|metaKey
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// If null still, go around again.
if|if
condition|(
name|metaLocation
operator|==
literal|null
condition|)
continue|continue;
name|ClientService
operator|.
name|BlockingInterface
name|service
init|=
name|getClient
argument_list|(
name|metaLocation
operator|.
name|getServerName
argument_list|()
argument_list|)
decl_stmt|;
name|Result
name|regionInfoRow
decl_stmt|;
comment|// This block guards against two threads trying to load the meta
comment|// region at the same time. The first will load the meta region and
comment|// the second will use the value that the first one found.
if|if
condition|(
name|useCache
condition|)
block|{
if|if
condition|(
name|TableName
operator|.
name|META_TABLE_NAME
operator|.
name|equals
argument_list|(
name|parentTable
argument_list|)
operator|&&
name|getRegionCachePrefetch
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
synchronized|synchronized
init|(
name|regionLockObject
init|)
block|{
comment|// Check the cache again for a hit in case some other thread made the
comment|// same query while we were waiting on the lock.
name|location
operator|=
name|getCachedLocation
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
literal|null
condition|)
block|{
return|return
name|location
return|;
block|}
comment|// If the parent table is META, we may want to pre-fetch some
comment|// region info into the global region cache for this table.
name|prefetchRegionCache
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
block|}
name|location
operator|=
name|getCachedLocation
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
operator|!=
literal|null
condition|)
block|{
return|return
name|location
return|;
block|}
block|}
else|else
block|{
comment|// If we are not supposed to be using the cache, delete any existing cached location
comment|// so it won't interfere.
name|forceDeleteCachedLocation
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
comment|// Query the meta region for the location of the meta region
name|regionInfoRow
operator|=
name|ProtobufUtil
operator|.
name|getRowOrBefore
argument_list|(
name|service
argument_list|,
name|metaLocation
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionName
argument_list|()
argument_list|,
name|metaKey
argument_list|,
name|HConstants
operator|.
name|CATALOG_FAMILY
argument_list|)
expr_stmt|;
if|if
condition|(
name|regionInfoRow
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|TableNotFoundException
argument_list|(
name|tableName
argument_list|)
throw|;
block|}
comment|// convert the row result into the HRegionLocation we need!
name|HRegionInfo
name|regionInfo
init|=
name|MetaScanner
operator|.
name|getHRegionInfo
argument_list|(
name|regionInfoRow
argument_list|)
decl_stmt|;
if|if
condition|(
name|regionInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"HRegionInfo was null or empty in "
operator|+
name|parentTable
operator|+
literal|", row="
operator|+
name|regionInfoRow
argument_list|)
throw|;
block|}
comment|// possible we got a region of a different table...
if|if
condition|(
operator|!
name|regionInfo
operator|.
name|getTable
argument_list|()
operator|.
name|equals
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TableNotFoundException
argument_list|(
literal|"Table '"
operator|+
name|tableName
operator|+
literal|"' was not found, got: "
operator|+
name|regionInfo
operator|.
name|getTable
argument_list|()
operator|+
literal|"."
argument_list|)
throw|;
block|}
if|if
condition|(
name|regionInfo
operator|.
name|isSplit
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RegionOfflineException
argument_list|(
literal|"the only available region for"
operator|+
literal|" the required row is a split parent,"
operator|+
literal|" the daughters should be online soon: "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|regionInfo
operator|.
name|isOffline
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RegionOfflineException
argument_list|(
literal|"the region is offline, could"
operator|+
literal|" be caused by a disable table call: "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|)
throw|;
block|}
name|ServerName
name|serverName
init|=
name|HRegionInfo
operator|.
name|getServerName
argument_list|(
name|regionInfoRow
argument_list|)
decl_stmt|;
if|if
condition|(
name|serverName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoServerForRegionException
argument_list|(
literal|"No server address listed "
operator|+
literal|"in "
operator|+
name|parentTable
operator|+
literal|" for region "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" containing row "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|row
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|isDeadServer
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RegionServerStoppedException
argument_list|(
literal|"hbase:meta says the region "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" is managed by the server "
operator|+
name|serverName
operator|+
literal|", but it is dead."
argument_list|)
throw|;
block|}
comment|// Instantiate the location
name|location
operator|=
operator|new
name|HRegionLocation
argument_list|(
name|regionInfo
argument_list|,
name|serverName
argument_list|,
name|HRegionInfo
operator|.
name|getSeqNumDuringOpen
argument_list|(
name|regionInfoRow
argument_list|)
argument_list|)
expr_stmt|;
name|cacheLocation
argument_list|(
name|tableName
argument_list|,
literal|null
argument_list|,
name|location
argument_list|)
expr_stmt|;
return|return
name|location
return|;
block|}
catch|catch
parameter_list|(
name|TableNotFoundException
name|e
parameter_list|)
block|{
comment|// if we got this error, probably means the table just plain doesn't
comment|// exist. rethrow the error immediately. this should always be coming
comment|// from the HTable constructor.
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|RemoteException
condition|)
block|{
name|e
operator|=
operator|(
operator|(
name|RemoteException
operator|)
name|e
operator|)
operator|.
name|unwrapRemoteException
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|tries
operator|<
name|numTries
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"locateRegionInMeta parentTable="
operator|+
name|parentTable
operator|+
literal|", metaLocation="
operator|+
operator|(
operator|(
name|metaLocation
operator|==
literal|null
operator|)
condition|?
literal|"null"
else|:
literal|"{"
operator|+
name|metaLocation
operator|+
literal|"}"
operator|)
operator|+
literal|", attempt="
operator|+
name|tries
operator|+
literal|" of "
operator|+
name|this
operator|.
name|numTries
operator|+
literal|" failed; retrying after sleep of "
operator|+
name|ConnectionUtils
operator|.
name|getPauseTime
argument_list|(
name|this
operator|.
name|pause
argument_list|,
name|tries
argument_list|)
operator|+
literal|" because: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
comment|// Only relocate the parent region if necessary
if|if
condition|(
operator|!
operator|(
name|e
operator|instanceof
name|RegionOfflineException
operator|||
name|e
operator|instanceof
name|NoServerForRegionException
operator|)
condition|)
block|{
name|relocateRegion
argument_list|(
name|parentTable
argument_list|,
name|metaKey
argument_list|)
expr_stmt|;
block|}
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|ConnectionUtils
operator|.
name|getPauseTime
argument_list|(
name|this
operator|.
name|pause
argument_list|,
name|tries
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Giving up trying to location region in "
operator|+
literal|"meta: thread is interrupted."
argument_list|)
throw|;
block|}
block|}
block|}
comment|/*      * Search the cache for a location that fits our table and row key.      * Return null if no suitable region is located.      *      * @param tableName      * @param row      * @return Null or region location found in cache.      */
name|HRegionLocation
name|getCachedLocation
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|)
block|{
name|ConcurrentSkipListMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|tableLocations
init|=
name|getTableLocations
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|e
init|=
name|tableLocations
operator|.
name|floorEntry
argument_list|(
name|row
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|HRegionLocation
name|possibleRegion
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// make sure that the end key is greater than the row we're looking
comment|// for, otherwise the row actually belongs in the next region, not
comment|// this one. the exception case is when the endkey is
comment|// HConstants.EMPTY_END_ROW, signifying that the region we're
comment|// checking is actually the last region in the table.
name|byte
index|[]
name|endKey
init|=
name|possibleRegion
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getEndKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|endKey
argument_list|,
name|HConstants
operator|.
name|EMPTY_END_ROW
argument_list|)
operator|||
name|tableName
operator|.
name|getRowComparator
argument_list|()
operator|.
name|compareRows
argument_list|(
name|endKey
argument_list|,
literal|0
argument_list|,
name|endKey
operator|.
name|length
argument_list|,
name|row
argument_list|,
literal|0
argument_list|,
name|row
operator|.
name|length
argument_list|)
operator|>
literal|0
condition|)
block|{
return|return
name|possibleRegion
return|;
block|}
comment|// Passed all the way through, so we got nothing - complete cache miss
return|return
literal|null
return|;
block|}
comment|/**      * Delete a cached location, no matter what it is. Called when we were told to not use cache.      * @param tableName tableName      * @param row      */
name|void
name|forceDeleteCachedLocation
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|)
block|{
name|HRegionLocation
name|rl
init|=
literal|null
decl_stmt|;
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|tableLocations
init|=
name|getTableLocations
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
comment|// start to examine the cache. we can only do cache actions
comment|// if there's something in the cache for this table.
name|rl
operator|=
name|getCachedLocation
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|!=
literal|null
condition|)
block|{
name|tableLocations
operator|.
name|remove
argument_list|(
name|rl
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getStartKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rl
operator|!=
literal|null
operator|)
operator|&&
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removed "
operator|+
name|rl
operator|.
name|getHostname
argument_list|()
operator|+
literal|":"
operator|+
name|rl
operator|.
name|getPort
argument_list|()
operator|+
literal|" as a location of "
operator|+
name|rl
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" for tableName="
operator|+
name|tableName
operator|+
literal|" from cache"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Delete all cached entries of a table that maps to a specific location.      */
annotation|@
name|Override
specifier|public
name|void
name|clearCaches
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|cachedServers
operator|.
name|contains
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
return|return;
block|}
name|boolean
name|deletedSomething
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|cachedServers
init|)
block|{
comment|// We block here, because if there is an error on a server, it's likely that multiple
comment|//  threads will get the error  simultaneously. If there are hundreds of thousand of
comment|//  region location to check, it's better to do this only once. A better pattern would
comment|//  be to check if the server is dead when we get the region location.
if|if
condition|(
operator|!
name|this
operator|.
name|cachedServers
operator|.
name|contains
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
return|return;
block|}
for|for
control|(
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|tableLocations
range|:
name|cachedRegionLocations
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|e
range|:
name|tableLocations
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|HRegionLocation
name|value
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
name|serverName
operator|.
name|equals
argument_list|(
name|value
operator|.
name|getServerName
argument_list|()
argument_list|)
condition|)
block|{
name|tableLocations
operator|.
name|remove
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|deletedSomething
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
name|this
operator|.
name|cachedServers
operator|.
name|remove
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|deletedSomething
operator|&&
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removed all cached region locations that map to "
operator|+
name|serverName
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * @param tableName      * @return Map of cached locations for passed<code>tableName</code>      */
specifier|private
name|ConcurrentSkipListMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|getTableLocations
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
block|{
comment|// find the map of cached locations for this table
name|ConcurrentSkipListMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|result
decl_stmt|;
name|result
operator|=
name|this
operator|.
name|cachedRegionLocations
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
comment|// if tableLocations for this table isn't built yet, make one
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|result
operator|=
operator|new
name|ConcurrentSkipListMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
expr_stmt|;
name|ConcurrentSkipListMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|old
init|=
name|this
operator|.
name|cachedRegionLocations
operator|.
name|putIfAbsent
argument_list|(
name|tableName
argument_list|,
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
condition|)
block|{
return|return
name|old
return|;
block|}
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clearRegionCache
parameter_list|()
block|{
name|this
operator|.
name|cachedRegionLocations
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|cachedServers
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clearRegionCache
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
block|{
name|this
operator|.
name|cachedRegionLocations
operator|.
name|remove
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clearRegionCache
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
block|{
name|clearRegionCache
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Put a newly discovered HRegionLocation into the cache.      * @param tableName The table name.      * @param source the source of the new location, if it's not coming from meta      * @param location the new location      */
specifier|private
name|void
name|cacheLocation
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|HRegionLocation
name|source
parameter_list|,
specifier|final
name|HRegionLocation
name|location
parameter_list|)
block|{
name|boolean
name|isFromMeta
init|=
operator|(
name|source
operator|==
literal|null
operator|)
decl_stmt|;
name|byte
index|[]
name|startKey
init|=
name|location
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getStartKey
argument_list|()
decl_stmt|;
name|ConcurrentMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|tableLocations
init|=
name|getTableLocations
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|HRegionLocation
name|oldLocation
init|=
name|tableLocations
operator|.
name|putIfAbsent
argument_list|(
name|startKey
argument_list|,
name|location
argument_list|)
decl_stmt|;
name|boolean
name|isNewCacheEntry
init|=
operator|(
name|oldLocation
operator|==
literal|null
operator|)
decl_stmt|;
if|if
condition|(
name|isNewCacheEntry
condition|)
block|{
name|cachedServers
operator|.
name|add
argument_list|(
name|location
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|boolean
name|updateCache
decl_stmt|;
comment|// If the server in cache sends us a redirect, assume it's always valid.
if|if
condition|(
name|oldLocation
operator|.
name|equals
argument_list|(
name|source
argument_list|)
condition|)
block|{
name|updateCache
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|long
name|newLocationSeqNum
init|=
name|location
operator|.
name|getSeqNum
argument_list|()
decl_stmt|;
comment|// Meta record is stale - some (probably the same) server has closed the region
comment|// with later seqNum and told us about the new location.
name|boolean
name|isStaleMetaRecord
init|=
name|isFromMeta
operator|&&
operator|(
name|oldLocation
operator|.
name|getSeqNum
argument_list|()
operator|>
name|newLocationSeqNum
operator|)
decl_stmt|;
comment|// Same as above for redirect. However, in this case, if the number is equal to previous
comment|// record, the most common case is that first the region was closed with seqNum, and then
comment|// opened with the same seqNum; hence we will ignore the redirect.
comment|// There are so many corner cases with various combinations of opens and closes that
comment|// an additional counter on top of seqNum would be necessary to handle them all.
name|boolean
name|isStaleRedirect
init|=
operator|!
name|isFromMeta
operator|&&
operator|(
name|oldLocation
operator|.
name|getSeqNum
argument_list|()
operator|>=
name|newLocationSeqNum
operator|)
decl_stmt|;
name|boolean
name|isStaleUpdate
init|=
operator|(
name|isStaleMetaRecord
operator|||
name|isStaleRedirect
operator|)
decl_stmt|;
name|updateCache
operator|=
operator|(
operator|!
name|isStaleUpdate
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|updateCache
condition|)
block|{
name|tableLocations
operator|.
name|replace
argument_list|(
name|startKey
argument_list|,
name|oldLocation
argument_list|,
name|location
argument_list|)
expr_stmt|;
name|cachedServers
operator|.
name|add
argument_list|(
name|location
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Map keyed by service name + regionserver to service stub implementation
specifier|private
specifier|final
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|stubs
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
comment|// Map of locks used creating service stubs per regionserver.
specifier|private
specifier|final
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|connectionLock
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * State of the MasterService connection/setup.      */
specifier|static
class|class
name|MasterServiceState
block|{
name|HConnection
name|connection
decl_stmt|;
name|MasterService
operator|.
name|BlockingInterface
name|stub
decl_stmt|;
name|int
name|userCount
decl_stmt|;
name|long
name|keepAliveUntil
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
name|MasterServiceState
parameter_list|(
specifier|final
name|HConnection
name|connection
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|connection
operator|=
name|connection
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"MasterService"
return|;
block|}
name|Object
name|getStub
parameter_list|()
block|{
return|return
name|this
operator|.
name|stub
return|;
block|}
name|void
name|clearStub
parameter_list|()
block|{
name|this
operator|.
name|stub
operator|=
literal|null
expr_stmt|;
block|}
name|boolean
name|isMasterRunning
parameter_list|()
throws|throws
name|ServiceException
block|{
name|IsMasterRunningResponse
name|response
init|=
name|this
operator|.
name|stub
operator|.
name|isMasterRunning
argument_list|(
literal|null
argument_list|,
name|RequestConverter
operator|.
name|buildIsMasterRunningRequest
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|response
operator|!=
literal|null
condition|?
name|response
operator|.
name|getIsMasterRunning
argument_list|()
else|:
literal|false
return|;
block|}
block|}
comment|/**      * Makes a client-side stub for master services. Sub-class to specialize.      * Depends on hosting class so not static.  Exists so we avoid duplicating a bunch of code      * when setting up the MasterMonitorService and MasterAdminService.      */
specifier|abstract
class|class
name|StubMaker
block|{
comment|/**        * Returns the name of the service stub being created.        */
specifier|protected
specifier|abstract
name|String
name|getServiceName
parameter_list|()
function_decl|;
comment|/**        * Make stub and cache it internal so can be used later doing the isMasterRunning call.        * @param channel        */
specifier|protected
specifier|abstract
name|Object
name|makeStub
parameter_list|(
specifier|final
name|BlockingRpcChannel
name|channel
parameter_list|)
function_decl|;
comment|/**        * Once setup, check it works by doing isMasterRunning check.        * @throws ServiceException        */
specifier|protected
specifier|abstract
name|void
name|isMasterRunning
parameter_list|()
throws|throws
name|ServiceException
function_decl|;
comment|/**        * Create a stub. Try once only.  It is not typed because there is no common type to        * protobuf services nor their interfaces.  Let the caller do appropriate casting.        * @return A stub for master services.        * @throws IOException        * @throws KeeperException        * @throws ServiceException        */
specifier|private
name|Object
name|makeStubNoRetries
parameter_list|()
throws|throws
name|IOException
throws|,
name|KeeperException
throws|,
name|ServiceException
block|{
name|ZooKeeperKeepAliveConnection
name|zkw
decl_stmt|;
try|try
block|{
name|zkw
operator|=
name|getKeepAliveZooKeeperWatcher
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ZooKeeperConnectionException
argument_list|(
literal|"Can't connect to ZooKeeper"
argument_list|,
name|e
argument_list|)
throw|;
block|}
try|try
block|{
name|checkIfBaseNodeAvailable
argument_list|(
name|zkw
argument_list|)
expr_stmt|;
name|ServerName
name|sn
init|=
name|MasterAddressTracker
operator|.
name|getMasterAddress
argument_list|(
name|zkw
argument_list|)
decl_stmt|;
if|if
condition|(
name|sn
operator|==
literal|null
condition|)
block|{
name|String
name|msg
init|=
literal|"ZooKeeper available but no active master location found"
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MasterNotRunningException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
if|if
condition|(
name|isDeadServer
argument_list|(
name|sn
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|MasterNotRunningException
argument_list|(
name|sn
operator|+
literal|" is dead."
argument_list|)
throw|;
block|}
comment|// Use the security info interface name as our stub key
name|String
name|key
init|=
name|getStubKey
argument_list|(
name|getServiceName
argument_list|()
argument_list|,
name|sn
operator|.
name|getHostAndPort
argument_list|()
argument_list|)
decl_stmt|;
name|connectionLock
operator|.
name|putIfAbsent
argument_list|(
name|key
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|Object
name|stub
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|connectionLock
operator|.
name|get
argument_list|(
name|key
argument_list|)
init|)
block|{
name|stub
operator|=
name|stubs
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub
operator|==
literal|null
condition|)
block|{
name|BlockingRpcChannel
name|channel
init|=
name|rpcClient
operator|.
name|createBlockingRpcChannel
argument_list|(
name|sn
argument_list|,
name|user
argument_list|,
name|rpcTimeout
argument_list|)
decl_stmt|;
name|stub
operator|=
name|makeStub
argument_list|(
name|channel
argument_list|)
expr_stmt|;
name|isMasterRunning
argument_list|()
expr_stmt|;
name|stubs
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|stub
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|stub
return|;
block|}
finally|finally
block|{
name|zkw
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**        * Create a stub against the master.  Retry if necessary.        * @return A stub to do<code>intf</code> against the master        * @throws MasterNotRunningException        */
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
name|value
operator|=
literal|"SWL_SLEEP_WITH_LOCK_HELD"
argument_list|)
name|Object
name|makeStub
parameter_list|()
throws|throws
name|MasterNotRunningException
block|{
comment|// The lock must be at the beginning to prevent multiple master creations
comment|//  (and leaks) in a multithread context
synchronized|synchronized
init|(
name|masterAndZKLock
init|)
block|{
name|Exception
name|exceptionCaught
init|=
literal|null
decl_stmt|;
name|Object
name|stub
init|=
literal|null
decl_stmt|;
name|int
name|tries
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|closed
operator|&&
name|stub
operator|==
literal|null
condition|)
block|{
name|tries
operator|++
expr_stmt|;
try|try
block|{
name|stub
operator|=
name|makeStubNoRetries
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|exceptionCaught
operator|=
name|e
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|exceptionCaught
operator|=
name|e
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|e
parameter_list|)
block|{
name|exceptionCaught
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
name|exceptionCaught
operator|!=
literal|null
condition|)
comment|// It failed. If it's not the last try, we're going to wait a little
if|if
condition|(
name|tries
operator|<
name|numTries
condition|)
block|{
comment|// tries at this point is 1 or more; decrement to start from 0.
name|long
name|pauseTime
init|=
name|ConnectionUtils
operator|.
name|getPauseTime
argument_list|(
name|pause
argument_list|,
name|tries
operator|-
literal|1
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"getMaster attempt "
operator|+
name|tries
operator|+
literal|" of "
operator|+
name|numTries
operator|+
literal|" failed; retrying after sleep of "
operator|+
name|pauseTime
operator|+
literal|", exception="
operator|+
name|exceptionCaught
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|pauseTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Thread was interrupted while trying to connect to master."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// Enough tries, we stop now
name|LOG
operator|.
name|info
argument_list|(
literal|"getMaster attempt "
operator|+
name|tries
operator|+
literal|" of "
operator|+
name|numTries
operator|+
literal|" failed; no more retrying."
argument_list|,
name|exceptionCaught
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|MasterNotRunningException
argument_list|(
name|exceptionCaught
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|stub
operator|==
literal|null
condition|)
block|{
comment|// implies this.closed true
throw|throw
operator|new
name|MasterNotRunningException
argument_list|(
literal|"Connection was closed while trying to get master"
argument_list|)
throw|;
block|}
return|return
name|stub
return|;
block|}
block|}
block|}
comment|/**      * Class to make a MasterServiceStubMaker stub.      */
class|class
name|MasterServiceStubMaker
extends|extends
name|StubMaker
block|{
specifier|private
name|MasterService
operator|.
name|BlockingInterface
name|stub
decl_stmt|;
annotation|@
name|Override
specifier|protected
name|String
name|getServiceName
parameter_list|()
block|{
return|return
name|MasterService
operator|.
name|getDescriptor
argument_list|()
operator|.
name|getName
argument_list|()
return|;
block|}
annotation|@
name|Override
annotation|@
name|edu
operator|.
name|umd
operator|.
name|cs
operator|.
name|findbugs
operator|.
name|annotations
operator|.
name|SuppressWarnings
argument_list|(
literal|"SWL_SLEEP_WITH_LOCK_HELD"
argument_list|)
name|MasterService
operator|.
name|BlockingInterface
name|makeStub
parameter_list|()
throws|throws
name|MasterNotRunningException
block|{
return|return
operator|(
name|MasterService
operator|.
name|BlockingInterface
operator|)
name|super
operator|.
name|makeStub
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|protected
name|Object
name|makeStub
parameter_list|(
name|BlockingRpcChannel
name|channel
parameter_list|)
block|{
name|this
operator|.
name|stub
operator|=
name|MasterService
operator|.
name|newBlockingStub
argument_list|(
name|channel
argument_list|)
expr_stmt|;
return|return
name|this
operator|.
name|stub
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|isMasterRunning
parameter_list|()
throws|throws
name|ServiceException
block|{
name|this
operator|.
name|stub
operator|.
name|isMasterRunning
argument_list|(
literal|null
argument_list|,
name|RequestConverter
operator|.
name|buildIsMasterRunningRequest
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|AdminService
operator|.
name|BlockingInterface
name|getAdmin
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getAdmin
argument_list|(
name|serverName
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// Nothing is done w/ the 'master' parameter.  It is ignored.
specifier|public
name|AdminService
operator|.
name|BlockingInterface
name|getAdmin
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|,
specifier|final
name|boolean
name|master
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isDeadServer
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RegionServerStoppedException
argument_list|(
name|serverName
operator|+
literal|" is dead."
argument_list|)
throw|;
block|}
name|String
name|key
init|=
name|getStubKey
argument_list|(
name|AdminService
operator|.
name|BlockingInterface
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|,
name|serverName
operator|.
name|getHostAndPort
argument_list|()
argument_list|)
decl_stmt|;
name|this
operator|.
name|connectionLock
operator|.
name|putIfAbsent
argument_list|(
name|key
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|AdminService
operator|.
name|BlockingInterface
name|stub
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|connectionLock
operator|.
name|get
argument_list|(
name|key
argument_list|)
init|)
block|{
name|stub
operator|=
operator|(
name|AdminService
operator|.
name|BlockingInterface
operator|)
name|this
operator|.
name|stubs
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub
operator|==
literal|null
condition|)
block|{
name|BlockingRpcChannel
name|channel
init|=
name|this
operator|.
name|rpcClient
operator|.
name|createBlockingRpcChannel
argument_list|(
name|serverName
argument_list|,
name|user
argument_list|,
name|this
operator|.
name|rpcTimeout
argument_list|)
decl_stmt|;
name|stub
operator|=
name|AdminService
operator|.
name|newBlockingStub
argument_list|(
name|channel
argument_list|)
expr_stmt|;
name|this
operator|.
name|stubs
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|stub
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|stub
return|;
block|}
annotation|@
name|Override
specifier|public
name|ClientService
operator|.
name|BlockingInterface
name|getClient
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isDeadServer
argument_list|(
name|sn
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RegionServerStoppedException
argument_list|(
name|sn
operator|+
literal|" is dead."
argument_list|)
throw|;
block|}
name|String
name|key
init|=
name|getStubKey
argument_list|(
name|ClientService
operator|.
name|BlockingInterface
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|,
name|sn
operator|.
name|getHostAndPort
argument_list|()
argument_list|)
decl_stmt|;
name|this
operator|.
name|connectionLock
operator|.
name|putIfAbsent
argument_list|(
name|key
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|ClientService
operator|.
name|BlockingInterface
name|stub
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|connectionLock
operator|.
name|get
argument_list|(
name|key
argument_list|)
init|)
block|{
name|stub
operator|=
operator|(
name|ClientService
operator|.
name|BlockingInterface
operator|)
name|this
operator|.
name|stubs
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub
operator|==
literal|null
condition|)
block|{
name|BlockingRpcChannel
name|channel
init|=
name|this
operator|.
name|rpcClient
operator|.
name|createBlockingRpcChannel
argument_list|(
name|sn
argument_list|,
name|user
argument_list|,
name|this
operator|.
name|rpcTimeout
argument_list|)
decl_stmt|;
name|stub
operator|=
name|ClientService
operator|.
name|newBlockingStub
argument_list|(
name|channel
argument_list|)
expr_stmt|;
comment|// In old days, after getting stub/proxy, we'd make a call.  We are not doing that here.
comment|// Just fail on first actual call rather than in here on setup.
name|this
operator|.
name|stubs
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|stub
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|stub
return|;
block|}
specifier|static
name|String
name|getStubKey
parameter_list|(
specifier|final
name|String
name|serviceName
parameter_list|,
specifier|final
name|String
name|rsHostnamePort
parameter_list|)
block|{
return|return
name|serviceName
operator|+
literal|"@"
operator|+
name|rsHostnamePort
return|;
block|}
specifier|private
name|ZooKeeperKeepAliveConnection
name|keepAliveZookeeper
decl_stmt|;
specifier|private
name|int
name|keepAliveZookeeperUserCount
decl_stmt|;
specifier|private
name|boolean
name|canCloseZKW
init|=
literal|true
decl_stmt|;
comment|// keepAlive time, in ms. No reason to make it configurable.
specifier|private
specifier|static
specifier|final
name|long
name|keepAlive
init|=
literal|5
operator|*
literal|60
operator|*
literal|1000
decl_stmt|;
comment|/**      * Retrieve a shared ZooKeeperWatcher. You must close it it once you've have finished with it.      * @return The shared instance. Never returns null.      */
name|ZooKeeperKeepAliveConnection
name|getKeepAliveZooKeeperWatcher
parameter_list|()
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|masterAndZKLock
init|)
block|{
if|if
condition|(
name|keepAliveZookeeper
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|closed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|toString
argument_list|()
operator|+
literal|" closed"
argument_list|)
throw|;
block|}
comment|// We don't check that our link to ZooKeeper is still valid
comment|// But there is a retry mechanism in the ZooKeeperWatcher itself
name|keepAliveZookeeper
operator|=
operator|new
name|ZooKeeperKeepAliveConnection
argument_list|(
name|conf
argument_list|,
name|this
operator|.
name|toString
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
name|keepAliveZookeeperUserCount
operator|++
expr_stmt|;
name|keepZooKeeperWatcherAliveUntil
operator|=
name|Long
operator|.
name|MAX_VALUE
expr_stmt|;
return|return
name|keepAliveZookeeper
return|;
block|}
block|}
name|void
name|releaseZooKeeperWatcher
parameter_list|(
specifier|final
name|ZooKeeperWatcher
name|zkw
parameter_list|)
block|{
if|if
condition|(
name|zkw
operator|==
literal|null
condition|)
block|{
return|return;
block|}
synchronized|synchronized
init|(
name|masterAndZKLock
init|)
block|{
operator|--
name|keepAliveZookeeperUserCount
expr_stmt|;
if|if
condition|(
name|keepAliveZookeeperUserCount
operator|<=
literal|0
condition|)
block|{
name|keepZooKeeperWatcherAliveUntil
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|keepAlive
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Creates a Chore thread to check the connections to master& zookeeper      *  and close them when they reach their closing time (      *  {@link MasterServiceState#keepAliveUntil} and      *  {@link #keepZooKeeperWatcherAliveUntil}). Keep alive time is      *  managed by the release functions and the variable {@link #keepAlive}      */
specifier|private
specifier|static
class|class
name|DelayedClosing
extends|extends
name|Chore
implements|implements
name|Stoppable
block|{
specifier|private
name|HConnectionImplementation
name|hci
decl_stmt|;
name|Stoppable
name|stoppable
decl_stmt|;
specifier|private
name|DelayedClosing
parameter_list|(
name|HConnectionImplementation
name|hci
parameter_list|,
name|Stoppable
name|stoppable
parameter_list|)
block|{
name|super
argument_list|(
literal|"ZooKeeperWatcher and Master delayed closing for connection "
operator|+
name|hci
argument_list|,
literal|60
operator|*
literal|1000
argument_list|,
comment|// We check every minutes
name|stoppable
argument_list|)
expr_stmt|;
name|this
operator|.
name|hci
operator|=
name|hci
expr_stmt|;
name|this
operator|.
name|stoppable
operator|=
name|stoppable
expr_stmt|;
block|}
specifier|static
name|DelayedClosing
name|createAndStart
parameter_list|(
name|HConnectionImplementation
name|hci
parameter_list|)
block|{
name|Stoppable
name|stoppable
init|=
operator|new
name|Stoppable
argument_list|()
block|{
specifier|private
specifier|volatile
name|boolean
name|isStopped
init|=
literal|false
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|stop
parameter_list|(
name|String
name|why
parameter_list|)
block|{
name|isStopped
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isStopped
parameter_list|()
block|{
return|return
name|isStopped
return|;
block|}
block|}
decl_stmt|;
return|return
operator|new
name|DelayedClosing
argument_list|(
name|hci
argument_list|,
name|stoppable
argument_list|)
return|;
block|}
specifier|protected
name|void
name|closeMasterProtocol
parameter_list|(
name|MasterServiceState
name|protocolState
parameter_list|)
block|{
if|if
condition|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|>
name|protocolState
operator|.
name|keepAliveUntil
condition|)
block|{
name|hci
operator|.
name|closeMasterService
argument_list|(
name|protocolState
argument_list|)
expr_stmt|;
name|protocolState
operator|.
name|keepAliveUntil
operator|=
name|Long
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|void
name|chore
parameter_list|()
block|{
synchronized|synchronized
init|(
name|hci
operator|.
name|masterAndZKLock
init|)
block|{
if|if
condition|(
name|hci
operator|.
name|canCloseZKW
condition|)
block|{
if|if
condition|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|>
name|hci
operator|.
name|keepZooKeeperWatcherAliveUntil
condition|)
block|{
name|hci
operator|.
name|closeZooKeeperWatcher
argument_list|()
expr_stmt|;
name|hci
operator|.
name|keepZooKeeperWatcherAliveUntil
operator|=
name|Long
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
block|}
name|closeMasterProtocol
argument_list|(
name|hci
operator|.
name|masterServiceState
argument_list|)
expr_stmt|;
name|closeMasterProtocol
argument_list|(
name|hci
operator|.
name|masterServiceState
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|stop
parameter_list|(
name|String
name|why
parameter_list|)
block|{
name|stoppable
operator|.
name|stop
argument_list|(
name|why
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isStopped
parameter_list|()
block|{
return|return
name|stoppable
operator|.
name|isStopped
argument_list|()
return|;
block|}
block|}
specifier|private
name|void
name|closeZooKeeperWatcher
parameter_list|()
block|{
synchronized|synchronized
init|(
name|masterAndZKLock
init|)
block|{
if|if
condition|(
name|keepAliveZookeeper
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Closing zookeeper sessionid=0x"
operator|+
name|Long
operator|.
name|toHexString
argument_list|(
name|keepAliveZookeeper
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|getSessionId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|keepAliveZookeeper
operator|.
name|internalClose
argument_list|()
expr_stmt|;
name|keepAliveZookeeper
operator|=
literal|null
expr_stmt|;
block|}
name|keepAliveZookeeperUserCount
operator|=
literal|0
expr_stmt|;
block|}
block|}
specifier|final
name|MasterServiceState
name|masterServiceState
init|=
operator|new
name|MasterServiceState
argument_list|(
name|this
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|MasterService
operator|.
name|BlockingInterface
name|getMaster
parameter_list|()
throws|throws
name|MasterNotRunningException
block|{
return|return
name|getKeepAliveMasterService
argument_list|()
return|;
block|}
specifier|private
name|void
name|resetMasterServiceState
parameter_list|(
specifier|final
name|MasterServiceState
name|mss
parameter_list|)
block|{
name|mss
operator|.
name|userCount
operator|++
expr_stmt|;
name|mss
operator|.
name|keepAliveUntil
operator|=
name|Long
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|MasterKeepAliveConnection
name|getKeepAliveMasterService
parameter_list|()
throws|throws
name|MasterNotRunningException
block|{
synchronized|synchronized
init|(
name|masterAndZKLock
init|)
block|{
if|if
condition|(
operator|!
name|isKeepAliveMasterConnectedAndRunning
argument_list|(
name|this
operator|.
name|masterServiceState
argument_list|)
condition|)
block|{
name|MasterServiceStubMaker
name|stubMaker
init|=
operator|new
name|MasterServiceStubMaker
argument_list|()
decl_stmt|;
name|this
operator|.
name|masterServiceState
operator|.
name|stub
operator|=
name|stubMaker
operator|.
name|makeStub
argument_list|()
expr_stmt|;
block|}
name|resetMasterServiceState
argument_list|(
name|this
operator|.
name|masterServiceState
argument_list|)
expr_stmt|;
block|}
comment|// Ugly delegation just so we can add in a Close method.
specifier|final
name|MasterService
operator|.
name|BlockingInterface
name|stub
init|=
name|this
operator|.
name|masterServiceState
operator|.
name|stub
decl_stmt|;
return|return
operator|new
name|MasterKeepAliveConnection
argument_list|()
block|{
name|MasterServiceState
name|mss
init|=
name|masterServiceState
decl_stmt|;
annotation|@
name|Override
specifier|public
name|AddColumnResponse
name|addColumn
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|AddColumnRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|addColumn
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|DeleteColumnResponse
name|deleteColumn
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|DeleteColumnRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|deleteColumn
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|ModifyColumnResponse
name|modifyColumn
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|ModifyColumnRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|modifyColumn
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|MoveRegionResponse
name|moveRegion
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|MoveRegionRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|moveRegion
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|DispatchMergingRegionsResponse
name|dispatchMergingRegions
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|DispatchMergingRegionsRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|dispatchMergingRegions
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|AssignRegionResponse
name|assignRegion
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|AssignRegionRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|assignRegion
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|UnassignRegionResponse
name|unassignRegion
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|UnassignRegionRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|unassignRegion
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|OfflineRegionResponse
name|offlineRegion
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|OfflineRegionRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|offlineRegion
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|DeleteTableResponse
name|deleteTable
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|DeleteTableRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|deleteTable
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|EnableTableResponse
name|enableTable
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|EnableTableRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|enableTable
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|DisableTableResponse
name|disableTable
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|DisableTableRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|disableTable
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|ModifyTableResponse
name|modifyTable
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|ModifyTableRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|modifyTable
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|CreateTableResponse
name|createTable
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|CreateTableRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|createTable
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|ShutdownResponse
name|shutdown
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|ShutdownRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|shutdown
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|StopMasterResponse
name|stopMaster
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|StopMasterRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|stopMaster
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|BalanceResponse
name|balance
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|BalanceRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|balance
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|SetBalancerRunningResponse
name|setBalancerRunning
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|SetBalancerRunningRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|setBalancerRunning
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RunCatalogScanResponse
name|runCatalogScan
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|RunCatalogScanRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|runCatalogScan
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|EnableCatalogJanitorResponse
name|enableCatalogJanitor
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|EnableCatalogJanitorRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|enableCatalogJanitor
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|IsCatalogJanitorEnabledResponse
name|isCatalogJanitorEnabled
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|IsCatalogJanitorEnabledRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|isCatalogJanitorEnabled
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|CoprocessorServiceResponse
name|execMasterService
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|CoprocessorServiceRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|execMasterService
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|SnapshotResponse
name|snapshot
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|SnapshotRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|snapshot
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|GetCompletedSnapshotsResponse
name|getCompletedSnapshots
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|GetCompletedSnapshotsRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|getCompletedSnapshots
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|DeleteSnapshotResponse
name|deleteSnapshot
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|DeleteSnapshotRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|deleteSnapshot
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|IsSnapshotDoneResponse
name|isSnapshotDone
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|IsSnapshotDoneRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|isSnapshotDone
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RestoreSnapshotResponse
name|restoreSnapshot
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|RestoreSnapshotRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|restoreSnapshot
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|IsRestoreSnapshotDoneResponse
name|isRestoreSnapshotDone
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|IsRestoreSnapshotDoneRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|isRestoreSnapshotDone
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|ExecProcedureResponse
name|execProcedure
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|ExecProcedureRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|execProcedure
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|IsProcedureDoneResponse
name|isProcedureDone
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|IsProcedureDoneRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|isProcedureDone
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|IsMasterRunningResponse
name|isMasterRunning
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|IsMasterRunningRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|isMasterRunning
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|ModifyNamespaceResponse
name|modifyNamespace
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|ModifyNamespaceRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|modifyNamespace
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|CreateNamespaceResponse
name|createNamespace
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|CreateNamespaceRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|createNamespace
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|DeleteNamespaceResponse
name|deleteNamespace
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|DeleteNamespaceRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|deleteNamespace
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|GetNamespaceDescriptorResponse
name|getNamespaceDescriptor
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|GetNamespaceDescriptorRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|getNamespaceDescriptor
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|ListNamespaceDescriptorsResponse
name|listNamespaceDescriptors
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|ListNamespaceDescriptorsRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|listNamespaceDescriptors
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|ListTableDescriptorsByNamespaceResponse
name|listTableDescriptorsByNamespace
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|ListTableDescriptorsByNamespaceRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|listTableDescriptorsByNamespace
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|ListTableNamesByNamespaceResponse
name|listTableNamesByNamespace
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|ListTableNamesByNamespaceRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|listTableNamesByNamespace
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{
name|release
argument_list|(
name|this
operator|.
name|mss
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|GetSchemaAlterStatusResponse
name|getSchemaAlterStatus
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|GetSchemaAlterStatusRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|getSchemaAlterStatus
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|GetTableDescriptorsResponse
name|getTableDescriptors
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|GetTableDescriptorsRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|getTableDescriptors
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|GetTableNamesResponse
name|getTableNames
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|GetTableNamesRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|getTableNames
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|GetClusterStatusResponse
name|getClusterStatus
parameter_list|(
name|RpcController
name|controller
parameter_list|,
name|GetClusterStatusRequest
name|request
parameter_list|)
throws|throws
name|ServiceException
block|{
return|return
name|stub
operator|.
name|getClusterStatus
argument_list|(
name|controller
argument_list|,
name|request
argument_list|)
return|;
block|}
block|}
return|;
block|}
specifier|private
specifier|static
name|void
name|release
parameter_list|(
name|MasterServiceState
name|mss
parameter_list|)
block|{
if|if
condition|(
name|mss
operator|!=
literal|null
operator|&&
name|mss
operator|.
name|connection
operator|!=
literal|null
condition|)
block|{
operator|(
operator|(
name|HConnectionImplementation
operator|)
name|mss
operator|.
name|connection
operator|)
operator|.
name|releaseMaster
argument_list|(
name|mss
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|isKeepAliveMasterConnectedAndRunning
parameter_list|(
name|MasterServiceState
name|mss
parameter_list|)
block|{
if|if
condition|(
name|mss
operator|.
name|getStub
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
try|try
block|{
return|return
name|mss
operator|.
name|isMasterRunning
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|UndeclaredThrowableException
name|e
parameter_list|)
block|{
comment|// It's somehow messy, but we can receive exceptions such as
comment|//  java.net.ConnectException but they're not declared. So we catch it...
name|LOG
operator|.
name|info
argument_list|(
literal|"Master connection is not running anymore"
argument_list|,
name|e
operator|.
name|getUndeclaredThrowable
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Checking master connection"
argument_list|,
name|se
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|void
name|releaseMaster
parameter_list|(
name|MasterServiceState
name|mss
parameter_list|)
block|{
if|if
condition|(
name|mss
operator|.
name|getStub
argument_list|()
operator|==
literal|null
condition|)
return|return;
synchronized|synchronized
init|(
name|masterAndZKLock
init|)
block|{
operator|--
name|mss
operator|.
name|userCount
expr_stmt|;
if|if
condition|(
name|mss
operator|.
name|userCount
operator|<=
literal|0
condition|)
block|{
name|mss
operator|.
name|keepAliveUntil
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|keepAlive
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|closeMasterService
parameter_list|(
name|MasterServiceState
name|mss
parameter_list|)
block|{
if|if
condition|(
name|mss
operator|.
name|getStub
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Closing master protocol: "
operator|+
name|mss
argument_list|)
expr_stmt|;
name|mss
operator|.
name|clearStub
argument_list|()
expr_stmt|;
block|}
name|mss
operator|.
name|userCount
operator|=
literal|0
expr_stmt|;
block|}
comment|/**      * Immediate close of the shared master. Can be by the delayed close or when closing the      * connection itself.      */
specifier|private
name|void
name|closeMaster
parameter_list|()
block|{
synchronized|synchronized
init|(
name|masterAndZKLock
init|)
block|{
name|closeMasterService
argument_list|(
name|masterServiceState
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|updateCachedLocation
parameter_list|(
name|HRegionInfo
name|hri
parameter_list|,
name|HRegionLocation
name|source
parameter_list|,
name|ServerName
name|serverName
parameter_list|,
name|long
name|seqNum
parameter_list|)
block|{
name|HRegionLocation
name|newHrl
init|=
operator|new
name|HRegionLocation
argument_list|(
name|hri
argument_list|,
name|serverName
argument_list|,
name|seqNum
argument_list|)
decl_stmt|;
name|cacheLocation
argument_list|(
name|hri
operator|.
name|getTable
argument_list|()
argument_list|,
name|source
argument_list|,
name|newHrl
argument_list|)
expr_stmt|;
block|}
comment|/**     * Deletes the cached location of the region if necessary, based on some error from source.     * @param hri The region in question.     * @param source The source of the error that prompts us to invalidate cache.     */
name|void
name|deleteCachedLocation
parameter_list|(
name|HRegionInfo
name|hri
parameter_list|,
name|HRegionLocation
name|source
parameter_list|)
block|{
name|ConcurrentMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|tableLocations
init|=
name|getTableLocations
argument_list|(
name|hri
operator|.
name|getTable
argument_list|()
argument_list|)
decl_stmt|;
name|tableLocations
operator|.
name|remove
argument_list|(
name|hri
operator|.
name|getStartKey
argument_list|()
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|deleteCachedRegionLocation
parameter_list|(
specifier|final
name|HRegionLocation
name|location
parameter_list|)
block|{
if|if
condition|(
name|location
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|HRegionLocation
name|removedLocation
decl_stmt|;
name|TableName
name|tableName
init|=
name|location
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getTable
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|tableLocations
init|=
name|getTableLocations
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|removedLocation
operator|=
name|tableLocations
operator|.
name|remove
argument_list|(
name|location
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getStartKey
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
name|removedLocation
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removed "
operator|+
name|location
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" for tableName="
operator|+
name|tableName
operator|+
literal|" from cache"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Update the location with the new value (if the exception is a RegionMovedException)      * or delete it from the cache. Does nothing if we can be sure from the exception that      * the location is still accurate, or if the cache has already been updated.      * @param exception an object (to simplify user code) on which we will try to find a nested      *                  or wrapped or both RegionMovedException      * @param source server that is the source of the location update.      */
annotation|@
name|Override
specifier|public
name|void
name|updateCachedLocations
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
name|byte
index|[]
name|rowkey
parameter_list|,
specifier|final
name|Object
name|exception
parameter_list|,
specifier|final
name|HRegionLocation
name|source
parameter_list|)
block|{
if|if
condition|(
name|rowkey
operator|==
literal|null
operator|||
name|tableName
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Coding error, see method javadoc. row="
operator|+
operator|(
name|rowkey
operator|==
literal|null
condition|?
literal|"null"
else|:
name|rowkey
operator|)
operator|+
literal|", tableName="
operator|+
operator|(
name|tableName
operator|==
literal|null
condition|?
literal|"null"
else|:
name|tableName
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|source
operator|==
literal|null
operator|||
name|source
operator|.
name|getServerName
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// This should not happen, but let's secure ourselves.
return|return;
block|}
comment|// Is it something we have already updated?
specifier|final
name|HRegionLocation
name|oldLocation
init|=
name|getCachedLocation
argument_list|(
name|tableName
argument_list|,
name|rowkey
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldLocation
operator|==
literal|null
operator|||
operator|!
name|source
operator|.
name|getServerName
argument_list|()
operator|.
name|equals
argument_list|(
name|oldLocation
operator|.
name|getServerName
argument_list|()
argument_list|)
condition|)
block|{
comment|// There is no such location in the cache (it's been removed already) or
comment|// the cache has already been refreshed with a different location.  => nothing to do
return|return;
block|}
name|HRegionInfo
name|regionInfo
init|=
name|oldLocation
operator|.
name|getRegionInfo
argument_list|()
decl_stmt|;
name|Throwable
name|cause
init|=
name|findException
argument_list|(
name|exception
argument_list|)
decl_stmt|;
if|if
condition|(
name|cause
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|cause
operator|instanceof
name|RegionTooBusyException
operator|||
name|cause
operator|instanceof
name|RegionOpeningException
condition|)
block|{
comment|// We know that the region is still on this region server
return|return;
block|}
if|if
condition|(
name|cause
operator|instanceof
name|RegionMovedException
condition|)
block|{
name|RegionMovedException
name|rme
init|=
operator|(
name|RegionMovedException
operator|)
name|cause
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Region "
operator|+
name|regionInfo
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" moved to "
operator|+
name|rme
operator|.
name|getHostname
argument_list|()
operator|+
literal|":"
operator|+
name|rme
operator|.
name|getPort
argument_list|()
operator|+
literal|" according to "
operator|+
name|source
operator|.
name|getHostnamePort
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// We know that the region is not anymore on this region server, but we know
comment|//  the new location.
name|updateCachedLocation
argument_list|(
name|regionInfo
argument_list|,
name|source
argument_list|,
name|rme
operator|.
name|getServerName
argument_list|()
argument_list|,
name|rme
operator|.
name|getLocationSeqNum
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// If we're here, it means that can cannot be sure about the location, so we remove it from
comment|//  the cache.
name|deleteCachedLocation
argument_list|(
name|regionInfo
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|updateCachedLocations
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
name|byte
index|[]
name|rowkey
parameter_list|,
specifier|final
name|Object
name|exception
parameter_list|,
specifier|final
name|HRegionLocation
name|source
parameter_list|)
block|{
name|updateCachedLocations
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|rowkey
argument_list|,
name|exception
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
annotation|@
name|Deprecated
specifier|public
name|void
name|processBatch
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|Row
argument_list|>
name|list
parameter_list|,
specifier|final
name|TableName
name|tableName
parameter_list|,
name|ExecutorService
name|pool
parameter_list|,
name|Object
index|[]
name|results
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
comment|// This belongs in HTable!!! Not in here.  St.Ack
comment|// results must be the same size as list
if|if
condition|(
name|results
operator|.
name|length
operator|!=
name|list
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"argument results must be the same size as argument list"
argument_list|)
throw|;
block|}
name|processBatchCallback
argument_list|(
name|list
argument_list|,
name|tableName
argument_list|,
name|pool
argument_list|,
name|results
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
annotation|@
name|Deprecated
specifier|public
name|void
name|processBatch
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|Row
argument_list|>
name|list
parameter_list|,
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
name|ExecutorService
name|pool
parameter_list|,
name|Object
index|[]
name|results
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|processBatch
argument_list|(
name|list
argument_list|,
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|pool
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
comment|/**      * Send the queries in parallel on the different region servers. Retries on failures.      * If the method returns it means that there is no error, and the 'results' array will      * contain no exception. On error, an exception is thrown, and the 'results' array will      * contain results and exceptions.      * @deprecated since 0.96 - Use {@link HTable#processBatchCallback} instead      */
annotation|@
name|Override
annotation|@
name|Deprecated
specifier|public
parameter_list|<
name|R
parameter_list|>
name|void
name|processBatchCallback
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|Row
argument_list|>
name|list
parameter_list|,
name|TableName
name|tableName
parameter_list|,
name|ExecutorService
name|pool
parameter_list|,
name|Object
index|[]
name|results
parameter_list|,
name|Batch
operator|.
name|Callback
argument_list|<
name|R
argument_list|>
name|callback
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
comment|// To fulfill the original contract, we have a special callback. This callback
comment|//  will set the results in the Object array.
name|ObjectResultFiller
argument_list|<
name|R
argument_list|>
name|cb
init|=
operator|new
name|ObjectResultFiller
argument_list|<
name|R
argument_list|>
argument_list|(
name|results
argument_list|,
name|callback
argument_list|)
decl_stmt|;
name|AsyncProcess
argument_list|<
name|?
argument_list|>
name|asyncProcess
init|=
name|createAsyncProcess
argument_list|(
name|tableName
argument_list|,
name|pool
argument_list|,
name|cb
argument_list|,
name|conf
argument_list|)
decl_stmt|;
comment|// We're doing a submit all. This way, the originalIndex will match the initial list.
name|asyncProcess
operator|.
name|submitAll
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|asyncProcess
operator|.
name|waitUntilDone
argument_list|()
expr_stmt|;
if|if
condition|(
name|asyncProcess
operator|.
name|hasError
argument_list|()
condition|)
block|{
throw|throw
name|asyncProcess
operator|.
name|getErrors
argument_list|()
throw|;
block|}
block|}
annotation|@
name|Override
annotation|@
name|Deprecated
specifier|public
parameter_list|<
name|R
parameter_list|>
name|void
name|processBatchCallback
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|Row
argument_list|>
name|list
parameter_list|,
name|byte
index|[]
name|tableName
parameter_list|,
name|ExecutorService
name|pool
parameter_list|,
name|Object
index|[]
name|results
parameter_list|,
name|Batch
operator|.
name|Callback
argument_list|<
name|R
argument_list|>
name|callback
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|processBatchCallback
argument_list|(
name|list
argument_list|,
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|pool
argument_list|,
name|results
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
comment|// For tests.
specifier|protected
parameter_list|<
name|R
parameter_list|>
name|AsyncProcess
name|createAsyncProcess
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|ExecutorService
name|pool
parameter_list|,
name|AsyncProcess
operator|.
name|AsyncProcessCallback
argument_list|<
name|R
argument_list|>
name|callback
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
return|return
operator|new
name|AsyncProcess
argument_list|<
name|R
argument_list|>
argument_list|(
name|this
argument_list|,
name|tableName
argument_list|,
name|pool
argument_list|,
name|callback
argument_list|,
name|conf
argument_list|,
name|RpcRetryingCallerFactory
operator|.
name|instantiate
argument_list|(
name|conf
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Fill the result array for the interfaces using it.      */
specifier|private
specifier|static
class|class
name|ObjectResultFiller
parameter_list|<
name|Res
parameter_list|>
implements|implements
name|AsyncProcess
operator|.
name|AsyncProcessCallback
argument_list|<
name|Res
argument_list|>
block|{
specifier|private
specifier|final
name|Object
index|[]
name|results
decl_stmt|;
specifier|private
name|Batch
operator|.
name|Callback
argument_list|<
name|Res
argument_list|>
name|callback
decl_stmt|;
name|ObjectResultFiller
parameter_list|(
name|Object
index|[]
name|results
parameter_list|,
name|Batch
operator|.
name|Callback
argument_list|<
name|Res
argument_list|>
name|callback
parameter_list|)
block|{
name|this
operator|.
name|results
operator|=
name|results
expr_stmt|;
name|this
operator|.
name|callback
operator|=
name|callback
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|success
parameter_list|(
name|int
name|pos
parameter_list|,
name|byte
index|[]
name|region
parameter_list|,
name|Row
name|row
parameter_list|,
name|Res
name|result
parameter_list|)
block|{
assert|assert
name|pos
operator|<
name|results
operator|.
name|length
assert|;
name|results
index|[
name|pos
index|]
operator|=
name|result
expr_stmt|;
if|if
condition|(
name|callback
operator|!=
literal|null
condition|)
block|{
name|callback
operator|.
name|update
argument_list|(
name|region
argument_list|,
name|row
operator|.
name|getRow
argument_list|()
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|failure
parameter_list|(
name|int
name|pos
parameter_list|,
name|byte
index|[]
name|region
parameter_list|,
name|Row
name|row
parameter_list|,
name|Throwable
name|t
parameter_list|)
block|{
assert|assert
name|pos
operator|<
name|results
operator|.
name|length
assert|;
name|results
index|[
name|pos
index|]
operator|=
name|t
expr_stmt|;
comment|//Batch.Callback<Res> was not called on failure in 0.94. We keep this.
return|return
literal|true
return|;
comment|// we want to have this failure in the failures list.
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|retriableFailure
parameter_list|(
name|int
name|originalIndex
parameter_list|,
name|Row
name|row
parameter_list|,
name|byte
index|[]
name|region
parameter_list|,
name|Throwable
name|exception
parameter_list|)
block|{
return|return
literal|true
return|;
comment|// we retry
block|}
block|}
comment|/*      * Return the number of cached region for a table. It will only be called      * from a unit test.      */
name|int
name|getNumberOfCachedRegionLocations
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
block|{
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|HRegionLocation
argument_list|>
name|tableLocs
init|=
name|this
operator|.
name|cachedRegionLocations
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|tableLocs
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|tableLocs
operator|.
name|values
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Check the region cache to see whether a region is cached yet or not.      * Called by unit tests.      * @param tableName tableName      * @param row row      * @return Region cached or not.      */
name|boolean
name|isRegionCached
parameter_list|(
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|row
parameter_list|)
block|{
name|HRegionLocation
name|location
init|=
name|getCachedLocation
argument_list|(
name|tableName
argument_list|,
name|row
argument_list|)
decl_stmt|;
return|return
name|location
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setRegionCachePrefetch
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|boolean
name|enable
parameter_list|)
block|{
if|if
condition|(
operator|!
name|enable
condition|)
block|{
name|regionCachePrefetchDisabledTables
operator|.
name|add
argument_list|(
name|Bytes
operator|.
name|mapKey
argument_list|(
name|tableName
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|regionCachePrefetchDisabledTables
operator|.
name|remove
argument_list|(
name|Bytes
operator|.
name|mapKey
argument_list|(
name|tableName
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|setRegionCachePrefetch
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|boolean
name|enable
parameter_list|)
block|{
name|setRegionCachePrefetch
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|,
name|enable
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|getRegionCachePrefetch
parameter_list|(
name|TableName
name|tableName
parameter_list|)
block|{
return|return
operator|!
name|regionCachePrefetchDisabledTables
operator|.
name|contains
argument_list|(
name|Bytes
operator|.
name|mapKey
argument_list|(
name|tableName
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|getRegionCachePrefetch
parameter_list|(
name|byte
index|[]
name|tableName
parameter_list|)
block|{
return|return
name|getRegionCachePrefetch
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|abort
parameter_list|(
specifier|final
name|String
name|msg
parameter_list|,
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|KeeperException
operator|.
name|SessionExpiredException
operator|&&
name|keepAliveZookeeper
operator|!=
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|masterAndZKLock
init|)
block|{
if|if
condition|(
name|keepAliveZookeeper
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"This client just lost it's session with ZooKeeper,"
operator|+
literal|" closing it."
operator|+
literal|" It will be recreated next time someone needs it"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|closeZooKeeperWatcher
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
name|msg
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|fatal
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|aborted
operator|=
literal|true
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
name|this
operator|.
name|closed
operator|=
literal|true
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isClosed
parameter_list|()
block|{
return|return
name|this
operator|.
name|closed
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isAborted
parameter_list|()
block|{
return|return
name|this
operator|.
name|aborted
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getCurrentNrHRS
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|this
operator|.
name|registry
operator|.
name|getCurrentNrHRS
argument_list|()
return|;
block|}
comment|/**      * Increment this client's reference count.      */
name|void
name|incCount
parameter_list|()
block|{
operator|++
name|refCount
expr_stmt|;
block|}
comment|/**      * Decrement this client's reference count.      */
name|void
name|decCount
parameter_list|()
block|{
if|if
condition|(
name|refCount
operator|>
literal|0
condition|)
block|{
operator|--
name|refCount
expr_stmt|;
block|}
block|}
comment|/**      * Return if this client has no reference      *      * @return true if this client has no reference; false otherwise      */
name|boolean
name|isZeroReference
parameter_list|()
block|{
return|return
name|refCount
operator|==
literal|0
return|;
block|}
name|void
name|internalClose
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|closed
condition|)
block|{
return|return;
block|}
name|delayedClosing
operator|.
name|stop
argument_list|(
literal|"Closing connection"
argument_list|)
expr_stmt|;
name|closeMaster
argument_list|()
expr_stmt|;
name|shutdownBatchPool
argument_list|()
expr_stmt|;
name|this
operator|.
name|closed
operator|=
literal|true
expr_stmt|;
name|closeZooKeeperWatcher
argument_list|()
expr_stmt|;
name|this
operator|.
name|stubs
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|clusterStatusListener
operator|!=
literal|null
condition|)
block|{
name|clusterStatusListener
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|managed
condition|)
block|{
if|if
condition|(
name|aborted
condition|)
block|{
name|HConnectionManager
operator|.
name|deleteStaleConnection
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HConnectionManager
operator|.
name|deleteConnection
argument_list|(
name|this
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|internalClose
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Close the connection for good, regardless of what the current value of      * {@link #refCount} is. Ideally, {@link #refCount} should be zero at this      * point, which would be the case if all of its consumers close the      * connection. However, on the off chance that someone is unable to close      * the connection, perhaps because it bailed out prematurely, the method      * below will ensure that this {@link HConnection} instance is cleaned up.      * Caveat: The JVM may take an unknown amount of time to call finalize on an      * unreachable object, so our hope is that every consumer cleans up after      * itself, like any good citizen.      */
annotation|@
name|Override
specifier|protected
name|void
name|finalize
parameter_list|()
throws|throws
name|Throwable
block|{
name|super
operator|.
name|finalize
argument_list|()
expr_stmt|;
comment|// Pretend as if we are about to release the last remaining reference
name|refCount
operator|=
literal|1
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|HTableDescriptor
index|[]
name|listTables
parameter_list|()
throws|throws
name|IOException
block|{
name|MasterKeepAliveConnection
name|master
init|=
name|getKeepAliveMasterService
argument_list|()
decl_stmt|;
try|try
block|{
name|GetTableDescriptorsRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildGetTableDescriptorsRequest
argument_list|(
operator|(
name|List
argument_list|<
name|TableName
argument_list|>
operator|)
literal|null
argument_list|)
decl_stmt|;
return|return
name|ProtobufUtil
operator|.
name|getHTableDescriptorArray
argument_list|(
name|master
operator|.
name|getTableDescriptors
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
finally|finally
block|{
name|master
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
index|[]
name|getTableNames
parameter_list|()
throws|throws
name|IOException
block|{
name|TableName
index|[]
name|tableNames
init|=
name|listTableNames
argument_list|()
decl_stmt|;
name|String
name|result
index|[]
init|=
operator|new
name|String
index|[
name|tableNames
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tableNames
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|result
index|[
name|i
index|]
operator|=
name|tableNames
index|[
name|i
index|]
operator|.
name|getNameAsString
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|TableName
index|[]
name|listTableNames
parameter_list|()
throws|throws
name|IOException
block|{
name|MasterKeepAliveConnection
name|master
init|=
name|getKeepAliveMasterService
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|ProtobufUtil
operator|.
name|getTableNameArray
argument_list|(
name|master
operator|.
name|getTableNames
argument_list|(
literal|null
argument_list|,
name|GetTableNamesRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|build
argument_list|()
argument_list|)
operator|.
name|getTableNamesList
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
finally|finally
block|{
name|master
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|HTableDescriptor
index|[]
name|getHTableDescriptorsByTableName
parameter_list|(
name|List
argument_list|<
name|TableName
argument_list|>
name|tableNames
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|tableNames
operator|==
literal|null
operator|||
name|tableNames
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
operator|new
name|HTableDescriptor
index|[
literal|0
index|]
return|;
name|MasterKeepAliveConnection
name|master
init|=
name|getKeepAliveMasterService
argument_list|()
decl_stmt|;
try|try
block|{
name|GetTableDescriptorsRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildGetTableDescriptorsRequest
argument_list|(
name|tableNames
argument_list|)
decl_stmt|;
return|return
name|ProtobufUtil
operator|.
name|getHTableDescriptorArray
argument_list|(
name|master
operator|.
name|getTableDescriptors
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
finally|finally
block|{
name|master
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|HTableDescriptor
index|[]
name|getHTableDescriptors
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|names
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|TableName
argument_list|>
name|tableNames
init|=
operator|new
name|ArrayList
argument_list|(
name|names
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|names
control|)
block|{
name|tableNames
operator|.
name|add
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|getHTableDescriptorsByTableName
argument_list|(
name|tableNames
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|NonceGenerator
name|getNonceGenerator
parameter_list|()
block|{
return|return
name|this
operator|.
name|nonceGenerator
return|;
block|}
comment|/**      * Connects to the master to get the table descriptor.      * @param tableName table name      * @return      * @throws IOException if the connection to master fails or if the table      *  is not found.      */
annotation|@
name|Override
specifier|public
name|HTableDescriptor
name|getHTableDescriptor
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|tableName
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|tableName
operator|.
name|equals
argument_list|(
name|TableName
operator|.
name|META_TABLE_NAME
argument_list|)
condition|)
block|{
return|return
name|HTableDescriptor
operator|.
name|META_TABLEDESC
return|;
block|}
name|MasterKeepAliveConnection
name|master
init|=
name|getKeepAliveMasterService
argument_list|()
decl_stmt|;
name|GetTableDescriptorsResponse
name|htds
decl_stmt|;
try|try
block|{
name|GetTableDescriptorsRequest
name|req
init|=
name|RequestConverter
operator|.
name|buildGetTableDescriptorsRequest
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|htds
operator|=
name|master
operator|.
name|getTableDescriptors
argument_list|(
literal|null
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ServiceException
name|se
parameter_list|)
block|{
throw|throw
name|ProtobufUtil
operator|.
name|getRemoteException
argument_list|(
name|se
argument_list|)
throw|;
block|}
finally|finally
block|{
name|master
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|htds
operator|.
name|getTableSchemaList
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|HTableDescriptor
operator|.
name|convert
argument_list|(
name|htds
operator|.
name|getTableSchemaList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
throw|throw
operator|new
name|TableNotFoundException
argument_list|(
name|tableName
operator|.
name|getNameAsString
argument_list|()
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|HTableDescriptor
name|getHTableDescriptor
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getHTableDescriptor
argument_list|(
name|TableName
operator|.
name|valueOf
argument_list|(
name|tableName
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**    * The record of errors for servers.    */
specifier|static
class|class
name|ServerErrorTracker
block|{
comment|// We need a concurrent map here, as we could have multiple threads updating it in parallel.
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|HRegionLocation
argument_list|,
name|ServerErrors
argument_list|>
name|errorsByServer
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|HRegionLocation
argument_list|,
name|ServerErrors
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|long
name|canRetryUntil
decl_stmt|;
specifier|private
specifier|final
name|int
name|maxRetries
decl_stmt|;
specifier|private
specifier|final
name|String
name|startTrackingTime
decl_stmt|;
specifier|public
name|ServerErrorTracker
parameter_list|(
name|long
name|timeout
parameter_list|,
name|int
name|maxRetries
parameter_list|)
block|{
name|this
operator|.
name|maxRetries
operator|=
name|maxRetries
expr_stmt|;
name|this
operator|.
name|canRetryUntil
operator|=
name|EnvironmentEdgeManager
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|timeout
expr_stmt|;
name|this
operator|.
name|startTrackingTime
operator|=
operator|new
name|Date
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
comment|/**      * We stop to retry when we have exhausted BOTH the number of retries and the time allocated.      */
name|boolean
name|canRetryMore
parameter_list|(
name|int
name|numRetry
parameter_list|)
block|{
comment|// If there is a single try we must not take into account the time.
return|return
name|numRetry
operator|<
name|maxRetries
operator|||
operator|(
name|maxRetries
operator|>
literal|1
operator|&&
name|EnvironmentEdgeManager
operator|.
name|currentTimeMillis
argument_list|()
operator|<
name|this
operator|.
name|canRetryUntil
operator|)
return|;
block|}
comment|/**      * Calculates the back-off time for a retrying request to a particular server.      *      * @param server    The server in question.      * @param basePause The default hci pause.      * @return The time to wait before sending next request.      */
name|long
name|calculateBackoffTime
parameter_list|(
name|HRegionLocation
name|server
parameter_list|,
name|long
name|basePause
parameter_list|)
block|{
name|long
name|result
decl_stmt|;
name|ServerErrors
name|errorStats
init|=
name|errorsByServer
operator|.
name|get
argument_list|(
name|server
argument_list|)
decl_stmt|;
if|if
condition|(
name|errorStats
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
name|ConnectionUtils
operator|.
name|getPauseTime
argument_list|(
name|basePause
argument_list|,
name|errorStats
operator|.
name|retries
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
literal|0
expr_stmt|;
comment|// yes, if the server is not in our list we don't wait before retrying.
block|}
return|return
name|result
return|;
block|}
comment|/**      * Reports that there was an error on the server to do whatever bean-counting necessary.      *      * @param server The server in question.      */
name|void
name|reportServerError
parameter_list|(
name|HRegionLocation
name|server
parameter_list|)
block|{
name|ServerErrors
name|errors
init|=
name|errorsByServer
operator|.
name|get
argument_list|(
name|server
argument_list|)
decl_stmt|;
if|if
condition|(
name|errors
operator|!=
literal|null
condition|)
block|{
name|errors
operator|.
name|addError
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|errors
operator|=
name|errorsByServer
operator|.
name|putIfAbsent
argument_list|(
name|server
argument_list|,
operator|new
name|ServerErrors
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|errors
operator|!=
literal|null
condition|)
block|{
name|errors
operator|.
name|addError
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|String
name|getStartTrackingTime
parameter_list|()
block|{
return|return
name|startTrackingTime
return|;
block|}
comment|/**      * The record of errors for a server.      */
specifier|private
specifier|static
class|class
name|ServerErrors
block|{
specifier|public
specifier|final
name|AtomicInteger
name|retries
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|public
name|void
name|addError
parameter_list|()
block|{
name|retries
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Look for an exception we know in the remote exception:    * - hadoop.ipc wrapped exceptions    * - nested exceptions    *     * Looks for: RegionMovedException / RegionOpeningException / RegionTooBusyException    * @return null if we didn't find the exception, the exception otherwise.    */
specifier|public
specifier|static
name|Throwable
name|findException
parameter_list|(
name|Object
name|exception
parameter_list|)
block|{
if|if
condition|(
name|exception
operator|==
literal|null
operator|||
operator|!
operator|(
name|exception
operator|instanceof
name|Throwable
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Throwable
name|cur
init|=
operator|(
name|Throwable
operator|)
name|exception
decl_stmt|;
while|while
condition|(
name|cur
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|cur
operator|instanceof
name|RegionMovedException
operator|||
name|cur
operator|instanceof
name|RegionOpeningException
operator|||
name|cur
operator|instanceof
name|RegionTooBusyException
condition|)
block|{
return|return
name|cur
return|;
block|}
if|if
condition|(
name|cur
operator|instanceof
name|RemoteException
condition|)
block|{
name|RemoteException
name|re
init|=
operator|(
name|RemoteException
operator|)
name|cur
decl_stmt|;
name|cur
operator|=
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|RegionOpeningException
operator|.
name|class
argument_list|,
name|RegionMovedException
operator|.
name|class
argument_list|,
name|RegionTooBusyException
operator|.
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|==
literal|null
condition|)
block|{
name|cur
operator|=
name|re
operator|.
name|unwrapRemoteException
argument_list|()
expr_stmt|;
block|}
comment|// unwrapRemoteException can return the exception given as a parameter when it cannot
comment|//  unwrap it. In this case, there is no need to look further
comment|// noinspection ObjectEquality
if|if
condition|(
name|cur
operator|==
name|re
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
name|cur
operator|=
name|cur
operator|.
name|getCause
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Set the number of retries to use serverside when trying to communicate    * with another server over {@link HConnection}.  Used updating catalog    * tables, etc.  Call this method before we create any Connections.    * @param c The Configuration instance to set the retries into.    * @param log Used to log what we set in here.    */
specifier|public
specifier|static
name|void
name|setServerSideHConnectionRetries
parameter_list|(
specifier|final
name|Configuration
name|c
parameter_list|,
specifier|final
name|String
name|sn
parameter_list|,
specifier|final
name|Log
name|log
parameter_list|)
block|{
name|int
name|hcRetries
init|=
name|c
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_RETRIES_NUMBER
argument_list|,
name|HConstants
operator|.
name|DEFAULT_HBASE_CLIENT_RETRIES_NUMBER
argument_list|)
decl_stmt|;
comment|// Go big.  Multiply by 10.  If we can't get to meta after this many retries
comment|// then something seriously wrong.
name|int
name|serversideMultiplier
init|=
name|c
operator|.
name|getInt
argument_list|(
literal|"hbase.client.serverside.retries.multiplier"
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|int
name|retries
init|=
name|hcRetries
operator|*
name|serversideMultiplier
decl_stmt|;
name|c
operator|.
name|setInt
argument_list|(
name|HConstants
operator|.
name|HBASE_CLIENT_RETRIES_NUMBER
argument_list|,
name|retries
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
name|sn
operator|+
literal|" HConnection server-to-server retries="
operator|+
name|retries
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

