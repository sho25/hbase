begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|BufferOverflowException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Cell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellScannable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|PrivateCellUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValueUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_comment
comment|/**  * Single row result of a {@link Get} or {@link Scan} query.<p>  *  * This class is<b>NOT THREAD SAFE</b>.<p>  *  * Convenience methods are available that return various {@link Map}  * structures and values directly.<p>  *  * To get a complete mapping of all cells in the Result, which can include  * multiple families and multiple versions, use {@link #getMap()}.<p>  *  * To get a mapping of each family to its columns (qualifiers and values),  * including only the latest version of each, use {@link #getNoVersionMap()}.  *  * To get a mapping of qualifiers to latest values for an individual family use  * {@link #getFamilyMap(byte[])}.<p>  *  * To get the latest value for a specific family and qualifier use  * {@link #getValue(byte[], byte[])}.  *  * A Result is backed by an array of {@link Cell} objects, each representing  * an HBase cell defined by the row, family, qualifier, timestamp, and value.<p>  *  * The underlying {@link Cell} objects can be accessed through the method {@link #listCells()}.  * This will create a List from the internal Cell []. Better is to exploit the fact that  * a new Result instance is a primed {@link CellScanner}; just call {@link #advance()} and  * {@link #current()} to iterate over Cells as you would any {@link CellScanner}.  * Call {@link #cellScanner()} to reset should you need to iterate the same Result over again  * ({@link CellScanner}s are one-shot).  *  * If you need to overwrite a Result with another Result instance -- as in the old 'mapred'  * RecordReader next invocations -- then create an empty Result with the null constructor and  * in then use {@link #copyFrom(Result)}  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
specifier|public
class|class
name|Result
implements|implements
name|CellScannable
implements|,
name|CellScanner
block|{
specifier|private
name|Cell
index|[]
name|cells
decl_stmt|;
specifier|private
name|Boolean
name|exists
decl_stmt|;
comment|// if the query was just to check existence.
specifier|private
name|boolean
name|stale
init|=
literal|false
decl_stmt|;
comment|/**    * See {@link #mayHaveMoreCellsInRow()}.    */
specifier|private
name|boolean
name|mayHaveMoreCellsInRow
init|=
literal|false
decl_stmt|;
comment|// We're not using java serialization.  Transient here is just a marker to say
comment|// that this is where we cache row if we're ever asked for it.
specifier|private
specifier|transient
name|byte
index|[]
name|row
init|=
literal|null
decl_stmt|;
comment|// Ditto for familyMap.  It can be composed on fly from passed in kvs.
specifier|private
specifier|transient
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
argument_list|>
name|familyMap
init|=
literal|null
decl_stmt|;
specifier|private
specifier|static
name|ThreadLocal
argument_list|<
name|byte
index|[]
argument_list|>
name|localBuffer
init|=
operator|new
name|ThreadLocal
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|PAD_WIDTH
init|=
literal|128
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Result
name|EMPTY_RESULT
init|=
operator|new
name|Result
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|int
name|INITIAL_CELLSCANNER_INDEX
init|=
operator|-
literal|1
decl_stmt|;
comment|/**    * Index for where we are when Result is acting as a {@link CellScanner}.    */
specifier|private
name|int
name|cellScannerIndex
init|=
name|INITIAL_CELLSCANNER_INDEX
decl_stmt|;
specifier|private
name|RegionLoadStats
name|stats
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|readonly
decl_stmt|;
specifier|private
name|Cursor
name|cursor
init|=
literal|null
decl_stmt|;
comment|/**    * Creates an empty Result w/ no KeyValue payload; returns null if you call {@link #rawCells()}.    * Use this to represent no results if {@code null} won't do or in old 'mapred' as opposed    * to 'mapreduce' package MapReduce where you need to overwrite a Result instance with a    * {@link #copyFrom(Result)} call.    */
specifier|public
name|Result
parameter_list|()
block|{
name|this
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Allows to construct special purpose immutable Result objects,    * such as EMPTY_RESULT.    * @param readonly whether this Result instance is readonly    */
specifier|private
name|Result
parameter_list|(
name|boolean
name|readonly
parameter_list|)
block|{
name|this
operator|.
name|readonly
operator|=
name|readonly
expr_stmt|;
block|}
comment|/**    * Instantiate a Result with the specified List of KeyValues.    *<br><strong>Note:</strong> You must ensure that the keyvalues are already sorted.    * @param cells List of cells    */
specifier|public
specifier|static
name|Result
name|create
parameter_list|(
name|List
argument_list|<
name|Cell
argument_list|>
name|cells
parameter_list|)
block|{
return|return
name|create
argument_list|(
name|cells
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Result
name|create
parameter_list|(
name|List
argument_list|<
name|Cell
argument_list|>
name|cells
parameter_list|,
name|Boolean
name|exists
parameter_list|)
block|{
return|return
name|create
argument_list|(
name|cells
argument_list|,
name|exists
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Result
name|create
parameter_list|(
name|List
argument_list|<
name|Cell
argument_list|>
name|cells
parameter_list|,
name|Boolean
name|exists
parameter_list|,
name|boolean
name|stale
parameter_list|)
block|{
return|return
name|create
argument_list|(
name|cells
argument_list|,
name|exists
argument_list|,
name|stale
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Result
name|create
parameter_list|(
name|List
argument_list|<
name|Cell
argument_list|>
name|cells
parameter_list|,
name|Boolean
name|exists
parameter_list|,
name|boolean
name|stale
parameter_list|,
name|boolean
name|mayHaveMoreCellsInRow
parameter_list|)
block|{
if|if
condition|(
name|exists
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|Result
argument_list|(
literal|null
argument_list|,
name|exists
argument_list|,
name|stale
argument_list|,
name|mayHaveMoreCellsInRow
argument_list|)
return|;
block|}
return|return
operator|new
name|Result
argument_list|(
name|cells
operator|.
name|toArray
argument_list|(
operator|new
name|Cell
index|[
name|cells
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
literal|null
argument_list|,
name|stale
argument_list|,
name|mayHaveMoreCellsInRow
argument_list|)
return|;
block|}
comment|/**    * Instantiate a Result with the specified array of KeyValues.    *<br><strong>Note:</strong> You must ensure that the keyvalues are already sorted.    * @param cells array of cells    */
specifier|public
specifier|static
name|Result
name|create
parameter_list|(
name|Cell
index|[]
name|cells
parameter_list|)
block|{
return|return
name|create
argument_list|(
name|cells
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Result
name|create
parameter_list|(
name|Cell
index|[]
name|cells
parameter_list|,
name|Boolean
name|exists
parameter_list|,
name|boolean
name|stale
parameter_list|)
block|{
return|return
name|create
argument_list|(
name|cells
argument_list|,
name|exists
argument_list|,
name|stale
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Result
name|create
parameter_list|(
name|Cell
index|[]
name|cells
parameter_list|,
name|Boolean
name|exists
parameter_list|,
name|boolean
name|stale
parameter_list|,
name|boolean
name|mayHaveMoreCellsInRow
parameter_list|)
block|{
if|if
condition|(
name|exists
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|Result
argument_list|(
literal|null
argument_list|,
name|exists
argument_list|,
name|stale
argument_list|,
name|mayHaveMoreCellsInRow
argument_list|)
return|;
block|}
return|return
operator|new
name|Result
argument_list|(
name|cells
argument_list|,
literal|null
argument_list|,
name|stale
argument_list|,
name|mayHaveMoreCellsInRow
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Result
name|createCursorResult
parameter_list|(
name|Cursor
name|cursor
parameter_list|)
block|{
return|return
operator|new
name|Result
argument_list|(
name|cursor
argument_list|)
return|;
block|}
specifier|private
name|Result
parameter_list|(
name|Cursor
name|cursor
parameter_list|)
block|{
name|this
operator|.
name|cursor
operator|=
name|cursor
expr_stmt|;
name|this
operator|.
name|readonly
operator|=
literal|false
expr_stmt|;
block|}
comment|/** Private ctor. Use {@link #create(Cell[])}. */
specifier|private
name|Result
parameter_list|(
name|Cell
index|[]
name|cells
parameter_list|,
name|Boolean
name|exists
parameter_list|,
name|boolean
name|stale
parameter_list|,
name|boolean
name|mayHaveMoreCellsInRow
parameter_list|)
block|{
name|this
operator|.
name|cells
operator|=
name|cells
expr_stmt|;
name|this
operator|.
name|exists
operator|=
name|exists
expr_stmt|;
name|this
operator|.
name|stale
operator|=
name|stale
expr_stmt|;
name|this
operator|.
name|mayHaveMoreCellsInRow
operator|=
name|mayHaveMoreCellsInRow
expr_stmt|;
name|this
operator|.
name|readonly
operator|=
literal|false
expr_stmt|;
block|}
comment|/**    * Method for retrieving the row key that corresponds to    * the row from which this Result was created.    * @return row    */
specifier|public
name|byte
index|[]
name|getRow
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|row
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|row
operator|=
operator|(
name|this
operator|.
name|cells
operator|==
literal|null
operator|||
name|this
operator|.
name|cells
operator|.
name|length
operator|==
literal|0
operator|)
condition|?
literal|null
else|:
name|CellUtil
operator|.
name|cloneRow
argument_list|(
name|this
operator|.
name|cells
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|this
operator|.
name|row
return|;
block|}
comment|/**    * Return the array of Cells backing this Result instance.    *    * The array is sorted from smallest -&gt; largest using the    * {@link CellComparator}.    *    * The array only contains what your Get or Scan specifies and no more.    * For example if you request column "A" 1 version you will have at most 1    * Cell in the array. If you request column "A" with 2 version you will    * have at most 2 Cells, with the first one being the newer timestamp and    * the second being the older timestamp (this is the sort order defined by    * {@link CellComparator}).  If columns don't exist, they won't be    * present in the result. Therefore if you ask for 1 version all columns,    * it is safe to iterate over this array and expect to see 1 Cell for    * each column and no more.    *    * This API is faster than using getFamilyMap() and getMap()    *    * @return array of Cells; can be null if nothing in the result    */
specifier|public
name|Cell
index|[]
name|rawCells
parameter_list|()
block|{
return|return
name|cells
return|;
block|}
comment|/**    * Create a sorted list of the Cell's in this result.    *    * Since HBase 0.20.5 this is equivalent to raw().    *    * @return sorted List of Cells; can be null if no cells in the result    */
specifier|public
name|List
argument_list|<
name|Cell
argument_list|>
name|listCells
parameter_list|()
block|{
return|return
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|Arrays
operator|.
name|asList
argument_list|(
name|rawCells
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Return the Cells for the specific column.  The Cells are sorted in    * the {@link CellComparator} order.  That implies the first entry in    * the list is the most recent column.  If the query (Scan or Get) only    * requested 1 version the list will contain at most 1 entry.  If the column    * did not exist in the result set (either the column does not exist    * or the column was not selected in the query) the list will be empty.    *    * Also see getColumnLatest which returns just a Cell    *    * @param family the family    * @param qualifier    * @return a list of Cells for this column or empty list if the column    * did not exist in the result set    */
specifier|public
name|List
argument_list|<
name|Cell
argument_list|>
name|getColumnCells
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
name|List
argument_list|<
name|Cell
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Cell
index|[]
name|kvs
init|=
name|rawCells
argument_list|()
decl_stmt|;
if|if
condition|(
name|kvs
operator|==
literal|null
operator|||
name|kvs
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
name|int
name|pos
init|=
name|binarySearch
argument_list|(
name|kvs
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|result
return|;
comment|// cant find it
block|}
for|for
control|(
name|int
name|i
init|=
name|pos
init|;
name|i
operator|<
name|kvs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CellUtil
operator|.
name|matchingColumn
argument_list|(
name|kvs
index|[
name|i
index|]
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|)
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|kvs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
specifier|private
name|byte
index|[]
name|notNullBytes
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|)
block|{
if|if
condition|(
name|bytes
operator|==
literal|null
condition|)
block|{
return|return
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
return|;
block|}
else|else
block|{
return|return
name|bytes
return|;
block|}
block|}
specifier|protected
name|int
name|binarySearch
parameter_list|(
specifier|final
name|Cell
index|[]
name|kvs
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
name|byte
index|[]
name|familyNotNull
init|=
name|notNullBytes
argument_list|(
name|family
argument_list|)
decl_stmt|;
name|byte
index|[]
name|qualifierNotNull
init|=
name|notNullBytes
argument_list|(
name|qualifier
argument_list|)
decl_stmt|;
name|Cell
name|searchTerm
init|=
name|PrivateCellUtil
operator|.
name|createFirstOnRow
argument_list|(
name|kvs
index|[
literal|0
index|]
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|kvs
index|[
literal|0
index|]
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|kvs
index|[
literal|0
index|]
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|familyNotNull
argument_list|,
literal|0
argument_list|,
operator|(
name|byte
operator|)
name|familyNotNull
operator|.
name|length
argument_list|,
name|qualifierNotNull
argument_list|,
literal|0
argument_list|,
name|qualifierNotNull
operator|.
name|length
argument_list|)
decl_stmt|;
comment|// pos === ( -(insertion point) - 1)
name|int
name|pos
init|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|kvs
argument_list|,
name|searchTerm
argument_list|,
name|CellComparator
operator|.
name|getInstance
argument_list|()
argument_list|)
decl_stmt|;
comment|// never will exact match
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
name|pos
operator|=
operator|(
name|pos
operator|+
literal|1
operator|)
operator|*
operator|-
literal|1
expr_stmt|;
comment|// pos is now insertion point
block|}
if|if
condition|(
name|pos
operator|==
name|kvs
operator|.
name|length
condition|)
block|{
return|return
operator|-
literal|1
return|;
comment|// doesn't exist
block|}
return|return
name|pos
return|;
block|}
comment|/**    * Searches for the latest value for the specified column.    *    * @param kvs the array to search    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    *    * @return the index where the value was found, or -1 otherwise    */
specifier|protected
name|int
name|binarySearch
parameter_list|(
specifier|final
name|Cell
index|[]
name|kvs
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|int
name|foffset
parameter_list|,
specifier|final
name|int
name|flength
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|int
name|qoffset
parameter_list|,
specifier|final
name|int
name|qlength
parameter_list|)
block|{
name|double
name|keyValueSize
init|=
operator|(
name|double
operator|)
name|KeyValue
operator|.
name|getKeyValueDataStructureSize
argument_list|(
name|kvs
index|[
literal|0
index|]
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|flength
argument_list|,
name|qlength
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|byte
index|[]
name|buffer
init|=
name|localBuffer
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|buffer
operator|==
literal|null
operator|||
name|keyValueSize
operator|>
name|buffer
operator|.
name|length
condition|)
block|{
comment|// pad to the smallest multiple of the pad width
name|buffer
operator|=
operator|new
name|byte
index|[
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|keyValueSize
operator|/
name|PAD_WIDTH
argument_list|)
operator|*
name|PAD_WIDTH
index|]
expr_stmt|;
name|localBuffer
operator|.
name|set
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|Cell
name|searchTerm
init|=
name|KeyValueUtil
operator|.
name|createFirstOnRow
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|kvs
index|[
literal|0
index|]
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|kvs
index|[
literal|0
index|]
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|kvs
index|[
literal|0
index|]
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
decl_stmt|;
comment|// pos === ( -(insertion point) - 1)
name|int
name|pos
init|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|kvs
argument_list|,
name|searchTerm
argument_list|,
name|CellComparator
operator|.
name|getInstance
argument_list|()
argument_list|)
decl_stmt|;
comment|// never will exact match
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
name|pos
operator|=
operator|(
name|pos
operator|+
literal|1
operator|)
operator|*
operator|-
literal|1
expr_stmt|;
comment|// pos is now insertion point
block|}
if|if
condition|(
name|pos
operator|==
name|kvs
operator|.
name|length
condition|)
block|{
return|return
operator|-
literal|1
return|;
comment|// doesn't exist
block|}
return|return
name|pos
return|;
block|}
comment|/**    * The Cell for the most recent timestamp for a given column.    *    * @param family    * @param qualifier    *    * @return the Cell for the column, or null if no value exists in the row or none have been    * selected in the query (Get/Scan)    */
specifier|public
name|Cell
name|getColumnLatestCell
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
name|Cell
index|[]
name|kvs
init|=
name|rawCells
argument_list|()
decl_stmt|;
comment|// side effect possibly.
if|if
condition|(
name|kvs
operator|==
literal|null
operator|||
name|kvs
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|pos
init|=
name|binarySearch
argument_list|(
name|kvs
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|CellUtil
operator|.
name|matchingColumn
argument_list|(
name|kvs
index|[
name|pos
index|]
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|)
condition|)
block|{
return|return
name|kvs
index|[
name|pos
index|]
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * The Cell for the most recent timestamp for a given column.    *    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    *    * @return the Cell for the column, or null if no value exists in the row or none have been    * selected in the query (Get/Scan)    */
specifier|public
name|Cell
name|getColumnLatestCell
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|int
name|foffset
parameter_list|,
name|int
name|flength
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|int
name|qoffset
parameter_list|,
name|int
name|qlength
parameter_list|)
block|{
name|Cell
index|[]
name|kvs
init|=
name|rawCells
argument_list|()
decl_stmt|;
comment|// side effect possibly.
if|if
condition|(
name|kvs
operator|==
literal|null
operator|||
name|kvs
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|pos
init|=
name|binarySearch
argument_list|(
name|kvs
argument_list|,
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|PrivateCellUtil
operator|.
name|matchingColumn
argument_list|(
name|kvs
index|[
name|pos
index|]
argument_list|,
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
condition|)
block|{
return|return
name|kvs
index|[
name|pos
index|]
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Get the latest version of the specified column.    * Note: this call clones the value content of the hosting Cell. See    * {@link #getValueAsByteBuffer(byte[], byte[])}, etc., or {@link #listCells()} if you would    * avoid the cloning.    * @param family family name    * @param qualifier column qualifier    * @return value of latest version of column, null if none found    */
specifier|public
name|byte
index|[]
name|getValue
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
name|Cell
name|kv
init|=
name|getColumnLatestCell
argument_list|(
name|family
argument_list|,
name|qualifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|kv
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|CellUtil
operator|.
name|cloneValue
argument_list|(
name|kv
argument_list|)
return|;
block|}
comment|/**    * Returns the value wrapped in a new<code>ByteBuffer</code>.    *    * @param family family name    * @param qualifier column qualifier    *    * @return the latest version of the column, or<code>null</code> if none found    */
specifier|public
name|ByteBuffer
name|getValueAsByteBuffer
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
name|Cell
name|kv
init|=
name|getColumnLatestCell
argument_list|(
name|family
argument_list|,
literal|0
argument_list|,
name|family
operator|.
name|length
argument_list|,
name|qualifier
argument_list|,
literal|0
argument_list|,
name|qualifier
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|kv
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|kv
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|kv
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getValueLength
argument_list|()
argument_list|)
operator|.
name|asReadOnlyBuffer
argument_list|()
return|;
block|}
comment|/**    * Returns the value wrapped in a new<code>ByteBuffer</code>.    *    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    *    * @return the latest version of the column, or<code>null</code> if none found    */
specifier|public
name|ByteBuffer
name|getValueAsByteBuffer
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|int
name|foffset
parameter_list|,
name|int
name|flength
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|int
name|qoffset
parameter_list|,
name|int
name|qlength
parameter_list|)
block|{
name|Cell
name|kv
init|=
name|getColumnLatestCell
argument_list|(
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
decl_stmt|;
if|if
condition|(
name|kv
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|kv
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|kv
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getValueLength
argument_list|()
argument_list|)
operator|.
name|asReadOnlyBuffer
argument_list|()
return|;
block|}
comment|/**    * Loads the latest version of the specified column into the provided<code>ByteBuffer</code>.    *<p>    * Does not clear or flip the buffer.    *    * @param family family name    * @param qualifier column qualifier    * @param dst the buffer where to write the value    *    * @return<code>true</code> if a value was found,<code>false</code> otherwise    *    * @throws BufferOverflowException there is insufficient space remaining in the buffer    */
specifier|public
name|boolean
name|loadValue
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|ByteBuffer
name|dst
parameter_list|)
throws|throws
name|BufferOverflowException
block|{
return|return
name|loadValue
argument_list|(
name|family
argument_list|,
literal|0
argument_list|,
name|family
operator|.
name|length
argument_list|,
name|qualifier
argument_list|,
literal|0
argument_list|,
name|qualifier
operator|.
name|length
argument_list|,
name|dst
argument_list|)
return|;
block|}
comment|/**    * Loads the latest version of the specified column into the provided<code>ByteBuffer</code>.    *<p>    * Does not clear or flip the buffer.    *    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    * @param dst the buffer where to write the value    *    * @return<code>true</code> if a value was found,<code>false</code> otherwise    *    * @throws BufferOverflowException there is insufficient space remaining in the buffer    */
specifier|public
name|boolean
name|loadValue
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|int
name|foffset
parameter_list|,
name|int
name|flength
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|int
name|qoffset
parameter_list|,
name|int
name|qlength
parameter_list|,
name|ByteBuffer
name|dst
parameter_list|)
throws|throws
name|BufferOverflowException
block|{
name|Cell
name|kv
init|=
name|getColumnLatestCell
argument_list|(
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
decl_stmt|;
if|if
condition|(
name|kv
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|dst
operator|.
name|put
argument_list|(
name|kv
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|kv
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getValueLength
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Checks if the specified column contains a non-empty value (not a zero-length byte array).    *    * @param family family name    * @param qualifier column qualifier    *    * @return whether or not a latest value exists and is not empty    */
specifier|public
name|boolean
name|containsNonEmptyColumn
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
return|return
name|containsNonEmptyColumn
argument_list|(
name|family
argument_list|,
literal|0
argument_list|,
name|family
operator|.
name|length
argument_list|,
name|qualifier
argument_list|,
literal|0
argument_list|,
name|qualifier
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * Checks if the specified column contains a non-empty value (not a zero-length byte array).    *    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    *    * @return whether or not a latest value exists and is not empty    */
specifier|public
name|boolean
name|containsNonEmptyColumn
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|int
name|foffset
parameter_list|,
name|int
name|flength
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|int
name|qoffset
parameter_list|,
name|int
name|qlength
parameter_list|)
block|{
name|Cell
name|kv
init|=
name|getColumnLatestCell
argument_list|(
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
decl_stmt|;
return|return
operator|(
name|kv
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|kv
operator|.
name|getValueLength
argument_list|()
operator|>
literal|0
operator|)
return|;
block|}
comment|/**    * Checks if the specified column contains an empty value (a zero-length byte array).    *    * @param family family name    * @param qualifier column qualifier    *    * @return whether or not a latest value exists and is empty    */
specifier|public
name|boolean
name|containsEmptyColumn
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
return|return
name|containsEmptyColumn
argument_list|(
name|family
argument_list|,
literal|0
argument_list|,
name|family
operator|.
name|length
argument_list|,
name|qualifier
argument_list|,
literal|0
argument_list|,
name|qualifier
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * Checks if the specified column contains an empty value (a zero-length byte array).    *    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    *    * @return whether or not a latest value exists and is empty    */
specifier|public
name|boolean
name|containsEmptyColumn
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|int
name|foffset
parameter_list|,
name|int
name|flength
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|int
name|qoffset
parameter_list|,
name|int
name|qlength
parameter_list|)
block|{
name|Cell
name|kv
init|=
name|getColumnLatestCell
argument_list|(
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
decl_stmt|;
return|return
operator|(
name|kv
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|kv
operator|.
name|getValueLength
argument_list|()
operator|==
literal|0
operator|)
return|;
block|}
comment|/**    * Checks for existence of a value for the specified column (empty or not).    *    * @param family family name    * @param qualifier column qualifier    *    * @return true if at least one value exists in the result, false if not    */
specifier|public
name|boolean
name|containsColumn
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
name|Cell
name|kv
init|=
name|getColumnLatestCell
argument_list|(
name|family
argument_list|,
name|qualifier
argument_list|)
decl_stmt|;
return|return
name|kv
operator|!=
literal|null
return|;
block|}
comment|/**    * Checks for existence of a value for the specified column (empty or not).    *    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    *    * @return true if at least one value exists in the result, false if not    */
specifier|public
name|boolean
name|containsColumn
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|int
name|foffset
parameter_list|,
name|int
name|flength
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|int
name|qoffset
parameter_list|,
name|int
name|qlength
parameter_list|)
block|{
return|return
name|getColumnLatestCell
argument_list|(
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**    * Map of families to all versions of its qualifiers and values.    *<p>    * Returns a three level Map of the form:    *<code>Map&amp;family,Map&lt;qualifier,Map&lt;timestamp,value&gt;&gt;&gt;</code>    *<p>    * Note: All other map returning methods make use of this map internally.    * @return map from families to qualifiers to versions    */
specifier|public
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
argument_list|>
name|getMap
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|familyMap
operator|!=
literal|null
condition|)
block|{
return|return
name|this
operator|.
name|familyMap
return|;
block|}
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|this
operator|.
name|familyMap
operator|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
expr_stmt|;
for|for
control|(
name|Cell
name|kv
range|:
name|this
operator|.
name|cells
control|)
block|{
name|byte
index|[]
name|family
init|=
name|CellUtil
operator|.
name|cloneFamily
argument_list|(
name|kv
argument_list|)
decl_stmt|;
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|columnMap
init|=
name|familyMap
operator|.
name|get
argument_list|(
name|family
argument_list|)
decl_stmt|;
if|if
condition|(
name|columnMap
operator|==
literal|null
condition|)
block|{
name|columnMap
operator|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
expr_stmt|;
name|familyMap
operator|.
name|put
argument_list|(
name|family
argument_list|,
name|columnMap
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|qualifier
init|=
name|CellUtil
operator|.
name|cloneQualifier
argument_list|(
name|kv
argument_list|)
decl_stmt|;
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
name|versionMap
init|=
name|columnMap
operator|.
name|get
argument_list|(
name|qualifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|versionMap
operator|==
literal|null
condition|)
block|{
name|versionMap
operator|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
operator|new
name|Comparator
argument_list|<
name|Long
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Long
name|l1
parameter_list|,
name|Long
name|l2
parameter_list|)
block|{
return|return
name|l2
operator|.
name|compareTo
argument_list|(
name|l1
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|columnMap
operator|.
name|put
argument_list|(
name|qualifier
argument_list|,
name|versionMap
argument_list|)
expr_stmt|;
block|}
name|Long
name|timestamp
init|=
name|kv
operator|.
name|getTimestamp
argument_list|()
decl_stmt|;
name|byte
index|[]
name|value
init|=
name|CellUtil
operator|.
name|cloneValue
argument_list|(
name|kv
argument_list|)
decl_stmt|;
name|versionMap
operator|.
name|put
argument_list|(
name|timestamp
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|this
operator|.
name|familyMap
return|;
block|}
comment|/**    * Map of families to their most recent qualifiers and values.    *<p>    * Returns a two level Map of the form:<code>Map&amp;family,Map&lt;qualifier,value&gt;&gt;</code>    *<p>    * The most recent version of each qualifier will be used.    * @return map from families to qualifiers and value    */
specifier|public
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|getNoVersionMap
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|familyMap
operator|==
literal|null
condition|)
block|{
name|getMap
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|returnMap
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
argument_list|>
name|familyEntry
range|:
name|familyMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|qualifierMap
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|qualifierEntry
range|:
name|familyEntry
operator|.
name|getValue
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|byte
index|[]
name|value
init|=
name|qualifierEntry
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|(
name|qualifierEntry
operator|.
name|getValue
argument_list|()
operator|.
name|firstKey
argument_list|()
argument_list|)
decl_stmt|;
name|qualifierMap
operator|.
name|put
argument_list|(
name|qualifierEntry
operator|.
name|getKey
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|returnMap
operator|.
name|put
argument_list|(
name|familyEntry
operator|.
name|getKey
argument_list|()
argument_list|,
name|qualifierMap
argument_list|)
expr_stmt|;
block|}
return|return
name|returnMap
return|;
block|}
comment|/**    * Map of qualifiers to values.    *<p>    * Returns a Map of the form:<code>Map&lt;qualifier,value&gt;</code>    * @param family column family to get    * @return map of qualifiers to values    */
specifier|public
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|getFamilyMap
parameter_list|(
name|byte
index|[]
name|family
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|familyMap
operator|==
literal|null
condition|)
block|{
name|getMap
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|returnMap
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|qualifierMap
init|=
name|familyMap
operator|.
name|get
argument_list|(
name|family
argument_list|)
decl_stmt|;
if|if
condition|(
name|qualifierMap
operator|==
literal|null
condition|)
block|{
return|return
name|returnMap
return|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|entry
range|:
name|qualifierMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|byte
index|[]
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|firstKey
argument_list|()
argument_list|)
decl_stmt|;
name|returnMap
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|returnMap
return|;
block|}
comment|/**    * Returns the value of the first column in the Result.    * @return value of the first column    */
specifier|public
name|byte
index|[]
name|value
parameter_list|()
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|CellUtil
operator|.
name|cloneValue
argument_list|(
name|cells
index|[
literal|0
index|]
argument_list|)
return|;
block|}
comment|/**    * Check if the underlying Cell [] is empty or not    * @return true if empty    */
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|this
operator|.
name|cells
operator|==
literal|null
operator|||
name|this
operator|.
name|cells
operator|.
name|length
operator|==
literal|0
return|;
block|}
comment|/**    * @return the size of the underlying Cell []    */
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|this
operator|.
name|cells
operator|==
literal|null
condition|?
literal|0
else|:
name|this
operator|.
name|cells
operator|.
name|length
return|;
block|}
comment|/**    * @return String    */
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"keyvalues="
argument_list|)
expr_stmt|;
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"NONE"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|boolean
name|moreThanOne
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Cell
name|kv
range|:
name|this
operator|.
name|cells
control|)
block|{
if|if
condition|(
name|moreThanOne
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|moreThanOne
operator|=
literal|true
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|kv
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Does a deep comparison of two Results, down to the byte arrays.    * @param res1 first result to compare    * @param res2 second result to compare    * @throws Exception Every difference is throwing an exception    */
specifier|public
specifier|static
name|void
name|compareResults
parameter_list|(
name|Result
name|res1
parameter_list|,
name|Result
name|res2
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|res2
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
literal|"There wasn't enough rows, we stopped at "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|res1
operator|.
name|getRow
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|res1
operator|.
name|size
argument_list|()
operator|!=
name|res2
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
literal|"This row doesn't have the same number of KVs: "
operator|+
name|res1
operator|.
name|toString
argument_list|()
operator|+
literal|" compared to "
operator|+
name|res2
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
name|Cell
index|[]
name|ourKVs
init|=
name|res1
operator|.
name|rawCells
argument_list|()
decl_stmt|;
name|Cell
index|[]
name|replicatedKVs
init|=
name|res2
operator|.
name|rawCells
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|res1
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ourKVs
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
name|replicatedKVs
index|[
name|i
index|]
argument_list|)
operator|||
operator|!
name|CellUtil
operator|.
name|matchingValue
argument_list|(
name|ourKVs
index|[
name|i
index|]
argument_list|,
name|replicatedKVs
index|[
name|i
index|]
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
literal|"This result was different: "
operator|+
name|res1
operator|.
name|toString
argument_list|()
operator|+
literal|" compared to "
operator|+
name|res2
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Forms a single result from the partial results in the partialResults list. This method is    * useful for reconstructing partial results on the client side.    * @param partialResults list of partial results    * @return The complete result that is formed by combining all of the partial results together    * @throws IOException A complete result cannot be formed because the results in the partial list    *           come from different rows    */
specifier|public
specifier|static
name|Result
name|createCompleteResult
parameter_list|(
name|Iterable
argument_list|<
name|Result
argument_list|>
name|partialResults
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|partialResults
operator|==
literal|null
condition|)
block|{
return|return
name|Result
operator|.
name|create
argument_list|(
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|List
argument_list|<
name|Cell
argument_list|>
name|cells
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|boolean
name|stale
init|=
literal|false
decl_stmt|;
name|byte
index|[]
name|prevRow
init|=
literal|null
decl_stmt|;
name|byte
index|[]
name|currentRow
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|Result
argument_list|>
name|iter
init|=
name|partialResults
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Result
name|r
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|currentRow
operator|=
name|r
operator|.
name|getRow
argument_list|()
expr_stmt|;
if|if
condition|(
name|prevRow
operator|!=
literal|null
operator|&&
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|prevRow
argument_list|,
name|currentRow
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot form complete result. Rows of partial results do not match."
operator|+
literal|" Partial Results: "
operator|+
name|partialResults
argument_list|)
throw|;
block|}
comment|// Ensure that all Results except the last one are marked as partials. The last result
comment|// may not be marked as a partial because Results are only marked as partials when
comment|// the scan on the server side must be stopped due to reaching the maxResultSize.
comment|// Visualizing it makes it easier to understand:
comment|// maxResultSize: 2 cells
comment|// (-x-) represents cell number x in a row
comment|// Example: row1: -1- -2- -3- -4- -5- (5 cells total)
comment|// How row1 will be returned by the server as partial Results:
comment|// Result1: -1- -2- (2 cells, size limit reached, mark as partial)
comment|// Result2: -3- -4- (2 cells, size limit reached, mark as partial)
comment|// Result3: -5- (1 cell, size limit NOT reached, NOT marked as partial)
if|if
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
operator|&&
operator|!
name|r
operator|.
name|mayHaveMoreCellsInRow
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot form complete result. Result is missing partial flag. "
operator|+
literal|"Partial Results: "
operator|+
name|partialResults
argument_list|)
throw|;
block|}
name|prevRow
operator|=
name|currentRow
expr_stmt|;
name|stale
operator|=
name|stale
operator|||
name|r
operator|.
name|isStale
argument_list|()
expr_stmt|;
for|for
control|(
name|Cell
name|c
range|:
name|r
operator|.
name|rawCells
argument_list|()
control|)
block|{
name|cells
operator|.
name|add
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Result
operator|.
name|create
argument_list|(
name|cells
argument_list|,
literal|null
argument_list|,
name|stale
argument_list|)
return|;
block|}
comment|/**    * Get total size of raw cells    * @param result    * @return Total size.    */
specifier|public
specifier|static
name|long
name|getTotalSizeOfCells
parameter_list|(
name|Result
name|result
parameter_list|)
block|{
name|long
name|size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|size
return|;
block|}
for|for
control|(
name|Cell
name|c
range|:
name|result
operator|.
name|rawCells
argument_list|()
control|)
block|{
name|size
operator|+=
name|c
operator|.
name|heapSize
argument_list|()
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
comment|/**    * Copy another Result into this one. Needed for the old Mapred framework    * @throws UnsupportedOperationException if invoked on instance of EMPTY_RESULT    * (which is supposed to be immutable).    * @param other    */
specifier|public
name|void
name|copyFrom
parameter_list|(
name|Result
name|other
parameter_list|)
block|{
name|checkReadonly
argument_list|()
expr_stmt|;
name|this
operator|.
name|row
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|familyMap
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|cells
operator|=
name|other
operator|.
name|cells
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|CellScanner
name|cellScanner
parameter_list|()
block|{
comment|// Reset
name|this
operator|.
name|cellScannerIndex
operator|=
name|INITIAL_CELLSCANNER_INDEX
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|Cell
name|current
parameter_list|()
block|{
if|if
condition|(
name|cells
operator|==
literal|null
operator|||
name|cellScannerIndex
operator|==
name|INITIAL_CELLSCANNER_INDEX
operator|||
name|cellScannerIndex
operator|>=
name|cells
operator|.
name|length
condition|)
return|return
literal|null
return|;
return|return
name|this
operator|.
name|cells
index|[
name|cellScannerIndex
index|]
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|advance
parameter_list|()
block|{
if|if
condition|(
name|cells
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|cellScannerIndex
operator|++
expr_stmt|;
if|if
condition|(
name|cellScannerIndex
operator|<
name|this
operator|.
name|cells
operator|.
name|length
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|cellScannerIndex
operator|==
name|this
operator|.
name|cells
operator|.
name|length
condition|)
block|{
return|return
literal|false
return|;
block|}
throw|throw
operator|new
name|NoSuchElementException
argument_list|(
literal|"Cannot advance beyond the last cell"
argument_list|)
throw|;
block|}
specifier|public
name|Boolean
name|getExists
parameter_list|()
block|{
return|return
name|exists
return|;
block|}
specifier|public
name|void
name|setExists
parameter_list|(
name|Boolean
name|exists
parameter_list|)
block|{
name|checkReadonly
argument_list|()
expr_stmt|;
name|this
operator|.
name|exists
operator|=
name|exists
expr_stmt|;
block|}
comment|/**    * Whether or not the results are coming from possibly stale data. Stale results    * might be returned if {@link Consistency} is not STRONG for the query.    * @return Whether or not the results are coming from possibly stale data.    */
specifier|public
name|boolean
name|isStale
parameter_list|()
block|{
return|return
name|stale
return|;
block|}
comment|/**    * For scanning large rows, the RS may choose to return the cells chunk by chunk to prevent OOM    * or timeout. This flag is used to tell you if the current Result is the last one of the current    * row. False means this Result is the last one. True means there MAY be more cells belonging to    * the current row.    * If you don't use {@link Scan#setAllowPartialResults(boolean)} or {@link Scan#setBatch(int)},    * this method will always return false because the Result must contains all cells in one Row.    */
specifier|public
name|boolean
name|mayHaveMoreCellsInRow
parameter_list|()
block|{
return|return
name|mayHaveMoreCellsInRow
return|;
block|}
comment|/**    * Set load information about the region to the information about the result    * @param loadStats statistics about the current region from which this was returned    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
name|void
name|setStatistics
parameter_list|(
name|RegionLoadStats
name|loadStats
parameter_list|)
block|{
name|this
operator|.
name|stats
operator|=
name|loadStats
expr_stmt|;
block|}
comment|/**    * @return the associated statistics about the region from which this was returned. Can be    *<tt>null</tt> if stats are disabled.    */
specifier|public
name|RegionLoadStats
name|getStats
parameter_list|()
block|{
return|return
name|stats
return|;
block|}
comment|/**    * All methods modifying state of Result object must call this method    * to ensure that special purpose immutable Results can't be accidentally modified.    */
specifier|private
name|void
name|checkReadonly
parameter_list|()
block|{
if|if
condition|(
name|readonly
operator|==
literal|true
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Attempting to modify readonly EMPTY_RESULT!"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Return true if this Result is a cursor to tell users where the server has scanned.    * In this Result the only meaningful method is {@link #getCursor()}.    *    * {@code    *  while (r = scanner.next()&& r != null) {    *    if(r.isCursor()){    *    // scanning is not end, it is a cursor, save its row key and close scanner if you want, or    *    // just continue the loop to call next().    *    } else {    *    // just like before    *    }    *  }    *  // scanning is end    *    * }    * {@link Scan#setNeedCursorResult(boolean)}    * {@link Cursor}    * {@link #getCursor()}    */
specifier|public
name|boolean
name|isCursor
parameter_list|()
block|{
return|return
name|cursor
operator|!=
literal|null
return|;
block|}
comment|/**    * Return the cursor if this Result is a cursor result.    * {@link Scan#setNeedCursorResult(boolean)}    * {@link Cursor}    * {@link #isCursor()}    */
specifier|public
name|Cursor
name|getCursor
parameter_list|()
block|{
return|return
name|cursor
return|;
block|}
block|}
end_class

end_unit

