begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
package|;
end_package

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|BufferOverflowException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Cell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellScannable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValueUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_comment
comment|/**  * Single row result of a {@link Get} or {@link Scan} query.<p>  *  * This class is<b>NOT THREAD SAFE</b>.<p>  *  * Convenience methods are available that return various {@link Map}  * structures and values directly.<p>  *  * To get a complete mapping of all cells in the Result, which can include  * multiple families and multiple versions, use {@link #getMap()}.<p>  *  * To get a mapping of each family to its columns (qualifiers and values),  * including only the latest version of each, use {@link #getNoVersionMap()}.  *  * To get a mapping of qualifiers to latest values for an individual family use  * {@link #getFamilyMap(byte[])}.<p>  *  * To get the latest value for a specific family and qualifier use {@link #getValue(byte[], byte[])}.  *  * A Result is backed by an array of {@link KeyValue} objects, each representing  * an HBase cell defined by the row, family, qualifier, timestamp, and value.<p>  *  * The underlying {@link KeyValue} objects can be accessed through the method {@link #listCells()}.  * Each KeyValue can then be accessed through  * {@link KeyValue#getRow()}, {@link KeyValue#getFamily()}, {@link KeyValue#getQualifier()},  * {@link KeyValue#getTimestamp()}, and {@link KeyValue#getValue()}.<p>  *  * If you need to overwrite a Result with another Result instance -- as in the old 'mapred' RecordReader next  * invocations -- then create an empty Result with the null constructor and in then use {@link #copyFrom(Result)}  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Stable
specifier|public
class|class
name|Result
implements|implements
name|CellScannable
block|{
specifier|private
name|Cell
index|[]
name|cells
decl_stmt|;
specifier|private
name|Boolean
name|exists
decl_stmt|;
comment|// if the query was just to check existence.
comment|// We're not using java serialization.  Transient here is just a marker to say
comment|// that this is where we cache row if we're ever asked for it.
specifier|private
specifier|transient
name|byte
index|[]
name|row
init|=
literal|null
decl_stmt|;
comment|// Ditto for familyMap.  It can be composed on fly from passed in kvs.
specifier|private
specifier|transient
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
argument_list|>
name|familyMap
init|=
literal|null
decl_stmt|;
comment|// never use directly
specifier|private
specifier|static
name|byte
index|[]
name|buffer
init|=
literal|null
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|PAD_WIDTH
init|=
literal|128
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Result
name|EMPTY_RESULT
init|=
operator|new
name|Result
argument_list|()
decl_stmt|;
comment|/**    * Creates an empty Result w/ no KeyValue payload; returns null if you call {@link #rawCells()}.    * Use this to represent no results if<code>null</code> won't do or in old 'mapred' as oppposed to 'mapreduce' package    * MapReduce where you need to overwrite a Result    * instance with a {@link #copyFrom(Result)} call.    */
specifier|public
name|Result
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
comment|/**    * @deprecated Use {@link #create(List)} instead.    */
annotation|@
name|Deprecated
specifier|public
name|Result
parameter_list|(
name|KeyValue
index|[]
name|cells
parameter_list|)
block|{
name|this
operator|.
name|cells
operator|=
name|cells
expr_stmt|;
block|}
comment|/**    * @deprecated Use {@link #create(List)} instead.    */
annotation|@
name|Deprecated
specifier|public
name|Result
parameter_list|(
name|List
argument_list|<
name|KeyValue
argument_list|>
name|kvs
parameter_list|)
block|{
comment|// TODO: Here we presume the passed in Cells are KVs.  One day this won't always be so.
name|this
argument_list|(
name|kvs
operator|.
name|toArray
argument_list|(
operator|new
name|Cell
index|[
name|kvs
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Instantiate a Result with the specified List of KeyValues.    *<br><strong>Note:</strong> You must ensure that the keyvalues are already sorted.    * @param cells List of cells    */
specifier|public
specifier|static
name|Result
name|create
parameter_list|(
name|List
argument_list|<
name|Cell
argument_list|>
name|cells
parameter_list|)
block|{
return|return
operator|new
name|Result
argument_list|(
name|cells
operator|.
name|toArray
argument_list|(
operator|new
name|Cell
index|[
name|cells
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Result
name|create
parameter_list|(
name|List
argument_list|<
name|Cell
argument_list|>
name|cells
parameter_list|,
name|Boolean
name|exists
parameter_list|)
block|{
if|if
condition|(
name|exists
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|Result
argument_list|(
literal|null
argument_list|,
name|exists
argument_list|)
return|;
block|}
return|return
operator|new
name|Result
argument_list|(
name|cells
operator|.
name|toArray
argument_list|(
operator|new
name|Cell
index|[
name|cells
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Instantiate a Result with the specified array of KeyValues.    *<br><strong>Note:</strong> You must ensure that the keyvalues are already sorted.    * @param cells array of cells    */
specifier|public
specifier|static
name|Result
name|create
parameter_list|(
name|Cell
index|[]
name|cells
parameter_list|)
block|{
return|return
operator|new
name|Result
argument_list|(
name|cells
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Private ctor. Use {@link #create(Cell[])}. */
specifier|private
name|Result
parameter_list|(
name|Cell
index|[]
name|cells
parameter_list|,
name|Boolean
name|exists
parameter_list|)
block|{
name|this
operator|.
name|cells
operator|=
name|cells
expr_stmt|;
name|this
operator|.
name|exists
operator|=
name|exists
expr_stmt|;
block|}
comment|/**    * Method for retrieving the row key that corresponds to    * the row from which this Result was created.    * @return row    */
specifier|public
name|byte
index|[]
name|getRow
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|row
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|row
operator|=
name|this
operator|.
name|cells
operator|==
literal|null
operator|||
name|this
operator|.
name|cells
operator|.
name|length
operator|==
literal|0
condition|?
literal|null
else|:
name|CellUtil
operator|.
name|cloneRow
argument_list|(
name|this
operator|.
name|cells
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|this
operator|.
name|row
return|;
block|}
comment|/**    * Return the array of Cells backing this Result instance.    *    * The array is sorted from smallest -> largest using the    * {@link KeyValue#COMPARATOR}.    *    * The array only contains what your Get or Scan specifies and no more.    * For example if you request column "A" 1 version you will have at most 1    * Cell in the array. If you request column "A" with 2 version you will    * have at most 2 Cells, with the first one being the newer timestamp and    * the second being the older timestamp (this is the sort order defined by    * {@link KeyValue#COMPARATOR}).  If columns don't exist, they won't be    * present in the result. Therefore if you ask for 1 version all columns,    * it is safe to iterate over this array and expect to see 1 Cell for    * each column and no more.    *    * This API is faster than using getFamilyMap() and getMap()    *    * @return array of Cells; can be null if nothing in the result    */
specifier|public
name|Cell
index|[]
name|rawCells
parameter_list|()
block|{
return|return
name|cells
return|;
block|}
comment|/**    * Return an cells of a Result as an array of KeyValues     *     * WARNING do not use, expensive.  This does an arraycopy of the cell[]'s value.    *    * Added to ease transition from  0.94 -> 0.96.    *     * @deprecated as of 0.96, use {@link #rawCells()}      * @return array of KeyValues, empty array if nothing in result.    */
annotation|@
name|Deprecated
specifier|public
name|KeyValue
index|[]
name|raw
parameter_list|()
block|{
name|KeyValue
index|[]
name|kvs
init|=
operator|new
name|KeyValue
index|[
name|cells
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|kvs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|kvs
index|[
name|i
index|]
operator|=
name|KeyValueUtil
operator|.
name|ensureKeyValue
argument_list|(
name|cells
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|kvs
return|;
block|}
comment|/**    * Create a sorted list of the Cell's in this result.    *    * Since HBase 0.20.5 this is equivalent to raw().    *    * @return sorted List of Cells; can be null if no cells in the result    */
specifier|public
name|List
argument_list|<
name|Cell
argument_list|>
name|listCells
parameter_list|()
block|{
return|return
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|Arrays
operator|.
name|asList
argument_list|(
name|rawCells
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Return an cells of a Result as an array of KeyValues     *     * WARNING do not use, expensive.  This does  an arraycopy of the cell[]'s value.    *    * Added to ease transition from  0.94 -> 0.96.    *     * @deprecated as of 0.96, use {@link #listCells()}      * @return all sorted List of KeyValues; can be null if no cells in the result    */
annotation|@
name|Deprecated
specifier|public
name|List
argument_list|<
name|KeyValue
argument_list|>
name|list
parameter_list|()
block|{
return|return
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|Arrays
operator|.
name|asList
argument_list|(
name|raw
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @deprecated Use {@link #getColumnCells(byte[], byte[])} instead.    */
annotation|@
name|Deprecated
specifier|public
name|List
argument_list|<
name|KeyValue
argument_list|>
name|getColumn
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
return|return
name|KeyValueUtil
operator|.
name|ensureKeyValues
argument_list|(
name|getColumnCells
argument_list|(
name|family
argument_list|,
name|qualifier
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Return the Cells for the specific column.  The Cells are sorted in    * the {@link KeyValue#COMPARATOR} order.  That implies the first entry in    * the list is the most recent column.  If the query (Scan or Get) only    * requested 1 version the list will contain at most 1 entry.  If the column    * did not exist in the result set (either the column does not exist    * or the column was not selected in the query) the list will be empty.    *    * Also see getColumnLatest which returns just a Cell    *    * @param family the family    * @param qualifier    * @return a list of Cells for this column or empty list if the column    * did not exist in the result set    */
specifier|public
name|List
argument_list|<
name|Cell
argument_list|>
name|getColumnCells
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
name|List
argument_list|<
name|Cell
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|Cell
argument_list|>
argument_list|()
decl_stmt|;
name|Cell
index|[]
name|kvs
init|=
name|rawCells
argument_list|()
decl_stmt|;
if|if
condition|(
name|kvs
operator|==
literal|null
operator|||
name|kvs
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
name|int
name|pos
init|=
name|binarySearch
argument_list|(
name|kvs
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|result
return|;
comment|// cant find it
block|}
for|for
control|(
name|int
name|i
init|=
name|pos
init|;
name|i
operator|<
name|kvs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CellUtil
operator|.
name|matchingColumn
argument_list|(
name|kvs
index|[
name|i
index|]
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|)
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|kvs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
specifier|protected
name|int
name|binarySearch
parameter_list|(
specifier|final
name|Cell
index|[]
name|kvs
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
name|Cell
name|searchTerm
init|=
name|KeyValueUtil
operator|.
name|createFirstOnRow
argument_list|(
name|CellUtil
operator|.
name|cloneRow
argument_list|(
name|kvs
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|)
decl_stmt|;
comment|// pos === ( -(insertion point) - 1)
name|int
name|pos
init|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|kvs
argument_list|,
name|searchTerm
argument_list|,
name|KeyValue
operator|.
name|COMPARATOR
argument_list|)
decl_stmt|;
comment|// never will exact match
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
name|pos
operator|=
operator|(
name|pos
operator|+
literal|1
operator|)
operator|*
operator|-
literal|1
expr_stmt|;
comment|// pos is now insertion point
block|}
if|if
condition|(
name|pos
operator|==
name|kvs
operator|.
name|length
condition|)
block|{
return|return
operator|-
literal|1
return|;
comment|// doesn't exist
block|}
return|return
name|pos
return|;
block|}
comment|/**    * Searches for the latest value for the specified column.    *    * @param kvs the array to search    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    *    * @return the index where the value was found, or -1 otherwise    */
specifier|protected
name|int
name|binarySearch
parameter_list|(
specifier|final
name|Cell
index|[]
name|kvs
parameter_list|,
specifier|final
name|byte
index|[]
name|family
parameter_list|,
specifier|final
name|int
name|foffset
parameter_list|,
specifier|final
name|int
name|flength
parameter_list|,
specifier|final
name|byte
index|[]
name|qualifier
parameter_list|,
specifier|final
name|int
name|qoffset
parameter_list|,
specifier|final
name|int
name|qlength
parameter_list|)
block|{
name|double
name|keyValueSize
init|=
operator|(
name|double
operator|)
name|KeyValue
operator|.
name|getKeyValueDataStructureSize
argument_list|(
name|kvs
index|[
literal|0
index|]
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|flength
argument_list|,
name|qlength
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|buffer
operator|==
literal|null
operator|||
name|keyValueSize
operator|>
name|buffer
operator|.
name|length
condition|)
block|{
comment|// pad to the smallest multiple of the pad width
name|buffer
operator|=
operator|new
name|byte
index|[
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|keyValueSize
operator|/
name|PAD_WIDTH
argument_list|)
operator|*
name|PAD_WIDTH
index|]
expr_stmt|;
block|}
name|Cell
name|searchTerm
init|=
name|KeyValueUtil
operator|.
name|createFirstOnRow
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|kvs
index|[
literal|0
index|]
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|kvs
index|[
literal|0
index|]
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|kvs
index|[
literal|0
index|]
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
decl_stmt|;
comment|// pos === ( -(insertion point) - 1)
name|int
name|pos
init|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|kvs
argument_list|,
name|searchTerm
argument_list|,
name|KeyValue
operator|.
name|COMPARATOR
argument_list|)
decl_stmt|;
comment|// never will exact match
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
name|pos
operator|=
operator|(
name|pos
operator|+
literal|1
operator|)
operator|*
operator|-
literal|1
expr_stmt|;
comment|// pos is now insertion point
block|}
if|if
condition|(
name|pos
operator|==
name|kvs
operator|.
name|length
condition|)
block|{
return|return
operator|-
literal|1
return|;
comment|// doesn't exist
block|}
return|return
name|pos
return|;
block|}
comment|/**    * @deprecated Use {@link #getColumnLatestCell(byte[], byte[])} instead.    */
annotation|@
name|Deprecated
specifier|public
name|KeyValue
name|getColumnLatest
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
return|return
name|KeyValueUtil
operator|.
name|ensureKeyValue
argument_list|(
name|getColumnLatestCell
argument_list|(
name|family
argument_list|,
name|qualifier
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * The Cell for the most recent timestamp for a given column.    *    * @param family    * @param qualifier    *    * @return the Cell for the column, or null if no value exists in the row or none have been    * selected in the query (Get/Scan)    */
specifier|public
name|Cell
name|getColumnLatestCell
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
name|Cell
index|[]
name|kvs
init|=
name|rawCells
argument_list|()
decl_stmt|;
comment|// side effect possibly.
if|if
condition|(
name|kvs
operator|==
literal|null
operator|||
name|kvs
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|pos
init|=
name|binarySearch
argument_list|(
name|kvs
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|CellUtil
operator|.
name|matchingColumn
argument_list|(
name|kvs
index|[
name|pos
index|]
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|)
condition|)
block|{
return|return
name|kvs
index|[
name|pos
index|]
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * @deprecated Use {@link #getColumnLatestCell(byte[], int, int, byte[], int, int)} instead.    */
annotation|@
name|Deprecated
specifier|public
name|KeyValue
name|getColumnLatest
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|int
name|foffset
parameter_list|,
name|int
name|flength
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|int
name|qoffset
parameter_list|,
name|int
name|qlength
parameter_list|)
block|{
return|return
name|KeyValueUtil
operator|.
name|ensureKeyValue
argument_list|(
name|getColumnLatestCell
argument_list|(
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * The Cell for the most recent timestamp for a given column.    *    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    *    * @return the Cell for the column, or null if no value exists in the row or none have been    * selected in the query (Get/Scan)    */
specifier|public
name|Cell
name|getColumnLatestCell
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|int
name|foffset
parameter_list|,
name|int
name|flength
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|int
name|qoffset
parameter_list|,
name|int
name|qlength
parameter_list|)
block|{
name|Cell
index|[]
name|kvs
init|=
name|rawCells
argument_list|()
decl_stmt|;
comment|// side effect possibly.
if|if
condition|(
name|kvs
operator|==
literal|null
operator|||
name|kvs
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|pos
init|=
name|binarySearch
argument_list|(
name|kvs
argument_list|,
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|CellUtil
operator|.
name|matchingColumn
argument_list|(
name|kvs
index|[
name|pos
index|]
argument_list|,
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
condition|)
block|{
return|return
name|kvs
index|[
name|pos
index|]
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Get the latest version of the specified column.    * @param family family name    * @param qualifier column qualifier    * @return value of latest version of column, null if none found    */
specifier|public
name|byte
index|[]
name|getValue
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
name|Cell
name|kv
init|=
name|getColumnLatestCell
argument_list|(
name|family
argument_list|,
name|qualifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|kv
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|CellUtil
operator|.
name|cloneValue
argument_list|(
name|kv
argument_list|)
return|;
block|}
comment|/**    * Returns the value wrapped in a new<code>ByteBuffer</code>.    *    * @param family family name    * @param qualifier column qualifier    *    * @return the latest version of the column, or<code>null</code> if none found    */
specifier|public
name|ByteBuffer
name|getValueAsByteBuffer
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
name|Cell
name|kv
init|=
name|getColumnLatestCell
argument_list|(
name|family
argument_list|,
literal|0
argument_list|,
name|family
operator|.
name|length
argument_list|,
name|qualifier
argument_list|,
literal|0
argument_list|,
name|qualifier
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|kv
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|kv
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|kv
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getValueLength
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns the value wrapped in a new<code>ByteBuffer</code>.    *    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    *    * @return the latest version of the column, or<code>null</code> if none found    */
specifier|public
name|ByteBuffer
name|getValueAsByteBuffer
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|int
name|foffset
parameter_list|,
name|int
name|flength
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|int
name|qoffset
parameter_list|,
name|int
name|qlength
parameter_list|)
block|{
name|Cell
name|kv
init|=
name|getColumnLatestCell
argument_list|(
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
decl_stmt|;
if|if
condition|(
name|kv
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|kv
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|kv
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getValueLength
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Loads the latest version of the specified column into the provided<code>ByteBuffer</code>.    *<p>    * Does not clear or flip the buffer.    *    * @param family family name    * @param qualifier column qualifier    * @param dst the buffer where to write the value    *    * @return<code>true</code> if a value was found,<code>false</code> otherwise    *    * @throws BufferOverflowException there is insufficient space remaining in the buffer    */
specifier|public
name|boolean
name|loadValue
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|ByteBuffer
name|dst
parameter_list|)
throws|throws
name|BufferOverflowException
block|{
return|return
name|loadValue
argument_list|(
name|family
argument_list|,
literal|0
argument_list|,
name|family
operator|.
name|length
argument_list|,
name|qualifier
argument_list|,
literal|0
argument_list|,
name|qualifier
operator|.
name|length
argument_list|,
name|dst
argument_list|)
return|;
block|}
comment|/**    * Loads the latest version of the specified column into the provided<code>ByteBuffer</code>.    *<p>    * Does not clear or flip the buffer.    *    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    * @param dst the buffer where to write the value    *    * @return<code>true</code> if a value was found,<code>false</code> otherwise    *    * @throws BufferOverflowException there is insufficient space remaining in the buffer    */
specifier|public
name|boolean
name|loadValue
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|int
name|foffset
parameter_list|,
name|int
name|flength
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|int
name|qoffset
parameter_list|,
name|int
name|qlength
parameter_list|,
name|ByteBuffer
name|dst
parameter_list|)
throws|throws
name|BufferOverflowException
block|{
name|Cell
name|kv
init|=
name|getColumnLatestCell
argument_list|(
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
decl_stmt|;
if|if
condition|(
name|kv
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|dst
operator|.
name|put
argument_list|(
name|kv
operator|.
name|getValueArray
argument_list|()
argument_list|,
name|kv
operator|.
name|getValueOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getValueLength
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Checks if the specified column contains a non-empty value (not a zero-length byte array).    *    * @param family family name    * @param qualifier column qualifier    *    * @return whether or not a latest value exists and is not empty    */
specifier|public
name|boolean
name|containsNonEmptyColumn
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
return|return
name|containsNonEmptyColumn
argument_list|(
name|family
argument_list|,
literal|0
argument_list|,
name|family
operator|.
name|length
argument_list|,
name|qualifier
argument_list|,
literal|0
argument_list|,
name|qualifier
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * Checks if the specified column contains a non-empty value (not a zero-length byte array).    *    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    *    * @return whether or not a latest value exists and is not empty    */
specifier|public
name|boolean
name|containsNonEmptyColumn
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|int
name|foffset
parameter_list|,
name|int
name|flength
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|int
name|qoffset
parameter_list|,
name|int
name|qlength
parameter_list|)
block|{
name|Cell
name|kv
init|=
name|getColumnLatestCell
argument_list|(
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
decl_stmt|;
return|return
operator|(
name|kv
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|kv
operator|.
name|getValueLength
argument_list|()
operator|>
literal|0
operator|)
return|;
block|}
comment|/**    * Checks if the specified column contains an empty value (a zero-length byte array).    *    * @param family family name    * @param qualifier column qualifier    *    * @return whether or not a latest value exists and is empty    */
specifier|public
name|boolean
name|containsEmptyColumn
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
return|return
name|containsEmptyColumn
argument_list|(
name|family
argument_list|,
literal|0
argument_list|,
name|family
operator|.
name|length
argument_list|,
name|qualifier
argument_list|,
literal|0
argument_list|,
name|qualifier
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * Checks if the specified column contains an empty value (a zero-length byte array).    *    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    *    * @return whether or not a latest value exists and is empty    */
specifier|public
name|boolean
name|containsEmptyColumn
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|int
name|foffset
parameter_list|,
name|int
name|flength
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|int
name|qoffset
parameter_list|,
name|int
name|qlength
parameter_list|)
block|{
name|Cell
name|kv
init|=
name|getColumnLatestCell
argument_list|(
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
decl_stmt|;
return|return
operator|(
name|kv
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|kv
operator|.
name|getValueLength
argument_list|()
operator|==
literal|0
operator|)
return|;
block|}
comment|/**    * Checks for existence of a value for the specified column (empty or not).    *    * @param family family name    * @param qualifier column qualifier    *    * @return true if at least one value exists in the result, false if not    */
specifier|public
name|boolean
name|containsColumn
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|)
block|{
name|Cell
name|kv
init|=
name|getColumnLatestCell
argument_list|(
name|family
argument_list|,
name|qualifier
argument_list|)
decl_stmt|;
return|return
name|kv
operator|!=
literal|null
return|;
block|}
comment|/**    * Checks for existence of a value for the specified column (empty or not).    *    * @param family family name    * @param foffset family offset    * @param flength family length    * @param qualifier column qualifier    * @param qoffset qualifier offset    * @param qlength qualifier length    *    * @return true if at least one value exists in the result, false if not    */
specifier|public
name|boolean
name|containsColumn
parameter_list|(
name|byte
index|[]
name|family
parameter_list|,
name|int
name|foffset
parameter_list|,
name|int
name|flength
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|int
name|qoffset
parameter_list|,
name|int
name|qlength
parameter_list|)
block|{
return|return
name|getColumnLatestCell
argument_list|(
name|family
argument_list|,
name|foffset
argument_list|,
name|flength
argument_list|,
name|qualifier
argument_list|,
name|qoffset
argument_list|,
name|qlength
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**    * Map of families to all versions of its qualifiers and values.    *<p>    * Returns a three level Map of the form:    *<code>Map&amp;family,Map&lt;qualifier,Map&lt;timestamp,value>>></code>    *<p>    * Note: All other map returning methods make use of this map internally.    * @return map from families to qualifiers to versions    */
specifier|public
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
argument_list|>
name|getMap
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|familyMap
operator|!=
literal|null
condition|)
block|{
return|return
name|this
operator|.
name|familyMap
return|;
block|}
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|this
operator|.
name|familyMap
operator|=
operator|new
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
expr_stmt|;
for|for
control|(
name|Cell
name|kv
range|:
name|this
operator|.
name|cells
control|)
block|{
name|byte
index|[]
name|family
init|=
name|CellUtil
operator|.
name|cloneFamily
argument_list|(
name|kv
argument_list|)
decl_stmt|;
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|columnMap
init|=
name|familyMap
operator|.
name|get
argument_list|(
name|family
argument_list|)
decl_stmt|;
if|if
condition|(
name|columnMap
operator|==
literal|null
condition|)
block|{
name|columnMap
operator|=
operator|new
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
expr_stmt|;
name|familyMap
operator|.
name|put
argument_list|(
name|family
argument_list|,
name|columnMap
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|qualifier
init|=
name|CellUtil
operator|.
name|cloneQualifier
argument_list|(
name|kv
argument_list|)
decl_stmt|;
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
name|versionMap
init|=
name|columnMap
operator|.
name|get
argument_list|(
name|qualifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|versionMap
operator|==
literal|null
condition|)
block|{
name|versionMap
operator|=
operator|new
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|(
operator|new
name|Comparator
argument_list|<
name|Long
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|Long
name|l1
parameter_list|,
name|Long
name|l2
parameter_list|)
block|{
return|return
name|l2
operator|.
name|compareTo
argument_list|(
name|l1
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|columnMap
operator|.
name|put
argument_list|(
name|qualifier
argument_list|,
name|versionMap
argument_list|)
expr_stmt|;
block|}
name|Long
name|timestamp
init|=
name|kv
operator|.
name|getTimestamp
argument_list|()
decl_stmt|;
name|byte
index|[]
name|value
init|=
name|CellUtil
operator|.
name|cloneValue
argument_list|(
name|kv
argument_list|)
decl_stmt|;
name|versionMap
operator|.
name|put
argument_list|(
name|timestamp
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|this
operator|.
name|familyMap
return|;
block|}
comment|/**    * Map of families to their most recent qualifiers and values.    *<p>    * Returns a two level Map of the form:<code>Map&amp;family,Map&lt;qualifier,value>></code>    *<p>    * The most recent version of each qualifier will be used.    * @return map from families to qualifiers and value    */
specifier|public
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|getNoVersionMap
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|familyMap
operator|==
literal|null
condition|)
block|{
name|getMap
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|returnMap
init|=
operator|new
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
argument_list|>
name|familyEntry
range|:
name|familyMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|qualifierMap
init|=
operator|new
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|qualifierEntry
range|:
name|familyEntry
operator|.
name|getValue
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|byte
index|[]
name|value
init|=
name|qualifierEntry
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|(
name|qualifierEntry
operator|.
name|getValue
argument_list|()
operator|.
name|firstKey
argument_list|()
argument_list|)
decl_stmt|;
name|qualifierMap
operator|.
name|put
argument_list|(
name|qualifierEntry
operator|.
name|getKey
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|returnMap
operator|.
name|put
argument_list|(
name|familyEntry
operator|.
name|getKey
argument_list|()
argument_list|,
name|qualifierMap
argument_list|)
expr_stmt|;
block|}
return|return
name|returnMap
return|;
block|}
comment|/**    * Map of qualifiers to values.    *<p>    * Returns a Map of the form:<code>Map&lt;qualifier,value></code>    * @param family column family to get    * @return map of qualifiers to values    */
specifier|public
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|getFamilyMap
parameter_list|(
name|byte
index|[]
name|family
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|familyMap
operator|==
literal|null
condition|)
block|{
name|getMap
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|returnMap
init|=
operator|new
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
name|NavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|qualifierMap
init|=
name|familyMap
operator|.
name|get
argument_list|(
name|family
argument_list|)
decl_stmt|;
if|if
condition|(
name|qualifierMap
operator|==
literal|null
condition|)
block|{
return|return
name|returnMap
return|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|>
name|entry
range|:
name|qualifierMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|byte
index|[]
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|firstKey
argument_list|()
argument_list|)
decl_stmt|;
name|returnMap
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|returnMap
return|;
block|}
comment|/**    * Returns the value of the first column in the Result.    * @return value of the first column    */
specifier|public
name|byte
index|[]
name|value
parameter_list|()
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|CellUtil
operator|.
name|cloneValue
argument_list|(
name|cells
index|[
literal|0
index|]
argument_list|)
return|;
block|}
comment|/**    * Check if the underlying Cell [] is empty or not    * @return true if empty    */
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|this
operator|.
name|cells
operator|==
literal|null
operator|||
name|this
operator|.
name|cells
operator|.
name|length
operator|==
literal|0
return|;
block|}
comment|/**    * @return the size of the underlying Cell []    */
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|this
operator|.
name|cells
operator|==
literal|null
condition|?
literal|0
else|:
name|this
operator|.
name|cells
operator|.
name|length
return|;
block|}
comment|/**    * @return String    */
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"keyvalues="
argument_list|)
expr_stmt|;
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"NONE"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|boolean
name|moreThanOne
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Cell
name|kv
range|:
name|this
operator|.
name|cells
control|)
block|{
if|if
condition|(
name|moreThanOne
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|moreThanOne
operator|=
literal|true
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|kv
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Does a deep comparison of two Results, down to the byte arrays.    * @param res1 first result to compare    * @param res2 second result to compare    * @throws Exception Every difference is throwing an exception    */
specifier|public
specifier|static
name|void
name|compareResults
parameter_list|(
name|Result
name|res1
parameter_list|,
name|Result
name|res2
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|res2
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
literal|"There wasn't enough rows, we stopped at "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|res1
operator|.
name|getRow
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|res1
operator|.
name|size
argument_list|()
operator|!=
name|res2
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
literal|"This row doesn't have the same number of KVs: "
operator|+
name|res1
operator|.
name|toString
argument_list|()
operator|+
literal|" compared to "
operator|+
name|res2
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
name|Cell
index|[]
name|ourKVs
init|=
name|res1
operator|.
name|rawCells
argument_list|()
decl_stmt|;
name|Cell
index|[]
name|replicatedKVs
init|=
name|res2
operator|.
name|rawCells
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|res1
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ourKVs
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
name|replicatedKVs
index|[
name|i
index|]
argument_list|)
operator|||
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|CellUtil
operator|.
name|cloneValue
argument_list|(
name|ourKVs
index|[
name|i
index|]
argument_list|)
argument_list|,
name|CellUtil
operator|.
name|cloneValue
argument_list|(
name|replicatedKVs
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
literal|"This result was different: "
operator|+
name|res1
operator|.
name|toString
argument_list|()
operator|+
literal|" compared to "
operator|+
name|res2
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Get total size of raw cells     * @param result    * @return Total size.    */
specifier|public
specifier|static
name|long
name|getTotalSizeOfCells
parameter_list|(
name|Result
name|result
parameter_list|)
block|{
name|long
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Cell
name|c
range|:
name|result
operator|.
name|rawCells
argument_list|()
control|)
block|{
name|size
operator|+=
name|KeyValueUtil
operator|.
name|ensureKeyValue
argument_list|(
name|c
argument_list|)
operator|.
name|heapSize
argument_list|()
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
comment|/**    * Copy another Result into this one. Needed for the old Mapred framework    * @param other    */
specifier|public
name|void
name|copyFrom
parameter_list|(
name|Result
name|other
parameter_list|)
block|{
name|this
operator|.
name|row
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|familyMap
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|cells
operator|=
name|other
operator|.
name|cells
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|CellScanner
name|cellScanner
parameter_list|()
block|{
return|return
name|CellUtil
operator|.
name|createCellScanner
argument_list|(
name|this
operator|.
name|cells
argument_list|)
return|;
block|}
specifier|public
name|Boolean
name|getExists
parameter_list|()
block|{
return|return
name|exists
return|;
block|}
specifier|public
name|void
name|setExists
parameter_list|(
name|Boolean
name|exists
parameter_list|)
block|{
name|this
operator|.
name|exists
operator|=
name|exists
expr_stmt|;
block|}
block|}
end_class

end_unit

