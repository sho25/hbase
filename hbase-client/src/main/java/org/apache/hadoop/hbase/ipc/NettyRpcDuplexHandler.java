begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Message
operator|.
name|Builder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|TextFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|buffer
operator|.
name|ByteBuf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|buffer
operator|.
name|ByteBufInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|buffer
operator|.
name|ByteBufOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|channel
operator|.
name|ChannelDuplexHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|channel
operator|.
name|ChannelHandlerContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|channel
operator|.
name|ChannelPromise
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|handler
operator|.
name|timeout
operator|.
name|IdleStateEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|io
operator|.
name|netty
operator|.
name|util
operator|.
name|concurrent
operator|.
name|PromiseCombiner
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|codec
operator|.
name|Codec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|CellBlockMeta
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|ExceptionResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|RequestHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RPCProtos
operator|.
name|ResponseHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|CompressionCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_comment
comment|/**  * The netty rpc handler.  * @since 2.0.0  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
class|class
name|NettyRpcDuplexHandler
extends|extends
name|ChannelDuplexHandler
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|NettyRpcDuplexHandler
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|NettyRpcConnection
name|conn
decl_stmt|;
specifier|private
specifier|final
name|CellBlockBuilder
name|cellBlockBuilder
decl_stmt|;
specifier|private
specifier|final
name|Codec
name|codec
decl_stmt|;
specifier|private
specifier|final
name|CompressionCodec
name|compressor
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Call
argument_list|>
name|id2Call
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|public
name|NettyRpcDuplexHandler
parameter_list|(
name|NettyRpcConnection
name|conn
parameter_list|,
name|CellBlockBuilder
name|cellBlockBuilder
parameter_list|,
name|Codec
name|codec
parameter_list|,
name|CompressionCodec
name|compressor
parameter_list|)
block|{
name|this
operator|.
name|conn
operator|=
name|conn
expr_stmt|;
name|this
operator|.
name|cellBlockBuilder
operator|=
name|cellBlockBuilder
expr_stmt|;
name|this
operator|.
name|codec
operator|=
name|codec
expr_stmt|;
name|this
operator|.
name|compressor
operator|=
name|compressor
expr_stmt|;
block|}
specifier|private
name|void
name|writeRequest
parameter_list|(
name|ChannelHandlerContext
name|ctx
parameter_list|,
name|Call
name|call
parameter_list|,
name|ChannelPromise
name|promise
parameter_list|)
throws|throws
name|IOException
block|{
name|id2Call
operator|.
name|put
argument_list|(
name|call
operator|.
name|id
argument_list|,
name|call
argument_list|)
expr_stmt|;
name|ByteBuf
name|cellBlock
init|=
name|cellBlockBuilder
operator|.
name|buildCellBlock
argument_list|(
name|codec
argument_list|,
name|compressor
argument_list|,
name|call
operator|.
name|cells
argument_list|,
name|ctx
operator|.
name|alloc
argument_list|()
argument_list|)
decl_stmt|;
name|CellBlockMeta
name|cellBlockMeta
decl_stmt|;
if|if
condition|(
name|cellBlock
operator|!=
literal|null
condition|)
block|{
name|CellBlockMeta
operator|.
name|Builder
name|cellBlockMetaBuilder
init|=
name|CellBlockMeta
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|cellBlockMetaBuilder
operator|.
name|setLength
argument_list|(
name|cellBlock
operator|.
name|writerIndex
argument_list|()
argument_list|)
expr_stmt|;
name|cellBlockMeta
operator|=
name|cellBlockMetaBuilder
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|cellBlockMeta
operator|=
literal|null
expr_stmt|;
block|}
name|RequestHeader
name|requestHeader
init|=
name|IPCUtil
operator|.
name|buildRequestHeader
argument_list|(
name|call
argument_list|,
name|cellBlockMeta
argument_list|)
decl_stmt|;
name|int
name|sizeWithoutCellBlock
init|=
name|IPCUtil
operator|.
name|getTotalSizeWhenWrittenDelimited
argument_list|(
name|requestHeader
argument_list|,
name|call
operator|.
name|param
argument_list|)
decl_stmt|;
name|int
name|totalSize
init|=
name|cellBlock
operator|!=
literal|null
condition|?
name|sizeWithoutCellBlock
operator|+
name|cellBlock
operator|.
name|writerIndex
argument_list|()
else|:
name|sizeWithoutCellBlock
decl_stmt|;
name|ByteBuf
name|buf
init|=
name|ctx
operator|.
name|alloc
argument_list|()
operator|.
name|buffer
argument_list|(
name|sizeWithoutCellBlock
operator|+
literal|4
argument_list|)
decl_stmt|;
name|buf
operator|.
name|writeInt
argument_list|(
name|totalSize
argument_list|)
expr_stmt|;
try|try
init|(
name|ByteBufOutputStream
name|bbos
init|=
operator|new
name|ByteBufOutputStream
argument_list|(
name|buf
argument_list|)
init|)
block|{
name|requestHeader
operator|.
name|writeDelimitedTo
argument_list|(
name|bbos
argument_list|)
expr_stmt|;
if|if
condition|(
name|call
operator|.
name|param
operator|!=
literal|null
condition|)
block|{
name|call
operator|.
name|param
operator|.
name|writeDelimitedTo
argument_list|(
name|bbos
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cellBlock
operator|!=
literal|null
condition|)
block|{
name|ChannelPromise
name|withoutCellBlockPromise
init|=
name|ctx
operator|.
name|newPromise
argument_list|()
decl_stmt|;
name|ctx
operator|.
name|write
argument_list|(
name|buf
argument_list|,
name|withoutCellBlockPromise
argument_list|)
expr_stmt|;
name|ChannelPromise
name|cellBlockPromise
init|=
name|ctx
operator|.
name|newPromise
argument_list|()
decl_stmt|;
name|ctx
operator|.
name|write
argument_list|(
name|cellBlock
argument_list|,
name|cellBlockPromise
argument_list|)
expr_stmt|;
name|PromiseCombiner
name|combiner
init|=
operator|new
name|PromiseCombiner
argument_list|()
decl_stmt|;
name|combiner
operator|.
name|addAll
argument_list|(
name|withoutCellBlockPromise
argument_list|,
name|cellBlockPromise
argument_list|)
expr_stmt|;
name|combiner
operator|.
name|finish
argument_list|(
name|promise
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|.
name|write
argument_list|(
name|buf
argument_list|,
name|promise
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|ChannelHandlerContext
name|ctx
parameter_list|,
name|Object
name|msg
parameter_list|,
name|ChannelPromise
name|promise
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|msg
operator|instanceof
name|Call
condition|)
block|{
name|writeRequest
argument_list|(
name|ctx
argument_list|,
operator|(
name|Call
operator|)
name|msg
argument_list|,
name|promise
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|.
name|write
argument_list|(
name|msg
argument_list|,
name|promise
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|readResponse
parameter_list|(
name|ChannelHandlerContext
name|ctx
parameter_list|,
name|ByteBuf
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|totalSize
init|=
name|buf
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|ByteBufInputStream
name|in
init|=
operator|new
name|ByteBufInputStream
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|ResponseHeader
name|responseHeader
init|=
name|ResponseHeader
operator|.
name|parseDelimitedFrom
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|int
name|id
init|=
name|responseHeader
operator|.
name|getCallId
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"got response header "
operator|+
name|TextFormat
operator|.
name|shortDebugString
argument_list|(
name|responseHeader
argument_list|)
operator|+
literal|", totalSize: "
operator|+
name|totalSize
operator|+
literal|" bytes"
argument_list|)
expr_stmt|;
block|}
name|RemoteException
name|remoteExc
decl_stmt|;
if|if
condition|(
name|responseHeader
operator|.
name|hasException
argument_list|()
condition|)
block|{
name|ExceptionResponse
name|exceptionResponse
init|=
name|responseHeader
operator|.
name|getException
argument_list|()
decl_stmt|;
name|remoteExc
operator|=
name|IPCUtil
operator|.
name|createRemoteException
argument_list|(
name|exceptionResponse
argument_list|)
expr_stmt|;
if|if
condition|(
name|IPCUtil
operator|.
name|isFatalConnectionException
argument_list|(
name|exceptionResponse
argument_list|)
condition|)
block|{
comment|// Here we will cleanup all calls so do not need to fall back, just return.
name|exceptionCaught
argument_list|(
name|ctx
argument_list|,
name|remoteExc
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|remoteExc
operator|=
literal|null
expr_stmt|;
block|}
name|Call
name|call
init|=
name|id2Call
operator|.
name|remove
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|call
operator|==
literal|null
condition|)
block|{
comment|// So we got a response for which we have no corresponding 'call' here on the client-side.
comment|// We probably timed out waiting, cleaned up all references, and now the server decides
comment|// to return a response. There is nothing we can do w/ the response at this stage. Clean
comment|// out the wire of the response so its out of the way and we can get other responses on
comment|// this connection.
name|int
name|readSoFar
init|=
name|IPCUtil
operator|.
name|getTotalSizeWhenWrittenDelimited
argument_list|(
name|responseHeader
argument_list|)
decl_stmt|;
name|int
name|whatIsLeftToRead
init|=
name|totalSize
operator|-
name|readSoFar
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unknown callId: "
operator|+
name|id
operator|+
literal|", skipping over this response of "
operator|+
name|whatIsLeftToRead
operator|+
literal|" bytes"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|remoteExc
operator|!=
literal|null
condition|)
block|{
name|call
operator|.
name|setException
argument_list|(
name|remoteExc
argument_list|)
expr_stmt|;
return|return;
block|}
name|Message
name|value
decl_stmt|;
if|if
condition|(
name|call
operator|.
name|responseDefaultType
operator|!=
literal|null
condition|)
block|{
name|Builder
name|builder
init|=
name|call
operator|.
name|responseDefaultType
operator|.
name|newBuilderForType
argument_list|()
decl_stmt|;
name|builder
operator|.
name|mergeDelimitedFrom
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|value
operator|=
name|builder
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
literal|null
expr_stmt|;
block|}
name|CellScanner
name|cellBlockScanner
decl_stmt|;
if|if
condition|(
name|responseHeader
operator|.
name|hasCellBlockMeta
argument_list|()
condition|)
block|{
name|int
name|size
init|=
name|responseHeader
operator|.
name|getCellBlockMeta
argument_list|()
operator|.
name|getLength
argument_list|()
decl_stmt|;
comment|// Maybe we could read directly from the ByteBuf.
comment|// The problem here is that we do not know when to release it.
name|byte
index|[]
name|cellBlock
init|=
operator|new
name|byte
index|[
name|size
index|]
decl_stmt|;
name|buf
operator|.
name|readBytes
argument_list|(
name|cellBlock
argument_list|)
expr_stmt|;
name|cellBlockScanner
operator|=
name|cellBlockBuilder
operator|.
name|createCellScanner
argument_list|(
name|this
operator|.
name|codec
argument_list|,
name|this
operator|.
name|compressor
argument_list|,
name|cellBlock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cellBlockScanner
operator|=
literal|null
expr_stmt|;
block|}
name|call
operator|.
name|setResponse
argument_list|(
name|value
argument_list|,
name|cellBlockScanner
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|channelRead
parameter_list|(
name|ChannelHandlerContext
name|ctx
parameter_list|,
name|Object
name|msg
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|msg
operator|instanceof
name|ByteBuf
condition|)
block|{
name|ByteBuf
name|buf
init|=
operator|(
name|ByteBuf
operator|)
name|msg
decl_stmt|;
try|try
block|{
name|readResponse
argument_list|(
name|ctx
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|buf
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|super
operator|.
name|channelRead
argument_list|(
name|ctx
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|cleanupCalls
parameter_list|(
name|ChannelHandlerContext
name|ctx
parameter_list|,
name|IOException
name|error
parameter_list|)
block|{
for|for
control|(
name|Call
name|call
range|:
name|id2Call
operator|.
name|values
argument_list|()
control|)
block|{
name|call
operator|.
name|setException
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
name|id2Call
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|channelInactive
parameter_list|(
name|ChannelHandlerContext
name|ctx
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|id2Call
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|cleanupCalls
argument_list|(
name|ctx
argument_list|,
operator|new
name|IOException
argument_list|(
literal|"Connection closed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|conn
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|ctx
operator|.
name|fireChannelInactive
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|exceptionCaught
parameter_list|(
name|ChannelHandlerContext
name|ctx
parameter_list|,
name|Throwable
name|cause
parameter_list|)
block|{
if|if
condition|(
operator|!
name|id2Call
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|cleanupCalls
argument_list|(
name|ctx
argument_list|,
name|IPCUtil
operator|.
name|toIOE
argument_list|(
name|cause
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|conn
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|userEventTriggered
parameter_list|(
name|ChannelHandlerContext
name|ctx
parameter_list|,
name|Object
name|evt
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|evt
operator|instanceof
name|IdleStateEvent
condition|)
block|{
name|IdleStateEvent
name|idleEvt
init|=
operator|(
name|IdleStateEvent
operator|)
name|evt
decl_stmt|;
switch|switch
condition|(
name|idleEvt
operator|.
name|state
argument_list|()
condition|)
block|{
case|case
name|WRITER_IDLE
case|:
if|if
condition|(
name|id2Call
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"shutdown connection to "
operator|+
name|conn
operator|.
name|remoteId
argument_list|()
operator|.
name|address
operator|+
literal|" because idle for a long time"
argument_list|)
expr_stmt|;
block|}
comment|// It may happen that there are still some pending calls in the event loop queue and
comment|// they will get a closed channel exception. But this is not a big deal as it rarely
comment|// rarely happens and the upper layer could retry immediately.
name|conn
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unrecognized idle state "
operator|+
name|idleEvt
operator|.
name|state
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|evt
operator|instanceof
name|CallEvent
condition|)
block|{
comment|// just remove the call for now until we add other call event other than timeout and cancel.
name|id2Call
operator|.
name|remove
argument_list|(
operator|(
operator|(
name|CallEvent
operator|)
name|evt
operator|)
operator|.
name|call
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|.
name|fireUserEventTriggered
argument_list|(
name|evt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

