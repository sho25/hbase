begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|DeserializationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|HBaseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|compress
operator|.
name|Compression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|encoding
operator|.
name|DataBlockEncoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|BytesBytesPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|ColumnFamilySchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|NameStringPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|BloomType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ByteStringer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|PrettyPrinter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|PrettyPrinter
operator|.
name|Unit
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_comment
comment|/**  * An HColumnDescriptor contains information about a column family such as the  * number of versions, compression settings, etc.  *  * It is used as input when creating a table or adding a column.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
class|class
name|HColumnDescriptor
implements|implements
name|Comparable
argument_list|<
name|HColumnDescriptor
argument_list|>
block|{
comment|// For future backward compatibility
comment|// Version  3 was when column names become byte arrays and when we picked up
comment|// Time-to-live feature.  Version 4 was when we moved to byte arrays, HBASE-82.
comment|// Version  5 was when bloom filter descriptors were removed.
comment|// Version  6 adds metadata as a map where keys and values are byte[].
comment|// Version  7 -- add new compression and hfile blocksize to HColumnDescriptor (HBASE-1217)
comment|// Version  8 -- reintroduction of bloom filters, changed from boolean to enum
comment|// Version  9 -- add data block encoding
comment|// Version 10 -- change metadata to standard type.
comment|// Version 11 -- add column family level configuration.
specifier|private
specifier|static
specifier|final
name|byte
name|COLUMN_DESCRIPTOR_VERSION
init|=
operator|(
name|byte
operator|)
literal|11
decl_stmt|;
comment|// These constants are used as FileInfo keys
specifier|public
specifier|static
specifier|final
name|String
name|COMPRESSION
init|=
literal|"COMPRESSION"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|COMPRESSION_COMPACT
init|=
literal|"COMPRESSION_COMPACT"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ENCODE_ON_DISK
init|=
comment|// To be removed, it is not used anymore
literal|"ENCODE_ON_DISK"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|DATA_BLOCK_ENCODING
init|=
literal|"DATA_BLOCK_ENCODING"
decl_stmt|;
comment|/**    * Key for the BLOCKCACHE attribute.    * A more exact name would be CACHE_DATA_ON_READ because this flag sets whether or not we    * cache DATA blocks.  We always cache INDEX and BLOOM blocks; caching these blocks cannot be    * disabled.    */
specifier|public
specifier|static
specifier|final
name|String
name|BLOCKCACHE
init|=
literal|"BLOCKCACHE"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|CACHE_DATA_ON_WRITE
init|=
literal|"CACHE_DATA_ON_WRITE"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|CACHE_INDEX_ON_WRITE
init|=
literal|"CACHE_INDEX_ON_WRITE"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|CACHE_BLOOMS_ON_WRITE
init|=
literal|"CACHE_BLOOMS_ON_WRITE"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|EVICT_BLOCKS_ON_CLOSE
init|=
literal|"EVICT_BLOCKS_ON_CLOSE"
decl_stmt|;
comment|/**    * Key for cache data into L1 if cache is set up with more than one tier.    * To set in the shell, do something like this:    *<code>hbase(main):003:0&gt; create 't',    *    {NAME =&gt; 't', CONFIGURATION =&gt; {CACHE_DATA_IN_L1 =&gt; 'true'}}</code>    */
specifier|public
specifier|static
specifier|final
name|String
name|CACHE_DATA_IN_L1
init|=
literal|"CACHE_DATA_IN_L1"
decl_stmt|;
comment|/**    * Key for the PREFETCH_BLOCKS_ON_OPEN attribute.    * If set, all INDEX, BLOOM, and DATA blocks of HFiles belonging to this    * family will be loaded into the cache as soon as the file is opened. These    * loads will not count as cache misses.    */
specifier|public
specifier|static
specifier|final
name|String
name|PREFETCH_BLOCKS_ON_OPEN
init|=
literal|"PREFETCH_BLOCKS_ON_OPEN"
decl_stmt|;
comment|/**    * Size of storefile/hfile 'blocks'.  Default is {@link #DEFAULT_BLOCKSIZE}.    * Use smaller block sizes for faster random-access at expense of larger    * indices (more memory consumption).    */
specifier|public
specifier|static
specifier|final
name|String
name|BLOCKSIZE
init|=
literal|"BLOCKSIZE"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|LENGTH
init|=
literal|"LENGTH"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|TTL
init|=
literal|"TTL"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|BLOOMFILTER
init|=
literal|"BLOOMFILTER"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|FOREVER
init|=
literal|"FOREVER"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|REPLICATION_SCOPE
init|=
literal|"REPLICATION_SCOPE"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|REPLICATION_SCOPE_BYTES
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|REPLICATION_SCOPE
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|MIN_VERSIONS
init|=
literal|"MIN_VERSIONS"
decl_stmt|;
comment|/**    * Retain all cells across flushes and compactions even if they fall behind    * a delete tombstone. To see all retained cells, do a 'raw' scan; see    * Scan#setRaw or pass RAW =&gt; true attribute in the shell.    */
specifier|public
specifier|static
specifier|final
name|String
name|KEEP_DELETED_CELLS
init|=
literal|"KEEP_DELETED_CELLS"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|COMPRESS_TAGS
init|=
literal|"COMPRESS_TAGS"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ENCRYPTION
init|=
literal|"ENCRYPTION"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ENCRYPTION_KEY
init|=
literal|"ENCRYPTION_KEY"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|IS_MOB
init|=
literal|"IS_MOB"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|IS_MOB_BYTES
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|IS_MOB
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|MOB_THRESHOLD
init|=
literal|"MOB_THRESHOLD"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|MOB_THRESHOLD_BYTES
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|MOB_THRESHOLD
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|long
name|DEFAULT_MOB_THRESHOLD
init|=
literal|100
operator|*
literal|1024
decl_stmt|;
comment|// 100k
specifier|public
specifier|static
specifier|final
name|String
name|DFS_REPLICATION
init|=
literal|"DFS_REPLICATION"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|short
name|DEFAULT_DFS_REPLICATION
init|=
literal|0
decl_stmt|;
comment|/**    * Default compression type.    */
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_COMPRESSION
init|=
name|Compression
operator|.
name|Algorithm
operator|.
name|NONE
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|/**    * Default value of the flag that enables data block encoding on disk, as    * opposed to encoding in cache only. We encode blocks everywhere by default,    * as long as {@link #DATA_BLOCK_ENCODING} is not NONE.    */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_ENCODE_ON_DISK
init|=
literal|true
decl_stmt|;
comment|/** Default data block encoding algorithm. */
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_DATA_BLOCK_ENCODING
init|=
name|DataBlockEncoding
operator|.
name|NONE
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|/**    * Default number of versions of a record to keep.    */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_VERSIONS
init|=
name|HBaseConfiguration
operator|.
name|create
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"hbase.column.max.version"
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/**    * Default is not to keep a minimum of versions.    */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MIN_VERSIONS
init|=
literal|0
decl_stmt|;
comment|/*    * Cache here the HCD value.    * Question: its OK to cache since when we're reenable, we create a new HCD?    */
specifier|private
specifier|volatile
name|Integer
name|blocksize
init|=
literal|null
decl_stmt|;
comment|/**    * Default setting for whether to try and serve this column family from memory or not.    */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_IN_MEMORY
init|=
literal|false
decl_stmt|;
comment|/**    * Default setting for preventing deleted from being collected immediately.    */
specifier|public
specifier|static
specifier|final
name|KeepDeletedCells
name|DEFAULT_KEEP_DELETED
init|=
name|KeepDeletedCells
operator|.
name|FALSE
decl_stmt|;
comment|/**    * Default setting for whether to use a block cache or not.    */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_BLOCKCACHE
init|=
literal|true
decl_stmt|;
comment|/**    * Default setting for whether to cache data blocks on write if block caching    * is enabled.    */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_CACHE_DATA_ON_WRITE
init|=
literal|false
decl_stmt|;
comment|/**    * Default setting for whether to cache data blocks in L1 tier.  Only makes sense if more than    * one tier in operations: i.e. if we have an L1 and a L2.  This will be the cases if we are    * using BucketCache.    */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_CACHE_DATA_IN_L1
init|=
literal|false
decl_stmt|;
comment|/**    * Default setting for whether to cache index blocks on write if block    * caching is enabled.    */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_CACHE_INDEX_ON_WRITE
init|=
literal|false
decl_stmt|;
comment|/**    * Default size of blocks in files stored to the filesytem (hfiles).    */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_BLOCKSIZE
init|=
name|HConstants
operator|.
name|DEFAULT_BLOCKSIZE
decl_stmt|;
comment|/**    * Default setting for whether or not to use bloomfilters.    */
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_BLOOMFILTER
init|=
name|BloomType
operator|.
name|ROW
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|/**    * Default setting for whether to cache bloom filter blocks on write if block    * caching is enabled.    */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_CACHE_BLOOMS_ON_WRITE
init|=
literal|false
decl_stmt|;
comment|/**    * Default time to live of cell contents.    */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_TTL
init|=
name|HConstants
operator|.
name|FOREVER
decl_stmt|;
comment|/**    * Default scope.    */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_REPLICATION_SCOPE
init|=
name|HConstants
operator|.
name|REPLICATION_SCOPE_LOCAL
decl_stmt|;
comment|/**    * Default setting for whether to evict cached blocks from the blockcache on    * close.    */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_EVICT_BLOCKS_ON_CLOSE
init|=
literal|false
decl_stmt|;
comment|/**    * Default compress tags along with any type of DataBlockEncoding.    */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_COMPRESS_TAGS
init|=
literal|true
decl_stmt|;
comment|/*    * Default setting for whether to prefetch blocks into the blockcache on open.    */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_PREFETCH_BLOCKS_ON_OPEN
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|DEFAULT_VALUES
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|Set
argument_list|<
name|Bytes
argument_list|>
name|RESERVED_KEYWORDS
init|=
operator|new
name|HashSet
argument_list|<
name|Bytes
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|BLOOMFILTER
argument_list|,
name|DEFAULT_BLOOMFILTER
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|REPLICATION_SCOPE
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_REPLICATION_SCOPE
argument_list|)
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|HConstants
operator|.
name|VERSIONS
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_VERSIONS
argument_list|)
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|MIN_VERSIONS
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_MIN_VERSIONS
argument_list|)
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|COMPRESSION
argument_list|,
name|DEFAULT_COMPRESSION
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|TTL
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_TTL
argument_list|)
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|BLOCKSIZE
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_BLOCKSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|HConstants
operator|.
name|IN_MEMORY
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_IN_MEMORY
argument_list|)
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|BLOCKCACHE
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_BLOCKCACHE
argument_list|)
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|KEEP_DELETED_CELLS
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_KEEP_DELETED
argument_list|)
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|DATA_BLOCK_ENCODING
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_DATA_BLOCK_ENCODING
argument_list|)
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|CACHE_DATA_ON_WRITE
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_CACHE_DATA_ON_WRITE
argument_list|)
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|CACHE_DATA_IN_L1
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_CACHE_DATA_IN_L1
argument_list|)
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|CACHE_INDEX_ON_WRITE
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_CACHE_INDEX_ON_WRITE
argument_list|)
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|CACHE_BLOOMS_ON_WRITE
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_CACHE_BLOOMS_ON_WRITE
argument_list|)
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|EVICT_BLOCKS_ON_CLOSE
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_EVICT_BLOCKS_ON_CLOSE
argument_list|)
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|PREFETCH_BLOCKS_ON_OPEN
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_PREFETCH_BLOCKS_ON_OPEN
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|DEFAULT_VALUES
operator|.
name|keySet
argument_list|()
control|)
block|{
name|RESERVED_KEYWORDS
operator|.
name|add
argument_list|(
operator|new
name|Bytes
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RESERVED_KEYWORDS
operator|.
name|add
argument_list|(
operator|new
name|Bytes
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|ENCRYPTION
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RESERVED_KEYWORDS
operator|.
name|add
argument_list|(
operator|new
name|Bytes
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|ENCRYPTION_KEY
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RESERVED_KEYWORDS
operator|.
name|add
argument_list|(
operator|new
name|Bytes
argument_list|(
name|IS_MOB_BYTES
argument_list|)
argument_list|)
expr_stmt|;
name|RESERVED_KEYWORDS
operator|.
name|add
argument_list|(
operator|new
name|Bytes
argument_list|(
name|MOB_THRESHOLD_BYTES
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
specifier|final
name|int
name|UNINITIALIZED
init|=
operator|-
literal|1
decl_stmt|;
comment|// Column family name
specifier|private
name|byte
index|[]
name|name
decl_stmt|;
comment|// Column metadata
specifier|private
specifier|final
name|Map
argument_list|<
name|Bytes
argument_list|,
name|Bytes
argument_list|>
name|values
init|=
operator|new
name|HashMap
argument_list|<
name|Bytes
argument_list|,
name|Bytes
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * A map which holds the configuration specific to the column family.    * The keys of the map have the same names as config keys and override the defaults with    * cf-specific settings. Example usage may be for compactions, etc.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|configuration
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|/*    * Cache the max versions rather than calculate it every time.    */
specifier|private
name|int
name|cachedMaxVersions
init|=
name|UNINITIALIZED
decl_stmt|;
comment|/**    * Default constructor. Must be present for PB deserializations.    */
specifier|private
name|HColumnDescriptor
parameter_list|()
block|{
name|this
operator|.
name|name
operator|=
literal|null
expr_stmt|;
block|}
comment|/**    * Construct a column descriptor specifying only the family name    * The other attributes are defaulted.    *    * @param familyName Column family name. Must be 'printable' -- digit or    * letter -- and may not contain a<code>:</code>    */
specifier|public
name|HColumnDescriptor
parameter_list|(
specifier|final
name|String
name|familyName
parameter_list|)
block|{
name|this
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|familyName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct a column descriptor specifying only the family name    * The other attributes are defaulted.    *    * @param familyName Column family name. Must be 'printable' -- digit or    * letter -- and may not contain a<code>:</code>    */
specifier|public
name|HColumnDescriptor
parameter_list|(
specifier|final
name|byte
index|[]
name|familyName
parameter_list|)
block|{
name|isLegalFamilyName
argument_list|(
name|familyName
argument_list|)
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|familyName
expr_stmt|;
name|setMaxVersions
argument_list|(
name|DEFAULT_VERSIONS
argument_list|)
expr_stmt|;
name|setMinVersions
argument_list|(
name|DEFAULT_MIN_VERSIONS
argument_list|)
expr_stmt|;
name|setKeepDeletedCells
argument_list|(
name|DEFAULT_KEEP_DELETED
argument_list|)
expr_stmt|;
name|setInMemory
argument_list|(
name|DEFAULT_IN_MEMORY
argument_list|)
expr_stmt|;
name|setBlockCacheEnabled
argument_list|(
name|DEFAULT_BLOCKCACHE
argument_list|)
expr_stmt|;
name|setTimeToLive
argument_list|(
name|DEFAULT_TTL
argument_list|)
expr_stmt|;
name|setCompressionType
argument_list|(
name|Compression
operator|.
name|Algorithm
operator|.
name|valueOf
argument_list|(
name|DEFAULT_COMPRESSION
operator|.
name|toUpperCase
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|setDataBlockEncoding
argument_list|(
name|DataBlockEncoding
operator|.
name|valueOf
argument_list|(
name|DEFAULT_DATA_BLOCK_ENCODING
operator|.
name|toUpperCase
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|setBloomFilterType
argument_list|(
name|BloomType
operator|.
name|valueOf
argument_list|(
name|DEFAULT_BLOOMFILTER
operator|.
name|toUpperCase
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|setBlocksize
argument_list|(
name|DEFAULT_BLOCKSIZE
argument_list|)
expr_stmt|;
name|setScope
argument_list|(
name|DEFAULT_REPLICATION_SCOPE
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructor.    * Makes a deep copy of the supplied descriptor.    * Can make a modifiable descriptor from an UnmodifyableHColumnDescriptor.    * @param desc The descriptor.    */
specifier|public
name|HColumnDescriptor
parameter_list|(
name|HColumnDescriptor
name|desc
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|desc
operator|.
name|name
operator|.
name|clone
argument_list|()
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Bytes
argument_list|,
name|Bytes
argument_list|>
name|e
range|:
name|desc
operator|.
name|values
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|this
operator|.
name|values
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|e
range|:
name|desc
operator|.
name|configuration
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|this
operator|.
name|configuration
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|setMaxVersions
argument_list|(
name|desc
operator|.
name|getMaxVersions
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param b Family name.    * @return<code>b</code>    * @throws IllegalArgumentException If not null and not a legitimate family    * name: i.e. 'printable' and ends in a ':' (Null passes are allowed because    *<code>b</code> can be null when deserializing).  Cannot start with a '.'    * either. Also Family can not be an empty value or equal "recovered.edits".    */
specifier|public
specifier|static
name|byte
index|[]
name|isLegalFamilyName
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|)
block|{
if|if
condition|(
name|b
operator|==
literal|null
condition|)
block|{
return|return
name|b
return|;
block|}
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|b
operator|.
name|length
operator|!=
literal|0
argument_list|,
literal|"Family name can not be empty"
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Family names cannot start with a "
operator|+
literal|"period: "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|b
argument_list|)
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|b
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Character
operator|.
name|isISOControl
argument_list|(
name|b
index|[
name|i
index|]
argument_list|)
operator|||
name|b
index|[
name|i
index|]
operator|==
literal|':'
operator|||
name|b
index|[
name|i
index|]
operator|==
literal|'\\'
operator|||
name|b
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal character<"
operator|+
name|b
index|[
name|i
index|]
operator|+
literal|">. Family names cannot contain control characters or colons: "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|b
argument_list|)
argument_list|)
throw|;
block|}
block|}
name|byte
index|[]
name|recoveredEdit
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|HConstants
operator|.
name|RECOVERED_EDITS_DIR
argument_list|)
decl_stmt|;
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|recoveredEdit
argument_list|,
name|b
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Family name cannot be: "
operator|+
name|HConstants
operator|.
name|RECOVERED_EDITS_DIR
argument_list|)
throw|;
block|}
return|return
name|b
return|;
block|}
comment|/**    * @return Name of this column family    */
specifier|public
name|byte
index|[]
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
comment|/**    * @return Name of this column family    */
specifier|public
name|String
name|getNameAsString
parameter_list|()
block|{
return|return
name|Bytes
operator|.
name|toString
argument_list|(
name|this
operator|.
name|name
argument_list|)
return|;
block|}
comment|/**    * @param key The key.    * @return The value.    */
specifier|public
name|byte
index|[]
name|getValue
parameter_list|(
name|byte
index|[]
name|key
parameter_list|)
block|{
name|Bytes
name|ibw
init|=
name|values
operator|.
name|get
argument_list|(
operator|new
name|Bytes
argument_list|(
name|key
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ibw
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|ibw
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * @param key The key.    * @return The value as a string.    */
specifier|public
name|String
name|getValue
parameter_list|(
name|String
name|key
parameter_list|)
block|{
name|byte
index|[]
name|value
init|=
name|getValue
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|key
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|Bytes
operator|.
name|toString
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * @return All values.    */
specifier|public
name|Map
argument_list|<
name|Bytes
argument_list|,
name|Bytes
argument_list|>
name|getValues
parameter_list|()
block|{
comment|// shallow pointer copy
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|values
argument_list|)
return|;
block|}
comment|/**    * @param key The key.    * @param value The value.    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setValue
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|byte
index|[]
name|value
parameter_list|)
block|{
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|HConstants
operator|.
name|VERSIONS
argument_list|)
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cachedMaxVersions
operator|=
name|UNINITIALIZED
expr_stmt|;
block|}
name|values
operator|.
name|put
argument_list|(
operator|new
name|Bytes
argument_list|(
name|key
argument_list|)
argument_list|,
operator|new
name|Bytes
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * @param key Key whose key and value we're to remove from HCD parameters.    */
specifier|public
name|void
name|remove
parameter_list|(
specifier|final
name|byte
index|[]
name|key
parameter_list|)
block|{
name|values
operator|.
name|remove
argument_list|(
operator|new
name|Bytes
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param key The key.    * @param value The value.    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setValue
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|remove
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setValue
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|key
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/**    * @return compression type being used for the column family    * @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             (<a href="https://issues.apache.org/jira/browse/HBASE-13655">HBASE-13655</a>).    *             Use {@link #getCompressionType()}.    */
annotation|@
name|Deprecated
specifier|public
name|Compression
operator|.
name|Algorithm
name|getCompression
parameter_list|()
block|{
return|return
name|getCompressionType
argument_list|()
return|;
block|}
comment|/**    *  @return compression type being used for the column family for major compaction    *  @deprecated As of release 2.0.0, this will be removed in HBase 3.0.0    *             (<a href="https://issues.apache.org/jira/browse/HBASE-13655">HBASE-13655</a>).    *             Use {@link #getCompactionCompressionType()}.    */
annotation|@
name|Deprecated
specifier|public
name|Compression
operator|.
name|Algorithm
name|getCompactionCompression
parameter_list|()
block|{
return|return
name|getCompactionCompressionType
argument_list|()
return|;
block|}
comment|/** @return maximum number of versions */
specifier|public
name|int
name|getMaxVersions
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|cachedMaxVersions
operator|==
name|UNINITIALIZED
condition|)
block|{
name|String
name|v
init|=
name|getValue
argument_list|(
name|HConstants
operator|.
name|VERSIONS
argument_list|)
decl_stmt|;
name|this
operator|.
name|cachedMaxVersions
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
return|return
name|this
operator|.
name|cachedMaxVersions
return|;
block|}
comment|/**    * @param maxVersions maximum number of versions    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setMaxVersions
parameter_list|(
name|int
name|maxVersions
parameter_list|)
block|{
if|if
condition|(
name|maxVersions
operator|<=
literal|0
condition|)
block|{
comment|// TODO: Allow maxVersion of 0 to be the way you say "Keep all versions".
comment|// Until there is support, consider 0 or< 0 -- a configuration error.
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Maximum versions must be positive"
argument_list|)
throw|;
block|}
if|if
condition|(
name|maxVersions
operator|<
name|this
operator|.
name|getMinVersions
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Set MaxVersion to "
operator|+
name|maxVersions
operator|+
literal|" while minVersion is "
operator|+
name|this
operator|.
name|getMinVersions
argument_list|()
operator|+
literal|". Maximum versions must be>= minimum versions "
argument_list|)
throw|;
block|}
name|setValue
argument_list|(
name|HConstants
operator|.
name|VERSIONS
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|maxVersions
argument_list|)
argument_list|)
expr_stmt|;
name|cachedMaxVersions
operator|=
name|maxVersions
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Set minimum and maximum versions to keep    *    * @param minVersions minimal number of versions    * @param maxVersions maximum number of versions    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setVersions
parameter_list|(
name|int
name|minVersions
parameter_list|,
name|int
name|maxVersions
parameter_list|)
block|{
if|if
condition|(
name|minVersions
operator|<=
literal|0
condition|)
block|{
comment|// TODO: Allow minVersion and maxVersion of 0 to be the way you say "Keep all versions".
comment|// Until there is support, consider 0 or< 0 -- a configuration error.
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Minimum versions must be positive"
argument_list|)
throw|;
block|}
if|if
condition|(
name|maxVersions
operator|<
name|minVersions
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unable to set MaxVersion to "
operator|+
name|maxVersions
operator|+
literal|" and set MinVersion to "
operator|+
name|minVersions
operator|+
literal|", as maximum versions must be>= minimum versions."
argument_list|)
throw|;
block|}
name|setMinVersions
argument_list|(
name|minVersions
argument_list|)
expr_stmt|;
name|setMaxVersions
argument_list|(
name|maxVersions
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * @return The storefile/hfile blocksize for this column family.    */
specifier|public
specifier|synchronized
name|int
name|getBlocksize
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|blocksize
operator|==
literal|null
condition|)
block|{
name|String
name|value
init|=
name|getValue
argument_list|(
name|BLOCKSIZE
argument_list|)
decl_stmt|;
name|this
operator|.
name|blocksize
operator|=
operator|(
name|value
operator|!=
literal|null
operator|)
condition|?
name|Integer
operator|.
name|decode
argument_list|(
name|value
argument_list|)
else|:
name|Integer
operator|.
name|valueOf
argument_list|(
name|DEFAULT_BLOCKSIZE
argument_list|)
expr_stmt|;
block|}
return|return
name|this
operator|.
name|blocksize
operator|.
name|intValue
argument_list|()
return|;
block|}
comment|/**    * @param s Blocksize to use when writing out storefiles/hfiles on this    * column family.    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setBlocksize
parameter_list|(
name|int
name|s
parameter_list|)
block|{
name|setValue
argument_list|(
name|BLOCKSIZE
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|blocksize
operator|=
literal|null
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * @return Compression type setting.    */
specifier|public
name|Compression
operator|.
name|Algorithm
name|getCompressionType
parameter_list|()
block|{
name|String
name|n
init|=
name|getValue
argument_list|(
name|COMPRESSION
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|null
condition|)
block|{
return|return
name|Compression
operator|.
name|Algorithm
operator|.
name|NONE
return|;
block|}
return|return
name|Compression
operator|.
name|Algorithm
operator|.
name|valueOf
argument_list|(
name|n
operator|.
name|toUpperCase
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Compression types supported in hbase.    * LZO is not bundled as part of the hbase distribution.    * See<a href="http://wiki.apache.org/hadoop/UsingLzoCompression">LZO Compression</a>    * for how to enable it.    * @param type Compression type setting.    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setCompressionType
parameter_list|(
name|Compression
operator|.
name|Algorithm
name|type
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|COMPRESSION
argument_list|,
name|type
operator|.
name|getName
argument_list|()
operator|.
name|toUpperCase
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @return the data block encoding algorithm used in block cache and    *         optionally on disk    */
specifier|public
name|DataBlockEncoding
name|getDataBlockEncoding
parameter_list|()
block|{
name|String
name|type
init|=
name|getValue
argument_list|(
name|DATA_BLOCK_ENCODING
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
name|type
operator|=
name|DEFAULT_DATA_BLOCK_ENCODING
expr_stmt|;
block|}
return|return
name|DataBlockEncoding
operator|.
name|valueOf
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/**    * Set data block encoding algorithm used in block cache.    * @param type What kind of data block encoding will be used.    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setDataBlockEncoding
parameter_list|(
name|DataBlockEncoding
name|type
parameter_list|)
block|{
name|String
name|name
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
name|name
operator|=
name|type
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|DataBlockEncoding
operator|.
name|NONE
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
return|return
name|setValue
argument_list|(
name|DATA_BLOCK_ENCODING
argument_list|,
name|name
argument_list|)
return|;
block|}
comment|/**    * Set whether the tags should be compressed along with DataBlockEncoding. When no    * DataBlockEncoding is been used, this is having no effect.    *    * @param compressTags    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setCompressTags
parameter_list|(
name|boolean
name|compressTags
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|COMPRESS_TAGS
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|compressTags
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @return Whether KV tags should be compressed along with DataBlockEncoding. When no    *         DataBlockEncoding is been used, this is having no effect.    */
specifier|public
name|boolean
name|isCompressTags
parameter_list|()
block|{
name|String
name|compressTagsStr
init|=
name|getValue
argument_list|(
name|COMPRESS_TAGS
argument_list|)
decl_stmt|;
name|boolean
name|compressTags
init|=
name|DEFAULT_COMPRESS_TAGS
decl_stmt|;
if|if
condition|(
name|compressTagsStr
operator|!=
literal|null
condition|)
block|{
name|compressTags
operator|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|compressTagsStr
argument_list|)
expr_stmt|;
block|}
return|return
name|compressTags
return|;
block|}
comment|/**    * @return Compression type setting.    */
specifier|public
name|Compression
operator|.
name|Algorithm
name|getCompactionCompressionType
parameter_list|()
block|{
name|String
name|n
init|=
name|getValue
argument_list|(
name|COMPRESSION_COMPACT
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|null
condition|)
block|{
return|return
name|getCompressionType
argument_list|()
return|;
block|}
return|return
name|Compression
operator|.
name|Algorithm
operator|.
name|valueOf
argument_list|(
name|n
operator|.
name|toUpperCase
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Compression types supported in hbase.    * LZO is not bundled as part of the hbase distribution.    * See<a href="http://wiki.apache.org/hadoop/UsingLzoCompression">LZO Compression</a>    * for how to enable it.    * @param type Compression type setting.    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setCompactionCompressionType
parameter_list|(
name|Compression
operator|.
name|Algorithm
name|type
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|COMPRESSION_COMPACT
argument_list|,
name|type
operator|.
name|getName
argument_list|()
operator|.
name|toUpperCase
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @return True if we are to favor keeping all values for this column family in the    * HRegionServer cache.    */
specifier|public
name|boolean
name|isInMemory
parameter_list|()
block|{
name|String
name|value
init|=
name|getValue
argument_list|(
name|HConstants
operator|.
name|IN_MEMORY
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
return|return
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|value
argument_list|)
return|;
block|}
return|return
name|DEFAULT_IN_MEMORY
return|;
block|}
comment|/**    * @param inMemory True if we are to favor keeping all values for this column family in the    * HRegionServer cache    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setInMemory
parameter_list|(
name|boolean
name|inMemory
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|HConstants
operator|.
name|IN_MEMORY
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|inMemory
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|KeepDeletedCells
name|getKeepDeletedCells
parameter_list|()
block|{
name|String
name|value
init|=
name|getValue
argument_list|(
name|KEEP_DELETED_CELLS
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
comment|// toUpperCase for backwards compatibility
return|return
name|KeepDeletedCells
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|toUpperCase
argument_list|()
argument_list|)
return|;
block|}
return|return
name|DEFAULT_KEEP_DELETED
return|;
block|}
comment|/**    * @param keepDeletedCells True if deleted rows should not be collected    * immediately.    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setKeepDeletedCells
parameter_list|(
name|KeepDeletedCells
name|keepDeletedCells
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|KEEP_DELETED_CELLS
argument_list|,
name|keepDeletedCells
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @return Time-to-live of cell contents, in seconds.    */
specifier|public
name|int
name|getTimeToLive
parameter_list|()
block|{
name|String
name|value
init|=
name|getValue
argument_list|(
name|TTL
argument_list|)
decl_stmt|;
return|return
operator|(
name|value
operator|!=
literal|null
operator|)
condition|?
name|Integer
operator|.
name|parseInt
argument_list|(
name|value
argument_list|)
else|:
name|DEFAULT_TTL
return|;
block|}
comment|/**    * @param timeToLive Time-to-live of cell contents, in seconds.    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setTimeToLive
parameter_list|(
name|int
name|timeToLive
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|TTL
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|timeToLive
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @param timeToLive Time to live of cell contents, in human readable format    *                   @see org.apache.hadoop.hbase.util.PrettyPrinter#format(String, Unit)    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setTimeToLive
parameter_list|(
name|String
name|timeToLive
parameter_list|)
throws|throws
name|HBaseException
block|{
return|return
name|setValue
argument_list|(
name|TTL
argument_list|,
name|PrettyPrinter
operator|.
name|valueOf
argument_list|(
name|timeToLive
argument_list|,
name|Unit
operator|.
name|TIME_INTERVAL
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @return The minimum number of versions to keep.    */
specifier|public
name|int
name|getMinVersions
parameter_list|()
block|{
name|String
name|value
init|=
name|getValue
argument_list|(
name|MIN_VERSIONS
argument_list|)
decl_stmt|;
return|return
operator|(
name|value
operator|!=
literal|null
operator|)
condition|?
name|Integer
operator|.
name|parseInt
argument_list|(
name|value
argument_list|)
else|:
literal|0
return|;
block|}
comment|/**    * @param minVersions The minimum number of versions to keep.    * (used when timeToLive is set)    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setMinVersions
parameter_list|(
name|int
name|minVersions
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|MIN_VERSIONS
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|minVersions
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @return True if hfile DATA type blocks should be cached (You cannot disable caching of INDEX    * and BLOOM type blocks).    */
specifier|public
name|boolean
name|isBlockCacheEnabled
parameter_list|()
block|{
name|String
name|value
init|=
name|getValue
argument_list|(
name|BLOCKCACHE
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
return|return
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|value
argument_list|)
return|;
block|}
return|return
name|DEFAULT_BLOCKCACHE
return|;
block|}
comment|/**    * @param blockCacheEnabled True if hfile DATA type blocks should be cached (We always cache    * INDEX and BLOOM blocks; you cannot turn this off).    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setBlockCacheEnabled
parameter_list|(
name|boolean
name|blockCacheEnabled
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|BLOCKCACHE
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|blockCacheEnabled
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @return bloom filter type used for new StoreFiles in ColumnFamily    */
specifier|public
name|BloomType
name|getBloomFilterType
parameter_list|()
block|{
name|String
name|n
init|=
name|getValue
argument_list|(
name|BLOOMFILTER
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|null
condition|)
block|{
name|n
operator|=
name|DEFAULT_BLOOMFILTER
expr_stmt|;
block|}
return|return
name|BloomType
operator|.
name|valueOf
argument_list|(
name|n
operator|.
name|toUpperCase
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @param bt bloom filter type    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setBloomFilterType
parameter_list|(
specifier|final
name|BloomType
name|bt
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|BLOOMFILTER
argument_list|,
name|bt
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/**     * @return the scope tag     */
specifier|public
name|int
name|getScope
parameter_list|()
block|{
name|byte
index|[]
name|value
init|=
name|getValue
argument_list|(
name|REPLICATION_SCOPE_BYTES
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
return|return
name|DEFAULT_REPLICATION_SCOPE
return|;
block|}
comment|/**   * @param scope the scope tag   * @return this (for chained invocation)   */
specifier|public
name|HColumnDescriptor
name|setScope
parameter_list|(
name|int
name|scope
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|REPLICATION_SCOPE
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|scope
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @return true if we should cache data blocks on write    */
specifier|public
name|boolean
name|isCacheDataOnWrite
parameter_list|()
block|{
return|return
name|setAndGetBoolean
argument_list|(
name|CACHE_DATA_ON_WRITE
argument_list|,
name|DEFAULT_CACHE_DATA_ON_WRITE
argument_list|)
return|;
block|}
comment|/**    * @param value true if we should cache data blocks on write    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setCacheDataOnWrite
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|CACHE_DATA_ON_WRITE
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @return true if we should cache data blocks in the L1 cache (if block cache deploy has more    *         than one tier; e.g. we are using CombinedBlockCache).    */
specifier|public
name|boolean
name|isCacheDataInL1
parameter_list|()
block|{
return|return
name|setAndGetBoolean
argument_list|(
name|CACHE_DATA_IN_L1
argument_list|,
name|DEFAULT_CACHE_DATA_IN_L1
argument_list|)
return|;
block|}
comment|/**    * @param value true if we should cache data blocks in the L1 cache (if block cache deploy    * has more than one tier; e.g. we are using CombinedBlockCache).    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setCacheDataInL1
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|CACHE_DATA_IN_L1
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|setAndGetBoolean
parameter_list|(
specifier|final
name|String
name|key
parameter_list|,
specifier|final
name|boolean
name|defaultSetting
parameter_list|)
block|{
name|String
name|value
init|=
name|getValue
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
return|return
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|value
argument_list|)
return|;
block|}
return|return
name|defaultSetting
return|;
block|}
comment|/**    * @return true if we should cache index blocks on write    */
specifier|public
name|boolean
name|isCacheIndexesOnWrite
parameter_list|()
block|{
return|return
name|setAndGetBoolean
argument_list|(
name|CACHE_INDEX_ON_WRITE
argument_list|,
name|DEFAULT_CACHE_INDEX_ON_WRITE
argument_list|)
return|;
block|}
comment|/**    * @param value true if we should cache index blocks on write    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setCacheIndexesOnWrite
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|CACHE_INDEX_ON_WRITE
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @return true if we should cache bloomfilter blocks on write    */
specifier|public
name|boolean
name|isCacheBloomsOnWrite
parameter_list|()
block|{
return|return
name|setAndGetBoolean
argument_list|(
name|CACHE_BLOOMS_ON_WRITE
argument_list|,
name|DEFAULT_CACHE_BLOOMS_ON_WRITE
argument_list|)
return|;
block|}
comment|/**    * @param value true if we should cache bloomfilter blocks on write    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setCacheBloomsOnWrite
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|CACHE_BLOOMS_ON_WRITE
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @return true if we should evict cached blocks from the blockcache on close    */
specifier|public
name|boolean
name|isEvictBlocksOnClose
parameter_list|()
block|{
return|return
name|setAndGetBoolean
argument_list|(
name|EVICT_BLOCKS_ON_CLOSE
argument_list|,
name|DEFAULT_EVICT_BLOCKS_ON_CLOSE
argument_list|)
return|;
block|}
comment|/**    * @param value true if we should evict cached blocks from the blockcache on    * close    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setEvictBlocksOnClose
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|EVICT_BLOCKS_ON_CLOSE
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @return true if we should prefetch blocks into the blockcache on open    */
specifier|public
name|boolean
name|isPrefetchBlocksOnOpen
parameter_list|()
block|{
return|return
name|setAndGetBoolean
argument_list|(
name|PREFETCH_BLOCKS_ON_OPEN
argument_list|,
name|DEFAULT_PREFETCH_BLOCKS_ON_OPEN
argument_list|)
return|;
block|}
comment|/**    * @param value true if we should prefetch blocks into the blockcache on open    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setPrefetchBlocksOnOpen
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|PREFETCH_BLOCKS_ON_OPEN
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @see java.lang.Object#toString()    */
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|s
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|HConstants
operator|.
name|NAME
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|" => '"
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|getValues
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return
name|s
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * @return Column family descriptor with only the customized attributes.    */
specifier|public
name|String
name|toStringCustomizedValues
parameter_list|()
block|{
name|StringBuilder
name|s
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|HConstants
operator|.
name|NAME
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|" => '"
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|getValues
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return
name|s
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|StringBuilder
name|getValues
parameter_list|(
name|boolean
name|printDefaults
parameter_list|)
block|{
name|StringBuilder
name|s
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|boolean
name|hasConfigKeys
init|=
literal|false
decl_stmt|;
comment|// print all reserved keys first
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Bytes
argument_list|,
name|Bytes
argument_list|>
name|entry
range|:
name|values
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|RESERVED_KEYWORDS
operator|.
name|contains
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|hasConfigKeys
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
name|String
name|key
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|value
init|=
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|printDefaults
operator|||
operator|!
name|DEFAULT_VALUES
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
operator|||
operator|!
name|DEFAULT_VALUES
operator|.
name|get
argument_list|(
name|key
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|" => "
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
operator|.
name|append
argument_list|(
name|PrettyPrinter
operator|.
name|format
argument_list|(
name|value
argument_list|,
name|getUnit
argument_list|(
name|key
argument_list|)
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
block|}
comment|// print all non-reserved, advanced config keys as a separate subset
if|if
condition|(
name|hasConfigKeys
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|HConstants
operator|.
name|METADATA
argument_list|)
operator|.
name|append
argument_list|(
literal|" => "
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|boolean
name|printComma
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Bytes
name|k
range|:
name|values
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|RESERVED_KEYWORDS
operator|.
name|contains
argument_list|(
name|k
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|String
name|key
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|k
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|value
init|=
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|values
operator|.
name|get
argument_list|(
name|k
argument_list|)
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|printComma
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|printComma
operator|=
literal|true
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
operator|.
name|append
argument_list|(
name|key
argument_list|)
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|" => "
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
operator|.
name|append
argument_list|(
name|PrettyPrinter
operator|.
name|format
argument_list|(
name|value
argument_list|,
name|getUnit
argument_list|(
name|key
argument_list|)
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|configuration
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|HConstants
operator|.
name|CONFIGURATION
argument_list|)
operator|.
name|append
argument_list|(
literal|" => "
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|boolean
name|printCommaForConfiguration
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|e
range|:
name|configuration
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|printCommaForConfiguration
condition|)
name|s
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|printCommaForConfiguration
operator|=
literal|true
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
operator|.
name|append
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|" => "
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
operator|.
name|append
argument_list|(
name|PrettyPrinter
operator|.
name|format
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|,
name|getUnit
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
specifier|public
specifier|static
name|Unit
name|getUnit
parameter_list|(
name|String
name|key
parameter_list|)
block|{
name|Unit
name|unit
decl_stmt|;
comment|/* TTL for now, we can add more as we neeed */
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
name|HColumnDescriptor
operator|.
name|TTL
argument_list|)
condition|)
block|{
name|unit
operator|=
name|Unit
operator|.
name|TIME_INTERVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
name|HColumnDescriptor
operator|.
name|MOB_THRESHOLD
argument_list|)
condition|)
block|{
name|unit
operator|=
name|Unit
operator|.
name|LONG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
name|HColumnDescriptor
operator|.
name|IS_MOB
argument_list|)
condition|)
block|{
name|unit
operator|=
name|Unit
operator|.
name|BOOLEAN
expr_stmt|;
block|}
else|else
block|{
name|unit
operator|=
name|Unit
operator|.
name|NONE
expr_stmt|;
block|}
return|return
name|unit
return|;
block|}
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getDefaultValues
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|DEFAULT_VALUES
argument_list|)
return|;
block|}
comment|/**    * @see java.lang.Object#equals(java.lang.Object)    */
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|obj
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|obj
operator|instanceof
name|HColumnDescriptor
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|compareTo
argument_list|(
operator|(
name|HColumnDescriptor
operator|)
name|obj
argument_list|)
operator|==
literal|0
return|;
block|}
comment|/**    * @see java.lang.Object#hashCode()    */
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|result
init|=
name|Bytes
operator|.
name|hashCode
argument_list|(
name|this
operator|.
name|name
argument_list|)
decl_stmt|;
name|result
operator|^=
operator|(
name|int
operator|)
name|COLUMN_DESCRIPTOR_VERSION
expr_stmt|;
name|result
operator|^=
name|values
operator|.
name|hashCode
argument_list|()
expr_stmt|;
name|result
operator|^=
name|configuration
operator|.
name|hashCode
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
comment|// Comparable
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
name|HColumnDescriptor
name|o
parameter_list|)
block|{
name|int
name|result
init|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|this
operator|.
name|name
argument_list|,
name|o
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
comment|// punt on comparison for ordering, just calculate difference
name|result
operator|=
name|this
operator|.
name|values
operator|.
name|hashCode
argument_list|()
operator|-
name|o
operator|.
name|values
operator|.
name|hashCode
argument_list|()
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|result
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|result
operator|>
literal|0
condition|)
name|result
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|this
operator|.
name|configuration
operator|.
name|hashCode
argument_list|()
operator|-
name|o
operator|.
name|configuration
operator|.
name|hashCode
argument_list|()
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|result
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|result
operator|>
literal|0
condition|)
name|result
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * @return This instance serialized with pb with pb magic prefix    * @see #parseFrom(byte[])    */
specifier|public
name|byte
index|[]
name|toByteArray
parameter_list|()
block|{
return|return
name|ProtobufUtil
operator|.
name|prependPBMagic
argument_list|(
name|convert
argument_list|()
operator|.
name|toByteArray
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @param bytes A pb serialized {@link HColumnDescriptor} instance with pb magic prefix    * @return An instance of {@link HColumnDescriptor} made from<code>bytes</code>    * @throws DeserializationException    * @see #toByteArray()    */
specifier|public
specifier|static
name|HColumnDescriptor
name|parseFrom
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|)
throws|throws
name|DeserializationException
block|{
if|if
condition|(
operator|!
name|ProtobufUtil
operator|.
name|isPBMagicPrefix
argument_list|(
name|bytes
argument_list|)
condition|)
throw|throw
operator|new
name|DeserializationException
argument_list|(
literal|"No magic"
argument_list|)
throw|;
name|int
name|pblen
init|=
name|ProtobufUtil
operator|.
name|lengthOfPBMagic
argument_list|()
decl_stmt|;
name|ColumnFamilySchema
operator|.
name|Builder
name|builder
init|=
name|ColumnFamilySchema
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|ColumnFamilySchema
name|cfs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ProtobufUtil
operator|.
name|mergeFrom
argument_list|(
name|builder
argument_list|,
name|bytes
argument_list|,
name|pblen
argument_list|,
name|bytes
operator|.
name|length
operator|-
name|pblen
argument_list|)
expr_stmt|;
name|cfs
operator|=
name|builder
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DeserializationException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|convert
argument_list|(
name|cfs
argument_list|)
return|;
block|}
comment|/**    * @param cfs    * @return An {@link HColumnDescriptor} made from the passed in<code>cfs</code>    */
specifier|public
specifier|static
name|HColumnDescriptor
name|convert
parameter_list|(
specifier|final
name|ColumnFamilySchema
name|cfs
parameter_list|)
block|{
comment|// Use the empty constructor so we preserve the initial values set on construction for things
comment|// like maxVersion.  Otherwise, we pick up wrong values on deserialization which makes for
comment|// unrelated-looking test failures that are hard to trace back to here.
name|HColumnDescriptor
name|hcd
init|=
operator|new
name|HColumnDescriptor
argument_list|()
decl_stmt|;
name|hcd
operator|.
name|name
operator|=
name|cfs
operator|.
name|getName
argument_list|()
operator|.
name|toByteArray
argument_list|()
expr_stmt|;
for|for
control|(
name|BytesBytesPair
name|a
range|:
name|cfs
operator|.
name|getAttributesList
argument_list|()
control|)
block|{
name|hcd
operator|.
name|setValue
argument_list|(
name|a
operator|.
name|getFirst
argument_list|()
operator|.
name|toByteArray
argument_list|()
argument_list|,
name|a
operator|.
name|getSecond
argument_list|()
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|NameStringPair
name|a
range|:
name|cfs
operator|.
name|getConfigurationList
argument_list|()
control|)
block|{
name|hcd
operator|.
name|setConfiguration
argument_list|(
name|a
operator|.
name|getName
argument_list|()
argument_list|,
name|a
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|hcd
return|;
block|}
comment|/**    * @return Convert this instance to a the pb column family type    */
specifier|public
name|ColumnFamilySchema
name|convert
parameter_list|()
block|{
name|ColumnFamilySchema
operator|.
name|Builder
name|builder
init|=
name|ColumnFamilySchema
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|setName
argument_list|(
name|ByteStringer
operator|.
name|wrap
argument_list|(
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Bytes
argument_list|,
name|Bytes
argument_list|>
name|e
range|:
name|this
operator|.
name|values
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|BytesBytesPair
operator|.
name|Builder
name|aBuilder
init|=
name|BytesBytesPair
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|aBuilder
operator|.
name|setFirst
argument_list|(
name|ByteStringer
operator|.
name|wrap
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|get
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|aBuilder
operator|.
name|setSecond
argument_list|(
name|ByteStringer
operator|.
name|wrap
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|addAttributes
argument_list|(
name|aBuilder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|e
range|:
name|this
operator|.
name|configuration
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|NameStringPair
operator|.
name|Builder
name|aBuilder
init|=
name|NameStringPair
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|aBuilder
operator|.
name|setName
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|aBuilder
operator|.
name|setValue
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|addConfiguration
argument_list|(
name|aBuilder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Getter for accessing the configuration value by key.    */
specifier|public
name|String
name|getConfigurationValue
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
name|configuration
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|/**    * Getter for fetching an unmodifiable {@link #configuration} map.    */
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getConfiguration
parameter_list|()
block|{
comment|// shallow pointer copy
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|configuration
argument_list|)
return|;
block|}
comment|/**    * Setter for storing a configuration setting in {@link #configuration} map.    * @param key Config key. Same as XML config key e.g. hbase.something.or.other.    * @param value String value. If null, removes the configuration.    */
specifier|public
name|HColumnDescriptor
name|setConfiguration
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|removeConfiguration
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|configuration
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/**    * Remove a configuration setting represented by the key from the {@link #configuration} map.    */
specifier|public
name|void
name|removeConfiguration
parameter_list|(
specifier|final
name|String
name|key
parameter_list|)
block|{
name|configuration
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return the encryption algorithm in use by this family    */
specifier|public
name|String
name|getEncryptionType
parameter_list|()
block|{
return|return
name|getValue
argument_list|(
name|ENCRYPTION
argument_list|)
return|;
block|}
comment|/**    * Set the encryption algorithm for use with this family    * @param algorithm    */
specifier|public
name|HColumnDescriptor
name|setEncryptionType
parameter_list|(
name|String
name|algorithm
parameter_list|)
block|{
name|setValue
argument_list|(
name|ENCRYPTION
argument_list|,
name|algorithm
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Return the raw crypto key attribute for the family, or null if not set  */
specifier|public
name|byte
index|[]
name|getEncryptionKey
parameter_list|()
block|{
return|return
name|getValue
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|ENCRYPTION_KEY
argument_list|)
argument_list|)
return|;
block|}
comment|/** Set the raw crypto key attribute for the family */
specifier|public
name|HColumnDescriptor
name|setEncryptionKey
parameter_list|(
name|byte
index|[]
name|keyBytes
parameter_list|)
block|{
name|setValue
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|ENCRYPTION_KEY
argument_list|)
argument_list|,
name|keyBytes
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Gets the mob threshold of the family.    * If the size of a cell value is larger than this threshold, it's regarded as a mob.    * The default threshold is 1024*100(100K)B.    * @return The mob threshold.    */
specifier|public
name|long
name|getMobThreshold
parameter_list|()
block|{
name|byte
index|[]
name|threshold
init|=
name|getValue
argument_list|(
name|MOB_THRESHOLD_BYTES
argument_list|)
decl_stmt|;
return|return
name|threshold
operator|!=
literal|null
operator|&&
name|threshold
operator|.
name|length
operator|==
name|Bytes
operator|.
name|SIZEOF_LONG
condition|?
name|Bytes
operator|.
name|toLong
argument_list|(
name|threshold
argument_list|)
else|:
name|DEFAULT_MOB_THRESHOLD
return|;
block|}
comment|/**    * Sets the mob threshold of the family.    * @param threshold The mob threshold.    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setMobThreshold
parameter_list|(
name|long
name|threshold
parameter_list|)
block|{
name|setValue
argument_list|(
name|MOB_THRESHOLD_BYTES
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|threshold
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * Gets whether the mob is enabled for the family.    * @return True if the mob is enabled for the family.    */
specifier|public
name|boolean
name|isMobEnabled
parameter_list|()
block|{
name|byte
index|[]
name|isMobEnabled
init|=
name|getValue
argument_list|(
name|IS_MOB_BYTES
argument_list|)
decl_stmt|;
return|return
name|isMobEnabled
operator|!=
literal|null
operator|&&
name|isMobEnabled
operator|.
name|length
operator|==
name|Bytes
operator|.
name|SIZEOF_BOOLEAN
operator|&&
name|Bytes
operator|.
name|toBoolean
argument_list|(
name|isMobEnabled
argument_list|)
return|;
block|}
comment|/**    * Enables the mob for the family.    * @param isMobEnabled Whether to enable the mob for the family.    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setMobEnabled
parameter_list|(
name|boolean
name|isMobEnabled
parameter_list|)
block|{
name|setValue
argument_list|(
name|IS_MOB_BYTES
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|isMobEnabled
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * @return replication factor set for this CF or {@link #DEFAULT_DFS_REPLICATION} if not set.    *<p>    *         {@link #DEFAULT_DFS_REPLICATION} value indicates that user has explicitly not set any    *         block replication factor for this CF, hence use the default replication factor set in    *         the file system.    */
specifier|public
name|short
name|getDFSReplication
parameter_list|()
block|{
name|String
name|rf
init|=
name|getValue
argument_list|(
name|DFS_REPLICATION
argument_list|)
decl_stmt|;
return|return
name|rf
operator|==
literal|null
condition|?
name|DEFAULT_DFS_REPLICATION
else|:
name|Short
operator|.
name|valueOf
argument_list|(
name|rf
argument_list|)
return|;
block|}
comment|/**    * Set the replication factor to hfile(s) belonging to this family    * @param replication number of replicas the blocks(s) belonging to this CF should have, or    *          {@link #DEFAULT_DFS_REPLICATION} for the default replication factor set in the    *          filesystem    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setDFSReplication
parameter_list|(
name|short
name|replication
parameter_list|)
block|{
if|if
condition|(
name|replication
operator|<
literal|1
operator|&&
name|replication
operator|!=
name|DEFAULT_DFS_REPLICATION
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"DFS replication factor cannot be less than 1 if explictly set."
argument_list|)
throw|;
block|}
name|setValue
argument_list|(
name|DFS_REPLICATION
argument_list|,
name|Short
operator|.
name|toString
argument_list|(
name|replication
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
end_class

end_unit

