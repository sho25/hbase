begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|ByteString
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|InvalidProtocolBufferException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|DeserializationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|ImmutableBytesWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|compress
operator|.
name|Compression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|encoding
operator|.
name|DataBlockEncoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|BytesBytesPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|ColumnFamilySchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|NameStringPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|BloomType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableComparable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * An HColumnDescriptor contains information about a column family such as the  * number of versions, compression settings, etc.  *  * It is used as input when creating a table or adding a column. Once set, the  * parameters that specify a column cannot be changed without deleting the  * column and recreating it. If there is data stored in the column, it will be  * deleted when the column is deleted.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
class|class
name|HColumnDescriptor
implements|implements
name|WritableComparable
argument_list|<
name|HColumnDescriptor
argument_list|>
block|{
comment|// For future backward compatibility
comment|// Version  3 was when column names become byte arrays and when we picked up
comment|// Time-to-live feature.  Version 4 was when we moved to byte arrays, HBASE-82.
comment|// Version  5 was when bloom filter descriptors were removed.
comment|// Version  6 adds metadata as a map where keys and values are byte[].
comment|// Version  7 -- add new compression and hfile blocksize to HColumnDescriptor (HBASE-1217)
comment|// Version  8 -- reintroduction of bloom filters, changed from boolean to enum
comment|// Version  9 -- add data block encoding
comment|// Version 10 -- change metadata to standard type.
comment|// Version 11 -- add column family level configuration.
specifier|private
specifier|static
specifier|final
name|byte
name|COLUMN_DESCRIPTOR_VERSION
init|=
operator|(
name|byte
operator|)
literal|11
decl_stmt|;
comment|// These constants are used as FileInfo keys
specifier|public
specifier|static
specifier|final
name|String
name|COMPRESSION
init|=
literal|"COMPRESSION"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|COMPRESSION_COMPACT
init|=
literal|"COMPRESSION_COMPACT"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ENCODE_ON_DISK
init|=
literal|"ENCODE_ON_DISK"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|DATA_BLOCK_ENCODING
init|=
literal|"DATA_BLOCK_ENCODING"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|BLOCKCACHE
init|=
literal|"BLOCKCACHE"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|CACHE_DATA_ON_WRITE
init|=
literal|"CACHE_DATA_ON_WRITE"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|CACHE_INDEX_ON_WRITE
init|=
literal|"CACHE_INDEX_ON_WRITE"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|CACHE_BLOOMS_ON_WRITE
init|=
literal|"CACHE_BLOOMS_ON_WRITE"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|EVICT_BLOCKS_ON_CLOSE
init|=
literal|"EVICT_BLOCKS_ON_CLOSE"
decl_stmt|;
comment|/**    * Size of storefile/hfile 'blocks'.  Default is {@link #DEFAULT_BLOCKSIZE}.    * Use smaller block sizes for faster random-access at expense of larger    * indices (more memory consumption).    */
specifier|public
specifier|static
specifier|final
name|String
name|BLOCKSIZE
init|=
literal|"BLOCKSIZE"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|LENGTH
init|=
literal|"LENGTH"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|TTL
init|=
literal|"TTL"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|BLOOMFILTER
init|=
literal|"BLOOMFILTER"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|FOREVER
init|=
literal|"FOREVER"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|REPLICATION_SCOPE
init|=
literal|"REPLICATION_SCOPE"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|MIN_VERSIONS
init|=
literal|"MIN_VERSIONS"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|KEEP_DELETED_CELLS
init|=
literal|"KEEP_DELETED_CELLS"
decl_stmt|;
comment|/**    * Default compression type.    */
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_COMPRESSION
init|=
name|Compression
operator|.
name|Algorithm
operator|.
name|NONE
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|/**    * Default value of the flag that enables data block encoding on disk, as    * opposed to encoding in cache only. We encode blocks everywhere by default,    * as long as {@link #DATA_BLOCK_ENCODING} is not NONE.    */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_ENCODE_ON_DISK
init|=
literal|true
decl_stmt|;
comment|/** Default data block encoding algorithm. */
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_DATA_BLOCK_ENCODING
init|=
name|DataBlockEncoding
operator|.
name|NONE
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|/**    * Default number of versions of a record to keep.    */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_VERSIONS
init|=
literal|3
decl_stmt|;
comment|/**    * Default is not to keep a minimum of versions.    */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MIN_VERSIONS
init|=
literal|0
decl_stmt|;
comment|/*    * Cache here the HCD value.    * Question: its OK to cache since when we're reenable, we create a new HCD?    */
specifier|private
specifier|volatile
name|Integer
name|blocksize
init|=
literal|null
decl_stmt|;
comment|/**    * Default setting for whether to serve from memory or not.    */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_IN_MEMORY
init|=
literal|false
decl_stmt|;
comment|/**    * Default setting for preventing deleted from being collected immediately.    */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_KEEP_DELETED
init|=
literal|false
decl_stmt|;
comment|/**    * Default setting for whether to use a block cache or not.    */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_BLOCKCACHE
init|=
literal|true
decl_stmt|;
comment|/**    * Default setting for whether to cache data blocks on write if block caching    * is enabled.    */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_CACHE_DATA_ON_WRITE
init|=
literal|false
decl_stmt|;
comment|/**    * Default setting for whether to cache index blocks on write if block    * caching is enabled.    */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_CACHE_INDEX_ON_WRITE
init|=
literal|false
decl_stmt|;
comment|/**    * Default size of blocks in files stored to the filesytem (hfiles).    */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_BLOCKSIZE
init|=
name|HConstants
operator|.
name|DEFAULT_BLOCKSIZE
decl_stmt|;
comment|/**    * Default setting for whether or not to use bloomfilters.    */
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_BLOOMFILTER
init|=
name|BloomType
operator|.
name|NONE
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|/**    * Default setting for whether to cache bloom filter blocks on write if block    * caching is enabled.    */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_CACHE_BLOOMS_ON_WRITE
init|=
literal|false
decl_stmt|;
comment|/**    * Default time to live of cell contents.    */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_TTL
init|=
name|HConstants
operator|.
name|FOREVER
decl_stmt|;
comment|/**    * Default scope.    */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_REPLICATION_SCOPE
init|=
name|HConstants
operator|.
name|REPLICATION_SCOPE_LOCAL
decl_stmt|;
comment|/**    * Default setting for whether to evict cached blocks from the blockcache on    * close.    */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_EVICT_BLOCKS_ON_CLOSE
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|DEFAULT_VALUES
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|Set
argument_list|<
name|ImmutableBytesWritable
argument_list|>
name|RESERVED_KEYWORDS
init|=
operator|new
name|HashSet
argument_list|<
name|ImmutableBytesWritable
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|BLOOMFILTER
argument_list|,
name|DEFAULT_BLOOMFILTER
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|REPLICATION_SCOPE
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_REPLICATION_SCOPE
argument_list|)
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|HConstants
operator|.
name|VERSIONS
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_VERSIONS
argument_list|)
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|MIN_VERSIONS
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_MIN_VERSIONS
argument_list|)
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|COMPRESSION
argument_list|,
name|DEFAULT_COMPRESSION
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|TTL
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_TTL
argument_list|)
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|BLOCKSIZE
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_BLOCKSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|HConstants
operator|.
name|IN_MEMORY
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_IN_MEMORY
argument_list|)
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|BLOCKCACHE
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_BLOCKCACHE
argument_list|)
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|KEEP_DELETED_CELLS
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_KEEP_DELETED
argument_list|)
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|ENCODE_ON_DISK
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_ENCODE_ON_DISK
argument_list|)
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|DATA_BLOCK_ENCODING
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_DATA_BLOCK_ENCODING
argument_list|)
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|CACHE_DATA_ON_WRITE
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_CACHE_DATA_ON_WRITE
argument_list|)
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|CACHE_INDEX_ON_WRITE
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_CACHE_INDEX_ON_WRITE
argument_list|)
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|CACHE_BLOOMS_ON_WRITE
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_CACHE_BLOOMS_ON_WRITE
argument_list|)
argument_list|)
expr_stmt|;
name|DEFAULT_VALUES
operator|.
name|put
argument_list|(
name|EVICT_BLOCKS_ON_CLOSE
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|DEFAULT_EVICT_BLOCKS_ON_CLOSE
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|DEFAULT_VALUES
operator|.
name|keySet
argument_list|()
control|)
block|{
name|RESERVED_KEYWORDS
operator|.
name|add
argument_list|(
operator|new
name|ImmutableBytesWritable
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|int
name|UNINITIALIZED
init|=
operator|-
literal|1
decl_stmt|;
comment|// Column family name
specifier|private
name|byte
index|[]
name|name
decl_stmt|;
comment|// Column metadata
specifier|private
specifier|final
name|Map
argument_list|<
name|ImmutableBytesWritable
argument_list|,
name|ImmutableBytesWritable
argument_list|>
name|values
init|=
operator|new
name|HashMap
argument_list|<
name|ImmutableBytesWritable
argument_list|,
name|ImmutableBytesWritable
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * A map which holds the configuration specific to the column family.    * The keys of the map have the same names as config keys and override the defaults with    * cf-specific settings. Example usage may be for compactions, etc.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|configuration
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|/*    * Cache the max versions rather than calculate it every time.    */
specifier|private
name|int
name|cachedMaxVersions
init|=
name|UNINITIALIZED
decl_stmt|;
comment|/**    * Default constructor. Must be present for Writable.    * @deprecated Used by Writables and Writables are going away.    */
annotation|@
name|Deprecated
comment|// Make this private rather than remove after deprecation period elapses.  Its needed by pb
comment|// deserializations.
specifier|public
name|HColumnDescriptor
parameter_list|()
block|{
name|this
operator|.
name|name
operator|=
literal|null
expr_stmt|;
block|}
comment|/**    * Construct a column descriptor specifying only the family name    * The other attributes are defaulted.    *    * @param familyName Column family name. Must be 'printable' -- digit or    * letter -- and may not contain a<code>:<code>    */
specifier|public
name|HColumnDescriptor
parameter_list|(
specifier|final
name|String
name|familyName
parameter_list|)
block|{
name|this
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|familyName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct a column descriptor specifying only the family name    * The other attributes are defaulted.    *    * @param familyName Column family name. Must be 'printable' -- digit or    * letter -- and may not contain a<code>:<code>    */
specifier|public
name|HColumnDescriptor
parameter_list|(
specifier|final
name|byte
index|[]
name|familyName
parameter_list|)
block|{
name|this
argument_list|(
name|familyName
operator|==
literal|null
operator|||
name|familyName
operator|.
name|length
operator|<=
literal|0
condition|?
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
else|:
name|familyName
argument_list|,
name|DEFAULT_VERSIONS
argument_list|,
name|DEFAULT_COMPRESSION
argument_list|,
name|DEFAULT_IN_MEMORY
argument_list|,
name|DEFAULT_BLOCKCACHE
argument_list|,
name|DEFAULT_TTL
argument_list|,
name|DEFAULT_BLOOMFILTER
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructor.    * Makes a deep copy of the supplied descriptor.    * Can make a modifiable descriptor from an UnmodifyableHColumnDescriptor.    * @param desc The descriptor.    */
specifier|public
name|HColumnDescriptor
parameter_list|(
name|HColumnDescriptor
name|desc
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|desc
operator|.
name|name
operator|.
name|clone
argument_list|()
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ImmutableBytesWritable
argument_list|,
name|ImmutableBytesWritable
argument_list|>
name|e
range|:
name|desc
operator|.
name|values
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|this
operator|.
name|values
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|e
range|:
name|desc
operator|.
name|configuration
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|this
operator|.
name|configuration
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|setMaxVersions
argument_list|(
name|desc
operator|.
name|getMaxVersions
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructor    * @param familyName Column family name. Must be 'printable' -- digit or    * letter -- and may not contain a<code>:<code>    * @param maxVersions Maximum number of versions to keep    * @param compression Compression type    * @param inMemory If true, column data should be kept in an HRegionServer's    * cache    * @param blockCacheEnabled If true, MapFile blocks should be cached    * @param timeToLive Time-to-live of cell contents, in seconds    * (use HConstants.FOREVER for unlimited TTL)    * @param bloomFilter Bloom filter type for this column    *    * @throws IllegalArgumentException if passed a family name that is made of    * other than 'word' characters: i.e.<code>[a-zA-Z_0-9]</code> or contains    * a<code>:</code>    * @throws IllegalArgumentException if the number of versions is&lt;= 0    * @deprecated use {@link #HColumnDescriptor(String)} and setters    */
annotation|@
name|Deprecated
specifier|public
name|HColumnDescriptor
parameter_list|(
specifier|final
name|byte
index|[]
name|familyName
parameter_list|,
specifier|final
name|int
name|maxVersions
parameter_list|,
specifier|final
name|String
name|compression
parameter_list|,
specifier|final
name|boolean
name|inMemory
parameter_list|,
specifier|final
name|boolean
name|blockCacheEnabled
parameter_list|,
specifier|final
name|int
name|timeToLive
parameter_list|,
specifier|final
name|String
name|bloomFilter
parameter_list|)
block|{
name|this
argument_list|(
name|familyName
argument_list|,
name|maxVersions
argument_list|,
name|compression
argument_list|,
name|inMemory
argument_list|,
name|blockCacheEnabled
argument_list|,
name|DEFAULT_BLOCKSIZE
argument_list|,
name|timeToLive
argument_list|,
name|bloomFilter
argument_list|,
name|DEFAULT_REPLICATION_SCOPE
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructor    * @param familyName Column family name. Must be 'printable' -- digit or    * letter -- and may not contain a<code>:<code>    * @param maxVersions Maximum number of versions to keep    * @param compression Compression type    * @param inMemory If true, column data should be kept in an HRegionServer's    * cache    * @param blockCacheEnabled If true, MapFile blocks should be cached    * @param blocksize Block size to use when writing out storefiles.  Use    * smaller block sizes for faster random-access at expense of larger indices    * (more memory consumption).  Default is usually 64k.    * @param timeToLive Time-to-live of cell contents, in seconds    * (use HConstants.FOREVER for unlimited TTL)    * @param bloomFilter Bloom filter type for this column    * @param scope The scope tag for this column    *    * @throws IllegalArgumentException if passed a family name that is made of    * other than 'word' characters: i.e.<code>[a-zA-Z_0-9]</code> or contains    * a<code>:</code>    * @throws IllegalArgumentException if the number of versions is&lt;= 0    * @deprecated use {@link #HColumnDescriptor(String)} and setters    */
annotation|@
name|Deprecated
specifier|public
name|HColumnDescriptor
parameter_list|(
specifier|final
name|byte
index|[]
name|familyName
parameter_list|,
specifier|final
name|int
name|maxVersions
parameter_list|,
specifier|final
name|String
name|compression
parameter_list|,
specifier|final
name|boolean
name|inMemory
parameter_list|,
specifier|final
name|boolean
name|blockCacheEnabled
parameter_list|,
specifier|final
name|int
name|blocksize
parameter_list|,
specifier|final
name|int
name|timeToLive
parameter_list|,
specifier|final
name|String
name|bloomFilter
parameter_list|,
specifier|final
name|int
name|scope
parameter_list|)
block|{
name|this
argument_list|(
name|familyName
argument_list|,
name|DEFAULT_MIN_VERSIONS
argument_list|,
name|maxVersions
argument_list|,
name|DEFAULT_KEEP_DELETED
argument_list|,
name|compression
argument_list|,
name|DEFAULT_ENCODE_ON_DISK
argument_list|,
name|DEFAULT_DATA_BLOCK_ENCODING
argument_list|,
name|inMemory
argument_list|,
name|blockCacheEnabled
argument_list|,
name|blocksize
argument_list|,
name|timeToLive
argument_list|,
name|bloomFilter
argument_list|,
name|scope
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructor    * @param familyName Column family name. Must be 'printable' -- digit or    * letter -- and may not contain a<code>:<code>    * @param minVersions Minimum number of versions to keep    * @param maxVersions Maximum number of versions to keep    * @param keepDeletedCells Whether to retain deleted cells until they expire    *        up to maxVersions versions.    * @param compression Compression type    * @param encodeOnDisk whether to use the specified data block encoding    *        on disk. If false, the encoding will be used in cache only.    * @param dataBlockEncoding data block encoding    * @param inMemory If true, column data should be kept in an HRegionServer's    * cache    * @param blockCacheEnabled If true, MapFile blocks should be cached    * @param blocksize Block size to use when writing out storefiles.  Use    * smaller blocksizes for faster random-access at expense of larger indices    * (more memory consumption).  Default is usually 64k.    * @param timeToLive Time-to-live of cell contents, in seconds    * (use HConstants.FOREVER for unlimited TTL)    * @param bloomFilter Bloom filter type for this column    * @param scope The scope tag for this column    *    * @throws IllegalArgumentException if passed a family name that is made of    * other than 'word' characters: i.e.<code>[a-zA-Z_0-9]</code> or contains    * a<code>:</code>    * @throws IllegalArgumentException if the number of versions is&lt;= 0    * @deprecated use {@link #HColumnDescriptor(String)} and setters    */
annotation|@
name|Deprecated
specifier|public
name|HColumnDescriptor
parameter_list|(
specifier|final
name|byte
index|[]
name|familyName
parameter_list|,
specifier|final
name|int
name|minVersions
parameter_list|,
specifier|final
name|int
name|maxVersions
parameter_list|,
specifier|final
name|boolean
name|keepDeletedCells
parameter_list|,
specifier|final
name|String
name|compression
parameter_list|,
specifier|final
name|boolean
name|encodeOnDisk
parameter_list|,
specifier|final
name|String
name|dataBlockEncoding
parameter_list|,
specifier|final
name|boolean
name|inMemory
parameter_list|,
specifier|final
name|boolean
name|blockCacheEnabled
parameter_list|,
specifier|final
name|int
name|blocksize
parameter_list|,
specifier|final
name|int
name|timeToLive
parameter_list|,
specifier|final
name|String
name|bloomFilter
parameter_list|,
specifier|final
name|int
name|scope
parameter_list|)
block|{
name|isLegalFamilyName
argument_list|(
name|familyName
argument_list|)
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|familyName
expr_stmt|;
if|if
condition|(
name|maxVersions
operator|<=
literal|0
condition|)
block|{
comment|// TODO: Allow maxVersion of 0 to be the way you say "Keep all versions".
comment|// Until there is support, consider 0 or< 0 -- a configuration error.
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Maximum versions must be positive"
argument_list|)
throw|;
block|}
if|if
condition|(
name|minVersions
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|timeToLive
operator|==
name|HConstants
operator|.
name|FOREVER
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Minimum versions requires TTL."
argument_list|)
throw|;
block|}
if|if
condition|(
name|minVersions
operator|>=
name|maxVersions
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Minimum versions must be< "
operator|+
literal|"maximum versions."
argument_list|)
throw|;
block|}
block|}
name|setMaxVersions
argument_list|(
name|maxVersions
argument_list|)
expr_stmt|;
name|setMinVersions
argument_list|(
name|minVersions
argument_list|)
expr_stmt|;
name|setKeepDeletedCells
argument_list|(
name|keepDeletedCells
argument_list|)
expr_stmt|;
name|setInMemory
argument_list|(
name|inMemory
argument_list|)
expr_stmt|;
name|setBlockCacheEnabled
argument_list|(
name|blockCacheEnabled
argument_list|)
expr_stmt|;
name|setTimeToLive
argument_list|(
name|timeToLive
argument_list|)
expr_stmt|;
name|setCompressionType
argument_list|(
name|Compression
operator|.
name|Algorithm
operator|.
name|valueOf
argument_list|(
name|compression
operator|.
name|toUpperCase
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|setEncodeOnDisk
argument_list|(
name|encodeOnDisk
argument_list|)
expr_stmt|;
name|setDataBlockEncoding
argument_list|(
name|DataBlockEncoding
operator|.
name|valueOf
argument_list|(
name|dataBlockEncoding
operator|.
name|toUpperCase
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|setBloomFilterType
argument_list|(
name|BloomType
operator|.
name|valueOf
argument_list|(
name|bloomFilter
operator|.
name|toUpperCase
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|setBlocksize
argument_list|(
name|blocksize
argument_list|)
expr_stmt|;
name|setScope
argument_list|(
name|scope
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param b Family name.    * @return<code>b</code>    * @throws IllegalArgumentException If not null and not a legitimate family    * name: i.e. 'printable' and ends in a ':' (Null passes are allowed because    *<code>b</code> can be null when deserializing).  Cannot start with a '.'    * either. Also Family can not be an empty value or equal "recovered.edits".    */
specifier|public
specifier|static
name|byte
index|[]
name|isLegalFamilyName
parameter_list|(
specifier|final
name|byte
index|[]
name|b
parameter_list|)
block|{
if|if
condition|(
name|b
operator|==
literal|null
condition|)
block|{
return|return
name|b
return|;
block|}
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|b
operator|.
name|length
operator|!=
literal|0
argument_list|,
literal|"Family name can not be empty"
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Family names cannot start with a "
operator|+
literal|"period: "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|b
argument_list|)
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|b
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Character
operator|.
name|isISOControl
argument_list|(
name|b
index|[
name|i
index|]
argument_list|)
operator|||
name|b
index|[
name|i
index|]
operator|==
literal|':'
operator|||
name|b
index|[
name|i
index|]
operator|==
literal|'\\'
operator|||
name|b
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal character<"
operator|+
name|b
index|[
name|i
index|]
operator|+
literal|">. Family names cannot contain control characters or colons: "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|b
argument_list|)
argument_list|)
throw|;
block|}
block|}
name|byte
index|[]
name|recoveredEdit
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|HConstants
operator|.
name|RECOVERED_EDITS_DIR
argument_list|)
decl_stmt|;
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|recoveredEdit
argument_list|,
name|b
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Family name cannot be: "
operator|+
name|HConstants
operator|.
name|RECOVERED_EDITS_DIR
argument_list|)
throw|;
block|}
return|return
name|b
return|;
block|}
comment|/**    * @return Name of this column family    */
specifier|public
name|byte
index|[]
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
comment|/**    * @return Name of this column family    */
specifier|public
name|String
name|getNameAsString
parameter_list|()
block|{
return|return
name|Bytes
operator|.
name|toString
argument_list|(
name|this
operator|.
name|name
argument_list|)
return|;
block|}
comment|/**    * @param key The key.    * @return The value.    */
specifier|public
name|byte
index|[]
name|getValue
parameter_list|(
name|byte
index|[]
name|key
parameter_list|)
block|{
name|ImmutableBytesWritable
name|ibw
init|=
name|values
operator|.
name|get
argument_list|(
operator|new
name|ImmutableBytesWritable
argument_list|(
name|key
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ibw
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|ibw
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * @param key The key.    * @return The value as a string.    */
specifier|public
name|String
name|getValue
parameter_list|(
name|String
name|key
parameter_list|)
block|{
name|byte
index|[]
name|value
init|=
name|getValue
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|key
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|Bytes
operator|.
name|toString
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**    * @return All values.    */
specifier|public
name|Map
argument_list|<
name|ImmutableBytesWritable
argument_list|,
name|ImmutableBytesWritable
argument_list|>
name|getValues
parameter_list|()
block|{
comment|// shallow pointer copy
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|values
argument_list|)
return|;
block|}
comment|/**    * @param key The key.    * @param value The value.    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setValue
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|byte
index|[]
name|value
parameter_list|)
block|{
name|values
operator|.
name|put
argument_list|(
operator|new
name|ImmutableBytesWritable
argument_list|(
name|key
argument_list|)
argument_list|,
operator|new
name|ImmutableBytesWritable
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * @param key Key whose key and value we're to remove from HCD parameters.    */
specifier|public
name|void
name|remove
parameter_list|(
specifier|final
name|byte
index|[]
name|key
parameter_list|)
block|{
name|values
operator|.
name|remove
argument_list|(
operator|new
name|ImmutableBytesWritable
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param key The key.    * @param value The value.    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setValue
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|remove
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setValue
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|key
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/** @return compression type being used for the column family */
specifier|public
name|Compression
operator|.
name|Algorithm
name|getCompression
parameter_list|()
block|{
name|String
name|n
init|=
name|getValue
argument_list|(
name|COMPRESSION
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|null
condition|)
block|{
return|return
name|Compression
operator|.
name|Algorithm
operator|.
name|NONE
return|;
block|}
return|return
name|Compression
operator|.
name|Algorithm
operator|.
name|valueOf
argument_list|(
name|n
operator|.
name|toUpperCase
argument_list|()
argument_list|)
return|;
block|}
comment|/** @return compression type being used for the column family for major        compression */
specifier|public
name|Compression
operator|.
name|Algorithm
name|getCompactionCompression
parameter_list|()
block|{
name|String
name|n
init|=
name|getValue
argument_list|(
name|COMPRESSION_COMPACT
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|null
condition|)
block|{
return|return
name|getCompression
argument_list|()
return|;
block|}
return|return
name|Compression
operator|.
name|Algorithm
operator|.
name|valueOf
argument_list|(
name|n
operator|.
name|toUpperCase
argument_list|()
argument_list|)
return|;
block|}
comment|/** @return maximum number of versions */
specifier|public
name|int
name|getMaxVersions
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|cachedMaxVersions
operator|==
name|UNINITIALIZED
condition|)
block|{
name|String
name|v
init|=
name|getValue
argument_list|(
name|HConstants
operator|.
name|VERSIONS
argument_list|)
decl_stmt|;
name|this
operator|.
name|cachedMaxVersions
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
return|return
name|this
operator|.
name|cachedMaxVersions
return|;
block|}
comment|/**    * @param maxVersions maximum number of versions    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setMaxVersions
parameter_list|(
name|int
name|maxVersions
parameter_list|)
block|{
name|setValue
argument_list|(
name|HConstants
operator|.
name|VERSIONS
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|maxVersions
argument_list|)
argument_list|)
expr_stmt|;
name|cachedMaxVersions
operator|=
name|maxVersions
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * @return The storefile/hfile blocksize for this column family.    */
specifier|public
specifier|synchronized
name|int
name|getBlocksize
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|blocksize
operator|==
literal|null
condition|)
block|{
name|String
name|value
init|=
name|getValue
argument_list|(
name|BLOCKSIZE
argument_list|)
decl_stmt|;
name|this
operator|.
name|blocksize
operator|=
operator|(
name|value
operator|!=
literal|null
operator|)
condition|?
name|Integer
operator|.
name|decode
argument_list|(
name|value
argument_list|)
else|:
name|Integer
operator|.
name|valueOf
argument_list|(
name|DEFAULT_BLOCKSIZE
argument_list|)
expr_stmt|;
block|}
return|return
name|this
operator|.
name|blocksize
operator|.
name|intValue
argument_list|()
return|;
block|}
comment|/**    * @param s Blocksize to use when writing out storefiles/hfiles on this    * column family.    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setBlocksize
parameter_list|(
name|int
name|s
parameter_list|)
block|{
name|setValue
argument_list|(
name|BLOCKSIZE
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|blocksize
operator|=
literal|null
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**    * @return Compression type setting.    */
specifier|public
name|Compression
operator|.
name|Algorithm
name|getCompressionType
parameter_list|()
block|{
return|return
name|getCompression
argument_list|()
return|;
block|}
comment|/**    * Compression types supported in hbase.    * LZO is not bundled as part of the hbase distribution.    * See<a href="http://wiki.apache.org/hadoop/UsingLzoCompression">LZO Compression</a>    * for how to enable it.    * @param type Compression type setting.    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setCompressionType
parameter_list|(
name|Compression
operator|.
name|Algorithm
name|type
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|COMPRESSION
argument_list|,
name|type
operator|.
name|getName
argument_list|()
operator|.
name|toUpperCase
argument_list|()
argument_list|)
return|;
block|}
comment|/** @return data block encoding algorithm used on disk */
specifier|public
name|DataBlockEncoding
name|getDataBlockEncodingOnDisk
parameter_list|()
block|{
name|String
name|encodeOnDiskStr
init|=
name|getValue
argument_list|(
name|ENCODE_ON_DISK
argument_list|)
decl_stmt|;
name|boolean
name|encodeOnDisk
decl_stmt|;
if|if
condition|(
name|encodeOnDiskStr
operator|==
literal|null
condition|)
block|{
name|encodeOnDisk
operator|=
name|DEFAULT_ENCODE_ON_DISK
expr_stmt|;
block|}
else|else
block|{
name|encodeOnDisk
operator|=
name|Boolean
operator|.
name|valueOf
argument_list|(
name|encodeOnDiskStr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|encodeOnDisk
condition|)
block|{
comment|// No encoding on disk.
return|return
name|DataBlockEncoding
operator|.
name|NONE
return|;
block|}
return|return
name|getDataBlockEncoding
argument_list|()
return|;
block|}
comment|/**    * Set the flag indicating that we only want to encode data block in cache    * but not on disk.    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setEncodeOnDisk
parameter_list|(
name|boolean
name|encodeOnDisk
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|ENCODE_ON_DISK
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|encodeOnDisk
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @return the data block encoding algorithm used in block cache and    *         optionally on disk    */
specifier|public
name|DataBlockEncoding
name|getDataBlockEncoding
parameter_list|()
block|{
name|String
name|type
init|=
name|getValue
argument_list|(
name|DATA_BLOCK_ENCODING
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
name|type
operator|=
name|DEFAULT_DATA_BLOCK_ENCODING
expr_stmt|;
block|}
return|return
name|DataBlockEncoding
operator|.
name|valueOf
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/**    * Set data block encoding algorithm used in block cache.    * @param type What kind of data block encoding will be used.    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setDataBlockEncoding
parameter_list|(
name|DataBlockEncoding
name|type
parameter_list|)
block|{
name|String
name|name
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
name|name
operator|=
name|type
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|DataBlockEncoding
operator|.
name|NONE
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
return|return
name|setValue
argument_list|(
name|DATA_BLOCK_ENCODING
argument_list|,
name|name
argument_list|)
return|;
block|}
comment|/**    * @return Compression type setting.    */
specifier|public
name|Compression
operator|.
name|Algorithm
name|getCompactionCompressionType
parameter_list|()
block|{
return|return
name|getCompactionCompression
argument_list|()
return|;
block|}
comment|/**    * Compression types supported in hbase.    * LZO is not bundled as part of the hbase distribution.    * See<a href="http://wiki.apache.org/hadoop/UsingLzoCompression">LZO Compression</a>    * for how to enable it.    * @param type Compression type setting.    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setCompactionCompressionType
parameter_list|(
name|Compression
operator|.
name|Algorithm
name|type
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|COMPRESSION_COMPACT
argument_list|,
name|type
operator|.
name|getName
argument_list|()
operator|.
name|toUpperCase
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @return True if we are to keep all in use HRegionServer cache.    */
specifier|public
name|boolean
name|isInMemory
parameter_list|()
block|{
name|String
name|value
init|=
name|getValue
argument_list|(
name|HConstants
operator|.
name|IN_MEMORY
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
return|return
name|Boolean
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
operator|.
name|booleanValue
argument_list|()
return|;
return|return
name|DEFAULT_IN_MEMORY
return|;
block|}
comment|/**    * @param inMemory True if we are to keep all values in the HRegionServer    * cache    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setInMemory
parameter_list|(
name|boolean
name|inMemory
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|HConstants
operator|.
name|IN_MEMORY
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|inMemory
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|getKeepDeletedCells
parameter_list|()
block|{
name|String
name|value
init|=
name|getValue
argument_list|(
name|KEEP_DELETED_CELLS
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
return|return
name|Boolean
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
operator|.
name|booleanValue
argument_list|()
return|;
block|}
return|return
name|DEFAULT_KEEP_DELETED
return|;
block|}
comment|/**    * @param keepDeletedCells True if deleted rows should not be collected    * immediately.    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setKeepDeletedCells
parameter_list|(
name|boolean
name|keepDeletedCells
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|KEEP_DELETED_CELLS
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|keepDeletedCells
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @return Time-to-live of cell contents, in seconds.    */
specifier|public
name|int
name|getTimeToLive
parameter_list|()
block|{
name|String
name|value
init|=
name|getValue
argument_list|(
name|TTL
argument_list|)
decl_stmt|;
return|return
operator|(
name|value
operator|!=
literal|null
operator|)
condition|?
name|Integer
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
operator|.
name|intValue
argument_list|()
else|:
name|DEFAULT_TTL
return|;
block|}
comment|/**    * @param timeToLive Time-to-live of cell contents, in seconds.    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setTimeToLive
parameter_list|(
name|int
name|timeToLive
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|TTL
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|timeToLive
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @return The minimum number of versions to keep.    */
specifier|public
name|int
name|getMinVersions
parameter_list|()
block|{
name|String
name|value
init|=
name|getValue
argument_list|(
name|MIN_VERSIONS
argument_list|)
decl_stmt|;
return|return
operator|(
name|value
operator|!=
literal|null
operator|)
condition|?
name|Integer
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
operator|.
name|intValue
argument_list|()
else|:
literal|0
return|;
block|}
comment|/**    * @param minVersions The minimum number of versions to keep.    * (used when timeToLive is set)    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setMinVersions
parameter_list|(
name|int
name|minVersions
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|MIN_VERSIONS
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|minVersions
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @return True if MapFile blocks should be cached.    */
specifier|public
name|boolean
name|isBlockCacheEnabled
parameter_list|()
block|{
name|String
name|value
init|=
name|getValue
argument_list|(
name|BLOCKCACHE
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
return|return
name|Boolean
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
operator|.
name|booleanValue
argument_list|()
return|;
return|return
name|DEFAULT_BLOCKCACHE
return|;
block|}
comment|/**    * @param blockCacheEnabled True if MapFile blocks should be cached.    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setBlockCacheEnabled
parameter_list|(
name|boolean
name|blockCacheEnabled
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|BLOCKCACHE
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|blockCacheEnabled
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @return bloom filter type used for new StoreFiles in ColumnFamily    */
specifier|public
name|BloomType
name|getBloomFilterType
parameter_list|()
block|{
name|String
name|n
init|=
name|getValue
argument_list|(
name|BLOOMFILTER
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|null
condition|)
block|{
name|n
operator|=
name|DEFAULT_BLOOMFILTER
expr_stmt|;
block|}
return|return
name|BloomType
operator|.
name|valueOf
argument_list|(
name|n
operator|.
name|toUpperCase
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @param bt bloom filter type    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setBloomFilterType
parameter_list|(
specifier|final
name|BloomType
name|bt
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|BLOOMFILTER
argument_list|,
name|bt
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/**     * @return the scope tag     */
specifier|public
name|int
name|getScope
parameter_list|()
block|{
name|String
name|value
init|=
name|getValue
argument_list|(
name|REPLICATION_SCOPE
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
return|return
name|Integer
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
operator|.
name|intValue
argument_list|()
return|;
block|}
return|return
name|DEFAULT_REPLICATION_SCOPE
return|;
block|}
comment|/**   * @param scope the scope tag   * @return this (for chained invocation)   */
specifier|public
name|HColumnDescriptor
name|setScope
parameter_list|(
name|int
name|scope
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|REPLICATION_SCOPE
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|scope
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @return true if we should cache data blocks on write    */
specifier|public
name|boolean
name|shouldCacheDataOnWrite
parameter_list|()
block|{
name|String
name|value
init|=
name|getValue
argument_list|(
name|CACHE_DATA_ON_WRITE
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
return|return
name|Boolean
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
operator|.
name|booleanValue
argument_list|()
return|;
block|}
return|return
name|DEFAULT_CACHE_DATA_ON_WRITE
return|;
block|}
comment|/**    * @param value true if we should cache data blocks on write    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setCacheDataOnWrite
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|CACHE_DATA_ON_WRITE
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @return true if we should cache index blocks on write    */
specifier|public
name|boolean
name|shouldCacheIndexesOnWrite
parameter_list|()
block|{
name|String
name|value
init|=
name|getValue
argument_list|(
name|CACHE_INDEX_ON_WRITE
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
return|return
name|Boolean
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
operator|.
name|booleanValue
argument_list|()
return|;
block|}
return|return
name|DEFAULT_CACHE_INDEX_ON_WRITE
return|;
block|}
comment|/**    * @param value true if we should cache index blocks on write    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setCacheIndexesOnWrite
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|CACHE_INDEX_ON_WRITE
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @return true if we should cache bloomfilter blocks on write    */
specifier|public
name|boolean
name|shouldCacheBloomsOnWrite
parameter_list|()
block|{
name|String
name|value
init|=
name|getValue
argument_list|(
name|CACHE_BLOOMS_ON_WRITE
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
return|return
name|Boolean
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
operator|.
name|booleanValue
argument_list|()
return|;
block|}
return|return
name|DEFAULT_CACHE_BLOOMS_ON_WRITE
return|;
block|}
comment|/**    * @param value true if we should cache bloomfilter blocks on write    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setCacheBloomsOnWrite
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|CACHE_BLOOMS_ON_WRITE
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @return true if we should evict cached blocks from the blockcache on    * close    */
specifier|public
name|boolean
name|shouldEvictBlocksOnClose
parameter_list|()
block|{
name|String
name|value
init|=
name|getValue
argument_list|(
name|EVICT_BLOCKS_ON_CLOSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
return|return
name|Boolean
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
operator|.
name|booleanValue
argument_list|()
return|;
block|}
return|return
name|DEFAULT_EVICT_BLOCKS_ON_CLOSE
return|;
block|}
comment|/**    * @param value true if we should evict cached blocks from the blockcache on    * close    * @return this (for chained invocation)    */
specifier|public
name|HColumnDescriptor
name|setEvictBlocksOnClose
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
return|return
name|setValue
argument_list|(
name|EVICT_BLOCKS_ON_CLOSE
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * @see java.lang.Object#toString()    */
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|s
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|HConstants
operator|.
name|NAME
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|" => '"
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|getValues
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return
name|s
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * @return Column family descriptor with only the customized attributes.    */
specifier|public
name|String
name|toStringCustomizedValues
parameter_list|()
block|{
name|StringBuilder
name|s
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|HConstants
operator|.
name|NAME
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|" => '"
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|getValues
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return
name|s
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|StringBuilder
name|getValues
parameter_list|(
name|boolean
name|printDefaults
parameter_list|)
block|{
name|StringBuilder
name|s
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|boolean
name|hasConfigKeys
init|=
literal|false
decl_stmt|;
comment|// print all reserved keys first
for|for
control|(
name|ImmutableBytesWritable
name|k
range|:
name|values
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|RESERVED_KEYWORDS
operator|.
name|contains
argument_list|(
name|k
argument_list|)
condition|)
block|{
name|hasConfigKeys
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
name|String
name|key
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|k
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|value
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|values
operator|.
name|get
argument_list|(
name|k
argument_list|)
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|printDefaults
operator|||
operator|!
name|DEFAULT_VALUES
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
operator|||
operator|!
name|DEFAULT_VALUES
operator|.
name|get
argument_list|(
name|key
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|" => "
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
operator|.
name|append
argument_list|(
name|value
argument_list|)
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
block|}
comment|// print all non-reserved, advanced config keys as a separate subset
if|if
condition|(
name|hasConfigKeys
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|HConstants
operator|.
name|METADATA
argument_list|)
operator|.
name|append
argument_list|(
literal|" => "
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|boolean
name|printComma
init|=
literal|false
decl_stmt|;
for|for
control|(
name|ImmutableBytesWritable
name|k
range|:
name|values
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|RESERVED_KEYWORDS
operator|.
name|contains
argument_list|(
name|k
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|String
name|key
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|k
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|value
init|=
name|Bytes
operator|.
name|toString
argument_list|(
name|values
operator|.
name|get
argument_list|(
name|k
argument_list|)
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|printComma
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|printComma
operator|=
literal|true
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
operator|.
name|append
argument_list|(
name|key
argument_list|)
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|" => "
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
operator|.
name|append
argument_list|(
name|value
argument_list|)
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|configuration
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|HConstants
operator|.
name|CONFIGURATION
argument_list|)
operator|.
name|append
argument_list|(
literal|" => "
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|boolean
name|printCommaForConfiguration
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|e
range|:
name|configuration
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|printCommaForConfiguration
condition|)
name|s
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|printCommaForConfiguration
operator|=
literal|true
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
operator|.
name|append
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|" => "
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
operator|.
name|append
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getDefaultValues
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|DEFAULT_VALUES
argument_list|)
return|;
block|}
comment|/**    * @see java.lang.Object#equals(java.lang.Object)    */
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|obj
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|obj
operator|instanceof
name|HColumnDescriptor
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|compareTo
argument_list|(
operator|(
name|HColumnDescriptor
operator|)
name|obj
argument_list|)
operator|==
literal|0
return|;
block|}
comment|/**    * @see java.lang.Object#hashCode()    */
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|result
init|=
name|Bytes
operator|.
name|hashCode
argument_list|(
name|this
operator|.
name|name
argument_list|)
decl_stmt|;
name|result
operator|^=
name|Byte
operator|.
name|valueOf
argument_list|(
name|COLUMN_DESCRIPTOR_VERSION
argument_list|)
operator|.
name|hashCode
argument_list|()
expr_stmt|;
name|result
operator|^=
name|values
operator|.
name|hashCode
argument_list|()
expr_stmt|;
name|result
operator|^=
name|configuration
operator|.
name|hashCode
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * @deprecated Writables are going away.  Use pb {@link #parseFrom(byte[])} instead.    */
annotation|@
name|Deprecated
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|version
init|=
name|in
operator|.
name|readByte
argument_list|()
decl_stmt|;
if|if
condition|(
name|version
operator|<
literal|6
condition|)
block|{
if|if
condition|(
name|version
operator|<=
literal|2
condition|)
block|{
name|Text
name|t
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
name|t
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|t
operator|.
name|getBytes
argument_list|()
expr_stmt|;
comment|//        if(KeyValue.getFamilyDelimiterIndex(this.name, 0, this.name.length)
comment|//> 0) {
comment|//          this.name = stripColon(this.name);
comment|//        }
block|}
else|else
block|{
name|this
operator|.
name|name
operator|=
name|Bytes
operator|.
name|readByteArray
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|values
operator|.
name|clear
argument_list|()
expr_stmt|;
name|setMaxVersions
argument_list|(
name|in
operator|.
name|readInt
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|ordinal
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|setCompressionType
argument_list|(
name|Compression
operator|.
name|Algorithm
operator|.
name|values
argument_list|()
index|[
name|ordinal
index|]
argument_list|)
expr_stmt|;
name|setInMemory
argument_list|(
name|in
operator|.
name|readBoolean
argument_list|()
argument_list|)
expr_stmt|;
name|setBloomFilterType
argument_list|(
name|in
operator|.
name|readBoolean
argument_list|()
condition|?
name|BloomType
operator|.
name|ROW
else|:
name|BloomType
operator|.
name|NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|getBloomFilterType
argument_list|()
operator|!=
name|BloomType
operator|.
name|NONE
operator|&&
name|version
operator|<
literal|5
condition|)
block|{
comment|// If a bloomFilter is enabled and the column descriptor is less than
comment|// version 5, we need to skip over it to read the rest of the column
comment|// descriptor. There are no BloomFilterDescriptors written to disk for
comment|// column descriptors with a version number>= 5
throw|throw
operator|new
name|UnsupportedClassVersionError
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" does not support backward compatibility with versions older "
operator|+
literal|"than version 5"
argument_list|)
throw|;
block|}
if|if
condition|(
name|version
operator|>
literal|1
condition|)
block|{
name|setBlockCacheEnabled
argument_list|(
name|in
operator|.
name|readBoolean
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|version
operator|>
literal|2
condition|)
block|{
name|setTimeToLive
argument_list|(
name|in
operator|.
name|readInt
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// version 6+
name|this
operator|.
name|name
operator|=
name|Bytes
operator|.
name|readByteArray
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|this
operator|.
name|values
operator|.
name|clear
argument_list|()
expr_stmt|;
name|int
name|numValues
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numValues
condition|;
name|i
operator|++
control|)
block|{
name|ImmutableBytesWritable
name|key
init|=
operator|new
name|ImmutableBytesWritable
argument_list|()
decl_stmt|;
name|ImmutableBytesWritable
name|value
init|=
operator|new
name|ImmutableBytesWritable
argument_list|()
decl_stmt|;
name|key
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|value
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
comment|// in version 8, the BloomFilter setting changed from bool to enum
if|if
condition|(
name|version
operator|<
literal|8
operator|&&
name|Bytes
operator|.
name|toString
argument_list|(
name|key
operator|.
name|get
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
name|BLOOMFILTER
argument_list|)
condition|)
block|{
name|value
operator|.
name|set
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|Boolean
operator|.
name|getBoolean
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|value
operator|.
name|get
argument_list|()
argument_list|)
argument_list|)
condition|?
name|BloomType
operator|.
name|ROW
operator|.
name|toString
argument_list|()
else|:
name|BloomType
operator|.
name|NONE
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|values
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|version
operator|==
literal|6
condition|)
block|{
comment|// Convert old values.
name|setValue
argument_list|(
name|COMPRESSION
argument_list|,
name|Compression
operator|.
name|Algorithm
operator|.
name|NONE
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|String
name|value
init|=
name|getValue
argument_list|(
name|HConstants
operator|.
name|VERSIONS
argument_list|)
decl_stmt|;
name|this
operator|.
name|cachedMaxVersions
operator|=
operator|(
name|value
operator|!=
literal|null
operator|)
condition|?
name|Integer
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
operator|.
name|intValue
argument_list|()
else|:
name|DEFAULT_VERSIONS
expr_stmt|;
if|if
condition|(
name|version
operator|>
literal|10
condition|)
block|{
name|configuration
operator|.
name|clear
argument_list|()
expr_stmt|;
name|int
name|numConfigs
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numConfigs
condition|;
name|i
operator|++
control|)
block|{
name|ImmutableBytesWritable
name|key
init|=
operator|new
name|ImmutableBytesWritable
argument_list|()
decl_stmt|;
name|ImmutableBytesWritable
name|val
init|=
operator|new
name|ImmutableBytesWritable
argument_list|()
decl_stmt|;
name|key
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|val
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|configuration
operator|.
name|put
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|key
operator|.
name|get
argument_list|()
argument_list|,
name|key
operator|.
name|getOffset
argument_list|()
argument_list|,
name|key
operator|.
name|getLength
argument_list|()
argument_list|)
argument_list|,
name|Bytes
operator|.
name|toString
argument_list|(
name|val
operator|.
name|get
argument_list|()
argument_list|,
name|val
operator|.
name|getOffset
argument_list|()
argument_list|,
name|val
operator|.
name|getLength
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * @deprecated Writables are going away.  Use {@link #toByteArray()} instead.    */
annotation|@
name|Deprecated
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|writeByte
argument_list|(
name|COLUMN_DESCRIPTOR_VERSION
argument_list|)
expr_stmt|;
name|Bytes
operator|.
name|writeByteArray
argument_list|(
name|out
argument_list|,
name|this
operator|.
name|name
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|values
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ImmutableBytesWritable
argument_list|,
name|ImmutableBytesWritable
argument_list|>
name|e
range|:
name|values
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|writeInt
argument_list|(
name|configuration
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|e
range|:
name|configuration
operator|.
name|entrySet
argument_list|()
control|)
block|{
operator|new
name|ImmutableBytesWritable
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
operator|new
name|ImmutableBytesWritable
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Comparable
specifier|public
name|int
name|compareTo
parameter_list|(
name|HColumnDescriptor
name|o
parameter_list|)
block|{
name|int
name|result
init|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|this
operator|.
name|name
argument_list|,
name|o
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
comment|// punt on comparison for ordering, just calculate difference
name|result
operator|=
name|this
operator|.
name|values
operator|.
name|hashCode
argument_list|()
operator|-
name|o
operator|.
name|values
operator|.
name|hashCode
argument_list|()
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|result
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|result
operator|>
literal|0
condition|)
name|result
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|this
operator|.
name|configuration
operator|.
name|hashCode
argument_list|()
operator|-
name|o
operator|.
name|configuration
operator|.
name|hashCode
argument_list|()
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|result
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|result
operator|>
literal|0
condition|)
name|result
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * @return This instance serialized with pb with pb magic prefix    * @see #parseFrom(byte[])    */
specifier|public
name|byte
index|[]
name|toByteArray
parameter_list|()
block|{
return|return
name|ProtobufUtil
operator|.
name|prependPBMagic
argument_list|(
name|convert
argument_list|()
operator|.
name|toByteArray
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @param bytes A pb serialized {@link HColumnDescriptor} instance with pb magic prefix    * @return An instance of {@link HColumnDescriptor} made from<code>bytes</code>    * @throws DeserializationException    * @see #toByteArray()    */
specifier|public
specifier|static
name|HColumnDescriptor
name|parseFrom
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|)
throws|throws
name|DeserializationException
block|{
if|if
condition|(
operator|!
name|ProtobufUtil
operator|.
name|isPBMagicPrefix
argument_list|(
name|bytes
argument_list|)
condition|)
throw|throw
operator|new
name|DeserializationException
argument_list|(
literal|"No magic"
argument_list|)
throw|;
name|int
name|pblen
init|=
name|ProtobufUtil
operator|.
name|lengthOfPBMagic
argument_list|()
decl_stmt|;
name|ColumnFamilySchema
operator|.
name|Builder
name|builder
init|=
name|ColumnFamilySchema
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|ColumnFamilySchema
name|cfs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|cfs
operator|=
name|builder
operator|.
name|mergeFrom
argument_list|(
name|bytes
argument_list|,
name|pblen
argument_list|,
name|bytes
operator|.
name|length
operator|-
name|pblen
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidProtocolBufferException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DeserializationException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|convert
argument_list|(
name|cfs
argument_list|)
return|;
block|}
comment|/**    * @param cfs    * @return An {@link HColumnDescriptor} made from the passed in<code>cfs</code>    */
specifier|public
specifier|static
name|HColumnDescriptor
name|convert
parameter_list|(
specifier|final
name|ColumnFamilySchema
name|cfs
parameter_list|)
block|{
comment|// Use the empty constructor so we preserve the initial values set on construction for things
comment|// like maxVersion.  Otherwise, we pick up wrong values on deserialization which makes for
comment|// unrelated-looking test failures that are hard to trace back to here.
name|HColumnDescriptor
name|hcd
init|=
operator|new
name|HColumnDescriptor
argument_list|()
decl_stmt|;
name|hcd
operator|.
name|name
operator|=
name|cfs
operator|.
name|getName
argument_list|()
operator|.
name|toByteArray
argument_list|()
expr_stmt|;
for|for
control|(
name|BytesBytesPair
name|a
range|:
name|cfs
operator|.
name|getAttributesList
argument_list|()
control|)
block|{
name|hcd
operator|.
name|setValue
argument_list|(
name|a
operator|.
name|getFirst
argument_list|()
operator|.
name|toByteArray
argument_list|()
argument_list|,
name|a
operator|.
name|getSecond
argument_list|()
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|NameStringPair
name|a
range|:
name|cfs
operator|.
name|getConfigurationList
argument_list|()
control|)
block|{
name|hcd
operator|.
name|setConfiguration
argument_list|(
name|a
operator|.
name|getName
argument_list|()
argument_list|,
name|a
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|hcd
return|;
block|}
comment|/**    * @return Convert this instance to a the pb column family type    */
specifier|public
name|ColumnFamilySchema
name|convert
parameter_list|()
block|{
name|ColumnFamilySchema
operator|.
name|Builder
name|builder
init|=
name|ColumnFamilySchema
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|setName
argument_list|(
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ImmutableBytesWritable
argument_list|,
name|ImmutableBytesWritable
argument_list|>
name|e
range|:
name|this
operator|.
name|values
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|BytesBytesPair
operator|.
name|Builder
name|aBuilder
init|=
name|BytesBytesPair
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|aBuilder
operator|.
name|setFirst
argument_list|(
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|get
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|aBuilder
operator|.
name|setSecond
argument_list|(
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|addAttributes
argument_list|(
name|aBuilder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|e
range|:
name|this
operator|.
name|configuration
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|NameStringPair
operator|.
name|Builder
name|aBuilder
init|=
name|NameStringPair
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|aBuilder
operator|.
name|setName
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|aBuilder
operator|.
name|setValue
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|addConfiguration
argument_list|(
name|aBuilder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Getter for accessing the configuration value by key.    */
specifier|public
name|String
name|getConfigurationValue
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
name|configuration
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|/**    * Getter for fetching an unmodifiable {@link #configuration} map.    */
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getConfiguration
parameter_list|()
block|{
comment|// shallow pointer copy
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|configuration
argument_list|)
return|;
block|}
comment|/**    * Setter for storing a configuration setting in {@link #configuration} map.    * @param key Config key. Same as XML config key e.g. hbase.something.or.other.    * @param value String value. If null, removes the configuration.    */
specifier|public
name|void
name|setConfiguration
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|removeConfiguration
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|configuration
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Remove a configuration setting represented by the key from the {@link #configuration} map.    */
specifier|public
name|void
name|removeConfiguration
parameter_list|(
specifier|final
name|String
name|key
parameter_list|)
block|{
name|configuration
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

