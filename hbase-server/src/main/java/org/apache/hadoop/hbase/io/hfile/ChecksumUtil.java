begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ChecksumException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ChecksumType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DataChecksum
import|;
end_import

begin_comment
comment|/**  * Utility methods to compute and validate checksums.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|ChecksumUtil
block|{
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ChecksumUtil
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** This is used to reserve space in a byte buffer */
specifier|private
specifier|static
name|byte
index|[]
name|DUMMY_VALUE
init|=
operator|new
name|byte
index|[
literal|128
operator|*
name|HFileBlock
operator|.
name|CHECKSUM_SIZE
index|]
decl_stmt|;
comment|/**    * This is used by unit tests to make checksum failures throw an    * exception instead of returning null. Returning a null value from    * checksum validation will cause the higher layer to retry that    * read with hdfs-level checksums. Instead, we would like checksum    * failures to cause the entire unit test to fail.    */
specifier|private
specifier|static
name|boolean
name|generateExceptions
init|=
literal|false
decl_stmt|;
comment|/**    * Generates a checksum for all the data in indata. The checksum is    * written to outdata.    * @param indata input data stream    * @param startOffset starting offset in the indata stream from where to    *                    compute checkums from    * @param endOffset ending offset in the indata stream upto    *                   which checksums needs to be computed    * @param outdata the output buffer where checksum values are written    * @param outOffset the starting offset in the outdata where the    *                  checksum values are written    * @param checksumType type of checksum    * @param bytesPerChecksum number of bytes per checksum value    */
specifier|static
name|void
name|generateChecksums
parameter_list|(
name|byte
index|[]
name|indata
parameter_list|,
name|int
name|startOffset
parameter_list|,
name|int
name|endOffset
parameter_list|,
name|byte
index|[]
name|outdata
parameter_list|,
name|int
name|outOffset
parameter_list|,
name|ChecksumType
name|checksumType
parameter_list|,
name|int
name|bytesPerChecksum
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|checksumType
operator|==
name|ChecksumType
operator|.
name|NULL
condition|)
block|{
return|return;
comment|// No checksum for this block.
block|}
name|DataChecksum
name|checksum
init|=
name|DataChecksum
operator|.
name|newDataChecksum
argument_list|(
name|checksumType
operator|.
name|getDataChecksumType
argument_list|()
argument_list|,
name|bytesPerChecksum
argument_list|)
decl_stmt|;
name|checksum
operator|.
name|calculateChunkedSums
argument_list|(
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|indata
argument_list|,
name|startOffset
argument_list|,
name|endOffset
operator|-
name|startOffset
argument_list|)
argument_list|,
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|outdata
argument_list|,
name|outOffset
argument_list|,
name|outdata
operator|.
name|length
operator|-
name|outOffset
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Validates that the data in the specified HFileBlock matches the checksum. Generates the    * checksums for the data and then validate that it matches those stored in the end of the data.    * @param buffer Contains the data in following order: HFileBlock header, data, checksums.    * @param pathName Path of the HFile to which the {@code data} belongs. Only used for logging.    * @param offset offset of the data being validated. Only used for logging.    * @param hdrSize Size of the block header in {@code data}. Only used for logging.    * @return True if checksum matches, else false.    */
specifier|static
name|boolean
name|validateChecksum
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|,
name|String
name|pathName
parameter_list|,
name|long
name|offset
parameter_list|,
name|int
name|hdrSize
parameter_list|)
throws|throws
name|IOException
block|{
comment|// A ChecksumType.NULL indicates that the caller is not interested in validating checksums,
comment|// so we always return true.
name|ChecksumType
name|cktype
init|=
name|ChecksumType
operator|.
name|codeToType
argument_list|(
name|buffer
operator|.
name|get
argument_list|(
name|HFileBlock
operator|.
name|Header
operator|.
name|CHECKSUM_TYPE_INDEX
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cktype
operator|==
name|ChecksumType
operator|.
name|NULL
condition|)
block|{
return|return
literal|true
return|;
comment|// No checksum validations needed for this block.
block|}
comment|// read in the stored value of the checksum size from the header.
name|int
name|bytesPerChecksum
init|=
name|buffer
operator|.
name|getInt
argument_list|(
name|HFileBlock
operator|.
name|Header
operator|.
name|BYTES_PER_CHECKSUM_INDEX
argument_list|)
decl_stmt|;
name|DataChecksum
name|dataChecksum
init|=
name|DataChecksum
operator|.
name|newDataChecksum
argument_list|(
name|cktype
operator|.
name|getDataChecksumType
argument_list|()
argument_list|,
name|bytesPerChecksum
argument_list|)
decl_stmt|;
assert|assert
name|dataChecksum
operator|!=
literal|null
assert|;
name|int
name|onDiskDataSizeWithHeader
init|=
name|buffer
operator|.
name|getInt
argument_list|(
name|HFileBlock
operator|.
name|Header
operator|.
name|ON_DISK_DATA_SIZE_WITH_HEADER_INDEX
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"dataLength="
operator|+
name|buffer
operator|.
name|capacity
argument_list|()
operator|+
literal|", sizeWithHeader="
operator|+
name|onDiskDataSizeWithHeader
operator|+
literal|", checksumType="
operator|+
name|cktype
operator|.
name|getName
argument_list|()
operator|+
literal|", file="
operator|+
name|pathName
operator|+
literal|", offset="
operator|+
name|offset
operator|+
literal|", headerSize="
operator|+
name|hdrSize
operator|+
literal|", bytesPerChecksum="
operator|+
name|bytesPerChecksum
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|ByteBuffer
name|data
init|=
operator|(
name|ByteBuffer
operator|)
name|buffer
operator|.
name|duplicate
argument_list|()
operator|.
name|position
argument_list|(
literal|0
argument_list|)
operator|.
name|limit
argument_list|(
name|onDiskDataSizeWithHeader
argument_list|)
decl_stmt|;
name|ByteBuffer
name|checksums
init|=
operator|(
name|ByteBuffer
operator|)
name|buffer
operator|.
name|duplicate
argument_list|()
operator|.
name|position
argument_list|(
name|onDiskDataSizeWithHeader
argument_list|)
operator|.
name|limit
argument_list|(
name|buffer
operator|.
name|capacity
argument_list|()
argument_list|)
decl_stmt|;
name|dataChecksum
operator|.
name|verifyChunkedSums
argument_list|(
name|data
argument_list|,
name|checksums
argument_list|,
name|pathName
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ChecksumException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
comment|// checksum is valid
block|}
comment|/**    * Returns the number of bytes needed to store the checksums for    * a specified data size    * @param datasize number of bytes of data    * @param bytesPerChecksum number of bytes in a checksum chunk    * @return The number of bytes needed to store the checksum values    */
specifier|static
name|long
name|numBytes
parameter_list|(
name|long
name|datasize
parameter_list|,
name|int
name|bytesPerChecksum
parameter_list|)
block|{
return|return
name|numChunks
argument_list|(
name|datasize
argument_list|,
name|bytesPerChecksum
argument_list|)
operator|*
name|HFileBlock
operator|.
name|CHECKSUM_SIZE
return|;
block|}
comment|/**    * Returns the number of checksum chunks needed to store the checksums for    * a specified data size    * @param datasize number of bytes of data    * @param bytesPerChecksum number of bytes in a checksum chunk    * @return The number of checksum chunks    */
specifier|static
name|long
name|numChunks
parameter_list|(
name|long
name|datasize
parameter_list|,
name|int
name|bytesPerChecksum
parameter_list|)
block|{
name|long
name|numChunks
init|=
name|datasize
operator|/
name|bytesPerChecksum
decl_stmt|;
if|if
condition|(
name|datasize
operator|%
name|bytesPerChecksum
operator|!=
literal|0
condition|)
block|{
name|numChunks
operator|++
expr_stmt|;
block|}
return|return
name|numChunks
return|;
block|}
comment|/**    * Write dummy checksums to the end of the specified bytes array    * to reserve space for writing checksums later    * @param baos OutputStream to write dummy checkum values    * @param numBytes Number of bytes of data for which dummy checksums    *                 need to be generated    * @param bytesPerChecksum Number of bytes per checksum value    */
specifier|static
name|void
name|reserveSpaceForChecksums
parameter_list|(
name|ByteArrayOutputStream
name|baos
parameter_list|,
name|int
name|numBytes
parameter_list|,
name|int
name|bytesPerChecksum
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|numChunks
init|=
name|numChunks
argument_list|(
name|numBytes
argument_list|,
name|bytesPerChecksum
argument_list|)
decl_stmt|;
name|long
name|bytesLeft
init|=
name|numChunks
operator|*
name|HFileBlock
operator|.
name|CHECKSUM_SIZE
decl_stmt|;
while|while
condition|(
name|bytesLeft
operator|>
literal|0
condition|)
block|{
name|long
name|count
init|=
name|Math
operator|.
name|min
argument_list|(
name|bytesLeft
argument_list|,
name|DUMMY_VALUE
operator|.
name|length
argument_list|)
decl_stmt|;
name|baos
operator|.
name|write
argument_list|(
name|DUMMY_VALUE
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|count
argument_list|)
expr_stmt|;
name|bytesLeft
operator|-=
name|count
expr_stmt|;
block|}
block|}
comment|/**    * Mechanism to throw an exception in case of hbase checksum    * failure. This is used by unit tests only.    * @param value Setting this to true will cause hbase checksum    *              verification failures to generate exceptions.    */
specifier|public
specifier|static
name|void
name|generateExceptionForChecksumFailureForTest
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
name|generateExceptions
operator|=
name|value
expr_stmt|;
block|}
block|}
end_class

end_unit

