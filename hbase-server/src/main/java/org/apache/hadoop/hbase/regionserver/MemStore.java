begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|ManagementFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|RuntimeMXBean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|rmi
operator|.
name|UnexpectedException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValueUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Scan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|HeapSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|MemStoreLAB
operator|.
name|Allocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ClassSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|Cell
import|;
end_import

begin_comment
comment|/**  * The MemStore holds in-memory modifications to the Store.  Modifications  * are {@link KeyValue}s.  When asked to flush, current memstore is moved  * to snapshot and is cleared.  We continue to serve edits out of new memstore  * and backing snapshot until flusher reports in that the flush succeeded. At  * this point we let the snapshot go.  * TODO: Adjust size of the memstore when we remove items because they have  * been deleted.  * TODO: With new KVSLS, need to make sure we update HeapSize with difference  * in KV size.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|MemStore
implements|implements
name|HeapSize
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|MemStore
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|static
specifier|final
name|String
name|USEMSLAB_KEY
init|=
literal|"hbase.hregion.memstore.mslab.enabled"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|boolean
name|USEMSLAB_DEFAULT
init|=
literal|true
decl_stmt|;
specifier|private
name|Configuration
name|conf
decl_stmt|;
comment|// MemStore.  Use a KeyValueSkipListSet rather than SkipListSet because of the
comment|// better semantics.  The Map will overwrite if passed a key it already had
comment|// whereas the Set will not add new KV if key is same though value might be
comment|// different.  Value is not important -- just make sure always same
comment|// reference passed.
specifier|volatile
name|KeyValueSkipListSet
name|kvset
decl_stmt|;
comment|// Snapshot of memstore.  Made for flusher.
specifier|volatile
name|KeyValueSkipListSet
name|snapshot
decl_stmt|;
specifier|final
name|ReentrantReadWriteLock
name|lock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
specifier|final
name|KeyValue
operator|.
name|KVComparator
name|comparator
decl_stmt|;
comment|// Used comparing versions -- same r/c and ts but different type.
specifier|final
name|KeyValue
operator|.
name|KVComparator
name|comparatorIgnoreType
decl_stmt|;
comment|// Used comparing versions -- same r/c and type but different timestamp.
specifier|final
name|KeyValue
operator|.
name|KVComparator
name|comparatorIgnoreTimestamp
decl_stmt|;
comment|// Used to track own heapSize
specifier|final
name|AtomicLong
name|size
decl_stmt|;
name|TimeRangeTracker
name|timeRangeTracker
decl_stmt|;
name|TimeRangeTracker
name|snapshotTimeRangeTracker
decl_stmt|;
name|MemStoreLAB
name|allocator
decl_stmt|;
comment|/**    * Default constructor. Used for tests.    */
specifier|public
name|MemStore
parameter_list|()
block|{
name|this
argument_list|(
name|HBaseConfiguration
operator|.
name|create
argument_list|()
argument_list|,
name|KeyValue
operator|.
name|COMPARATOR
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructor.    * @param c Comparator    */
specifier|public
name|MemStore
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|KeyValue
operator|.
name|KVComparator
name|c
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|comparator
operator|=
name|c
expr_stmt|;
name|this
operator|.
name|comparatorIgnoreTimestamp
operator|=
name|this
operator|.
name|comparator
operator|.
name|getComparatorIgnoringTimestamps
argument_list|()
expr_stmt|;
name|this
operator|.
name|comparatorIgnoreType
operator|=
name|this
operator|.
name|comparator
operator|.
name|getComparatorIgnoringType
argument_list|()
expr_stmt|;
name|this
operator|.
name|kvset
operator|=
operator|new
name|KeyValueSkipListSet
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|this
operator|.
name|snapshot
operator|=
operator|new
name|KeyValueSkipListSet
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|timeRangeTracker
operator|=
operator|new
name|TimeRangeTracker
argument_list|()
expr_stmt|;
name|snapshotTimeRangeTracker
operator|=
operator|new
name|TimeRangeTracker
argument_list|()
expr_stmt|;
name|this
operator|.
name|size
operator|=
operator|new
name|AtomicLong
argument_list|(
name|DEEP_OVERHEAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|USEMSLAB_KEY
argument_list|,
name|USEMSLAB_DEFAULT
argument_list|)
condition|)
block|{
name|this
operator|.
name|allocator
operator|=
operator|new
name|MemStoreLAB
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|allocator
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|void
name|dump
parameter_list|()
block|{
for|for
control|(
name|KeyValue
name|kv
range|:
name|this
operator|.
name|kvset
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|kv
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|KeyValue
name|kv
range|:
name|this
operator|.
name|snapshot
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|kv
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Creates a snapshot of the current memstore.    * Snapshot must be cleared by call to {@link #clearSnapshot(SortedSet<KeyValue>)}    * To get the snapshot made by this method, use {@link #getSnapshot()}    */
name|void
name|snapshot
parameter_list|()
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// If snapshot currently has entries, then flusher failed or didn't call
comment|// cleanup.  Log a warning.
if|if
condition|(
operator|!
name|this
operator|.
name|snapshot
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Snapshot called again without clearing previous. "
operator|+
literal|"Doing nothing. Another ongoing flush or did we fail last attempt?"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|kvset
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|this
operator|.
name|snapshot
operator|=
name|this
operator|.
name|kvset
expr_stmt|;
name|this
operator|.
name|kvset
operator|=
operator|new
name|KeyValueSkipListSet
argument_list|(
name|this
operator|.
name|comparator
argument_list|)
expr_stmt|;
name|this
operator|.
name|snapshotTimeRangeTracker
operator|=
name|this
operator|.
name|timeRangeTracker
expr_stmt|;
name|this
operator|.
name|timeRangeTracker
operator|=
operator|new
name|TimeRangeTracker
argument_list|()
expr_stmt|;
comment|// Reset heap to not include any keys
name|this
operator|.
name|size
operator|.
name|set
argument_list|(
name|DEEP_OVERHEAD
argument_list|)
expr_stmt|;
comment|// Reset allocator so we get a fresh buffer for the new memstore
if|if
condition|(
name|allocator
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|allocator
operator|=
operator|new
name|MemStoreLAB
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Return the current snapshot.    * Called by flusher to get current snapshot made by a previous    * call to {@link #snapshot()}    * @return Return snapshot.    * @see {@link #snapshot()}    * @see {@link #clearSnapshot(SortedSet<KeyValue>)}    */
name|KeyValueSkipListSet
name|getSnapshot
parameter_list|()
block|{
return|return
name|this
operator|.
name|snapshot
return|;
block|}
comment|/**    * The passed snapshot was successfully persisted; it can be let go.    * @param ss The snapshot to clean out.    * @throws UnexpectedException    * @see {@link #snapshot()}    */
name|void
name|clearSnapshot
parameter_list|(
specifier|final
name|SortedSet
argument_list|<
name|KeyValue
argument_list|>
name|ss
parameter_list|)
throws|throws
name|UnexpectedException
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|this
operator|.
name|snapshot
operator|!=
name|ss
condition|)
block|{
throw|throw
operator|new
name|UnexpectedException
argument_list|(
literal|"Current snapshot is "
operator|+
name|this
operator|.
name|snapshot
operator|+
literal|", was passed "
operator|+
name|ss
argument_list|)
throw|;
block|}
comment|// OK. Passed in snapshot is same as current snapshot.  If not-empty,
comment|// create a new snapshot and let the old one go.
if|if
condition|(
operator|!
name|ss
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|this
operator|.
name|snapshot
operator|=
operator|new
name|KeyValueSkipListSet
argument_list|(
name|this
operator|.
name|comparator
argument_list|)
expr_stmt|;
name|this
operator|.
name|snapshotTimeRangeTracker
operator|=
operator|new
name|TimeRangeTracker
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Write an update    * @param kv    * @return approximate size of the passed key and value.    */
name|long
name|add
parameter_list|(
specifier|final
name|KeyValue
name|kv
parameter_list|)
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|KeyValue
name|toAdd
init|=
name|maybeCloneWithAllocator
argument_list|(
name|kv
argument_list|)
decl_stmt|;
return|return
name|internalAdd
argument_list|(
name|toAdd
argument_list|)
return|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Internal version of add() that doesn't clone KVs with the    * allocator, and doesn't take the lock.    *    * Callers should ensure they already have the read lock taken    */
specifier|private
name|long
name|internalAdd
parameter_list|(
specifier|final
name|KeyValue
name|toAdd
parameter_list|)
block|{
name|long
name|s
init|=
name|heapSizeChange
argument_list|(
name|toAdd
argument_list|,
name|this
operator|.
name|kvset
operator|.
name|add
argument_list|(
name|toAdd
argument_list|)
argument_list|)
decl_stmt|;
name|timeRangeTracker
operator|.
name|includeTimestamp
argument_list|(
name|toAdd
argument_list|)
expr_stmt|;
name|this
operator|.
name|size
operator|.
name|addAndGet
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
specifier|private
name|KeyValue
name|maybeCloneWithAllocator
parameter_list|(
name|KeyValue
name|kv
parameter_list|)
block|{
if|if
condition|(
name|allocator
operator|==
literal|null
condition|)
block|{
return|return
name|kv
return|;
block|}
name|int
name|len
init|=
name|kv
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|Allocation
name|alloc
init|=
name|allocator
operator|.
name|allocateBytes
argument_list|(
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|alloc
operator|==
literal|null
condition|)
block|{
comment|// The allocation was too large, allocator decided
comment|// not to do anything with it.
return|return
name|kv
return|;
block|}
assert|assert
name|alloc
operator|!=
literal|null
operator|&&
name|alloc
operator|.
name|getData
argument_list|()
operator|!=
literal|null
assert|;
name|System
operator|.
name|arraycopy
argument_list|(
name|kv
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|kv
operator|.
name|getOffset
argument_list|()
argument_list|,
name|alloc
operator|.
name|getData
argument_list|()
argument_list|,
name|alloc
operator|.
name|getOffset
argument_list|()
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|KeyValue
name|newKv
init|=
operator|new
name|KeyValue
argument_list|(
name|alloc
operator|.
name|getData
argument_list|()
argument_list|,
name|alloc
operator|.
name|getOffset
argument_list|()
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|newKv
operator|.
name|setMemstoreTS
argument_list|(
name|kv
operator|.
name|getMemstoreTS
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|newKv
return|;
block|}
comment|/**    * Remove n key from the memstore. Only kvs that have the same key and the    * same memstoreTS are removed.  It is ok to not update timeRangeTracker    * in this call. It is possible that we can optimize this method by using    * tailMap/iterator, but since this method is called rarely (only for    * error recovery), we can leave those optimization for the future.    * @param kv    */
name|void
name|rollback
parameter_list|(
specifier|final
name|KeyValue
name|kv
parameter_list|)
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// If the key is in the snapshot, delete it. We should not update
comment|// this.size, because that tracks the size of only the memstore and
comment|// not the snapshot. The flush of this snapshot to disk has not
comment|// yet started because Store.flush() waits for all rwcc transactions to
comment|// commit before starting the flush to disk.
name|KeyValue
name|found
init|=
name|this
operator|.
name|snapshot
operator|.
name|get
argument_list|(
name|kv
argument_list|)
decl_stmt|;
if|if
condition|(
name|found
operator|!=
literal|null
operator|&&
name|found
operator|.
name|getMemstoreTS
argument_list|()
operator|==
name|kv
operator|.
name|getMemstoreTS
argument_list|()
condition|)
block|{
name|this
operator|.
name|snapshot
operator|.
name|remove
argument_list|(
name|kv
argument_list|)
expr_stmt|;
block|}
comment|// If the key is in the memstore, delete it. Update this.size.
name|found
operator|=
name|this
operator|.
name|kvset
operator|.
name|get
argument_list|(
name|kv
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|!=
literal|null
operator|&&
name|found
operator|.
name|getMemstoreTS
argument_list|()
operator|==
name|kv
operator|.
name|getMemstoreTS
argument_list|()
condition|)
block|{
name|this
operator|.
name|kvset
operator|.
name|remove
argument_list|(
name|kv
argument_list|)
expr_stmt|;
name|long
name|s
init|=
name|heapSizeChange
argument_list|(
name|kv
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|this
operator|.
name|size
operator|.
name|addAndGet
argument_list|(
operator|-
name|s
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Write a delete    * @param delete    * @return approximate size of the passed key and value.    */
name|long
name|delete
parameter_list|(
specifier|final
name|KeyValue
name|delete
parameter_list|)
block|{
name|long
name|s
init|=
literal|0
decl_stmt|;
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|KeyValue
name|toAdd
init|=
name|maybeCloneWithAllocator
argument_list|(
name|delete
argument_list|)
decl_stmt|;
name|s
operator|+=
name|heapSizeChange
argument_list|(
name|toAdd
argument_list|,
name|this
operator|.
name|kvset
operator|.
name|add
argument_list|(
name|toAdd
argument_list|)
argument_list|)
expr_stmt|;
name|timeRangeTracker
operator|.
name|includeTimestamp
argument_list|(
name|toAdd
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|size
operator|.
name|addAndGet
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
comment|/**    * @param kv Find the row that comes after this one.  If null, we return the    * first.    * @return Next row or null if none found.    */
name|KeyValue
name|getNextRow
parameter_list|(
specifier|final
name|KeyValue
name|kv
parameter_list|)
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|getLowest
argument_list|(
name|getNextRow
argument_list|(
name|kv
argument_list|,
name|this
operator|.
name|kvset
argument_list|)
argument_list|,
name|getNextRow
argument_list|(
name|kv
argument_list|,
name|this
operator|.
name|snapshot
argument_list|)
argument_list|)
return|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*    * @param a    * @param b    * @return Return lowest of a or b or null if both a and b are null    */
specifier|private
name|KeyValue
name|getLowest
parameter_list|(
specifier|final
name|KeyValue
name|a
parameter_list|,
specifier|final
name|KeyValue
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|==
literal|null
condition|)
block|{
return|return
name|b
return|;
block|}
if|if
condition|(
name|b
operator|==
literal|null
condition|)
block|{
return|return
name|a
return|;
block|}
return|return
name|comparator
operator|.
name|compareRows
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|<=
literal|0
condition|?
name|a
else|:
name|b
return|;
block|}
comment|/*    * @param key Find row that follows this one.  If null, return first.    * @param map Set to look in for a row beyond<code>row</code>.    * @return Next row or null if none found.  If one found, will be a new    * KeyValue -- can be destroyed by subsequent calls to this method.    */
specifier|private
name|KeyValue
name|getNextRow
parameter_list|(
specifier|final
name|KeyValue
name|key
parameter_list|,
specifier|final
name|NavigableSet
argument_list|<
name|KeyValue
argument_list|>
name|set
parameter_list|)
block|{
name|KeyValue
name|result
init|=
literal|null
decl_stmt|;
name|SortedSet
argument_list|<
name|KeyValue
argument_list|>
name|tail
init|=
name|key
operator|==
literal|null
condition|?
name|set
else|:
name|set
operator|.
name|tailSet
argument_list|(
name|key
argument_list|)
decl_stmt|;
comment|// Iterate until we fall into the next row; i.e. move off current row
for|for
control|(
name|KeyValue
name|kv
range|:
name|tail
control|)
block|{
if|if
condition|(
name|comparator
operator|.
name|compareRows
argument_list|(
name|kv
argument_list|,
name|key
argument_list|)
operator|<=
literal|0
condition|)
continue|continue;
comment|// Note: Not suppressing deletes or expired cells.  Needs to be handled
comment|// by higher up functions.
name|result
operator|=
name|kv
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
comment|/**    * @param state column/delete tracking state    */
name|void
name|getRowKeyAtOrBefore
parameter_list|(
specifier|final
name|GetClosestRowBeforeTracker
name|state
parameter_list|)
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|getRowKeyAtOrBefore
argument_list|(
name|kvset
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|getRowKeyAtOrBefore
argument_list|(
name|snapshot
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*    * @param set    * @param state Accumulates deletes and candidates.    */
specifier|private
name|void
name|getRowKeyAtOrBefore
parameter_list|(
specifier|final
name|NavigableSet
argument_list|<
name|KeyValue
argument_list|>
name|set
parameter_list|,
specifier|final
name|GetClosestRowBeforeTracker
name|state
parameter_list|)
block|{
if|if
condition|(
name|set
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|walkForwardInSingleRow
argument_list|(
name|set
argument_list|,
name|state
operator|.
name|getTargetKey
argument_list|()
argument_list|,
name|state
argument_list|)
condition|)
block|{
comment|// Found nothing in row.  Try backing up.
name|getRowKeyBefore
argument_list|(
name|set
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Walk forward in a row from<code>firstOnRow</code>.  Presumption is that    * we have been passed the first possible key on a row.  As we walk forward    * we accumulate deletes until we hit a candidate on the row at which point    * we return.    * @param set    * @param firstOnRow First possible key on this row.    * @param state    * @return True if we found a candidate walking this row.    */
specifier|private
name|boolean
name|walkForwardInSingleRow
parameter_list|(
specifier|final
name|SortedSet
argument_list|<
name|KeyValue
argument_list|>
name|set
parameter_list|,
specifier|final
name|KeyValue
name|firstOnRow
parameter_list|,
specifier|final
name|GetClosestRowBeforeTracker
name|state
parameter_list|)
block|{
name|boolean
name|foundCandidate
init|=
literal|false
decl_stmt|;
name|SortedSet
argument_list|<
name|KeyValue
argument_list|>
name|tail
init|=
name|set
operator|.
name|tailSet
argument_list|(
name|firstOnRow
argument_list|)
decl_stmt|;
if|if
condition|(
name|tail
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|foundCandidate
return|;
for|for
control|(
name|Iterator
argument_list|<
name|KeyValue
argument_list|>
name|i
init|=
name|tail
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|KeyValue
name|kv
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// Did we go beyond the target row? If so break.
if|if
condition|(
name|state
operator|.
name|isTooFar
argument_list|(
name|kv
argument_list|,
name|firstOnRow
argument_list|)
condition|)
break|break;
if|if
condition|(
name|state
operator|.
name|isExpired
argument_list|(
name|kv
argument_list|)
condition|)
block|{
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|// If we added something, this row is a contender. break.
if|if
condition|(
name|state
operator|.
name|handle
argument_list|(
name|kv
argument_list|)
condition|)
block|{
name|foundCandidate
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
return|return
name|foundCandidate
return|;
block|}
comment|/*    * Walk backwards through the passed set a row at a time until we run out of    * set or until we get a candidate.    * @param set    * @param state    */
specifier|private
name|void
name|getRowKeyBefore
parameter_list|(
name|NavigableSet
argument_list|<
name|KeyValue
argument_list|>
name|set
parameter_list|,
specifier|final
name|GetClosestRowBeforeTracker
name|state
parameter_list|)
block|{
name|KeyValue
name|firstOnRow
init|=
name|state
operator|.
name|getTargetKey
argument_list|()
decl_stmt|;
for|for
control|(
name|Member
name|p
init|=
name|memberOfPreviousRow
argument_list|(
name|set
argument_list|,
name|state
argument_list|,
name|firstOnRow
argument_list|)
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|memberOfPreviousRow
argument_list|(
name|p
operator|.
name|set
argument_list|,
name|state
argument_list|,
name|firstOnRow
argument_list|)
control|)
block|{
comment|// Make sure we don't fall out of our table.
if|if
condition|(
operator|!
name|state
operator|.
name|isTargetTable
argument_list|(
name|p
operator|.
name|kv
argument_list|)
condition|)
break|break;
comment|// Stop looking if we've exited the better candidate range.
if|if
condition|(
operator|!
name|state
operator|.
name|isBetterCandidate
argument_list|(
name|p
operator|.
name|kv
argument_list|)
condition|)
break|break;
comment|// Make into firstOnRow
name|firstOnRow
operator|=
operator|new
name|KeyValue
argument_list|(
name|p
operator|.
name|kv
operator|.
name|getRow
argument_list|()
argument_list|,
name|HConstants
operator|.
name|LATEST_TIMESTAMP
argument_list|)
expr_stmt|;
comment|// If we find something, break;
if|if
condition|(
name|walkForwardInSingleRow
argument_list|(
name|p
operator|.
name|set
argument_list|,
name|firstOnRow
argument_list|,
name|state
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/**    * Only used by tests. TODO: Remove    *    * Given the specs of a column, update it, first by inserting a new record,    * then removing the old one.  Since there is only 1 KeyValue involved, the memstoreTS    * will be set to 0, thus ensuring that they instantly appear to anyone. The underlying    * store will ensure that the insert/delete each are atomic. A scanner/reader will either    * get the new value, or the old value and all readers will eventually only see the new    * value after the old was removed.    *    * @param row    * @param family    * @param qualifier    * @param newValue    * @param now    * @return  Timestamp    */
name|long
name|updateColumnValue
parameter_list|(
name|byte
index|[]
name|row
parameter_list|,
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|long
name|newValue
parameter_list|,
name|long
name|now
parameter_list|)
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|KeyValue
name|firstKv
init|=
name|KeyValue
operator|.
name|createFirstOnRow
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|)
decl_stmt|;
comment|// Is there a KeyValue in 'snapshot' with the same TS? If so, upgrade the timestamp a bit.
name|SortedSet
argument_list|<
name|KeyValue
argument_list|>
name|snSs
init|=
name|snapshot
operator|.
name|tailSet
argument_list|(
name|firstKv
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|snSs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|KeyValue
name|snKv
init|=
name|snSs
operator|.
name|first
argument_list|()
decl_stmt|;
comment|// is there a matching KV in the snapshot?
if|if
condition|(
name|snKv
operator|.
name|matchingRow
argument_list|(
name|firstKv
argument_list|)
operator|&&
name|snKv
operator|.
name|matchingQualifier
argument_list|(
name|firstKv
argument_list|)
condition|)
block|{
if|if
condition|(
name|snKv
operator|.
name|getTimestamp
argument_list|()
operator|==
name|now
condition|)
block|{
comment|// poop,
name|now
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|// logic here: the new ts MUST be at least 'now'. But it could be larger if necessary.
comment|// But the timestamp should also be max(now, mostRecentTsInMemstore)
comment|// so we cant add the new KV w/o knowing what's there already, but we also
comment|// want to take this chance to delete some kvs. So two loops (sad)
name|SortedSet
argument_list|<
name|KeyValue
argument_list|>
name|ss
init|=
name|kvset
operator|.
name|tailSet
argument_list|(
name|firstKv
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|KeyValue
argument_list|>
name|it
init|=
name|ss
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|KeyValue
name|kv
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// if this isnt the row we are interested in, then bail:
if|if
condition|(
operator|!
name|kv
operator|.
name|matchingColumn
argument_list|(
name|family
argument_list|,
name|qualifier
argument_list|)
operator|||
operator|!
name|kv
operator|.
name|matchingRow
argument_list|(
name|firstKv
argument_list|)
condition|)
block|{
break|break;
comment|// rows dont match, bail.
block|}
comment|// if the qualifier matches and it's a put, just RM it out of the kvset.
if|if
condition|(
name|kv
operator|.
name|getType
argument_list|()
operator|==
name|KeyValue
operator|.
name|Type
operator|.
name|Put
operator|.
name|getCode
argument_list|()
operator|&&
name|kv
operator|.
name|getTimestamp
argument_list|()
operator|>
name|now
operator|&&
name|firstKv
operator|.
name|matchingQualifier
argument_list|(
name|kv
argument_list|)
condition|)
block|{
name|now
operator|=
name|kv
operator|.
name|getTimestamp
argument_list|()
expr_stmt|;
block|}
block|}
comment|// create or update (upsert) a new KeyValue with
comment|// 'now' and a 0 memstoreTS == immediately visible
name|List
argument_list|<
name|Cell
argument_list|>
name|cells
init|=
operator|new
name|ArrayList
argument_list|<
name|Cell
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|cells
operator|.
name|add
argument_list|(
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|now
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|newValue
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|upsert
argument_list|(
name|cells
argument_list|,
literal|1L
argument_list|)
return|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Update or insert the specified KeyValues.    *<p>    * For each KeyValue, insert into MemStore.  This will atomically upsert the    * value for that row/family/qualifier.  If a KeyValue did already exist,    * it will then be removed.    *<p>    * Currently the memstoreTS is kept at 0 so as each insert happens, it will    * be immediately visible.  May want to change this so it is atomic across    * all KeyValues.    *<p>    * This is called under row lock, so Get operations will still see updates    * atomically.  Scans will only see each KeyValue update as atomic.    *    * @param cells    * @param readpoint readpoint below which we can safely remove duplicate KVs     * @return change in memstore size    */
specifier|public
name|long
name|upsert
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|Cell
argument_list|>
name|cells
parameter_list|,
name|long
name|readpoint
parameter_list|)
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|long
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Cell
name|cell
range|:
name|cells
control|)
block|{
name|size
operator|+=
name|upsert
argument_list|(
name|cell
argument_list|,
name|readpoint
argument_list|)
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Inserts the specified KeyValue into MemStore and deletes any existing    * versions of the same row/family/qualifier as the specified KeyValue.    *<p>    * First, the specified KeyValue is inserted into the Memstore.    *<p>    * If there are any existing KeyValues in this MemStore with the same row,    * family, and qualifier, they are removed.    *<p>    * Callers must hold the read lock.    *    * @param cell    * @return change in size of MemStore    */
specifier|private
name|long
name|upsert
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|long
name|readpoint
parameter_list|)
block|{
comment|// Add the KeyValue to the MemStore
comment|// Use the internalAdd method here since we (a) already have a lock
comment|// and (b) cannot safely use the MSLAB here without potentially
comment|// hitting OOME - see TestMemStore.testUpsertMSLAB for a
comment|// test that triggers the pathological case if we don't avoid MSLAB
comment|// here.
name|KeyValue
name|kv
init|=
name|KeyValueUtil
operator|.
name|ensureKeyValue
argument_list|(
name|cell
argument_list|)
decl_stmt|;
name|long
name|addedSize
init|=
name|internalAdd
argument_list|(
name|kv
argument_list|)
decl_stmt|;
comment|// Get the KeyValues for the row/family/qualifier regardless of timestamp.
comment|// For this case we want to clean up any other puts
name|KeyValue
name|firstKv
init|=
name|KeyValue
operator|.
name|createFirstOnRow
argument_list|(
name|kv
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|kv
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|kv
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|kv
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|kv
operator|.
name|getBuffer
argument_list|()
argument_list|,
name|kv
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|kv
operator|.
name|getQualifierLength
argument_list|()
argument_list|)
decl_stmt|;
name|SortedSet
argument_list|<
name|KeyValue
argument_list|>
name|ss
init|=
name|kvset
operator|.
name|tailSet
argument_list|(
name|firstKv
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|KeyValue
argument_list|>
name|it
init|=
name|ss
operator|.
name|iterator
argument_list|()
decl_stmt|;
comment|// versions visible to oldest scanner
name|int
name|versionsVisible
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|KeyValue
name|cur
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|kv
operator|==
name|cur
condition|)
block|{
comment|// ignore the one just put in
continue|continue;
block|}
comment|// check that this is the row and column we are interested in, otherwise bail
if|if
condition|(
name|kv
operator|.
name|matchingRow
argument_list|(
name|cur
argument_list|)
operator|&&
name|kv
operator|.
name|matchingQualifier
argument_list|(
name|cur
argument_list|)
condition|)
block|{
comment|// only remove Puts that concurrent scanners cannot possibly see
if|if
condition|(
name|cur
operator|.
name|getType
argument_list|()
operator|==
name|KeyValue
operator|.
name|Type
operator|.
name|Put
operator|.
name|getCode
argument_list|()
operator|&&
name|cur
operator|.
name|getMemstoreTS
argument_list|()
operator|<=
name|readpoint
condition|)
block|{
if|if
condition|(
name|versionsVisible
operator|>
literal|1
condition|)
block|{
comment|// if we get here we have seen at least one version visible to the oldest scanner,
comment|// which means we can prove that no scanner will see this version
comment|// false means there was a change, so give us the size.
name|long
name|delta
init|=
name|heapSizeChange
argument_list|(
name|cur
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|addedSize
operator|-=
name|delta
expr_stmt|;
name|this
operator|.
name|size
operator|.
name|addAndGet
argument_list|(
operator|-
name|delta
argument_list|)
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|versionsVisible
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// past the row or column, done
break|break;
block|}
block|}
return|return
name|addedSize
return|;
block|}
comment|/*    * Immutable data structure to hold member found in set and the set it was    * found in.  Include set because it is carrying context.    */
specifier|private
specifier|static
class|class
name|Member
block|{
specifier|final
name|KeyValue
name|kv
decl_stmt|;
specifier|final
name|NavigableSet
argument_list|<
name|KeyValue
argument_list|>
name|set
decl_stmt|;
name|Member
parameter_list|(
specifier|final
name|NavigableSet
argument_list|<
name|KeyValue
argument_list|>
name|s
parameter_list|,
specifier|final
name|KeyValue
name|kv
parameter_list|)
block|{
name|this
operator|.
name|kv
operator|=
name|kv
expr_stmt|;
name|this
operator|.
name|set
operator|=
name|s
expr_stmt|;
block|}
block|}
comment|/*    * @param set Set to walk back in.  Pass a first in row or we'll return    * same row (loop).    * @param state Utility and context.    * @param firstOnRow First item on the row after the one we want to find a    * member in.    * @return Null or member of row previous to<code>firstOnRow</code>    */
specifier|private
name|Member
name|memberOfPreviousRow
parameter_list|(
name|NavigableSet
argument_list|<
name|KeyValue
argument_list|>
name|set
parameter_list|,
specifier|final
name|GetClosestRowBeforeTracker
name|state
parameter_list|,
specifier|final
name|KeyValue
name|firstOnRow
parameter_list|)
block|{
name|NavigableSet
argument_list|<
name|KeyValue
argument_list|>
name|head
init|=
name|set
operator|.
name|headSet
argument_list|(
name|firstOnRow
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|head
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|null
return|;
for|for
control|(
name|Iterator
argument_list|<
name|KeyValue
argument_list|>
name|i
init|=
name|head
operator|.
name|descendingIterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|KeyValue
name|found
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
operator|.
name|isExpired
argument_list|(
name|found
argument_list|)
condition|)
block|{
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
continue|continue;
block|}
return|return
operator|new
name|Member
argument_list|(
name|head
argument_list|,
name|found
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * @return scanner on memstore and snapshot in this order.    */
name|List
argument_list|<
name|KeyValueScanner
argument_list|>
name|getScanners
parameter_list|()
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|Collections
operator|.
expr|<
name|KeyValueScanner
operator|>
name|singletonList
argument_list|(
operator|new
name|MemStoreScanner
argument_list|()
argument_list|)
return|;
block|}
finally|finally
block|{
name|this
operator|.
name|lock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Check if this memstore may contain the required keys    * @param scan    * @return False if the key definitely does not exist in this Memstore    */
specifier|public
name|boolean
name|shouldSeek
parameter_list|(
name|Scan
name|scan
parameter_list|,
name|long
name|oldestUnexpiredTS
parameter_list|)
block|{
return|return
operator|(
name|timeRangeTracker
operator|.
name|includesTimeRange
argument_list|(
name|scan
operator|.
name|getTimeRange
argument_list|()
argument_list|)
operator|||
name|snapshotTimeRangeTracker
operator|.
name|includesTimeRange
argument_list|(
name|scan
operator|.
name|getTimeRange
argument_list|()
argument_list|)
operator|)
operator|&&
operator|(
name|Math
operator|.
name|max
argument_list|(
name|timeRangeTracker
operator|.
name|getMaximumTimestamp
argument_list|()
argument_list|,
name|snapshotTimeRangeTracker
operator|.
name|getMaximumTimestamp
argument_list|()
argument_list|)
operator|>=
name|oldestUnexpiredTS
operator|)
return|;
block|}
specifier|public
name|TimeRangeTracker
name|getSnapshotTimeRangeTracker
parameter_list|()
block|{
return|return
name|this
operator|.
name|snapshotTimeRangeTracker
return|;
block|}
comment|/*    * MemStoreScanner implements the KeyValueScanner.    * It lets the caller scan the contents of a memstore -- both current    * map and snapshot.    * This behaves as if it were a real scanner but does not maintain position.    */
specifier|protected
class|class
name|MemStoreScanner
extends|extends
name|NonLazyKeyValueScanner
block|{
comment|// Next row information for either kvset or snapshot
specifier|private
name|KeyValue
name|kvsetNextRow
init|=
literal|null
decl_stmt|;
specifier|private
name|KeyValue
name|snapshotNextRow
init|=
literal|null
decl_stmt|;
comment|// last iterated KVs for kvset and snapshot (to restore iterator state after reseek)
specifier|private
name|KeyValue
name|kvsetItRow
init|=
literal|null
decl_stmt|;
specifier|private
name|KeyValue
name|snapshotItRow
init|=
literal|null
decl_stmt|;
comment|// iterator based scanning.
specifier|private
name|Iterator
argument_list|<
name|KeyValue
argument_list|>
name|kvsetIt
decl_stmt|;
specifier|private
name|Iterator
argument_list|<
name|KeyValue
argument_list|>
name|snapshotIt
decl_stmt|;
comment|// The kvset and snapshot at the time of creating this scanner
specifier|private
name|KeyValueSkipListSet
name|kvsetAtCreation
decl_stmt|;
specifier|private
name|KeyValueSkipListSet
name|snapshotAtCreation
decl_stmt|;
comment|// the pre-calculated KeyValue to be returned by peek() or next()
specifier|private
name|KeyValue
name|theNext
decl_stmt|;
comment|/*     Some notes...       So memstorescanner is fixed at creation time. this includes pointers/iterators into     existing kvset/snapshot.  during a snapshot creation, the kvset is null, and the     snapshot is moved.  since kvset is null there is no point on reseeking on both,       we can save us the trouble. During the snapshot->hfile transition, the memstore       scanner is re-created by StoreScanner#updateReaders().  StoreScanner should       potentially do something smarter by adjusting the existing memstore scanner.        But there is a greater problem here, that being once a scanner has progressed       during a snapshot scenario, we currently iterate past the kvset then 'finish' up.       if a scan lasts a little while, there is a chance for new entries in kvset to       become available but we will never see them.  This needs to be handled at the       StoreScanner level with coordination with MemStoreScanner.        Currently, this problem is only partly managed: during the small amount of time       when the StoreScanner has not yet created a new MemStoreScanner, we will miss       the adds to kvset in the MemStoreScanner.     */
name|MemStoreScanner
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
name|kvsetAtCreation
operator|=
name|kvset
expr_stmt|;
name|snapshotAtCreation
operator|=
name|snapshot
expr_stmt|;
block|}
specifier|private
name|KeyValue
name|getNext
parameter_list|(
name|Iterator
argument_list|<
name|KeyValue
argument_list|>
name|it
parameter_list|)
block|{
name|long
name|readPoint
init|=
name|MultiVersionConsistencyControl
operator|.
name|getThreadReadPoint
argument_list|()
decl_stmt|;
name|KeyValue
name|v
init|=
literal|null
decl_stmt|;
try|try
block|{
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|v
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|v
operator|.
name|getMemstoreTS
argument_list|()
operator|<=
name|readPoint
condition|)
block|{
return|return
name|v
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|v
operator|!=
literal|null
condition|)
block|{
comment|// in all cases, remember the last KV iterated to
if|if
condition|(
name|it
operator|==
name|snapshotIt
condition|)
block|{
name|snapshotItRow
operator|=
name|v
expr_stmt|;
block|}
else|else
block|{
name|kvsetItRow
operator|=
name|v
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      *  Set the scanner at the seek key.      *  Must be called only once: there is no thread safety between the scanner      *   and the memStore.      * @param key seek value      * @return false if the key is null or if there is no data      */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|boolean
name|seek
parameter_list|(
name|KeyValue
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
name|close
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// kvset and snapshot will never be null.
comment|// if tailSet can't find anything, SortedSet is empty (not null).
name|kvsetIt
operator|=
name|kvsetAtCreation
operator|.
name|tailSet
argument_list|(
name|key
argument_list|)
operator|.
name|iterator
argument_list|()
expr_stmt|;
name|snapshotIt
operator|=
name|snapshotAtCreation
operator|.
name|tailSet
argument_list|(
name|key
argument_list|)
operator|.
name|iterator
argument_list|()
expr_stmt|;
name|kvsetItRow
operator|=
literal|null
expr_stmt|;
name|snapshotItRow
operator|=
literal|null
expr_stmt|;
return|return
name|seekInSubLists
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|/**      * (Re)initialize the iterators after a seek or a reseek.      */
specifier|private
specifier|synchronized
name|boolean
name|seekInSubLists
parameter_list|(
name|KeyValue
name|key
parameter_list|)
block|{
name|kvsetNextRow
operator|=
name|getNext
argument_list|(
name|kvsetIt
argument_list|)
expr_stmt|;
name|snapshotNextRow
operator|=
name|getNext
argument_list|(
name|snapshotIt
argument_list|)
expr_stmt|;
comment|// Calculate the next value
name|theNext
operator|=
name|getLowest
argument_list|(
name|kvsetNextRow
argument_list|,
name|snapshotNextRow
argument_list|)
expr_stmt|;
comment|// has data
return|return
operator|(
name|theNext
operator|!=
literal|null
operator|)
return|;
block|}
comment|/**      * Move forward on the sub-lists set previously by seek.      * @param key seek value (should be non-null)      * @return true if there is at least one KV to read, false otherwise      */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|boolean
name|reseek
parameter_list|(
name|KeyValue
name|key
parameter_list|)
block|{
comment|/*       See HBASE-4195& HBASE-3855& HBASE-6591 for the background on this implementation.       This code is executed concurrently with flush and puts, without locks.       Two points must be known when working on this code:       1) It's not possible to use the 'kvTail' and 'snapshot'        variables, as they are modified during a flush.       2) The ideal implementation for performance would use the sub skip list        implicitly pointed by the iterators 'kvsetIt' and        'snapshotIt'. Unfortunately the Java API does not offer a method to        get it. So we remember the last keys we iterated to and restore        the reseeked set to at least that point.        */
name|kvsetIt
operator|=
name|kvsetAtCreation
operator|.
name|tailSet
argument_list|(
name|getHighest
argument_list|(
name|key
argument_list|,
name|kvsetItRow
argument_list|)
argument_list|)
operator|.
name|iterator
argument_list|()
expr_stmt|;
name|snapshotIt
operator|=
name|snapshotAtCreation
operator|.
name|tailSet
argument_list|(
name|getHighest
argument_list|(
name|key
argument_list|,
name|snapshotItRow
argument_list|)
argument_list|)
operator|.
name|iterator
argument_list|()
expr_stmt|;
return|return
name|seekInSubLists
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|KeyValue
name|peek
parameter_list|()
block|{
comment|//DebugPrint.println(" MS@" + hashCode() + " peek = " + getLowest());
return|return
name|theNext
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|KeyValue
name|next
parameter_list|()
block|{
if|if
condition|(
name|theNext
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|KeyValue
name|ret
init|=
name|theNext
decl_stmt|;
comment|// Advance one of the iterators
if|if
condition|(
name|theNext
operator|==
name|kvsetNextRow
condition|)
block|{
name|kvsetNextRow
operator|=
name|getNext
argument_list|(
name|kvsetIt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snapshotNextRow
operator|=
name|getNext
argument_list|(
name|snapshotIt
argument_list|)
expr_stmt|;
block|}
comment|// Calculate the next value
name|theNext
operator|=
name|getLowest
argument_list|(
name|kvsetNextRow
argument_list|,
name|snapshotNextRow
argument_list|)
expr_stmt|;
comment|//long readpoint = ReadWriteConsistencyControl.getThreadReadPoint();
comment|//DebugPrint.println(" MS@" + hashCode() + " next: " + theNext + " next_next: " +
comment|//    getLowest() + " threadpoint=" + readpoint);
return|return
name|ret
return|;
block|}
comment|/*      * Returns the lower of the two key values, or null if they are both null.      * This uses comparator.compare() to compare the KeyValue using the memstore      * comparator.      */
specifier|private
name|KeyValue
name|getLowest
parameter_list|(
name|KeyValue
name|first
parameter_list|,
name|KeyValue
name|second
parameter_list|)
block|{
if|if
condition|(
name|first
operator|==
literal|null
operator|&&
name|second
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|first
operator|!=
literal|null
operator|&&
name|second
operator|!=
literal|null
condition|)
block|{
name|int
name|compare
init|=
name|comparator
operator|.
name|compare
argument_list|(
name|first
argument_list|,
name|second
argument_list|)
decl_stmt|;
return|return
operator|(
name|compare
operator|<=
literal|0
condition|?
name|first
else|:
name|second
operator|)
return|;
block|}
return|return
operator|(
name|first
operator|!=
literal|null
condition|?
name|first
else|:
name|second
operator|)
return|;
block|}
comment|/*      * Returns the higher of the two key values, or null if they are both null.      * This uses comparator.compare() to compare the KeyValue using the memstore      * comparator.      */
specifier|private
name|KeyValue
name|getHighest
parameter_list|(
name|KeyValue
name|first
parameter_list|,
name|KeyValue
name|second
parameter_list|)
block|{
if|if
condition|(
name|first
operator|==
literal|null
operator|&&
name|second
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|first
operator|!=
literal|null
operator|&&
name|second
operator|!=
literal|null
condition|)
block|{
name|int
name|compare
init|=
name|comparator
operator|.
name|compare
argument_list|(
name|first
argument_list|,
name|second
argument_list|)
decl_stmt|;
return|return
operator|(
name|compare
operator|>
literal|0
condition|?
name|first
else|:
name|second
operator|)
return|;
block|}
return|return
operator|(
name|first
operator|!=
literal|null
condition|?
name|first
else|:
name|second
operator|)
return|;
block|}
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
block|{
name|this
operator|.
name|kvsetNextRow
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|snapshotNextRow
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|kvsetIt
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|snapshotIt
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|kvsetItRow
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|snapshotItRow
operator|=
literal|null
expr_stmt|;
block|}
comment|/**      * MemStoreScanner returns max value as sequence id because it will      * always have the latest data among all files.      */
annotation|@
name|Override
specifier|public
name|long
name|getSequenceID
parameter_list|()
block|{
return|return
name|Long
operator|.
name|MAX_VALUE
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|shouldUseScanner
parameter_list|(
name|Scan
name|scan
parameter_list|,
name|SortedSet
argument_list|<
name|byte
index|[]
argument_list|>
name|columns
parameter_list|,
name|long
name|oldestUnexpiredTS
parameter_list|)
block|{
return|return
name|shouldSeek
argument_list|(
name|scan
argument_list|,
name|oldestUnexpiredTS
argument_list|)
return|;
block|}
block|}
specifier|public
specifier|final
specifier|static
name|long
name|FIXED_OVERHEAD
init|=
name|ClassSize
operator|.
name|align
argument_list|(
name|ClassSize
operator|.
name|OBJECT
operator|+
operator|(
literal|11
operator|*
name|ClassSize
operator|.
name|REFERENCE
operator|)
argument_list|)
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|long
name|DEEP_OVERHEAD
init|=
name|ClassSize
operator|.
name|align
argument_list|(
name|FIXED_OVERHEAD
operator|+
name|ClassSize
operator|.
name|REENTRANT_LOCK
operator|+
name|ClassSize
operator|.
name|ATOMIC_LONG
operator|+
name|ClassSize
operator|.
name|COPYONWRITE_ARRAYSET
operator|+
name|ClassSize
operator|.
name|COPYONWRITE_ARRAYLIST
operator|+
operator|(
literal|2
operator|*
name|ClassSize
operator|.
name|CONCURRENT_SKIPLISTMAP
operator|)
argument_list|)
decl_stmt|;
comment|/** Used for readability when we don't store memstore timestamp in HFile */
specifier|public
specifier|static
specifier|final
name|boolean
name|NO_PERSISTENT_TS
init|=
literal|false
decl_stmt|;
comment|/*    * Calculate how the MemStore size has changed.  Includes overhead of the    * backing Map.    * @param kv    * @param notpresent True if the kv was NOT present in the set.    * @return Size    */
name|long
name|heapSizeChange
parameter_list|(
specifier|final
name|KeyValue
name|kv
parameter_list|,
specifier|final
name|boolean
name|notpresent
parameter_list|)
block|{
return|return
name|notpresent
condition|?
name|ClassSize
operator|.
name|align
argument_list|(
name|ClassSize
operator|.
name|CONCURRENT_SKIPLISTMAP_ENTRY
operator|+
name|kv
operator|.
name|heapSize
argument_list|()
argument_list|)
else|:
literal|0
return|;
block|}
comment|/**    * Get the entire heap usage for this MemStore not including keys in the    * snapshot.    */
annotation|@
name|Override
specifier|public
name|long
name|heapSize
parameter_list|()
block|{
return|return
name|size
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * Get the heap usage of KVs in this MemStore.    */
specifier|public
name|long
name|keySize
parameter_list|()
block|{
return|return
name|heapSize
argument_list|()
operator|-
name|DEEP_OVERHEAD
return|;
block|}
comment|/**    * Code to help figure if our approximation of object heap sizes is close    * enough.  See hbase-900.  Fills memstores then waits so user can heap    * dump and bring up resultant hprof in something like jprofiler which    * allows you get 'deep size' on objects.    * @param args main args    */
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|RuntimeMXBean
name|runtime
init|=
name|ManagementFactory
operator|.
name|getRuntimeMXBean
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"vmName="
operator|+
name|runtime
operator|.
name|getVmName
argument_list|()
operator|+
literal|", vmVendor="
operator|+
name|runtime
operator|.
name|getVmVendor
argument_list|()
operator|+
literal|", vmVersion="
operator|+
name|runtime
operator|.
name|getVmVersion
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"vmInputArguments="
operator|+
name|runtime
operator|.
name|getInputArguments
argument_list|()
argument_list|)
expr_stmt|;
name|MemStore
name|memstore1
init|=
operator|new
name|MemStore
argument_list|()
decl_stmt|;
comment|// TODO: x32 vs x64
name|long
name|size
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|count
init|=
literal|10000
decl_stmt|;
name|byte
index|[]
name|fam
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"col"
argument_list|)
decl_stmt|;
name|byte
index|[]
name|qf
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"umn"
argument_list|)
decl_stmt|;
name|byte
index|[]
name|empty
init|=
operator|new
name|byte
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|// Give each its own ts
name|size
operator|+=
name|memstore1
operator|.
name|add
argument_list|(
operator|new
name|KeyValue
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|i
argument_list|)
argument_list|,
name|fam
argument_list|,
name|qf
argument_list|,
name|i
argument_list|,
name|empty
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"memstore1 estimated size="
operator|+
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|+=
name|memstore1
operator|.
name|add
argument_list|(
operator|new
name|KeyValue
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|i
argument_list|)
argument_list|,
name|fam
argument_list|,
name|qf
argument_list|,
name|i
argument_list|,
name|empty
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"memstore1 estimated size (2nd loading of same data)="
operator|+
name|size
argument_list|)
expr_stmt|;
comment|// Make a variably sized memstore.
name|MemStore
name|memstore2
init|=
operator|new
name|MemStore
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|+=
name|memstore2
operator|.
name|add
argument_list|(
operator|new
name|KeyValue
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|i
argument_list|)
argument_list|,
name|fam
argument_list|,
name|qf
argument_list|,
name|i
argument_list|,
operator|new
name|byte
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"memstore2 estimated size="
operator|+
name|size
argument_list|)
expr_stmt|;
specifier|final
name|int
name|seconds
init|=
literal|30
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting "
operator|+
name|seconds
operator|+
literal|" seconds while heap dump is taken"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|seconds
condition|;
name|i
operator|++
control|)
block|{
comment|// Thread.sleep(1000);
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Exiting."
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

