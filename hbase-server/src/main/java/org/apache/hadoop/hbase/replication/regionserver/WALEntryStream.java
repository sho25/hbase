begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|regionserver
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|PriorityBlockingQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|wal
operator|.
name|ProtobufLogReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|CancelableProgressable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|LeaseNotRecoveredException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WAL
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WAL
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WALFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_comment
comment|/**  * Streaming access to WAL entries. This class is given a queue of WAL {@link Path}, and continually  * iterates through all the WAL {@link Entry} in the queue. When it's done reading from a Path, it  * dequeues it and starts reading from the next.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
class|class
name|WALEntryStream
implements|implements
name|Iterator
argument_list|<
name|Entry
argument_list|>
implements|,
name|Closeable
implements|,
name|Iterable
argument_list|<
name|Entry
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|WALEntryStream
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|Reader
name|reader
decl_stmt|;
specifier|private
name|Path
name|currentPath
decl_stmt|;
comment|// cache of next entry for hasNext()
specifier|private
name|Entry
name|currentEntry
decl_stmt|;
comment|// position after reading current entry
specifier|private
name|long
name|currentPosition
init|=
literal|0
decl_stmt|;
specifier|private
name|PriorityBlockingQueue
argument_list|<
name|Path
argument_list|>
name|logQueue
decl_stmt|;
specifier|private
name|FileSystem
name|fs
decl_stmt|;
specifier|private
name|Configuration
name|conf
decl_stmt|;
specifier|private
name|MetricsSource
name|metrics
decl_stmt|;
comment|/**    * Create an entry stream over the given queue    * @param logQueue the queue of WAL paths    * @param fs {@link FileSystem} to use to create {@link Reader} for this stream    * @param conf {@link Configuration} to use to create {@link Reader} for this stream    * @param metrics replication metrics    * @throws IOException    */
specifier|public
name|WALEntryStream
parameter_list|(
name|PriorityBlockingQueue
argument_list|<
name|Path
argument_list|>
name|logQueue
parameter_list|,
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|MetricsSource
name|metrics
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|logQueue
argument_list|,
name|fs
argument_list|,
name|conf
argument_list|,
literal|0
argument_list|,
name|metrics
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create an entry stream over the given queue at the given start position    * @param logQueue the queue of WAL paths    * @param fs {@link FileSystem} to use to create {@link Reader} for this stream    * @param conf {@link Configuration} to use to create {@link Reader} for this stream    * @param startPosition the position in the first WAL to start reading at    * @param metrics replication metrics    * @throws IOException    */
specifier|public
name|WALEntryStream
parameter_list|(
name|PriorityBlockingQueue
argument_list|<
name|Path
argument_list|>
name|logQueue
parameter_list|,
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|long
name|startPosition
parameter_list|,
name|MetricsSource
name|metrics
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|logQueue
operator|=
name|logQueue
expr_stmt|;
name|this
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|currentPosition
operator|=
name|startPosition
expr_stmt|;
name|this
operator|.
name|metrics
operator|=
name|metrics
expr_stmt|;
block|}
comment|/**    * @return true if there is another WAL {@link Entry}    * @throws WALEntryStreamRuntimeException if there was an Exception while reading    */
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
if|if
condition|(
name|currentEntry
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|tryAdvanceEntry
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|WALEntryStreamRuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|currentEntry
operator|!=
literal|null
return|;
block|}
comment|/**    * @return the next WAL entry in this stream    * @throws WALEntryStreamRuntimeException if there was an IOException    * @throws NoSuchElementException if no more entries in the stream.    */
annotation|@
name|Override
specifier|public
name|Entry
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
name|Entry
name|save
init|=
name|currentEntry
decl_stmt|;
name|currentEntry
operator|=
literal|null
expr_stmt|;
comment|// gets reloaded by hasNext()
return|return
name|save
return|;
block|}
comment|/**    * Not supported.    */
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|/**    * {@inheritDoc}    */
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|closeReader
argument_list|()
expr_stmt|;
block|}
comment|/**    * @return the iterator over WAL entries in the queue.    */
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Entry
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|this
return|;
block|}
comment|/**    * @return the position of the last Entry returned by next()    */
specifier|public
name|long
name|getPosition
parameter_list|()
block|{
return|return
name|currentPosition
return|;
block|}
comment|/**    * @return the {@link Path} of the current WAL    */
specifier|public
name|Path
name|getCurrentPath
parameter_list|()
block|{
return|return
name|currentPath
return|;
block|}
specifier|private
name|String
name|getCurrentPathStat
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentPath
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"currently replicating from: "
argument_list|)
operator|.
name|append
argument_list|(
name|currentPath
argument_list|)
operator|.
name|append
argument_list|(
literal|" at position: "
argument_list|)
operator|.
name|append
argument_list|(
name|currentPosition
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"no replication ongoing, waiting for new log"
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Should be called if the stream is to be reused (i.e. used again after hasNext() has returned    * false)    * @throws IOException    */
specifier|public
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|reader
operator|!=
literal|null
operator|&&
name|currentPath
operator|!=
literal|null
condition|)
block|{
name|resetReader
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|setPosition
parameter_list|(
name|long
name|position
parameter_list|)
block|{
name|currentPosition
operator|=
name|position
expr_stmt|;
block|}
specifier|private
name|void
name|setCurrentPath
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
name|this
operator|.
name|currentPath
operator|=
name|path
expr_stmt|;
block|}
specifier|private
name|void
name|tryAdvanceEntry
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|checkReader
argument_list|()
condition|)
block|{
name|readNextEntryAndSetPosition
argument_list|()
expr_stmt|;
if|if
condition|(
name|currentEntry
operator|==
literal|null
condition|)
block|{
comment|// no more entries in this log file - see if log was rolled
if|if
condition|(
name|logQueue
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// log was rolled
comment|// Before dequeueing, we should always get one more attempt at reading.
comment|// This is in case more entries came in after we opened the reader,
comment|// and a new log was enqueued while we were reading. See HBASE-6758
name|resetReader
argument_list|()
expr_stmt|;
name|readNextEntryAndSetPosition
argument_list|()
expr_stmt|;
if|if
condition|(
name|currentEntry
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|checkAllBytesParsed
argument_list|()
condition|)
block|{
comment|// now we're certain we're done with this log file
name|dequeueCurrentLog
argument_list|()
expr_stmt|;
if|if
condition|(
name|openNextLog
argument_list|()
condition|)
block|{
name|readNextEntryAndSetPosition
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// no other logs, we've simply hit the end of the current open log. Do nothing
block|}
block|}
comment|// do nothing if we don't have a WAL Reader (e.g. if there's no logs in queue)
block|}
comment|// HBASE-15984 check to see we have in fact parsed all data in a cleanly closed file
specifier|private
name|boolean
name|checkAllBytesParsed
parameter_list|()
throws|throws
name|IOException
block|{
comment|// -1 means the wal wasn't closed cleanly.
specifier|final
name|long
name|trailerSize
init|=
name|currentTrailerSize
argument_list|()
decl_stmt|;
name|FileStatus
name|stat
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stat
operator|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|this
operator|.
name|currentPath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Couldn't get file length information about log "
operator|+
name|this
operator|.
name|currentPath
operator|+
literal|", it "
operator|+
operator|(
name|trailerSize
operator|<
literal|0
condition|?
literal|"was not"
else|:
literal|"was"
operator|)
operator|+
literal|" closed cleanly "
operator|+
name|getCurrentPathStat
argument_list|()
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|incrUnknownFileLengthForClosedWAL
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|trailerSize
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|currentPosition
operator|<
name|stat
operator|.
name|getLen
argument_list|()
condition|)
block|{
specifier|final
name|long
name|skippedBytes
init|=
name|stat
operator|.
name|getLen
argument_list|()
operator|-
name|currentPosition
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reached the end of WAL file '"
operator|+
name|currentPath
operator|+
literal|"'. It was not closed cleanly, so we did not parse "
operator|+
name|skippedBytes
operator|+
literal|" bytes of data. This is normally ok."
argument_list|)
expr_stmt|;
block|}
name|metrics
operator|.
name|incrUncleanlyClosedWALs
argument_list|()
expr_stmt|;
name|metrics
operator|.
name|incrBytesSkippedInUncleanlyClosedWALs
argument_list|(
name|skippedBytes
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|currentPosition
operator|+
name|trailerSize
operator|<
name|stat
operator|.
name|getLen
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Processing end of WAL file '"
operator|+
name|currentPath
operator|+
literal|"'. At position "
operator|+
name|currentPosition
operator|+
literal|", which is too far away from reported file length "
operator|+
name|stat
operator|.
name|getLen
argument_list|()
operator|+
literal|". Restarting WAL reading (see HBASE-15983 for details). "
operator|+
name|getCurrentPathStat
argument_list|()
argument_list|)
expr_stmt|;
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|resetReader
argument_list|()
expr_stmt|;
name|metrics
operator|.
name|incrRestartedWALReading
argument_list|()
expr_stmt|;
name|metrics
operator|.
name|incrRepeatedFileBytes
argument_list|(
name|currentPosition
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Reached the end of log "
operator|+
name|this
operator|.
name|currentPath
operator|+
literal|", and the length of the file is "
operator|+
operator|(
name|stat
operator|==
literal|null
condition|?
literal|"N/A"
else|:
name|stat
operator|.
name|getLen
argument_list|()
operator|)
argument_list|)
expr_stmt|;
block|}
name|metrics
operator|.
name|incrCompletedWAL
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|dequeueCurrentLog
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reached the end of log "
operator|+
name|currentPath
argument_list|)
expr_stmt|;
block|}
name|closeReader
argument_list|()
expr_stmt|;
name|logQueue
operator|.
name|remove
argument_list|()
expr_stmt|;
name|setPosition
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|decrSizeOfLogQueue
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|readNextEntryAndSetPosition
parameter_list|()
throws|throws
name|IOException
block|{
name|Entry
name|readEntry
init|=
name|reader
operator|.
name|next
argument_list|()
decl_stmt|;
name|long
name|readerPos
init|=
name|reader
operator|.
name|getPosition
argument_list|()
decl_stmt|;
if|if
condition|(
name|readEntry
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|incrLogEditsRead
argument_list|()
expr_stmt|;
name|metrics
operator|.
name|incrLogReadInBytes
argument_list|(
name|readerPos
operator|-
name|currentPosition
argument_list|)
expr_stmt|;
block|}
name|currentEntry
operator|=
name|readEntry
expr_stmt|;
comment|// could be null
name|setPosition
argument_list|(
name|readerPos
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|closeReader
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
block|{
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
name|reader
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// if we don't have a reader, open a reader on the next log
specifier|private
name|boolean
name|checkReader
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|reader
operator|==
literal|null
condition|)
block|{
return|return
name|openNextLog
argument_list|()
return|;
block|}
return|return
literal|true
return|;
block|}
comment|// open a reader on the next log in queue
specifier|private
name|boolean
name|openNextLog
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|nextPath
init|=
name|logQueue
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextPath
operator|!=
literal|null
condition|)
block|{
name|openReader
argument_list|(
name|nextPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|Path
name|getArchivedLog
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|rootDir
init|=
name|FSUtils
operator|.
name|getRootDir
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Path
name|oldLogDir
init|=
operator|new
name|Path
argument_list|(
name|rootDir
argument_list|,
name|HConstants
operator|.
name|HREGION_OLDLOGDIR_NAME
argument_list|)
decl_stmt|;
name|Path
name|archivedLogLocation
init|=
operator|new
name|Path
argument_list|(
name|oldLogDir
argument_list|,
name|path
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|archivedLogLocation
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Log "
operator|+
name|path
operator|+
literal|" was moved to "
operator|+
name|archivedLogLocation
argument_list|)
expr_stmt|;
return|return
name|archivedLogLocation
return|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Couldn't locate log: "
operator|+
name|path
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
block|}
specifier|private
name|void
name|handleFileNotFound
parameter_list|(
name|Path
name|path
parameter_list|,
name|FileNotFoundException
name|fnfe
parameter_list|)
throws|throws
name|IOException
block|{
comment|// If the log was archived, continue reading from there
name|Path
name|archivedLog
init|=
name|getArchivedLog
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|path
operator|.
name|equals
argument_list|(
name|archivedLog
argument_list|)
condition|)
block|{
name|openReader
argument_list|(
name|archivedLog
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|fnfe
throw|;
block|}
block|}
specifier|private
name|void
name|openReader
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
comment|// Detect if this is a new file, if so get a new reader else
comment|// reset the current reader so that we see the new data
if|if
condition|(
name|reader
operator|==
literal|null
operator|||
operator|!
name|getCurrentPath
argument_list|()
operator|.
name|equals
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|closeReader
argument_list|()
expr_stmt|;
name|reader
operator|=
name|WALFactory
operator|.
name|createReader
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|seek
argument_list|()
expr_stmt|;
name|setCurrentPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|resetReader
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfe
parameter_list|)
block|{
name|handleFileNotFound
argument_list|(
name|path
argument_list|,
name|fnfe
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
name|IOException
name|ioe
init|=
name|re
operator|.
name|unwrapRemoteException
argument_list|(
name|FileNotFoundException
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ioe
operator|instanceof
name|FileNotFoundException
operator|)
condition|)
throw|throw
name|ioe
throw|;
name|handleFileNotFound
argument_list|(
name|path
argument_list|,
operator|(
name|FileNotFoundException
operator|)
name|ioe
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LeaseNotRecoveredException
name|lnre
parameter_list|)
block|{
comment|// HBASE-15019 the WAL was not closed due to some hiccup.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Try to recover the WAL lease "
operator|+
name|currentPath
argument_list|,
name|lnre
argument_list|)
expr_stmt|;
name|recoverLease
argument_list|(
name|conf
argument_list|,
name|currentPath
argument_list|)
expr_stmt|;
name|reader
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|npe
parameter_list|)
block|{
comment|// Workaround for race condition in HDFS-4380
comment|// which throws a NPE if we open a file before any data node has the most recent block
comment|// Just sleep and retry. Will require re-reading compressed WALs for compressionContext.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Got NPE opening reader, will retry."
argument_list|)
expr_stmt|;
name|reader
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// For HBASE-15019
specifier|private
name|void
name|recoverLease
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|Path
name|path
parameter_list|)
block|{
try|try
block|{
specifier|final
name|FileSystem
name|dfs
init|=
name|FSUtils
operator|.
name|getCurrentFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FSUtils
name|fsUtils
init|=
name|FSUtils
operator|.
name|getInstance
argument_list|(
name|dfs
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|fsUtils
operator|.
name|recoverFileLease
argument_list|(
name|dfs
argument_list|,
name|path
argument_list|,
name|conf
argument_list|,
operator|new
name|CancelableProgressable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|progress
parameter_list|()
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"recover WAL lease: "
operator|+
name|path
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"unable to recover lease for WAL: "
operator|+
name|path
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|resetReader
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|reader
operator|.
name|reset
argument_list|()
expr_stmt|;
name|seek
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfe
parameter_list|)
block|{
comment|// If the log was archived, continue reading from there
name|Path
name|archivedLog
init|=
name|getArchivedLog
argument_list|(
name|currentPath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|currentPath
operator|.
name|equals
argument_list|(
name|archivedLog
argument_list|)
condition|)
block|{
name|openReader
argument_list|(
name|archivedLog
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|fnfe
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|npe
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"NPE resetting reader, likely HDFS-4380"
argument_list|,
name|npe
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|seek
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentPosition
operator|!=
literal|0
condition|)
block|{
name|reader
operator|.
name|seek
argument_list|(
name|currentPosition
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|long
name|currentTrailerSize
parameter_list|()
block|{
name|long
name|size
init|=
operator|-
literal|1L
decl_stmt|;
if|if
condition|(
name|reader
operator|instanceof
name|ProtobufLogReader
condition|)
block|{
specifier|final
name|ProtobufLogReader
name|pblr
init|=
operator|(
name|ProtobufLogReader
operator|)
name|reader
decl_stmt|;
name|size
operator|=
name|pblr
operator|.
name|trailerSize
argument_list|()
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|static
class|class
name|WALEntryStreamRuntimeException
extends|extends
name|RuntimeException
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
operator|-
literal|6298201811259982568L
decl_stmt|;
specifier|public
name|WALEntryStreamRuntimeException
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|super
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

