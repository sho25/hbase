begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2007 The Apache Software Foundation  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
operator|.
name|KVComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|migration
operator|.
name|HRegionInfo090x
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|RegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSTableDescriptors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|JenkinsHash
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|MD5Hash
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Writables
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|VersionedWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableComparable
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|ByteString
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|InvalidProtocolBufferException
import|;
end_import

begin_comment
comment|/**  * HRegion information.  * Contains HRegion id, start and end keys, a reference to this HRegions' table descriptor, etc.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
class|class
name|HRegionInfo
extends|extends
name|VersionedWritable
implements|implements
name|WritableComparable
argument_list|<
name|HRegionInfo
argument_list|>
block|{
comment|// VERSION == 0 when HRegionInfo had an HTableDescriptor inside it.
specifier|public
specifier|static
specifier|final
name|byte
name|VERSION_PRE_092
init|=
literal|0
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
name|VERSION
init|=
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HRegionInfo
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * The new format for a region name contains its encodedName at the end.    * The encoded name also serves as the directory name for the region    * in the filesystem.    *    * New region name format:    *&lt;tablename>,,&lt;startkey>,&lt;regionIdTimestamp>.&lt;encodedName>.    * where,    *&lt;encodedName> is a hex version of the MD5 hash of    *&lt;tablename>,&lt;startkey>,&lt;regionIdTimestamp>    *     * The old region name format:    *&lt;tablename>,&lt;startkey>,&lt;regionIdTimestamp>    * For region names in the old format, the encoded name is a 32-bit    * JenkinsHash integer value (in its decimal notation, string form).     *<p>    * **NOTE**    *    * ROOT, the first META region, and regions created by an older    * version of HBase (0.20 or prior) will continue to use the    * old region name format.    */
comment|/** Separator used to demarcate the encodedName in a region name    * in the new format. See description on new format above.     */
specifier|private
specifier|static
specifier|final
name|int
name|ENC_SEPARATOR
init|=
literal|'.'
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|MD5_HEX_LENGTH
init|=
literal|32
decl_stmt|;
comment|/**    * Does region name contain its encoded name?    * @param regionName region name    * @return boolean indicating if this a new format region    *         name which contains its encoded name.    */
specifier|private
specifier|static
name|boolean
name|hasEncodedName
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
block|{
comment|// check if region name ends in ENC_SEPARATOR
if|if
condition|(
operator|(
name|regionName
operator|.
name|length
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|regionName
index|[
name|regionName
operator|.
name|length
operator|-
literal|1
index|]
operator|==
name|ENC_SEPARATOR
operator|)
condition|)
block|{
comment|// region name is new format. it contains the encoded name.
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * @param regionName    * @return the encodedName    */
specifier|public
specifier|static
name|String
name|encodeRegionName
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
block|{
name|String
name|encodedName
decl_stmt|;
if|if
condition|(
name|hasEncodedName
argument_list|(
name|regionName
argument_list|)
condition|)
block|{
comment|// region is in new format:
comment|//<tableName>,<startKey>,<regionIdTimeStamp>/encodedName/
name|encodedName
operator|=
name|Bytes
operator|.
name|toString
argument_list|(
name|regionName
argument_list|,
name|regionName
operator|.
name|length
operator|-
name|MD5_HEX_LENGTH
operator|-
literal|1
argument_list|,
name|MD5_HEX_LENGTH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// old format region name. ROOT and first META region also
comment|// use this format.EncodedName is the JenkinsHash value.
name|int
name|hashVal
init|=
name|Math
operator|.
name|abs
argument_list|(
name|JenkinsHash
operator|.
name|getInstance
argument_list|()
operator|.
name|hash
argument_list|(
name|regionName
argument_list|,
name|regionName
operator|.
name|length
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|encodedName
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|hashVal
argument_list|)
expr_stmt|;
block|}
return|return
name|encodedName
return|;
block|}
comment|/**    * Use logging.    * @param encodedRegionName The encoded regionname.    * @return<code>-ROOT-</code> if passed<code>70236052</code> or    *<code>.META.</code> if passed</code>1028785192</code> else returns    *<code>encodedRegionName</code>    */
specifier|public
specifier|static
name|String
name|prettyPrint
parameter_list|(
specifier|final
name|String
name|encodedRegionName
parameter_list|)
block|{
if|if
condition|(
name|encodedRegionName
operator|.
name|equals
argument_list|(
literal|"70236052"
argument_list|)
condition|)
block|{
return|return
name|encodedRegionName
operator|+
literal|"/-ROOT-"
return|;
block|}
elseif|else
if|if
condition|(
name|encodedRegionName
operator|.
name|equals
argument_list|(
literal|"1028785192"
argument_list|)
condition|)
block|{
return|return
name|encodedRegionName
operator|+
literal|"/.META."
return|;
block|}
return|return
name|encodedRegionName
return|;
block|}
comment|/** HRegionInfo for root region */
specifier|public
specifier|static
specifier|final
name|HRegionInfo
name|ROOT_REGIONINFO
init|=
operator|new
name|HRegionInfo
argument_list|(
literal|0L
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"-ROOT-"
argument_list|)
argument_list|)
decl_stmt|;
comment|/** HRegionInfo for first meta region */
specifier|public
specifier|static
specifier|final
name|HRegionInfo
name|FIRST_META_REGIONINFO
init|=
operator|new
name|HRegionInfo
argument_list|(
literal|1L
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|".META."
argument_list|)
argument_list|)
decl_stmt|;
specifier|private
name|byte
index|[]
name|endKey
init|=
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
decl_stmt|;
comment|// This flag is in the parent of a split while the parent is still referenced
comment|// by daughter regions.  We USED to set this flag when we disabled a table
comment|// but now table state is kept up in zookeeper as of 0.90.0 HBase.
specifier|private
name|boolean
name|offLine
init|=
literal|false
decl_stmt|;
specifier|private
name|long
name|regionId
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|transient
name|byte
index|[]
name|regionName
init|=
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
decl_stmt|;
specifier|private
name|String
name|regionNameStr
init|=
literal|""
decl_stmt|;
specifier|private
name|boolean
name|split
init|=
literal|false
decl_stmt|;
specifier|private
name|byte
index|[]
name|startKey
init|=
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
decl_stmt|;
specifier|private
name|int
name|hashCode
init|=
operator|-
literal|1
decl_stmt|;
comment|//TODO: Move NO_HASH to HStoreFile which is really the only place it is used.
specifier|public
specifier|static
specifier|final
name|String
name|NO_HASH
init|=
literal|null
decl_stmt|;
specifier|private
specifier|volatile
name|String
name|encodedName
init|=
name|NO_HASH
decl_stmt|;
specifier|private
name|byte
index|[]
name|encodedNameAsBytes
init|=
literal|null
decl_stmt|;
comment|// Current TableName
specifier|private
name|byte
index|[]
name|tableName
init|=
literal|null
decl_stmt|;
specifier|private
name|void
name|setHashCode
parameter_list|()
block|{
name|int
name|result
init|=
name|Arrays
operator|.
name|hashCode
argument_list|(
name|this
operator|.
name|regionName
argument_list|)
decl_stmt|;
name|result
operator|^=
name|this
operator|.
name|regionId
expr_stmt|;
name|result
operator|^=
name|Arrays
operator|.
name|hashCode
argument_list|(
name|this
operator|.
name|startKey
argument_list|)
expr_stmt|;
name|result
operator|^=
name|Arrays
operator|.
name|hashCode
argument_list|(
name|this
operator|.
name|endKey
argument_list|)
expr_stmt|;
name|result
operator|^=
name|Boolean
operator|.
name|valueOf
argument_list|(
name|this
operator|.
name|offLine
argument_list|)
operator|.
name|hashCode
argument_list|()
expr_stmt|;
name|result
operator|^=
name|Arrays
operator|.
name|hashCode
argument_list|(
name|this
operator|.
name|tableName
argument_list|)
expr_stmt|;
name|this
operator|.
name|hashCode
operator|=
name|result
expr_stmt|;
block|}
comment|/**    * Private constructor used constructing HRegionInfo for the catalog root and    * first meta regions    */
specifier|private
name|HRegionInfo
parameter_list|(
name|long
name|regionId
parameter_list|,
name|byte
index|[]
name|tableName
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|regionId
operator|=
name|regionId
expr_stmt|;
name|this
operator|.
name|tableName
operator|=
name|tableName
operator|.
name|clone
argument_list|()
expr_stmt|;
comment|// Note: Root& First Meta regions names are still in old format
name|this
operator|.
name|regionName
operator|=
name|createRegionName
argument_list|(
name|tableName
argument_list|,
literal|null
argument_list|,
name|regionId
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionNameStr
operator|=
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|this
operator|.
name|regionName
argument_list|)
expr_stmt|;
name|setHashCode
argument_list|()
expr_stmt|;
block|}
comment|/** Default constructor - creates empty object    * @deprecated Used by Writables and Writables are going away.    */
annotation|@
name|Deprecated
specifier|public
name|HRegionInfo
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
comment|/**    * Used only for migration    * @param other HRegionInfoForMigration    */
specifier|public
name|HRegionInfo
parameter_list|(
name|HRegionInfo090x
name|other
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|endKey
operator|=
name|other
operator|.
name|getEndKey
argument_list|()
expr_stmt|;
name|this
operator|.
name|offLine
operator|=
name|other
operator|.
name|isOffline
argument_list|()
expr_stmt|;
name|this
operator|.
name|regionId
operator|=
name|other
operator|.
name|getRegionId
argument_list|()
expr_stmt|;
name|this
operator|.
name|regionName
operator|=
name|other
operator|.
name|getRegionName
argument_list|()
expr_stmt|;
name|this
operator|.
name|regionNameStr
operator|=
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|this
operator|.
name|regionName
argument_list|)
expr_stmt|;
name|this
operator|.
name|split
operator|=
name|other
operator|.
name|isSplit
argument_list|()
expr_stmt|;
name|this
operator|.
name|startKey
operator|=
name|other
operator|.
name|getStartKey
argument_list|()
expr_stmt|;
name|this
operator|.
name|hashCode
operator|=
name|other
operator|.
name|hashCode
argument_list|()
expr_stmt|;
name|this
operator|.
name|encodedName
operator|=
name|other
operator|.
name|getEncodedName
argument_list|()
expr_stmt|;
name|this
operator|.
name|tableName
operator|=
name|other
operator|.
name|getTableDesc
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
specifier|public
name|HRegionInfo
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|)
block|{
name|this
argument_list|(
name|tableName
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct HRegionInfo with explicit parameters    *    * @param tableName the table name    * @param startKey first key in region    * @param endKey end of key range    * @throws IllegalArgumentException    */
specifier|public
name|HRegionInfo
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|byte
index|[]
name|endKey
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|this
argument_list|(
name|tableName
argument_list|,
name|startKey
argument_list|,
name|endKey
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct HRegionInfo with explicit parameters    *    * @param tableName the table descriptor    * @param startKey first key in region    * @param endKey end of key range    * @param split true if this region has split and we have daughter regions    * regions that may or may not hold references to this region.    * @throws IllegalArgumentException    */
specifier|public
name|HRegionInfo
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|byte
index|[]
name|endKey
parameter_list|,
specifier|final
name|boolean
name|split
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|this
argument_list|(
name|tableName
argument_list|,
name|startKey
argument_list|,
name|endKey
argument_list|,
name|split
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct HRegionInfo with explicit parameters    *    * @param tableName the table descriptor    * @param startKey first key in region    * @param endKey end of key range    * @param split true if this region has split and we have daughter regions    * regions that may or may not hold references to this region.    * @param regionid Region id to use.    * @throws IllegalArgumentException    */
specifier|public
name|HRegionInfo
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|byte
index|[]
name|endKey
parameter_list|,
specifier|final
name|boolean
name|split
parameter_list|,
specifier|final
name|long
name|regionid
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|super
argument_list|()
expr_stmt|;
if|if
condition|(
name|tableName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"tableName cannot be null"
argument_list|)
throw|;
block|}
name|this
operator|.
name|tableName
operator|=
name|tableName
operator|.
name|clone
argument_list|()
expr_stmt|;
name|this
operator|.
name|offLine
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|regionId
operator|=
name|regionid
expr_stmt|;
name|this
operator|.
name|regionName
operator|=
name|createRegionName
argument_list|(
name|this
operator|.
name|tableName
argument_list|,
name|startKey
argument_list|,
name|regionId
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionNameStr
operator|=
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|this
operator|.
name|regionName
argument_list|)
expr_stmt|;
name|this
operator|.
name|split
operator|=
name|split
expr_stmt|;
name|this
operator|.
name|endKey
operator|=
name|endKey
operator|==
literal|null
condition|?
name|HConstants
operator|.
name|EMPTY_END_ROW
else|:
name|endKey
operator|.
name|clone
argument_list|()
expr_stmt|;
name|this
operator|.
name|startKey
operator|=
name|startKey
operator|==
literal|null
condition|?
name|HConstants
operator|.
name|EMPTY_START_ROW
else|:
name|startKey
operator|.
name|clone
argument_list|()
expr_stmt|;
name|this
operator|.
name|tableName
operator|=
name|tableName
operator|.
name|clone
argument_list|()
expr_stmt|;
name|setHashCode
argument_list|()
expr_stmt|;
block|}
comment|/**    * Costruct a copy of another HRegionInfo    *    * @param other    */
specifier|public
name|HRegionInfo
parameter_list|(
name|HRegionInfo
name|other
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|endKey
operator|=
name|other
operator|.
name|getEndKey
argument_list|()
expr_stmt|;
name|this
operator|.
name|offLine
operator|=
name|other
operator|.
name|isOffline
argument_list|()
expr_stmt|;
name|this
operator|.
name|regionId
operator|=
name|other
operator|.
name|getRegionId
argument_list|()
expr_stmt|;
name|this
operator|.
name|regionName
operator|=
name|other
operator|.
name|getRegionName
argument_list|()
expr_stmt|;
name|this
operator|.
name|regionNameStr
operator|=
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|this
operator|.
name|regionName
argument_list|)
expr_stmt|;
name|this
operator|.
name|split
operator|=
name|other
operator|.
name|isSplit
argument_list|()
expr_stmt|;
name|this
operator|.
name|startKey
operator|=
name|other
operator|.
name|getStartKey
argument_list|()
expr_stmt|;
name|this
operator|.
name|hashCode
operator|=
name|other
operator|.
name|hashCode
argument_list|()
expr_stmt|;
name|this
operator|.
name|encodedName
operator|=
name|other
operator|.
name|getEncodedName
argument_list|()
expr_stmt|;
name|this
operator|.
name|tableName
operator|=
name|other
operator|.
name|tableName
expr_stmt|;
block|}
comment|/**    * Make a region name of passed parameters.    * @param tableName    * @param startKey Can be null    * @param regionid Region id (Usually timestamp from when region was created).    * @param newFormat should we create the region name in the new format    *                  (such that it contains its encoded name?).    * @return Region name made of passed tableName, startKey and id    */
specifier|public
specifier|static
name|byte
index|[]
name|createRegionName
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|long
name|regionid
parameter_list|,
name|boolean
name|newFormat
parameter_list|)
block|{
return|return
name|createRegionName
argument_list|(
name|tableName
argument_list|,
name|startKey
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|regionid
argument_list|)
argument_list|,
name|newFormat
argument_list|)
return|;
block|}
comment|/**    * Make a region name of passed parameters.    * @param tableName    * @param startKey Can be null    * @param id Region id (Usually timestamp from when region was created).    * @param newFormat should we create the region name in the new format    *                  (such that it contains its encoded name?).    * @return Region name made of passed tableName, startKey and id    */
specifier|public
specifier|static
name|byte
index|[]
name|createRegionName
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|String
name|id
parameter_list|,
name|boolean
name|newFormat
parameter_list|)
block|{
return|return
name|createRegionName
argument_list|(
name|tableName
argument_list|,
name|startKey
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|id
argument_list|)
argument_list|,
name|newFormat
argument_list|)
return|;
block|}
comment|/**    * Make a region name of passed parameters.    * @param tableName    * @param startKey Can be null    * @param id Region id (Usually timestamp from when region was created).    * @param newFormat should we create the region name in the new format    *                  (such that it contains its encoded name?).    * @return Region name made of passed tableName, startKey and id    */
specifier|public
specifier|static
name|byte
index|[]
name|createRegionName
parameter_list|(
specifier|final
name|byte
index|[]
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|startKey
parameter_list|,
specifier|final
name|byte
index|[]
name|id
parameter_list|,
name|boolean
name|newFormat
parameter_list|)
block|{
name|byte
index|[]
name|b
init|=
operator|new
name|byte
index|[
name|tableName
operator|.
name|length
operator|+
literal|2
operator|+
name|id
operator|.
name|length
operator|+
operator|(
name|startKey
operator|==
literal|null
condition|?
literal|0
else|:
name|startKey
operator|.
name|length
operator|)
operator|+
operator|(
name|newFormat
condition|?
operator|(
name|MD5_HEX_LENGTH
operator|+
literal|2
operator|)
else|:
literal|0
operator|)
index|]
decl_stmt|;
name|int
name|offset
init|=
name|tableName
operator|.
name|length
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|tableName
argument_list|,
literal|0
argument_list|,
name|b
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|b
index|[
name|offset
operator|++
index|]
operator|=
name|HConstants
operator|.
name|DELIMITER
expr_stmt|;
if|if
condition|(
name|startKey
operator|!=
literal|null
operator|&&
name|startKey
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|startKey
argument_list|,
literal|0
argument_list|,
name|b
argument_list|,
name|offset
argument_list|,
name|startKey
operator|.
name|length
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|startKey
operator|.
name|length
expr_stmt|;
block|}
name|b
index|[
name|offset
operator|++
index|]
operator|=
name|HConstants
operator|.
name|DELIMITER
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|id
argument_list|,
literal|0
argument_list|,
name|b
argument_list|,
name|offset
argument_list|,
name|id
operator|.
name|length
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|id
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|newFormat
condition|)
block|{
comment|//
comment|// Encoded name should be built into the region name.
comment|//
comment|// Use the region name thus far (namely,<tablename>,<startKey>,<id>)
comment|// to compute a MD5 hash to be used as the encoded name, and append
comment|// it to the byte buffer.
comment|//
name|String
name|md5Hash
init|=
name|MD5Hash
operator|.
name|getMD5AsHex
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|byte
index|[]
name|md5HashBytes
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|md5Hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|md5HashBytes
operator|.
name|length
operator|!=
name|MD5_HEX_LENGTH
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"MD5-hash length mismatch: Expected="
operator|+
name|MD5_HEX_LENGTH
operator|+
literal|"; Got="
operator|+
name|md5HashBytes
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|// now append the bytes '.<encodedName>.' to the end
name|b
index|[
name|offset
operator|++
index|]
operator|=
name|ENC_SEPARATOR
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|md5HashBytes
argument_list|,
literal|0
argument_list|,
name|b
argument_list|,
name|offset
argument_list|,
name|MD5_HEX_LENGTH
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|MD5_HEX_LENGTH
expr_stmt|;
name|b
index|[
name|offset
operator|++
index|]
operator|=
name|ENC_SEPARATOR
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
comment|/**    * Gets the table name from the specified region name.    * @param regionName    * @return Table name.    */
specifier|public
specifier|static
name|byte
index|[]
name|getTableName
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|)
block|{
name|int
name|offset
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|regionName
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regionName
index|[
name|i
index|]
operator|==
name|HConstants
operator|.
name|DELIMITER
condition|)
block|{
name|offset
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|byte
index|[]
name|tableName
init|=
operator|new
name|byte
index|[
name|offset
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|regionName
argument_list|,
literal|0
argument_list|,
name|tableName
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|tableName
return|;
block|}
comment|/**    * Separate elements of a regionName.    * @param regionName    * @return Array of byte[] containing tableName, startKey and id    * @throws IOException    */
specifier|public
specifier|static
name|byte
index|[]
index|[]
name|parseRegionName
parameter_list|(
specifier|final
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|offset
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|regionName
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regionName
index|[
name|i
index|]
operator|==
name|HConstants
operator|.
name|DELIMITER
condition|)
block|{
name|offset
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|offset
operator|==
operator|-
literal|1
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid regionName format"
argument_list|)
throw|;
name|byte
index|[]
name|tableName
init|=
operator|new
name|byte
index|[
name|offset
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|regionName
argument_list|,
literal|0
argument_list|,
name|tableName
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|regionName
operator|.
name|length
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|regionName
index|[
name|i
index|]
operator|==
name|HConstants
operator|.
name|DELIMITER
condition|)
block|{
name|offset
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|offset
operator|==
operator|-
literal|1
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid regionName format"
argument_list|)
throw|;
name|byte
index|[]
name|startKey
init|=
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
decl_stmt|;
if|if
condition|(
name|offset
operator|!=
name|tableName
operator|.
name|length
operator|+
literal|1
condition|)
block|{
name|startKey
operator|=
operator|new
name|byte
index|[
name|offset
operator|-
name|tableName
operator|.
name|length
operator|-
literal|1
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|regionName
argument_list|,
name|tableName
operator|.
name|length
operator|+
literal|1
argument_list|,
name|startKey
argument_list|,
literal|0
argument_list|,
name|offset
operator|-
name|tableName
operator|.
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|id
init|=
operator|new
name|byte
index|[
name|regionName
operator|.
name|length
operator|-
name|offset
operator|-
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|regionName
argument_list|,
name|offset
operator|+
literal|1
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
name|regionName
operator|.
name|length
operator|-
name|offset
operator|-
literal|1
argument_list|)
expr_stmt|;
name|byte
index|[]
index|[]
name|elements
init|=
operator|new
name|byte
index|[
literal|3
index|]
index|[]
decl_stmt|;
name|elements
index|[
literal|0
index|]
operator|=
name|tableName
expr_stmt|;
name|elements
index|[
literal|1
index|]
operator|=
name|startKey
expr_stmt|;
name|elements
index|[
literal|2
index|]
operator|=
name|id
expr_stmt|;
return|return
name|elements
return|;
block|}
comment|/** @return the regionId */
specifier|public
name|long
name|getRegionId
parameter_list|()
block|{
return|return
name|regionId
return|;
block|}
comment|/**    * @return the regionName as an array of bytes.    * @see #getRegionNameAsString()    */
specifier|public
name|byte
index|[]
name|getRegionName
parameter_list|()
block|{
return|return
name|regionName
return|;
block|}
comment|/**    * @return Region name as a String for use in logging, etc.    */
specifier|public
name|String
name|getRegionNameAsString
parameter_list|()
block|{
if|if
condition|(
name|hasEncodedName
argument_list|(
name|this
operator|.
name|regionName
argument_list|)
condition|)
block|{
comment|// new format region names already have their encoded name.
return|return
name|this
operator|.
name|regionNameStr
return|;
block|}
comment|// old format. regionNameStr doesn't have the region name.
comment|//
comment|//
return|return
name|this
operator|.
name|regionNameStr
operator|+
literal|"."
operator|+
name|this
operator|.
name|getEncodedName
argument_list|()
return|;
block|}
comment|/** @return the encoded region name */
specifier|public
specifier|synchronized
name|String
name|getEncodedName
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|encodedName
operator|==
name|NO_HASH
condition|)
block|{
name|this
operator|.
name|encodedName
operator|=
name|encodeRegionName
argument_list|(
name|this
operator|.
name|regionName
argument_list|)
expr_stmt|;
block|}
return|return
name|this
operator|.
name|encodedName
return|;
block|}
specifier|public
specifier|synchronized
name|byte
index|[]
name|getEncodedNameAsBytes
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|encodedNameAsBytes
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|encodedNameAsBytes
operator|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|this
operator|.
name|encodedNameAsBytes
return|;
block|}
comment|/** @return the startKey */
specifier|public
name|byte
index|[]
name|getStartKey
parameter_list|()
block|{
return|return
name|startKey
return|;
block|}
comment|/** @return the endKey */
specifier|public
name|byte
index|[]
name|getEndKey
parameter_list|()
block|{
return|return
name|endKey
return|;
block|}
comment|/**    * Get current table name of the region    * @return byte array of table name    */
specifier|public
name|byte
index|[]
name|getTableName
parameter_list|()
block|{
if|if
condition|(
name|tableName
operator|==
literal|null
operator|||
name|tableName
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|tableName
operator|=
name|getTableName
argument_list|(
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|tableName
return|;
block|}
comment|/**    * Get current table name as string    * @return string representation of current table    */
specifier|public
name|String
name|getTableNameAsString
parameter_list|()
block|{
return|return
name|Bytes
operator|.
name|toString
argument_list|(
name|tableName
argument_list|)
return|;
block|}
comment|/**    * Returns true if the given inclusive range of rows is fully contained    * by this region. For example, if the region is foo,a,g and this is    * passed ["b","c"] or ["a","c"] it will return true, but if this is passed    * ["b","z"] it will return false.    * @throws IllegalArgumentException if the range passed is invalid (ie end< start)    */
specifier|public
name|boolean
name|containsRange
parameter_list|(
name|byte
index|[]
name|rangeStartKey
parameter_list|,
name|byte
index|[]
name|rangeEndKey
parameter_list|)
block|{
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|rangeStartKey
argument_list|,
name|rangeEndKey
argument_list|)
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid range: "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|rangeStartKey
argument_list|)
operator|+
literal|"> "
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|rangeEndKey
argument_list|)
argument_list|)
throw|;
block|}
name|boolean
name|firstKeyInRange
init|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|rangeStartKey
argument_list|,
name|startKey
argument_list|)
operator|>=
literal|0
decl_stmt|;
name|boolean
name|lastKeyInRange
init|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|rangeEndKey
argument_list|,
name|endKey
argument_list|)
operator|<
literal|0
operator|||
name|Bytes
operator|.
name|equals
argument_list|(
name|endKey
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|)
decl_stmt|;
return|return
name|firstKeyInRange
operator|&&
name|lastKeyInRange
return|;
block|}
comment|/**    * Return true if the given row falls in this region.    */
specifier|public
name|boolean
name|containsRow
parameter_list|(
name|byte
index|[]
name|row
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|row
argument_list|,
name|startKey
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|row
argument_list|,
name|endKey
argument_list|)
operator|<
literal|0
operator|||
name|Bytes
operator|.
name|equals
argument_list|(
name|endKey
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|)
operator|)
return|;
block|}
comment|/**    * @return the tableDesc    * @deprecated Do not use; expensive call    *         use HRegionInfo.getTableNameAsString() in place of    *         HRegionInfo.getTableDesc().getNameAsString()    */
annotation|@
name|Deprecated
specifier|public
name|HTableDescriptor
name|getTableDesc
parameter_list|()
block|{
name|Configuration
name|c
init|=
name|HBaseConfiguration
operator|.
name|create
argument_list|()
decl_stmt|;
name|FileSystem
name|fs
decl_stmt|;
try|try
block|{
name|fs
operator|=
name|FileSystem
operator|.
name|get
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|FSTableDescriptors
name|fstd
init|=
operator|new
name|FSTableDescriptors
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
name|c
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|HBASE_DIR
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|fstd
operator|.
name|get
argument_list|(
name|this
operator|.
name|tableName
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * @param newDesc new table descriptor to use    * @deprecated Do not use; expensive call    */
annotation|@
name|Deprecated
specifier|public
name|void
name|setTableDesc
parameter_list|(
name|HTableDescriptor
name|newDesc
parameter_list|)
block|{
name|Configuration
name|c
init|=
name|HBaseConfiguration
operator|.
name|create
argument_list|()
decl_stmt|;
name|FileSystem
name|fs
decl_stmt|;
try|try
block|{
name|fs
operator|=
name|FileSystem
operator|.
name|get
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|FSTableDescriptors
name|fstd
init|=
operator|new
name|FSTableDescriptors
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
name|c
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|HBASE_DIR
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|fstd
operator|.
name|add
argument_list|(
name|newDesc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** @return true if this is the root region */
specifier|public
name|boolean
name|isRootRegion
parameter_list|()
block|{
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|tableName
argument_list|,
name|HRegionInfo
operator|.
name|ROOT_REGIONINFO
operator|.
name|getTableName
argument_list|()
argument_list|)
return|;
block|}
comment|/** @return true if this region is from a table that is a meta table,    * either<code>.META.</code> or<code>-ROOT-</code>    */
specifier|public
name|boolean
name|isMetaTable
parameter_list|()
block|{
return|return
name|isRootRegion
argument_list|()
operator|||
name|isMetaRegion
argument_list|()
return|;
block|}
comment|/** @return true if this region is a meta region */
specifier|public
name|boolean
name|isMetaRegion
parameter_list|()
block|{
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|tableName
argument_list|,
name|HRegionInfo
operator|.
name|FIRST_META_REGIONINFO
operator|.
name|getTableName
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @return True if has been split and has daughters.    */
specifier|public
name|boolean
name|isSplit
parameter_list|()
block|{
return|return
name|this
operator|.
name|split
return|;
block|}
comment|/**    * @param split set split status    */
specifier|public
name|void
name|setSplit
parameter_list|(
name|boolean
name|split
parameter_list|)
block|{
name|this
operator|.
name|split
operator|=
name|split
expr_stmt|;
block|}
comment|/**    * @return True if this region is offline.    */
specifier|public
name|boolean
name|isOffline
parameter_list|()
block|{
return|return
name|this
operator|.
name|offLine
return|;
block|}
comment|/**    * The parent of a region split is offline while split daughters hold    * references to the parent. Offlined regions are closed.    * @param offLine Set online/offline status.    */
specifier|public
name|void
name|setOffline
parameter_list|(
name|boolean
name|offLine
parameter_list|)
block|{
name|this
operator|.
name|offLine
operator|=
name|offLine
expr_stmt|;
block|}
comment|/**    * @return True if this is a split parent region.    */
specifier|public
name|boolean
name|isSplitParent
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isSplit
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|isOffline
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Region is split but NOT offline: "
operator|+
name|getRegionNameAsString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * @see java.lang.Object#toString()    */
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"{"
operator|+
name|HConstants
operator|.
name|NAME
operator|+
literal|" => '"
operator|+
name|this
operator|.
name|regionNameStr
operator|+
literal|"', STARTKEY => '"
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|this
operator|.
name|startKey
argument_list|)
operator|+
literal|"', ENDKEY => '"
operator|+
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|this
operator|.
name|endKey
argument_list|)
operator|+
literal|"', ENCODED => "
operator|+
name|getEncodedName
argument_list|()
operator|+
literal|","
operator|+
operator|(
name|isOffline
argument_list|()
condition|?
literal|" OFFLINE => true,"
else|:
literal|""
operator|)
operator|+
operator|(
name|isSplit
argument_list|()
condition|?
literal|" SPLIT => true,"
else|:
literal|""
operator|)
operator|+
literal|"}"
return|;
block|}
comment|/**    * @see java.lang.Object#equals(java.lang.Object)    */
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|HRegionInfo
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|this
operator|.
name|compareTo
argument_list|(
operator|(
name|HRegionInfo
operator|)
name|o
argument_list|)
operator|==
literal|0
return|;
block|}
comment|/**    * @see java.lang.Object#hashCode()    */
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|this
operator|.
name|hashCode
return|;
block|}
comment|/** @return the object version number */
annotation|@
name|Override
specifier|public
name|byte
name|getVersion
parameter_list|()
block|{
return|return
name|VERSION
return|;
block|}
comment|/**    * @deprecated Use protobuf serialization instead.  See {@link #toByteArray()} and    * {@link #toDelimitedByteArray()}    */
annotation|@
name|Deprecated
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|Bytes
operator|.
name|writeByteArray
argument_list|(
name|out
argument_list|,
name|endKey
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBoolean
argument_list|(
name|offLine
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeLong
argument_list|(
name|regionId
argument_list|)
expr_stmt|;
name|Bytes
operator|.
name|writeByteArray
argument_list|(
name|out
argument_list|,
name|regionName
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBoolean
argument_list|(
name|split
argument_list|)
expr_stmt|;
name|Bytes
operator|.
name|writeByteArray
argument_list|(
name|out
argument_list|,
name|startKey
argument_list|)
expr_stmt|;
name|Bytes
operator|.
name|writeByteArray
argument_list|(
name|out
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|hashCode
argument_list|)
expr_stmt|;
block|}
comment|/**    * @deprecated Use protobuf deserialization instead. See {@link #parseFrom(byte[])} and    * {@link #parseFrom(FSDataInputStream)}    */
annotation|@
name|Deprecated
annotation|@
name|Override
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Read the single version byte.  We don't ask the super class do it
comment|// because freaks out if its not the current classes' version.  This method
comment|// can deserialize version 0 and version 1 of HRI.
name|byte
name|version
init|=
name|in
operator|.
name|readByte
argument_list|()
decl_stmt|;
if|if
condition|(
name|version
operator|==
literal|0
condition|)
block|{
comment|// This is the old HRI that carried an HTD.  Migrate it.  The below
comment|// was copied from the old 0.90 HRI readFields.
name|this
operator|.
name|endKey
operator|=
name|Bytes
operator|.
name|readByteArray
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|this
operator|.
name|offLine
operator|=
name|in
operator|.
name|readBoolean
argument_list|()
expr_stmt|;
name|this
operator|.
name|regionId
operator|=
name|in
operator|.
name|readLong
argument_list|()
expr_stmt|;
name|this
operator|.
name|regionName
operator|=
name|Bytes
operator|.
name|readByteArray
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionNameStr
operator|=
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|this
operator|.
name|regionName
argument_list|)
expr_stmt|;
name|this
operator|.
name|split
operator|=
name|in
operator|.
name|readBoolean
argument_list|()
expr_stmt|;
name|this
operator|.
name|startKey
operator|=
name|Bytes
operator|.
name|readByteArray
argument_list|(
name|in
argument_list|)
expr_stmt|;
try|try
block|{
name|HTableDescriptor
name|htd
init|=
operator|new
name|HTableDescriptor
argument_list|()
decl_stmt|;
name|htd
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableName
operator|=
name|htd
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|eofe
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"HTD not found in input buffer"
argument_list|,
name|eofe
argument_list|)
throw|;
block|}
name|this
operator|.
name|hashCode
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|getVersion
argument_list|()
operator|==
name|version
condition|)
block|{
name|this
operator|.
name|endKey
operator|=
name|Bytes
operator|.
name|readByteArray
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|this
operator|.
name|offLine
operator|=
name|in
operator|.
name|readBoolean
argument_list|()
expr_stmt|;
name|this
operator|.
name|regionId
operator|=
name|in
operator|.
name|readLong
argument_list|()
expr_stmt|;
name|this
operator|.
name|regionName
operator|=
name|Bytes
operator|.
name|readByteArray
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionNameStr
operator|=
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|this
operator|.
name|regionName
argument_list|)
expr_stmt|;
name|this
operator|.
name|split
operator|=
name|in
operator|.
name|readBoolean
argument_list|()
expr_stmt|;
name|this
operator|.
name|startKey
operator|=
name|Bytes
operator|.
name|readByteArray
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableName
operator|=
name|Bytes
operator|.
name|readByteArray
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|this
operator|.
name|hashCode
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Non-migratable/unknown version="
operator|+
name|getVersion
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|//
comment|// Comparable
comment|//
specifier|public
name|int
name|compareTo
parameter_list|(
name|HRegionInfo
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|// Are regions of same table?
name|int
name|result
init|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|this
operator|.
name|tableName
argument_list|,
name|o
operator|.
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
comment|// Compare start keys.
name|result
operator|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|this
operator|.
name|startKey
argument_list|,
name|o
operator|.
name|startKey
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
return|return
name|result
return|;
block|}
comment|// Compare end keys.
name|result
operator|=
name|Bytes
operator|.
name|compareTo
argument_list|(
name|this
operator|.
name|endKey
argument_list|,
name|o
operator|.
name|endKey
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|getStartKey
argument_list|()
operator|.
name|length
operator|!=
literal|0
operator|&&
name|this
operator|.
name|getEndKey
argument_list|()
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
comment|// this is last region
block|}
if|if
condition|(
name|o
operator|.
name|getStartKey
argument_list|()
operator|.
name|length
operator|!=
literal|0
operator|&&
name|o
operator|.
name|getEndKey
argument_list|()
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
comment|// o is the last region
block|}
return|return
name|result
return|;
block|}
comment|// regionId is usually milli timestamp -- this defines older stamps
comment|// to be "smaller" than newer stamps in sort order.
if|if
condition|(
name|this
operator|.
name|regionId
operator|>
name|o
operator|.
name|regionId
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|this
operator|.
name|regionId
operator|<
name|o
operator|.
name|regionId
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|this
operator|.
name|offLine
operator|==
name|o
operator|.
name|offLine
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|this
operator|.
name|offLine
operator|==
literal|true
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
comment|/**    * @return Comparator to use comparing {@link KeyValue}s.    */
specifier|public
name|KVComparator
name|getComparator
parameter_list|()
block|{
return|return
name|isRootRegion
argument_list|()
condition|?
name|KeyValue
operator|.
name|ROOT_COMPARATOR
else|:
name|isMetaRegion
argument_list|()
condition|?
name|KeyValue
operator|.
name|META_COMPARATOR
else|:
name|KeyValue
operator|.
name|COMPARATOR
return|;
block|}
comment|/**    * Convert a HRegionInfo to a RegionInfo    *    * @return the converted RegionInfo    */
name|RegionInfo
name|convert
parameter_list|()
block|{
return|return
name|convert
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * Convert a HRegionInfo to a RegionInfo    *    * @param info the HRegionInfo to convert    * @return the converted RegionInfo    */
specifier|public
specifier|static
name|RegionInfo
name|convert
parameter_list|(
specifier|final
name|HRegionInfo
name|info
parameter_list|)
block|{
if|if
condition|(
name|info
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|RegionInfo
operator|.
name|Builder
name|builder
init|=
name|RegionInfo
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|setTableName
argument_list|(
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|info
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setRegionId
argument_list|(
name|info
operator|.
name|getRegionId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|getStartKey
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setStartKey
argument_list|(
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|info
operator|.
name|getStartKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|.
name|getEndKey
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|setEndKey
argument_list|(
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|info
operator|.
name|getEndKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|setOffline
argument_list|(
name|info
operator|.
name|isOffline
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setSplit
argument_list|(
name|info
operator|.
name|isSplit
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * Convert a RegionInfo to a HRegionInfo    *    * @param proto the RegionInfo to convert    * @return the converted HRegionInfo    */
specifier|public
specifier|static
name|HRegionInfo
name|convert
parameter_list|(
specifier|final
name|RegionInfo
name|proto
parameter_list|)
block|{
if|if
condition|(
name|proto
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|byte
index|[]
name|tableName
init|=
name|proto
operator|.
name|getTableName
argument_list|()
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|tableName
argument_list|,
name|HConstants
operator|.
name|ROOT_TABLE_NAME
argument_list|)
condition|)
block|{
return|return
name|ROOT_REGIONINFO
return|;
block|}
elseif|else
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|tableName
argument_list|,
name|HConstants
operator|.
name|META_TABLE_NAME
argument_list|)
condition|)
block|{
return|return
name|FIRST_META_REGIONINFO
return|;
block|}
name|long
name|regionId
init|=
name|proto
operator|.
name|getRegionId
argument_list|()
decl_stmt|;
name|byte
index|[]
name|startKey
init|=
literal|null
decl_stmt|;
name|byte
index|[]
name|endKey
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|proto
operator|.
name|hasStartKey
argument_list|()
condition|)
block|{
name|startKey
operator|=
name|proto
operator|.
name|getStartKey
argument_list|()
operator|.
name|toByteArray
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|proto
operator|.
name|hasEndKey
argument_list|()
condition|)
block|{
name|endKey
operator|=
name|proto
operator|.
name|getEndKey
argument_list|()
operator|.
name|toByteArray
argument_list|()
expr_stmt|;
block|}
name|boolean
name|split
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|proto
operator|.
name|hasSplit
argument_list|()
condition|)
block|{
name|split
operator|=
name|proto
operator|.
name|getSplit
argument_list|()
expr_stmt|;
block|}
name|HRegionInfo
name|hri
init|=
operator|new
name|HRegionInfo
argument_list|(
name|tableName
argument_list|,
name|startKey
argument_list|,
name|endKey
argument_list|,
name|split
argument_list|,
name|regionId
argument_list|)
decl_stmt|;
if|if
condition|(
name|proto
operator|.
name|hasOffline
argument_list|()
condition|)
block|{
name|hri
operator|.
name|setOffline
argument_list|(
name|proto
operator|.
name|getOffline
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|hri
return|;
block|}
comment|/**    * @return This instance serialized as protobuf w/ a magic pb prefix.    * @see #parseFrom(byte[]);    */
specifier|public
name|byte
index|[]
name|toByteArray
parameter_list|()
block|{
name|byte
index|[]
name|bytes
init|=
name|convert
argument_list|()
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
return|return
name|ProtobufUtil
operator|.
name|prependPBMagic
argument_list|(
name|bytes
argument_list|)
return|;
block|}
comment|/**    * @param bytes    * @return A deserialized {@link HRegionInfo} or null if we failed deserialize or passed bytes null    * @see {@link #toByteArray()}    */
specifier|public
specifier|static
name|HRegionInfo
name|parseFromOrNull
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|)
block|{
if|if
condition|(
name|bytes
operator|==
literal|null
operator|||
name|bytes
operator|.
name|length
operator|<=
literal|0
condition|)
return|return
literal|null
return|;
try|try
block|{
return|return
name|parseFrom
argument_list|(
name|bytes
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * @param bytes A pb RegionInfo serialized with a pb magic prefix.    * @return    * @throws DeserializationException    * @see {@link #toByteArray()}    */
specifier|public
specifier|static
name|HRegionInfo
name|parseFrom
parameter_list|(
specifier|final
name|byte
index|[]
name|bytes
parameter_list|)
throws|throws
name|DeserializationException
block|{
if|if
condition|(
name|ProtobufUtil
operator|.
name|isPBMagicPrefix
argument_list|(
name|bytes
argument_list|)
condition|)
block|{
name|int
name|pblen
init|=
name|ProtobufUtil
operator|.
name|lengthOfPBMagic
argument_list|()
decl_stmt|;
try|try
block|{
name|HBaseProtos
operator|.
name|RegionInfo
name|ri
init|=
name|HBaseProtos
operator|.
name|RegionInfo
operator|.
name|newBuilder
argument_list|()
operator|.
name|mergeFrom
argument_list|(
name|bytes
argument_list|,
name|pblen
argument_list|,
name|bytes
operator|.
name|length
operator|-
name|pblen
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|convert
argument_list|(
name|ri
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InvalidProtocolBufferException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DeserializationException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
try|try
block|{
return|return
operator|(
name|HRegionInfo
operator|)
name|Writables
operator|.
name|getWritable
argument_list|(
name|bytes
argument_list|,
operator|new
name|HRegionInfo
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|DeserializationException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Use this instead of {@link #toByteArray()} when writing to a stream and you want to use    * the pb mergeDelimitedFrom (w/o the delimiter, pb reads to EOF which may not be what you want).    * @return This instance serialized as a delimited protobuf w/ a magic pb prefix.    * @throws IOException    * @see {@link #toByteArray()}    */
specifier|public
name|byte
index|[]
name|toDelimitedByteArray
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|ProtobufUtil
operator|.
name|toDelimitedByteArray
argument_list|(
name|convert
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Parses an HRegionInfo instance from the passed in stream.  Presumes the HRegionInfo was    * serialized to the stream with {@link #toDelimitedByteArray()}    * @param in    * @return An instance of HRegionInfo.    * @throws IOException    */
specifier|public
specifier|static
name|HRegionInfo
name|parseFrom
parameter_list|(
specifier|final
name|FSDataInputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
comment|// I need to be able to move back in the stream if this is not a pb serialization so I can
comment|// do the Writable decoding instead.
name|InputStream
name|is
init|=
name|in
operator|.
name|markSupported
argument_list|()
condition|?
name|in
else|:
operator|new
name|BufferedInputStream
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|int
name|pblen
init|=
name|ProtobufUtil
operator|.
name|lengthOfPBMagic
argument_list|()
decl_stmt|;
name|is
operator|.
name|mark
argument_list|(
name|pblen
argument_list|)
expr_stmt|;
name|byte
index|[]
name|pbuf
init|=
operator|new
name|byte
index|[
name|pblen
index|]
decl_stmt|;
name|int
name|read
init|=
name|is
operator|.
name|read
argument_list|(
name|pbuf
argument_list|)
decl_stmt|;
if|if
condition|(
name|read
operator|!=
name|pblen
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"read="
operator|+
name|read
operator|+
literal|", wanted="
operator|+
name|pblen
argument_list|)
throw|;
if|if
condition|(
name|ProtobufUtil
operator|.
name|isPBMagicPrefix
argument_list|(
name|pbuf
argument_list|)
condition|)
block|{
return|return
name|convert
argument_list|(
name|HBaseProtos
operator|.
name|RegionInfo
operator|.
name|parseDelimitedFrom
argument_list|(
name|is
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
comment|// Presume Writables.  Need to reset the stream since it didn't start w/ pb.
name|in
operator|.
name|reset
argument_list|()
expr_stmt|;
name|HRegionInfo
name|hri
init|=
operator|new
name|HRegionInfo
argument_list|()
decl_stmt|;
name|hri
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
name|hri
return|;
block|}
block|}
block|}
end_class

end_unit

