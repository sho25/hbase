begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|regionserver
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|PriorityBlockingQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Cell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|WALEntryFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|wal
operator|.
name|WAL
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_comment
comment|/**  * WAL reader for a serial replication peer.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|SerialReplicationSourceWALReader
extends|extends
name|ReplicationSourceWALReader
block|{
comment|// used to store the first cell in an entry before filtering. This is because that if serial
comment|// replication is enabled, we may find out that an entry can not be pushed after filtering. And
comment|// when we try the next time, the cells maybe null since the entry has already been filtered,
comment|// especially for region event wal entries. And this can also used to determine whether we can
comment|// skip filtering.
specifier|private
name|Cell
name|firstCellInEntryBeforeFiltering
decl_stmt|;
specifier|private
specifier|final
name|SerialReplicationChecker
name|checker
decl_stmt|;
specifier|public
name|SerialReplicationSourceWALReader
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|PriorityBlockingQueue
argument_list|<
name|Path
argument_list|>
name|logQueue
parameter_list|,
name|long
name|startPosition
parameter_list|,
name|WALEntryFilter
name|filter
parameter_list|,
name|ReplicationSource
name|source
parameter_list|)
block|{
name|super
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|logQueue
argument_list|,
name|startPosition
argument_list|,
name|filter
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|checker
operator|=
operator|new
name|SerialReplicationChecker
argument_list|(
name|conf
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|WALEntryBatch
name|readWALEntries
parameter_list|(
name|WALEntryStream
name|entryStream
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|Path
name|currentPath
init|=
name|entryStream
operator|.
name|getCurrentPath
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|entryStream
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// check whether we have switched a file
if|if
condition|(
name|currentPath
operator|!=
literal|null
operator|&&
name|switched
argument_list|(
name|entryStream
argument_list|,
name|currentPath
argument_list|)
condition|)
block|{
return|return
name|WALEntryBatch
operator|.
name|endOfFile
argument_list|(
name|currentPath
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
if|if
condition|(
name|currentPath
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|switched
argument_list|(
name|entryStream
argument_list|,
name|currentPath
argument_list|)
condition|)
block|{
return|return
name|WALEntryBatch
operator|.
name|endOfFile
argument_list|(
name|currentPath
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|// when reading from the entry stream first time we will enter here
name|currentPath
operator|=
name|entryStream
operator|.
name|getCurrentPath
argument_list|()
expr_stmt|;
block|}
name|long
name|positionBefore
init|=
name|entryStream
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|WALEntryBatch
name|batch
init|=
name|createBatch
argument_list|(
name|entryStream
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|Entry
name|entry
init|=
name|entryStream
operator|.
name|peek
argument_list|()
decl_stmt|;
name|boolean
name|doFiltering
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|firstCellInEntryBeforeFiltering
operator|==
literal|null
condition|)
block|{
assert|assert
operator|!
name|entry
operator|.
name|getEdit
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|:
literal|"should not write empty edits"
assert|;
comment|// Used to locate the region record in meta table. In WAL we only have the table name and
comment|// encoded region name which can not be mapping to region name without scanning all the
comment|// records for a table, so we need a start key, just like what we have done at client side
comment|// when locating a region. For the markers, we will use the start key of the region as the
comment|// row key for the edit. And we need to do this before filtering since all the cells may
comment|// be filtered out, especially that for the markers.
name|firstCellInEntryBeforeFiltering
operator|=
name|entry
operator|.
name|getEdit
argument_list|()
operator|.
name|getCells
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// if this is not null then we know that the entry has already been filtered.
name|doFiltering
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|doFiltering
condition|)
block|{
name|entry
operator|=
name|filterEntry
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|checker
operator|.
name|canPush
argument_list|(
name|entry
argument_list|,
name|firstCellInEntryBeforeFiltering
argument_list|)
condition|)
block|{
if|if
condition|(
name|batch
operator|.
name|getLastWalPosition
argument_list|()
operator|>
name|positionBefore
condition|)
block|{
comment|// we have something that can push, break
break|break;
block|}
else|else
block|{
name|checker
operator|.
name|waitUntilCanPush
argument_list|(
name|entry
argument_list|,
name|firstCellInEntryBeforeFiltering
argument_list|)
expr_stmt|;
block|}
block|}
comment|// arrive here means we can push the entry, record the last sequence id
name|batch
operator|.
name|setLastSeqId
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getEncodedRegionName
argument_list|()
argument_list|)
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getSequenceId
argument_list|()
argument_list|)
expr_stmt|;
comment|// actually remove the entry.
name|removeEntryFromStream
argument_list|(
name|entryStream
argument_list|,
name|batch
argument_list|)
expr_stmt|;
if|if
condition|(
name|addEntryToBatch
argument_list|(
name|batch
argument_list|,
name|entry
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
comment|// actually remove the entry.
name|removeEntryFromStream
argument_list|(
name|entryStream
argument_list|,
name|batch
argument_list|)
expr_stmt|;
block|}
name|boolean
name|hasNext
init|=
name|entryStream
operator|.
name|hasNext
argument_list|()
decl_stmt|;
comment|// always return if we have switched to a new file.
if|if
condition|(
name|switched
argument_list|(
name|entryStream
argument_list|,
name|currentPath
argument_list|)
condition|)
block|{
name|batch
operator|.
name|setEndOfFile
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|hasNext
condition|)
block|{
break|break;
block|}
block|}
return|return
name|batch
return|;
block|}
specifier|private
name|void
name|removeEntryFromStream
parameter_list|(
name|WALEntryStream
name|entryStream
parameter_list|,
name|WALEntryBatch
name|batch
parameter_list|)
throws|throws
name|IOException
block|{
name|entryStream
operator|.
name|next
argument_list|()
expr_stmt|;
name|firstCellInEntryBeforeFiltering
operator|=
literal|null
expr_stmt|;
name|batch
operator|.
name|setLastWalPosition
argument_list|(
name|entryStream
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

