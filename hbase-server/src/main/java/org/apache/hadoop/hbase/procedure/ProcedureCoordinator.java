begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|RejectedExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|SynchronousQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|DaemonThreadFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|errorhandling
operator|.
name|ForeignException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|errorhandling
operator|.
name|ForeignExceptionDispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|MapMaker
import|;
end_import

begin_comment
comment|/**  * This is the master side of a distributed complex procedure execution.  *<p>  * The {@link Procedure} is generic and subclassing or customization shouldn't be  * necessary -- any customization should happen just in {@link Subprocedure}s.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|ProcedureCoordinator
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ProcedureCoordinator
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
specifier|static
name|long
name|KEEP_ALIVE_MILLIS_DEFAULT
init|=
literal|5000
decl_stmt|;
specifier|final
specifier|static
name|long
name|TIMEOUT_MILLIS_DEFAULT
init|=
literal|60000
decl_stmt|;
specifier|final
specifier|static
name|long
name|WAKE_MILLIS_DEFAULT
init|=
literal|500
decl_stmt|;
specifier|private
specifier|final
name|ProcedureCoordinatorRpcs
name|rpcs
decl_stmt|;
specifier|private
specifier|final
name|ExecutorService
name|pool
decl_stmt|;
specifier|private
specifier|final
name|long
name|wakeTimeMillis
decl_stmt|;
specifier|private
specifier|final
name|long
name|timeoutMillis
decl_stmt|;
comment|// Running procedure table.  Maps procedure name to running procedure reference
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|String
argument_list|,
name|Procedure
argument_list|>
name|procedures
init|=
operator|new
name|MapMaker
argument_list|()
operator|.
name|concurrencyLevel
argument_list|(
literal|4
argument_list|)
operator|.
name|weakValues
argument_list|()
operator|.
name|makeMap
argument_list|()
decl_stmt|;
comment|/**    * Create and start a ProcedureCoordinator.    *    * The rpc object registers the ProcedureCoordinator and starts any threads in this    * constructor.    *    * @param rpcs    * @param pool Used for executing procedures.    */
specifier|public
name|ProcedureCoordinator
parameter_list|(
name|ProcedureCoordinatorRpcs
name|rpcs
parameter_list|,
name|ThreadPoolExecutor
name|pool
parameter_list|)
block|{
name|this
argument_list|(
name|rpcs
argument_list|,
name|pool
argument_list|,
name|TIMEOUT_MILLIS_DEFAULT
argument_list|,
name|WAKE_MILLIS_DEFAULT
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create and start a ProcedureCoordinator.    *    * The rpc object registers the ProcedureCoordinator and starts any threads in    * this constructor.    *    * @param rpcs    * @param pool Used for executing procedures.    * @param timeoutMillis    */
specifier|public
name|ProcedureCoordinator
parameter_list|(
name|ProcedureCoordinatorRpcs
name|rpcs
parameter_list|,
name|ThreadPoolExecutor
name|pool
parameter_list|,
name|long
name|timeoutMillis
parameter_list|,
name|long
name|wakeTimeMillis
parameter_list|)
block|{
name|this
operator|.
name|timeoutMillis
operator|=
name|timeoutMillis
expr_stmt|;
name|this
operator|.
name|wakeTimeMillis
operator|=
name|wakeTimeMillis
expr_stmt|;
name|this
operator|.
name|rpcs
operator|=
name|rpcs
expr_stmt|;
name|this
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|this
operator|.
name|rpcs
operator|.
name|start
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**    * Default thread pool for the procedure    *    * @param coordName    * @param opThreads the maximum number of threads to allow in the pool    */
specifier|public
specifier|static
name|ThreadPoolExecutor
name|defaultPool
parameter_list|(
name|String
name|coordName
parameter_list|,
name|int
name|opThreads
parameter_list|)
block|{
return|return
name|defaultPool
argument_list|(
name|coordName
argument_list|,
name|opThreads
argument_list|,
name|KEEP_ALIVE_MILLIS_DEFAULT
argument_list|)
return|;
block|}
comment|/**    * Default thread pool for the procedure    *    * @param coordName    * @param opThreads the maximum number of threads to allow in the pool    * @param keepAliveMillis the maximum time (ms) that excess idle threads will wait for new tasks    */
specifier|public
specifier|static
name|ThreadPoolExecutor
name|defaultPool
parameter_list|(
name|String
name|coordName
parameter_list|,
name|int
name|opThreads
parameter_list|,
name|long
name|keepAliveMillis
parameter_list|)
block|{
return|return
operator|new
name|ThreadPoolExecutor
argument_list|(
literal|1
argument_list|,
name|opThreads
argument_list|,
name|keepAliveMillis
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|,
operator|new
name|SynchronousQueue
argument_list|<>
argument_list|()
argument_list|,
operator|new
name|DaemonThreadFactory
argument_list|(
literal|"("
operator|+
name|coordName
operator|+
literal|")-proc-coordinator-pool"
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Shutdown the thread pools and release rpc resources    * @throws IOException    */
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
comment|// have to use shutdown now to break any latch waiting
name|pool
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|rpcs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Submit an procedure to kick off its dependent subprocedures.    * @param proc Procedure to execute    * @return<tt>true</tt> if the procedure was started correctly,<tt>false</tt> if the    *         procedure or any subprocedures could not be started.  Failure could be due to    *         submitting a procedure multiple times (or one with the same name), or some sort    *         of IO problem.  On errors, the procedure's monitor holds a reference to the exception    *         that caused the failure.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"FutureReturnValueIgnored"
argument_list|)
name|boolean
name|submitProcedure
parameter_list|(
name|Procedure
name|proc
parameter_list|)
block|{
comment|// if the submitted procedure was null, then we don't want to run it
if|if
condition|(
name|proc
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|String
name|procName
init|=
name|proc
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// make sure we aren't already running a procedure of that name
name|Procedure
name|oldProc
init|=
name|procedures
operator|.
name|get
argument_list|(
name|procName
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldProc
operator|!=
literal|null
condition|)
block|{
comment|// procedures are always eventually completed on both successful and failed execution
try|try
block|{
if|if
condition|(
operator|!
name|oldProc
operator|.
name|isCompleted
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Procedure "
operator|+
name|procName
operator|+
literal|" currently running.  Rejecting new request"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Procedure "
operator|+
name|procName
operator|+
literal|" was in running list but was completed.  Accepting new attempt."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|procedures
operator|.
name|remove
argument_list|(
name|procName
argument_list|,
name|oldProc
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Procedure "
operator|+
name|procName
operator|+
literal|" has been resubmitted by another thread. Rejecting this request."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|ForeignException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Procedure "
operator|+
name|procName
operator|+
literal|" was in running list but has exception.  Accepting new attempt."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|procedures
operator|.
name|remove
argument_list|(
name|procName
argument_list|,
name|oldProc
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Procedure "
operator|+
name|procName
operator|+
literal|" has been resubmitted by another thread. Rejecting this request."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
comment|// kick off the procedure's execution in a separate thread
try|try
block|{
if|if
condition|(
name|this
operator|.
name|procedures
operator|.
name|putIfAbsent
argument_list|(
name|procName
argument_list|,
name|proc
argument_list|)
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Submitting procedure "
operator|+
name|procName
argument_list|)
expr_stmt|;
name|this
operator|.
name|pool
operator|.
name|submit
argument_list|(
name|proc
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Another thread has submitted procedure '"
operator|+
name|procName
operator|+
literal|"'. Ignoring this attempt."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|RejectedExecutionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Procedure "
operator|+
name|procName
operator|+
literal|" rejected by execution pool.  Propagating error."
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// Remove the procedure from the list since is not started
name|this
operator|.
name|procedures
operator|.
name|remove
argument_list|(
name|procName
argument_list|,
name|proc
argument_list|)
expr_stmt|;
comment|// the thread pool is full and we can't run the procedure
name|proc
operator|.
name|receive
argument_list|(
operator|new
name|ForeignException
argument_list|(
name|procName
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * The connection to the rest of the procedure group (members and coordinator) has been    * broken/lost/failed. This should fail any interested procedures, but not attempt to notify other    * members since we cannot reach them anymore.    * @param message description of the error    * @param cause the actual cause of the failure    */
name|void
name|rpcConnectionFailure
parameter_list|(
specifier|final
name|String
name|message
parameter_list|,
specifier|final
name|IOException
name|cause
parameter_list|)
block|{
name|Collection
argument_list|<
name|Procedure
argument_list|>
name|toNotify
init|=
name|procedures
operator|.
name|values
argument_list|()
decl_stmt|;
name|boolean
name|isTraceEnabled
init|=
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"received connection failure: "
operator|+
name|message
argument_list|,
name|cause
argument_list|)
expr_stmt|;
for|for
control|(
name|Procedure
name|proc
range|:
name|toNotify
control|)
block|{
if|if
condition|(
name|proc
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
comment|// notify the elements, if they aren't null
if|if
condition|(
name|isTraceEnabled
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"connection failure - notify procedure: "
operator|+
name|proc
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|proc
operator|.
name|receive
argument_list|(
operator|new
name|ForeignException
argument_list|(
name|proc
operator|.
name|getName
argument_list|()
argument_list|,
name|cause
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Abort the procedure with the given name    * @param procName name of the procedure to abort    * @param reason serialized information about the abort    */
specifier|public
name|void
name|abortProcedure
parameter_list|(
name|String
name|procName
parameter_list|,
name|ForeignException
name|reason
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"abort procedure "
operator|+
name|procName
argument_list|,
name|reason
argument_list|)
expr_stmt|;
comment|// if we know about the Procedure, notify it
name|Procedure
name|proc
init|=
name|procedures
operator|.
name|get
argument_list|(
name|procName
argument_list|)
decl_stmt|;
if|if
condition|(
name|proc
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|proc
operator|.
name|receive
argument_list|(
name|reason
argument_list|)
expr_stmt|;
block|}
comment|/**    * Exposed for hooking with unit tests.    * @param procName    * @param procArgs    * @param expectedMembers    * @return the newly created procedure    */
name|Procedure
name|createProcedure
parameter_list|(
name|ForeignExceptionDispatcher
name|fed
parameter_list|,
name|String
name|procName
parameter_list|,
name|byte
index|[]
name|procArgs
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|expectedMembers
parameter_list|)
block|{
comment|// build the procedure
return|return
operator|new
name|Procedure
argument_list|(
name|this
argument_list|,
name|fed
argument_list|,
name|wakeTimeMillis
argument_list|,
name|timeoutMillis
argument_list|,
name|procName
argument_list|,
name|procArgs
argument_list|,
name|expectedMembers
argument_list|)
return|;
block|}
comment|/**    * Kick off the named procedure    * Currently only one procedure with the same type and name is allowed to run at a time.    * @param procName name of the procedure to start    * @param procArgs arguments for the procedure    * @param expectedMembers expected members to start    * @return handle to the running procedure, if it was started correctly,    *<tt>null</tt> otherwise.    *         Null could be due to submitting a procedure multiple times    *         (or one with the same name), or runtime exception.    *         Check the procedure's monitor that holds a reference to the exception    *         that caused the failure.    */
specifier|public
name|Procedure
name|startProcedure
parameter_list|(
name|ForeignExceptionDispatcher
name|fed
parameter_list|,
name|String
name|procName
parameter_list|,
name|byte
index|[]
name|procArgs
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|expectedMembers
parameter_list|)
block|{
name|Procedure
name|proc
init|=
name|createProcedure
argument_list|(
name|fed
argument_list|,
name|procName
argument_list|,
name|procArgs
argument_list|,
name|expectedMembers
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|this
operator|.
name|submitProcedure
argument_list|(
name|proc
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to submit procedure '"
operator|+
name|procName
operator|+
literal|"'"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|proc
return|;
block|}
comment|/**    * Notification that the procedure had the specified member acquired its part of the barrier    * via {@link Subprocedure#acquireBarrier()}.    * @param procName name of the procedure that acquired    * @param member name of the member that acquired    */
name|void
name|memberAcquiredBarrier
parameter_list|(
name|String
name|procName
parameter_list|,
specifier|final
name|String
name|member
parameter_list|)
block|{
name|Procedure
name|proc
init|=
name|procedures
operator|.
name|get
argument_list|(
name|procName
argument_list|)
decl_stmt|;
if|if
condition|(
name|proc
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Member '"
operator|+
name|member
operator|+
literal|"' is trying to acquire an unknown procedure '"
operator|+
name|procName
operator|+
literal|"'"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Member '"
operator|+
name|member
operator|+
literal|"' acquired procedure '"
operator|+
name|procName
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
name|proc
operator|.
name|barrierAcquiredByMember
argument_list|(
name|member
argument_list|)
expr_stmt|;
block|}
comment|/**    * Notification that the procedure had another member finished executing its in-barrier subproc    * via {@link Subprocedure#insideBarrier()}.    * @param procName name of the subprocedure that finished    * @param member name of the member that executed and released its barrier    * @param dataFromMember the data that the member returned along with the notification    */
name|void
name|memberFinishedBarrier
parameter_list|(
name|String
name|procName
parameter_list|,
specifier|final
name|String
name|member
parameter_list|,
name|byte
index|[]
name|dataFromMember
parameter_list|)
block|{
name|Procedure
name|proc
init|=
name|procedures
operator|.
name|get
argument_list|(
name|procName
argument_list|)
decl_stmt|;
if|if
condition|(
name|proc
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Member '"
operator|+
name|member
operator|+
literal|"' is trying to release an unknown procedure '"
operator|+
name|procName
operator|+
literal|"'"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Member '"
operator|+
name|member
operator|+
literal|"' released procedure '"
operator|+
name|procName
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
name|proc
operator|.
name|barrierReleasedByMember
argument_list|(
name|member
argument_list|,
name|dataFromMember
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return the rpcs implementation for all current procedures    */
name|ProcedureCoordinatorRpcs
name|getRpcs
parameter_list|()
block|{
return|return
name|rpcs
return|;
block|}
comment|/**    * Returns the procedure.  This Procedure is a live instance so should not be modified but can    * be inspected.    * @param name Name of the procedure    * @return Procedure or null if not present any more    */
specifier|public
name|Procedure
name|getProcedure
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|procedures
operator|.
name|get
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**    * @return Return set of all procedure names.    */
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getProcedureNames
parameter_list|()
block|{
return|return
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|procedures
operator|.
name|keySet
argument_list|()
argument_list|)
return|;
block|}
block|}
end_class

end_unit

