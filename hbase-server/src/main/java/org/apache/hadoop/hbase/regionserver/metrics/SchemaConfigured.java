begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|metrics
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|HeapSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|HFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|metrics
operator|.
name|SchemaMetrics
operator|.
name|SchemaAware
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ClassSize
import|;
end_import

begin_comment
comment|/**  * A base class for objects that are associated with a particular table and  * column family. Provides a way to obtain the schema metrics object.  *<p>  * Due to the variety of things that can be associated with a table/CF, there  * are many ways to initialize this base class, either in the constructor, or  * from another similar object. For example, an HFile reader configures HFile  * blocks it reads with its own table/CF name.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|SchemaConfigured
implements|implements
name|HeapSize
implements|,
name|SchemaAware
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|SchemaConfigured
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// These are not final because we set them at runtime e.g. for HFile blocks.
specifier|private
name|String
name|cfName
decl_stmt|;
specifier|private
name|String
name|tableName
decl_stmt|;
comment|/**    * Schema metrics. Can only be initialized when we know our column family    * name, table name, and have had a chance to take a look at the    * configuration (in {@link SchemaMetrics#configureGlobally(Configuration))    * so we know whether we are using per-table metrics. Therefore, initialized    * lazily. We don't make this volatile because even if a thread sees a stale    * value of null, it will be re-initialized to the same value that other    * threads see.    */
specifier|private
name|SchemaMetrics
name|schemaMetrics
decl_stmt|;
static|static
block|{
if|if
condition|(
name|ClassSize
operator|.
name|OBJECT
operator|<=
literal|0
operator|||
name|ClassSize
operator|.
name|REFERENCE
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Class sizes are not initialized"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Estimated heap size of this object. We don't count table name and column    * family name characters because these strings are shared among many    * objects. We need unaligned size to reuse this in subclasses.    */
specifier|public
specifier|static
specifier|final
name|int
name|SCHEMA_CONFIGURED_UNALIGNED_HEAP_SIZE
init|=
name|ClassSize
operator|.
name|OBJECT
operator|+
literal|3
operator|*
name|ClassSize
operator|.
name|REFERENCE
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|SCHEMA_CONFIGURED_ALIGNED_HEAP_SIZE
init|=
name|ClassSize
operator|.
name|align
argument_list|(
name|SCHEMA_CONFIGURED_UNALIGNED_HEAP_SIZE
argument_list|)
decl_stmt|;
comment|/** A helper constructor that configures the "use table name" flag. */
specifier|private
name|SchemaConfigured
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|SchemaMetrics
operator|.
name|configureGlobally
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// Even though we now know if table-level metrics are used, we can't
comment|// initialize schemaMetrics yet, because CF and table name are only known
comment|// to the calling constructor.
block|}
comment|/**    * Creates an instance corresponding to an unknown table and column family.    * Used in unit tests.     */
specifier|public
specifier|static
name|SchemaConfigured
name|createUnknown
parameter_list|()
block|{
return|return
operator|new
name|SchemaConfigured
argument_list|(
literal|null
argument_list|,
name|SchemaMetrics
operator|.
name|UNKNOWN
argument_list|,
name|SchemaMetrics
operator|.
name|UNKNOWN
argument_list|)
return|;
block|}
comment|/**    * Default constructor. Only use when column/family name are not known at    * construction (i.e. for HFile blocks).    */
specifier|public
name|SchemaConfigured
parameter_list|()
block|{   }
comment|/**    * Initialize table and column family name from an HFile path. If    * configuration is null,    * {@link SchemaMetrics#configureGlobally(Configuration)} should have been    * called already.    */
specifier|public
name|SchemaConfigured
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Path
name|path
parameter_list|)
block|{
name|this
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|!=
literal|null
condition|)
block|{
name|String
name|splits
index|[]
init|=
name|path
operator|.
name|toString
argument_list|()
operator|.
name|split
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
name|int
name|numPathLevels
init|=
name|splits
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|numPathLevels
operator|>
literal|0
operator|&&
name|splits
index|[
literal|0
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// This path starts with an '/'.
operator|--
name|numPathLevels
expr_stmt|;
block|}
if|if
condition|(
name|numPathLevels
operator|<
name|HFile
operator|.
name|MIN_NUM_HFILE_PATH_LEVELS
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not determine table and column family of the HFile "
operator|+
literal|"path "
operator|+
name|path
operator|+
literal|". Expecting at least "
operator|+
name|HFile
operator|.
name|MIN_NUM_HFILE_PATH_LEVELS
operator|+
literal|" path components."
argument_list|)
expr_stmt|;
name|path
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|cfName
operator|=
name|splits
index|[
name|splits
operator|.
name|length
operator|-
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|cfName
operator|.
name|equals
argument_list|(
name|HRegion
operator|.
name|REGION_TEMP_SUBDIR
argument_list|)
condition|)
block|{
comment|// This is probably a compaction or flush output file. We will set
comment|// the real CF name later.
name|cfName
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|cfName
operator|=
name|cfName
operator|.
name|intern
argument_list|()
expr_stmt|;
block|}
name|tableName
operator|=
name|splits
index|[
name|splits
operator|.
name|length
operator|-
literal|4
index|]
operator|.
name|intern
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|// This might also happen if we were passed an incorrect path.
name|cfName
operator|=
name|SchemaMetrics
operator|.
name|UNKNOWN
expr_stmt|;
name|tableName
operator|=
name|SchemaMetrics
operator|.
name|UNKNOWN
expr_stmt|;
block|}
comment|/**    * Used when we know an HFile path to deduce table and CF name from, but do    * not have a configuration.    * @param path an HFile path    */
specifier|public
name|SchemaConfigured
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
name|this
argument_list|(
literal|null
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
comment|/**    * Used when we know table and column family name. If configuration is null,    * {@link SchemaMetrics#configureGlobally(Configuration)} should have been    * called already.    */
specifier|public
name|SchemaConfigured
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|tableName
parameter_list|,
name|String
name|cfName
parameter_list|)
block|{
name|this
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|tableName
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|tableName
operator|=
name|tableName
operator|.
name|intern
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cfName
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|cfName
operator|=
name|cfName
operator|.
name|intern
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|SchemaConfigured
parameter_list|(
name|SchemaAware
name|that
parameter_list|)
block|{
name|tableName
operator|=
name|that
operator|.
name|getTableName
argument_list|()
operator|.
name|intern
argument_list|()
expr_stmt|;
name|cfName
operator|=
name|that
operator|.
name|getColumnFamilyName
argument_list|()
operator|.
name|intern
argument_list|()
expr_stmt|;
name|schemaMetrics
operator|=
name|that
operator|.
name|getSchemaMetrics
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getTableName
parameter_list|()
block|{
return|return
name|tableName
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getColumnFamilyName
parameter_list|()
block|{
return|return
name|cfName
return|;
block|}
annotation|@
name|Override
specifier|public
name|SchemaMetrics
name|getSchemaMetrics
parameter_list|()
block|{
if|if
condition|(
name|schemaMetrics
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|tableName
operator|==
literal|null
operator|||
name|cfName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Schema metrics requested before "
operator|+
literal|"table/CF name initialization: "
operator|+
name|schemaConfAsJSON
argument_list|()
argument_list|)
throw|;
block|}
name|schemaMetrics
operator|=
name|SchemaMetrics
operator|.
name|getInstance
argument_list|(
name|tableName
argument_list|,
name|cfName
argument_list|)
expr_stmt|;
block|}
return|return
name|schemaMetrics
return|;
block|}
comment|/**    * Configures the given object (e.g. an HFile block) with the current table    * and column family name, and the associated collection of metrics. Please    * note that this method configures the<b>other</b> object, not<b>this</b>    * object.    */
specifier|public
name|void
name|passSchemaMetricsTo
parameter_list|(
name|SchemaConfigured
name|target
parameter_list|)
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
block|{
name|resetSchemaMetricsConf
argument_list|(
name|target
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|isSchemaConfigured
argument_list|()
condition|)
block|{
comment|// Cannot configure another object if we are not configured ourselves.
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Table name/CF not initialized: "
operator|+
name|schemaConfAsJSON
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|conflictingWith
argument_list|(
name|target
argument_list|)
condition|)
block|{
comment|// Make sure we don't try to change table or CF name.
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Trying to change table name to \""
operator|+
name|tableName
operator|+
literal|"\", CF name to \""
operator|+
name|cfName
operator|+
literal|"\" from "
operator|+
name|target
operator|.
name|schemaConfAsJSON
argument_list|()
argument_list|)
throw|;
block|}
name|target
operator|.
name|tableName
operator|=
name|tableName
operator|.
name|intern
argument_list|()
expr_stmt|;
name|target
operator|.
name|cfName
operator|=
name|cfName
operator|.
name|intern
argument_list|()
expr_stmt|;
name|target
operator|.
name|schemaMetrics
operator|=
name|schemaMetrics
expr_stmt|;
name|target
operator|.
name|schemaConfigurationChanged
argument_list|()
expr_stmt|;
block|}
comment|/**    * Reset schema metrics configuration in this particular instance. Used when    * legitimately need to re-initialize the object with another table/CF.    * This is a static method because its use is discouraged and reserved for    * when it is really necessary (e.g. writing HFiles in a temp direcdtory    * on compaction).    */
specifier|public
specifier|static
name|void
name|resetSchemaMetricsConf
parameter_list|(
name|SchemaConfigured
name|target
parameter_list|)
block|{
name|target
operator|.
name|tableName
operator|=
literal|null
expr_stmt|;
name|target
operator|.
name|cfName
operator|=
literal|null
expr_stmt|;
name|target
operator|.
name|schemaMetrics
operator|=
literal|null
expr_stmt|;
name|target
operator|.
name|schemaConfigurationChanged
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|heapSize
parameter_list|()
block|{
return|return
name|SCHEMA_CONFIGURED_ALIGNED_HEAP_SIZE
return|;
block|}
specifier|public
name|String
name|schemaConfAsJSON
parameter_list|()
block|{
return|return
literal|"{\"tableName\":\""
operator|+
name|tableName
operator|+
literal|"\",\"cfName\":\""
operator|+
name|cfName
operator|+
literal|"\"}"
return|;
block|}
specifier|protected
name|boolean
name|isSchemaConfigured
parameter_list|()
block|{
return|return
name|tableName
operator|!=
literal|null
operator|&&
name|cfName
operator|!=
literal|null
return|;
block|}
specifier|private
name|boolean
name|isNull
parameter_list|()
block|{
return|return
name|tableName
operator|==
literal|null
operator|&&
name|cfName
operator|==
literal|null
operator|&&
name|schemaMetrics
operator|==
literal|null
return|;
block|}
comment|/**    * Determines if the current object's table/CF settings are not in conflict    * with the other object's table and CF. If the other object's table/CF are    * undefined, they are not considered to be in conflict. Used to sanity-check    * configuring the other object with this object's table/CF.    */
name|boolean
name|conflictingWith
parameter_list|(
name|SchemaConfigured
name|other
parameter_list|)
block|{
return|return
operator|(
name|other
operator|.
name|tableName
operator|!=
literal|null
operator|&&
operator|!
name|tableName
operator|.
name|equals
argument_list|(
name|other
operator|.
name|tableName
argument_list|)
operator|)
operator|||
operator|(
name|other
operator|.
name|cfName
operator|!=
literal|null
operator|&&
operator|!
name|cfName
operator|.
name|equals
argument_list|(
name|other
operator|.
name|cfName
argument_list|)
operator|)
return|;
block|}
comment|/**    * A hook method called when schema configuration changes. Can be used to    * update schema-aware member fields.    */
specifier|protected
name|void
name|schemaConfigurationChanged
parameter_list|()
block|{   }
block|}
end_class

end_unit

