begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|snapshot
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HColumnDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|errorhandling
operator|.
name|ForeignExceptionSnare
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|mob
operator|.
name|MobUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegionFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|Store
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|StoreFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|StoreFileInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|CodedInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|InvalidProtocolBufferException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|SnapshotProtos
operator|.
name|SnapshotDataManifest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|SnapshotProtos
operator|.
name|SnapshotDescription
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|SnapshotProtos
operator|.
name|SnapshotRegionManifest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSTableDescriptors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_comment
comment|/**  * Utility class to help read/write the Snapshot Manifest.  *  * The snapshot format is transparent for the users of this class,  * once the snapshot is written, it will never be modified.  * On open() the snapshot will be loaded to the current in-memory format.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|final
class|class
name|SnapshotManifest
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|SnapshotManifest
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|SNAPSHOT_MANIFEST_SIZE_LIMIT_CONF_KEY
init|=
literal|"snapshot.manifest.size.limit"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|DATA_MANIFEST_NAME
init|=
literal|"data.manifest"
decl_stmt|;
specifier|private
name|List
argument_list|<
name|SnapshotRegionManifest
argument_list|>
name|regionManifests
decl_stmt|;
specifier|private
name|SnapshotDescription
name|desc
decl_stmt|;
specifier|private
name|HTableDescriptor
name|htd
decl_stmt|;
specifier|private
specifier|final
name|ForeignExceptionSnare
name|monitor
decl_stmt|;
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
specifier|private
specifier|final
name|Path
name|workingDir
decl_stmt|;
specifier|private
specifier|final
name|FileSystem
name|fs
decl_stmt|;
specifier|private
name|int
name|manifestSizeLimit
decl_stmt|;
specifier|private
name|SnapshotManifest
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|workingDir
parameter_list|,
specifier|final
name|SnapshotDescription
name|desc
parameter_list|,
specifier|final
name|ForeignExceptionSnare
name|monitor
parameter_list|)
block|{
name|this
operator|.
name|monitor
operator|=
name|monitor
expr_stmt|;
name|this
operator|.
name|desc
operator|=
name|desc
expr_stmt|;
name|this
operator|.
name|workingDir
operator|=
name|workingDir
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|this
operator|.
name|manifestSizeLimit
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|SNAPSHOT_MANIFEST_SIZE_LIMIT_CONF_KEY
argument_list|,
literal|64
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return a SnapshotManifest instance, used for writing a snapshot.    *    * There are two usage pattern:    *  - The Master will create a manifest, add the descriptor, offline regions    *    and consolidate the snapshot by writing all the pending stuff on-disk.    *      manifest = SnapshotManifest.create(...)    *      manifest.addRegion(tableDir, hri)    *      manifest.consolidate()    *  - The RegionServer will create a single region manifest    *      manifest = SnapshotManifest.create(...)    *      manifest.addRegion(region)    */
specifier|public
specifier|static
name|SnapshotManifest
name|create
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|workingDir
parameter_list|,
specifier|final
name|SnapshotDescription
name|desc
parameter_list|,
specifier|final
name|ForeignExceptionSnare
name|monitor
parameter_list|)
block|{
return|return
operator|new
name|SnapshotManifest
argument_list|(
name|conf
argument_list|,
name|fs
argument_list|,
name|workingDir
argument_list|,
name|desc
argument_list|,
name|monitor
argument_list|)
return|;
block|}
comment|/**    * Return a SnapshotManifest instance with the information already loaded in-memory.    *    SnapshotManifest manifest = SnapshotManifest.open(...)    *    HTableDescriptor htd = manifest.getTableDescriptor()    *    for (SnapshotRegionManifest regionManifest: manifest.getRegionManifests())    *      hri = regionManifest.getRegionInfo()    *      for (regionManifest.getFamilyFiles())    *        ...    */
specifier|public
specifier|static
name|SnapshotManifest
name|open
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|workingDir
parameter_list|,
specifier|final
name|SnapshotDescription
name|desc
parameter_list|)
throws|throws
name|IOException
block|{
name|SnapshotManifest
name|manifest
init|=
operator|new
name|SnapshotManifest
argument_list|(
name|conf
argument_list|,
name|fs
argument_list|,
name|workingDir
argument_list|,
name|desc
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|manifest
operator|.
name|load
argument_list|()
expr_stmt|;
return|return
name|manifest
return|;
block|}
comment|/**    * Add the table descriptor to the snapshot manifest    */
specifier|public
name|void
name|addTableDescriptor
parameter_list|(
specifier|final
name|HTableDescriptor
name|htd
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|htd
operator|=
name|htd
expr_stmt|;
block|}
interface|interface
name|RegionVisitor
parameter_list|<
name|TRegion
parameter_list|,
name|TFamily
parameter_list|>
block|{
name|TRegion
name|regionOpen
parameter_list|(
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|IOException
function_decl|;
name|void
name|regionClose
parameter_list|(
specifier|final
name|TRegion
name|region
parameter_list|)
throws|throws
name|IOException
function_decl|;
name|TFamily
name|familyOpen
parameter_list|(
specifier|final
name|TRegion
name|region
parameter_list|,
specifier|final
name|byte
index|[]
name|familyName
parameter_list|)
throws|throws
name|IOException
function_decl|;
name|void
name|familyClose
parameter_list|(
specifier|final
name|TRegion
name|region
parameter_list|,
specifier|final
name|TFamily
name|family
parameter_list|)
throws|throws
name|IOException
function_decl|;
name|void
name|storeFile
parameter_list|(
specifier|final
name|TRegion
name|region
parameter_list|,
specifier|final
name|TFamily
name|family
parameter_list|,
specifier|final
name|StoreFileInfo
name|storeFile
parameter_list|)
throws|throws
name|IOException
function_decl|;
block|}
specifier|private
name|RegionVisitor
name|createRegionVisitor
parameter_list|(
specifier|final
name|SnapshotDescription
name|desc
parameter_list|)
throws|throws
name|IOException
block|{
switch|switch
condition|(
name|getSnapshotFormat
argument_list|(
name|desc
argument_list|)
condition|)
block|{
case|case
name|SnapshotManifestV1
operator|.
name|DESCRIPTOR_VERSION
case|:
return|return
operator|new
name|SnapshotManifestV1
operator|.
name|ManifestBuilder
argument_list|(
name|conf
argument_list|,
name|fs
argument_list|,
name|workingDir
argument_list|)
return|;
case|case
name|SnapshotManifestV2
operator|.
name|DESCRIPTOR_VERSION
case|:
return|return
operator|new
name|SnapshotManifestV2
operator|.
name|ManifestBuilder
argument_list|(
name|conf
argument_list|,
name|fs
argument_list|,
name|workingDir
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|CorruptedSnapshotException
argument_list|(
literal|"Invalid Snapshot version: "
operator|+
name|desc
operator|.
name|getVersion
argument_list|()
argument_list|,
name|ProtobufUtil
operator|.
name|createSnapshotDesc
argument_list|(
name|desc
argument_list|)
argument_list|)
throw|;
block|}
block|}
specifier|public
name|void
name|addMobRegion
parameter_list|(
name|HRegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|IOException
block|{
comment|// 0. Get the ManifestBuilder/RegionVisitor
name|RegionVisitor
name|visitor
init|=
name|createRegionVisitor
argument_list|(
name|desc
argument_list|)
decl_stmt|;
comment|// 1. dump region meta info into the snapshot directory
name|LOG
operator|.
name|debug
argument_list|(
literal|"Storing mob region '"
operator|+
name|regionInfo
operator|+
literal|"' region-info for snapshot."
argument_list|)
expr_stmt|;
name|Object
name|regionData
init|=
name|visitor
operator|.
name|regionOpen
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
name|monitor
operator|.
name|rethrowException
argument_list|()
expr_stmt|;
comment|// 2. iterate through all the stores in the region
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating references for mob files"
argument_list|)
expr_stmt|;
name|Path
name|mobRegionPath
init|=
name|MobUtils
operator|.
name|getMobRegionPath
argument_list|(
name|conf
argument_list|,
name|regionInfo
operator|.
name|getTable
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|HColumnDescriptor
name|hcd
range|:
name|htd
operator|.
name|getColumnFamilies
argument_list|()
control|)
block|{
comment|// 2.1. build the snapshot reference for the store if it's a mob store
if|if
condition|(
operator|!
name|hcd
operator|.
name|isMobEnabled
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|Object
name|familyData
init|=
name|visitor
operator|.
name|familyOpen
argument_list|(
name|regionData
argument_list|,
name|hcd
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|monitor
operator|.
name|rethrowException
argument_list|()
expr_stmt|;
name|Path
name|storePath
init|=
name|MobUtils
operator|.
name|getMobFamilyPath
argument_list|(
name|mobRegionPath
argument_list|,
name|hcd
operator|.
name|getNameAsString
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|StoreFileInfo
argument_list|>
name|storeFiles
init|=
name|getStoreFiles
argument_list|(
name|storePath
argument_list|)
decl_stmt|;
if|if
condition|(
name|storeFiles
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No mob files under family: "
operator|+
name|hcd
operator|.
name|getNameAsString
argument_list|()
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|addReferenceFiles
argument_list|(
name|visitor
argument_list|,
name|regionData
argument_list|,
name|familyData
argument_list|,
name|storeFiles
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|visitor
operator|.
name|familyClose
argument_list|(
name|regionData
argument_list|,
name|familyData
argument_list|)
expr_stmt|;
block|}
name|visitor
operator|.
name|regionClose
argument_list|(
name|regionData
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a 'manifest' for the specified region, by reading directly from the HRegion object.    * This is used by the "online snapshot" when the table is enabled.    */
specifier|public
name|void
name|addRegion
parameter_list|(
specifier|final
name|HRegion
name|region
parameter_list|)
throws|throws
name|IOException
block|{
comment|// 0. Get the ManifestBuilder/RegionVisitor
name|RegionVisitor
name|visitor
init|=
name|createRegionVisitor
argument_list|(
name|desc
argument_list|)
decl_stmt|;
comment|// 1. dump region meta info into the snapshot directory
name|LOG
operator|.
name|debug
argument_list|(
literal|"Storing '"
operator|+
name|region
operator|+
literal|"' region-info for snapshot."
argument_list|)
expr_stmt|;
name|Object
name|regionData
init|=
name|visitor
operator|.
name|regionOpen
argument_list|(
name|region
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
decl_stmt|;
name|monitor
operator|.
name|rethrowException
argument_list|()
expr_stmt|;
comment|// 2. iterate through all the stores in the region
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating references for hfiles"
argument_list|)
expr_stmt|;
for|for
control|(
name|Store
name|store
range|:
name|region
operator|.
name|getStores
argument_list|()
control|)
block|{
comment|// 2.1. build the snapshot reference for the store
name|Object
name|familyData
init|=
name|visitor
operator|.
name|familyOpen
argument_list|(
name|regionData
argument_list|,
name|store
operator|.
name|getColumnFamilyDescriptor
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|monitor
operator|.
name|rethrowException
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|StoreFile
argument_list|>
name|storeFiles
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|store
operator|.
name|getStorefiles
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding snapshot references for "
operator|+
name|storeFiles
operator|+
literal|" hfiles"
argument_list|)
expr_stmt|;
block|}
comment|// 2.2. iterate through all the store's files and create "references".
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|sz
init|=
name|storeFiles
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
name|StoreFile
name|storeFile
init|=
name|storeFiles
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|monitor
operator|.
name|rethrowException
argument_list|()
expr_stmt|;
comment|// create "reference" to this store file.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding reference for file ("
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|+
literal|"/"
operator|+
name|sz
operator|+
literal|"): "
operator|+
name|storeFile
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|visitor
operator|.
name|storeFile
argument_list|(
name|regionData
argument_list|,
name|familyData
argument_list|,
name|storeFile
operator|.
name|getFileInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|visitor
operator|.
name|familyClose
argument_list|(
name|regionData
argument_list|,
name|familyData
argument_list|)
expr_stmt|;
block|}
name|visitor
operator|.
name|regionClose
argument_list|(
name|regionData
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a 'manifest' for the specified region, by reading directly from the disk.    * This is used by the "offline snapshot" when the table is disabled.    */
specifier|public
name|void
name|addRegion
parameter_list|(
specifier|final
name|Path
name|tableDir
parameter_list|,
specifier|final
name|HRegionInfo
name|regionInfo
parameter_list|)
throws|throws
name|IOException
block|{
comment|// 0. Get the ManifestBuilder/RegionVisitor
name|RegionVisitor
name|visitor
init|=
name|createRegionVisitor
argument_list|(
name|desc
argument_list|)
decl_stmt|;
name|boolean
name|isMobRegion
init|=
name|MobUtils
operator|.
name|isMobRegionInfo
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
try|try
block|{
name|Path
name|baseDir
init|=
name|tableDir
decl_stmt|;
comment|// Open the RegionFS
if|if
condition|(
name|isMobRegion
condition|)
block|{
name|baseDir
operator|=
name|FSUtils
operator|.
name|getTableDir
argument_list|(
name|MobUtils
operator|.
name|getMobHome
argument_list|(
name|conf
argument_list|)
argument_list|,
name|regionInfo
operator|.
name|getTable
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|HRegionFileSystem
name|regionFs
init|=
name|HRegionFileSystem
operator|.
name|openRegionFromFileSystem
argument_list|(
name|conf
argument_list|,
name|fs
argument_list|,
name|baseDir
argument_list|,
name|regionInfo
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|monitor
operator|.
name|rethrowException
argument_list|()
expr_stmt|;
comment|// 1. dump region meta info into the snapshot directory
name|LOG
operator|.
name|debug
argument_list|(
literal|"Storing region-info for snapshot."
argument_list|)
expr_stmt|;
name|Object
name|regionData
init|=
name|visitor
operator|.
name|regionOpen
argument_list|(
name|regionInfo
argument_list|)
decl_stmt|;
name|monitor
operator|.
name|rethrowException
argument_list|()
expr_stmt|;
comment|// 2. iterate through all the stores in the region
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating references for hfiles"
argument_list|)
expr_stmt|;
comment|// This ensures that we have an atomic view of the directory as long as we have< ls limit
comment|// (batch size of the files in a directory) on the namenode. Otherwise, we get back the files
comment|// in batches and may miss files being added/deleted. This could be more robust (iteratively
comment|// checking to see if we have all the files until we are sure), but the limit is currently
comment|// 1000 files/batch, far more than the number of store files under a single column family.
name|Collection
argument_list|<
name|String
argument_list|>
name|familyNames
init|=
name|regionFs
operator|.
name|getFamilies
argument_list|()
decl_stmt|;
if|if
condition|(
name|familyNames
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|familyName
range|:
name|familyNames
control|)
block|{
name|Object
name|familyData
init|=
name|visitor
operator|.
name|familyOpen
argument_list|(
name|regionData
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|familyName
argument_list|)
argument_list|)
decl_stmt|;
name|monitor
operator|.
name|rethrowException
argument_list|()
expr_stmt|;
name|Collection
argument_list|<
name|StoreFileInfo
argument_list|>
name|storeFiles
init|=
name|regionFs
operator|.
name|getStoreFiles
argument_list|(
name|familyName
argument_list|)
decl_stmt|;
if|if
condition|(
name|storeFiles
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No files under family: "
operator|+
name|familyName
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|// 2.1. build the snapshot reference for the store
comment|// iterate through all the store's files and create "references".
name|addReferenceFiles
argument_list|(
name|visitor
argument_list|,
name|regionData
argument_list|,
name|familyData
argument_list|,
name|storeFiles
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|visitor
operator|.
name|familyClose
argument_list|(
name|regionData
argument_list|,
name|familyData
argument_list|)
expr_stmt|;
block|}
block|}
name|visitor
operator|.
name|regionClose
argument_list|(
name|regionData
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// the mob directory might not be created yet, so do nothing when it is a mob region
if|if
condition|(
operator|!
name|isMobRegion
condition|)
block|{
throw|throw
name|e
throw|;
block|}
block|}
block|}
specifier|private
name|List
argument_list|<
name|StoreFileInfo
argument_list|>
name|getStoreFiles
parameter_list|(
name|Path
name|storeDir
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
index|[]
name|stats
init|=
name|FSUtils
operator|.
name|listStatus
argument_list|(
name|fs
argument_list|,
name|storeDir
argument_list|)
decl_stmt|;
if|if
condition|(
name|stats
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|ArrayList
argument_list|<
name|StoreFileInfo
argument_list|>
name|storeFiles
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|stats
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|stats
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|storeFiles
operator|.
name|add
argument_list|(
operator|new
name|StoreFileInfo
argument_list|(
name|conf
argument_list|,
name|fs
argument_list|,
name|stats
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|storeFiles
return|;
block|}
specifier|private
name|void
name|addReferenceFiles
parameter_list|(
name|RegionVisitor
name|visitor
parameter_list|,
name|Object
name|regionData
parameter_list|,
name|Object
name|familyData
parameter_list|,
name|Collection
argument_list|<
name|StoreFileInfo
argument_list|>
name|storeFiles
parameter_list|,
name|boolean
name|isMob
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
name|fileType
init|=
name|isMob
condition|?
literal|"mob file"
else|:
literal|"hfile"
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Adding snapshot references for %s %ss"
argument_list|,
name|storeFiles
argument_list|,
name|fileType
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|sz
init|=
name|storeFiles
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|StoreFileInfo
name|storeFile
range|:
name|storeFiles
control|)
block|{
name|monitor
operator|.
name|rethrowException
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Adding reference for %s (%d/%d): %s"
argument_list|,
name|fileType
argument_list|,
operator|++
name|i
argument_list|,
name|sz
argument_list|,
name|storeFile
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// create "reference" to this store file.
name|visitor
operator|.
name|storeFile
argument_list|(
name|regionData
argument_list|,
name|familyData
argument_list|,
name|storeFile
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Load the information in the SnapshotManifest. Called by SnapshotManifest.open()    *    * If the format is v2 and there is no data-manifest, means that we are loading an    * in-progress snapshot. Since we support rolling-upgrades, we loook for v1 and v2    * regions format.    */
specifier|private
name|void
name|load
parameter_list|()
throws|throws
name|IOException
block|{
switch|switch
condition|(
name|getSnapshotFormat
argument_list|(
name|desc
argument_list|)
condition|)
block|{
case|case
name|SnapshotManifestV1
operator|.
name|DESCRIPTOR_VERSION
case|:
block|{
name|this
operator|.
name|htd
operator|=
name|FSTableDescriptors
operator|.
name|getTableDescriptorFromFs
argument_list|(
name|fs
argument_list|,
name|workingDir
argument_list|)
expr_stmt|;
name|ThreadPoolExecutor
name|tpool
init|=
name|createExecutor
argument_list|(
literal|"SnapshotManifestLoader"
argument_list|)
decl_stmt|;
try|try
block|{
name|this
operator|.
name|regionManifests
operator|=
name|SnapshotManifestV1
operator|.
name|loadRegionManifests
argument_list|(
name|conf
argument_list|,
name|tpool
argument_list|,
name|fs
argument_list|,
name|workingDir
argument_list|,
name|desc
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|tpool
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SnapshotManifestV2
operator|.
name|DESCRIPTOR_VERSION
case|:
block|{
name|SnapshotDataManifest
name|dataManifest
init|=
name|readDataManifest
argument_list|()
decl_stmt|;
if|if
condition|(
name|dataManifest
operator|!=
literal|null
condition|)
block|{
name|htd
operator|=
name|ProtobufUtil
operator|.
name|convertToHTableDesc
argument_list|(
name|dataManifest
operator|.
name|getTableSchema
argument_list|()
argument_list|)
expr_stmt|;
name|regionManifests
operator|=
name|dataManifest
operator|.
name|getRegionManifestsList
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Compatibility, load the v1 regions
comment|// This happens only when the snapshot is in-progress and the cache wants to refresh.
name|List
argument_list|<
name|SnapshotRegionManifest
argument_list|>
name|v1Regions
decl_stmt|,
name|v2Regions
decl_stmt|;
name|ThreadPoolExecutor
name|tpool
init|=
name|createExecutor
argument_list|(
literal|"SnapshotManifestLoader"
argument_list|)
decl_stmt|;
try|try
block|{
name|v1Regions
operator|=
name|SnapshotManifestV1
operator|.
name|loadRegionManifests
argument_list|(
name|conf
argument_list|,
name|tpool
argument_list|,
name|fs
argument_list|,
name|workingDir
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|v2Regions
operator|=
name|SnapshotManifestV2
operator|.
name|loadRegionManifests
argument_list|(
name|conf
argument_list|,
name|tpool
argument_list|,
name|fs
argument_list|,
name|workingDir
argument_list|,
name|desc
argument_list|,
name|manifestSizeLimit
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidProtocolBufferException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|CorruptedSnapshotException
argument_list|(
literal|"unable to parse region manifest "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|tpool
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|v1Regions
operator|!=
literal|null
operator|&&
name|v2Regions
operator|!=
literal|null
condition|)
block|{
name|regionManifests
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|v1Regions
operator|.
name|size
argument_list|()
operator|+
name|v2Regions
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|regionManifests
operator|.
name|addAll
argument_list|(
name|v1Regions
argument_list|)
expr_stmt|;
name|regionManifests
operator|.
name|addAll
argument_list|(
name|v2Regions
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v1Regions
operator|!=
literal|null
condition|)
block|{
name|regionManifests
operator|=
name|v1Regions
expr_stmt|;
block|}
else|else
comment|/* if (v2Regions != null) */
block|{
name|regionManifests
operator|=
name|v2Regions
expr_stmt|;
block|}
block|}
break|break;
block|}
default|default:
throw|throw
operator|new
name|CorruptedSnapshotException
argument_list|(
literal|"Invalid Snapshot version: "
operator|+
name|desc
operator|.
name|getVersion
argument_list|()
argument_list|,
name|ProtobufUtil
operator|.
name|createSnapshotDesc
argument_list|(
name|desc
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|/**    * Get the current snapshot working dir    */
specifier|public
name|Path
name|getSnapshotDir
parameter_list|()
block|{
return|return
name|this
operator|.
name|workingDir
return|;
block|}
comment|/**    * Get the SnapshotDescription    */
specifier|public
name|SnapshotDescription
name|getSnapshotDescription
parameter_list|()
block|{
return|return
name|this
operator|.
name|desc
return|;
block|}
comment|/**    * Get the table descriptor from the Snapshot    */
specifier|public
name|HTableDescriptor
name|getTableDescriptor
parameter_list|()
block|{
return|return
name|this
operator|.
name|htd
return|;
block|}
comment|/**    * Get all the Region Manifest from the snapshot    */
specifier|public
name|List
argument_list|<
name|SnapshotRegionManifest
argument_list|>
name|getRegionManifests
parameter_list|()
block|{
return|return
name|this
operator|.
name|regionManifests
return|;
block|}
comment|/**    * Get all the Region Manifest from the snapshot.    * This is an helper to get a map with the region encoded name    */
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|SnapshotRegionManifest
argument_list|>
name|getRegionManifestsMap
parameter_list|()
block|{
if|if
condition|(
name|regionManifests
operator|==
literal|null
operator|||
name|regionManifests
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|null
return|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|SnapshotRegionManifest
argument_list|>
name|regionsMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|regionManifests
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|SnapshotRegionManifest
name|manifest
range|:
name|regionManifests
control|)
block|{
name|String
name|regionName
init|=
name|getRegionNameFromManifest
argument_list|(
name|manifest
argument_list|)
decl_stmt|;
name|regionsMap
operator|.
name|put
argument_list|(
name|regionName
argument_list|,
name|manifest
argument_list|)
expr_stmt|;
block|}
return|return
name|regionsMap
return|;
block|}
specifier|public
name|void
name|consolidate
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|getSnapshotFormat
argument_list|(
name|desc
argument_list|)
operator|==
name|SnapshotManifestV1
operator|.
name|DESCRIPTOR_VERSION
condition|)
block|{
name|Path
name|rootDir
init|=
name|FSUtils
operator|.
name|getRootDir
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Using old Snapshot Format"
argument_list|)
expr_stmt|;
comment|// write a copy of descriptor to the snapshot directory
operator|new
name|FSTableDescriptors
argument_list|(
name|conf
argument_list|,
name|fs
argument_list|,
name|rootDir
argument_list|)
operator|.
name|createTableDescriptorForTableDirectory
argument_list|(
name|workingDir
argument_list|,
name|htd
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Convert to Single Snapshot Manifest"
argument_list|)
expr_stmt|;
name|convertToV2SingleManifest
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*    * In case of rolling-upgrade, we try to read all the formats and build    * the snapshot with the latest format.    */
specifier|private
name|void
name|convertToV2SingleManifest
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Try to load v1 and v2 regions
name|List
argument_list|<
name|SnapshotRegionManifest
argument_list|>
name|v1Regions
decl_stmt|,
name|v2Regions
decl_stmt|;
name|ThreadPoolExecutor
name|tpool
init|=
name|createExecutor
argument_list|(
literal|"SnapshotManifestLoader"
argument_list|)
decl_stmt|;
try|try
block|{
name|v1Regions
operator|=
name|SnapshotManifestV1
operator|.
name|loadRegionManifests
argument_list|(
name|conf
argument_list|,
name|tpool
argument_list|,
name|fs
argument_list|,
name|workingDir
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|v2Regions
operator|=
name|SnapshotManifestV2
operator|.
name|loadRegionManifests
argument_list|(
name|conf
argument_list|,
name|tpool
argument_list|,
name|fs
argument_list|,
name|workingDir
argument_list|,
name|desc
argument_list|,
name|manifestSizeLimit
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|tpool
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
name|SnapshotDataManifest
operator|.
name|Builder
name|dataManifestBuilder
init|=
name|SnapshotDataManifest
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|dataManifestBuilder
operator|.
name|setTableSchema
argument_list|(
name|ProtobufUtil
operator|.
name|convertToTableSchema
argument_list|(
name|htd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|v1Regions
operator|!=
literal|null
operator|&&
name|v1Regions
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|dataManifestBuilder
operator|.
name|addAllRegionManifests
argument_list|(
name|v1Regions
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v2Regions
operator|!=
literal|null
operator|&&
name|v2Regions
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|dataManifestBuilder
operator|.
name|addAllRegionManifests
argument_list|(
name|v2Regions
argument_list|)
expr_stmt|;
block|}
comment|// Write the v2 Data Manifest.
comment|// Once the data-manifest is written, the snapshot can be considered complete.
comment|// Currently snapshots are written in a "temporary" directory and later
comment|// moved to the "complated" snapshot directory.
name|SnapshotDataManifest
name|dataManifest
init|=
name|dataManifestBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
name|writeDataManifest
argument_list|(
name|dataManifest
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionManifests
operator|=
name|dataManifest
operator|.
name|getRegionManifestsList
argument_list|()
expr_stmt|;
comment|// Remove the region manifests. Everything is now in the data-manifest.
comment|// The delete operation is "relaxed", unless we get an exception we keep going.
comment|// The extra files in the snapshot directory will not give any problem,
comment|// since they have the same content as the data manifest, and even by re-reading
comment|// them we will get the same information.
if|if
condition|(
name|v1Regions
operator|!=
literal|null
operator|&&
name|v1Regions
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|SnapshotRegionManifest
name|regionManifest
range|:
name|v1Regions
control|)
block|{
name|SnapshotManifestV1
operator|.
name|deleteRegionManifest
argument_list|(
name|fs
argument_list|,
name|workingDir
argument_list|,
name|regionManifest
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|v2Regions
operator|!=
literal|null
operator|&&
name|v2Regions
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|SnapshotRegionManifest
name|regionManifest
range|:
name|v2Regions
control|)
block|{
name|SnapshotManifestV2
operator|.
name|deleteRegionManifest
argument_list|(
name|fs
argument_list|,
name|workingDir
argument_list|,
name|regionManifest
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*    * Write the SnapshotDataManifest file    */
specifier|private
name|void
name|writeDataManifest
parameter_list|(
specifier|final
name|SnapshotDataManifest
name|manifest
parameter_list|)
throws|throws
name|IOException
block|{
name|FSDataOutputStream
name|stream
init|=
name|fs
operator|.
name|create
argument_list|(
operator|new
name|Path
argument_list|(
name|workingDir
argument_list|,
name|DATA_MANIFEST_NAME
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|manifest
operator|.
name|writeTo
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|stream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*    * Read the SnapshotDataManifest file    */
specifier|private
name|SnapshotDataManifest
name|readDataManifest
parameter_list|()
throws|throws
name|IOException
block|{
name|FSDataInputStream
name|in
init|=
literal|null
decl_stmt|;
try|try
block|{
name|in
operator|=
name|fs
operator|.
name|open
argument_list|(
operator|new
name|Path
argument_list|(
name|workingDir
argument_list|,
name|DATA_MANIFEST_NAME
argument_list|)
argument_list|)
expr_stmt|;
name|CodedInputStream
name|cin
init|=
name|CodedInputStream
operator|.
name|newInstance
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|cin
operator|.
name|setSizeLimit
argument_list|(
name|manifestSizeLimit
argument_list|)
expr_stmt|;
return|return
name|SnapshotDataManifest
operator|.
name|parseFrom
argument_list|(
name|cin
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|InvalidProtocolBufferException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|CorruptedSnapshotException
argument_list|(
literal|"unable to parse data manifest "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|in
operator|!=
literal|null
condition|)
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|ThreadPoolExecutor
name|createExecutor
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
block|{
return|return
name|createExecutor
argument_list|(
name|conf
argument_list|,
name|name
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|ThreadPoolExecutor
name|createExecutor
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|String
name|name
parameter_list|)
block|{
name|int
name|maxThreads
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.snapshot.thread.pool.max"
argument_list|,
literal|8
argument_list|)
decl_stmt|;
return|return
name|Threads
operator|.
name|getBoundedCachedThreadPool
argument_list|(
name|maxThreads
argument_list|,
literal|30L
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
name|Threads
operator|.
name|getNamedThreadFactory
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Extract the region encoded name from the region manifest    */
specifier|static
name|String
name|getRegionNameFromManifest
parameter_list|(
specifier|final
name|SnapshotRegionManifest
name|manifest
parameter_list|)
block|{
name|byte
index|[]
name|regionName
init|=
name|HRegionInfo
operator|.
name|createRegionName
argument_list|(
name|ProtobufUtil
operator|.
name|toTableName
argument_list|(
name|manifest
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|,
name|manifest
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getStartKey
argument_list|()
operator|.
name|toByteArray
argument_list|()
argument_list|,
name|manifest
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionId
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
name|HRegionInfo
operator|.
name|encodeRegionName
argument_list|(
name|regionName
argument_list|)
return|;
block|}
comment|/*    * Return the snapshot format    */
specifier|private
specifier|static
name|int
name|getSnapshotFormat
parameter_list|(
specifier|final
name|SnapshotDescription
name|desc
parameter_list|)
block|{
return|return
name|desc
operator|.
name|hasVersion
argument_list|()
condition|?
name|desc
operator|.
name|getVersion
argument_list|()
else|:
name|SnapshotManifestV1
operator|.
name|DESCRIPTOR_VERSION
return|;
block|}
block|}
end_class

end_unit

