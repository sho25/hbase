begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Cell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|compactions
operator|.
name|StripeCompactionPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ConcatenatedLists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|TraditionalBinaryPrefix
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_comment
comment|/**  * Stripe implementation of StoreFileManager.  * Not thread safe - relies on external locking (in HStore). Collections that this class  * returns are immutable or unique to the call, so they should be safe.  * Stripe store splits the key space of the region into non-overlapping stripes, as well as  * some recent files that have all the keys (level 0). Each stripe contains a set of files.  * When L0 is compacted, it's split into the files corresponding to existing stripe boundaries,  * that can thus be added to stripes.  * When scan or get happens, it only has to read the files from the corresponding stripes.  * See StripeCompationPolicy on how the stripes are determined; this class doesn't care.  *  * This class should work together with StripeCompactionPolicy and StripeCompactor.  * With regard to how they work, we make at least the following (reasonable) assumptions:  *  - Compaction produces one file per new stripe (if any); that is easy to change.  *  - Compaction has one contiguous set of stripes both in and out, except if L0 is involved.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|StripeStoreFileManager
implements|implements
name|StoreFileManager
implements|,
name|StripeCompactionPolicy
operator|.
name|StripeInformationProvider
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|StripeStoreFileManager
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * The file metadata fields that contain the stripe information.    */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|STRIPE_START_KEY
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"STRIPE_START_KEY"
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|STRIPE_END_KEY
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"STRIPE_END_KEY"
argument_list|)
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|Bytes
operator|.
name|RowEndKeyComparator
name|MAP_COMPARATOR
init|=
operator|new
name|Bytes
operator|.
name|RowEndKeyComparator
argument_list|()
decl_stmt|;
comment|/**    * The key value used for range boundary, indicating that the boundary is open (i.e. +-inf).    */
specifier|public
specifier|final
specifier|static
name|byte
index|[]
name|OPEN_KEY
init|=
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
decl_stmt|;
specifier|final
specifier|static
name|byte
index|[]
name|INVALID_KEY
init|=
literal|null
decl_stmt|;
comment|/**    * The state class. Used solely to replace results atomically during    * compactions and avoid complicated error handling.    */
specifier|private
specifier|static
class|class
name|State
block|{
comment|/**      * The end rows of each stripe. The last stripe end is always open-ended, so it's not stored      * here. It is invariant that the start row of the stripe is the end row of the previous one      * (and is an open boundary for the first one).      */
specifier|public
name|byte
index|[]
index|[]
name|stripeEndRows
init|=
operator|new
name|byte
index|[
literal|0
index|]
index|[]
decl_stmt|;
comment|/**      * Files by stripe. Each element of the list corresponds to stripeEndRow element with the      * same index, except the last one. Inside each list, the files are in reverse order by      * seqNum. Note that the length of this is one higher than that of stripeEndKeys.      */
specifier|public
name|ArrayList
argument_list|<
name|ImmutableList
argument_list|<
name|HStoreFile
argument_list|>
argument_list|>
name|stripeFiles
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Level 0. The files are in reverse order by seqNum. */
specifier|public
name|ImmutableList
argument_list|<
name|HStoreFile
argument_list|>
name|level0Files
init|=
name|ImmutableList
operator|.
name|of
argument_list|()
decl_stmt|;
comment|/** Cached list of all files in the structure, to return from some calls */
specifier|public
name|ImmutableList
argument_list|<
name|HStoreFile
argument_list|>
name|allFilesCached
init|=
name|ImmutableList
operator|.
name|of
argument_list|()
decl_stmt|;
specifier|private
name|ImmutableList
argument_list|<
name|HStoreFile
argument_list|>
name|allCompactedFilesCached
init|=
name|ImmutableList
operator|.
name|of
argument_list|()
decl_stmt|;
block|}
specifier|private
name|State
name|state
init|=
literal|null
decl_stmt|;
comment|/** Cached file metadata (or overrides as the case may be) */
specifier|private
name|HashMap
argument_list|<
name|HStoreFile
argument_list|,
name|byte
index|[]
argument_list|>
name|fileStarts
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
name|HashMap
argument_list|<
name|HStoreFile
argument_list|,
name|byte
index|[]
argument_list|>
name|fileEnds
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Normally invalid key is null, but in the map null is the result for "no key"; so use    * the following constant value in these maps instead. Note that this is a constant and    * we use it to compare by reference when we read from the map. */
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|INVALID_KEY_IN_MAP
init|=
operator|new
name|byte
index|[
literal|0
index|]
decl_stmt|;
specifier|private
specifier|final
name|CellComparator
name|cellComparator
decl_stmt|;
specifier|private
name|StripeStoreConfig
name|config
decl_stmt|;
specifier|private
specifier|final
name|int
name|blockingFileCount
decl_stmt|;
specifier|public
name|StripeStoreFileManager
parameter_list|(
name|CellComparator
name|kvComparator
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|StripeStoreConfig
name|config
parameter_list|)
block|{
name|this
operator|.
name|cellComparator
operator|=
name|kvComparator
expr_stmt|;
name|this
operator|.
name|config
operator|=
name|config
expr_stmt|;
name|this
operator|.
name|blockingFileCount
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|HStore
operator|.
name|BLOCKING_STOREFILES_KEY
argument_list|,
name|HStore
operator|.
name|DEFAULT_BLOCKING_STOREFILE_COUNT
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|loadFiles
parameter_list|(
name|List
argument_list|<
name|HStoreFile
argument_list|>
name|storeFiles
parameter_list|)
block|{
name|loadUnclassifiedStoreFiles
argument_list|(
name|storeFiles
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|HStoreFile
argument_list|>
name|getStorefiles
parameter_list|()
block|{
return|return
name|state
operator|.
name|allFilesCached
return|;
block|}
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|HStoreFile
argument_list|>
name|getCompactedfiles
parameter_list|()
block|{
return|return
name|state
operator|.
name|allCompactedFilesCached
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getCompactedFilesCount
parameter_list|()
block|{
return|return
name|state
operator|.
name|allCompactedFilesCached
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|insertNewFiles
parameter_list|(
name|Collection
argument_list|<
name|HStoreFile
argument_list|>
name|sfs
parameter_list|)
throws|throws
name|IOException
block|{
name|CompactionOrFlushMergeCopy
name|cmc
init|=
operator|new
name|CompactionOrFlushMergeCopy
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|// Passing null does not cause NPE??
name|cmc
operator|.
name|mergeResults
argument_list|(
literal|null
argument_list|,
name|sfs
argument_list|)
expr_stmt|;
name|debugDumpState
argument_list|(
literal|"Added new files"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|ImmutableCollection
argument_list|<
name|HStoreFile
argument_list|>
name|clearFiles
parameter_list|()
block|{
name|ImmutableCollection
argument_list|<
name|HStoreFile
argument_list|>
name|result
init|=
name|state
operator|.
name|allFilesCached
decl_stmt|;
name|this
operator|.
name|state
operator|=
operator|new
name|State
argument_list|()
expr_stmt|;
name|this
operator|.
name|fileStarts
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|fileEnds
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|ImmutableCollection
argument_list|<
name|HStoreFile
argument_list|>
name|clearCompactedFiles
parameter_list|()
block|{
name|ImmutableCollection
argument_list|<
name|HStoreFile
argument_list|>
name|result
init|=
name|state
operator|.
name|allCompactedFilesCached
decl_stmt|;
name|this
operator|.
name|state
operator|=
operator|new
name|State
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getStorefileCount
parameter_list|()
block|{
return|return
name|state
operator|.
name|allFilesCached
operator|.
name|size
argument_list|()
return|;
block|}
comment|/** See {@link StoreFileManager#getCandidateFilesForRowKeyBefore(KeyValue)}    * for details on this methods. */
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|HStoreFile
argument_list|>
name|getCandidateFilesForRowKeyBefore
parameter_list|(
specifier|final
name|KeyValue
name|targetKey
parameter_list|)
block|{
name|KeyBeforeConcatenatedLists
name|result
init|=
operator|new
name|KeyBeforeConcatenatedLists
argument_list|()
decl_stmt|;
comment|// Order matters for this call.
name|result
operator|.
name|addSublist
argument_list|(
name|state
operator|.
name|level0Files
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|state
operator|.
name|stripeFiles
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|lastStripeIndex
init|=
name|findStripeForRow
argument_list|(
name|CellUtil
operator|.
name|cloneRow
argument_list|(
name|targetKey
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|stripeIndex
init|=
name|lastStripeIndex
init|;
name|stripeIndex
operator|>=
literal|0
condition|;
operator|--
name|stripeIndex
control|)
block|{
name|result
operator|.
name|addSublist
argument_list|(
name|state
operator|.
name|stripeFiles
operator|.
name|get
argument_list|(
name|stripeIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
operator|.
name|iterator
argument_list|()
return|;
block|}
comment|/** See {@link StoreFileManager#getCandidateFilesForRowKeyBefore(KeyValue)} and    * {@link StoreFileManager#updateCandidateFilesForRowKeyBefore(Iterator, KeyValue, Cell)}    * for details on this methods. */
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|HStoreFile
argument_list|>
name|updateCandidateFilesForRowKeyBefore
parameter_list|(
name|Iterator
argument_list|<
name|HStoreFile
argument_list|>
name|candidateFiles
parameter_list|,
specifier|final
name|KeyValue
name|targetKey
parameter_list|,
specifier|final
name|Cell
name|candidate
parameter_list|)
block|{
name|KeyBeforeConcatenatedLists
operator|.
name|Iterator
name|original
init|=
operator|(
name|KeyBeforeConcatenatedLists
operator|.
name|Iterator
operator|)
name|candidateFiles
decl_stmt|;
assert|assert
name|original
operator|!=
literal|null
assert|;
name|ArrayList
argument_list|<
name|List
argument_list|<
name|HStoreFile
argument_list|>
argument_list|>
name|components
init|=
name|original
operator|.
name|getComponents
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|firstIrrelevant
init|=
literal|0
init|;
name|firstIrrelevant
operator|<
name|components
operator|.
name|size
argument_list|()
condition|;
operator|++
name|firstIrrelevant
control|)
block|{
name|HStoreFile
name|sf
init|=
name|components
operator|.
name|get
argument_list|(
name|firstIrrelevant
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|byte
index|[]
name|endKey
init|=
name|endOf
argument_list|(
name|sf
argument_list|)
decl_stmt|;
comment|// Entries are ordered as such: L0, then stripes in reverse order. We never remove
comment|// level 0; we remove the stripe, and all subsequent ones, as soon as we find the
comment|// first one that cannot possibly have better candidates.
if|if
condition|(
operator|!
name|isInvalid
argument_list|(
name|endKey
argument_list|)
operator|&&
operator|!
name|isOpen
argument_list|(
name|endKey
argument_list|)
operator|&&
operator|(
name|nonOpenRowCompare
argument_list|(
name|targetKey
argument_list|,
name|endKey
argument_list|)
operator|>=
literal|0
operator|)
condition|)
block|{
name|original
operator|.
name|removeComponents
argument_list|(
name|firstIrrelevant
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|original
return|;
block|}
comment|/**    * Override of getSplitPoint that determines the split point as the boundary between two    * stripes, unless it causes significant imbalance between split sides' sizes. In that    * case, the split boundary will be chosen from the middle of one of the stripes to    * minimize imbalance.    * @return The split point, or null if no split is possible.    */
annotation|@
name|Override
specifier|public
name|Optional
argument_list|<
name|byte
index|[]
argument_list|>
name|getSplitPoint
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|getStorefileCount
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
if|if
condition|(
name|state
operator|.
name|stripeFiles
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
block|{
return|return
name|getSplitPointFromAllFiles
argument_list|()
return|;
block|}
name|int
name|leftIndex
init|=
operator|-
literal|1
decl_stmt|,
name|rightIndex
init|=
name|state
operator|.
name|stripeFiles
operator|.
name|size
argument_list|()
decl_stmt|;
name|long
name|leftSize
init|=
literal|0
decl_stmt|,
name|rightSize
init|=
literal|0
decl_stmt|;
name|long
name|lastLeftSize
init|=
literal|0
decl_stmt|,
name|lastRightSize
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|rightIndex
operator|-
literal|1
operator|!=
name|leftIndex
condition|)
block|{
if|if
condition|(
name|leftSize
operator|>=
name|rightSize
condition|)
block|{
operator|--
name|rightIndex
expr_stmt|;
name|lastRightSize
operator|=
name|getStripeFilesSize
argument_list|(
name|rightIndex
argument_list|)
expr_stmt|;
name|rightSize
operator|+=
name|lastRightSize
expr_stmt|;
block|}
else|else
block|{
operator|++
name|leftIndex
expr_stmt|;
name|lastLeftSize
operator|=
name|getStripeFilesSize
argument_list|(
name|leftIndex
argument_list|)
expr_stmt|;
name|leftSize
operator|+=
name|lastLeftSize
expr_stmt|;
block|}
block|}
if|if
condition|(
name|leftSize
operator|==
literal|0
operator|||
name|rightSize
operator|==
literal|0
condition|)
block|{
name|String
name|errMsg
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Cannot split on a boundary - left index %d size %d, "
operator|+
literal|"right index %d size %d"
argument_list|,
name|leftIndex
argument_list|,
name|leftSize
argument_list|,
name|rightIndex
argument_list|,
name|rightSize
argument_list|)
decl_stmt|;
name|debugDumpState
argument_list|(
name|errMsg
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|errMsg
argument_list|)
expr_stmt|;
return|return
name|getSplitPointFromAllFiles
argument_list|()
return|;
block|}
name|double
name|ratio
init|=
operator|(
name|double
operator|)
name|rightSize
operator|/
name|leftSize
decl_stmt|;
if|if
condition|(
name|ratio
operator|<
literal|1
condition|)
block|{
name|ratio
operator|=
literal|1
operator|/
name|ratio
expr_stmt|;
block|}
if|if
condition|(
name|config
operator|.
name|getMaxSplitImbalance
argument_list|()
operator|>
name|ratio
condition|)
block|{
return|return
name|Optional
operator|.
name|of
argument_list|(
name|state
operator|.
name|stripeEndRows
index|[
name|leftIndex
index|]
argument_list|)
return|;
block|}
comment|// If the difference between the sides is too large, we could get the proportional key on
comment|// the a stripe to equalize the difference, but there's no proportional key method at the
comment|// moment, and it's not extremely important.
comment|// See if we can achieve better ratio if we split the bigger side in half.
name|boolean
name|isRightLarger
init|=
name|rightSize
operator|>=
name|leftSize
decl_stmt|;
name|double
name|newRatio
init|=
name|isRightLarger
condition|?
name|getMidStripeSplitRatio
argument_list|(
name|leftSize
argument_list|,
name|rightSize
argument_list|,
name|lastRightSize
argument_list|)
else|:
name|getMidStripeSplitRatio
argument_list|(
name|rightSize
argument_list|,
name|leftSize
argument_list|,
name|lastLeftSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|newRatio
operator|<
literal|1
condition|)
block|{
name|newRatio
operator|=
literal|1
operator|/
name|newRatio
expr_stmt|;
block|}
if|if
condition|(
name|newRatio
operator|>=
name|ratio
condition|)
block|{
return|return
name|Optional
operator|.
name|of
argument_list|(
name|state
operator|.
name|stripeEndRows
index|[
name|leftIndex
index|]
argument_list|)
return|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Splitting the stripe - ratio w/o split "
operator|+
name|ratio
operator|+
literal|", ratio with split "
operator|+
name|newRatio
operator|+
literal|" configured ratio "
operator|+
name|config
operator|.
name|getMaxSplitImbalance
argument_list|()
argument_list|)
expr_stmt|;
comment|// OK, we may get better ratio, get it.
return|return
name|StoreUtils
operator|.
name|getSplitPoint
argument_list|(
name|state
operator|.
name|stripeFiles
operator|.
name|get
argument_list|(
name|isRightLarger
condition|?
name|rightIndex
else|:
name|leftIndex
argument_list|)
argument_list|,
name|cellComparator
argument_list|)
return|;
block|}
specifier|private
name|Optional
argument_list|<
name|byte
index|[]
argument_list|>
name|getSplitPointFromAllFiles
parameter_list|()
throws|throws
name|IOException
block|{
name|ConcatenatedLists
argument_list|<
name|HStoreFile
argument_list|>
name|sfs
init|=
operator|new
name|ConcatenatedLists
argument_list|<>
argument_list|()
decl_stmt|;
name|sfs
operator|.
name|addSublist
argument_list|(
name|state
operator|.
name|level0Files
argument_list|)
expr_stmt|;
name|sfs
operator|.
name|addAllSublists
argument_list|(
name|state
operator|.
name|stripeFiles
argument_list|)
expr_stmt|;
return|return
name|StoreUtils
operator|.
name|getSplitPoint
argument_list|(
name|sfs
argument_list|,
name|cellComparator
argument_list|)
return|;
block|}
specifier|private
name|double
name|getMidStripeSplitRatio
parameter_list|(
name|long
name|smallerSize
parameter_list|,
name|long
name|largerSize
parameter_list|,
name|long
name|lastLargerSize
parameter_list|)
block|{
return|return
call|(
name|double
call|)
argument_list|(
name|largerSize
operator|-
name|lastLargerSize
operator|/
literal|2f
argument_list|)
operator|/
operator|(
name|smallerSize
operator|+
name|lastLargerSize
operator|/
literal|2f
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|HStoreFile
argument_list|>
name|getFilesForScan
parameter_list|(
name|byte
index|[]
name|startRow
parameter_list|,
name|boolean
name|includeStartRow
parameter_list|,
name|byte
index|[]
name|stopRow
parameter_list|,
name|boolean
name|includeStopRow
parameter_list|)
block|{
if|if
condition|(
name|state
operator|.
name|stripeFiles
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|state
operator|.
name|level0Files
return|;
comment|// There's just L0.
block|}
name|int
name|firstStripe
init|=
name|findStripeForRow
argument_list|(
name|startRow
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|int
name|lastStripe
init|=
name|findStripeForRow
argument_list|(
name|stopRow
argument_list|,
literal|false
argument_list|)
decl_stmt|;
assert|assert
name|firstStripe
operator|<=
name|lastStripe
assert|;
if|if
condition|(
name|firstStripe
operator|==
name|lastStripe
operator|&&
name|state
operator|.
name|level0Files
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|state
operator|.
name|stripeFiles
operator|.
name|get
argument_list|(
name|firstStripe
argument_list|)
return|;
comment|// There's just one stripe we need.
block|}
if|if
condition|(
name|firstStripe
operator|==
literal|0
operator|&&
name|lastStripe
operator|==
operator|(
name|state
operator|.
name|stripeFiles
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
condition|)
block|{
return|return
name|state
operator|.
name|allFilesCached
return|;
comment|// We need to read all files.
block|}
name|ConcatenatedLists
argument_list|<
name|HStoreFile
argument_list|>
name|result
init|=
operator|new
name|ConcatenatedLists
argument_list|<>
argument_list|()
decl_stmt|;
name|result
operator|.
name|addAllSublists
argument_list|(
name|state
operator|.
name|stripeFiles
operator|.
name|subList
argument_list|(
name|firstStripe
argument_list|,
name|lastStripe
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|addSublist
argument_list|(
name|state
operator|.
name|level0Files
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addCompactionResults
parameter_list|(
name|Collection
argument_list|<
name|HStoreFile
argument_list|>
name|compactedFiles
parameter_list|,
name|Collection
argument_list|<
name|HStoreFile
argument_list|>
name|results
parameter_list|)
throws|throws
name|IOException
block|{
comment|// See class comment for the assumptions we make here.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempting to merge compaction results: "
operator|+
name|compactedFiles
operator|.
name|size
argument_list|()
operator|+
literal|" files replaced by "
operator|+
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// In order to be able to fail in the middle of the operation, we'll operate on lazy
comment|// copies and apply the result at the end.
name|CompactionOrFlushMergeCopy
name|cmc
init|=
operator|new
name|CompactionOrFlushMergeCopy
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|cmc
operator|.
name|mergeResults
argument_list|(
name|compactedFiles
argument_list|,
name|results
argument_list|)
expr_stmt|;
name|markCompactedAway
argument_list|(
name|compactedFiles
argument_list|)
expr_stmt|;
name|debugDumpState
argument_list|(
literal|"Merged compaction results"
argument_list|)
expr_stmt|;
block|}
comment|// Mark the files as compactedAway once the storefiles and compactedfiles list is finalised
comment|// Let a background thread close the actual reader on these compacted files and also
comment|// ensure to evict the blocks from block cache so that they are no longer in
comment|// cache
specifier|private
name|void
name|markCompactedAway
parameter_list|(
name|Collection
argument_list|<
name|HStoreFile
argument_list|>
name|compactedFiles
parameter_list|)
block|{
for|for
control|(
name|HStoreFile
name|file
range|:
name|compactedFiles
control|)
block|{
name|file
operator|.
name|markCompactedAway
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeCompactedFiles
parameter_list|(
name|Collection
argument_list|<
name|HStoreFile
argument_list|>
name|compactedFiles
parameter_list|)
throws|throws
name|IOException
block|{
comment|// See class comment for the assumptions we make here.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempting to delete compaction results: "
operator|+
name|compactedFiles
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// In order to be able to fail in the middle of the operation, we'll operate on lazy
comment|// copies and apply the result at the end.
name|CompactionOrFlushMergeCopy
name|cmc
init|=
operator|new
name|CompactionOrFlushMergeCopy
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|cmc
operator|.
name|deleteResults
argument_list|(
name|compactedFiles
argument_list|)
expr_stmt|;
name|debugDumpState
argument_list|(
literal|"Deleted compaction results"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getStoreCompactionPriority
parameter_list|()
block|{
comment|// If there's only L0, do what the default store does.
comment|// If we are in critical priority, do the same - we don't want to trump all stores all
comment|// the time due to how many files we have.
name|int
name|fc
init|=
name|getStorefileCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
operator|.
name|stripeFiles
operator|.
name|isEmpty
argument_list|()
operator|||
operator|(
name|this
operator|.
name|blockingFileCount
operator|<=
name|fc
operator|)
condition|)
block|{
return|return
name|this
operator|.
name|blockingFileCount
operator|-
name|fc
return|;
block|}
comment|// If we are in good shape, we don't want to be trumped by all other stores due to how
comment|// many files we have, so do an approximate mapping to normal priority range; L0 counts
comment|// for all stripes.
name|int
name|l0
init|=
name|state
operator|.
name|level0Files
operator|.
name|size
argument_list|()
decl_stmt|,
name|sc
init|=
name|state
operator|.
name|stripeFiles
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|priority
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
operator|(
call|(
name|double
call|)
argument_list|(
name|this
operator|.
name|blockingFileCount
operator|-
name|fc
operator|+
name|l0
argument_list|)
operator|/
name|sc
operator|)
operator|-
name|l0
argument_list|)
decl_stmt|;
return|return
operator|(
name|priority
operator|<=
name|HStore
operator|.
name|PRIORITY_USER
operator|)
condition|?
operator|(
name|HStore
operator|.
name|PRIORITY_USER
operator|+
literal|1
operator|)
else|:
name|priority
return|;
block|}
comment|/**    * Gets the total size of all files in the stripe.    * @param stripeIndex Stripe index.    * @return Size.    */
specifier|private
name|long
name|getStripeFilesSize
parameter_list|(
name|int
name|stripeIndex
parameter_list|)
block|{
name|long
name|result
init|=
literal|0
decl_stmt|;
for|for
control|(
name|HStoreFile
name|sf
range|:
name|state
operator|.
name|stripeFiles
operator|.
name|get
argument_list|(
name|stripeIndex
argument_list|)
control|)
block|{
name|result
operator|+=
name|sf
operator|.
name|getReader
argument_list|()
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Loads initial store files that were picked up from some physical location pertaining to    * this store (presumably). Unlike adding files after compaction, assumes empty initial    * sets, and is forgiving with regard to stripe constraints - at worst, many/all files will    * go to level 0.    * @param storeFiles Store files to add.    */
specifier|private
name|void
name|loadUnclassifiedStoreFiles
parameter_list|(
name|List
argument_list|<
name|HStoreFile
argument_list|>
name|storeFiles
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempting to load "
operator|+
name|storeFiles
operator|.
name|size
argument_list|()
operator|+
literal|" store files."
argument_list|)
expr_stmt|;
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|ArrayList
argument_list|<
name|HStoreFile
argument_list|>
argument_list|>
name|candidateStripes
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|MAP_COMPARATOR
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|HStoreFile
argument_list|>
name|level0Files
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Separate the files into tentative stripes; then validate. Currently, we rely on metadata.
comment|// If needed, we could dynamically determine the stripes in future.
for|for
control|(
name|HStoreFile
name|sf
range|:
name|storeFiles
control|)
block|{
name|byte
index|[]
name|startRow
init|=
name|startOf
argument_list|(
name|sf
argument_list|)
decl_stmt|,
name|endRow
init|=
name|endOf
argument_list|(
name|sf
argument_list|)
decl_stmt|;
comment|// Validate the range and put the files into place.
if|if
condition|(
name|isInvalid
argument_list|(
name|startRow
argument_list|)
operator|||
name|isInvalid
argument_list|(
name|endRow
argument_list|)
condition|)
block|{
name|insertFileIntoStripe
argument_list|(
name|level0Files
argument_list|,
name|sf
argument_list|)
expr_stmt|;
comment|// No metadata - goes to L0.
name|ensureLevel0Metadata
argument_list|(
name|sf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isOpen
argument_list|(
name|startRow
argument_list|)
operator|&&
operator|!
name|isOpen
argument_list|(
name|endRow
argument_list|)
operator|&&
name|nonOpenRowCompare
argument_list|(
name|startRow
argument_list|,
name|endRow
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unexpected metadata - start row ["
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|startRow
argument_list|)
operator|+
literal|"], end row ["
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|endRow
argument_list|)
operator|+
literal|"] in file ["
operator|+
name|sf
operator|.
name|getPath
argument_list|()
operator|+
literal|"], pushing to L0"
argument_list|)
expr_stmt|;
name|insertFileIntoStripe
argument_list|(
name|level0Files
argument_list|,
name|sf
argument_list|)
expr_stmt|;
comment|// Bad metadata - goes to L0 also.
name|ensureLevel0Metadata
argument_list|(
name|sf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ArrayList
argument_list|<
name|HStoreFile
argument_list|>
name|stripe
init|=
name|candidateStripes
operator|.
name|get
argument_list|(
name|endRow
argument_list|)
decl_stmt|;
if|if
condition|(
name|stripe
operator|==
literal|null
condition|)
block|{
name|stripe
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|candidateStripes
operator|.
name|put
argument_list|(
name|endRow
argument_list|,
name|stripe
argument_list|)
expr_stmt|;
block|}
name|insertFileIntoStripe
argument_list|(
name|stripe
argument_list|,
name|sf
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Possible improvement - for variable-count stripes, if all the files are in L0, we can
comment|// instead create single, open-ended stripe with all files.
name|boolean
name|hasOverlaps
init|=
literal|false
decl_stmt|;
name|byte
index|[]
name|expectedStartRow
init|=
literal|null
decl_stmt|;
comment|// first stripe can start wherever
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|ArrayList
argument_list|<
name|HStoreFile
argument_list|>
argument_list|>
argument_list|>
name|entryIter
init|=
name|candidateStripes
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|entryIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|ArrayList
argument_list|<
name|HStoreFile
argument_list|>
argument_list|>
name|entry
init|=
name|entryIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|HStoreFile
argument_list|>
name|files
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// Validate the file start rows, and remove the bad ones to level 0.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|files
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|HStoreFile
name|sf
init|=
name|files
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|byte
index|[]
name|startRow
init|=
name|startOf
argument_list|(
name|sf
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedStartRow
operator|==
literal|null
condition|)
block|{
name|expectedStartRow
operator|=
name|startRow
expr_stmt|;
comment|// ensure that first stripe is still consistent
block|}
elseif|else
if|if
condition|(
operator|!
name|rowEquals
argument_list|(
name|expectedStartRow
argument_list|,
name|startRow
argument_list|)
condition|)
block|{
name|hasOverlaps
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Store file doesn't fit into the tentative stripes - expected to start at ["
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|expectedStartRow
argument_list|)
operator|+
literal|"], but starts at ["
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|startRow
argument_list|)
operator|+
literal|"], to L0 it goes"
argument_list|)
expr_stmt|;
name|HStoreFile
name|badSf
init|=
name|files
operator|.
name|remove
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|insertFileIntoStripe
argument_list|(
name|level0Files
argument_list|,
name|badSf
argument_list|)
expr_stmt|;
name|ensureLevel0Metadata
argument_list|(
name|badSf
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
block|}
comment|// Check if any files from the candidate stripe are valid. If so, add a stripe.
name|byte
index|[]
name|endRow
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|files
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|expectedStartRow
operator|=
name|endRow
expr_stmt|;
comment|// Next stripe must start exactly at that key.
block|}
else|else
block|{
name|entryIter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
comment|// In the end, there must be open ends on two sides. If not, and there were no errors i.e.
comment|// files are consistent, they might be coming from a split. We will treat the boundaries
comment|// as open keys anyway, and log the message.
comment|// If there were errors, we'll play it safe and dump everything into L0.
if|if
condition|(
operator|!
name|candidateStripes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|HStoreFile
name|firstFile
init|=
name|candidateStripes
operator|.
name|firstEntry
argument_list|()
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|boolean
name|isOpen
init|=
name|isOpen
argument_list|(
name|startOf
argument_list|(
name|firstFile
argument_list|)
argument_list|)
operator|&&
name|isOpen
argument_list|(
name|candidateStripes
operator|.
name|lastKey
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isOpen
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The range of the loaded files does not cover full key space: from ["
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|startOf
argument_list|(
name|firstFile
argument_list|)
argument_list|)
operator|+
literal|"], to ["
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|candidateStripes
operator|.
name|lastKey
argument_list|()
argument_list|)
operator|+
literal|"]"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hasOverlaps
condition|)
block|{
name|ensureEdgeStripeMetadata
argument_list|(
name|candidateStripes
operator|.
name|firstEntry
argument_list|()
operator|.
name|getValue
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|ensureEdgeStripeMetadata
argument_list|(
name|candidateStripes
operator|.
name|lastEntry
argument_list|()
operator|.
name|getValue
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Inconsistent files, everything goes to L0."
argument_list|)
expr_stmt|;
for|for
control|(
name|ArrayList
argument_list|<
name|HStoreFile
argument_list|>
name|files
range|:
name|candidateStripes
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|HStoreFile
name|sf
range|:
name|files
control|)
block|{
name|insertFileIntoStripe
argument_list|(
name|level0Files
argument_list|,
name|sf
argument_list|)
expr_stmt|;
name|ensureLevel0Metadata
argument_list|(
name|sf
argument_list|)
expr_stmt|;
block|}
block|}
name|candidateStripes
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// Copy the results into the fields.
name|State
name|state
init|=
operator|new
name|State
argument_list|()
decl_stmt|;
name|state
operator|.
name|level0Files
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|level0Files
argument_list|)
expr_stmt|;
name|state
operator|.
name|stripeFiles
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|candidateStripes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|state
operator|.
name|stripeEndRows
operator|=
operator|new
name|byte
index|[
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|candidateStripes
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
index|]
index|[]
expr_stmt|;
name|ArrayList
argument_list|<
name|HStoreFile
argument_list|>
name|newAllFiles
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|level0Files
argument_list|)
decl_stmt|;
name|int
name|i
init|=
name|candidateStripes
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|ArrayList
argument_list|<
name|HStoreFile
argument_list|>
argument_list|>
name|entry
range|:
name|candidateStripes
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|state
operator|.
name|stripeFiles
operator|.
name|add
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|newAllFiles
operator|.
name|addAll
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|state
operator|.
name|stripeEndRows
index|[
name|state
operator|.
name|stripeFiles
operator|.
name|size
argument_list|()
operator|-
literal|1
index|]
operator|=
name|entry
operator|.
name|getKey
argument_list|()
expr_stmt|;
block|}
operator|--
name|i
expr_stmt|;
block|}
name|state
operator|.
name|allFilesCached
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|newAllFiles
argument_list|)
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
name|debugDumpState
argument_list|(
literal|"Files loaded"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|ensureEdgeStripeMetadata
parameter_list|(
name|ArrayList
argument_list|<
name|HStoreFile
argument_list|>
name|stripe
parameter_list|,
name|boolean
name|isFirst
parameter_list|)
block|{
name|HashMap
argument_list|<
name|HStoreFile
argument_list|,
name|byte
index|[]
argument_list|>
name|targetMap
init|=
name|isFirst
condition|?
name|fileStarts
else|:
name|fileEnds
decl_stmt|;
for|for
control|(
name|HStoreFile
name|sf
range|:
name|stripe
control|)
block|{
name|targetMap
operator|.
name|put
argument_list|(
name|sf
argument_list|,
name|OPEN_KEY
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|ensureLevel0Metadata
parameter_list|(
name|HStoreFile
name|sf
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isInvalid
argument_list|(
name|startOf
argument_list|(
name|sf
argument_list|)
argument_list|)
condition|)
name|this
operator|.
name|fileStarts
operator|.
name|put
argument_list|(
name|sf
argument_list|,
name|INVALID_KEY_IN_MAP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isInvalid
argument_list|(
name|endOf
argument_list|(
name|sf
argument_list|)
argument_list|)
condition|)
name|this
operator|.
name|fileEnds
operator|.
name|put
argument_list|(
name|sf
argument_list|,
name|INVALID_KEY_IN_MAP
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|debugDumpState
parameter_list|(
name|String
name|string
parameter_list|)
block|{
if|if
condition|(
operator|!
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
return|return;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
operator|+
name|string
operator|+
literal|"; current stripe state is as such:"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n level 0 with "
argument_list|)
operator|.
name|append
argument_list|(
name|state
operator|.
name|level0Files
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" files: "
operator|+
name|TraditionalBinaryPrefix
operator|.
name|long2String
argument_list|(
name|StripeCompactionPolicy
operator|.
name|getTotalFileSize
argument_list|(
name|state
operator|.
name|level0Files
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
operator|+
literal|";"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|state
operator|.
name|stripeFiles
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|String
name|endRow
init|=
operator|(
name|i
operator|==
name|state
operator|.
name|stripeEndRows
operator|.
name|length
operator|)
condition|?
literal|"(end)"
else|:
literal|"["
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|state
operator|.
name|stripeEndRows
index|[
name|i
index|]
argument_list|)
operator|+
literal|"]"
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n stripe ending in "
argument_list|)
operator|.
name|append
argument_list|(
name|endRow
argument_list|)
operator|.
name|append
argument_list|(
literal|" with "
argument_list|)
operator|.
name|append
argument_list|(
name|state
operator|.
name|stripeFiles
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" files: "
operator|+
name|TraditionalBinaryPrefix
operator|.
name|long2String
argument_list|(
name|StripeCompactionPolicy
operator|.
name|getTotalFileSize
argument_list|(
name|state
operator|.
name|stripeFiles
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
operator|+
literal|";"
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
operator|.
name|append
argument_list|(
name|state
operator|.
name|stripeFiles
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" stripes total."
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
operator|.
name|append
argument_list|(
name|getStorefileCount
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" files total."
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Checks whether the key indicates an open interval boundary (i.e. infinity).    */
specifier|private
specifier|static
specifier|final
name|boolean
name|isOpen
parameter_list|(
name|byte
index|[]
name|key
parameter_list|)
block|{
return|return
name|key
operator|!=
literal|null
operator|&&
name|key
operator|.
name|length
operator|==
literal|0
return|;
block|}
specifier|private
specifier|static
specifier|final
name|boolean
name|isOpen
parameter_list|(
name|Cell
name|key
parameter_list|)
block|{
return|return
name|key
operator|!=
literal|null
operator|&&
name|key
operator|.
name|getRowLength
argument_list|()
operator|==
literal|0
return|;
block|}
comment|/**    * Checks whether the key is invalid (e.g. from an L0 file, or non-stripe-compacted files).    */
specifier|private
specifier|static
specifier|final
name|boolean
name|isInvalid
parameter_list|(
name|byte
index|[]
name|key
parameter_list|)
block|{
comment|// No need to use Arrays.equals because INVALID_KEY is null
return|return
name|key
operator|==
name|INVALID_KEY
return|;
block|}
comment|/**    * Compare two keys for equality.    */
specifier|private
specifier|final
name|boolean
name|rowEquals
parameter_list|(
name|byte
index|[]
name|k1
parameter_list|,
name|byte
index|[]
name|k2
parameter_list|)
block|{
return|return
name|Bytes
operator|.
name|equals
argument_list|(
name|k1
argument_list|,
literal|0
argument_list|,
name|k1
operator|.
name|length
argument_list|,
name|k2
argument_list|,
literal|0
argument_list|,
name|k2
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * Compare two keys. Keys must not be open (isOpen(row) == false).    */
specifier|private
specifier|final
name|int
name|nonOpenRowCompare
parameter_list|(
name|byte
index|[]
name|k1
parameter_list|,
name|byte
index|[]
name|k2
parameter_list|)
block|{
assert|assert
operator|!
name|isOpen
argument_list|(
name|k1
argument_list|)
operator|&&
operator|!
name|isOpen
argument_list|(
name|k2
argument_list|)
assert|;
return|return
name|Bytes
operator|.
name|compareTo
argument_list|(
name|k1
argument_list|,
name|k2
argument_list|)
return|;
block|}
specifier|private
specifier|final
name|int
name|nonOpenRowCompare
parameter_list|(
name|Cell
name|k1
parameter_list|,
name|byte
index|[]
name|k2
parameter_list|)
block|{
assert|assert
operator|!
name|isOpen
argument_list|(
name|k1
argument_list|)
operator|&&
operator|!
name|isOpen
argument_list|(
name|k2
argument_list|)
assert|;
return|return
name|cellComparator
operator|.
name|compareRows
argument_list|(
name|k1
argument_list|,
name|k2
argument_list|,
literal|0
argument_list|,
name|k2
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * Finds the stripe index by end row.    */
specifier|private
specifier|final
name|int
name|findStripeIndexByEndRow
parameter_list|(
name|byte
index|[]
name|endRow
parameter_list|)
block|{
assert|assert
operator|!
name|isInvalid
argument_list|(
name|endRow
argument_list|)
assert|;
if|if
condition|(
name|isOpen
argument_list|(
name|endRow
argument_list|)
condition|)
return|return
name|state
operator|.
name|stripeEndRows
operator|.
name|length
return|;
return|return
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|state
operator|.
name|stripeEndRows
argument_list|,
name|endRow
argument_list|,
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
return|;
block|}
comment|/**    * Finds the stripe index for the stripe containing a row provided externally for get/scan.    */
specifier|private
specifier|final
name|int
name|findStripeForRow
parameter_list|(
name|byte
index|[]
name|row
parameter_list|,
name|boolean
name|isStart
parameter_list|)
block|{
if|if
condition|(
name|isStart
operator|&&
name|Arrays
operator|.
name|equals
argument_list|(
name|row
argument_list|,
name|HConstants
operator|.
name|EMPTY_START_ROW
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|isStart
operator|&&
name|Arrays
operator|.
name|equals
argument_list|(
name|row
argument_list|,
name|HConstants
operator|.
name|EMPTY_END_ROW
argument_list|)
condition|)
block|{
return|return
name|state
operator|.
name|stripeFiles
operator|.
name|size
argument_list|()
operator|-
literal|1
return|;
block|}
comment|// If there's an exact match below, a stripe ends at "row". Stripe right boundary is
comment|// exclusive, so that means the row is in the next stripe; thus, we need to add one to index.
comment|// If there's no match, the return value of binarySearch is (-(insertion point) - 1), where
comment|// insertion point is the index of the next greater element, or list size if none. The
comment|// insertion point happens to be exactly what we need, so we need to add one to the result.
return|return
name|Math
operator|.
name|abs
argument_list|(
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|state
operator|.
name|stripeEndRows
argument_list|,
name|row
argument_list|,
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
operator|+
literal|1
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|byte
index|[]
name|getStartRow
parameter_list|(
name|int
name|stripeIndex
parameter_list|)
block|{
return|return
operator|(
name|stripeIndex
operator|==
literal|0
condition|?
name|OPEN_KEY
else|:
name|state
operator|.
name|stripeEndRows
index|[
name|stripeIndex
operator|-
literal|1
index|]
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|byte
index|[]
name|getEndRow
parameter_list|(
name|int
name|stripeIndex
parameter_list|)
block|{
return|return
operator|(
name|stripeIndex
operator|==
name|state
operator|.
name|stripeEndRows
operator|.
name|length
condition|?
name|OPEN_KEY
else|:
name|state
operator|.
name|stripeEndRows
index|[
name|stripeIndex
index|]
operator|)
return|;
block|}
specifier|private
name|byte
index|[]
name|startOf
parameter_list|(
name|HStoreFile
name|sf
parameter_list|)
block|{
name|byte
index|[]
name|result
init|=
name|fileStarts
operator|.
name|get
argument_list|(
name|sf
argument_list|)
decl_stmt|;
comment|// result and INVALID_KEY_IN_MAP are compared _only_ by reference on purpose here as the latter
comment|// serves only as a marker and is not to be confused with other empty byte arrays.
comment|// See Javadoc of INVALID_KEY_IN_MAP for more information
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|sf
operator|.
name|getMetadataValue
argument_list|(
name|STRIPE_START_KEY
argument_list|)
else|:
name|result
operator|==
name|INVALID_KEY_IN_MAP
condition|?
name|INVALID_KEY
else|:
name|result
return|;
block|}
specifier|private
name|byte
index|[]
name|endOf
parameter_list|(
name|HStoreFile
name|sf
parameter_list|)
block|{
name|byte
index|[]
name|result
init|=
name|fileEnds
operator|.
name|get
argument_list|(
name|sf
argument_list|)
decl_stmt|;
comment|// result and INVALID_KEY_IN_MAP are compared _only_ by reference on purpose here as the latter
comment|// serves only as a marker and is not to be confused with other empty byte arrays.
comment|// See Javadoc of INVALID_KEY_IN_MAP for more information
return|return
operator|(
name|result
operator|==
literal|null
operator|)
condition|?
name|sf
operator|.
name|getMetadataValue
argument_list|(
name|STRIPE_END_KEY
argument_list|)
else|:
name|result
operator|==
name|INVALID_KEY_IN_MAP
condition|?
name|INVALID_KEY
else|:
name|result
return|;
block|}
comment|/**    * Inserts a file in the correct place (by seqnum) in a stripe copy.    * @param stripe Stripe copy to insert into.    * @param sf File to insert.    */
specifier|private
specifier|static
name|void
name|insertFileIntoStripe
parameter_list|(
name|ArrayList
argument_list|<
name|HStoreFile
argument_list|>
name|stripe
parameter_list|,
name|HStoreFile
name|sf
parameter_list|)
block|{
comment|// The only operation for which sorting of the files matters is KeyBefore. Therefore,
comment|// we will store the file in reverse order by seqNum from the outset.
for|for
control|(
name|int
name|insertBefore
init|=
literal|0
init|;
condition|;
operator|++
name|insertBefore
control|)
block|{
if|if
condition|(
name|insertBefore
operator|==
name|stripe
operator|.
name|size
argument_list|()
operator|||
operator|(
name|StoreFileComparators
operator|.
name|SEQ_ID
operator|.
name|compare
argument_list|(
name|sf
argument_list|,
name|stripe
operator|.
name|get
argument_list|(
name|insertBefore
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
condition|)
block|{
name|stripe
operator|.
name|add
argument_list|(
name|insertBefore
argument_list|,
name|sf
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/**    * An extension of ConcatenatedLists that has several peculiar properties.    * First, one can cut the tail of the logical list by removing last several sub-lists.    * Second, items can be removed thru iterator.    * Third, if the sub-lists are immutable, they are replaced with mutable copies when needed.    * On average KeyBefore operation will contain half the stripes as potential candidates,    * but will quickly cut down on them as it finds something in the more likely ones; thus,    * the above allow us to avoid unnecessary copying of a bunch of lists.    */
specifier|private
specifier|static
class|class
name|KeyBeforeConcatenatedLists
extends|extends
name|ConcatenatedLists
argument_list|<
name|HStoreFile
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|java
operator|.
name|util
operator|.
name|Iterator
argument_list|<
name|HStoreFile
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Iterator
argument_list|()
return|;
block|}
specifier|public
class|class
name|Iterator
extends|extends
name|ConcatenatedLists
argument_list|<
name|HStoreFile
argument_list|>
operator|.
name|Iterator
block|{
specifier|public
name|ArrayList
argument_list|<
name|List
argument_list|<
name|HStoreFile
argument_list|>
argument_list|>
name|getComponents
parameter_list|()
block|{
return|return
name|components
return|;
block|}
specifier|public
name|void
name|removeComponents
parameter_list|(
name|int
name|startIndex
parameter_list|)
block|{
name|List
argument_list|<
name|List
argument_list|<
name|HStoreFile
argument_list|>
argument_list|>
name|subList
init|=
name|components
operator|.
name|subList
argument_list|(
name|startIndex
argument_list|,
name|components
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|HStoreFile
argument_list|>
name|entry
range|:
name|subList
control|)
block|{
name|size
operator|-=
name|entry
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
assert|assert
name|size
operator|>=
literal|0
assert|;
name|subList
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|nextWasCalled
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"No element to remove"
argument_list|)
throw|;
block|}
name|this
operator|.
name|nextWasCalled
operator|=
literal|false
expr_stmt|;
name|List
argument_list|<
name|HStoreFile
argument_list|>
name|src
init|=
name|components
operator|.
name|get
argument_list|(
name|currentComponent
argument_list|)
decl_stmt|;
if|if
condition|(
name|src
operator|instanceof
name|ImmutableList
argument_list|<
name|?
argument_list|>
condition|)
block|{
name|src
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|components
operator|.
name|set
argument_list|(
name|currentComponent
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
name|src
operator|.
name|remove
argument_list|(
name|indexWithinComponent
argument_list|)
expr_stmt|;
operator|--
name|size
expr_stmt|;
operator|--
name|indexWithinComponent
expr_stmt|;
if|if
condition|(
name|src
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|components
operator|.
name|remove
argument_list|(
name|currentComponent
argument_list|)
expr_stmt|;
comment|// indexWithinComponent is already -1 here.
block|}
block|}
block|}
block|}
comment|/**    * Non-static helper class for merging compaction or flush results.    * Since we want to merge them atomically (more or less), it operates on lazy copies,    * then creates a new state object and puts it in place.    */
specifier|private
class|class
name|CompactionOrFlushMergeCopy
block|{
specifier|private
name|ArrayList
argument_list|<
name|List
argument_list|<
name|HStoreFile
argument_list|>
argument_list|>
name|stripeFiles
init|=
literal|null
decl_stmt|;
specifier|private
name|ArrayList
argument_list|<
name|HStoreFile
argument_list|>
name|level0Files
init|=
literal|null
decl_stmt|;
specifier|private
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
name|stripeEndRows
init|=
literal|null
decl_stmt|;
specifier|private
name|Collection
argument_list|<
name|HStoreFile
argument_list|>
name|compactedFiles
init|=
literal|null
decl_stmt|;
specifier|private
name|Collection
argument_list|<
name|HStoreFile
argument_list|>
name|results
init|=
literal|null
decl_stmt|;
specifier|private
name|List
argument_list|<
name|HStoreFile
argument_list|>
name|l0Results
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|isFlush
decl_stmt|;
specifier|public
name|CompactionOrFlushMergeCopy
parameter_list|(
name|boolean
name|isFlush
parameter_list|)
block|{
comment|// Create a lazy mutable copy (other fields are so lazy they start out as nulls).
name|this
operator|.
name|stripeFiles
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|StripeStoreFileManager
operator|.
name|this
operator|.
name|state
operator|.
name|stripeFiles
argument_list|)
expr_stmt|;
name|this
operator|.
name|isFlush
operator|=
name|isFlush
expr_stmt|;
block|}
specifier|private
name|void
name|mergeResults
parameter_list|(
name|Collection
argument_list|<
name|HStoreFile
argument_list|>
name|compactedFiles
parameter_list|,
name|Collection
argument_list|<
name|HStoreFile
argument_list|>
name|results
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|this
operator|.
name|compactedFiles
operator|==
literal|null
operator|&&
name|this
operator|.
name|results
operator|==
literal|null
assert|;
name|this
operator|.
name|compactedFiles
operator|=
name|compactedFiles
expr_stmt|;
name|this
operator|.
name|results
operator|=
name|results
expr_stmt|;
comment|// Do logical processing.
if|if
condition|(
operator|!
name|isFlush
condition|)
name|removeCompactedFiles
argument_list|()
expr_stmt|;
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HStoreFile
argument_list|>
name|newStripes
init|=
name|processResults
argument_list|()
decl_stmt|;
if|if
condition|(
name|newStripes
operator|!=
literal|null
condition|)
block|{
name|processNewCandidateStripes
argument_list|(
name|newStripes
argument_list|)
expr_stmt|;
block|}
comment|// Create new state and update parent.
name|State
name|state
init|=
name|createNewState
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|StripeStoreFileManager
operator|.
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
name|updateMetadataMaps
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|deleteResults
parameter_list|(
name|Collection
argument_list|<
name|HStoreFile
argument_list|>
name|compactedFiles
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|compactedFiles
operator|=
name|compactedFiles
expr_stmt|;
comment|// Create new state and update parent.
name|State
name|state
init|=
name|createNewState
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|StripeStoreFileManager
operator|.
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
name|updateMetadataMaps
argument_list|()
expr_stmt|;
block|}
specifier|private
name|State
name|createNewState
parameter_list|(
name|boolean
name|delCompactedFiles
parameter_list|)
block|{
name|State
name|oldState
init|=
name|StripeStoreFileManager
operator|.
name|this
operator|.
name|state
decl_stmt|;
comment|// Stripe count should be the same unless the end rows changed.
assert|assert
name|oldState
operator|.
name|stripeFiles
operator|.
name|size
argument_list|()
operator|==
name|this
operator|.
name|stripeFiles
operator|.
name|size
argument_list|()
operator|||
name|this
operator|.
name|stripeEndRows
operator|!=
literal|null
assert|;
name|State
name|newState
init|=
operator|new
name|State
argument_list|()
decl_stmt|;
name|newState
operator|.
name|level0Files
operator|=
operator|(
name|this
operator|.
name|level0Files
operator|==
literal|null
operator|)
condition|?
name|oldState
operator|.
name|level0Files
else|:
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|this
operator|.
name|level0Files
argument_list|)
expr_stmt|;
name|newState
operator|.
name|stripeEndRows
operator|=
operator|(
name|this
operator|.
name|stripeEndRows
operator|==
literal|null
operator|)
condition|?
name|oldState
operator|.
name|stripeEndRows
else|:
name|this
operator|.
name|stripeEndRows
operator|.
name|toArray
argument_list|(
operator|new
name|byte
index|[
name|this
operator|.
name|stripeEndRows
operator|.
name|size
argument_list|()
index|]
index|[]
argument_list|)
expr_stmt|;
name|newState
operator|.
name|stripeFiles
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|this
operator|.
name|stripeFiles
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|List
argument_list|<
name|HStoreFile
argument_list|>
name|newStripe
range|:
name|this
operator|.
name|stripeFiles
control|)
block|{
name|newState
operator|.
name|stripeFiles
operator|.
name|add
argument_list|(
name|newStripe
operator|instanceof
name|ImmutableList
argument_list|<
name|?
argument_list|>
condition|?
operator|(
name|ImmutableList
argument_list|<
name|HStoreFile
argument_list|>
operator|)
name|newStripe
else|:
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|newStripe
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|HStoreFile
argument_list|>
name|newAllFiles
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|oldState
operator|.
name|allFilesCached
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|HStoreFile
argument_list|>
name|newAllCompactedFiles
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|oldState
operator|.
name|allCompactedFilesCached
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isFlush
condition|)
block|{
name|newAllFiles
operator|.
name|removeAll
argument_list|(
name|compactedFiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|delCompactedFiles
condition|)
block|{
name|newAllCompactedFiles
operator|.
name|removeAll
argument_list|(
name|compactedFiles
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newAllCompactedFiles
operator|.
name|addAll
argument_list|(
name|compactedFiles
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|results
operator|!=
literal|null
condition|)
block|{
name|newAllFiles
operator|.
name|addAll
argument_list|(
name|results
argument_list|)
expr_stmt|;
block|}
name|newState
operator|.
name|allFilesCached
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|newAllFiles
argument_list|)
expr_stmt|;
name|newState
operator|.
name|allCompactedFilesCached
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|newAllCompactedFiles
argument_list|)
expr_stmt|;
return|return
name|newState
return|;
block|}
specifier|private
name|void
name|updateMetadataMaps
parameter_list|()
block|{
name|StripeStoreFileManager
name|parent
init|=
name|StripeStoreFileManager
operator|.
name|this
decl_stmt|;
if|if
condition|(
operator|!
name|isFlush
condition|)
block|{
for|for
control|(
name|HStoreFile
name|sf
range|:
name|this
operator|.
name|compactedFiles
control|)
block|{
name|parent
operator|.
name|fileStarts
operator|.
name|remove
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|parent
operator|.
name|fileEnds
operator|.
name|remove
argument_list|(
name|sf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|this
operator|.
name|l0Results
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|HStoreFile
name|sf
range|:
name|this
operator|.
name|l0Results
control|)
block|{
name|parent
operator|.
name|ensureLevel0Metadata
argument_list|(
name|sf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * @param index Index of the stripe we need.      * @return A lazy stripe copy from current stripes.      */
specifier|private
specifier|final
name|ArrayList
argument_list|<
name|HStoreFile
argument_list|>
name|getStripeCopy
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|List
argument_list|<
name|HStoreFile
argument_list|>
name|stripeCopy
init|=
name|this
operator|.
name|stripeFiles
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|HStoreFile
argument_list|>
name|result
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|stripeCopy
operator|instanceof
name|ImmutableList
argument_list|<
name|?
argument_list|>
condition|)
block|{
name|result
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|stripeCopy
argument_list|)
expr_stmt|;
name|this
operator|.
name|stripeFiles
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
operator|(
name|ArrayList
argument_list|<
name|HStoreFile
argument_list|>
operator|)
name|stripeCopy
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**      * @return A lazy L0 copy from current state.      */
specifier|private
specifier|final
name|ArrayList
argument_list|<
name|HStoreFile
argument_list|>
name|getLevel0Copy
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|level0Files
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|level0Files
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|StripeStoreFileManager
operator|.
name|this
operator|.
name|state
operator|.
name|level0Files
argument_list|)
expr_stmt|;
block|}
return|return
name|this
operator|.
name|level0Files
return|;
block|}
comment|/**      * Process new files, and add them either to the structure of existing stripes,      * or to the list of new candidate stripes.      * @return New candidate stripes.      */
specifier|private
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HStoreFile
argument_list|>
name|processResults
parameter_list|()
throws|throws
name|IOException
block|{
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HStoreFile
argument_list|>
name|newStripes
init|=
literal|null
decl_stmt|;
for|for
control|(
name|HStoreFile
name|sf
range|:
name|this
operator|.
name|results
control|)
block|{
name|byte
index|[]
name|startRow
init|=
name|startOf
argument_list|(
name|sf
argument_list|)
decl_stmt|,
name|endRow
init|=
name|endOf
argument_list|(
name|sf
argument_list|)
decl_stmt|;
if|if
condition|(
name|isInvalid
argument_list|(
name|endRow
argument_list|)
operator|||
name|isInvalid
argument_list|(
name|startRow
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|isFlush
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The newly compacted file doesn't have stripes set: "
operator|+
name|sf
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|insertFileIntoStripe
argument_list|(
name|getLevel0Copy
argument_list|()
argument_list|,
name|sf
argument_list|)
expr_stmt|;
name|this
operator|.
name|l0Results
operator|.
name|add
argument_list|(
name|sf
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|this
operator|.
name|stripeFiles
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|stripeIndex
init|=
name|findStripeIndexByEndRow
argument_list|(
name|endRow
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|stripeIndex
operator|>=
literal|0
operator|)
operator|&&
name|rowEquals
argument_list|(
name|getStartRow
argument_list|(
name|stripeIndex
argument_list|)
argument_list|,
name|startRow
argument_list|)
condition|)
block|{
comment|// Simple/common case - add file to an existing stripe.
name|insertFileIntoStripe
argument_list|(
name|getStripeCopy
argument_list|(
name|stripeIndex
argument_list|)
argument_list|,
name|sf
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|// Make a new candidate stripe.
if|if
condition|(
name|newStripes
operator|==
literal|null
condition|)
block|{
name|newStripes
operator|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|MAP_COMPARATOR
argument_list|)
expr_stmt|;
block|}
name|HStoreFile
name|oldSf
init|=
name|newStripes
operator|.
name|put
argument_list|(
name|endRow
argument_list|,
name|sf
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldSf
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Compactor has produced multiple files for the stripe ending in ["
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|endRow
argument_list|)
operator|+
literal|"], found "
operator|+
name|sf
operator|.
name|getPath
argument_list|()
operator|+
literal|" and "
operator|+
name|oldSf
operator|.
name|getPath
argument_list|()
argument_list|)
throw|;
block|}
block|}
return|return
name|newStripes
return|;
block|}
comment|/**      * Remove compacted files.      * @param compactedFiles Compacted files.      */
specifier|private
name|void
name|removeCompactedFiles
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|HStoreFile
name|oldFile
range|:
name|this
operator|.
name|compactedFiles
control|)
block|{
name|byte
index|[]
name|oldEndRow
init|=
name|endOf
argument_list|(
name|oldFile
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|HStoreFile
argument_list|>
name|source
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isInvalid
argument_list|(
name|oldEndRow
argument_list|)
condition|)
block|{
name|source
operator|=
name|getLevel0Copy
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|stripeIndex
init|=
name|findStripeIndexByEndRow
argument_list|(
name|oldEndRow
argument_list|)
decl_stmt|;
if|if
condition|(
name|stripeIndex
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"An allegedly compacted file ["
operator|+
name|oldFile
operator|+
literal|"] does not belong"
operator|+
literal|" to a known stripe (end row - ["
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|oldEndRow
argument_list|)
operator|+
literal|"])"
argument_list|)
throw|;
block|}
name|source
operator|=
name|getStripeCopy
argument_list|(
name|stripeIndex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|source
operator|.
name|remove
argument_list|(
name|oldFile
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"An allegedly compacted file ["
operator|+
name|oldFile
operator|+
literal|"] was not found"
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * See {@link #addCompactionResults(Collection, Collection)} - updates the stripe list with      * new candidate stripes/removes old stripes; produces new set of stripe end rows.      * @param newStripes  New stripes - files by end row.      */
specifier|private
name|void
name|processNewCandidateStripes
parameter_list|(
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|HStoreFile
argument_list|>
name|newStripes
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Validate that the removed and added aggregate ranges still make for a full key space.
name|boolean
name|hasStripes
init|=
operator|!
name|this
operator|.
name|stripeFiles
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
name|this
operator|.
name|stripeEndRows
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|StripeStoreFileManager
operator|.
name|this
operator|.
name|state
operator|.
name|stripeEndRows
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|removeFrom
init|=
literal|0
decl_stmt|;
name|byte
index|[]
name|firstStartRow
init|=
name|startOf
argument_list|(
name|newStripes
operator|.
name|firstEntry
argument_list|()
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|byte
index|[]
name|lastEndRow
init|=
name|newStripes
operator|.
name|lastKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|hasStripes
operator|&&
operator|(
operator|!
name|isOpen
argument_list|(
name|firstStartRow
argument_list|)
operator|||
operator|!
name|isOpen
argument_list|(
name|lastEndRow
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Newly created stripes do not cover the entire key space."
argument_list|)
throw|;
block|}
name|boolean
name|canAddNewStripes
init|=
literal|true
decl_stmt|;
name|Collection
argument_list|<
name|HStoreFile
argument_list|>
name|filesForL0
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|hasStripes
condition|)
block|{
comment|// Determine which stripes will need to be removed because they conflict with new stripes.
comment|// The new boundaries should match old stripe boundaries, so we should get exact matches.
if|if
condition|(
name|isOpen
argument_list|(
name|firstStartRow
argument_list|)
condition|)
block|{
name|removeFrom
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|removeFrom
operator|=
name|findStripeIndexByEndRow
argument_list|(
name|firstStartRow
argument_list|)
expr_stmt|;
if|if
condition|(
name|removeFrom
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Compaction is trying to add a bad range."
argument_list|)
throw|;
operator|++
name|removeFrom
expr_stmt|;
block|}
name|int
name|removeTo
init|=
name|findStripeIndexByEndRow
argument_list|(
name|lastEndRow
argument_list|)
decl_stmt|;
if|if
condition|(
name|removeTo
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Compaction is trying to add a bad range."
argument_list|)
throw|;
comment|// See if there are files in the stripes we are trying to replace.
name|ArrayList
argument_list|<
name|HStoreFile
argument_list|>
name|conflictingFiles
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|removeIndex
init|=
name|removeTo
init|;
name|removeIndex
operator|>=
name|removeFrom
condition|;
operator|--
name|removeIndex
control|)
block|{
name|conflictingFiles
operator|.
name|addAll
argument_list|(
name|this
operator|.
name|stripeFiles
operator|.
name|get
argument_list|(
name|removeIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|conflictingFiles
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// This can be caused by two things - concurrent flush into stripes, or a bug.
comment|// Unfortunately, we cannot tell them apart without looking at timing or something
comment|// like that. We will assume we are dealing with a flush and dump it into L0.
if|if
condition|(
name|isFlush
condition|)
block|{
name|long
name|newSize
init|=
name|StripeCompactionPolicy
operator|.
name|getTotalFileSize
argument_list|(
name|newStripes
operator|.
name|values
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Stripes were created by a flush, but results of size "
operator|+
name|newSize
operator|+
literal|" cannot be added because the stripes have changed"
argument_list|)
expr_stmt|;
name|canAddNewStripes
operator|=
literal|false
expr_stmt|;
name|filesForL0
operator|=
name|newStripes
operator|.
name|values
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|long
name|oldSize
init|=
name|StripeCompactionPolicy
operator|.
name|getTotalFileSize
argument_list|(
name|conflictingFiles
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|conflictingFiles
operator|.
name|size
argument_list|()
operator|+
literal|" conflicting files (likely created by a flush) "
operator|+
literal|" of size "
operator|+
name|oldSize
operator|+
literal|" are moved to L0 due to concurrent stripe change"
argument_list|)
expr_stmt|;
name|filesForL0
operator|=
name|conflictingFiles
expr_stmt|;
block|}
if|if
condition|(
name|filesForL0
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|HStoreFile
name|sf
range|:
name|filesForL0
control|)
block|{
name|insertFileIntoStripe
argument_list|(
name|getLevel0Copy
argument_list|()
argument_list|,
name|sf
argument_list|)
expr_stmt|;
block|}
name|l0Results
operator|.
name|addAll
argument_list|(
name|filesForL0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|canAddNewStripes
condition|)
block|{
comment|// Remove old empty stripes.
name|int
name|originalCount
init|=
name|this
operator|.
name|stripeFiles
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|removeIndex
init|=
name|removeTo
init|;
name|removeIndex
operator|>=
name|removeFrom
condition|;
operator|--
name|removeIndex
control|)
block|{
if|if
condition|(
name|removeIndex
operator|!=
name|originalCount
operator|-
literal|1
condition|)
block|{
name|this
operator|.
name|stripeEndRows
operator|.
name|remove
argument_list|(
name|removeIndex
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|stripeFiles
operator|.
name|remove
argument_list|(
name|removeIndex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|canAddNewStripes
condition|)
return|return;
comment|// Files were already put into L0.
comment|// Now, insert new stripes. The total ranges match, so we can insert where we removed.
name|byte
index|[]
name|previousEndRow
init|=
literal|null
decl_stmt|;
name|int
name|insertAt
init|=
name|removeFrom
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|HStoreFile
argument_list|>
name|newStripe
range|:
name|newStripes
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|previousEndRow
operator|!=
literal|null
condition|)
block|{
comment|// Validate that the ranges are contiguous.
assert|assert
operator|!
name|isOpen
argument_list|(
name|previousEndRow
argument_list|)
assert|;
name|byte
index|[]
name|startRow
init|=
name|startOf
argument_list|(
name|newStripe
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rowEquals
argument_list|(
name|previousEndRow
argument_list|,
name|startRow
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The new stripes produced by "
operator|+
operator|(
name|isFlush
condition|?
literal|"flush"
else|:
literal|"compaction"
operator|)
operator|+
literal|" are not contiguous"
argument_list|)
throw|;
block|}
block|}
comment|// Add the new stripe.
name|ArrayList
argument_list|<
name|HStoreFile
argument_list|>
name|tmp
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|tmp
operator|.
name|add
argument_list|(
name|newStripe
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|stripeFiles
operator|.
name|add
argument_list|(
name|insertAt
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|previousEndRow
operator|=
name|newStripe
operator|.
name|getKey
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isOpen
argument_list|(
name|previousEndRow
argument_list|)
condition|)
block|{
name|stripeEndRows
operator|.
name|add
argument_list|(
name|insertAt
argument_list|,
name|previousEndRow
argument_list|)
expr_stmt|;
block|}
operator|++
name|insertAt
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|HStoreFile
argument_list|>
name|getLevel0Files
parameter_list|()
block|{
return|return
name|this
operator|.
name|state
operator|.
name|level0Files
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|getStripeBoundaries
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|state
operator|.
name|stripeFiles
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|this
operator|.
name|state
operator|.
name|stripeEndRows
operator|.
name|length
operator|+
literal|2
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|OPEN_KEY
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|result
argument_list|,
name|this
operator|.
name|state
operator|.
name|stripeEndRows
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
name|OPEN_KEY
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|ArrayList
argument_list|<
name|ImmutableList
argument_list|<
name|HStoreFile
argument_list|>
argument_list|>
name|getStripes
parameter_list|()
block|{
return|return
name|this
operator|.
name|state
operator|.
name|stripeFiles
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getStripeCount
parameter_list|()
block|{
return|return
name|this
operator|.
name|state
operator|.
name|stripeFiles
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|HStoreFile
argument_list|>
name|getUnneededFiles
parameter_list|(
name|long
name|maxTs
parameter_list|,
name|List
argument_list|<
name|HStoreFile
argument_list|>
name|filesCompacting
parameter_list|)
block|{
comment|// 1) We can never get rid of the last file which has the maximum seqid in a stripe.
comment|// 2) Files that are not the latest can't become one due to (1), so the rest are fair game.
name|State
name|state
init|=
name|this
operator|.
name|state
decl_stmt|;
name|Collection
argument_list|<
name|HStoreFile
argument_list|>
name|expiredStoreFiles
init|=
literal|null
decl_stmt|;
for|for
control|(
name|ImmutableList
argument_list|<
name|HStoreFile
argument_list|>
name|stripe
range|:
name|state
operator|.
name|stripeFiles
control|)
block|{
name|expiredStoreFiles
operator|=
name|findExpiredFiles
argument_list|(
name|stripe
argument_list|,
name|maxTs
argument_list|,
name|filesCompacting
argument_list|,
name|expiredStoreFiles
argument_list|)
expr_stmt|;
block|}
return|return
name|findExpiredFiles
argument_list|(
name|state
operator|.
name|level0Files
argument_list|,
name|maxTs
argument_list|,
name|filesCompacting
argument_list|,
name|expiredStoreFiles
argument_list|)
return|;
block|}
specifier|private
name|Collection
argument_list|<
name|HStoreFile
argument_list|>
name|findExpiredFiles
parameter_list|(
name|ImmutableList
argument_list|<
name|HStoreFile
argument_list|>
name|stripe
parameter_list|,
name|long
name|maxTs
parameter_list|,
name|List
argument_list|<
name|HStoreFile
argument_list|>
name|filesCompacting
parameter_list|,
name|Collection
argument_list|<
name|HStoreFile
argument_list|>
name|expiredStoreFiles
parameter_list|)
block|{
comment|// Order by seqnum is reversed.
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|stripe
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|HStoreFile
name|sf
init|=
name|stripe
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|sf
init|)
block|{
name|long
name|fileTs
init|=
name|sf
operator|.
name|getReader
argument_list|()
operator|.
name|getMaxTimestamp
argument_list|()
decl_stmt|;
if|if
condition|(
name|fileTs
operator|<
name|maxTs
operator|&&
operator|!
name|filesCompacting
operator|.
name|contains
argument_list|(
name|sf
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Found an expired store file: "
operator|+
name|sf
operator|.
name|getPath
argument_list|()
operator|+
literal|" whose maxTimestamp is "
operator|+
name|fileTs
operator|+
literal|", which is below "
operator|+
name|maxTs
argument_list|)
expr_stmt|;
if|if
condition|(
name|expiredStoreFiles
operator|==
literal|null
condition|)
block|{
name|expiredStoreFiles
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|expiredStoreFiles
operator|.
name|add
argument_list|(
name|sf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|expiredStoreFiles
return|;
block|}
annotation|@
name|Override
specifier|public
name|double
name|getCompactionPressure
parameter_list|()
block|{
name|State
name|stateLocal
init|=
name|this
operator|.
name|state
decl_stmt|;
if|if
condition|(
name|stateLocal
operator|.
name|allFilesCached
operator|.
name|size
argument_list|()
operator|>
name|blockingFileCount
condition|)
block|{
comment|// just a hit to tell others that we have reached the blocking file count.
return|return
literal|2.0
return|;
block|}
if|if
condition|(
name|stateLocal
operator|.
name|stripeFiles
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|0.0
return|;
block|}
name|int
name|blockingFilePerStripe
init|=
name|blockingFileCount
operator|/
name|stateLocal
operator|.
name|stripeFiles
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// do not calculate L0 separately because data will be moved to stripe quickly and in most cases
comment|// we flush data to stripe directly.
name|int
name|delta
init|=
name|stateLocal
operator|.
name|level0Files
operator|.
name|isEmpty
argument_list|()
condition|?
literal|0
else|:
literal|1
decl_stmt|;
name|double
name|max
init|=
literal|0.0
decl_stmt|;
for|for
control|(
name|ImmutableList
argument_list|<
name|HStoreFile
argument_list|>
name|stripeFile
range|:
name|stateLocal
operator|.
name|stripeFiles
control|)
block|{
name|int
name|stripeFileCount
init|=
name|stripeFile
operator|.
name|size
argument_list|()
decl_stmt|;
name|double
name|normCount
init|=
call|(
name|double
call|)
argument_list|(
name|stripeFileCount
operator|+
name|delta
operator|-
name|config
operator|.
name|getStripeCompactMinFiles
argument_list|()
argument_list|)
operator|/
operator|(
name|blockingFilePerStripe
operator|-
name|config
operator|.
name|getStripeCompactMinFiles
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|normCount
operator|>=
literal|1.0
condition|)
block|{
comment|// This could happen if stripe is not split evenly. Do not return values that larger than
comment|// 1.0 because we have not reached the blocking file count actually.
return|return
literal|1.0
return|;
block|}
if|if
condition|(
name|normCount
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|normCount
expr_stmt|;
block|}
block|}
return|return
name|max
return|;
block|}
annotation|@
name|Override
specifier|public
name|Comparator
argument_list|<
name|HStoreFile
argument_list|>
name|getStoreFileComparator
parameter_list|()
block|{
return|return
name|StoreFileComparators
operator|.
name|SEQ_ID
return|;
block|}
block|}
end_class

end_unit

