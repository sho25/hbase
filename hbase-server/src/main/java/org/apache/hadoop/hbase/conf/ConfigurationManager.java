begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|conf
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|WeakHashMap
import|;
end_import

begin_comment
comment|/**  * Maintains the set of all the classes which would like to get notified  * when the Configuration is reloaded from the disk in the Online Configuration  * Change mechanism, which lets you update certain configuration properties  * on-the-fly, without having to restart the cluster.  *  * If a class has configuration properties which you would like to be able to  * change on-the-fly, do the following:  * 1. Implement the {@link ConfigurationObserver} interface. This would require  *    you to implement the  *    {@link ConfigurationObserver#onConfigurationChange(Configuration)}  *    method.  This is a callback that is used to notify your class' instance  *    that the configuration has changed. In this method, you need to check  *    if the new values for the properties that are of interest to your class  *    are different from the cached values. If yes, update them.  *  *    However, be careful with this. Certain properties might be trivially  *    mutable online, but others might not. Two properties might be trivially  *    mutable by themselves, but not when changed together. For example, if a  *    method uses properties "a" and "b" to make some decision, and is running  *    in parallel when the notifyOnChange() method updates "a", but hasn't  *    yet updated "b", it might make a decision on the basis of a new value of  *    "a", and an old value of "b". This might introduce subtle bugs. This  *    needs to be dealt on a case-by-case basis, and this class does not provide  *    any protection from such cases.  *  * 2. Register the appropriate instance of the class with the  *    {@link ConfigurationManager} instance, using the  *    {@link ConfigurationManager#registerObserver(ConfigurationObserver)}  *    method. For the RS side of things, the ConfigurationManager is a static  *    member of the {@link org.apache.hadoop.hbase.regionserver.HRegionServer}  *    class. Be careful not to do this in the constructor, as you might cause  *    the 'this' reference to escape. Use a factory method, or an initialize()  *    method which is called after the construction of the object.  *  * 3. Deregister the instance using the  *    {@link ConfigurationManager#deregisterObserver(ConfigurationObserver)}  *    method when it is going out of scope. In case you are not able to do that  *    for any reason, it is still okay, since entries for dead observers are  *    automatically collected during GC. But nonetheless, it is still a good  *    practice to deregister your observer, whenever possible.  *  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
class|class
name|ConfigurationManager
block|{
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ConfigurationManager
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// The set of Configuration Observers. These classes would like to get
comment|// notified when the configuration is reloaded from disk. This is a set
comment|// constructed from a WeakHashMap, whose entries would be removed if the
comment|// observer classes go out of scope.
specifier|private
name|Set
argument_list|<
name|ConfigurationObserver
argument_list|>
name|configurationObservers
init|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|WeakHashMap
argument_list|<
name|ConfigurationObserver
argument_list|,
name|Boolean
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Register an observer class    * @param observer    */
specifier|public
name|void
name|registerObserver
parameter_list|(
name|ConfigurationObserver
name|observer
parameter_list|)
block|{
synchronized|synchronized
init|(
name|configurationObservers
init|)
block|{
name|configurationObservers
operator|.
name|add
argument_list|(
name|observer
argument_list|)
expr_stmt|;
if|if
condition|(
name|observer
operator|instanceof
name|PropagatingConfigurationObserver
condition|)
block|{
operator|(
operator|(
name|PropagatingConfigurationObserver
operator|)
name|observer
operator|)
operator|.
name|registerChildren
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Deregister an observer class    * @param observer    */
specifier|public
name|void
name|deregisterObserver
parameter_list|(
name|ConfigurationObserver
name|observer
parameter_list|)
block|{
synchronized|synchronized
init|(
name|configurationObservers
init|)
block|{
name|configurationObservers
operator|.
name|remove
argument_list|(
name|observer
argument_list|)
expr_stmt|;
if|if
condition|(
name|observer
operator|instanceof
name|PropagatingConfigurationObserver
condition|)
block|{
operator|(
operator|(
name|PropagatingConfigurationObserver
operator|)
name|observer
operator|)
operator|.
name|deregisterChildren
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * The conf object has been repopulated from disk, and we have to notify    * all the observers that are expressed interest to do that.    */
specifier|public
name|void
name|notifyAllObservers
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
synchronized|synchronized
init|(
name|configurationObservers
init|)
block|{
for|for
control|(
name|ConfigurationObserver
name|observer
range|:
name|configurationObservers
control|)
block|{
try|try
block|{
if|if
condition|(
name|observer
operator|!=
literal|null
condition|)
block|{
name|observer
operator|.
name|onConfigurationChange
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Encountered a throwable while notifying observers: "
operator|+
literal|" of type : "
operator|+
name|observer
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"("
operator|+
name|observer
operator|+
literal|")"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * @return the number of observers.     */
specifier|public
name|int
name|getNumObservers
parameter_list|()
block|{
synchronized|synchronized
init|(
name|configurationObservers
init|)
block|{
return|return
name|configurationObservers
operator|.
name|size
argument_list|()
return|;
block|}
block|}
block|}
end_class

end_unit

