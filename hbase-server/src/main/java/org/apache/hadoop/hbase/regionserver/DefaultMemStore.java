begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|ManagementFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|RuntimeMXBean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Cell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValueUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Scan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|TimeRange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ByteRange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ClassSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|CollectionBackedScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|Trace
import|;
end_import

begin_comment
comment|/**  * The MemStore holds in-memory modifications to the Store.  Modifications  * are {@link Cell}s.  When asked to flush, current memstore is moved  * to snapshot and is cleared.  We continue to serve edits out of new memstore  * and backing snapshot until flusher reports in that the flush succeeded. At  * this point we let the snapshot go.  *<p>  * The MemStore functions should not be called in parallel. Callers should hold  *  write and read locks. This is done in {@link HStore}.  *</p>  *  * TODO: Adjust size of the memstore when we remove items because they have  * been deleted.  * TODO: With new KVSLS, need to make sure we update HeapSize with difference  * in KV size.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|DefaultMemStore
implements|implements
name|MemStore
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|DefaultMemStore
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|static
specifier|final
name|String
name|USEMSLAB_KEY
init|=
literal|"hbase.hregion.memstore.mslab.enabled"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|boolean
name|USEMSLAB_DEFAULT
init|=
literal|true
decl_stmt|;
specifier|static
specifier|final
name|String
name|MSLAB_CLASS_NAME
init|=
literal|"hbase.regionserver.mslab.class"
decl_stmt|;
specifier|private
name|Configuration
name|conf
decl_stmt|;
comment|// MemStore.  Use a CellSkipListSet rather than SkipListSet because of the
comment|// better semantics.  The Map will overwrite if passed a key it already had
comment|// whereas the Set will not add new Cell if key is same though value might be
comment|// different.  Value is not important -- just make sure always same
comment|// reference passed.
specifier|volatile
name|CellSkipListSet
name|cellSet
decl_stmt|;
comment|// Snapshot of memstore.  Made for flusher.
specifier|volatile
name|CellSkipListSet
name|snapshot
decl_stmt|;
specifier|final
name|CellComparator
name|comparator
decl_stmt|;
comment|// Used to track own heapSize
specifier|final
name|AtomicLong
name|size
decl_stmt|;
specifier|private
specifier|volatile
name|long
name|snapshotSize
decl_stmt|;
comment|// Used to track when to flush
specifier|volatile
name|long
name|timeOfOldestEdit
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
name|TimeRangeTracker
name|timeRangeTracker
decl_stmt|;
name|TimeRangeTracker
name|snapshotTimeRangeTracker
decl_stmt|;
specifier|volatile
name|MemStoreLAB
name|allocator
decl_stmt|;
specifier|volatile
name|MemStoreLAB
name|snapshotAllocator
decl_stmt|;
specifier|volatile
name|long
name|snapshotId
decl_stmt|;
specifier|volatile
name|boolean
name|tagsPresent
decl_stmt|;
comment|/**    * Default constructor. Used for tests.    */
specifier|public
name|DefaultMemStore
parameter_list|()
block|{
name|this
argument_list|(
name|HBaseConfiguration
operator|.
name|create
argument_list|()
argument_list|,
name|CellComparator
operator|.
name|COMPARATOR
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructor.    * @param c Comparator    */
specifier|public
name|DefaultMemStore
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|CellComparator
name|c
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|comparator
operator|=
name|c
expr_stmt|;
name|this
operator|.
name|cellSet
operator|=
operator|new
name|CellSkipListSet
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|this
operator|.
name|snapshot
operator|=
operator|new
name|CellSkipListSet
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|timeRangeTracker
operator|=
operator|new
name|TimeRangeTracker
argument_list|()
expr_stmt|;
name|snapshotTimeRangeTracker
operator|=
operator|new
name|TimeRangeTracker
argument_list|()
expr_stmt|;
name|this
operator|.
name|size
operator|=
operator|new
name|AtomicLong
argument_list|(
name|DEEP_OVERHEAD
argument_list|)
expr_stmt|;
name|this
operator|.
name|snapshotSize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|USEMSLAB_KEY
argument_list|,
name|USEMSLAB_DEFAULT
argument_list|)
condition|)
block|{
name|String
name|className
init|=
name|conf
operator|.
name|get
argument_list|(
name|MSLAB_CLASS_NAME
argument_list|,
name|HeapMemStoreLAB
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|this
operator|.
name|allocator
operator|=
name|ReflectionUtils
operator|.
name|instantiateWithCustomCtor
argument_list|(
name|className
argument_list|,
operator|new
name|Class
index|[]
block|{
name|Configuration
operator|.
name|class
block|}
argument_list|,
operator|new
name|Object
index|[]
block|{
name|conf
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|allocator
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|void
name|dump
parameter_list|()
block|{
for|for
control|(
name|Cell
name|cell
range|:
name|this
operator|.
name|cellSet
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|cell
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Cell
name|cell
range|:
name|this
operator|.
name|snapshot
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|cell
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Creates a snapshot of the current memstore.    * Snapshot must be cleared by call to {@link #clearSnapshot(long)}    */
annotation|@
name|Override
specifier|public
name|MemStoreSnapshot
name|snapshot
parameter_list|()
block|{
comment|// If snapshot currently has entries, then flusher failed or didn't call
comment|// cleanup.  Log a warning.
if|if
condition|(
operator|!
name|this
operator|.
name|snapshot
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Snapshot called again without clearing previous. "
operator|+
literal|"Doing nothing. Another ongoing flush or did we fail last attempt?"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|snapshotId
operator|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
expr_stmt|;
name|this
operator|.
name|snapshotSize
operator|=
name|keySize
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|this
operator|.
name|cellSet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|this
operator|.
name|snapshot
operator|=
name|this
operator|.
name|cellSet
expr_stmt|;
name|this
operator|.
name|cellSet
operator|=
operator|new
name|CellSkipListSet
argument_list|(
name|this
operator|.
name|comparator
argument_list|)
expr_stmt|;
name|this
operator|.
name|snapshotTimeRangeTracker
operator|=
name|this
operator|.
name|timeRangeTracker
expr_stmt|;
name|this
operator|.
name|timeRangeTracker
operator|=
operator|new
name|TimeRangeTracker
argument_list|()
expr_stmt|;
comment|// Reset heap to not include any keys
name|this
operator|.
name|size
operator|.
name|set
argument_list|(
name|DEEP_OVERHEAD
argument_list|)
expr_stmt|;
name|this
operator|.
name|snapshotAllocator
operator|=
name|this
operator|.
name|allocator
expr_stmt|;
comment|// Reset allocator so we get a fresh buffer for the new memstore
if|if
condition|(
name|allocator
operator|!=
literal|null
condition|)
block|{
name|String
name|className
init|=
name|conf
operator|.
name|get
argument_list|(
name|MSLAB_CLASS_NAME
argument_list|,
name|HeapMemStoreLAB
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|this
operator|.
name|allocator
operator|=
name|ReflectionUtils
operator|.
name|instantiateWithCustomCtor
argument_list|(
name|className
argument_list|,
operator|new
name|Class
index|[]
block|{
name|Configuration
operator|.
name|class
block|}
argument_list|,
operator|new
name|Object
index|[]
block|{
name|conf
block|}
argument_list|)
expr_stmt|;
block|}
name|timeOfOldestEdit
operator|=
name|Long
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
block|}
name|MemStoreSnapshot
name|memStoreSnapshot
init|=
operator|new
name|MemStoreSnapshot
argument_list|(
name|this
operator|.
name|snapshotId
argument_list|,
name|snapshot
operator|.
name|size
argument_list|()
argument_list|,
name|this
operator|.
name|snapshotSize
argument_list|,
name|this
operator|.
name|snapshotTimeRangeTracker
argument_list|,
operator|new
name|CollectionBackedScanner
argument_list|(
name|snapshot
argument_list|,
name|this
operator|.
name|comparator
argument_list|)
argument_list|,
name|this
operator|.
name|tagsPresent
argument_list|)
decl_stmt|;
name|this
operator|.
name|tagsPresent
operator|=
literal|false
expr_stmt|;
return|return
name|memStoreSnapshot
return|;
block|}
comment|/**    * The passed snapshot was successfully persisted; it can be let go.    * @param id Id of the snapshot to clean out.    * @throws UnexpectedStateException    * @see #snapshot()    */
annotation|@
name|Override
specifier|public
name|void
name|clearSnapshot
parameter_list|(
name|long
name|id
parameter_list|)
throws|throws
name|UnexpectedStateException
block|{
name|MemStoreLAB
name|tmpAllocator
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|snapshotId
operator|!=
name|id
condition|)
block|{
throw|throw
operator|new
name|UnexpectedStateException
argument_list|(
literal|"Current snapshot id is "
operator|+
name|this
operator|.
name|snapshotId
operator|+
literal|",passed "
operator|+
name|id
argument_list|)
throw|;
block|}
comment|// OK. Passed in snapshot is same as current snapshot. If not-empty,
comment|// create a new snapshot and let the old one go.
if|if
condition|(
operator|!
name|this
operator|.
name|snapshot
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|this
operator|.
name|snapshot
operator|=
operator|new
name|CellSkipListSet
argument_list|(
name|this
operator|.
name|comparator
argument_list|)
expr_stmt|;
name|this
operator|.
name|snapshotTimeRangeTracker
operator|=
operator|new
name|TimeRangeTracker
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|snapshotSize
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|snapshotId
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|snapshotAllocator
operator|!=
literal|null
condition|)
block|{
name|tmpAllocator
operator|=
name|this
operator|.
name|snapshotAllocator
expr_stmt|;
name|this
operator|.
name|snapshotAllocator
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|tmpAllocator
operator|!=
literal|null
condition|)
block|{
name|tmpAllocator
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|long
name|getFlushableSize
parameter_list|()
block|{
return|return
name|this
operator|.
name|snapshotSize
operator|>
literal|0
condition|?
name|this
operator|.
name|snapshotSize
else|:
name|keySize
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getSnapshotSize
parameter_list|()
block|{
return|return
name|this
operator|.
name|snapshotSize
return|;
block|}
comment|/**    * Write an update    * @param cell    * @return approximate size of the passed Cell.    */
annotation|@
name|Override
specifier|public
name|long
name|add
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
name|Cell
name|toAdd
init|=
name|maybeCloneWithAllocator
argument_list|(
name|cell
argument_list|)
decl_stmt|;
return|return
name|internalAdd
argument_list|(
name|toAdd
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|timeOfOldestEdit
parameter_list|()
block|{
return|return
name|timeOfOldestEdit
return|;
block|}
specifier|private
name|boolean
name|addToCellSet
parameter_list|(
name|Cell
name|e
parameter_list|)
block|{
name|boolean
name|b
init|=
name|this
operator|.
name|cellSet
operator|.
name|add
argument_list|(
name|e
argument_list|)
decl_stmt|;
comment|// In no tags case this NoTagsKeyValue.getTagsLength() is a cheap call.
comment|// When we use ACL CP or Visibility CP which deals with Tags during
comment|// mutation, the TagRewriteCell.getTagsLength() is a cheaper call. We do not
comment|// parse the byte[] to identify the tags length.
if|if
condition|(
operator|!
name|tagsPresent
operator|&&
operator|(
name|e
operator|.
name|getTagsLength
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
name|tagsPresent
operator|=
literal|true
expr_stmt|;
block|}
name|setOldestEditTimeToNow
argument_list|()
expr_stmt|;
return|return
name|b
return|;
block|}
specifier|private
name|boolean
name|removeFromCellSet
parameter_list|(
name|Cell
name|e
parameter_list|)
block|{
name|boolean
name|b
init|=
name|this
operator|.
name|cellSet
operator|.
name|remove
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|setOldestEditTimeToNow
argument_list|()
expr_stmt|;
return|return
name|b
return|;
block|}
name|void
name|setOldestEditTimeToNow
parameter_list|()
block|{
if|if
condition|(
name|timeOfOldestEdit
operator|==
name|Long
operator|.
name|MAX_VALUE
condition|)
block|{
name|timeOfOldestEdit
operator|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Internal version of add() that doesn't clone Cells with the    * allocator, and doesn't take the lock.    *    * Callers should ensure they already have the read lock taken    */
specifier|private
name|long
name|internalAdd
parameter_list|(
specifier|final
name|Cell
name|toAdd
parameter_list|)
block|{
name|long
name|s
init|=
name|heapSizeChange
argument_list|(
name|toAdd
argument_list|,
name|addToCellSet
argument_list|(
name|toAdd
argument_list|)
argument_list|)
decl_stmt|;
name|timeRangeTracker
operator|.
name|includeTimestamp
argument_list|(
name|toAdd
argument_list|)
expr_stmt|;
name|this
operator|.
name|size
operator|.
name|addAndGet
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
specifier|private
name|Cell
name|maybeCloneWithAllocator
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
if|if
condition|(
name|allocator
operator|==
literal|null
condition|)
block|{
return|return
name|cell
return|;
block|}
name|int
name|len
init|=
name|KeyValueUtil
operator|.
name|length
argument_list|(
name|cell
argument_list|)
decl_stmt|;
name|ByteRange
name|alloc
init|=
name|allocator
operator|.
name|allocateBytes
argument_list|(
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|alloc
operator|==
literal|null
condition|)
block|{
comment|// The allocation was too large, allocator decided
comment|// not to do anything with it.
return|return
name|cell
return|;
block|}
assert|assert
name|alloc
operator|.
name|getBytes
argument_list|()
operator|!=
literal|null
assert|;
name|KeyValueUtil
operator|.
name|appendToByteArray
argument_list|(
name|cell
argument_list|,
name|alloc
operator|.
name|getBytes
argument_list|()
argument_list|,
name|alloc
operator|.
name|getOffset
argument_list|()
argument_list|)
expr_stmt|;
name|KeyValue
name|newKv
init|=
operator|new
name|KeyValue
argument_list|(
name|alloc
operator|.
name|getBytes
argument_list|()
argument_list|,
name|alloc
operator|.
name|getOffset
argument_list|()
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|newKv
operator|.
name|setSequenceId
argument_list|(
name|cell
operator|.
name|getSequenceId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|newKv
return|;
block|}
comment|/**    * Remove n key from the memstore. Only cells that have the same key and the    * same memstoreTS are removed.  It is ok to not update timeRangeTracker    * in this call. It is possible that we can optimize this method by using    * tailMap/iterator, but since this method is called rarely (only for    * error recovery), we can leave those optimization for the future.    * @param cell    */
annotation|@
name|Override
specifier|public
name|void
name|rollback
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
comment|// If the key is in the snapshot, delete it. We should not update
comment|// this.size, because that tracks the size of only the memstore and
comment|// not the snapshot. The flush of this snapshot to disk has not
comment|// yet started because Store.flush() waits for all rwcc transactions to
comment|// commit before starting the flush to disk.
name|Cell
name|found
init|=
name|this
operator|.
name|snapshot
operator|.
name|get
argument_list|(
name|cell
argument_list|)
decl_stmt|;
if|if
condition|(
name|found
operator|!=
literal|null
operator|&&
name|found
operator|.
name|getSequenceId
argument_list|()
operator|==
name|cell
operator|.
name|getSequenceId
argument_list|()
condition|)
block|{
name|this
operator|.
name|snapshot
operator|.
name|remove
argument_list|(
name|cell
argument_list|)
expr_stmt|;
name|long
name|sz
init|=
name|heapSizeChange
argument_list|(
name|cell
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|this
operator|.
name|snapshotSize
operator|-=
name|sz
expr_stmt|;
block|}
comment|// If the key is in the memstore, delete it. Update this.size.
name|found
operator|=
name|this
operator|.
name|cellSet
operator|.
name|get
argument_list|(
name|cell
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|!=
literal|null
operator|&&
name|found
operator|.
name|getSequenceId
argument_list|()
operator|==
name|cell
operator|.
name|getSequenceId
argument_list|()
condition|)
block|{
name|removeFromCellSet
argument_list|(
name|cell
argument_list|)
expr_stmt|;
name|long
name|s
init|=
name|heapSizeChange
argument_list|(
name|cell
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|this
operator|.
name|size
operator|.
name|addAndGet
argument_list|(
operator|-
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Write a delete    * @param deleteCell    * @return approximate size of the passed key and value.    */
annotation|@
name|Override
specifier|public
name|long
name|delete
parameter_list|(
name|Cell
name|deleteCell
parameter_list|)
block|{
name|long
name|s
init|=
literal|0
decl_stmt|;
name|Cell
name|toAdd
init|=
name|maybeCloneWithAllocator
argument_list|(
name|deleteCell
argument_list|)
decl_stmt|;
name|s
operator|+=
name|heapSizeChange
argument_list|(
name|toAdd
argument_list|,
name|addToCellSet
argument_list|(
name|toAdd
argument_list|)
argument_list|)
expr_stmt|;
name|timeRangeTracker
operator|.
name|includeTimestamp
argument_list|(
name|toAdd
argument_list|)
expr_stmt|;
name|this
operator|.
name|size
operator|.
name|addAndGet
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
comment|/**    * @param cell Find the row that comes after this one.  If null, we return the    * first.    * @return Next row or null if none found.    */
name|Cell
name|getNextRow
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|)
block|{
return|return
name|getLowest
argument_list|(
name|getNextRow
argument_list|(
name|cell
argument_list|,
name|this
operator|.
name|cellSet
argument_list|)
argument_list|,
name|getNextRow
argument_list|(
name|cell
argument_list|,
name|this
operator|.
name|snapshot
argument_list|)
argument_list|)
return|;
block|}
comment|/*    * @param a    * @param b    * @return Return lowest of a or b or null if both a and b are null    */
specifier|private
name|Cell
name|getLowest
parameter_list|(
specifier|final
name|Cell
name|a
parameter_list|,
specifier|final
name|Cell
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|==
literal|null
condition|)
block|{
return|return
name|b
return|;
block|}
if|if
condition|(
name|b
operator|==
literal|null
condition|)
block|{
return|return
name|a
return|;
block|}
return|return
name|comparator
operator|.
name|compareRows
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|<=
literal|0
condition|?
name|a
else|:
name|b
return|;
block|}
comment|/*    * @param key Find row that follows this one.  If null, return first.    * @param map Set to look in for a row beyond<code>row</code>.    * @return Next row or null if none found.  If one found, will be a new    * KeyValue -- can be destroyed by subsequent calls to this method.    */
specifier|private
name|Cell
name|getNextRow
parameter_list|(
specifier|final
name|Cell
name|key
parameter_list|,
specifier|final
name|NavigableSet
argument_list|<
name|Cell
argument_list|>
name|set
parameter_list|)
block|{
name|Cell
name|result
init|=
literal|null
decl_stmt|;
name|SortedSet
argument_list|<
name|Cell
argument_list|>
name|tail
init|=
name|key
operator|==
literal|null
condition|?
name|set
else|:
name|set
operator|.
name|tailSet
argument_list|(
name|key
argument_list|)
decl_stmt|;
comment|// Iterate until we fall into the next row; i.e. move off current row
for|for
control|(
name|Cell
name|cell
range|:
name|tail
control|)
block|{
if|if
condition|(
name|comparator
operator|.
name|compareRows
argument_list|(
name|cell
argument_list|,
name|key
argument_list|)
operator|<=
literal|0
condition|)
continue|continue;
comment|// Note: Not suppressing deletes or expired cells.  Needs to be handled
comment|// by higher up functions.
name|result
operator|=
name|cell
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Only used by tests. TODO: Remove    *    * Given the specs of a column, update it, first by inserting a new record,    * then removing the old one.  Since there is only 1 KeyValue involved, the memstoreTS    * will be set to 0, thus ensuring that they instantly appear to anyone. The underlying    * store will ensure that the insert/delete each are atomic. A scanner/reader will either    * get the new value, or the old value and all readers will eventually only see the new    * value after the old was removed.    *    * @param row    * @param family    * @param qualifier    * @param newValue    * @param now    * @return  Timestamp    */
annotation|@
name|Override
specifier|public
name|long
name|updateColumnValue
parameter_list|(
name|byte
index|[]
name|row
parameter_list|,
name|byte
index|[]
name|family
parameter_list|,
name|byte
index|[]
name|qualifier
parameter_list|,
name|long
name|newValue
parameter_list|,
name|long
name|now
parameter_list|)
block|{
name|Cell
name|firstCell
init|=
name|KeyValueUtil
operator|.
name|createFirstOnRow
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|)
decl_stmt|;
comment|// Is there a Cell in 'snapshot' with the same TS? If so, upgrade the timestamp a bit.
name|SortedSet
argument_list|<
name|Cell
argument_list|>
name|snSs
init|=
name|snapshot
operator|.
name|tailSet
argument_list|(
name|firstCell
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|snSs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Cell
name|snc
init|=
name|snSs
operator|.
name|first
argument_list|()
decl_stmt|;
comment|// is there a matching Cell in the snapshot?
if|if
condition|(
name|CellUtil
operator|.
name|matchingRow
argument_list|(
name|snc
argument_list|,
name|firstCell
argument_list|)
operator|&&
name|CellUtil
operator|.
name|matchingQualifier
argument_list|(
name|snc
argument_list|,
name|firstCell
argument_list|)
condition|)
block|{
if|if
condition|(
name|snc
operator|.
name|getTimestamp
argument_list|()
operator|==
name|now
condition|)
block|{
comment|// poop,
name|now
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|// logic here: the new ts MUST be at least 'now'. But it could be larger if necessary.
comment|// But the timestamp should also be max(now, mostRecentTsInMemstore)
comment|// so we cant add the new Cell w/o knowing what's there already, but we also
comment|// want to take this chance to delete some cells. So two loops (sad)
name|SortedSet
argument_list|<
name|Cell
argument_list|>
name|ss
init|=
name|cellSet
operator|.
name|tailSet
argument_list|(
name|firstCell
argument_list|)
decl_stmt|;
for|for
control|(
name|Cell
name|cell
range|:
name|ss
control|)
block|{
comment|// if this isnt the row we are interested in, then bail:
if|if
condition|(
operator|!
name|CellUtil
operator|.
name|matchingColumn
argument_list|(
name|cell
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|)
operator|||
operator|!
name|CellUtil
operator|.
name|matchingRow
argument_list|(
name|cell
argument_list|,
name|firstCell
argument_list|)
condition|)
block|{
break|break;
comment|// rows dont match, bail.
block|}
comment|// if the qualifier matches and it's a put, just RM it out of the cellSet.
if|if
condition|(
name|cell
operator|.
name|getTypeByte
argument_list|()
operator|==
name|KeyValue
operator|.
name|Type
operator|.
name|Put
operator|.
name|getCode
argument_list|()
operator|&&
name|cell
operator|.
name|getTimestamp
argument_list|()
operator|>
name|now
operator|&&
name|CellUtil
operator|.
name|matchingQualifier
argument_list|(
name|firstCell
argument_list|,
name|cell
argument_list|)
condition|)
block|{
name|now
operator|=
name|cell
operator|.
name|getTimestamp
argument_list|()
expr_stmt|;
block|}
block|}
comment|// create or update (upsert) a new Cell with
comment|// 'now' and a 0 memstoreTS == immediately visible
name|List
argument_list|<
name|Cell
argument_list|>
name|cells
init|=
operator|new
name|ArrayList
argument_list|<
name|Cell
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|cells
operator|.
name|add
argument_list|(
operator|new
name|KeyValue
argument_list|(
name|row
argument_list|,
name|family
argument_list|,
name|qualifier
argument_list|,
name|now
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|newValue
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|upsert
argument_list|(
name|cells
argument_list|,
literal|1L
argument_list|)
return|;
block|}
comment|/**    * Update or insert the specified KeyValues.    *<p>    * For each KeyValue, insert into MemStore.  This will atomically upsert the    * value for that row/family/qualifier.  If a KeyValue did already exist,    * it will then be removed.    *<p>    * Currently the memstoreTS is kept at 0 so as each insert happens, it will    * be immediately visible.  May want to change this so it is atomic across    * all KeyValues.    *<p>    * This is called under row lock, so Get operations will still see updates    * atomically.  Scans will only see each KeyValue update as atomic.    *    * @param cells    * @param readpoint readpoint below which we can safely remove duplicate KVs    * @return change in memstore size    */
annotation|@
name|Override
specifier|public
name|long
name|upsert
parameter_list|(
name|Iterable
argument_list|<
name|Cell
argument_list|>
name|cells
parameter_list|,
name|long
name|readpoint
parameter_list|)
block|{
name|long
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Cell
name|cell
range|:
name|cells
control|)
block|{
name|size
operator|+=
name|upsert
argument_list|(
name|cell
argument_list|,
name|readpoint
argument_list|)
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
comment|/**    * Inserts the specified KeyValue into MemStore and deletes any existing    * versions of the same row/family/qualifier as the specified KeyValue.    *<p>    * First, the specified KeyValue is inserted into the Memstore.    *<p>    * If there are any existing KeyValues in this MemStore with the same row,    * family, and qualifier, they are removed.    *<p>    * Callers must hold the read lock.    *    * @param cell    * @return change in size of MemStore    */
specifier|private
name|long
name|upsert
parameter_list|(
name|Cell
name|cell
parameter_list|,
name|long
name|readpoint
parameter_list|)
block|{
comment|// Add the Cell to the MemStore
comment|// Use the internalAdd method here since we (a) already have a lock
comment|// and (b) cannot safely use the MSLAB here without potentially
comment|// hitting OOME - see TestMemStore.testUpsertMSLAB for a
comment|// test that triggers the pathological case if we don't avoid MSLAB
comment|// here.
name|long
name|addedSize
init|=
name|internalAdd
argument_list|(
name|cell
argument_list|)
decl_stmt|;
comment|// Get the Cells for the row/family/qualifier regardless of timestamp.
comment|// For this case we want to clean up any other puts
name|Cell
name|firstCell
init|=
name|KeyValueUtil
operator|.
name|createFirstOnRow
argument_list|(
name|cell
operator|.
name|getRowArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getRowOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getRowLength
argument_list|()
argument_list|,
name|cell
operator|.
name|getFamilyArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getFamilyOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getFamilyLength
argument_list|()
argument_list|,
name|cell
operator|.
name|getQualifierArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getQualifierOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getQualifierLength
argument_list|()
argument_list|)
decl_stmt|;
name|SortedSet
argument_list|<
name|Cell
argument_list|>
name|ss
init|=
name|cellSet
operator|.
name|tailSet
argument_list|(
name|firstCell
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|Cell
argument_list|>
name|it
init|=
name|ss
operator|.
name|iterator
argument_list|()
decl_stmt|;
comment|// versions visible to oldest scanner
name|int
name|versionsVisible
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Cell
name|cur
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|cell
operator|==
name|cur
condition|)
block|{
comment|// ignore the one just put in
continue|continue;
block|}
comment|// check that this is the row and column we are interested in, otherwise bail
if|if
condition|(
name|CellUtil
operator|.
name|matchingRow
argument_list|(
name|cell
argument_list|,
name|cur
argument_list|)
operator|&&
name|CellUtil
operator|.
name|matchingQualifier
argument_list|(
name|cell
argument_list|,
name|cur
argument_list|)
condition|)
block|{
comment|// only remove Puts that concurrent scanners cannot possibly see
if|if
condition|(
name|cur
operator|.
name|getTypeByte
argument_list|()
operator|==
name|KeyValue
operator|.
name|Type
operator|.
name|Put
operator|.
name|getCode
argument_list|()
operator|&&
name|cur
operator|.
name|getSequenceId
argument_list|()
operator|<=
name|readpoint
condition|)
block|{
if|if
condition|(
name|versionsVisible
operator|>=
literal|1
condition|)
block|{
comment|// if we get here we have seen at least one version visible to the oldest scanner,
comment|// which means we can prove that no scanner will see this version
comment|// false means there was a change, so give us the size.
name|long
name|delta
init|=
name|heapSizeChange
argument_list|(
name|cur
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|addedSize
operator|-=
name|delta
expr_stmt|;
name|this
operator|.
name|size
operator|.
name|addAndGet
argument_list|(
operator|-
name|delta
argument_list|)
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|setOldestEditTimeToNow
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|versionsVisible
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// past the row or column, done
break|break;
block|}
block|}
return|return
name|addedSize
return|;
block|}
comment|/**    * @return scanner on memstore and snapshot in this order.    */
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|KeyValueScanner
argument_list|>
name|getScanners
parameter_list|(
name|long
name|readPt
parameter_list|)
block|{
return|return
name|Collections
operator|.
expr|<
name|KeyValueScanner
operator|>
name|singletonList
argument_list|(
operator|new
name|MemStoreScanner
argument_list|(
name|readPt
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Check if this memstore may contain the required keys    * @param scan scan    * @param store holds reference to cf    * @param oldestUnexpiredTS    * @return False if the key definitely does not exist in this Memstore    */
specifier|public
name|boolean
name|shouldSeek
parameter_list|(
name|Scan
name|scan
parameter_list|,
name|Store
name|store
parameter_list|,
name|long
name|oldestUnexpiredTS
parameter_list|)
block|{
name|byte
index|[]
name|cf
init|=
name|store
operator|.
name|getFamily
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|TimeRange
name|timeRange
init|=
name|scan
operator|.
name|getColumnFamilyTimeRange
argument_list|()
operator|.
name|get
argument_list|(
name|cf
argument_list|)
decl_stmt|;
if|if
condition|(
name|timeRange
operator|==
literal|null
condition|)
block|{
name|timeRange
operator|=
name|scan
operator|.
name|getTimeRange
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|timeRangeTracker
operator|.
name|includesTimeRange
argument_list|(
name|timeRange
argument_list|)
operator|||
name|snapshotTimeRangeTracker
operator|.
name|includesTimeRange
argument_list|(
name|timeRange
argument_list|)
operator|)
operator|&&
operator|(
name|Math
operator|.
name|max
argument_list|(
name|timeRangeTracker
operator|.
name|getMaximumTimestamp
argument_list|()
argument_list|,
name|snapshotTimeRangeTracker
operator|.
name|getMaximumTimestamp
argument_list|()
argument_list|)
operator|>=
name|oldestUnexpiredTS
operator|)
return|;
block|}
comment|/*    * MemStoreScanner implements the KeyValueScanner.    * It lets the caller scan the contents of a memstore -- both current    * map and snapshot.    * This behaves as if it were a real scanner but does not maintain position.    */
specifier|protected
class|class
name|MemStoreScanner
extends|extends
name|NonLazyKeyValueScanner
block|{
comment|// Next row information for either cellSet or snapshot
specifier|private
name|Cell
name|cellSetNextRow
init|=
literal|null
decl_stmt|;
specifier|private
name|Cell
name|snapshotNextRow
init|=
literal|null
decl_stmt|;
comment|// last iterated Cells for cellSet and snapshot (to restore iterator state after reseek)
specifier|private
name|Cell
name|cellSetItRow
init|=
literal|null
decl_stmt|;
specifier|private
name|Cell
name|snapshotItRow
init|=
literal|null
decl_stmt|;
comment|// iterator based scanning.
specifier|private
name|Iterator
argument_list|<
name|Cell
argument_list|>
name|cellSetIt
decl_stmt|;
specifier|private
name|Iterator
argument_list|<
name|Cell
argument_list|>
name|snapshotIt
decl_stmt|;
comment|// The cellSet and snapshot at the time of creating this scanner
specifier|private
name|CellSkipListSet
name|cellSetAtCreation
decl_stmt|;
specifier|private
name|CellSkipListSet
name|snapshotAtCreation
decl_stmt|;
comment|// the pre-calculated Cell to be returned by peek() or next()
specifier|private
name|Cell
name|theNext
decl_stmt|;
comment|// The allocator and snapshot allocator at the time of creating this scanner
specifier|volatile
name|MemStoreLAB
name|allocatorAtCreation
decl_stmt|;
specifier|volatile
name|MemStoreLAB
name|snapshotAllocatorAtCreation
decl_stmt|;
comment|// A flag represents whether could stop skipping Cells for MVCC
comment|// if have encountered the next row. Only used for reversed scan
specifier|private
name|boolean
name|stopSkippingCellsIfNextRow
init|=
literal|false
decl_stmt|;
specifier|private
name|long
name|readPoint
decl_stmt|;
comment|/*     Some notes...       So memstorescanner is fixed at creation time. this includes pointers/iterators into     existing kvset/snapshot.  during a snapshot creation, the kvset is null, and the     snapshot is moved.  since kvset is null there is no point on reseeking on both,       we can save us the trouble. During the snapshot->hfile transition, the memstore       scanner is re-created by StoreScanner#updateReaders().  StoreScanner should       potentially do something smarter by adjusting the existing memstore scanner.        But there is a greater problem here, that being once a scanner has progressed       during a snapshot scenario, we currently iterate past the kvset then 'finish' up.       if a scan lasts a little while, there is a chance for new entries in kvset to       become available but we will never see them.  This needs to be handled at the       StoreScanner level with coordination with MemStoreScanner.        Currently, this problem is only partly managed: during the small amount of time       when the StoreScanner has not yet created a new MemStoreScanner, we will miss       the adds to kvset in the MemStoreScanner.     */
name|MemStoreScanner
parameter_list|(
name|long
name|readPoint
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|readPoint
operator|=
name|readPoint
expr_stmt|;
name|cellSetAtCreation
operator|=
name|cellSet
expr_stmt|;
name|snapshotAtCreation
operator|=
name|snapshot
expr_stmt|;
if|if
condition|(
name|allocator
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|allocatorAtCreation
operator|=
name|allocator
expr_stmt|;
name|this
operator|.
name|allocatorAtCreation
operator|.
name|incScannerCount
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|snapshotAllocator
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|snapshotAllocatorAtCreation
operator|=
name|snapshotAllocator
expr_stmt|;
name|this
operator|.
name|snapshotAllocatorAtCreation
operator|.
name|incScannerCount
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|Trace
operator|.
name|isTracing
argument_list|()
operator|&&
name|Trace
operator|.
name|currentSpan
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|Trace
operator|.
name|currentSpan
argument_list|()
operator|.
name|addTimelineAnnotation
argument_list|(
literal|"Creating MemStoreScanner"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Lock on 'this' must be held by caller.      * @param it      * @return Next Cell      */
specifier|private
name|Cell
name|getNext
parameter_list|(
name|Iterator
argument_list|<
name|Cell
argument_list|>
name|it
parameter_list|)
block|{
name|Cell
name|startCell
init|=
name|theNext
decl_stmt|;
name|Cell
name|v
init|=
literal|null
decl_stmt|;
try|try
block|{
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|v
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|v
operator|.
name|getSequenceId
argument_list|()
operator|<=
name|this
operator|.
name|readPoint
condition|)
block|{
return|return
name|v
return|;
block|}
if|if
condition|(
name|stopSkippingCellsIfNextRow
operator|&&
name|startCell
operator|!=
literal|null
operator|&&
name|comparator
operator|.
name|compareRows
argument_list|(
name|v
argument_list|,
name|startCell
argument_list|)
operator|>
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|v
operator|!=
literal|null
condition|)
block|{
comment|// in all cases, remember the last Cell iterated to
if|if
condition|(
name|it
operator|==
name|snapshotIt
condition|)
block|{
name|snapshotItRow
operator|=
name|v
expr_stmt|;
block|}
else|else
block|{
name|cellSetItRow
operator|=
name|v
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      *  Set the scanner at the seek key.      *  Must be called only once: there is no thread safety between the scanner      *   and the memStore.      * @param key seek value      * @return false if the key is null or if there is no data      */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|boolean
name|seek
parameter_list|(
name|Cell
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
name|close
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// kvset and snapshot will never be null.
comment|// if tailSet can't find anything, SortedSet is empty (not null).
name|cellSetIt
operator|=
name|cellSetAtCreation
operator|.
name|tailSet
argument_list|(
name|key
argument_list|)
operator|.
name|iterator
argument_list|()
expr_stmt|;
name|snapshotIt
operator|=
name|snapshotAtCreation
operator|.
name|tailSet
argument_list|(
name|key
argument_list|)
operator|.
name|iterator
argument_list|()
expr_stmt|;
name|cellSetItRow
operator|=
literal|null
expr_stmt|;
name|snapshotItRow
operator|=
literal|null
expr_stmt|;
return|return
name|seekInSubLists
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|/**      * (Re)initialize the iterators after a seek or a reseek.      */
specifier|private
specifier|synchronized
name|boolean
name|seekInSubLists
parameter_list|(
name|Cell
name|key
parameter_list|)
block|{
name|cellSetNextRow
operator|=
name|getNext
argument_list|(
name|cellSetIt
argument_list|)
expr_stmt|;
name|snapshotNextRow
operator|=
name|getNext
argument_list|(
name|snapshotIt
argument_list|)
expr_stmt|;
comment|// Calculate the next value
name|theNext
operator|=
name|getLowest
argument_list|(
name|cellSetNextRow
argument_list|,
name|snapshotNextRow
argument_list|)
expr_stmt|;
comment|// has data
return|return
operator|(
name|theNext
operator|!=
literal|null
operator|)
return|;
block|}
comment|/**      * Move forward on the sub-lists set previously by seek.      * @param key seek value (should be non-null)      * @return true if there is at least one KV to read, false otherwise      */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|boolean
name|reseek
parameter_list|(
name|Cell
name|key
parameter_list|)
block|{
comment|/*       See HBASE-4195& HBASE-3855& HBASE-6591 for the background on this implementation.       This code is executed concurrently with flush and puts, without locks.       Two points must be known when working on this code:       1) It's not possible to use the 'kvTail' and 'snapshot'        variables, as they are modified during a flush.       2) The ideal implementation for performance would use the sub skip list        implicitly pointed by the iterators 'kvsetIt' and        'snapshotIt'. Unfortunately the Java API does not offer a method to        get it. So we remember the last keys we iterated to and restore        the reseeked set to at least that point.        */
name|cellSetIt
operator|=
name|cellSetAtCreation
operator|.
name|tailSet
argument_list|(
name|getHighest
argument_list|(
name|key
argument_list|,
name|cellSetItRow
argument_list|)
argument_list|)
operator|.
name|iterator
argument_list|()
expr_stmt|;
name|snapshotIt
operator|=
name|snapshotAtCreation
operator|.
name|tailSet
argument_list|(
name|getHighest
argument_list|(
name|key
argument_list|,
name|snapshotItRow
argument_list|)
argument_list|)
operator|.
name|iterator
argument_list|()
expr_stmt|;
return|return
name|seekInSubLists
argument_list|(
name|key
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|Cell
name|peek
parameter_list|()
block|{
comment|//DebugPrint.println(" MS@" + hashCode() + " peek = " + getLowest());
return|return
name|theNext
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|Cell
name|next
parameter_list|()
block|{
if|if
condition|(
name|theNext
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|Cell
name|ret
init|=
name|theNext
decl_stmt|;
comment|// Advance one of the iterators
if|if
condition|(
name|theNext
operator|==
name|cellSetNextRow
condition|)
block|{
name|cellSetNextRow
operator|=
name|getNext
argument_list|(
name|cellSetIt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snapshotNextRow
operator|=
name|getNext
argument_list|(
name|snapshotIt
argument_list|)
expr_stmt|;
block|}
comment|// Calculate the next value
name|theNext
operator|=
name|getLowest
argument_list|(
name|cellSetNextRow
argument_list|,
name|snapshotNextRow
argument_list|)
expr_stmt|;
comment|//long readpoint = ReadWriteConsistencyControl.getThreadReadPoint();
comment|//DebugPrint.println(" MS@" + hashCode() + " next: " + theNext + " next_next: " +
comment|//    getLowest() + " threadpoint=" + readpoint);
return|return
name|ret
return|;
block|}
comment|/*      * Returns the lower of the two key values, or null if they are both null.      * This uses comparator.compare() to compare the KeyValue using the memstore      * comparator.      */
specifier|private
name|Cell
name|getLowest
parameter_list|(
name|Cell
name|first
parameter_list|,
name|Cell
name|second
parameter_list|)
block|{
if|if
condition|(
name|first
operator|==
literal|null
operator|&&
name|second
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|first
operator|!=
literal|null
operator|&&
name|second
operator|!=
literal|null
condition|)
block|{
name|int
name|compare
init|=
name|comparator
operator|.
name|compare
argument_list|(
name|first
argument_list|,
name|second
argument_list|)
decl_stmt|;
return|return
operator|(
name|compare
operator|<=
literal|0
condition|?
name|first
else|:
name|second
operator|)
return|;
block|}
return|return
operator|(
name|first
operator|!=
literal|null
condition|?
name|first
else|:
name|second
operator|)
return|;
block|}
comment|/*      * Returns the higher of the two cells, or null if they are both null.      * This uses comparator.compare() to compare the Cell using the memstore      * comparator.      */
specifier|private
name|Cell
name|getHighest
parameter_list|(
name|Cell
name|first
parameter_list|,
name|Cell
name|second
parameter_list|)
block|{
if|if
condition|(
name|first
operator|==
literal|null
operator|&&
name|second
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|first
operator|!=
literal|null
operator|&&
name|second
operator|!=
literal|null
condition|)
block|{
name|int
name|compare
init|=
name|comparator
operator|.
name|compare
argument_list|(
name|first
argument_list|,
name|second
argument_list|)
decl_stmt|;
return|return
operator|(
name|compare
operator|>
literal|0
condition|?
name|first
else|:
name|second
operator|)
return|;
block|}
return|return
operator|(
name|first
operator|!=
literal|null
condition|?
name|first
else|:
name|second
operator|)
return|;
block|}
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
block|{
name|this
operator|.
name|cellSetNextRow
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|snapshotNextRow
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|cellSetIt
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|snapshotIt
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|allocatorAtCreation
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|allocatorAtCreation
operator|.
name|decScannerCount
argument_list|()
expr_stmt|;
name|this
operator|.
name|allocatorAtCreation
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|snapshotAllocatorAtCreation
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|snapshotAllocatorAtCreation
operator|.
name|decScannerCount
argument_list|()
expr_stmt|;
name|this
operator|.
name|snapshotAllocatorAtCreation
operator|=
literal|null
expr_stmt|;
block|}
name|this
operator|.
name|cellSetItRow
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|snapshotItRow
operator|=
literal|null
expr_stmt|;
block|}
comment|/**      * MemStoreScanner returns max value as sequence id because it will      * always have the latest data among all files.      */
annotation|@
name|Override
specifier|public
name|long
name|getSequenceID
parameter_list|()
block|{
return|return
name|Long
operator|.
name|MAX_VALUE
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|shouldUseScanner
parameter_list|(
name|Scan
name|scan
parameter_list|,
name|Store
name|store
parameter_list|,
name|long
name|oldestUnexpiredTS
parameter_list|)
block|{
return|return
name|shouldSeek
argument_list|(
name|scan
argument_list|,
name|store
argument_list|,
name|oldestUnexpiredTS
argument_list|)
return|;
block|}
comment|/**      * Seek scanner to the given key first. If it returns false(means      * peek()==null) or scanner's peek row is bigger than row of given key, seek      * the scanner to the previous row of given key      */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|boolean
name|backwardSeek
parameter_list|(
name|Cell
name|key
parameter_list|)
block|{
name|seek
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek
argument_list|()
operator|==
literal|null
operator|||
name|comparator
operator|.
name|compareRows
argument_list|(
name|peek
argument_list|()
argument_list|,
name|key
argument_list|)
operator|>
literal|0
condition|)
block|{
return|return
name|seekToPreviousRow
argument_list|(
name|key
argument_list|)
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Separately get the KeyValue before the specified key from kvset and      * snapshotset, and use the row of higher one as the previous row of      * specified key, then seek to the first KeyValue of previous row      */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|boolean
name|seekToPreviousRow
parameter_list|(
name|Cell
name|originalKey
parameter_list|)
block|{
name|boolean
name|keepSeeking
init|=
literal|false
decl_stmt|;
name|Cell
name|key
init|=
name|originalKey
decl_stmt|;
do|do
block|{
name|Cell
name|firstKeyOnRow
init|=
name|CellUtil
operator|.
name|createFirstOnRow
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|SortedSet
argument_list|<
name|Cell
argument_list|>
name|cellHead
init|=
name|cellSetAtCreation
operator|.
name|headSet
argument_list|(
name|firstKeyOnRow
argument_list|)
decl_stmt|;
name|Cell
name|cellSetBeforeRow
init|=
name|cellHead
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|cellHead
operator|.
name|last
argument_list|()
decl_stmt|;
name|SortedSet
argument_list|<
name|Cell
argument_list|>
name|snapshotHead
init|=
name|snapshotAtCreation
operator|.
name|headSet
argument_list|(
name|firstKeyOnRow
argument_list|)
decl_stmt|;
name|Cell
name|snapshotBeforeRow
init|=
name|snapshotHead
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|snapshotHead
operator|.
name|last
argument_list|()
decl_stmt|;
name|Cell
name|lastCellBeforeRow
init|=
name|getHighest
argument_list|(
name|cellSetBeforeRow
argument_list|,
name|snapshotBeforeRow
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastCellBeforeRow
operator|==
literal|null
condition|)
block|{
name|theNext
operator|=
literal|null
expr_stmt|;
return|return
literal|false
return|;
block|}
name|Cell
name|firstKeyOnPreviousRow
init|=
name|CellUtil
operator|.
name|createFirstOnRow
argument_list|(
name|lastCellBeforeRow
argument_list|)
decl_stmt|;
name|this
operator|.
name|stopSkippingCellsIfNextRow
operator|=
literal|true
expr_stmt|;
name|seek
argument_list|(
name|firstKeyOnPreviousRow
argument_list|)
expr_stmt|;
name|this
operator|.
name|stopSkippingCellsIfNextRow
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|peek
argument_list|()
operator|==
literal|null
operator|||
name|comparator
operator|.
name|compareRows
argument_list|(
name|peek
argument_list|()
argument_list|,
name|firstKeyOnPreviousRow
argument_list|)
operator|>
literal|0
condition|)
block|{
name|keepSeeking
operator|=
literal|true
expr_stmt|;
name|key
operator|=
name|firstKeyOnPreviousRow
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|keepSeeking
operator|=
literal|false
expr_stmt|;
block|}
block|}
do|while
condition|(
name|keepSeeking
condition|)
do|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|boolean
name|seekToLastRow
parameter_list|()
block|{
name|Cell
name|first
init|=
name|cellSetAtCreation
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|cellSetAtCreation
operator|.
name|last
argument_list|()
decl_stmt|;
name|Cell
name|second
init|=
name|snapshotAtCreation
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|snapshotAtCreation
operator|.
name|last
argument_list|()
decl_stmt|;
name|Cell
name|higherCell
init|=
name|getHighest
argument_list|(
name|first
argument_list|,
name|second
argument_list|)
decl_stmt|;
if|if
condition|(
name|higherCell
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Cell
name|firstCellOnLastRow
init|=
name|CellUtil
operator|.
name|createFirstOnRow
argument_list|(
name|higherCell
argument_list|)
decl_stmt|;
if|if
condition|(
name|seek
argument_list|(
name|firstCellOnLastRow
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
name|seekToPreviousRow
argument_list|(
name|higherCell
argument_list|)
return|;
block|}
block|}
block|}
specifier|public
specifier|final
specifier|static
name|long
name|FIXED_OVERHEAD
init|=
name|ClassSize
operator|.
name|align
argument_list|(
name|ClassSize
operator|.
name|OBJECT
operator|+
operator|(
literal|9
operator|*
name|ClassSize
operator|.
name|REFERENCE
operator|)
operator|+
operator|(
literal|3
operator|*
name|Bytes
operator|.
name|SIZEOF_LONG
operator|)
operator|+
name|Bytes
operator|.
name|SIZEOF_BOOLEAN
argument_list|)
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|long
name|DEEP_OVERHEAD
init|=
name|ClassSize
operator|.
name|align
argument_list|(
name|FIXED_OVERHEAD
operator|+
name|ClassSize
operator|.
name|ATOMIC_LONG
operator|+
operator|(
literal|2
operator|*
name|ClassSize
operator|.
name|TIMERANGE_TRACKER
operator|)
operator|+
operator|(
literal|2
operator|*
name|ClassSize
operator|.
name|CELL_SKIPLIST_SET
operator|)
operator|+
operator|(
literal|2
operator|*
name|ClassSize
operator|.
name|CONCURRENT_SKIPLISTMAP
operator|)
argument_list|)
decl_stmt|;
comment|/*    * Calculate how the MemStore size has changed.  Includes overhead of the    * backing Map.    * @param cell    * @param notpresent True if the cell was NOT present in the set.    * @return Size    */
specifier|static
name|long
name|heapSizeChange
parameter_list|(
specifier|final
name|Cell
name|cell
parameter_list|,
specifier|final
name|boolean
name|notpresent
parameter_list|)
block|{
return|return
name|notpresent
condition|?
name|ClassSize
operator|.
name|align
argument_list|(
name|ClassSize
operator|.
name|CONCURRENT_SKIPLISTMAP_ENTRY
operator|+
name|CellUtil
operator|.
name|estimatedHeapSizeOf
argument_list|(
name|cell
argument_list|)
argument_list|)
else|:
literal|0
return|;
block|}
specifier|private
name|long
name|keySize
parameter_list|()
block|{
return|return
name|heapSize
argument_list|()
operator|-
name|DEEP_OVERHEAD
return|;
block|}
comment|/**    * Get the entire heap usage for this MemStore not including keys in the    * snapshot.    */
annotation|@
name|Override
specifier|public
name|long
name|heapSize
parameter_list|()
block|{
return|return
name|size
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|size
parameter_list|()
block|{
return|return
name|heapSize
argument_list|()
return|;
block|}
comment|/**    * Code to help figure if our approximation of object heap sizes is close    * enough.  See hbase-900.  Fills memstores then waits so user can heap    * dump and bring up resultant hprof in something like jprofiler which    * allows you get 'deep size' on objects.    * @param args main args    */
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|RuntimeMXBean
name|runtime
init|=
name|ManagementFactory
operator|.
name|getRuntimeMXBean
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"vmName="
operator|+
name|runtime
operator|.
name|getVmName
argument_list|()
operator|+
literal|", vmVendor="
operator|+
name|runtime
operator|.
name|getVmVendor
argument_list|()
operator|+
literal|", vmVersion="
operator|+
name|runtime
operator|.
name|getVmVersion
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"vmInputArguments="
operator|+
name|runtime
operator|.
name|getInputArguments
argument_list|()
argument_list|)
expr_stmt|;
name|DefaultMemStore
name|memstore1
init|=
operator|new
name|DefaultMemStore
argument_list|()
decl_stmt|;
comment|// TODO: x32 vs x64
name|long
name|size
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|count
init|=
literal|10000
decl_stmt|;
name|byte
index|[]
name|fam
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"col"
argument_list|)
decl_stmt|;
name|byte
index|[]
name|qf
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
literal|"umn"
argument_list|)
decl_stmt|;
name|byte
index|[]
name|empty
init|=
operator|new
name|byte
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|// Give each its own ts
name|size
operator|+=
name|memstore1
operator|.
name|add
argument_list|(
operator|new
name|KeyValue
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|i
argument_list|)
argument_list|,
name|fam
argument_list|,
name|qf
argument_list|,
name|i
argument_list|,
name|empty
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"memstore1 estimated size="
operator|+
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|+=
name|memstore1
operator|.
name|add
argument_list|(
operator|new
name|KeyValue
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|i
argument_list|)
argument_list|,
name|fam
argument_list|,
name|qf
argument_list|,
name|i
argument_list|,
name|empty
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"memstore1 estimated size (2nd loading of same data)="
operator|+
name|size
argument_list|)
expr_stmt|;
comment|// Make a variably sized memstore.
name|DefaultMemStore
name|memstore2
init|=
operator|new
name|DefaultMemStore
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|+=
name|memstore2
operator|.
name|add
argument_list|(
operator|new
name|KeyValue
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|i
argument_list|)
argument_list|,
name|fam
argument_list|,
name|qf
argument_list|,
name|i
argument_list|,
operator|new
name|byte
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"memstore2 estimated size="
operator|+
name|size
argument_list|)
expr_stmt|;
specifier|final
name|int
name|seconds
init|=
literal|30
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting "
operator|+
name|seconds
operator|+
literal|" seconds while heap dump is taken"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|seconds
condition|;
name|i
operator|++
control|)
block|{
comment|// Thread.sleep(1000);
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Exiting."
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

