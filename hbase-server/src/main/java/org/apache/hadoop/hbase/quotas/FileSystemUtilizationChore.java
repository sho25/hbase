begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ScheduledChore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegionServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|Region
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|Store
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|StoreFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|StoreFileReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EnvironmentEdgeManager
import|;
end_import

begin_comment
comment|/**  * A chore which computes the size of each {@link HRegion} on the FileSystem hosted by the given {@link HRegionServer}.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|FileSystemUtilizationChore
extends|extends
name|ScheduledChore
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FileSystemUtilizationChore
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|static
specifier|final
name|String
name|FS_UTILIZATION_CHORE_PERIOD_KEY
init|=
literal|"hbase.regionserver.quotas.fs.utilization.chore.period"
decl_stmt|;
specifier|static
specifier|final
name|int
name|FS_UTILIZATION_CHORE_PERIOD_DEFAULT
init|=
literal|1000
operator|*
literal|60
operator|*
literal|5
decl_stmt|;
comment|// 5 minutes in millis
specifier|static
specifier|final
name|String
name|FS_UTILIZATION_CHORE_DELAY_KEY
init|=
literal|"hbase.regionserver.quotas.fs.utilization.chore.delay"
decl_stmt|;
specifier|static
specifier|final
name|long
name|FS_UTILIZATION_CHORE_DELAY_DEFAULT
init|=
literal|1000L
operator|*
literal|60L
decl_stmt|;
comment|// 1 minute
specifier|static
specifier|final
name|String
name|FS_UTILIZATION_CHORE_TIMEUNIT_KEY
init|=
literal|"hbase.regionserver.quotas.fs.utilization.chore.timeunit"
decl_stmt|;
specifier|static
specifier|final
name|String
name|FS_UTILIZATION_CHORE_TIMEUNIT_DEFAULT
init|=
name|TimeUnit
operator|.
name|MILLISECONDS
operator|.
name|name
argument_list|()
decl_stmt|;
specifier|static
specifier|final
name|String
name|FS_UTILIZATION_MAX_ITERATION_DURATION_KEY
init|=
literal|"hbase.regionserver.quotas.fs.utilization.chore.max.iteration.millis"
decl_stmt|;
specifier|static
specifier|final
name|long
name|FS_UTILIZATION_MAX_ITERATION_DURATION_DEFAULT
init|=
literal|5000L
decl_stmt|;
specifier|private
name|int
name|numberOfCyclesToSkip
init|=
literal|0
decl_stmt|,
name|prevNumberOfCyclesToSkip
init|=
literal|0
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|CYCLE_UPPER_BOUND
init|=
literal|32
decl_stmt|;
specifier|private
specifier|final
name|HRegionServer
name|rs
decl_stmt|;
specifier|private
specifier|final
name|long
name|maxIterationMillis
decl_stmt|;
specifier|private
name|Iterator
argument_list|<
name|Region
argument_list|>
name|leftoverRegions
decl_stmt|;
specifier|public
name|FileSystemUtilizationChore
parameter_list|(
name|HRegionServer
name|rs
parameter_list|)
block|{
name|super
argument_list|(
name|FileSystemUtilizationChore
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|rs
argument_list|,
name|getPeriod
argument_list|(
name|rs
operator|.
name|getConfiguration
argument_list|()
argument_list|)
argument_list|,
name|getInitialDelay
argument_list|(
name|rs
operator|.
name|getConfiguration
argument_list|()
argument_list|)
argument_list|,
name|getTimeUnit
argument_list|(
name|rs
operator|.
name|getConfiguration
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|rs
operator|=
name|rs
expr_stmt|;
name|this
operator|.
name|maxIterationMillis
operator|=
name|rs
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getLong
argument_list|(
name|FS_UTILIZATION_MAX_ITERATION_DURATION_KEY
argument_list|,
name|FS_UTILIZATION_MAX_ITERATION_DURATION_DEFAULT
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|chore
parameter_list|()
block|{
if|if
condition|(
name|numberOfCyclesToSkip
operator|>
literal|0
condition|)
block|{
name|numberOfCyclesToSkip
operator|--
expr_stmt|;
return|return;
block|}
specifier|final
name|Map
argument_list|<
name|HRegionInfo
argument_list|,
name|Long
argument_list|>
name|onlineRegionSizes
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Region
argument_list|>
name|onlineRegions
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|rs
operator|.
name|getRegions
argument_list|()
argument_list|)
decl_stmt|;
comment|// Process the regions from the last run if we have any. If we are somehow having difficulty
comment|// processing the Regions, we want to avoid creating a backlog in memory of Region objs.
name|Iterator
argument_list|<
name|Region
argument_list|>
name|oldRegionsToProcess
init|=
name|getLeftoverRegions
argument_list|()
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|Region
argument_list|>
name|iterator
decl_stmt|;
specifier|final
name|boolean
name|processingLeftovers
decl_stmt|;
if|if
condition|(
name|oldRegionsToProcess
operator|==
literal|null
condition|)
block|{
name|iterator
operator|=
name|onlineRegions
operator|.
name|iterator
argument_list|()
expr_stmt|;
name|processingLeftovers
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|iterator
operator|=
name|oldRegionsToProcess
expr_stmt|;
name|processingLeftovers
operator|=
literal|true
expr_stmt|;
block|}
comment|// Reset the leftoverRegions and let the loop re-assign if necessary.
name|setLeftoverRegions
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|long
name|regionSizesCalculated
init|=
literal|0L
decl_stmt|;
name|long
name|offlineRegionsSkipped
init|=
literal|0L
decl_stmt|;
name|long
name|skippedSplitParents
init|=
literal|0L
decl_stmt|;
name|long
name|skippedRegionReplicas
init|=
literal|0L
decl_stmt|;
specifier|final
name|long
name|start
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// Make sure this chore doesn't hog the thread.
name|long
name|timeRunning
init|=
name|EnvironmentEdgeManager
operator|.
name|currentTime
argument_list|()
operator|-
name|start
decl_stmt|;
if|if
condition|(
name|timeRunning
operator|>
name|maxIterationMillis
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Preempting execution of FileSystemUtilizationChore because it exceeds the"
operator|+
literal|" maximum iteration configuration value. Will process remaining iterators"
operator|+
literal|" on a subsequent invocation."
argument_list|)
expr_stmt|;
name|setLeftoverRegions
argument_list|(
name|iterator
argument_list|)
expr_stmt|;
break|break;
block|}
specifier|final
name|Region
name|region
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// If we're processing leftover regions, the region may no-longer be online.
comment|// If so, we can skip it.
if|if
condition|(
name|processingLeftovers
operator|&&
operator|!
name|onlineRegions
operator|.
name|contains
argument_list|(
name|region
argument_list|)
condition|)
block|{
name|offlineRegionsSkipped
operator|++
expr_stmt|;
continue|continue;
block|}
comment|// Avoid computing the size of regions which are the parent of split.
if|if
condition|(
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|isSplitParent
argument_list|()
condition|)
block|{
name|skippedSplitParents
operator|++
expr_stmt|;
continue|continue;
block|}
comment|// Avoid computing the size of region replicas.
if|if
condition|(
name|HRegionInfo
operator|.
name|DEFAULT_REPLICA_ID
operator|!=
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getReplicaId
argument_list|()
condition|)
block|{
name|skippedRegionReplicas
operator|++
expr_stmt|;
continue|continue;
block|}
specifier|final
name|long
name|sizeInBytes
init|=
name|computeSize
argument_list|(
name|region
argument_list|)
decl_stmt|;
name|onlineRegionSizes
operator|.
name|put
argument_list|(
name|region
operator|.
name|getRegionInfo
argument_list|()
argument_list|,
name|sizeInBytes
argument_list|)
expr_stmt|;
name|regionSizesCalculated
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Computed the size of "
operator|+
name|regionSizesCalculated
operator|+
literal|" Regions. Skipped computation"
operator|+
literal|" of "
operator|+
name|offlineRegionsSkipped
operator|+
literal|" regions due to not being online on this RS, "
operator|+
name|skippedSplitParents
operator|+
literal|" regions due to being the parent of a split, and"
operator|+
name|skippedRegionReplicas
operator|+
literal|" regions due to being region replicas."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|reportRegionSizesToMaster
argument_list|(
name|onlineRegionSizes
argument_list|)
condition|)
block|{
comment|// backoff reporting
name|numberOfCyclesToSkip
operator|=
name|prevNumberOfCyclesToSkip
operator|>
literal|0
condition|?
literal|2
operator|*
name|prevNumberOfCyclesToSkip
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|numberOfCyclesToSkip
operator|>
name|CYCLE_UPPER_BOUND
condition|)
block|{
name|numberOfCyclesToSkip
operator|=
name|CYCLE_UPPER_BOUND
expr_stmt|;
block|}
name|prevNumberOfCyclesToSkip
operator|=
name|numberOfCyclesToSkip
expr_stmt|;
block|}
block|}
comment|/**    * Returns an {@link Iterator} over the Regions which were skipped last invocation of the chore.    *    * @return Regions from the previous invocation to process, or null.    */
name|Iterator
argument_list|<
name|Region
argument_list|>
name|getLeftoverRegions
parameter_list|()
block|{
return|return
name|leftoverRegions
return|;
block|}
comment|/**    * Sets a new collection of Regions as leftovers.    */
name|void
name|setLeftoverRegions
parameter_list|(
name|Iterator
argument_list|<
name|Region
argument_list|>
name|newLeftovers
parameter_list|)
block|{
name|this
operator|.
name|leftoverRegions
operator|=
name|newLeftovers
expr_stmt|;
block|}
comment|/**    * Computes total FileSystem size for the given {@link Region}.    *    * @param r The region    * @return The size, in bytes, of the Region.    */
name|long
name|computeSize
parameter_list|(
name|Region
name|r
parameter_list|)
block|{
name|long
name|regionSize
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|Store
name|store
range|:
name|r
operator|.
name|getStores
argument_list|()
control|)
block|{
name|regionSize
operator|+=
name|store
operator|.
name|getHFilesSize
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Size of "
operator|+
name|r
operator|+
literal|" is "
operator|+
name|regionSize
argument_list|)
expr_stmt|;
block|}
return|return
name|regionSize
return|;
block|}
comment|/**    * Reports the computed region sizes to the currently active Master.    *    * @param onlineRegionSizes The computed region sizes to report.    * @return {@code false} if FileSystemUtilizationChore should pause reporting to master,    *    {@code true} otherwise.    */
name|boolean
name|reportRegionSizesToMaster
parameter_list|(
name|Map
argument_list|<
name|HRegionInfo
argument_list|,
name|Long
argument_list|>
name|onlineRegionSizes
parameter_list|)
block|{
return|return
name|this
operator|.
name|rs
operator|.
name|reportRegionSizesForQuotas
argument_list|(
name|onlineRegionSizes
argument_list|)
return|;
block|}
comment|/**    * Extracts the period for the chore from the configuration.    *    * @param conf The configuration object.    * @return The configured chore period or the default value.    */
specifier|static
name|int
name|getPeriod
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|getInt
argument_list|(
name|FS_UTILIZATION_CHORE_PERIOD_KEY
argument_list|,
name|FS_UTILIZATION_CHORE_PERIOD_DEFAULT
argument_list|)
return|;
block|}
comment|/**    * Extracts the initial delay for the chore from the configuration.    *    * @param conf The configuration object.    * @return The configured chore initial delay or the default value.    */
specifier|static
name|long
name|getInitialDelay
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|getLong
argument_list|(
name|FS_UTILIZATION_CHORE_DELAY_KEY
argument_list|,
name|FS_UTILIZATION_CHORE_DELAY_DEFAULT
argument_list|)
return|;
block|}
comment|/**    * Extracts the time unit for the chore period and initial delay from the configuration. The    * configuration value for {@link #FS_UTILIZATION_CHORE_TIMEUNIT_KEY} must correspond to a    * {@link TimeUnit} value.    *    * @param conf The configuration object.    * @return The configured time unit for the chore period and initial delay or the default value.    */
specifier|static
name|TimeUnit
name|getTimeUnit
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|TimeUnit
operator|.
name|valueOf
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|FS_UTILIZATION_CHORE_TIMEUNIT_KEY
argument_list|,
name|FS_UTILIZATION_CHORE_TIMEUNIT_DEFAULT
argument_list|)
argument_list|)
return|;
block|}
block|}
end_class

end_unit

