begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|throttle
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentSkipListMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Cell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|RegionTooBusyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|Region
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|Store
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ClassSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * StoreHotnessProtector is designed to help limit the concurrency of puts with dense columns, it  * does best-effort to avoid exhausting all RS's handlers. When a lot of clients write requests with  * dense (hundreds) columns to a Store at the same time, it will lead to blocking of RS because CSLM  * degrades when concurrency goes up. It's not a kind of throttling. Throttling is user-oriented,  * while StoreHotnessProtector is system-oriented, RS-self-protected mechanism.  *<p>  * There are three key parameters:  *<p>  * 1. parallelPutToStoreThreadLimitCheckMinColumnCount: If the amount of columns exceed this  * threshold, the HotProtector will work, 100 by default  *<p>  * 2. parallelPutToStoreThreadLimit: The amount of concurrency allowed to write puts to a Store at  * the same time.  *<p>  * 3. parallelPreparePutToStoreThreadLimit: The amount of concurrency allowed to  * prepare writing puts to a Store at the same time.  *<p>  * Notice that our writing pipeline includes three key process: MVCC acquire, writing MemStore, and  * WAL. Only limit the concurrency of writing puts to Store(parallelPutToStoreThreadLimit) is not  * enough since the actual concurrency of puts may still exceed the limit when MVCC contention or  * slow WAL sync happens. This is why parallelPreparePutToStoreThreadLimit is needed.  *<p>  * This protector is enabled by default and could be turned off by setting  * hbase.region.store.parallel.put.limit to 0, supporting online configuration change.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|StoreHotnessProtector
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|StoreHotnessProtector
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|volatile
name|int
name|parallelPutToStoreThreadLimit
decl_stmt|;
specifier|private
specifier|volatile
name|int
name|parallelPreparePutToStoreThreadLimit
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|String
name|PARALLEL_PUT_STORE_THREADS_LIMIT
init|=
literal|"hbase.region.store.parallel.put.limit"
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|String
name|PARALLEL_PREPARE_PUT_STORE_MULTIPLIER
init|=
literal|"hbase.region.store.parallel.prepare.put.multiplier"
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|int
name|DEFAULT_PARALLEL_PUT_STORE_THREADS_LIMIT
init|=
literal|10
decl_stmt|;
specifier|private
specifier|volatile
name|int
name|parallelPutToStoreThreadLimitCheckMinColumnCount
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|String
name|PARALLEL_PUT_STORE_THREADS_LIMIT_MIN_COLUMN_COUNT
init|=
literal|"hbase.region.store.parallel.put.limit.min.column.count"
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|int
name|DEFAULT_PARALLEL_PUT_STORE_THREADS_LIMIT_MIN_COLUMN_NUM
init|=
literal|100
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|int
name|DEFAULT_PARALLEL_PREPARE_PUT_STORE_MULTIPLIER
init|=
literal|2
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|AtomicInteger
argument_list|>
name|preparePutToStoreMap
init|=
operator|new
name|ConcurrentSkipListMap
argument_list|<>
argument_list|(
name|Bytes
operator|.
name|BYTES_RAWCOMPARATOR
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|Region
name|region
decl_stmt|;
specifier|public
name|StoreHotnessProtector
parameter_list|(
name|Region
name|region
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|region
operator|=
name|region
expr_stmt|;
block|}
specifier|public
name|void
name|init
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|parallelPutToStoreThreadLimit
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|PARALLEL_PUT_STORE_THREADS_LIMIT
argument_list|,
name|DEFAULT_PARALLEL_PUT_STORE_THREADS_LIMIT
argument_list|)
expr_stmt|;
name|this
operator|.
name|parallelPreparePutToStoreThreadLimit
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|PARALLEL_PREPARE_PUT_STORE_MULTIPLIER
argument_list|,
name|DEFAULT_PARALLEL_PREPARE_PUT_STORE_MULTIPLIER
argument_list|)
operator|*
name|parallelPutToStoreThreadLimit
expr_stmt|;
name|this
operator|.
name|parallelPutToStoreThreadLimitCheckMinColumnCount
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|PARALLEL_PUT_STORE_THREADS_LIMIT_MIN_COLUMN_COUNT
argument_list|,
name|DEFAULT_PARALLEL_PUT_STORE_THREADS_LIMIT_MIN_COLUMN_NUM
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|update
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|preparePutToStoreMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"update config: "
operator|+
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|start
parameter_list|(
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|List
argument_list|<
name|Cell
argument_list|>
argument_list|>
name|familyMaps
parameter_list|)
throws|throws
name|RegionTooBusyException
block|{
if|if
condition|(
operator|!
name|isEnable
argument_list|()
condition|)
block|{
return|return;
block|}
name|String
name|tooBusyStore
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|List
argument_list|<
name|Cell
argument_list|>
argument_list|>
name|e
range|:
name|familyMaps
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Store
name|store
init|=
name|this
operator|.
name|region
operator|.
name|getStore
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|store
operator|==
literal|null
operator|||
name|e
operator|.
name|getValue
argument_list|()
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
operator|>
name|this
operator|.
name|parallelPutToStoreThreadLimitCheckMinColumnCount
condition|)
block|{
comment|//we need to try to add #preparePutCount at first because preparePutToStoreMap will be
comment|//cleared when changing the configuration.
name|preparePutToStoreMap
operator|.
name|putIfAbsent
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
operator|new
name|AtomicInteger
argument_list|()
argument_list|)
expr_stmt|;
name|AtomicInteger
name|preparePutCounter
init|=
name|preparePutToStoreMap
operator|.
name|get
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|preparePutCounter
operator|==
literal|null
condition|)
block|{
name|preparePutCounter
operator|=
operator|new
name|AtomicInteger
argument_list|()
expr_stmt|;
name|preparePutToStoreMap
operator|.
name|putIfAbsent
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|preparePutCounter
argument_list|)
expr_stmt|;
block|}
name|int
name|preparePutCount
init|=
name|preparePutCounter
operator|.
name|incrementAndGet
argument_list|()
decl_stmt|;
if|if
condition|(
name|store
operator|.
name|getCurrentParallelPutCount
argument_list|()
operator|>
name|this
operator|.
name|parallelPutToStoreThreadLimit
operator|||
name|preparePutCount
operator|>
name|this
operator|.
name|parallelPreparePutToStoreThreadLimit
condition|)
block|{
name|tooBusyStore
operator|=
operator|(
name|tooBusyStore
operator|==
literal|null
condition|?
name|store
operator|.
name|getColumnFamilyName
argument_list|()
else|:
name|tooBusyStore
operator|+
literal|","
operator|+
name|store
operator|.
name|getColumnFamilyName
argument_list|()
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|store
operator|.
name|getColumnFamilyName
argument_list|()
operator|+
literal|": preparePutCount="
operator|+
name|preparePutCount
operator|+
literal|"; currentParallelPutCount="
operator|+
name|store
operator|.
name|getCurrentParallelPutCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|tooBusyStore
operator|!=
literal|null
condition|)
block|{
name|String
name|msg
init|=
literal|"StoreTooBusy,"
operator|+
name|this
operator|.
name|region
operator|.
name|getRegionInfo
argument_list|()
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|":"
operator|+
name|tooBusyStore
operator|+
literal|" Above parallelPutToStoreThreadLimit("
operator|+
name|this
operator|.
name|parallelPutToStoreThreadLimit
operator|+
literal|")"
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|RegionTooBusyException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
specifier|public
name|void
name|finish
parameter_list|(
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|List
argument_list|<
name|Cell
argument_list|>
argument_list|>
name|familyMaps
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isEnable
argument_list|()
condition|)
block|{
return|return;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|List
argument_list|<
name|Cell
argument_list|>
argument_list|>
name|e
range|:
name|familyMaps
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Store
name|store
init|=
name|this
operator|.
name|region
operator|.
name|getStore
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|store
operator|==
literal|null
operator|||
name|e
operator|.
name|getValue
argument_list|()
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
operator|>
name|this
operator|.
name|parallelPutToStoreThreadLimitCheckMinColumnCount
condition|)
block|{
name|AtomicInteger
name|counter
init|=
name|preparePutToStoreMap
operator|.
name|get
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
comment|// preparePutToStoreMap will be cleared when changing the configuration, so it may turn
comment|// into a negative value. It will be not accuracy in a short time, it's a trade-off for
comment|// performance.
if|if
condition|(
name|counter
operator|!=
literal|null
operator|&&
name|counter
operator|.
name|decrementAndGet
argument_list|()
operator|<
literal|0
condition|)
block|{
name|counter
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"StoreHotnessProtector, parallelPutToStoreThreadLimit="
operator|+
name|this
operator|.
name|parallelPutToStoreThreadLimit
operator|+
literal|" ; minColumnNum="
operator|+
name|this
operator|.
name|parallelPutToStoreThreadLimitCheckMinColumnCount
operator|+
literal|" ; preparePutThreadLimit="
operator|+
name|this
operator|.
name|parallelPreparePutToStoreThreadLimit
operator|+
literal|" ; hotProtect now "
operator|+
operator|(
name|this
operator|.
name|isEnable
argument_list|()
condition|?
literal|"enable"
else|:
literal|"disable"
operator|)
return|;
block|}
specifier|public
name|boolean
name|isEnable
parameter_list|()
block|{
comment|// feature is enabled when parallelPutToStoreThreadLimit> 0
return|return
name|this
operator|.
name|parallelPutToStoreThreadLimit
operator|>
literal|0
return|;
block|}
annotation|@
name|VisibleForTesting
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|AtomicInteger
argument_list|>
name|getPreparePutToStoreMap
parameter_list|()
block|{
return|return
name|preparePutToStoreMap
return|;
block|}
specifier|public
specifier|static
specifier|final
name|long
name|FIXED_SIZE
init|=
name|ClassSize
operator|.
name|align
argument_list|(
name|ClassSize
operator|.
name|OBJECT
operator|+
literal|2
operator|*
name|ClassSize
operator|.
name|REFERENCE
operator|+
literal|3
operator|*
name|Bytes
operator|.
name|SIZEOF_INT
argument_list|)
decl_stmt|;
block|}
end_class

end_unit

