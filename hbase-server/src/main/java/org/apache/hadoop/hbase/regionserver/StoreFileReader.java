begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Cell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValueUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Scan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|FSDataInputStreamWrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|TimeRange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|BlockType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|CacheConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|HFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|HFileBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|HFileScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|nio
operator|.
name|ByteBuff
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|BloomFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|BloomFilterFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_comment
comment|/**  * Reader for a StoreFile.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|StoreFileReader
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|StoreFileReader
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|protected
name|BloomFilter
name|generalBloomFilter
init|=
literal|null
decl_stmt|;
specifier|protected
name|BloomFilter
name|deleteFamilyBloomFilter
init|=
literal|null
decl_stmt|;
specifier|protected
name|BloomType
name|bloomFilterType
decl_stmt|;
specifier|private
specifier|final
name|HFile
operator|.
name|Reader
name|reader
decl_stmt|;
specifier|protected
name|long
name|sequenceID
init|=
operator|-
literal|1
decl_stmt|;
specifier|protected
name|TimeRange
name|timeRange
init|=
literal|null
decl_stmt|;
specifier|private
name|byte
index|[]
name|lastBloomKey
decl_stmt|;
specifier|private
name|long
name|deleteFamilyCnt
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|boolean
name|bulkLoadResult
init|=
literal|false
decl_stmt|;
specifier|private
name|KeyValue
operator|.
name|KeyOnlyKeyValue
name|lastBloomKeyOnlyKV
init|=
literal|null
decl_stmt|;
specifier|private
name|boolean
name|skipResetSeqId
init|=
literal|true
decl_stmt|;
specifier|public
name|AtomicInteger
name|getRefCount
parameter_list|()
block|{
return|return
name|refCount
return|;
block|}
comment|// Counter that is incremented every time a scanner is created on the
comment|// store file.  It is decremented when the scan on the store file is
comment|// done.
specifier|private
name|AtomicInteger
name|refCount
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// Indicates if the file got compacted
specifier|private
specifier|volatile
name|boolean
name|compactedAway
init|=
literal|false
decl_stmt|;
specifier|public
name|StoreFileReader
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|CacheConfig
name|cacheConf
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|reader
operator|=
name|HFile
operator|.
name|createReader
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|cacheConf
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|bloomFilterType
operator|=
name|BloomType
operator|.
name|NONE
expr_stmt|;
block|}
name|void
name|markCompactedAway
parameter_list|()
block|{
name|this
operator|.
name|compactedAway
operator|=
literal|true
expr_stmt|;
block|}
specifier|public
name|StoreFileReader
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|FSDataInputStreamWrapper
name|in
parameter_list|,
name|long
name|size
parameter_list|,
name|CacheConfig
name|cacheConf
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|reader
operator|=
name|HFile
operator|.
name|createReader
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|in
argument_list|,
name|size
argument_list|,
name|cacheConf
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|bloomFilterType
operator|=
name|BloomType
operator|.
name|NONE
expr_stmt|;
block|}
specifier|public
name|void
name|setReplicaStoreFile
parameter_list|(
name|boolean
name|isPrimaryReplicaStoreFile
parameter_list|)
block|{
name|reader
operator|.
name|setPrimaryReplicaReader
argument_list|(
name|isPrimaryReplicaStoreFile
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|isPrimaryReplicaReader
parameter_list|()
block|{
return|return
name|reader
operator|.
name|isPrimaryReplicaReader
argument_list|()
return|;
block|}
comment|/**    * ONLY USE DEFAULT CONSTRUCTOR FOR UNIT TESTS    */
name|StoreFileReader
parameter_list|()
block|{
name|this
operator|.
name|reader
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
name|CellComparator
name|getComparator
parameter_list|()
block|{
return|return
name|reader
operator|.
name|getComparator
argument_list|()
return|;
block|}
comment|/**    * Uses {@link #getStoreFileScanner(boolean, boolean, boolean, long, long)} by setting    * {@code isCompaction} to false, {@code readPt} to 0 and {@code scannerOrder} to 0.    * Do not use this overload if using this scanner for compactions.    *    * @see #getStoreFileScanner(boolean, boolean, boolean, long, long)    */
specifier|public
name|StoreFileScanner
name|getStoreFileScanner
parameter_list|(
name|boolean
name|cacheBlocks
parameter_list|,
name|boolean
name|pread
parameter_list|)
block|{
comment|// 0 is passed as readpoint because this method is only used by test
comment|// where StoreFile is directly operated upon
return|return
name|getStoreFileScanner
argument_list|(
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Uses {@link #getStoreFileScanner(boolean, boolean, boolean, long, long)} by setting    * {@code scannerOrder} to 0.    *    * @see #getStoreFileScanner(boolean, boolean, boolean, long, long)    */
specifier|public
name|StoreFileScanner
name|getStoreFileScanner
parameter_list|(
name|boolean
name|cacheBlocks
parameter_list|,
name|boolean
name|pread
parameter_list|,
name|boolean
name|isCompaction
parameter_list|,
name|long
name|readPt
parameter_list|)
block|{
return|return
name|getStoreFileScanner
argument_list|(
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|,
name|readPt
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Get a scanner to scan over this StoreFile.    *    * @param cacheBlocks should this scanner cache blocks?    * @param pread use pread (for highly concurrent small readers)    * @param isCompaction is scanner being used for compaction?    * @param scannerOrder Order of this scanner relative to other scanners. See    *  {@link KeyValueScanner#getScannerOrder()}.    * @return a scanner    */
specifier|public
name|StoreFileScanner
name|getStoreFileScanner
parameter_list|(
name|boolean
name|cacheBlocks
parameter_list|,
name|boolean
name|pread
parameter_list|,
name|boolean
name|isCompaction
parameter_list|,
name|long
name|readPt
parameter_list|,
name|long
name|scannerOrder
parameter_list|)
block|{
comment|// Increment the ref count
name|refCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return
operator|new
name|StoreFileScanner
argument_list|(
name|this
argument_list|,
name|getScanner
argument_list|(
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|)
argument_list|,
operator|!
name|isCompaction
argument_list|,
name|reader
operator|.
name|hasMVCCInfo
argument_list|()
argument_list|,
name|readPt
argument_list|,
name|scannerOrder
argument_list|)
return|;
block|}
comment|/**    * Decrement the ref count associated with the reader when ever a scanner associated    * with the reader is closed    */
name|void
name|decrementRefCount
parameter_list|()
block|{
name|refCount
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|/**    * @return true if the file is still used in reads    */
specifier|public
name|boolean
name|isReferencedInReads
parameter_list|()
block|{
return|return
name|refCount
operator|.
name|get
argument_list|()
operator|!=
literal|0
return|;
block|}
comment|/**    * @return true if the file is compacted    */
specifier|public
name|boolean
name|isCompactedAway
parameter_list|()
block|{
return|return
name|this
operator|.
name|compactedAway
return|;
block|}
comment|/**    * @deprecated Do not write further code which depends on this call. Instead    *   use getStoreFileScanner() which uses the StoreFileScanner class/interface    *   which is the preferred way to scan a store with higher level concepts.    *    * @param cacheBlocks should we cache the blocks?    * @param pread use pread (for concurrent small readers)    * @return the underlying HFileScanner    */
annotation|@
name|Deprecated
specifier|public
name|HFileScanner
name|getScanner
parameter_list|(
name|boolean
name|cacheBlocks
parameter_list|,
name|boolean
name|pread
parameter_list|)
block|{
return|return
name|getScanner
argument_list|(
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * @deprecated Do not write further code which depends on this call. Instead    *   use getStoreFileScanner() which uses the StoreFileScanner class/interface    *   which is the preferred way to scan a store with higher level concepts.    *    * @param cacheBlocks    *          should we cache the blocks?    * @param pread    *          use pread (for concurrent small readers)    * @param isCompaction    *          is scanner being used for compaction?    * @return the underlying HFileScanner    */
annotation|@
name|Deprecated
specifier|public
name|HFileScanner
name|getScanner
parameter_list|(
name|boolean
name|cacheBlocks
parameter_list|,
name|boolean
name|pread
parameter_list|,
name|boolean
name|isCompaction
parameter_list|)
block|{
return|return
name|reader
operator|.
name|getScanner
argument_list|(
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|)
return|;
block|}
specifier|public
name|void
name|close
parameter_list|(
name|boolean
name|evictOnClose
parameter_list|)
throws|throws
name|IOException
block|{
name|reader
operator|.
name|close
argument_list|(
name|evictOnClose
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check if this storeFile may contain keys within the TimeRange that    * have not expired (i.e. not older than oldestUnexpiredTS).    * @param timeRange the timeRange to restrict    * @param oldestUnexpiredTS the oldest timestamp that is not expired, as    *          determined by the column family's TTL    * @return false if queried keys definitely don't exist in this StoreFile    */
name|boolean
name|passesTimerangeFilter
parameter_list|(
name|TimeRange
name|tr
parameter_list|,
name|long
name|oldestUnexpiredTS
parameter_list|)
block|{
return|return
name|this
operator|.
name|timeRange
operator|==
literal|null
condition|?
literal|true
else|:
name|this
operator|.
name|timeRange
operator|.
name|includesTimeRange
argument_list|(
name|tr
argument_list|)
operator|&&
name|this
operator|.
name|timeRange
operator|.
name|getMax
argument_list|()
operator|>=
name|oldestUnexpiredTS
return|;
block|}
comment|/**    * Checks whether the given scan passes the Bloom filter (if present). Only    * checks Bloom filters for single-row or single-row-column scans. Bloom    * filter checking for multi-gets is implemented as part of the store    * scanner system (see {@link StoreFileScanner#seekExactly}) and uses    * the lower-level API {@link #passesGeneralRowBloomFilter(byte[], int, int)}    * and {@link #passesGeneralRowColBloomFilter(Cell)}.    *    * @param scan the scan specification. Used to determine the row, and to    *          check whether this is a single-row ("get") scan.    * @param columns the set of columns. Only used for row-column Bloom    *          filters.    * @return true if the scan with the given column set passes the Bloom    *         filter, or if the Bloom filter is not applicable for the scan.    *         False if the Bloom filter is applicable and the scan fails it.    */
name|boolean
name|passesBloomFilter
parameter_list|(
name|Scan
name|scan
parameter_list|,
specifier|final
name|SortedSet
argument_list|<
name|byte
index|[]
argument_list|>
name|columns
parameter_list|)
block|{
comment|// Multi-column non-get scans will use Bloom filters through the
comment|// lower-level API function that this function calls.
if|if
condition|(
operator|!
name|scan
operator|.
name|isGetScan
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|byte
index|[]
name|row
init|=
name|scan
operator|.
name|getStartRow
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|this
operator|.
name|bloomFilterType
condition|)
block|{
case|case
name|ROW
case|:
return|return
name|passesGeneralRowBloomFilter
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
name|row
operator|.
name|length
argument_list|)
return|;
case|case
name|ROWCOL
case|:
if|if
condition|(
name|columns
operator|!=
literal|null
operator|&&
name|columns
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|byte
index|[]
name|column
init|=
name|columns
operator|.
name|first
argument_list|()
decl_stmt|;
comment|// create the required fake key
name|Cell
name|kvKey
init|=
name|KeyValueUtil
operator|.
name|createFirstOnRow
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
name|row
operator|.
name|length
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|column
argument_list|,
literal|0
argument_list|,
name|column
operator|.
name|length
argument_list|)
decl_stmt|;
return|return
name|passesGeneralRowColBloomFilter
argument_list|(
name|kvKey
argument_list|)
return|;
block|}
comment|// For multi-column queries the Bloom filter is checked from the
comment|// seekExact operation.
return|return
literal|true
return|;
default|default:
return|return
literal|true
return|;
block|}
block|}
specifier|public
name|boolean
name|passesDeleteFamilyBloomFilter
parameter_list|(
name|byte
index|[]
name|row
parameter_list|,
name|int
name|rowOffset
parameter_list|,
name|int
name|rowLen
parameter_list|)
block|{
comment|// Cache Bloom filter as a local variable in case it is set to null by
comment|// another thread on an IO error.
name|BloomFilter
name|bloomFilter
init|=
name|this
operator|.
name|deleteFamilyBloomFilter
decl_stmt|;
comment|// Empty file or there is no delete family at all
if|if
condition|(
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getEntryCount
argument_list|()
operator|==
literal|0
operator|||
name|deleteFamilyCnt
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|bloomFilter
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
try|try
block|{
if|if
condition|(
operator|!
name|bloomFilter
operator|.
name|supportsAutoLoading
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|bloomFilter
operator|.
name|contains
argument_list|(
name|row
argument_list|,
name|rowOffset
argument_list|,
name|rowLen
argument_list|,
literal|null
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Bad Delete Family bloom filter data -- proceeding without"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|setDeleteFamilyBloomFilterFaulty
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * A method for checking Bloom filters. Called directly from    * StoreFileScanner in case of a multi-column query.    *    * @return True if passes    */
specifier|public
name|boolean
name|passesGeneralRowBloomFilter
parameter_list|(
name|byte
index|[]
name|row
parameter_list|,
name|int
name|rowOffset
parameter_list|,
name|int
name|rowLen
parameter_list|)
block|{
name|BloomFilter
name|bloomFilter
init|=
name|this
operator|.
name|generalBloomFilter
decl_stmt|;
if|if
condition|(
name|bloomFilter
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// Used in ROW bloom
name|byte
index|[]
name|key
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|rowOffset
operator|!=
literal|0
operator|||
name|rowLen
operator|!=
name|row
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"For row-only Bloom filters the row "
operator|+
literal|"must occupy the whole array"
argument_list|)
throw|;
block|}
name|key
operator|=
name|row
expr_stmt|;
return|return
name|checkGeneralBloomFilter
argument_list|(
name|key
argument_list|,
literal|null
argument_list|,
name|bloomFilter
argument_list|)
return|;
block|}
comment|/**    * A method for checking Bloom filters. Called directly from    * StoreFileScanner in case of a multi-column query.    *    * @param cell    *          the cell to check if present in BloomFilter    * @return True if passes    */
specifier|public
name|boolean
name|passesGeneralRowColBloomFilter
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
name|BloomFilter
name|bloomFilter
init|=
name|this
operator|.
name|generalBloomFilter
decl_stmt|;
if|if
condition|(
name|bloomFilter
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// Used in ROW_COL bloom
name|Cell
name|kvKey
init|=
literal|null
decl_stmt|;
comment|// Already if the incoming key is a fake rowcol key then use it as it is
if|if
condition|(
name|cell
operator|.
name|getTypeByte
argument_list|()
operator|==
name|KeyValue
operator|.
name|Type
operator|.
name|Maximum
operator|.
name|getCode
argument_list|()
operator|&&
name|cell
operator|.
name|getFamilyLength
argument_list|()
operator|==
literal|0
condition|)
block|{
name|kvKey
operator|=
name|cell
expr_stmt|;
block|}
else|else
block|{
name|kvKey
operator|=
name|CellUtil
operator|.
name|createFirstOnRowCol
argument_list|(
name|cell
argument_list|)
expr_stmt|;
block|}
return|return
name|checkGeneralBloomFilter
argument_list|(
literal|null
argument_list|,
name|kvKey
argument_list|,
name|bloomFilter
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|checkGeneralBloomFilter
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|Cell
name|kvKey
parameter_list|,
name|BloomFilter
name|bloomFilter
parameter_list|)
block|{
comment|// Empty file
if|if
condition|(
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getEntryCount
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|HFileBlock
name|bloomBlock
init|=
literal|null
decl_stmt|;
try|try
block|{
name|boolean
name|shouldCheckBloom
decl_stmt|;
name|ByteBuff
name|bloom
decl_stmt|;
if|if
condition|(
name|bloomFilter
operator|.
name|supportsAutoLoading
argument_list|()
condition|)
block|{
name|bloom
operator|=
literal|null
expr_stmt|;
name|shouldCheckBloom
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|bloomBlock
operator|=
name|reader
operator|.
name|getMetaBlock
argument_list|(
name|HFile
operator|.
name|BLOOM_FILTER_DATA_KEY
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|bloom
operator|=
name|bloomBlock
operator|.
name|getBufferWithoutHeader
argument_list|()
expr_stmt|;
name|shouldCheckBloom
operator|=
name|bloom
operator|!=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|shouldCheckBloom
condition|)
block|{
name|boolean
name|exists
decl_stmt|;
comment|// Whether the primary Bloom key is greater than the last Bloom key
comment|// from the file info. For row-column Bloom filters this is not yet
comment|// a sufficient condition to return false.
name|boolean
name|keyIsAfterLast
init|=
operator|(
name|lastBloomKey
operator|!=
literal|null
operator|)
decl_stmt|;
comment|// hbase:meta does not have blooms. So we need not have special interpretation
comment|// of the hbase:meta cells.  We can safely use Bytes.BYTES_RAWCOMPARATOR for ROW Bloom
if|if
condition|(
name|keyIsAfterLast
condition|)
block|{
if|if
condition|(
name|bloomFilterType
operator|==
name|BloomType
operator|.
name|ROW
condition|)
block|{
name|keyIsAfterLast
operator|=
operator|(
name|Bytes
operator|.
name|BYTES_RAWCOMPARATOR
operator|.
name|compare
argument_list|(
name|key
argument_list|,
name|lastBloomKey
argument_list|)
operator|>
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|keyIsAfterLast
operator|=
operator|(
name|CellComparator
operator|.
name|COMPARATOR
operator|.
name|compare
argument_list|(
name|kvKey
argument_list|,
name|lastBloomKeyOnlyKV
argument_list|)
operator|)
operator|>
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bloomFilterType
operator|==
name|BloomType
operator|.
name|ROWCOL
condition|)
block|{
comment|// Since a Row Delete is essentially a DeleteFamily applied to all
comment|// columns, a file might be skipped if using row+col Bloom filter.
comment|// In order to ensure this file is included an additional check is
comment|// required looking only for a row bloom.
name|Cell
name|rowBloomKey
init|=
name|CellUtil
operator|.
name|createFirstOnRow
argument_list|(
name|kvKey
argument_list|)
decl_stmt|;
comment|// hbase:meta does not have blooms. So we need not have special interpretation
comment|// of the hbase:meta cells.  We can safely use Bytes.BYTES_RAWCOMPARATOR for ROW Bloom
if|if
condition|(
name|keyIsAfterLast
operator|&&
operator|(
name|CellComparator
operator|.
name|COMPARATOR
operator|.
name|compare
argument_list|(
name|rowBloomKey
argument_list|,
name|lastBloomKeyOnlyKV
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|exists
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|exists
operator|=
name|bloomFilter
operator|.
name|contains
argument_list|(
name|kvKey
argument_list|,
name|bloom
argument_list|)
operator|||
name|bloomFilter
operator|.
name|contains
argument_list|(
name|rowBloomKey
argument_list|,
name|bloom
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|exists
operator|=
operator|!
name|keyIsAfterLast
operator|&&
name|bloomFilter
operator|.
name|contains
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|length
argument_list|,
name|bloom
argument_list|)
expr_stmt|;
block|}
return|return
name|exists
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error reading bloom filter data -- proceeding without"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|setGeneralBloomFilterFaulty
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Bad bloom filter data -- proceeding without"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|setGeneralBloomFilterFaulty
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
comment|// Return the bloom block so that its ref count can be decremented.
name|reader
operator|.
name|returnBlock
argument_list|(
name|bloomBlock
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Checks whether the given scan rowkey range overlaps with the current storefile's    * @param scan the scan specification. Used to determine the rowkey range.    * @return true if there is overlap, false otherwise    */
specifier|public
name|boolean
name|passesKeyRangeFilter
parameter_list|(
name|Scan
name|scan
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|getFirstKey
argument_list|()
operator|==
literal|null
operator|||
name|this
operator|.
name|getLastKey
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// the file is empty
return|return
literal|false
return|;
block|}
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|scan
operator|.
name|getStartRow
argument_list|()
argument_list|,
name|HConstants
operator|.
name|EMPTY_START_ROW
argument_list|)
operator|&&
name|Bytes
operator|.
name|equals
argument_list|(
name|scan
operator|.
name|getStopRow
argument_list|()
argument_list|,
name|HConstants
operator|.
name|EMPTY_END_ROW
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|byte
index|[]
name|smallestScanRow
init|=
name|scan
operator|.
name|isReversed
argument_list|()
condition|?
name|scan
operator|.
name|getStopRow
argument_list|()
else|:
name|scan
operator|.
name|getStartRow
argument_list|()
decl_stmt|;
name|byte
index|[]
name|largestScanRow
init|=
name|scan
operator|.
name|isReversed
argument_list|()
condition|?
name|scan
operator|.
name|getStartRow
argument_list|()
else|:
name|scan
operator|.
name|getStopRow
argument_list|()
decl_stmt|;
name|Cell
name|firstKeyKV
init|=
name|this
operator|.
name|getFirstKey
argument_list|()
decl_stmt|;
name|Cell
name|lastKeyKV
init|=
name|this
operator|.
name|getLastKey
argument_list|()
decl_stmt|;
name|boolean
name|nonOverLapping
init|=
operator|(
name|getComparator
argument_list|()
operator|.
name|compareRows
argument_list|(
name|firstKeyKV
argument_list|,
name|largestScanRow
argument_list|,
literal|0
argument_list|,
name|largestScanRow
operator|.
name|length
argument_list|)
operator|>
literal|0
operator|&&
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|scan
operator|.
name|isReversed
argument_list|()
condition|?
name|scan
operator|.
name|getStartRow
argument_list|()
else|:
name|scan
operator|.
name|getStopRow
argument_list|()
argument_list|,
name|HConstants
operator|.
name|EMPTY_END_ROW
argument_list|)
operator|)
operator|||
name|getComparator
argument_list|()
operator|.
name|compareRows
argument_list|(
name|lastKeyKV
argument_list|,
name|smallestScanRow
argument_list|,
literal|0
argument_list|,
name|smallestScanRow
operator|.
name|length
argument_list|)
operator|<
literal|0
decl_stmt|;
return|return
operator|!
name|nonOverLapping
return|;
block|}
specifier|public
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|loadFileInfo
parameter_list|()
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|fi
init|=
name|reader
operator|.
name|loadFileInfo
argument_list|()
decl_stmt|;
name|byte
index|[]
name|b
init|=
name|fi
operator|.
name|get
argument_list|(
name|StoreFile
operator|.
name|BLOOM_FILTER_TYPE_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|!=
literal|null
condition|)
block|{
name|bloomFilterType
operator|=
name|BloomType
operator|.
name|valueOf
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lastBloomKey
operator|=
name|fi
operator|.
name|get
argument_list|(
name|StoreFile
operator|.
name|LAST_BLOOM_KEY
argument_list|)
expr_stmt|;
if|if
condition|(
name|bloomFilterType
operator|==
name|BloomType
operator|.
name|ROWCOL
condition|)
block|{
name|lastBloomKeyOnlyKV
operator|=
operator|new
name|KeyValue
operator|.
name|KeyOnlyKeyValue
argument_list|(
name|lastBloomKey
argument_list|,
literal|0
argument_list|,
name|lastBloomKey
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|cnt
init|=
name|fi
operator|.
name|get
argument_list|(
name|StoreFile
operator|.
name|DELETE_FAMILY_COUNT
argument_list|)
decl_stmt|;
if|if
condition|(
name|cnt
operator|!=
literal|null
condition|)
block|{
name|deleteFamilyCnt
operator|=
name|Bytes
operator|.
name|toLong
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
block|}
return|return
name|fi
return|;
block|}
specifier|public
name|void
name|loadBloomfilter
parameter_list|()
block|{
name|this
operator|.
name|loadBloomfilter
argument_list|(
name|BlockType
operator|.
name|GENERAL_BLOOM_META
argument_list|)
expr_stmt|;
name|this
operator|.
name|loadBloomfilter
argument_list|(
name|BlockType
operator|.
name|DELETE_FAMILY_BLOOM_META
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|loadBloomfilter
parameter_list|(
name|BlockType
name|blockType
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|blockType
operator|==
name|BlockType
operator|.
name|GENERAL_BLOOM_META
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|generalBloomFilter
operator|!=
literal|null
condition|)
return|return;
comment|// Bloom has been loaded
name|DataInput
name|bloomMeta
init|=
name|reader
operator|.
name|getGeneralBloomFilterMetadata
argument_list|()
decl_stmt|;
if|if
condition|(
name|bloomMeta
operator|!=
literal|null
condition|)
block|{
comment|// sanity check for NONE Bloom filter
if|if
condition|(
name|bloomFilterType
operator|==
name|BloomType
operator|.
name|NONE
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"valid bloom filter type not found in FileInfo"
argument_list|)
throw|;
block|}
else|else
block|{
name|generalBloomFilter
operator|=
name|BloomFilterFactory
operator|.
name|createFromMeta
argument_list|(
name|bloomMeta
argument_list|,
name|reader
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Loaded "
operator|+
name|bloomFilterType
operator|.
name|toString
argument_list|()
operator|+
literal|" "
operator|+
name|generalBloomFilter
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" metadata for "
operator|+
name|reader
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|blockType
operator|==
name|BlockType
operator|.
name|DELETE_FAMILY_BLOOM_META
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|deleteFamilyBloomFilter
operator|!=
literal|null
condition|)
return|return;
comment|// Bloom has been loaded
name|DataInput
name|bloomMeta
init|=
name|reader
operator|.
name|getDeleteBloomFilterMetadata
argument_list|()
decl_stmt|;
if|if
condition|(
name|bloomMeta
operator|!=
literal|null
condition|)
block|{
name|deleteFamilyBloomFilter
operator|=
name|BloomFilterFactory
operator|.
name|createFromMeta
argument_list|(
name|bloomMeta
argument_list|,
name|reader
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Loaded Delete Family Bloom ("
operator|+
name|deleteFamilyBloomFilter
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|") metadata for "
operator|+
name|reader
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Block Type: "
operator|+
name|blockType
operator|.
name|toString
argument_list|()
operator|+
literal|"is not supported for Bloom filter"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error reading bloom filter meta for "
operator|+
name|blockType
operator|+
literal|" -- proceeding without"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|setBloomFilterFaulty
argument_list|(
name|blockType
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Bad bloom filter meta "
operator|+
name|blockType
operator|+
literal|" -- proceeding without"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|setBloomFilterFaulty
argument_list|(
name|blockType
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|setBloomFilterFaulty
parameter_list|(
name|BlockType
name|blockType
parameter_list|)
block|{
if|if
condition|(
name|blockType
operator|==
name|BlockType
operator|.
name|GENERAL_BLOOM_META
condition|)
block|{
name|setGeneralBloomFilterFaulty
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|blockType
operator|==
name|BlockType
operator|.
name|DELETE_FAMILY_BLOOM_META
condition|)
block|{
name|setDeleteFamilyBloomFilterFaulty
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * The number of Bloom filter entries in this store file, or an estimate    * thereof, if the Bloom filter is not loaded. This always returns an upper    * bound of the number of Bloom filter entries.    *    * @return an estimate of the number of Bloom filter entries in this file    */
specifier|public
name|long
name|getFilterEntries
parameter_list|()
block|{
return|return
name|generalBloomFilter
operator|!=
literal|null
condition|?
name|generalBloomFilter
operator|.
name|getKeyCount
argument_list|()
else|:
name|reader
operator|.
name|getEntries
argument_list|()
return|;
block|}
specifier|public
name|void
name|setGeneralBloomFilterFaulty
parameter_list|()
block|{
name|generalBloomFilter
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
name|void
name|setDeleteFamilyBloomFilterFaulty
parameter_list|()
block|{
name|this
operator|.
name|deleteFamilyBloomFilter
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
name|Cell
name|getLastKey
parameter_list|()
block|{
return|return
name|reader
operator|.
name|getLastKey
argument_list|()
return|;
block|}
specifier|public
name|byte
index|[]
name|getLastRowKey
parameter_list|()
block|{
return|return
name|reader
operator|.
name|getLastRowKey
argument_list|()
return|;
block|}
specifier|public
name|Cell
name|midkey
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|reader
operator|.
name|midkey
argument_list|()
return|;
block|}
specifier|public
name|long
name|length
parameter_list|()
block|{
return|return
name|reader
operator|.
name|length
argument_list|()
return|;
block|}
specifier|public
name|long
name|getTotalUncompressedBytes
parameter_list|()
block|{
return|return
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getTotalUncompressedBytes
argument_list|()
return|;
block|}
specifier|public
name|long
name|getEntries
parameter_list|()
block|{
return|return
name|reader
operator|.
name|getEntries
argument_list|()
return|;
block|}
specifier|public
name|long
name|getDeleteFamilyCnt
parameter_list|()
block|{
return|return
name|deleteFamilyCnt
return|;
block|}
specifier|public
name|Cell
name|getFirstKey
parameter_list|()
block|{
return|return
name|reader
operator|.
name|getFirstKey
argument_list|()
return|;
block|}
specifier|public
name|long
name|indexSize
parameter_list|()
block|{
return|return
name|reader
operator|.
name|indexSize
argument_list|()
return|;
block|}
specifier|public
name|BloomType
name|getBloomFilterType
parameter_list|()
block|{
return|return
name|this
operator|.
name|bloomFilterType
return|;
block|}
specifier|public
name|long
name|getSequenceID
parameter_list|()
block|{
return|return
name|sequenceID
return|;
block|}
specifier|public
name|void
name|setSequenceID
parameter_list|(
name|long
name|sequenceID
parameter_list|)
block|{
name|this
operator|.
name|sequenceID
operator|=
name|sequenceID
expr_stmt|;
block|}
specifier|public
name|void
name|setBulkLoaded
parameter_list|(
name|boolean
name|bulkLoadResult
parameter_list|)
block|{
name|this
operator|.
name|bulkLoadResult
operator|=
name|bulkLoadResult
expr_stmt|;
block|}
specifier|public
name|boolean
name|isBulkLoaded
parameter_list|()
block|{
return|return
name|this
operator|.
name|bulkLoadResult
return|;
block|}
name|BloomFilter
name|getGeneralBloomFilter
parameter_list|()
block|{
return|return
name|generalBloomFilter
return|;
block|}
name|long
name|getUncompressedDataIndexSize
parameter_list|()
block|{
return|return
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getUncompressedDataIndexSize
argument_list|()
return|;
block|}
specifier|public
name|long
name|getTotalBloomSize
parameter_list|()
block|{
if|if
condition|(
name|generalBloomFilter
operator|==
literal|null
condition|)
return|return
literal|0
return|;
return|return
name|generalBloomFilter
operator|.
name|getByteSize
argument_list|()
return|;
block|}
specifier|public
name|int
name|getHFileVersion
parameter_list|()
block|{
return|return
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getMajorVersion
argument_list|()
return|;
block|}
specifier|public
name|int
name|getHFileMinorVersion
parameter_list|()
block|{
return|return
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getMinorVersion
argument_list|()
return|;
block|}
specifier|public
name|HFile
operator|.
name|Reader
name|getHFileReader
parameter_list|()
block|{
return|return
name|reader
return|;
block|}
name|void
name|disableBloomFilterForTesting
parameter_list|()
block|{
name|generalBloomFilter
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|deleteFamilyBloomFilter
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
name|long
name|getMaxTimestamp
parameter_list|()
block|{
return|return
name|timeRange
operator|==
literal|null
condition|?
name|TimeRange
operator|.
name|INITIAL_MAX_TIMESTAMP
else|:
name|timeRange
operator|.
name|getMax
argument_list|()
return|;
block|}
name|boolean
name|isSkipResetSeqId
parameter_list|()
block|{
return|return
name|skipResetSeqId
return|;
block|}
name|void
name|setSkipResetSeqId
parameter_list|(
name|boolean
name|skipResetSeqId
parameter_list|)
block|{
name|this
operator|.
name|skipResetSeqId
operator|=
name|skipResetSeqId
expr_stmt|;
block|}
block|}
end_class

end_unit

