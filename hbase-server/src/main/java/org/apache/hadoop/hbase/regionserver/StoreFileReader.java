begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HStoreFile
operator|.
name|BLOOM_FILTER_PARAM_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HStoreFile
operator|.
name|BLOOM_FILTER_TYPE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HStoreFile
operator|.
name|DELETE_FAMILY_COUNT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HStoreFile
operator|.
name|LAST_BLOOM_KEY
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Cell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseInterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|PrivateCellUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Scan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|FSDataInputStreamWrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|TimeRange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|BlockType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|CacheConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|HFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|HFileBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|io
operator|.
name|hfile
operator|.
name|HFileScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|nio
operator|.
name|ByteBuff
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|BloomFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|BloomFilterFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * Reader for a StoreFile.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
name|HBaseInterfaceAudience
operator|.
name|PHOENIX
argument_list|)
annotation|@
name|InterfaceStability
operator|.
name|Evolving
specifier|public
class|class
name|StoreFileReader
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|StoreFileReader
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|protected
name|BloomFilter
name|generalBloomFilter
init|=
literal|null
decl_stmt|;
specifier|protected
name|BloomFilter
name|deleteFamilyBloomFilter
init|=
literal|null
decl_stmt|;
specifier|protected
name|BloomType
name|bloomFilterType
decl_stmt|;
specifier|private
specifier|final
name|HFile
operator|.
name|Reader
name|reader
decl_stmt|;
specifier|protected
name|long
name|sequenceID
init|=
operator|-
literal|1
decl_stmt|;
specifier|protected
name|TimeRange
name|timeRange
init|=
literal|null
decl_stmt|;
specifier|private
name|byte
index|[]
name|lastBloomKey
decl_stmt|;
specifier|private
name|long
name|deleteFamilyCnt
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|boolean
name|bulkLoadResult
init|=
literal|false
decl_stmt|;
specifier|private
name|KeyValue
operator|.
name|KeyOnlyKeyValue
name|lastBloomKeyOnlyKV
init|=
literal|null
decl_stmt|;
specifier|private
name|boolean
name|skipResetSeqId
init|=
literal|true
decl_stmt|;
specifier|private
name|int
name|prefixLength
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|byte
index|[]
name|delimiter
init|=
literal|null
decl_stmt|;
comment|// Counter that is incremented every time a scanner is created on the
comment|// store file. It is decremented when the scan on the store file is
comment|// done. All StoreFileReader for the same StoreFile will share this counter.
specifier|private
specifier|final
name|AtomicInteger
name|refCount
decl_stmt|;
comment|// indicate that whether this StoreFileReader is shared, i.e., used for pread. If not, we will
comment|// close the internal reader when readCompleted is called.
annotation|@
name|VisibleForTesting
specifier|final
name|boolean
name|shared
decl_stmt|;
specifier|private
specifier|volatile
name|Listener
name|listener
decl_stmt|;
specifier|private
name|boolean
name|closed
init|=
literal|false
decl_stmt|;
specifier|private
name|StoreFileReader
parameter_list|(
name|HFile
operator|.
name|Reader
name|reader
parameter_list|,
name|AtomicInteger
name|refCount
parameter_list|,
name|boolean
name|shared
parameter_list|)
block|{
name|this
operator|.
name|reader
operator|=
name|reader
expr_stmt|;
name|bloomFilterType
operator|=
name|BloomType
operator|.
name|NONE
expr_stmt|;
name|this
operator|.
name|refCount
operator|=
name|refCount
expr_stmt|;
name|this
operator|.
name|shared
operator|=
name|shared
expr_stmt|;
block|}
specifier|public
name|StoreFileReader
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|CacheConfig
name|cacheConf
parameter_list|,
name|boolean
name|primaryReplicaStoreFile
parameter_list|,
name|AtomicInteger
name|refCount
parameter_list|,
name|boolean
name|shared
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|HFile
operator|.
name|createReader
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|cacheConf
argument_list|,
name|primaryReplicaStoreFile
argument_list|,
name|conf
argument_list|)
argument_list|,
name|refCount
argument_list|,
name|shared
argument_list|)
expr_stmt|;
block|}
specifier|public
name|StoreFileReader
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|FSDataInputStreamWrapper
name|in
parameter_list|,
name|long
name|size
parameter_list|,
name|CacheConfig
name|cacheConf
parameter_list|,
name|boolean
name|primaryReplicaStoreFile
parameter_list|,
name|AtomicInteger
name|refCount
parameter_list|,
name|boolean
name|shared
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|HFile
operator|.
name|createReader
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|in
argument_list|,
name|size
argument_list|,
name|cacheConf
argument_list|,
name|primaryReplicaStoreFile
argument_list|,
name|conf
argument_list|)
argument_list|,
name|refCount
argument_list|,
name|shared
argument_list|)
expr_stmt|;
block|}
name|void
name|copyFields
parameter_list|(
name|StoreFileReader
name|reader
parameter_list|)
block|{
name|this
operator|.
name|generalBloomFilter
operator|=
name|reader
operator|.
name|generalBloomFilter
expr_stmt|;
name|this
operator|.
name|deleteFamilyBloomFilter
operator|=
name|reader
operator|.
name|deleteFamilyBloomFilter
expr_stmt|;
name|this
operator|.
name|bloomFilterType
operator|=
name|reader
operator|.
name|bloomFilterType
expr_stmt|;
name|this
operator|.
name|sequenceID
operator|=
name|reader
operator|.
name|sequenceID
expr_stmt|;
name|this
operator|.
name|timeRange
operator|=
name|reader
operator|.
name|timeRange
expr_stmt|;
name|this
operator|.
name|lastBloomKey
operator|=
name|reader
operator|.
name|lastBloomKey
expr_stmt|;
name|this
operator|.
name|bulkLoadResult
operator|=
name|reader
operator|.
name|bulkLoadResult
expr_stmt|;
name|this
operator|.
name|lastBloomKeyOnlyKV
operator|=
name|reader
operator|.
name|lastBloomKeyOnlyKV
expr_stmt|;
name|this
operator|.
name|skipResetSeqId
operator|=
name|reader
operator|.
name|skipResetSeqId
expr_stmt|;
name|this
operator|.
name|prefixLength
operator|=
name|reader
operator|.
name|prefixLength
expr_stmt|;
name|this
operator|.
name|delimiter
operator|=
name|reader
operator|.
name|delimiter
expr_stmt|;
block|}
specifier|public
name|boolean
name|isPrimaryReplicaReader
parameter_list|()
block|{
return|return
name|reader
operator|.
name|isPrimaryReplicaReader
argument_list|()
return|;
block|}
comment|/**    * ONLY USE DEFAULT CONSTRUCTOR FOR UNIT TESTS    */
annotation|@
name|VisibleForTesting
name|StoreFileReader
parameter_list|()
block|{
name|this
operator|.
name|refCount
operator|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|reader
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|shared
operator|=
literal|false
expr_stmt|;
block|}
specifier|public
name|CellComparator
name|getComparator
parameter_list|()
block|{
return|return
name|reader
operator|.
name|getComparator
argument_list|()
return|;
block|}
comment|/**    * Get a scanner to scan over this StoreFile.    * @param cacheBlocks should this scanner cache blocks?    * @param pread use pread (for highly concurrent small readers)    * @param isCompaction is scanner being used for compaction?    * @param scannerOrder Order of this scanner relative to other scanners. See    *          {@link KeyValueScanner#getScannerOrder()}.    * @param canOptimizeForNonNullColumn {@code true} if we can make sure there is no null column,    *          otherwise {@code false}. This is a hint for optimization.    * @return a scanner    */
specifier|public
name|StoreFileScanner
name|getStoreFileScanner
parameter_list|(
name|boolean
name|cacheBlocks
parameter_list|,
name|boolean
name|pread
parameter_list|,
name|boolean
name|isCompaction
parameter_list|,
name|long
name|readPt
parameter_list|,
name|long
name|scannerOrder
parameter_list|,
name|boolean
name|canOptimizeForNonNullColumn
parameter_list|)
block|{
return|return
operator|new
name|StoreFileScanner
argument_list|(
name|this
argument_list|,
name|getScanner
argument_list|(
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|)
argument_list|,
operator|!
name|isCompaction
argument_list|,
name|reader
operator|.
name|hasMVCCInfo
argument_list|()
argument_list|,
name|readPt
argument_list|,
name|scannerOrder
argument_list|,
name|canOptimizeForNonNullColumn
argument_list|)
return|;
block|}
comment|/**    * Return the ref count associated with the reader whenever a scanner associated with the    * reader is opened.    */
name|int
name|getRefCount
parameter_list|()
block|{
return|return
name|refCount
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * Indicate that the scanner has started reading with this reader. We need to increment the ref    * count so reader is not close until some object is holding the lock    */
name|void
name|incrementRefCount
parameter_list|()
block|{
name|refCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|/**    * Indicate that the scanner has finished reading with this reader. We need to decrement the ref    * count, and also, if this is not the common pread reader, we should close it.    */
name|void
name|readCompleted
parameter_list|()
block|{
name|refCount
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|shared
condition|)
block|{
try|try
block|{
name|reader
operator|.
name|close
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to close stream reader"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * @deprecated Do not write further code which depends on this call. Instead    *   use getStoreFileScanner() which uses the StoreFileScanner class/interface    *   which is the preferred way to scan a store with higher level concepts.    *    * @param cacheBlocks should we cache the blocks?    * @param pread use pread (for concurrent small readers)    * @return the underlying HFileScanner    */
annotation|@
name|Deprecated
specifier|public
name|HFileScanner
name|getScanner
parameter_list|(
name|boolean
name|cacheBlocks
parameter_list|,
name|boolean
name|pread
parameter_list|)
block|{
return|return
name|getScanner
argument_list|(
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * @deprecated Do not write further code which depends on this call. Instead    *   use getStoreFileScanner() which uses the StoreFileScanner class/interface    *   which is the preferred way to scan a store with higher level concepts.    *    * @param cacheBlocks    *          should we cache the blocks?    * @param pread    *          use pread (for concurrent small readers)    * @param isCompaction    *          is scanner being used for compaction?    * @return the underlying HFileScanner    */
annotation|@
name|Deprecated
specifier|public
name|HFileScanner
name|getScanner
parameter_list|(
name|boolean
name|cacheBlocks
parameter_list|,
name|boolean
name|pread
parameter_list|,
name|boolean
name|isCompaction
parameter_list|)
block|{
return|return
name|reader
operator|.
name|getScanner
argument_list|(
name|cacheBlocks
argument_list|,
name|pread
argument_list|,
name|isCompaction
argument_list|)
return|;
block|}
specifier|public
name|void
name|close
parameter_list|(
name|boolean
name|evictOnClose
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|closed
condition|)
block|{
return|return;
block|}
name|reader
operator|.
name|close
argument_list|(
name|evictOnClose
argument_list|)
expr_stmt|;
name|closed
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
name|listener
operator|.
name|storeFileReaderClosed
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Check if this storeFile may contain keys within the TimeRange that    * have not expired (i.e. not older than oldestUnexpiredTS).    * @param tr the timeRange to restrict    * @param oldestUnexpiredTS the oldest timestamp that is not expired, as    *          determined by the column family's TTL    * @return false if queried keys definitely don't exist in this StoreFile    */
name|boolean
name|passesTimerangeFilter
parameter_list|(
name|TimeRange
name|tr
parameter_list|,
name|long
name|oldestUnexpiredTS
parameter_list|)
block|{
return|return
name|this
operator|.
name|timeRange
operator|==
literal|null
condition|?
literal|true
else|:
name|this
operator|.
name|timeRange
operator|.
name|includesTimeRange
argument_list|(
name|tr
argument_list|)
operator|&&
name|this
operator|.
name|timeRange
operator|.
name|getMax
argument_list|()
operator|>=
name|oldestUnexpiredTS
return|;
block|}
comment|/**    * Checks whether the given scan passes the Bloom filter (if present). Only    * checks Bloom filters for single-row or single-row-column scans. Bloom    * filter checking for multi-gets is implemented as part of the store    * scanner system (see {@link StoreFileScanner#seek(Cell)} and uses    * the lower-level API {@link #passesGeneralRowBloomFilter(byte[], int, int)}    * and {@link #passesGeneralRowColBloomFilter(Cell)}.    *    * @param scan the scan specification. Used to determine the row, and to    *          check whether this is a single-row ("get") scan.    * @param columns the set of columns. Only used for row-column Bloom    *          filters.    * @return true if the scan with the given column set passes the Bloom    *         filter, or if the Bloom filter is not applicable for the scan.    *         False if the Bloom filter is applicable and the scan fails it.    */
name|boolean
name|passesBloomFilter
parameter_list|(
name|Scan
name|scan
parameter_list|,
specifier|final
name|SortedSet
argument_list|<
name|byte
index|[]
argument_list|>
name|columns
parameter_list|)
block|{
name|byte
index|[]
name|row
init|=
name|scan
operator|.
name|getStartRow
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|this
operator|.
name|bloomFilterType
condition|)
block|{
case|case
name|ROW
case|:
if|if
condition|(
operator|!
name|scan
operator|.
name|isGetScan
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|passesGeneralRowBloomFilter
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
name|row
operator|.
name|length
argument_list|)
return|;
case|case
name|ROWCOL
case|:
if|if
condition|(
operator|!
name|scan
operator|.
name|isGetScan
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|columns
operator|!=
literal|null
operator|&&
name|columns
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|byte
index|[]
name|column
init|=
name|columns
operator|.
name|first
argument_list|()
decl_stmt|;
comment|// create the required fake key
name|Cell
name|kvKey
init|=
name|PrivateCellUtil
operator|.
name|createFirstOnRow
argument_list|(
name|row
argument_list|,
name|HConstants
operator|.
name|EMPTY_BYTE_ARRAY
argument_list|,
name|column
argument_list|)
decl_stmt|;
return|return
name|passesGeneralRowColBloomFilter
argument_list|(
name|kvKey
argument_list|)
return|;
block|}
comment|// For multi-column queries the Bloom filter is checked from the
comment|// seekExact operation.
return|return
literal|true
return|;
case|case
name|ROWPREFIX_FIXED_LENGTH
case|:
return|return
name|passesGeneralRowPrefixBloomFilter
argument_list|(
name|scan
argument_list|)
return|;
case|case
name|ROWPREFIX_DELIMITED
case|:
return|return
name|passesGeneralDelimitedRowPrefixBloomFilter
argument_list|(
name|scan
argument_list|)
return|;
default|default:
return|return
literal|true
return|;
block|}
block|}
specifier|public
name|boolean
name|passesDeleteFamilyBloomFilter
parameter_list|(
name|byte
index|[]
name|row
parameter_list|,
name|int
name|rowOffset
parameter_list|,
name|int
name|rowLen
parameter_list|)
block|{
comment|// Cache Bloom filter as a local variable in case it is set to null by
comment|// another thread on an IO error.
name|BloomFilter
name|bloomFilter
init|=
name|this
operator|.
name|deleteFamilyBloomFilter
decl_stmt|;
comment|// Empty file or there is no delete family at all
if|if
condition|(
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getEntryCount
argument_list|()
operator|==
literal|0
operator|||
name|deleteFamilyCnt
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|bloomFilter
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
try|try
block|{
if|if
condition|(
operator|!
name|bloomFilter
operator|.
name|supportsAutoLoading
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|bloomFilter
operator|.
name|contains
argument_list|(
name|row
argument_list|,
name|rowOffset
argument_list|,
name|rowLen
argument_list|,
literal|null
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Bad Delete Family bloom filter data -- proceeding without"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|setDeleteFamilyBloomFilterFaulty
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * A method for checking Bloom filters. Called directly from    * StoreFileScanner in case of a multi-column query.    *    * @return True if passes    */
specifier|private
name|boolean
name|passesGeneralRowBloomFilter
parameter_list|(
name|byte
index|[]
name|row
parameter_list|,
name|int
name|rowOffset
parameter_list|,
name|int
name|rowLen
parameter_list|)
block|{
name|BloomFilter
name|bloomFilter
init|=
name|this
operator|.
name|generalBloomFilter
decl_stmt|;
if|if
condition|(
name|bloomFilter
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// Used in ROW bloom
name|byte
index|[]
name|key
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|rowOffset
operator|!=
literal|0
operator|||
name|rowLen
operator|!=
name|row
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"For row-only Bloom filters the row must occupy the whole array"
argument_list|)
throw|;
block|}
name|key
operator|=
name|row
expr_stmt|;
return|return
name|checkGeneralBloomFilter
argument_list|(
name|key
argument_list|,
literal|null
argument_list|,
name|bloomFilter
argument_list|)
return|;
block|}
comment|/**    * A method for checking Bloom filters. Called directly from    * StoreFileScanner in case of a multi-column query.    *    * @param cell    *          the cell to check if present in BloomFilter    * @return True if passes    */
specifier|public
name|boolean
name|passesGeneralRowColBloomFilter
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
name|BloomFilter
name|bloomFilter
init|=
name|this
operator|.
name|generalBloomFilter
decl_stmt|;
if|if
condition|(
name|bloomFilter
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// Used in ROW_COL bloom
name|Cell
name|kvKey
init|=
literal|null
decl_stmt|;
comment|// Already if the incoming key is a fake rowcol key then use it as it is
if|if
condition|(
name|cell
operator|.
name|getTypeByte
argument_list|()
operator|==
name|KeyValue
operator|.
name|Type
operator|.
name|Maximum
operator|.
name|getCode
argument_list|()
operator|&&
name|cell
operator|.
name|getFamilyLength
argument_list|()
operator|==
literal|0
condition|)
block|{
name|kvKey
operator|=
name|cell
expr_stmt|;
block|}
else|else
block|{
name|kvKey
operator|=
name|PrivateCellUtil
operator|.
name|createFirstOnRowCol
argument_list|(
name|cell
argument_list|)
expr_stmt|;
block|}
return|return
name|checkGeneralBloomFilter
argument_list|(
literal|null
argument_list|,
name|kvKey
argument_list|,
name|bloomFilter
argument_list|)
return|;
block|}
comment|/**    * A method for checking Bloom filters. Called directly from    * StoreFileScanner in case of a multi-column query.    *    * @return True if passes    */
specifier|private
name|boolean
name|passesGeneralRowPrefixBloomFilter
parameter_list|(
name|Scan
name|scan
parameter_list|)
block|{
name|BloomFilter
name|bloomFilter
init|=
name|this
operator|.
name|generalBloomFilter
decl_stmt|;
if|if
condition|(
name|bloomFilter
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
name|byte
index|[]
name|row
init|=
name|scan
operator|.
name|getStartRow
argument_list|()
decl_stmt|;
name|byte
index|[]
name|rowPrefix
decl_stmt|;
if|if
condition|(
name|scan
operator|.
name|isGetScan
argument_list|()
condition|)
block|{
name|rowPrefix
operator|=
name|Bytes
operator|.
name|copy
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|prefixLength
argument_list|,
name|row
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// For non-get scans
comment|// Find out the common prefix of startRow and stopRow.
name|int
name|commonLength
init|=
name|Bytes
operator|.
name|findCommonPrefix
argument_list|(
name|scan
operator|.
name|getStartRow
argument_list|()
argument_list|,
name|scan
operator|.
name|getStopRow
argument_list|()
argument_list|,
name|scan
operator|.
name|getStartRow
argument_list|()
operator|.
name|length
argument_list|,
name|scan
operator|.
name|getStopRow
argument_list|()
operator|.
name|length
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// startRow and stopRow don't have the common prefix.
comment|// Or the common prefix length is less than prefixLength
if|if
condition|(
name|commonLength
operator|<=
literal|0
operator|||
name|commonLength
operator|<
name|prefixLength
condition|)
block|{
return|return
literal|true
return|;
block|}
name|rowPrefix
operator|=
name|Bytes
operator|.
name|copy
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
name|prefixLength
argument_list|)
expr_stmt|;
block|}
return|return
name|checkGeneralBloomFilter
argument_list|(
name|rowPrefix
argument_list|,
literal|null
argument_list|,
name|bloomFilter
argument_list|)
return|;
block|}
comment|/**    * A method for checking Bloom filters. Called directly from    * StoreFileScanner in case of a multi-column query.    *    * @return True if passes    */
specifier|private
name|boolean
name|passesGeneralDelimitedRowPrefixBloomFilter
parameter_list|(
name|Scan
name|scan
parameter_list|)
block|{
name|BloomFilter
name|bloomFilter
init|=
name|this
operator|.
name|generalBloomFilter
decl_stmt|;
if|if
condition|(
name|bloomFilter
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
name|byte
index|[]
name|row
init|=
name|scan
operator|.
name|getStartRow
argument_list|()
decl_stmt|;
name|byte
index|[]
name|rowPrefix
decl_stmt|;
if|if
condition|(
name|scan
operator|.
name|isGetScan
argument_list|()
condition|)
block|{
name|int
name|rowPrefixLength
init|=
name|Bytes
operator|.
name|indexOf
argument_list|(
name|row
argument_list|,
name|delimiter
argument_list|)
decl_stmt|;
if|if
condition|(
name|rowPrefixLength
operator|<=
literal|0
condition|)
block|{
name|rowPrefix
operator|=
name|row
expr_stmt|;
block|}
else|else
block|{
name|rowPrefix
operator|=
name|Bytes
operator|.
name|copy
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
name|rowPrefixLength
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// For non-get scans
comment|// If startRow does not contain delimiter, return true directly.
name|int
name|startRowPrefixLength
init|=
name|Bytes
operator|.
name|indexOf
argument_list|(
name|row
argument_list|,
name|delimiter
argument_list|)
decl_stmt|;
if|if
condition|(
name|startRowPrefixLength
operator|<=
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// If stopRow does not have the same prefix as startRow, return true directly.
name|int
name|commonLength
init|=
name|Bytes
operator|.
name|findCommonPrefix
argument_list|(
name|scan
operator|.
name|getStartRow
argument_list|()
argument_list|,
name|scan
operator|.
name|getStopRow
argument_list|()
argument_list|,
name|startRowPrefixLength
argument_list|,
name|scan
operator|.
name|getStopRow
argument_list|()
operator|.
name|length
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|commonLength
operator|<
name|startRowPrefixLength
condition|)
block|{
return|return
literal|true
return|;
block|}
name|rowPrefix
operator|=
name|Bytes
operator|.
name|copy
argument_list|(
name|row
argument_list|,
literal|0
argument_list|,
name|startRowPrefixLength
argument_list|)
expr_stmt|;
block|}
return|return
name|checkGeneralBloomFilter
argument_list|(
name|rowPrefix
argument_list|,
literal|null
argument_list|,
name|bloomFilter
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|checkGeneralBloomFilter
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|Cell
name|kvKey
parameter_list|,
name|BloomFilter
name|bloomFilter
parameter_list|)
block|{
comment|// Empty file
if|if
condition|(
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getEntryCount
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|HFileBlock
name|bloomBlock
init|=
literal|null
decl_stmt|;
try|try
block|{
name|boolean
name|shouldCheckBloom
decl_stmt|;
name|ByteBuff
name|bloom
decl_stmt|;
if|if
condition|(
name|bloomFilter
operator|.
name|supportsAutoLoading
argument_list|()
condition|)
block|{
name|bloom
operator|=
literal|null
expr_stmt|;
name|shouldCheckBloom
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|bloomBlock
operator|=
name|reader
operator|.
name|getMetaBlock
argument_list|(
name|HFile
operator|.
name|BLOOM_FILTER_DATA_KEY
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|bloom
operator|=
name|bloomBlock
operator|.
name|getBufferWithoutHeader
argument_list|()
expr_stmt|;
name|shouldCheckBloom
operator|=
name|bloom
operator|!=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|shouldCheckBloom
condition|)
block|{
name|boolean
name|exists
decl_stmt|;
comment|// Whether the primary Bloom key is greater than the last Bloom key
comment|// from the file info. For row-column Bloom filters this is not yet
comment|// a sufficient condition to return false.
name|boolean
name|keyIsAfterLast
init|=
operator|(
name|lastBloomKey
operator|!=
literal|null
operator|)
decl_stmt|;
comment|// hbase:meta does not have blooms. So we need not have special interpretation
comment|// of the hbase:meta cells.  We can safely use Bytes.BYTES_RAWCOMPARATOR for ROW Bloom
if|if
condition|(
name|keyIsAfterLast
condition|)
block|{
if|if
condition|(
name|bloomFilterType
operator|==
name|BloomType
operator|.
name|ROWCOL
condition|)
block|{
name|keyIsAfterLast
operator|=
operator|(
name|CellComparator
operator|.
name|getInstance
argument_list|()
operator|.
name|compare
argument_list|(
name|kvKey
argument_list|,
name|lastBloomKeyOnlyKV
argument_list|)
operator|)
operator|>
literal|0
expr_stmt|;
block|}
else|else
block|{
name|keyIsAfterLast
operator|=
operator|(
name|Bytes
operator|.
name|BYTES_RAWCOMPARATOR
operator|.
name|compare
argument_list|(
name|key
argument_list|,
name|lastBloomKey
argument_list|)
operator|>
literal|0
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bloomFilterType
operator|==
name|BloomType
operator|.
name|ROWCOL
condition|)
block|{
comment|// Since a Row Delete is essentially a DeleteFamily applied to all
comment|// columns, a file might be skipped if using row+col Bloom filter.
comment|// In order to ensure this file is included an additional check is
comment|// required looking only for a row bloom.
name|Cell
name|rowBloomKey
init|=
name|PrivateCellUtil
operator|.
name|createFirstOnRow
argument_list|(
name|kvKey
argument_list|)
decl_stmt|;
comment|// hbase:meta does not have blooms. So we need not have special interpretation
comment|// of the hbase:meta cells.  We can safely use Bytes.BYTES_RAWCOMPARATOR for ROW Bloom
if|if
condition|(
name|keyIsAfterLast
operator|&&
operator|(
name|CellComparator
operator|.
name|getInstance
argument_list|()
operator|.
name|compare
argument_list|(
name|rowBloomKey
argument_list|,
name|lastBloomKeyOnlyKV
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|exists
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|exists
operator|=
name|bloomFilter
operator|.
name|contains
argument_list|(
name|kvKey
argument_list|,
name|bloom
argument_list|,
name|BloomType
operator|.
name|ROWCOL
argument_list|)
operator|||
name|bloomFilter
operator|.
name|contains
argument_list|(
name|rowBloomKey
argument_list|,
name|bloom
argument_list|,
name|BloomType
operator|.
name|ROWCOL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|exists
operator|=
operator|!
name|keyIsAfterLast
operator|&&
name|bloomFilter
operator|.
name|contains
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|length
argument_list|,
name|bloom
argument_list|)
expr_stmt|;
block|}
return|return
name|exists
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error reading bloom filter data -- proceeding without"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|setGeneralBloomFilterFaulty
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Bad bloom filter data -- proceeding without"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|setGeneralBloomFilterFaulty
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
comment|// Return the bloom block so that its ref count can be decremented.
name|reader
operator|.
name|returnBlock
argument_list|(
name|bloomBlock
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Checks whether the given scan rowkey range overlaps with the current storefile's    * @param scan the scan specification. Used to determine the rowkey range.    * @return true if there is overlap, false otherwise    */
specifier|public
name|boolean
name|passesKeyRangeFilter
parameter_list|(
name|Scan
name|scan
parameter_list|)
block|{
name|Optional
argument_list|<
name|Cell
argument_list|>
name|firstKeyKV
init|=
name|this
operator|.
name|getFirstKey
argument_list|()
decl_stmt|;
name|Optional
argument_list|<
name|Cell
argument_list|>
name|lastKeyKV
init|=
name|this
operator|.
name|getLastKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|firstKeyKV
operator|.
name|isPresent
argument_list|()
operator|||
operator|!
name|lastKeyKV
operator|.
name|isPresent
argument_list|()
condition|)
block|{
comment|// the file is empty
return|return
literal|false
return|;
block|}
if|if
condition|(
name|Bytes
operator|.
name|equals
argument_list|(
name|scan
operator|.
name|getStartRow
argument_list|()
argument_list|,
name|HConstants
operator|.
name|EMPTY_START_ROW
argument_list|)
operator|&&
name|Bytes
operator|.
name|equals
argument_list|(
name|scan
operator|.
name|getStopRow
argument_list|()
argument_list|,
name|HConstants
operator|.
name|EMPTY_END_ROW
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|byte
index|[]
name|smallestScanRow
init|=
name|scan
operator|.
name|isReversed
argument_list|()
condition|?
name|scan
operator|.
name|getStopRow
argument_list|()
else|:
name|scan
operator|.
name|getStartRow
argument_list|()
decl_stmt|;
name|byte
index|[]
name|largestScanRow
init|=
name|scan
operator|.
name|isReversed
argument_list|()
condition|?
name|scan
operator|.
name|getStartRow
argument_list|()
else|:
name|scan
operator|.
name|getStopRow
argument_list|()
decl_stmt|;
name|boolean
name|nonOverLapping
init|=
operator|(
name|getComparator
argument_list|()
operator|.
name|compareRows
argument_list|(
name|firstKeyKV
operator|.
name|get
argument_list|()
argument_list|,
name|largestScanRow
argument_list|,
literal|0
argument_list|,
name|largestScanRow
operator|.
name|length
argument_list|)
operator|>
literal|0
operator|&&
operator|!
name|Bytes
operator|.
name|equals
argument_list|(
name|scan
operator|.
name|isReversed
argument_list|()
condition|?
name|scan
operator|.
name|getStartRow
argument_list|()
else|:
name|scan
operator|.
name|getStopRow
argument_list|()
argument_list|,
name|HConstants
operator|.
name|EMPTY_END_ROW
argument_list|)
operator|)
operator|||
name|getComparator
argument_list|()
operator|.
name|compareRows
argument_list|(
name|lastKeyKV
operator|.
name|get
argument_list|()
argument_list|,
name|smallestScanRow
argument_list|,
literal|0
argument_list|,
name|smallestScanRow
operator|.
name|length
argument_list|)
operator|<
literal|0
decl_stmt|;
return|return
operator|!
name|nonOverLapping
return|;
block|}
specifier|public
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|loadFileInfo
parameter_list|()
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|fi
init|=
name|reader
operator|.
name|loadFileInfo
argument_list|()
decl_stmt|;
name|byte
index|[]
name|b
init|=
name|fi
operator|.
name|get
argument_list|(
name|BLOOM_FILTER_TYPE_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|!=
literal|null
condition|)
block|{
name|bloomFilterType
operator|=
name|BloomType
operator|.
name|valueOf
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|p
init|=
name|fi
operator|.
name|get
argument_list|(
name|BLOOM_FILTER_PARAM_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|bloomFilterType
operator|==
name|BloomType
operator|.
name|ROWPREFIX_FIXED_LENGTH
condition|)
block|{
name|prefixLength
operator|=
name|Bytes
operator|.
name|toInt
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bloomFilterType
operator|==
name|BloomType
operator|.
name|ROWPREFIX_DELIMITED
condition|)
block|{
name|delimiter
operator|=
name|p
expr_stmt|;
block|}
name|lastBloomKey
operator|=
name|fi
operator|.
name|get
argument_list|(
name|LAST_BLOOM_KEY
argument_list|)
expr_stmt|;
if|if
condition|(
name|bloomFilterType
operator|==
name|BloomType
operator|.
name|ROWCOL
condition|)
block|{
name|lastBloomKeyOnlyKV
operator|=
operator|new
name|KeyValue
operator|.
name|KeyOnlyKeyValue
argument_list|(
name|lastBloomKey
argument_list|,
literal|0
argument_list|,
name|lastBloomKey
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|cnt
init|=
name|fi
operator|.
name|get
argument_list|(
name|DELETE_FAMILY_COUNT
argument_list|)
decl_stmt|;
if|if
condition|(
name|cnt
operator|!=
literal|null
condition|)
block|{
name|deleteFamilyCnt
operator|=
name|Bytes
operator|.
name|toLong
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
block|}
return|return
name|fi
return|;
block|}
specifier|public
name|void
name|loadBloomfilter
parameter_list|()
block|{
name|this
operator|.
name|loadBloomfilter
argument_list|(
name|BlockType
operator|.
name|GENERAL_BLOOM_META
argument_list|)
expr_stmt|;
name|this
operator|.
name|loadBloomfilter
argument_list|(
name|BlockType
operator|.
name|DELETE_FAMILY_BLOOM_META
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|loadBloomfilter
parameter_list|(
name|BlockType
name|blockType
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|blockType
operator|==
name|BlockType
operator|.
name|GENERAL_BLOOM_META
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|generalBloomFilter
operator|!=
literal|null
condition|)
return|return;
comment|// Bloom has been loaded
name|DataInput
name|bloomMeta
init|=
name|reader
operator|.
name|getGeneralBloomFilterMetadata
argument_list|()
decl_stmt|;
if|if
condition|(
name|bloomMeta
operator|!=
literal|null
condition|)
block|{
comment|// sanity check for NONE Bloom filter
if|if
condition|(
name|bloomFilterType
operator|==
name|BloomType
operator|.
name|NONE
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"valid bloom filter type not found in FileInfo"
argument_list|)
throw|;
block|}
else|else
block|{
name|generalBloomFilter
operator|=
name|BloomFilterFactory
operator|.
name|createFromMeta
argument_list|(
name|bloomMeta
argument_list|,
name|reader
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Loaded "
operator|+
name|bloomFilterType
operator|.
name|toString
argument_list|()
operator|+
literal|" "
operator|+
name|generalBloomFilter
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" metadata for "
operator|+
name|reader
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|blockType
operator|==
name|BlockType
operator|.
name|DELETE_FAMILY_BLOOM_META
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|deleteFamilyBloomFilter
operator|!=
literal|null
condition|)
return|return;
comment|// Bloom has been loaded
name|DataInput
name|bloomMeta
init|=
name|reader
operator|.
name|getDeleteBloomFilterMetadata
argument_list|()
decl_stmt|;
if|if
condition|(
name|bloomMeta
operator|!=
literal|null
condition|)
block|{
name|deleteFamilyBloomFilter
operator|=
name|BloomFilterFactory
operator|.
name|createFromMeta
argument_list|(
name|bloomMeta
argument_list|,
name|reader
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Loaded Delete Family Bloom ("
operator|+
name|deleteFamilyBloomFilter
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|") metadata for "
operator|+
name|reader
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Block Type: "
operator|+
name|blockType
operator|.
name|toString
argument_list|()
operator|+
literal|"is not supported for Bloom filter"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error reading bloom filter meta for "
operator|+
name|blockType
operator|+
literal|" -- proceeding without"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|setBloomFilterFaulty
argument_list|(
name|blockType
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Bad bloom filter meta "
operator|+
name|blockType
operator|+
literal|" -- proceeding without"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|setBloomFilterFaulty
argument_list|(
name|blockType
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|setBloomFilterFaulty
parameter_list|(
name|BlockType
name|blockType
parameter_list|)
block|{
if|if
condition|(
name|blockType
operator|==
name|BlockType
operator|.
name|GENERAL_BLOOM_META
condition|)
block|{
name|setGeneralBloomFilterFaulty
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|blockType
operator|==
name|BlockType
operator|.
name|DELETE_FAMILY_BLOOM_META
condition|)
block|{
name|setDeleteFamilyBloomFilterFaulty
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * The number of Bloom filter entries in this store file, or an estimate    * thereof, if the Bloom filter is not loaded. This always returns an upper    * bound of the number of Bloom filter entries.    *    * @return an estimate of the number of Bloom filter entries in this file    */
specifier|public
name|long
name|getFilterEntries
parameter_list|()
block|{
return|return
name|generalBloomFilter
operator|!=
literal|null
condition|?
name|generalBloomFilter
operator|.
name|getKeyCount
argument_list|()
else|:
name|reader
operator|.
name|getEntries
argument_list|()
return|;
block|}
specifier|public
name|void
name|setGeneralBloomFilterFaulty
parameter_list|()
block|{
name|generalBloomFilter
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
name|void
name|setDeleteFamilyBloomFilterFaulty
parameter_list|()
block|{
name|this
operator|.
name|deleteFamilyBloomFilter
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
name|Optional
argument_list|<
name|Cell
argument_list|>
name|getLastKey
parameter_list|()
block|{
return|return
name|reader
operator|.
name|getLastKey
argument_list|()
return|;
block|}
specifier|public
name|Optional
argument_list|<
name|byte
index|[]
argument_list|>
name|getLastRowKey
parameter_list|()
block|{
return|return
name|reader
operator|.
name|getLastRowKey
argument_list|()
return|;
block|}
specifier|public
name|Optional
argument_list|<
name|Cell
argument_list|>
name|midKey
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|reader
operator|.
name|midKey
argument_list|()
return|;
block|}
specifier|public
name|long
name|length
parameter_list|()
block|{
return|return
name|reader
operator|.
name|length
argument_list|()
return|;
block|}
specifier|public
name|long
name|getTotalUncompressedBytes
parameter_list|()
block|{
return|return
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getTotalUncompressedBytes
argument_list|()
return|;
block|}
specifier|public
name|long
name|getEntries
parameter_list|()
block|{
return|return
name|reader
operator|.
name|getEntries
argument_list|()
return|;
block|}
specifier|public
name|long
name|getDeleteFamilyCnt
parameter_list|()
block|{
return|return
name|deleteFamilyCnt
return|;
block|}
specifier|public
name|Optional
argument_list|<
name|Cell
argument_list|>
name|getFirstKey
parameter_list|()
block|{
return|return
name|reader
operator|.
name|getFirstKey
argument_list|()
return|;
block|}
specifier|public
name|long
name|indexSize
parameter_list|()
block|{
return|return
name|reader
operator|.
name|indexSize
argument_list|()
return|;
block|}
specifier|public
name|BloomType
name|getBloomFilterType
parameter_list|()
block|{
return|return
name|this
operator|.
name|bloomFilterType
return|;
block|}
specifier|public
name|long
name|getSequenceID
parameter_list|()
block|{
return|return
name|sequenceID
return|;
block|}
specifier|public
name|void
name|setSequenceID
parameter_list|(
name|long
name|sequenceID
parameter_list|)
block|{
name|this
operator|.
name|sequenceID
operator|=
name|sequenceID
expr_stmt|;
block|}
specifier|public
name|void
name|setBulkLoaded
parameter_list|(
name|boolean
name|bulkLoadResult
parameter_list|)
block|{
name|this
operator|.
name|bulkLoadResult
operator|=
name|bulkLoadResult
expr_stmt|;
block|}
specifier|public
name|boolean
name|isBulkLoaded
parameter_list|()
block|{
return|return
name|this
operator|.
name|bulkLoadResult
return|;
block|}
name|BloomFilter
name|getGeneralBloomFilter
parameter_list|()
block|{
return|return
name|generalBloomFilter
return|;
block|}
name|long
name|getUncompressedDataIndexSize
parameter_list|()
block|{
return|return
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getUncompressedDataIndexSize
argument_list|()
return|;
block|}
specifier|public
name|long
name|getTotalBloomSize
parameter_list|()
block|{
if|if
condition|(
name|generalBloomFilter
operator|==
literal|null
condition|)
return|return
literal|0
return|;
return|return
name|generalBloomFilter
operator|.
name|getByteSize
argument_list|()
return|;
block|}
specifier|public
name|int
name|getHFileVersion
parameter_list|()
block|{
return|return
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getMajorVersion
argument_list|()
return|;
block|}
specifier|public
name|int
name|getHFileMinorVersion
parameter_list|()
block|{
return|return
name|reader
operator|.
name|getTrailer
argument_list|()
operator|.
name|getMinorVersion
argument_list|()
return|;
block|}
specifier|public
name|HFile
operator|.
name|Reader
name|getHFileReader
parameter_list|()
block|{
return|return
name|reader
return|;
block|}
name|void
name|disableBloomFilterForTesting
parameter_list|()
block|{
name|generalBloomFilter
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|deleteFamilyBloomFilter
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
name|long
name|getMaxTimestamp
parameter_list|()
block|{
return|return
name|timeRange
operator|==
literal|null
condition|?
name|TimeRange
operator|.
name|INITIAL_MAX_TIMESTAMP
else|:
name|timeRange
operator|.
name|getMax
argument_list|()
return|;
block|}
name|boolean
name|isSkipResetSeqId
parameter_list|()
block|{
return|return
name|skipResetSeqId
return|;
block|}
name|void
name|setSkipResetSeqId
parameter_list|(
name|boolean
name|skipResetSeqId
parameter_list|)
block|{
name|this
operator|.
name|skipResetSeqId
operator|=
name|skipResetSeqId
expr_stmt|;
block|}
specifier|public
name|void
name|setListener
parameter_list|(
name|Listener
name|listener
parameter_list|)
block|{
name|this
operator|.
name|listener
operator|=
name|listener
expr_stmt|;
block|}
specifier|public
interface|interface
name|Listener
block|{
name|void
name|storeFileReaderClosed
parameter_list|(
name|StoreFileReader
name|reader
parameter_list|)
function_decl|;
block|}
specifier|public
name|int
name|getPrefixLength
parameter_list|()
block|{
return|return
name|prefixLength
return|;
block|}
specifier|public
name|byte
index|[]
name|getDelimiter
parameter_list|()
block|{
return|return
name|delimiter
return|;
block|}
block|}
end_class

end_unit

