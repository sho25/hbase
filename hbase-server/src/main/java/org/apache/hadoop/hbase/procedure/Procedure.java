begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|errorhandling
operator|.
name|ForeignException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|errorhandling
operator|.
name|ForeignExceptionDispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|errorhandling
operator|.
name|ForeignExceptionListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|errorhandling
operator|.
name|ForeignExceptionSnare
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|errorhandling
operator|.
name|TimeoutExceptionInjector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  * A globally-barriered distributed procedure.  This class encapsulates state and methods for  * tracking and managing a distributed procedure, as well as aborting if any member encounters  * a problem or if a cancellation is requested.  *<p>  * All procedures first attempt to reach a barrier point with the {@link #sendGlobalBarrierStart()}  * method.  The procedure contacts all members and waits for all subprocedures to execute  * {@link Subprocedure#acquireBarrier} to acquire its local piece of the global barrier and then  * send acquisition info back to the coordinator.  If all acquisitions at subprocedures succeed,  * the coordinator then will call {@link #sendGlobalBarrierReached()}.  This notifies members to  * execute the {@link Subprocedure#insideBarrier()} method.  The procedure is blocked until all  * {@link Subprocedure#insideBarrier} executions complete at the members.  When  * {@link Subprocedure#insideBarrier} completes at each member, the member sends notification to  * the coordinator.  Once all members complete, the coordinator calls  * {@link #sendGlobalBarrierComplete()}.  *<p>  * If errors are encountered remotely, they are forwarded to the coordinator, and  * {@link Subprocedure#cleanup(Exception)} is called.  *<p>  * Each Procedure and each Subprocedure enforces a time limit on the execution time. If the time  * limit expires before the procedure completes the {@link TimeoutExceptionInjector} will trigger  * an {@link ForeignException} to abort the procedure.  This is particularly useful for situations  * when running a distributed {@link Subprocedure} so participants can avoid blocking for extreme  * amounts of time if one of the participants fails or takes a really long time (e.g. GC pause).  *<p>  * Users should generally not directly create or subclass instances of this.  They are created  * for them implicitly via {@link ProcedureCoordinator#startProcedure(ForeignExceptionDispatcher,  * String, byte[], List)}}  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|Procedure
implements|implements
name|Callable
argument_list|<
name|Void
argument_list|>
implements|,
name|ForeignExceptionListener
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|Procedure
operator|.
name|class
argument_list|)
decl_stmt|;
comment|//
comment|// Arguments and naming
comment|//
comment|// Name of the procedure
specifier|final
specifier|private
name|String
name|procName
decl_stmt|;
comment|// Arguments for this procedure execution
specifier|final
specifier|private
name|byte
index|[]
name|args
decl_stmt|;
comment|//
comment|// Execution State
comment|//
comment|/** latch for waiting until all members have acquire in barrier state */
specifier|final
name|CountDownLatch
name|acquiredBarrierLatch
decl_stmt|;
comment|/** latch for waiting until all members have executed and released their in barrier state */
specifier|final
name|CountDownLatch
name|releasedBarrierLatch
decl_stmt|;
comment|/** latch for waiting until a procedure has completed */
specifier|final
name|CountDownLatch
name|completedLatch
decl_stmt|;
comment|/** monitor to check for errors */
specifier|private
specifier|final
name|ForeignExceptionDispatcher
name|monitor
decl_stmt|;
comment|//
comment|// Execution Timeout Handling.
comment|//
comment|/** frequency to check for errors (ms) */
specifier|protected
specifier|final
name|long
name|wakeFrequency
decl_stmt|;
specifier|protected
specifier|final
name|TimeoutExceptionInjector
name|timeoutInjector
decl_stmt|;
comment|//
comment|// Members' and Coordinator's state
comment|//
comment|/** lock to prevent nodes from acquiring and then releasing before we can track them */
specifier|private
name|Object
name|joinBarrierLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|acquiringMembers
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|inBarrierMembers
decl_stmt|;
specifier|private
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|byte
index|[]
argument_list|>
name|dataFromFinishedMembers
decl_stmt|;
specifier|private
name|ProcedureCoordinator
name|coord
decl_stmt|;
comment|/**    * Creates a procedure. (FOR TESTING)    *    * {@link Procedure} state to be run by a {@link ProcedureCoordinator}.    * @param coord coordinator to call back to for general errors (e.g.    *          {@link ProcedureCoordinator#rpcConnectionFailure(String, IOException)}).    * @param monitor error monitor to check for external errors    * @param wakeFreq frequency to check for errors while waiting    * @param timeout amount of time to allow the procedure to run before cancelling    * @param procName name of the procedure instance    * @param args argument data associated with the procedure instance    * @param expectedMembers names of the expected members    */
specifier|public
name|Procedure
parameter_list|(
name|ProcedureCoordinator
name|coord
parameter_list|,
name|ForeignExceptionDispatcher
name|monitor
parameter_list|,
name|long
name|wakeFreq
parameter_list|,
name|long
name|timeout
parameter_list|,
name|String
name|procName
parameter_list|,
name|byte
index|[]
name|args
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|expectedMembers
parameter_list|)
block|{
name|this
operator|.
name|coord
operator|=
name|coord
expr_stmt|;
name|this
operator|.
name|acquiringMembers
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|expectedMembers
argument_list|)
expr_stmt|;
name|this
operator|.
name|inBarrierMembers
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|acquiringMembers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|dataFromFinishedMembers
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|procName
operator|=
name|procName
expr_stmt|;
name|this
operator|.
name|args
operator|=
name|args
expr_stmt|;
name|this
operator|.
name|monitor
operator|=
name|monitor
expr_stmt|;
name|this
operator|.
name|wakeFrequency
operator|=
name|wakeFreq
expr_stmt|;
name|int
name|count
init|=
name|expectedMembers
operator|.
name|size
argument_list|()
decl_stmt|;
name|this
operator|.
name|acquiredBarrierLatch
operator|=
operator|new
name|CountDownLatch
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|this
operator|.
name|releasedBarrierLatch
operator|=
operator|new
name|CountDownLatch
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|this
operator|.
name|completedLatch
operator|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|this
operator|.
name|timeoutInjector
operator|=
operator|new
name|TimeoutExceptionInjector
argument_list|(
name|monitor
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a procedure.    *    * Users should generally not directly create instances of this.  They are created them    * implicitly via {@link ProcedureCoordinator#createProcedure(ForeignExceptionDispatcher,    * String, byte[], List)}}    *    * @param coord coordinator to call back to for general errors (e.g.    *          {@link ProcedureCoordinator#rpcConnectionFailure(String, IOException)}).    * @param wakeFreq frequency to check for errors while waiting    * @param timeout amount of time to allow the procedure to run before cancelling    * @param procName name of the procedure instance    * @param args argument data associated with the procedure instance    * @param expectedMembers names of the expected members    */
specifier|public
name|Procedure
parameter_list|(
name|ProcedureCoordinator
name|coord
parameter_list|,
name|long
name|wakeFreq
parameter_list|,
name|long
name|timeout
parameter_list|,
name|String
name|procName
parameter_list|,
name|byte
index|[]
name|args
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|expectedMembers
parameter_list|)
block|{
name|this
argument_list|(
name|coord
argument_list|,
operator|new
name|ForeignExceptionDispatcher
argument_list|()
argument_list|,
name|wakeFreq
argument_list|,
name|timeout
argument_list|,
name|procName
argument_list|,
name|args
argument_list|,
name|expectedMembers
argument_list|)
expr_stmt|;
block|}
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|procName
return|;
block|}
comment|/**    * @return String of the procedure members both trying to enter the barrier and already in barrier    */
specifier|public
name|String
name|getStatus
parameter_list|()
block|{
name|String
name|waiting
decl_stmt|,
name|done
decl_stmt|;
synchronized|synchronized
init|(
name|joinBarrierLock
init|)
block|{
name|waiting
operator|=
name|acquiringMembers
operator|.
name|toString
argument_list|()
expr_stmt|;
name|done
operator|=
name|inBarrierMembers
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
return|return
literal|"Procedure "
operator|+
name|procName
operator|+
literal|" { waiting="
operator|+
name|waiting
operator|+
literal|" done="
operator|+
name|done
operator|+
literal|" }"
return|;
block|}
comment|/**    * Get the ForeignExceptionDispatcher    * @return the Procedure's monitor.    */
specifier|public
name|ForeignExceptionDispatcher
name|getErrorMonitor
parameter_list|()
block|{
return|return
name|monitor
return|;
block|}
comment|/**    * This call is the main execution thread of the barriered procedure.  It sends messages and    * essentially blocks until all procedure members acquire or later complete but periodically    * checks for foreign exceptions.    */
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"finally"
argument_list|)
specifier|final
specifier|public
name|Void
name|call
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting procedure '"
operator|+
name|procName
operator|+
literal|"'"
argument_list|)
expr_stmt|;
comment|// start the timer
name|timeoutInjector
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// run the procedure
try|try
block|{
comment|// start by checking for error first
name|monitor
operator|.
name|rethrowException
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Procedure '"
operator|+
name|procName
operator|+
literal|"' starting 'acquire'"
argument_list|)
expr_stmt|;
name|sendGlobalBarrierStart
argument_list|()
expr_stmt|;
comment|// wait for all the members to report acquisition
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting for all members to 'acquire'"
argument_list|)
expr_stmt|;
name|waitForLatch
argument_list|(
name|acquiredBarrierLatch
argument_list|,
name|monitor
argument_list|,
name|wakeFrequency
argument_list|,
literal|"acquired"
argument_list|)
expr_stmt|;
name|monitor
operator|.
name|rethrowException
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Procedure '"
operator|+
name|procName
operator|+
literal|"' starting 'in-barrier' execution."
argument_list|)
expr_stmt|;
name|sendGlobalBarrierReached
argument_list|()
expr_stmt|;
comment|// wait for all members to report barrier release
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting for all members to 'release'"
argument_list|)
expr_stmt|;
name|waitForLatch
argument_list|(
name|releasedBarrierLatch
argument_list|,
name|monitor
argument_list|,
name|wakeFrequency
argument_list|,
literal|"released"
argument_list|)
expr_stmt|;
comment|// make sure we didn't get an error during in barrier execution and release
name|monitor
operator|.
name|rethrowException
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Procedure '"
operator|+
name|procName
operator|+
literal|"' execution completed"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|InterruptedException
condition|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
name|String
name|msg
init|=
literal|"Procedure '"
operator|+
name|procName
operator|+
literal|"' execution failed!"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|receive
argument_list|(
operator|new
name|ForeignException
argument_list|(
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Running finish phase."
argument_list|)
expr_stmt|;
name|sendGlobalBarrierComplete
argument_list|()
expr_stmt|;
name|completedLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
comment|// tell the timer we are done, if we get here successfully
name|timeoutInjector
operator|.
name|complete
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Sends a message to Members to create a new {@link Subprocedure} for this Procedure and execute    * the {@link Subprocedure#acquireBarrier} step.    * @throws ForeignException    */
specifier|public
name|void
name|sendGlobalBarrierStart
parameter_list|()
throws|throws
name|ForeignException
block|{
comment|// start the procedure
name|LOG
operator|.
name|debug
argument_list|(
literal|"Starting procedure '"
operator|+
name|procName
operator|+
literal|"', kicking off acquire phase on members."
argument_list|)
expr_stmt|;
try|try
block|{
comment|// send procedure barrier start to specified list of members. cloning the list to avoid
comment|// concurrent modification from the controller setting the prepared nodes
name|coord
operator|.
name|getRpcs
argument_list|()
operator|.
name|sendGlobalBarrierAcquire
argument_list|(
name|this
argument_list|,
name|args
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|this
operator|.
name|acquiringMembers
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|coord
operator|.
name|rpcConnectionFailure
argument_list|(
literal|"Can't reach controller."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ForeignException
argument_list|(
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Sends a message to all members that the global barrier condition has been satisfied.  This    * should only be executed after all members have completed its    * {@link Subprocedure#acquireBarrier()} call successfully.  This triggers the member    * {@link Subprocedure#insideBarrier} method.    * @throws ForeignException    */
specifier|public
name|void
name|sendGlobalBarrierReached
parameter_list|()
throws|throws
name|ForeignException
block|{
try|try
block|{
comment|// trigger to have member run {@link Subprocedure#insideBarrier}
name|coord
operator|.
name|getRpcs
argument_list|()
operator|.
name|sendGlobalBarrierReached
argument_list|(
name|this
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|inBarrierMembers
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|coord
operator|.
name|rpcConnectionFailure
argument_list|(
literal|"Can't reach controller."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Sends a message to members that all {@link Subprocedure#insideBarrier} calls have completed.    * After this executes, the coordinator can assume that any state resources about this barrier    * procedure state has been released.    */
specifier|public
name|void
name|sendGlobalBarrierComplete
parameter_list|()
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Finished coordinator procedure - removing self from list of running procedures"
argument_list|)
expr_stmt|;
try|try
block|{
name|coord
operator|.
name|getRpcs
argument_list|()
operator|.
name|resetMembers
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|coord
operator|.
name|rpcConnectionFailure
argument_list|(
literal|"Failed to reset procedure:"
operator|+
name|procName
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|//
comment|// Call backs from other external processes.
comment|//
comment|/**    * Call back triggered by an individual member upon successful local barrier acquisition    * @param member    */
specifier|public
name|void
name|barrierAcquiredByMember
parameter_list|(
name|String
name|member
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"member: '"
operator|+
name|member
operator|+
literal|"' joining acquired barrier for procedure '"
operator|+
name|procName
operator|+
literal|"' on coordinator"
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|acquiringMembers
operator|.
name|contains
argument_list|(
name|member
argument_list|)
condition|)
block|{
synchronized|synchronized
init|(
name|joinBarrierLock
init|)
block|{
if|if
condition|(
name|this
operator|.
name|acquiringMembers
operator|.
name|remove
argument_list|(
name|member
argument_list|)
condition|)
block|{
name|this
operator|.
name|inBarrierMembers
operator|.
name|add
argument_list|(
name|member
argument_list|)
expr_stmt|;
name|acquiredBarrierLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting on: "
operator|+
name|acquiredBarrierLatch
operator|+
literal|" remaining members to acquire global barrier"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Member "
operator|+
name|member
operator|+
literal|" joined barrier, but we weren't waiting on it to join."
operator|+
literal|" Continuing on."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Call back triggered by a individual member upon successful local in-barrier execution and    * release    * @param member    * @param dataFromMember    */
specifier|public
name|void
name|barrierReleasedByMember
parameter_list|(
name|String
name|member
parameter_list|,
name|byte
index|[]
name|dataFromMember
parameter_list|)
block|{
name|boolean
name|removed
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|joinBarrierLock
init|)
block|{
name|removed
operator|=
name|this
operator|.
name|inBarrierMembers
operator|.
name|remove
argument_list|(
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
name|removed
condition|)
block|{
name|releasedBarrierLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|removed
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Member: '"
operator|+
name|member
operator|+
literal|"' released barrier for procedure'"
operator|+
name|procName
operator|+
literal|"', counting down latch.  Waiting for "
operator|+
name|releasedBarrierLatch
operator|.
name|getCount
argument_list|()
operator|+
literal|" more"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Member: '"
operator|+
name|member
operator|+
literal|"' released barrier for procedure'"
operator|+
name|procName
operator|+
literal|"', but we weren't waiting on it to release!"
argument_list|)
expr_stmt|;
block|}
name|dataFromFinishedMembers
operator|.
name|put
argument_list|(
name|member
argument_list|,
name|dataFromMember
argument_list|)
expr_stmt|;
block|}
comment|/**    * Waits until the entire procedure has globally completed, or has been aborted.  If an    * exception is thrown the procedure may or not have run cleanup to trigger the completion latch    * yet.    * @throws ForeignException    * @throws InterruptedException    */
specifier|public
name|void
name|waitForCompleted
parameter_list|()
throws|throws
name|ForeignException
throws|,
name|InterruptedException
block|{
name|waitForLatch
argument_list|(
name|completedLatch
argument_list|,
name|monitor
argument_list|,
name|wakeFrequency
argument_list|,
name|procName
operator|+
literal|" completed"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Waits until the entire procedure has globally completed, or has been aborted.  If an    * exception is thrown the procedure may or not have run cleanup to trigger the completion latch    * yet.    * @return data returned from procedure members upon successfully completing subprocedure.    * @throws ForeignException    * @throws InterruptedException    */
specifier|public
name|HashMap
argument_list|<
name|String
argument_list|,
name|byte
index|[]
argument_list|>
name|waitForCompletedWithRet
parameter_list|()
throws|throws
name|ForeignException
throws|,
name|InterruptedException
block|{
name|waitForCompleted
argument_list|()
expr_stmt|;
return|return
name|dataFromFinishedMembers
return|;
block|}
comment|/**    * Check if the entire procedure has globally completed, or has been aborted.    * @throws ForeignException    */
specifier|public
name|boolean
name|isCompleted
parameter_list|()
throws|throws
name|ForeignException
block|{
comment|// Rethrow exception if any
name|monitor
operator|.
name|rethrowException
argument_list|()
expr_stmt|;
return|return
operator|(
name|completedLatch
operator|.
name|getCount
argument_list|()
operator|==
literal|0
operator|)
return|;
block|}
comment|/**    * A callback that handles incoming ForeignExceptions.    */
annotation|@
name|Override
specifier|public
name|void
name|receive
parameter_list|(
name|ForeignException
name|e
parameter_list|)
block|{
name|monitor
operator|.
name|receive
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|/**    * Wait for latch to count to zero, ignoring any spurious wake-ups, but waking periodically to    * check for errors    * @param latch latch to wait on    * @param monitor monitor to check for errors while waiting    * @param wakeFrequency frequency to wake up and check for errors (in    *          {@link TimeUnit#MILLISECONDS})    * @param latchDescription description of the latch, for logging    * @throws ForeignException type of error the monitor can throw, if the task fails    * @throws InterruptedException if we are interrupted while waiting on latch    */
specifier|public
specifier|static
name|void
name|waitForLatch
parameter_list|(
name|CountDownLatch
name|latch
parameter_list|,
name|ForeignExceptionSnare
name|monitor
parameter_list|,
name|long
name|wakeFrequency
parameter_list|,
name|String
name|latchDescription
parameter_list|)
throws|throws
name|ForeignException
throws|,
name|InterruptedException
block|{
name|boolean
name|released
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|released
condition|)
block|{
if|if
condition|(
name|monitor
operator|!=
literal|null
condition|)
block|{
name|monitor
operator|.
name|rethrowException
argument_list|()
expr_stmt|;
block|}
comment|/*       ForeignExceptionDispatcher.LOG.debug("Waiting for '" + latchDescription + "' latch. (sleep:"           + wakeFrequency + " ms)"); */
name|released
operator|=
name|latch
operator|.
name|await
argument_list|(
name|wakeFrequency
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
comment|// check error again in case an error raised during last wait
if|if
condition|(
name|monitor
operator|!=
literal|null
condition|)
block|{
name|monitor
operator|.
name|rethrowException
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

