begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|CollectionUtils
operator|.
name|computeIfAbsent
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentNavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentSkipListMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ClockOutOfSyncException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NotServingRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|RegionMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ScheduledChore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerMetricsBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|YouAreDeadException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|ClusterConnection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|RetriesExhaustedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|HBaseRpcController
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|RpcControllerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|assignment
operator|.
name|RegionStates
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|monitoring
operator|.
name|MonitoredTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegionServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|ByteString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|UnsafeByteOperations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|AdminService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClusterStatusProtos
operator|.
name|RegionStoreSequenceIds
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|ClusterStatusProtos
operator|.
name|StoreSequenceId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|FlushedRegionSequenceId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|FlushedSequenceId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|FlushedStoreSequenceId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|RegionServerStatusProtos
operator|.
name|RegionServerStartupRequest
import|;
end_import

begin_comment
comment|/**  * The ServerManager class manages info about region servers.  *<p>  * Maintains lists of online and dead servers.  Processes the startups,  * shutdowns, and deaths of region servers.  *<p>  * Servers are distinguished in two different ways.  A given server has a  * location, specified by hostname and port, and of which there can only be one  * online at any given time.  A server instance is specified by the location  * (hostname and port) as well as the startcode (timestamp from when the server  * was started).  This is used to differentiate a restarted instance of a given  * server from the original instance.  *<p>  * If a sever is known not to be running any more, it is called dead. The dead  * server needs to be handled by a ServerShutdownHandler.  If the handler is not  * enabled yet, the server can't be handled right away so it is queued up.  * After the handler is enabled, the server will be submitted to a handler to handle.  * However, the handler may be just partially enabled.  If so,  * the server cannot be fully processed, and be queued up for further processing.  * A server is fully processed only after the handler is fully enabled  * and has completed the handling.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|ServerManager
block|{
specifier|public
specifier|static
specifier|final
name|String
name|WAIT_ON_REGIONSERVERS_MAXTOSTART
init|=
literal|"hbase.master.wait.on.regionservers.maxtostart"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|WAIT_ON_REGIONSERVERS_MINTOSTART
init|=
literal|"hbase.master.wait.on.regionservers.mintostart"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|WAIT_ON_REGIONSERVERS_TIMEOUT
init|=
literal|"hbase.master.wait.on.regionservers.timeout"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|WAIT_ON_REGIONSERVERS_INTERVAL
init|=
literal|"hbase.master.wait.on.regionservers.interval"
decl_stmt|;
comment|/**    * see HBASE-20727    * if set to true, flushedSequenceIdByRegion and storeFlushedSequenceIdsByRegion    * will be persisted to HDFS and loaded when master restart to speed up log split    */
specifier|public
specifier|static
specifier|final
name|String
name|PERSIST_FLUSHEDSEQUENCEID
init|=
literal|"hbase.master.persist.flushedsequenceid.enabled"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|boolean
name|PERSIST_FLUSHEDSEQUENCEID_DEFAULT
init|=
literal|true
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|FLUSHEDSEQUENCEID_FLUSHER_INTERVAL
init|=
literal|"hbase.master.flushedsequenceid.flusher.interval"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|FLUSHEDSEQUENCEID_FLUSHER_INTERVAL_DEFAULT
init|=
literal|3
operator|*
literal|60
operator|*
literal|60
operator|*
literal|1000
decl_stmt|;
comment|// 3 hours
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ServerManager
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Set if we are to shutdown the cluster.
specifier|private
name|AtomicBoolean
name|clusterShutdown
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|/**    * The last flushed sequence id for a region.    */
specifier|private
specifier|final
name|ConcurrentNavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
name|flushedSequenceIdByRegion
init|=
operator|new
name|ConcurrentSkipListMap
argument_list|<>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
specifier|private
name|boolean
name|persistFlushedSequenceId
init|=
literal|true
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|isFlushSeqIdPersistInProgress
init|=
literal|false
decl_stmt|;
comment|/** File on hdfs to store last flushed sequence id of regions */
specifier|private
specifier|static
specifier|final
name|String
name|LAST_FLUSHED_SEQ_ID_FILE
init|=
literal|".lastflushedseqids"
decl_stmt|;
specifier|private
name|FlushedSequenceIdFlusher
name|flushedSeqIdFlusher
decl_stmt|;
comment|/**    * The last flushed sequence id for a store in a region.    */
specifier|private
specifier|final
name|ConcurrentNavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|ConcurrentNavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
argument_list|>
name|storeFlushedSequenceIdsByRegion
init|=
operator|new
name|ConcurrentSkipListMap
argument_list|<>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
decl_stmt|;
comment|/** Map of registered servers to their current load */
specifier|private
specifier|final
name|ConcurrentNavigableMap
argument_list|<
name|ServerName
argument_list|,
name|ServerMetrics
argument_list|>
name|onlineServers
init|=
operator|new
name|ConcurrentSkipListMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Map of admin interfaces per registered regionserver; these interfaces we use to control    * regionservers out on the cluster    */
specifier|private
specifier|final
name|Map
argument_list|<
name|ServerName
argument_list|,
name|AdminService
operator|.
name|BlockingInterface
argument_list|>
name|rsAdmins
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** List of region servers that should not get any more new regions. */
specifier|private
specifier|final
name|ArrayList
argument_list|<
name|ServerName
argument_list|>
name|drainingServers
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|MasterServices
name|master
decl_stmt|;
specifier|private
specifier|final
name|ClusterConnection
name|connection
decl_stmt|;
specifier|private
specifier|final
name|DeadServer
name|deadservers
init|=
operator|new
name|DeadServer
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|long
name|maxSkew
decl_stmt|;
specifier|private
specifier|final
name|long
name|warningSkew
decl_stmt|;
specifier|private
specifier|final
name|RpcControllerFactory
name|rpcControllerFactory
decl_stmt|;
comment|/**    * Set of region servers which are dead but not processed immediately. If one    * server died before master enables ServerShutdownHandler, the server will be    * added to this set and will be processed through calling    * {@link ServerManager#processQueuedDeadServers()} by master.    *<p>    * A dead server is a server instance known to be dead, not listed in the /hbase/rs    * znode any more. It may have not been submitted to ServerShutdownHandler yet    * because the handler is not enabled.    *<p>    * A dead server, which has been submitted to ServerShutdownHandler while the    * handler is not enabled, is queued up.    *<p>    * So this is a set of region servers known to be dead but not submitted to    * ServerShutdownHandler for processing yet.    */
specifier|private
name|Set
argument_list|<
name|ServerName
argument_list|>
name|queuedDeadServers
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Set of region servers which are dead and submitted to ServerShutdownHandler to process but not    * fully processed immediately.    *<p>    * If one server died before assignment manager finished the failover cleanup, the server will be    * added to this set and will be processed through calling    * {@link ServerManager#processQueuedDeadServers()} by assignment manager.    *<p>    * The Boolean value indicates whether log split is needed inside ServerShutdownHandler    *<p>    * ServerShutdownHandler processes a dead server submitted to the handler after the handler is    * enabled. It may not be able to complete the processing because meta is not yet online or master    * is currently in startup mode. In this case, the dead server will be parked in this set    * temporarily.    */
specifier|private
name|Map
argument_list|<
name|ServerName
argument_list|,
name|Boolean
argument_list|>
name|requeuedDeadServers
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** Listeners that are called on server events. */
specifier|private
name|List
argument_list|<
name|ServerListener
argument_list|>
name|listeners
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Constructor.    */
specifier|public
name|ServerManager
parameter_list|(
specifier|final
name|MasterServices
name|master
parameter_list|)
block|{
name|this
operator|.
name|master
operator|=
name|master
expr_stmt|;
name|Configuration
name|c
init|=
name|master
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|maxSkew
operator|=
name|c
operator|.
name|getLong
argument_list|(
literal|"hbase.master.maxclockskew"
argument_list|,
literal|30000
argument_list|)
expr_stmt|;
name|warningSkew
operator|=
name|c
operator|.
name|getLong
argument_list|(
literal|"hbase.master.warningclockskew"
argument_list|,
literal|10000
argument_list|)
expr_stmt|;
name|this
operator|.
name|connection
operator|=
name|master
operator|.
name|getClusterConnection
argument_list|()
expr_stmt|;
name|this
operator|.
name|rpcControllerFactory
operator|=
name|this
operator|.
name|connection
operator|==
literal|null
condition|?
literal|null
else|:
name|connection
operator|.
name|getRpcControllerFactory
argument_list|()
expr_stmt|;
name|persistFlushedSequenceId
operator|=
name|c
operator|.
name|getBoolean
argument_list|(
name|PERSIST_FLUSHEDSEQUENCEID
argument_list|,
name|PERSIST_FLUSHEDSEQUENCEID_DEFAULT
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add the listener to the notification list.    * @param listener The ServerListener to register    */
specifier|public
name|void
name|registerListener
parameter_list|(
specifier|final
name|ServerListener
name|listener
parameter_list|)
block|{
name|this
operator|.
name|listeners
operator|.
name|add
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
comment|/**    * Remove the listener from the notification list.    * @param listener The ServerListener to unregister    */
specifier|public
name|boolean
name|unregisterListener
parameter_list|(
specifier|final
name|ServerListener
name|listener
parameter_list|)
block|{
return|return
name|this
operator|.
name|listeners
operator|.
name|remove
argument_list|(
name|listener
argument_list|)
return|;
block|}
comment|/**    * Let the server manager know a new regionserver has come online    * @param request the startup request    * @param versionNumber the version of the new regionserver    * @param ia the InetAddress from which request is received    * @return The ServerName we know this server as.    * @throws IOException    */
name|ServerName
name|regionServerStartup
parameter_list|(
name|RegionServerStartupRequest
name|request
parameter_list|,
name|int
name|versionNumber
parameter_list|,
name|InetAddress
name|ia
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Test for case where we get a region startup message from a regionserver
comment|// that has been quickly restarted but whose znode expiration handler has
comment|// not yet run, or from a server whose fail we are currently processing.
comment|// Test its host+port combo is present in serverAddressToServerInfo.  If it
comment|// is, reject the server and trigger its expiration. The next time it comes
comment|// in, it should have been removed from serverAddressToServerInfo and queued
comment|// for processing by ProcessServerShutdown.
specifier|final
name|String
name|hostname
init|=
name|request
operator|.
name|hasUseThisHostnameInstead
argument_list|()
condition|?
name|request
operator|.
name|getUseThisHostnameInstead
argument_list|()
else|:
name|ia
operator|.
name|getHostName
argument_list|()
decl_stmt|;
name|ServerName
name|sn
init|=
name|ServerName
operator|.
name|valueOf
argument_list|(
name|hostname
argument_list|,
name|request
operator|.
name|getPort
argument_list|()
argument_list|,
name|request
operator|.
name|getServerStartCode
argument_list|()
argument_list|)
decl_stmt|;
name|checkClockSkew
argument_list|(
name|sn
argument_list|,
name|request
operator|.
name|getServerCurrentTime
argument_list|()
argument_list|)
expr_stmt|;
name|checkIsDead
argument_list|(
name|sn
argument_list|,
literal|"STARTUP"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkAndRecordNewServer
argument_list|(
name|sn
argument_list|,
name|ServerMetricsBuilder
operator|.
name|of
argument_list|(
name|sn
argument_list|,
name|versionNumber
argument_list|)
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"THIS SHOULD NOT HAPPEN, RegionServerStartup"
operator|+
literal|" could not record the server: "
operator|+
name|sn
argument_list|)
expr_stmt|;
block|}
return|return
name|sn
return|;
block|}
comment|/**    * Updates last flushed sequence Ids for the regions on server sn    * @param sn    * @param hsl    */
specifier|private
name|void
name|updateLastFlushedSequenceIds
parameter_list|(
name|ServerName
name|sn
parameter_list|,
name|ServerMetrics
name|hsl
parameter_list|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|RegionMetrics
argument_list|>
name|entry
range|:
name|hsl
operator|.
name|getRegionMetrics
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|byte
index|[]
name|encodedRegionName
init|=
name|Bytes
operator|.
name|toBytes
argument_list|(
name|RegionInfo
operator|.
name|encodeRegionName
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|Long
name|existingValue
init|=
name|flushedSequenceIdByRegion
operator|.
name|get
argument_list|(
name|encodedRegionName
argument_list|)
decl_stmt|;
name|long
name|l
init|=
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getCompletedSequenceId
argument_list|()
decl_stmt|;
comment|// Don't let smaller sequence ids override greater sequence ids.
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|encodedRegionName
argument_list|)
operator|+
literal|", existingValue="
operator|+
name|existingValue
operator|+
literal|", completeSequenceId="
operator|+
name|l
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|existingValue
operator|==
literal|null
operator|||
operator|(
name|l
operator|!=
name|HConstants
operator|.
name|NO_SEQNUM
operator|&&
name|l
operator|>
name|existingValue
operator|)
condition|)
block|{
name|flushedSequenceIdByRegion
operator|.
name|put
argument_list|(
name|encodedRegionName
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|l
operator|!=
name|HConstants
operator|.
name|NO_SEQNUM
operator|&&
name|l
operator|<
name|existingValue
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"RegionServer "
operator|+
name|sn
operator|+
literal|" indicates a last flushed sequence id ("
operator|+
name|l
operator|+
literal|") that is less than the previous last flushed sequence id ("
operator|+
name|existingValue
operator|+
literal|") for region "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|+
literal|" Ignoring."
argument_list|)
expr_stmt|;
block|}
name|ConcurrentNavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
name|storeFlushedSequenceId
init|=
name|computeIfAbsent
argument_list|(
name|storeFlushedSequenceIdsByRegion
argument_list|,
name|encodedRegionName
argument_list|,
parameter_list|()
lambda|->
operator|new
name|ConcurrentSkipListMap
argument_list|<>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
name|storeSeqId
range|:
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getStoreSequenceId
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|byte
index|[]
name|family
init|=
name|storeSeqId
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|existingValue
operator|=
name|storeFlushedSequenceId
operator|.
name|get
argument_list|(
name|family
argument_list|)
expr_stmt|;
name|l
operator|=
name|storeSeqId
operator|.
name|getValue
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|encodedRegionName
argument_list|)
operator|+
literal|", family="
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|family
argument_list|)
operator|+
literal|", existingValue="
operator|+
name|existingValue
operator|+
literal|", completeSequenceId="
operator|+
name|l
argument_list|)
expr_stmt|;
block|}
comment|// Don't let smaller sequence ids override greater sequence ids.
if|if
condition|(
name|existingValue
operator|==
literal|null
operator|||
operator|(
name|l
operator|!=
name|HConstants
operator|.
name|NO_SEQNUM
operator|&&
name|l
operator|>
name|existingValue
operator|.
name|longValue
argument_list|()
operator|)
condition|)
block|{
name|storeFlushedSequenceId
operator|.
name|put
argument_list|(
name|family
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|void
name|regionServerReport
parameter_list|(
name|ServerName
name|sn
parameter_list|,
name|ServerMetrics
name|sl
parameter_list|)
throws|throws
name|YouAreDeadException
block|{
name|checkIsDead
argument_list|(
name|sn
argument_list|,
literal|"REPORT"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|==
name|this
operator|.
name|onlineServers
operator|.
name|replace
argument_list|(
name|sn
argument_list|,
name|sl
argument_list|)
condition|)
block|{
comment|// Already have this host+port combo and its just different start code?
comment|// Just let the server in. Presume master joining a running cluster.
comment|// recordNewServer is what happens at the end of reportServerStartup.
comment|// The only thing we are skipping is passing back to the regionserver
comment|// the ServerName to use. Here we presume a master has already done
comment|// that so we'll press on with whatever it gave us for ServerName.
if|if
condition|(
operator|!
name|checkAndRecordNewServer
argument_list|(
name|sn
argument_list|,
name|sl
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"RegionServerReport ignored, could not record the server: "
operator|+
name|sn
argument_list|)
expr_stmt|;
return|return;
comment|// Not recorded, so no need to move on
block|}
block|}
name|updateLastFlushedSequenceIds
argument_list|(
name|sn
argument_list|,
name|sl
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check is a server of same host and port already exists,    * if not, or the existed one got a smaller start code, record it.    *    * @param serverName the server to check and record    * @param sl the server load on the server    * @return true if the server is recorded, otherwise, false    */
name|boolean
name|checkAndRecordNewServer
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|,
specifier|final
name|ServerMetrics
name|sl
parameter_list|)
block|{
name|ServerName
name|existingServer
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|onlineServers
init|)
block|{
name|existingServer
operator|=
name|findServerWithSameHostnamePortWithLock
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
if|if
condition|(
name|existingServer
operator|!=
literal|null
operator|&&
operator|(
name|existingServer
operator|.
name|getStartcode
argument_list|()
operator|>
name|serverName
operator|.
name|getStartcode
argument_list|()
operator|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Server serverName="
operator|+
name|serverName
operator|+
literal|" rejected; we already have "
operator|+
name|existingServer
operator|.
name|toString
argument_list|()
operator|+
literal|" registered with same hostname and port"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|recordNewServerWithLock
argument_list|(
name|serverName
argument_list|,
name|sl
argument_list|)
expr_stmt|;
block|}
comment|// Tell our listeners that a server was added
if|if
condition|(
operator|!
name|this
operator|.
name|listeners
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|ServerListener
name|listener
range|:
name|this
operator|.
name|listeners
control|)
block|{
name|listener
operator|.
name|serverAdded
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Note that we assume that same ts means same server, and don't expire in that case.
comment|//  TODO: ts can theoretically collide due to clock shifts, so this is a bit hacky.
if|if
condition|(
name|existingServer
operator|!=
literal|null
operator|&&
operator|(
name|existingServer
operator|.
name|getStartcode
argument_list|()
operator|<
name|serverName
operator|.
name|getStartcode
argument_list|()
operator|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Triggering server recovery; existingServer "
operator|+
name|existingServer
operator|+
literal|" looks stale, new server:"
operator|+
name|serverName
argument_list|)
expr_stmt|;
name|expireServer
argument_list|(
name|existingServer
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Checks if the clock skew between the server and the master. If the clock skew exceeds the    * configured max, it will throw an exception; if it exceeds the configured warning threshold,    * it will log a warning but start normally.    * @param serverName Incoming servers's name    * @param serverCurrentTime    * @throws ClockOutOfSyncException if the skew exceeds the configured max value    */
specifier|private
name|void
name|checkClockSkew
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|,
specifier|final
name|long
name|serverCurrentTime
parameter_list|)
throws|throws
name|ClockOutOfSyncException
block|{
name|long
name|skew
init|=
name|Math
operator|.
name|abs
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|serverCurrentTime
argument_list|)
decl_stmt|;
if|if
condition|(
name|skew
operator|>
name|maxSkew
condition|)
block|{
name|String
name|message
init|=
literal|"Server "
operator|+
name|serverName
operator|+
literal|" has been "
operator|+
literal|"rejected; Reported time is too far out of sync with master.  "
operator|+
literal|"Time difference of "
operator|+
name|skew
operator|+
literal|"ms> max allowed of "
operator|+
name|maxSkew
operator|+
literal|"ms"
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ClockOutOfSyncException
argument_list|(
name|message
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|skew
operator|>
name|warningSkew
condition|)
block|{
name|String
name|message
init|=
literal|"Reported time for server "
operator|+
name|serverName
operator|+
literal|" is out of sync with master "
operator|+
literal|"by "
operator|+
name|skew
operator|+
literal|"ms. (Warning threshold is "
operator|+
name|warningSkew
operator|+
literal|"ms; "
operator|+
literal|"error threshold is "
operator|+
name|maxSkew
operator|+
literal|"ms)"
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * If this server is on the dead list, reject it with a YouAreDeadException.    * If it was dead but came back with a new start code, remove the old entry    * from the dead list.    * @param serverName    * @param what START or REPORT    * @throws org.apache.hadoop.hbase.YouAreDeadException    */
specifier|private
name|void
name|checkIsDead
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|,
specifier|final
name|String
name|what
parameter_list|)
throws|throws
name|YouAreDeadException
block|{
if|if
condition|(
name|this
operator|.
name|deadservers
operator|.
name|isDeadServer
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
comment|// host name, port and start code all match with existing one of the
comment|// dead servers. So, this server must be dead.
name|String
name|message
init|=
literal|"Server "
operator|+
name|what
operator|+
literal|" rejected; currently processing "
operator|+
name|serverName
operator|+
literal|" as dead server"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|YouAreDeadException
argument_list|(
name|message
argument_list|)
throw|;
block|}
comment|// remove dead server with same hostname and port of newly checking in rs after master
comment|// initialization.See HBASE-5916 for more information.
if|if
condition|(
operator|(
name|this
operator|.
name|master
operator|==
literal|null
operator|||
name|this
operator|.
name|master
operator|.
name|isInitialized
argument_list|()
operator|)
operator|&&
name|this
operator|.
name|deadservers
operator|.
name|cleanPreviousInstance
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
comment|// This server has now become alive after we marked it as dead.
comment|// We removed it's previous entry from the dead list to reflect it.
name|LOG
operator|.
name|debug
argument_list|(
name|what
operator|+
literal|":"
operator|+
literal|" Server "
operator|+
name|serverName
operator|+
literal|" came back up,"
operator|+
literal|" removed it from the dead servers list"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Assumes onlineServers is locked.    * @return ServerName with matching hostname and port.    */
specifier|private
name|ServerName
name|findServerWithSameHostnamePortWithLock
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|)
block|{
name|ServerName
name|end
init|=
name|ServerName
operator|.
name|valueOf
argument_list|(
name|serverName
operator|.
name|getHostname
argument_list|()
argument_list|,
name|serverName
operator|.
name|getPort
argument_list|()
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
name|ServerName
name|r
init|=
name|onlineServers
operator|.
name|lowerKey
argument_list|(
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|ServerName
operator|.
name|isSameAddress
argument_list|(
name|r
argument_list|,
name|serverName
argument_list|)
condition|)
block|{
return|return
name|r
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Adds the onlineServers list. onlineServers should be locked.    * @param serverName The remote servers name.    */
annotation|@
name|VisibleForTesting
name|void
name|recordNewServerWithLock
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|,
specifier|final
name|ServerMetrics
name|sl
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Registering regionserver="
operator|+
name|serverName
argument_list|)
expr_stmt|;
name|this
operator|.
name|onlineServers
operator|.
name|put
argument_list|(
name|serverName
argument_list|,
name|sl
argument_list|)
expr_stmt|;
name|this
operator|.
name|rsAdmins
operator|.
name|remove
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|ConcurrentNavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
name|getFlushedSequenceIdByRegion
parameter_list|()
block|{
return|return
name|flushedSequenceIdByRegion
return|;
block|}
specifier|public
name|RegionStoreSequenceIds
name|getLastFlushedSequenceId
parameter_list|(
name|byte
index|[]
name|encodedRegionName
parameter_list|)
block|{
name|RegionStoreSequenceIds
operator|.
name|Builder
name|builder
init|=
name|RegionStoreSequenceIds
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|Long
name|seqId
init|=
name|flushedSequenceIdByRegion
operator|.
name|get
argument_list|(
name|encodedRegionName
argument_list|)
decl_stmt|;
name|builder
operator|.
name|setLastFlushedSequenceId
argument_list|(
name|seqId
operator|!=
literal|null
condition|?
name|seqId
operator|.
name|longValue
argument_list|()
else|:
name|HConstants
operator|.
name|NO_SEQNUM
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
name|storeFlushedSequenceId
init|=
name|storeFlushedSequenceIdsByRegion
operator|.
name|get
argument_list|(
name|encodedRegionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|storeFlushedSequenceId
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
name|entry
range|:
name|storeFlushedSequenceId
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|builder
operator|.
name|addStoreSequenceId
argument_list|(
name|StoreSequenceId
operator|.
name|newBuilder
argument_list|()
operator|.
name|setFamilyName
argument_list|(
name|UnsafeByteOperations
operator|.
name|unsafeWrap
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
operator|.
name|setSequenceId
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|longValue
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**    * @param serverName    * @return ServerMetrics if serverName is known else null    */
specifier|public
name|ServerMetrics
name|getLoad
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|)
block|{
return|return
name|this
operator|.
name|onlineServers
operator|.
name|get
argument_list|(
name|serverName
argument_list|)
return|;
block|}
comment|/**    * Compute the average load across all region servers.    * Currently, this uses a very naive computation - just uses the number of    * regions being served, ignoring stats about number of requests.    * @return the average load    */
specifier|public
name|double
name|getAverageLoad
parameter_list|()
block|{
name|int
name|totalLoad
init|=
literal|0
decl_stmt|;
name|int
name|numServers
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ServerMetrics
name|sl
range|:
name|this
operator|.
name|onlineServers
operator|.
name|values
argument_list|()
control|)
block|{
name|numServers
operator|++
expr_stmt|;
name|totalLoad
operator|+=
name|sl
operator|.
name|getRegionMetrics
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
return|return
name|numServers
operator|==
literal|0
condition|?
literal|0
else|:
operator|(
name|double
operator|)
name|totalLoad
operator|/
operator|(
name|double
operator|)
name|numServers
return|;
block|}
comment|/** @return the count of active regionservers */
specifier|public
name|int
name|countOfRegionServers
parameter_list|()
block|{
comment|// Presumes onlineServers is a concurrent map
return|return
name|this
operator|.
name|onlineServers
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * @return Read-only map of servers to serverinfo    */
specifier|public
name|Map
argument_list|<
name|ServerName
argument_list|,
name|ServerMetrics
argument_list|>
name|getOnlineServers
parameter_list|()
block|{
comment|// Presumption is that iterating the returned Map is OK.
synchronized|synchronized
init|(
name|this
operator|.
name|onlineServers
init|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|this
operator|.
name|onlineServers
argument_list|)
return|;
block|}
block|}
specifier|public
name|DeadServer
name|getDeadServers
parameter_list|()
block|{
return|return
name|this
operator|.
name|deadservers
return|;
block|}
comment|/**    * Checks if any dead servers are currently in progress.    * @return true if any RS are being processed as dead, false if not    */
specifier|public
name|boolean
name|areDeadServersInProgress
parameter_list|()
block|{
return|return
name|this
operator|.
name|deadservers
operator|.
name|areDeadServersInProgress
argument_list|()
return|;
block|}
name|void
name|letRegionServersShutdown
parameter_list|()
block|{
name|long
name|previousLogTime
init|=
literal|0
decl_stmt|;
name|ServerName
name|sn
init|=
name|master
operator|.
name|getServerName
argument_list|()
decl_stmt|;
name|ZKWatcher
name|zkw
init|=
name|master
operator|.
name|getZooKeeper
argument_list|()
decl_stmt|;
name|int
name|onlineServersCt
decl_stmt|;
while|while
condition|(
operator|(
name|onlineServersCt
operator|=
name|onlineServers
operator|.
name|size
argument_list|()
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|>
operator|(
name|previousLogTime
operator|+
literal|1000
operator|)
condition|)
block|{
name|Set
argument_list|<
name|ServerName
argument_list|>
name|remainingServers
init|=
name|onlineServers
operator|.
name|keySet
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|onlineServers
init|)
block|{
if|if
condition|(
name|remainingServers
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|remainingServers
operator|.
name|contains
argument_list|(
name|sn
argument_list|)
condition|)
block|{
comment|// Master will delete itself later.
return|return;
block|}
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|// It's ok here to not sync on onlineServers - merely logging
for|for
control|(
name|ServerName
name|key
range|:
name|remainingServers
control|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting on regionserver(s) "
operator|+
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|previousLogTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|List
argument_list|<
name|String
argument_list|>
name|servers
init|=
name|getRegionServersInZK
argument_list|(
name|zkw
argument_list|)
decl_stmt|;
if|if
condition|(
name|servers
operator|==
literal|null
operator|||
name|servers
operator|.
name|isEmpty
argument_list|()
operator|||
operator|(
name|servers
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|servers
operator|.
name|contains
argument_list|(
name|sn
operator|.
name|toString
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"ZK shows there is only the master self online, exiting now"
argument_list|)
expr_stmt|;
comment|// Master could have lost some ZK events, no need to wait more.
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|ke
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to list regionservers"
argument_list|,
name|ke
argument_list|)
expr_stmt|;
comment|// ZK is malfunctioning, don't hang here
break|break;
block|}
synchronized|synchronized
init|(
name|onlineServers
init|)
block|{
try|try
block|{
if|if
condition|(
name|onlineServersCt
operator|==
name|onlineServers
operator|.
name|size
argument_list|()
condition|)
name|onlineServers
operator|.
name|wait
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{
comment|// continue
block|}
block|}
block|}
block|}
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getRegionServersInZK
parameter_list|(
specifier|final
name|ZKWatcher
name|zkw
parameter_list|)
throws|throws
name|KeeperException
block|{
return|return
name|ZKUtil
operator|.
name|listChildrenNoWatch
argument_list|(
name|zkw
argument_list|,
name|zkw
operator|.
name|getZNodePaths
argument_list|()
operator|.
name|rsZNode
argument_list|)
return|;
block|}
comment|/*    * Expire the passed server.  Add it to list of dead servers and queue a    * shutdown processing.    * @return True if we queued a ServerCrashProcedure else false if we did not (could happen    * for many reasons including the fact that its this server that is going down or we already    * have queued an SCP for this server or SCP processing is currently disabled because we are    * in startup phase).    */
specifier|public
specifier|synchronized
name|boolean
name|expireServer
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|)
block|{
comment|// THIS server is going down... can't handle our own expiration.
if|if
condition|(
name|serverName
operator|.
name|equals
argument_list|(
name|master
operator|.
name|getServerName
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|master
operator|.
name|isAborted
argument_list|()
operator|||
name|master
operator|.
name|isStopped
argument_list|()
operator|)
condition|)
block|{
name|master
operator|.
name|stop
argument_list|(
literal|"We lost our znode?"
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|// No SCP handling during startup.
if|if
condition|(
operator|!
name|master
operator|.
name|isServerCrashProcessingEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Master doesn't enable ServerShutdownHandler during initialization, "
operator|+
literal|"delay expiring server "
operator|+
name|serverName
argument_list|)
expr_stmt|;
comment|// Even though we delay expire of this server, we still need to handle Meta's RIT
comment|// that are against the crashed server; since when we do RecoverMetaProcedure,
comment|// the SCP is not enabled yet and Meta's RIT may be suspend forever. See HBase-19287
name|master
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|handleMetaRITOnCrashedServer
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
name|this
operator|.
name|queuedDeadServers
operator|.
name|add
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
comment|// Return true because though on SCP queued, there will be one queued later.
return|return
literal|true
return|;
block|}
if|if
condition|(
name|this
operator|.
name|deadservers
operator|.
name|isDeadServer
argument_list|(
name|serverName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Expiration called on {} but crash processing already in progress"
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|moveFromOnlineToDeadServers
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
comment|// If cluster is going down, yes, servers are going to be expiring; don't
comment|// process as a dead server
if|if
condition|(
name|isClusterShutdown
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cluster shutdown set; "
operator|+
name|serverName
operator|+
literal|" expired; onlineServers="
operator|+
name|this
operator|.
name|onlineServers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|onlineServers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|master
operator|.
name|stop
argument_list|(
literal|"Cluster shutdown set; onlineServer=0"
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing expiration of "
operator|+
name|serverName
operator|+
literal|" on "
operator|+
name|this
operator|.
name|master
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
name|master
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|submitServerCrash
argument_list|(
name|serverName
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Tell our listeners that a server was removed
if|if
condition|(
operator|!
name|this
operator|.
name|listeners
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|ServerListener
name|listener
range|:
name|this
operator|.
name|listeners
control|)
block|{
name|listener
operator|.
name|serverRemoved
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
block|}
block|}
comment|// trigger a persist of flushedSeqId
if|if
condition|(
name|flushedSeqIdFlusher
operator|!=
literal|null
condition|)
block|{
name|flushedSeqIdFlusher
operator|.
name|triggerNow
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|void
name|moveFromOnlineToDeadServers
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|)
block|{
synchronized|synchronized
init|(
name|onlineServers
init|)
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|onlineServers
operator|.
name|containsKey
argument_list|(
name|sn
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Expiration of "
operator|+
name|sn
operator|+
literal|" but server not online"
argument_list|)
expr_stmt|;
block|}
comment|// Remove the server from the known servers lists and update load info BUT
comment|// add to deadservers first; do this so it'll show in dead servers list if
comment|// not in online servers list.
name|this
operator|.
name|deadservers
operator|.
name|add
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|this
operator|.
name|onlineServers
operator|.
name|remove
argument_list|(
name|sn
argument_list|)
expr_stmt|;
name|onlineServers
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|rsAdmins
operator|.
name|remove
argument_list|(
name|sn
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|synchronized
name|void
name|processDeadServer
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|,
name|boolean
name|shouldSplitWal
parameter_list|)
block|{
comment|// When assignment manager is cleaning up the zookeeper nodes and rebuilding the
comment|// in-memory region states, region servers could be down. Meta table can and
comment|// should be re-assigned, log splitting can be done too. However, it is better to
comment|// wait till the cleanup is done before re-assigning user regions.
comment|//
comment|// We should not wait in the server shutdown handler thread since it can clog
comment|// the handler threads and meta table could not be re-assigned in case
comment|// the corresponding server is down. So we queue them up here instead.
if|if
condition|(
operator|!
name|master
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|isFailoverCleanupDone
argument_list|()
condition|)
block|{
name|requeuedDeadServers
operator|.
name|put
argument_list|(
name|serverName
argument_list|,
name|shouldSplitWal
argument_list|)
expr_stmt|;
return|return;
block|}
name|this
operator|.
name|deadservers
operator|.
name|add
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
name|master
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|submitServerCrash
argument_list|(
name|serverName
argument_list|,
name|shouldSplitWal
argument_list|)
expr_stmt|;
block|}
comment|/**    * Process the servers which died during master's initialization. It will be    * called after HMaster#assignMeta and AssignmentManager#joinCluster.    * */
specifier|synchronized
name|void
name|processQueuedDeadServers
parameter_list|()
block|{
if|if
condition|(
operator|!
name|master
operator|.
name|isServerCrashProcessingEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Master hasn't enabled ServerShutdownHandler"
argument_list|)
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|ServerName
argument_list|>
name|serverIterator
init|=
name|queuedDeadServers
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|serverIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|ServerName
name|tmpServerName
init|=
name|serverIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|expireServer
argument_list|(
name|tmpServerName
argument_list|)
expr_stmt|;
name|serverIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
name|requeuedDeadServers
operator|.
name|remove
argument_list|(
name|tmpServerName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|master
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|isFailoverCleanupDone
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"AssignmentManager failover cleanup not done."
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ServerName
argument_list|,
name|Boolean
argument_list|>
name|entry
range|:
name|requeuedDeadServers
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|processDeadServer
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|requeuedDeadServers
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/*    * Remove the server from the drain list.    */
specifier|public
specifier|synchronized
name|boolean
name|removeServerFromDrainList
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|)
block|{
comment|// Warn if the server (sn) is not online.  ServerName is of the form:
comment|//<hostname> ,<port> ,<startcode>
if|if
condition|(
operator|!
name|this
operator|.
name|isServerOnline
argument_list|(
name|sn
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Server "
operator|+
name|sn
operator|+
literal|" is not currently online. "
operator|+
literal|"Removing from draining list anyway, as requested."
argument_list|)
expr_stmt|;
block|}
comment|// Remove the server from the draining servers lists.
return|return
name|this
operator|.
name|drainingServers
operator|.
name|remove
argument_list|(
name|sn
argument_list|)
return|;
block|}
comment|/**    * Add the server to the drain list.    * @param sn    * @return True if the server is added or the server is already on the drain list.    */
specifier|public
specifier|synchronized
name|boolean
name|addServerToDrainList
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|)
block|{
comment|// Warn if the server (sn) is not online.  ServerName is of the form:
comment|//<hostname> ,<port> ,<startcode>
if|if
condition|(
operator|!
name|this
operator|.
name|isServerOnline
argument_list|(
name|sn
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Server "
operator|+
name|sn
operator|+
literal|" is not currently online. "
operator|+
literal|"Ignoring request to add it to draining list."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Add the server to the draining servers lists, if it's not already in
comment|// it.
if|if
condition|(
name|this
operator|.
name|drainingServers
operator|.
name|contains
argument_list|(
name|sn
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Server "
operator|+
name|sn
operator|+
literal|" is already in the draining server list."
operator|+
literal|"Ignoring request to add it again."
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Server "
operator|+
name|sn
operator|+
literal|" added to draining server list."
argument_list|)
expr_stmt|;
return|return
name|this
operator|.
name|drainingServers
operator|.
name|add
argument_list|(
name|sn
argument_list|)
return|;
block|}
comment|// RPC methods to region servers
specifier|private
name|HBaseRpcController
name|newRpcController
parameter_list|()
block|{
return|return
name|rpcControllerFactory
operator|==
literal|null
condition|?
literal|null
else|:
name|rpcControllerFactory
operator|.
name|newController
argument_list|()
return|;
block|}
comment|/**    * Sends a WARMUP RPC to the specified server to warmup the specified region.    *<p>    * A region server could reject the close request because it either does not    * have the specified region or the region is being split.    * @param server server to warmup a region    * @param region region to  warmup    */
specifier|public
name|void
name|sendRegionWarmup
parameter_list|(
name|ServerName
name|server
parameter_list|,
name|RegionInfo
name|region
parameter_list|)
block|{
if|if
condition|(
name|server
operator|==
literal|null
condition|)
return|return;
try|try
block|{
name|AdminService
operator|.
name|BlockingInterface
name|admin
init|=
name|getRsAdmin
argument_list|(
name|server
argument_list|)
decl_stmt|;
name|HBaseRpcController
name|controller
init|=
name|newRpcController
argument_list|()
decl_stmt|;
name|ProtobufUtil
operator|.
name|warmupRegion
argument_list|(
name|controller
argument_list|,
name|admin
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Received exception in RPC for warmup server:"
operator|+
name|server
operator|+
literal|"region: "
operator|+
name|region
operator|+
literal|"exception: "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Contacts a region server and waits up to timeout ms    * to close the region.  This bypasses the active hmaster.    */
specifier|public
specifier|static
name|void
name|closeRegionSilentlyAndWait
parameter_list|(
name|ClusterConnection
name|connection
parameter_list|,
name|ServerName
name|server
parameter_list|,
name|RegionInfo
name|region
parameter_list|,
name|long
name|timeout
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|AdminService
operator|.
name|BlockingInterface
name|rs
init|=
name|connection
operator|.
name|getAdmin
argument_list|(
name|server
argument_list|)
decl_stmt|;
name|HBaseRpcController
name|controller
init|=
name|connection
operator|.
name|getRpcControllerFactory
argument_list|()
operator|.
name|newController
argument_list|()
decl_stmt|;
try|try
block|{
name|ProtobufUtil
operator|.
name|closeRegion
argument_list|(
name|controller
argument_list|,
name|rs
argument_list|,
name|server
argument_list|,
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception when closing region: "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|long
name|expiration
init|=
name|timeout
operator|+
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
while|while
condition|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|<
name|expiration
condition|)
block|{
name|controller
operator|.
name|reset
argument_list|()
expr_stmt|;
try|try
block|{
name|RegionInfo
name|rsRegion
init|=
name|ProtobufUtil
operator|.
name|getRegionInfo
argument_list|(
name|controller
argument_list|,
name|rs
argument_list|,
name|region
operator|.
name|getRegionName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rsRegion
operator|==
literal|null
condition|)
return|return;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
if|if
condition|(
name|ioe
operator|instanceof
name|NotServingRegionException
condition|)
comment|// no need to retry again
return|return;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception when retrieving regioninfo from: "
operator|+
name|region
operator|.
name|getRegionNameAsString
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Region "
operator|+
name|region
operator|+
literal|" failed to close within"
operator|+
literal|" timeout "
operator|+
name|timeout
argument_list|)
throw|;
block|}
comment|/**    * @param sn    * @return Admin interface for the remote regionserver named<code>sn</code>    * @throws IOException    * @throws RetriesExhaustedException wrapping a ConnectException if failed    */
specifier|public
name|AdminService
operator|.
name|BlockingInterface
name|getRsAdmin
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|)
throws|throws
name|IOException
block|{
name|AdminService
operator|.
name|BlockingInterface
name|admin
init|=
name|this
operator|.
name|rsAdmins
operator|.
name|get
argument_list|(
name|sn
argument_list|)
decl_stmt|;
if|if
condition|(
name|admin
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"New admin connection to "
operator|+
name|sn
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|sn
operator|.
name|equals
argument_list|(
name|master
operator|.
name|getServerName
argument_list|()
argument_list|)
operator|&&
name|master
operator|instanceof
name|HRegionServer
condition|)
block|{
comment|// A master is also a region server now, see HBASE-10569 for details
name|admin
operator|=
operator|(
operator|(
name|HRegionServer
operator|)
name|master
operator|)
operator|.
name|getRSRpcServices
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|admin
operator|=
name|this
operator|.
name|connection
operator|.
name|getAdmin
argument_list|(
name|sn
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|rsAdmins
operator|.
name|put
argument_list|(
name|sn
argument_list|,
name|admin
argument_list|)
expr_stmt|;
block|}
return|return
name|admin
return|;
block|}
comment|/**    * Calculate min necessary to start. This is not an absolute. It is just    * a friction that will cause us hang around a bit longer waiting on    * RegionServers to check-in.    */
specifier|private
name|int
name|getMinToStart
parameter_list|()
block|{
comment|// One server should be enough to get us off the ground.
name|int
name|requiredMinToStart
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|LoadBalancer
operator|.
name|isTablesOnMaster
argument_list|(
name|master
operator|.
name|getConfiguration
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|LoadBalancer
operator|.
name|isSystemTablesOnlyOnMaster
argument_list|(
name|master
operator|.
name|getConfiguration
argument_list|()
argument_list|)
condition|)
block|{
comment|// If Master is carrying regions but NOT user-space regions, it
comment|// still shows as a 'server'. We need at least one more server to check
comment|// in before we can start up so set defaultMinToStart to 2.
name|requiredMinToStart
operator|=
name|requiredMinToStart
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|int
name|minToStart
init|=
name|this
operator|.
name|master
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|WAIT_ON_REGIONSERVERS_MINTOSTART
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|// Ensure we are never less than requiredMinToStart else stuff won't work.
return|return
name|minToStart
operator|==
operator|-
literal|1
operator|||
name|minToStart
operator|<
name|requiredMinToStart
condition|?
name|requiredMinToStart
else|:
name|minToStart
return|;
block|}
comment|/**    * Wait for the region servers to report in.    * We will wait until one of this condition is met:    *  - the master is stopped    *  - the 'hbase.master.wait.on.regionservers.maxtostart' number of    *    region servers is reached    *  - the 'hbase.master.wait.on.regionservers.mintostart' is reached AND    *   there have been no new region server in for    *      'hbase.master.wait.on.regionservers.interval' time AND    *   the 'hbase.master.wait.on.regionservers.timeout' is reached    *    * @throws InterruptedException    */
specifier|public
name|void
name|waitForRegionServers
parameter_list|(
name|MonitoredTask
name|status
parameter_list|)
throws|throws
name|InterruptedException
block|{
specifier|final
name|long
name|interval
init|=
name|this
operator|.
name|master
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getLong
argument_list|(
name|WAIT_ON_REGIONSERVERS_INTERVAL
argument_list|,
literal|1500
argument_list|)
decl_stmt|;
specifier|final
name|long
name|timeout
init|=
name|this
operator|.
name|master
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getLong
argument_list|(
name|WAIT_ON_REGIONSERVERS_TIMEOUT
argument_list|,
literal|4500
argument_list|)
decl_stmt|;
comment|// Min is not an absolute; just a friction making us wait longer on server checkin.
name|int
name|minToStart
init|=
name|getMinToStart
argument_list|()
decl_stmt|;
name|int
name|maxToStart
init|=
name|this
operator|.
name|master
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|WAIT_ON_REGIONSERVERS_MAXTOSTART
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxToStart
operator|<
name|minToStart
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"The value of '%s' (%d) is set less than '%s' (%d), ignoring."
argument_list|,
name|WAIT_ON_REGIONSERVERS_MAXTOSTART
argument_list|,
name|maxToStart
argument_list|,
name|WAIT_ON_REGIONSERVERS_MINTOSTART
argument_list|,
name|minToStart
argument_list|)
argument_list|)
expr_stmt|;
name|maxToStart
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
specifier|final
name|long
name|startTime
init|=
name|now
decl_stmt|;
name|long
name|slept
init|=
literal|0
decl_stmt|;
name|long
name|lastLogTime
init|=
literal|0
decl_stmt|;
name|long
name|lastCountChange
init|=
name|startTime
decl_stmt|;
name|int
name|count
init|=
name|countOfRegionServers
argument_list|()
decl_stmt|;
name|int
name|oldCount
init|=
literal|0
decl_stmt|;
comment|// This while test is a little hard to read. We try to comment it in below but in essence:
comment|// Wait if Master is not stopped and the number of regionservers that have checked-in is
comment|// less than the maxToStart. Both of these conditions will be true near universally.
comment|// Next, we will keep cycling if ANY of the following three conditions are true:
comment|// 1. The time since a regionserver registered is< interval (means servers are actively checking in).
comment|// 2. We are under the total timeout.
comment|// 3. The count of servers is< minimum.
for|for
control|(
name|ServerListener
name|listener
range|:
name|this
operator|.
name|listeners
control|)
block|{
name|listener
operator|.
name|waiting
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|this
operator|.
name|master
operator|.
name|isStopped
argument_list|()
operator|&&
operator|!
name|isClusterShutdown
argument_list|()
operator|&&
name|count
operator|<
name|maxToStart
operator|&&
operator|(
operator|(
name|lastCountChange
operator|+
name|interval
operator|)
operator|>
name|now
operator|||
name|timeout
operator|>
name|slept
operator|||
name|count
operator|<
name|minToStart
operator|)
condition|)
block|{
comment|// Log some info at every interval time or if there is a change
if|if
condition|(
name|oldCount
operator|!=
name|count
operator|||
name|lastLogTime
operator|+
name|interval
operator|<
name|now
condition|)
block|{
name|lastLogTime
operator|=
name|now
expr_stmt|;
name|String
name|msg
init|=
literal|"Waiting on regionserver count="
operator|+
name|count
operator|+
literal|"; waited="
operator|+
name|slept
operator|+
literal|"ms, expecting min="
operator|+
name|minToStart
operator|+
literal|" server(s), max="
operator|+
name|getStrForMax
argument_list|(
name|maxToStart
argument_list|)
operator|+
literal|" server(s), "
operator|+
literal|"timeout="
operator|+
name|timeout
operator|+
literal|"ms, lastChange="
operator|+
operator|(
name|lastCountChange
operator|-
name|now
operator|)
operator|+
literal|"ms"
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
comment|// We sleep for some time
specifier|final
name|long
name|sleepTime
init|=
literal|50
decl_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepTime
argument_list|)
expr_stmt|;
name|now
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|slept
operator|=
name|now
operator|-
name|startTime
expr_stmt|;
name|oldCount
operator|=
name|count
expr_stmt|;
name|count
operator|=
name|countOfRegionServers
argument_list|()
expr_stmt|;
if|if
condition|(
name|count
operator|!=
name|oldCount
condition|)
block|{
name|lastCountChange
operator|=
name|now
expr_stmt|;
block|}
block|}
comment|// Did we exit the loop because cluster is going down?
if|if
condition|(
name|isClusterShutdown
argument_list|()
condition|)
block|{
name|this
operator|.
name|master
operator|.
name|stop
argument_list|(
literal|"Cluster shutdown"
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Finished waiting on RegionServer count="
operator|+
name|count
operator|+
literal|"; waited="
operator|+
name|slept
operator|+
literal|"ms,"
operator|+
literal|" expected min="
operator|+
name|minToStart
operator|+
literal|" server(s), max="
operator|+
name|getStrForMax
argument_list|(
name|maxToStart
argument_list|)
operator|+
literal|" server(s),"
operator|+
literal|" master is "
operator|+
operator|(
name|this
operator|.
name|master
operator|.
name|isStopped
argument_list|()
condition|?
literal|"stopped."
else|:
literal|"running"
operator|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|String
name|getStrForMax
parameter_list|(
specifier|final
name|int
name|max
parameter_list|)
block|{
return|return
name|max
operator|==
name|Integer
operator|.
name|MAX_VALUE
condition|?
literal|"NO_LIMIT"
else|:
name|Integer
operator|.
name|toString
argument_list|(
name|max
argument_list|)
return|;
block|}
comment|/**    * @return A copy of the internal list of online servers.    */
specifier|public
name|List
argument_list|<
name|ServerName
argument_list|>
name|getOnlineServersList
parameter_list|()
block|{
comment|// TODO: optimize the load balancer call so we don't need to make a new list
comment|// TODO: FIX. THIS IS POPULAR CALL.
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|this
operator|.
name|onlineServers
operator|.
name|keySet
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @param keys The target server name    * @param idleServerPredicator Evaluates the server on the given load    * @return A copy of the internal list of online servers matched by the predicator    */
specifier|public
name|List
argument_list|<
name|ServerName
argument_list|>
name|getOnlineServersListWithPredicator
parameter_list|(
name|List
argument_list|<
name|ServerName
argument_list|>
name|keys
parameter_list|,
name|Predicate
argument_list|<
name|ServerMetrics
argument_list|>
name|idleServerPredicator
parameter_list|)
block|{
name|List
argument_list|<
name|ServerName
argument_list|>
name|names
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|keys
operator|!=
literal|null
operator|&&
name|idleServerPredicator
operator|!=
literal|null
condition|)
block|{
name|keys
operator|.
name|forEach
argument_list|(
name|name
lambda|->
block|{
name|ServerMetrics
name|load
init|=
name|onlineServers
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|load
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|idleServerPredicator
operator|.
name|test
argument_list|(
name|load
argument_list|)
condition|)
block|{
name|names
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
return|return
name|names
return|;
block|}
comment|/**    * @return A copy of the internal list of draining servers.    */
specifier|public
name|List
argument_list|<
name|ServerName
argument_list|>
name|getDrainingServersList
parameter_list|()
block|{
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|this
operator|.
name|drainingServers
argument_list|)
return|;
block|}
comment|/**    * @return A copy of the internal set of deadNotExpired servers.    */
name|Set
argument_list|<
name|ServerName
argument_list|>
name|getDeadNotExpiredServers
parameter_list|()
block|{
return|return
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|this
operator|.
name|queuedDeadServers
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isServerOnline
parameter_list|(
name|ServerName
name|serverName
parameter_list|)
block|{
return|return
name|serverName
operator|!=
literal|null
operator|&&
name|onlineServers
operator|.
name|containsKey
argument_list|(
name|serverName
argument_list|)
return|;
block|}
comment|/**    * Check if a server is known to be dead.  A server can be online,    * or known to be dead, or unknown to this manager (i.e, not online,    * not known to be dead either. it is simply not tracked by the    * master any more, for example, a very old previous instance).    */
specifier|public
specifier|synchronized
name|boolean
name|isServerDead
parameter_list|(
name|ServerName
name|serverName
parameter_list|)
block|{
return|return
name|serverName
operator|==
literal|null
operator|||
name|deadservers
operator|.
name|isDeadServer
argument_list|(
name|serverName
argument_list|)
operator|||
name|queuedDeadServers
operator|.
name|contains
argument_list|(
name|serverName
argument_list|)
operator|||
name|requeuedDeadServers
operator|.
name|containsKey
argument_list|(
name|serverName
argument_list|)
return|;
block|}
specifier|public
name|void
name|shutdownCluster
parameter_list|()
block|{
name|String
name|statusStr
init|=
literal|"Cluster shutdown requested of master="
operator|+
name|this
operator|.
name|master
operator|.
name|getServerName
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|statusStr
argument_list|)
expr_stmt|;
name|this
operator|.
name|clusterShutdown
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|onlineServers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// we do not synchronize here so this may cause a double stop, but not a big deal
name|master
operator|.
name|stop
argument_list|(
literal|"OnlineServer=0 right after cluster shutdown set"
argument_list|)
expr_stmt|;
block|}
block|}
name|boolean
name|isClusterShutdown
parameter_list|()
block|{
return|return
name|this
operator|.
name|clusterShutdown
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * start chore in ServerManager    */
specifier|public
name|void
name|startChore
parameter_list|()
block|{
name|Configuration
name|c
init|=
name|master
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
if|if
condition|(
name|persistFlushedSequenceId
condition|)
block|{
comment|// when reach here, RegionStates should loaded, firstly, we call remove deleted regions
name|removeDeletedRegionFromLoadedFlushedSequenceIds
argument_list|()
expr_stmt|;
name|int
name|flushPeriod
init|=
name|c
operator|.
name|getInt
argument_list|(
name|FLUSHEDSEQUENCEID_FLUSHER_INTERVAL
argument_list|,
name|FLUSHEDSEQUENCEID_FLUSHER_INTERVAL_DEFAULT
argument_list|)
decl_stmt|;
name|flushedSeqIdFlusher
operator|=
operator|new
name|FlushedSequenceIdFlusher
argument_list|(
literal|"FlushedSequenceIdFlusher"
argument_list|,
name|flushPeriod
argument_list|)
expr_stmt|;
name|master
operator|.
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|flushedSeqIdFlusher
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Stop the ServerManager.    */
specifier|public
name|void
name|stop
parameter_list|()
block|{
if|if
condition|(
name|flushedSeqIdFlusher
operator|!=
literal|null
condition|)
block|{
name|flushedSeqIdFlusher
operator|.
name|cancel
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|persistFlushedSequenceId
condition|)
block|{
try|try
block|{
name|persistRegionLastFlushedSequenceIds
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to persist last flushed sequence id of regions"
operator|+
literal|" to file system"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Creates a list of possible destinations for a region. It contains the online servers, but not    *  the draining or dying servers.    *  @param serversToExclude can be null if there is no server to exclude    */
specifier|public
name|List
argument_list|<
name|ServerName
argument_list|>
name|createDestinationServersList
parameter_list|(
specifier|final
name|List
argument_list|<
name|ServerName
argument_list|>
name|serversToExclude
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|ServerName
argument_list|>
name|destServers
init|=
name|getOnlineServersList
argument_list|()
decl_stmt|;
if|if
condition|(
name|serversToExclude
operator|!=
literal|null
condition|)
block|{
name|destServers
operator|.
name|removeAll
argument_list|(
name|serversToExclude
argument_list|)
expr_stmt|;
block|}
comment|// Loop through the draining server list and remove them from the server list
specifier|final
name|List
argument_list|<
name|ServerName
argument_list|>
name|drainingServersCopy
init|=
name|getDrainingServersList
argument_list|()
decl_stmt|;
name|destServers
operator|.
name|removeAll
argument_list|(
name|drainingServersCopy
argument_list|)
expr_stmt|;
comment|// Remove the deadNotExpired servers from the server list.
name|removeDeadNotExpiredServers
argument_list|(
name|destServers
argument_list|)
expr_stmt|;
return|return
name|destServers
return|;
block|}
comment|/**    * Calls {@link #createDestinationServersList} without server to exclude.    */
specifier|public
name|List
argument_list|<
name|ServerName
argument_list|>
name|createDestinationServersList
parameter_list|()
block|{
return|return
name|createDestinationServersList
argument_list|(
literal|null
argument_list|)
return|;
block|}
comment|/**     * Loop through the deadNotExpired server list and remove them from the     * servers.     * This function should be used carefully outside of this class. You should use a high level     *  method such as {@link #createDestinationServersList()} instead of managing you own list.     */
name|void
name|removeDeadNotExpiredServers
parameter_list|(
name|List
argument_list|<
name|ServerName
argument_list|>
name|servers
parameter_list|)
block|{
name|Set
argument_list|<
name|ServerName
argument_list|>
name|deadNotExpiredServersCopy
init|=
name|this
operator|.
name|getDeadNotExpiredServers
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|deadNotExpiredServersCopy
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|ServerName
name|server
range|:
name|deadNotExpiredServersCopy
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing dead but not expired server: "
operator|+
name|server
operator|+
literal|" from eligible server pool."
argument_list|)
expr_stmt|;
name|servers
operator|.
name|remove
argument_list|(
name|server
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * To clear any dead server with same host name and port of any online server    */
name|void
name|clearDeadServersWithSameHostNameAndPortOfOnlineServer
parameter_list|()
block|{
for|for
control|(
name|ServerName
name|serverName
range|:
name|getOnlineServersList
argument_list|()
control|)
block|{
name|deadservers
operator|.
name|cleanAllPreviousInstances
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Called by delete table and similar to notify the ServerManager that a region was removed.    */
specifier|public
name|void
name|removeRegion
parameter_list|(
specifier|final
name|RegionInfo
name|regionInfo
parameter_list|)
block|{
specifier|final
name|byte
index|[]
name|encodedName
init|=
name|regionInfo
operator|.
name|getEncodedNameAsBytes
argument_list|()
decl_stmt|;
name|storeFlushedSequenceIdsByRegion
operator|.
name|remove
argument_list|(
name|encodedName
argument_list|)
expr_stmt|;
name|flushedSequenceIdByRegion
operator|.
name|remove
argument_list|(
name|encodedName
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|boolean
name|isRegionInServerManagerStates
parameter_list|(
specifier|final
name|RegionInfo
name|hri
parameter_list|)
block|{
specifier|final
name|byte
index|[]
name|encodedName
init|=
name|hri
operator|.
name|getEncodedNameAsBytes
argument_list|()
decl_stmt|;
return|return
operator|(
name|storeFlushedSequenceIdsByRegion
operator|.
name|containsKey
argument_list|(
name|encodedName
argument_list|)
operator|||
name|flushedSequenceIdByRegion
operator|.
name|containsKey
argument_list|(
name|encodedName
argument_list|)
operator|)
return|;
block|}
comment|/**    * Called by delete table and similar to notify the ServerManager that a region was removed.    */
specifier|public
name|void
name|removeRegions
parameter_list|(
specifier|final
name|List
argument_list|<
name|RegionInfo
argument_list|>
name|regions
parameter_list|)
block|{
for|for
control|(
name|RegionInfo
name|hri
range|:
name|regions
control|)
block|{
name|removeRegion
argument_list|(
name|hri
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * May return 0 when server is not online.    */
specifier|public
name|int
name|getServerVersion
parameter_list|(
specifier|final
name|ServerName
name|serverName
parameter_list|)
block|{
name|ServerMetrics
name|serverMetrics
init|=
name|onlineServers
operator|.
name|get
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
return|return
name|serverMetrics
operator|!=
literal|null
condition|?
name|serverMetrics
operator|.
name|getVersionNumber
argument_list|()
else|:
literal|0
return|;
block|}
specifier|public
name|int
name|getInfoPort
parameter_list|(
name|ServerName
name|serverName
parameter_list|)
block|{
name|ServerMetrics
name|serverMetrics
init|=
name|onlineServers
operator|.
name|get
argument_list|(
name|serverName
argument_list|)
decl_stmt|;
return|return
name|serverMetrics
operator|!=
literal|null
condition|?
name|serverMetrics
operator|.
name|getInfoServerPort
argument_list|()
else|:
literal|0
return|;
block|}
comment|/**    * Persist last flushed sequence id of each region to HDFS    * @throws IOException if persit to HDFS fails    */
specifier|private
name|void
name|persistRegionLastFlushedSequenceIds
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|isFlushSeqIdPersistInProgress
condition|)
block|{
return|return;
block|}
name|isFlushSeqIdPersistInProgress
operator|=
literal|true
expr_stmt|;
try|try
block|{
name|Configuration
name|conf
init|=
name|master
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|Path
name|rootDir
init|=
name|FSUtils
operator|.
name|getRootDir
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Path
name|lastFlushedSeqIdPath
init|=
operator|new
name|Path
argument_list|(
name|rootDir
argument_list|,
name|LAST_FLUSHED_SEQ_ID_FILE
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|lastFlushedSeqIdPath
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Rewriting .lastflushedseqids file at: "
operator|+
name|lastFlushedSeqIdPath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fs
operator|.
name|delete
argument_list|(
name|lastFlushedSeqIdPath
argument_list|,
literal|false
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to remove existing "
operator|+
name|lastFlushedSeqIdPath
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Writing .lastflushedseqids file at: "
operator|+
name|lastFlushedSeqIdPath
argument_list|)
expr_stmt|;
block|}
name|FSDataOutputStream
name|out
init|=
name|fs
operator|.
name|create
argument_list|(
name|lastFlushedSeqIdPath
argument_list|)
decl_stmt|;
name|FlushedSequenceId
operator|.
name|Builder
name|flushedSequenceIdBuilder
init|=
name|FlushedSequenceId
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
try|try
block|{
for|for
control|(
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
name|entry
range|:
name|flushedSequenceIdByRegion
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|FlushedRegionSequenceId
operator|.
name|Builder
name|flushedRegionSequenceIdBuilder
init|=
name|FlushedRegionSequenceId
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|flushedRegionSequenceIdBuilder
operator|.
name|setRegionEncodedName
argument_list|(
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|flushedRegionSequenceIdBuilder
operator|.
name|setSeqId
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|ConcurrentNavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
name|storeSeqIds
init|=
name|storeFlushedSequenceIdsByRegion
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|storeSeqIds
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
name|store
range|:
name|storeSeqIds
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|FlushedStoreSequenceId
operator|.
name|Builder
name|flushedStoreSequenceIdBuilder
init|=
name|FlushedStoreSequenceId
operator|.
name|newBuilder
argument_list|()
decl_stmt|;
name|flushedStoreSequenceIdBuilder
operator|.
name|setFamily
argument_list|(
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|store
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|flushedStoreSequenceIdBuilder
operator|.
name|setSeqId
argument_list|(
name|store
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|flushedRegionSequenceIdBuilder
operator|.
name|addStores
argument_list|(
name|flushedStoreSequenceIdBuilder
argument_list|)
expr_stmt|;
block|}
block|}
name|flushedSequenceIdBuilder
operator|.
name|addRegionSequenceId
argument_list|(
name|flushedRegionSequenceIdBuilder
argument_list|)
expr_stmt|;
block|}
name|flushedSequenceIdBuilder
operator|.
name|build
argument_list|()
operator|.
name|writeDelimitedTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|isFlushSeqIdPersistInProgress
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|/**    * Load last flushed sequence id of each region from HDFS, if persisted    */
specifier|public
name|void
name|loadLastFlushedSequenceIds
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|persistFlushedSequenceId
condition|)
block|{
return|return;
block|}
name|Configuration
name|conf
init|=
name|master
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|Path
name|rootDir
init|=
name|FSUtils
operator|.
name|getRootDir
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Path
name|lastFlushedSeqIdPath
init|=
operator|new
name|Path
argument_list|(
name|rootDir
argument_list|,
name|LAST_FLUSHED_SEQ_ID_FILE
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|lastFlushedSeqIdPath
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No .lastflushedseqids found at"
operator|+
name|lastFlushedSeqIdPath
operator|+
literal|" will record last flushed sequence id"
operator|+
literal|" for regions by regionserver report all over again"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"begin to load .lastflushedseqids at "
operator|+
name|lastFlushedSeqIdPath
argument_list|)
expr_stmt|;
block|}
name|FSDataInputStream
name|in
init|=
name|fs
operator|.
name|open
argument_list|(
name|lastFlushedSeqIdPath
argument_list|)
decl_stmt|;
try|try
block|{
name|FlushedSequenceId
name|flushedSequenceId
init|=
name|FlushedSequenceId
operator|.
name|parseDelimitedFrom
argument_list|(
name|in
argument_list|)
decl_stmt|;
for|for
control|(
name|FlushedRegionSequenceId
name|flushedRegionSequenceId
range|:
name|flushedSequenceId
operator|.
name|getRegionSequenceIdList
argument_list|()
control|)
block|{
name|byte
index|[]
name|encodedRegionName
init|=
name|flushedRegionSequenceId
operator|.
name|getRegionEncodedName
argument_list|()
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
name|flushedSequenceIdByRegion
operator|.
name|putIfAbsent
argument_list|(
name|encodedRegionName
argument_list|,
name|flushedRegionSequenceId
operator|.
name|getSeqId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|flushedRegionSequenceId
operator|.
name|getStoresList
argument_list|()
operator|!=
literal|null
operator|&&
name|flushedRegionSequenceId
operator|.
name|getStoresList
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|ConcurrentNavigableMap
argument_list|<
name|byte
index|[]
argument_list|,
name|Long
argument_list|>
name|storeFlushedSequenceId
init|=
name|computeIfAbsent
argument_list|(
name|storeFlushedSequenceIdsByRegion
argument_list|,
name|encodedRegionName
argument_list|,
parameter_list|()
lambda|->
operator|new
name|ConcurrentSkipListMap
argument_list|<>
argument_list|(
name|Bytes
operator|.
name|BYTES_COMPARATOR
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|FlushedStoreSequenceId
name|flushedStoreSequenceId
range|:
name|flushedRegionSequenceId
operator|.
name|getStoresList
argument_list|()
control|)
block|{
name|storeFlushedSequenceId
operator|.
name|put
argument_list|(
name|flushedStoreSequenceId
operator|.
name|getFamily
argument_list|()
operator|.
name|toByteArray
argument_list|()
argument_list|,
name|flushedStoreSequenceId
operator|.
name|getSeqId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Regions may have been removed between latest persist of FlushedSequenceIds    * and master abort. So after loading FlushedSequenceIds from file, and after    * meta loaded, we need to remove the deleted region according to RegionStates.    */
specifier|public
name|void
name|removeDeletedRegionFromLoadedFlushedSequenceIds
parameter_list|()
block|{
name|RegionStates
name|regionStates
init|=
name|master
operator|.
name|getAssignmentManager
argument_list|()
operator|.
name|getRegionStates
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|byte
index|[]
argument_list|>
name|it
init|=
name|flushedSequenceIdByRegion
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|byte
index|[]
name|regionEncodedName
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|regionStates
operator|.
name|getRegionState
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|regionEncodedName
argument_list|)
argument_list|)
operator|==
literal|null
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|storeFlushedSequenceIdsByRegion
operator|.
name|remove
argument_list|(
name|regionEncodedName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
class|class
name|FlushedSequenceIdFlusher
extends|extends
name|ScheduledChore
block|{
specifier|public
name|FlushedSequenceIdFlusher
parameter_list|(
name|String
name|name
parameter_list|,
name|int
name|p
parameter_list|)
block|{
name|super
argument_list|(
name|name
argument_list|,
name|master
argument_list|,
name|p
argument_list|,
literal|60
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|//delay one minute before first execute
block|}
annotation|@
name|Override
specifier|protected
name|void
name|chore
parameter_list|()
block|{
try|try
block|{
name|persistRegionLastFlushedSequenceIds
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to persist last flushed sequence id of regions"
operator|+
literal|" to file system"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

