begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to you under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
operator|.
name|ReadLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
operator|.
name|WriteLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|builder
operator|.
name|HashCodeBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Get
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Put
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|snapshot
operator|.
name|SnapshotDescriptionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|snapshot
operator|.
name|SnapshotManifest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|HFileArchiveUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|yetus
operator|.
name|audience
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|HashMultimap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Multimap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hbase
operator|.
name|thirdparty
operator|.
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|InvalidProtocolBufferException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|ProtobufUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|SnapshotProtos
operator|.
name|SnapshotDescription
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|SnapshotProtos
operator|.
name|SnapshotRegionManifest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|SnapshotProtos
operator|.
name|SnapshotRegionManifest
operator|.
name|FamilyFiles
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|shaded
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|SnapshotProtos
operator|.
name|SnapshotRegionManifest
operator|.
name|StoreFile
import|;
end_import

begin_comment
comment|/**  * Tracks file archiving and updates the hbase quota table.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
class|class
name|FileArchiverNotifierImpl
implements|implements
name|FileArchiverNotifier
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|FileArchiverNotifierImpl
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|Connection
name|conn
decl_stmt|;
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
specifier|private
specifier|final
name|FileSystem
name|fs
decl_stmt|;
specifier|private
specifier|final
name|TableName
name|tn
decl_stmt|;
specifier|private
specifier|final
name|ReadLock
name|readLock
decl_stmt|;
specifier|private
specifier|final
name|WriteLock
name|writeLock
decl_stmt|;
specifier|private
specifier|volatile
name|long
name|lastFullCompute
init|=
name|Long
operator|.
name|MIN_VALUE
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|currentSnapshots
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|NAMESPACE_LOCKS
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * An Exception thrown when SnapshotSize updates to hbase:quota fail to be written.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
specifier|public
specifier|static
class|class
name|QuotaSnapshotSizeSerializationException
extends|extends
name|IOException
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
specifier|public
name|QuotaSnapshotSizeSerializationException
parameter_list|(
name|String
name|msg
parameter_list|)
block|{
name|super
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|FileArchiverNotifierImpl
parameter_list|(
name|Connection
name|conn
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|FileSystem
name|fs
parameter_list|,
name|TableName
name|tn
parameter_list|)
block|{
name|this
operator|.
name|conn
operator|=
name|conn
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|this
operator|.
name|tn
operator|=
name|tn
expr_stmt|;
name|ReentrantReadWriteLock
name|lock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
name|readLock
operator|=
name|lock
operator|.
name|readLock
argument_list|()
expr_stmt|;
name|writeLock
operator|=
name|lock
operator|.
name|writeLock
argument_list|()
expr_stmt|;
block|}
specifier|static
specifier|synchronized
name|Object
name|getLockForNamespace
parameter_list|(
name|String
name|namespace
parameter_list|)
block|{
return|return
name|NAMESPACE_LOCKS
operator|.
name|computeIfAbsent
argument_list|(
name|namespace
argument_list|,
parameter_list|(
name|ns
parameter_list|)
lambda|->
operator|new
name|Object
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Returns a strictly-increasing measure of time extracted by {@link System#nanoTime()}.    */
name|long
name|getLastFullCompute
parameter_list|()
block|{
return|return
name|lastFullCompute
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addArchivedFiles
parameter_list|(
name|Set
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|>
name|fileSizes
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|start
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// We want to catch the case where we got an archival request, but there was a full
comment|// re-computation in progress that was blocking us. Most likely, the full computation is going
comment|// to already include the changes we were going to make.
comment|//
comment|// Same as "start< lastFullCompute" but avoiding numeric overflow per the
comment|// System.nanoTime() javadoc
if|if
condition|(
name|lastFullCompute
operator|!=
name|Long
operator|.
name|MIN_VALUE
operator|&&
name|start
operator|-
name|lastFullCompute
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"A full computation was performed after this request was received."
operator|+
literal|" Ignoring requested updates: "
operator|+
name|fileSizes
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"currentSnapshots: "
operator|+
name|currentSnapshots
operator|+
literal|" fileSize: "
operator|+
name|fileSizes
argument_list|)
expr_stmt|;
block|}
comment|// Write increment to quota table for the correct snapshot. Only do this if we have snapshots
comment|// and some files that were archived.
if|if
condition|(
operator|!
name|currentSnapshots
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|fileSizes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// We get back the files which no snapshot referenced (the files which will be deleted soon)
name|groupArchivedFiledBySnapshotAndRecordSize
argument_list|(
name|currentSnapshots
argument_list|,
name|fileSizes
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * For each file in the map, this updates the first snapshot (lexicographic snapshot name) that    * references this file. The result of this computation is serialized to the quota table.    *    * @param snapshots A collection of HBase snapshots to group the files into    * @param fileSizes A map of file names to their sizes    */
name|void
name|groupArchivedFiledBySnapshotAndRecordSize
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|snapshots
parameter_list|,
name|Set
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|>
name|fileSizes
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Make a copy as we'll modify it.
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|filesToUpdate
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|fileSizes
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|entry
range|:
name|fileSizes
control|)
block|{
name|filesToUpdate
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Track the change in size to each snapshot
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|snapshotSizeChanges
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|snapshot
range|:
name|snapshots
control|)
block|{
comment|// For each file in `filesToUpdate`, check if `snapshot` refers to it.
comment|// If `snapshot` does, remove it from `filesToUpdate` and add it to `snapshotSizeChanges`.
name|bucketFilesToSnapshot
argument_list|(
name|snapshot
argument_list|,
name|filesToUpdate
argument_list|,
name|snapshotSizeChanges
argument_list|)
expr_stmt|;
if|if
condition|(
name|filesToUpdate
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// If we have no more files recently archived, we have nothing more to check
break|break;
block|}
block|}
comment|// We have computed changes to the snapshot size, we need to record them.
if|if
condition|(
operator|!
name|snapshotSizeChanges
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Writing snapshot size changes for: "
operator|+
name|snapshotSizeChanges
argument_list|)
expr_stmt|;
block|}
name|persistSnapshotSizeChanges
argument_list|(
name|snapshotSizeChanges
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * For the given snapshot, find all files which this {@code snapshotName} references. After a file    * is found to be referenced by the snapshot, it is removed from {@code filesToUpdate} and    * {@code snapshotSizeChanges} is updated in concert.    *    * @param snapshotName The snapshot to check    * @param filesToUpdate A mapping of archived files to their size    * @param snapshotSizeChanges A mapping of snapshots and their change in size    */
name|void
name|bucketFilesToSnapshot
parameter_list|(
name|String
name|snapshotName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|filesToUpdate
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|snapshotSizeChanges
parameter_list|)
throws|throws
name|IOException
block|{
comment|// A quick check to avoid doing work if the caller unnecessarily invoked this method.
if|if
condition|(
name|filesToUpdate
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|Path
name|snapshotDir
init|=
name|SnapshotDescriptionUtils
operator|.
name|getCompletedSnapshotDir
argument_list|(
name|snapshotName
argument_list|,
name|FSUtils
operator|.
name|getRootDir
argument_list|(
name|conf
argument_list|)
argument_list|)
decl_stmt|;
name|SnapshotDescription
name|sd
init|=
name|SnapshotDescriptionUtils
operator|.
name|readSnapshotInfo
argument_list|(
name|fs
argument_list|,
name|snapshotDir
argument_list|)
decl_stmt|;
name|SnapshotManifest
name|manifest
init|=
name|SnapshotManifest
operator|.
name|open
argument_list|(
name|conf
argument_list|,
name|fs
argument_list|,
name|snapshotDir
argument_list|,
name|sd
argument_list|)
decl_stmt|;
comment|// For each region referenced by the snapshot
for|for
control|(
name|SnapshotRegionManifest
name|rm
range|:
name|manifest
operator|.
name|getRegionManifests
argument_list|()
control|)
block|{
comment|// For each column family in this region
for|for
control|(
name|FamilyFiles
name|ff
range|:
name|rm
operator|.
name|getFamilyFilesList
argument_list|()
control|)
block|{
comment|// And each store file in that family
for|for
control|(
name|StoreFile
name|sf
range|:
name|ff
operator|.
name|getStoreFilesList
argument_list|()
control|)
block|{
name|Long
name|valueOrNull
init|=
name|filesToUpdate
operator|.
name|remove
argument_list|(
name|sf
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|valueOrNull
operator|!=
literal|null
condition|)
block|{
comment|// This storefile was recently archived, we should update this snapshot with its size
name|snapshotSizeChanges
operator|.
name|merge
argument_list|(
name|snapshotName
argument_list|,
name|valueOrNull
argument_list|,
name|Long
operator|::
name|sum
argument_list|)
expr_stmt|;
block|}
comment|// Short-circuit, if we have no more files that were archived, we don't need to iterate
comment|// over the rest of the snapshot.
if|if
condition|(
name|filesToUpdate
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
block|}
block|}
block|}
block|}
comment|/**    * Reads the current size for each snapshot to update, generates a new update based on that value,    * and then writes the new update.    *    * @param snapshotSizeChanges A map of snapshot name to size change    */
name|void
name|persistSnapshotSizeChanges
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|snapshotSizeChanges
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|Table
name|quotaTable
init|=
name|conn
operator|.
name|getTable
argument_list|(
name|QuotaTableUtil
operator|.
name|QUOTA_TABLE_NAME
argument_list|)
init|)
block|{
comment|// Create a list (with a more typical ordering implied)
specifier|final
name|List
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|>
name|snapshotSizeEntries
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|snapshotSizeChanges
operator|.
name|entrySet
argument_list|()
argument_list|)
decl_stmt|;
comment|// Create the Gets for each snapshot we need to update
specifier|final
name|List
argument_list|<
name|Get
argument_list|>
name|snapshotSizeGets
init|=
name|snapshotSizeEntries
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
parameter_list|(
name|e
parameter_list|)
lambda|->
name|QuotaTableUtil
operator|.
name|makeGetForSnapshotSize
argument_list|(
name|tn
argument_list|,
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|>
name|iterator
init|=
name|snapshotSizeEntries
operator|.
name|iterator
argument_list|()
decl_stmt|;
comment|// A List to store each Put we'll create from the Get's we retrieve
specifier|final
name|List
argument_list|<
name|Put
argument_list|>
name|updates
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|snapshotSizeEntries
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// TODO Push this down to the RegionServer with a coprocessor:
comment|//
comment|// We would really like to piggy-back on the row-lock already being grabbed
comment|// to handle the update of the row in the quota table. However, because the value
comment|// is a serialized protobuf, the standard Increment API doesn't work for us. With a CP, we
comment|// can just send the size deltas to the RS and atomically update the serialized PB object
comment|// while relying on the row-lock for synchronization.
comment|//
comment|// Synchronizing on the namespace string is a "minor smell" but passable as this is
comment|// only invoked via a single caller (the active Master). Using the namespace name lets us
comment|// have some parallelism without worry of on caller seeing stale data from the quota table.
synchronized|synchronized
init|(
name|getLockForNamespace
argument_list|(
name|tn
operator|.
name|getNamespaceAsString
argument_list|()
argument_list|)
init|)
block|{
specifier|final
name|Result
index|[]
name|existingSnapshotSizes
init|=
name|quotaTable
operator|.
name|get
argument_list|(
name|snapshotSizeGets
argument_list|)
decl_stmt|;
name|long
name|totalSizeChange
init|=
literal|0
decl_stmt|;
comment|// Read the current size values (if they exist) to generate the new value
for|for
control|(
name|Result
name|result
range|:
name|existingSnapshotSizes
control|)
block|{
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|entry
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|snapshot
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Long
name|size
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// Track the total size change for the namespace this table belongs in
name|totalSizeChange
operator|+=
name|size
expr_stmt|;
comment|// Get the size of the previous value (or zero)
name|long
name|previousSize
init|=
name|getSnapshotSizeFromResult
argument_list|(
name|result
argument_list|)
decl_stmt|;
comment|// Create an update. A file was archived from the table, so the table's size goes
comment|// down, but the snapshot's size goes up.
name|updates
operator|.
name|add
argument_list|(
name|QuotaTableUtil
operator|.
name|createPutForSnapshotSize
argument_list|(
name|tn
argument_list|,
name|snapshot
argument_list|,
name|previousSize
operator|+
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Create an update for the summation of all snapshots in the namespace
if|if
condition|(
name|totalSizeChange
operator|!=
literal|0
condition|)
block|{
name|long
name|previousSize
init|=
name|getPreviousNamespaceSnapshotSize
argument_list|(
name|quotaTable
argument_list|,
name|tn
operator|.
name|getNamespaceAsString
argument_list|()
argument_list|)
decl_stmt|;
name|updates
operator|.
name|add
argument_list|(
name|QuotaTableUtil
operator|.
name|createPutForNamespaceSnapshotSize
argument_list|(
name|tn
operator|.
name|getNamespaceAsString
argument_list|()
argument_list|,
name|previousSize
operator|+
name|totalSizeChange
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Send all of the quota table updates in one batch.
name|List
argument_list|<
name|Object
argument_list|>
name|failures
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Object
index|[]
name|results
init|=
operator|new
name|Object
index|[
name|updates
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|quotaTable
operator|.
name|batch
argument_list|(
name|updates
argument_list|,
name|results
argument_list|)
expr_stmt|;
for|for
control|(
name|Object
name|result
range|:
name|results
control|)
block|{
comment|// A null result is an error condition (all RPC attempts failed)
if|if
condition|(
operator|!
operator|(
name|result
operator|instanceof
name|Result
operator|)
condition|)
block|{
name|failures
operator|.
name|add
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Propagate a failure if any updates failed
if|if
condition|(
operator|!
name|failures
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|QuotaSnapshotSizeSerializationException
argument_list|(
literal|"Failed to write some snapshot size updates: "
operator|+
name|failures
argument_list|)
throw|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|/**    * Fetches the current size of all snapshots in the given {@code namespace}.    *    * @param quotaTable The HBase quota table    * @param namespace Namespace to fetch the sum of snapshot sizes for    * @return The size of all snapshot sizes for the namespace in bytes.    */
name|long
name|getPreviousNamespaceSnapshotSize
parameter_list|(
name|Table
name|quotaTable
parameter_list|,
name|String
name|namespace
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Update the size of each snapshot for all snapshots in a namespace.
name|Result
name|r
init|=
name|quotaTable
operator|.
name|get
argument_list|(
name|QuotaTableUtil
operator|.
name|createGetNamespaceSnapshotSize
argument_list|(
name|namespace
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|getSnapshotSizeFromResult
argument_list|(
name|r
argument_list|)
return|;
block|}
comment|/**    * Extracts the size component from a serialized {@link SpaceQuotaSnapshot} protobuf.    *    * @param r A Result containing one cell with a SpaceQuotaSnapshot protobuf    * @return The size in bytes of the snapshot.    */
name|long
name|getSnapshotSizeFromResult
parameter_list|(
name|Result
name|r
parameter_list|)
throws|throws
name|InvalidProtocolBufferException
block|{
comment|// Per javadoc, Result should only be null if an exception was thrown. So, if we're here,
comment|// we should be non-null. If we can't advance to the first cell, same as "no cell".
if|if
condition|(
operator|!
name|r
operator|.
name|isEmpty
argument_list|()
operator|&&
name|r
operator|.
name|advance
argument_list|()
condition|)
block|{
return|return
name|QuotaTableUtil
operator|.
name|parseSnapshotSize
argument_list|(
name|r
operator|.
name|current
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|0L
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|computeAndStoreSnapshotSizes
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|currentSnapshots
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Record what the current snapshots are
name|this
operator|.
name|currentSnapshots
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|currentSnapshots
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|this
operator|.
name|currentSnapshots
argument_list|)
expr_stmt|;
comment|// compute new size for table + snapshots for that table
name|List
argument_list|<
name|SnapshotWithSize
argument_list|>
name|snapshotSizes
init|=
name|computeSnapshotSizes
argument_list|(
name|this
operator|.
name|currentSnapshots
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Computed snapshot sizes for "
operator|+
name|tn
operator|+
literal|" of "
operator|+
name|snapshotSizes
argument_list|)
expr_stmt|;
block|}
comment|// Compute the total size of all snapshots against our table
specifier|final
name|long
name|totalSnapshotSize
init|=
name|snapshotSizes
operator|.
name|stream
argument_list|()
operator|.
name|mapToLong
argument_list|(
parameter_list|(
name|sws
parameter_list|)
lambda|->
name|sws
operator|.
name|getSize
argument_list|()
argument_list|)
operator|.
name|sum
argument_list|()
decl_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Persist the size of each snapshot
try|try
init|(
name|Table
name|quotaTable
init|=
name|conn
operator|.
name|getTable
argument_list|(
name|QuotaTableUtil
operator|.
name|QUOTA_TABLE_NAME
argument_list|)
init|)
block|{
name|persistSnapshotSizes
argument_list|(
name|quotaTable
argument_list|,
name|snapshotSizes
argument_list|)
expr_stmt|;
block|}
comment|// Report the last time we did a recomputation
name|lastFullCompute
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
return|return
name|totalSnapshotSize
return|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"tableName="
argument_list|)
operator|.
name|append
argument_list|(
name|tn
argument_list|)
operator|.
name|append
argument_list|(
literal|", currentSnapshots="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|currentSnapshots
argument_list|)
operator|.
name|append
argument_list|(
literal|", lastFullCompute="
argument_list|)
operator|.
name|append
argument_list|(
name|lastFullCompute
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Computes the size of each snapshot against the table referenced by {@code this}.    *    * @param snapshots A sorted list of snapshots against {@code tn}.    * @return A list of the size for each snapshot against {@code tn}.    */
name|List
argument_list|<
name|SnapshotWithSize
argument_list|>
name|computeSnapshotSizes
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|snapshots
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|List
argument_list|<
name|SnapshotWithSize
argument_list|>
name|snapshotSizes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|snapshots
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|rootDir
init|=
name|FSUtils
operator|.
name|getRootDir
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// Get the map of store file names to store file path for this table
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|tableReferencedStoreFiles
decl_stmt|;
try|try
block|{
name|tableReferencedStoreFiles
operator|=
name|FSUtils
operator|.
name|getTableStoreFilePathMap
argument_list|(
name|fs
argument_list|,
name|rootDir
argument_list|)
operator|.
name|keySet
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Paths for "
operator|+
name|tn
operator|+
literal|": "
operator|+
name|tableReferencedStoreFiles
argument_list|)
expr_stmt|;
block|}
comment|// For each snapshot on this table, get the files which the snapshot references which
comment|// the table does not.
name|Set
argument_list|<
name|String
argument_list|>
name|snapshotReferencedFiles
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|snapshotName
range|:
name|snapshots
control|)
block|{
name|Path
name|snapshotDir
init|=
name|SnapshotDescriptionUtils
operator|.
name|getCompletedSnapshotDir
argument_list|(
name|snapshotName
argument_list|,
name|rootDir
argument_list|)
decl_stmt|;
name|SnapshotDescription
name|sd
init|=
name|SnapshotDescriptionUtils
operator|.
name|readSnapshotInfo
argument_list|(
name|fs
argument_list|,
name|snapshotDir
argument_list|)
decl_stmt|;
name|SnapshotManifest
name|manifest
init|=
name|SnapshotManifest
operator|.
name|open
argument_list|(
name|conf
argument_list|,
name|fs
argument_list|,
name|snapshotDir
argument_list|,
name|sd
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Files referenced by other snapshots: "
operator|+
name|snapshotReferencedFiles
argument_list|)
expr_stmt|;
block|}
comment|// Get the set of files from the manifest that this snapshot references which are not also
comment|// referenced by the originating table.
name|Set
argument_list|<
name|StoreFileReference
argument_list|>
name|unreferencedStoreFileNames
init|=
name|getStoreFilesFromSnapshot
argument_list|(
name|manifest
argument_list|,
parameter_list|(
name|sfn
parameter_list|)
lambda|->
operator|!
name|tableReferencedStoreFiles
operator|.
name|contains
argument_list|(
name|sfn
argument_list|)
operator|&&
operator|!
name|snapshotReferencedFiles
operator|.
name|contains
argument_list|(
name|sfn
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Snapshot "
operator|+
name|snapshotName
operator|+
literal|" solely references the files: "
operator|+
name|unreferencedStoreFileNames
argument_list|)
expr_stmt|;
block|}
comment|// Compute the size of the store files for this snapshot
name|long
name|size
init|=
name|getSizeOfStoreFiles
argument_list|(
name|tn
argument_list|,
name|unreferencedStoreFileNames
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Computed size of "
operator|+
name|snapshotName
operator|+
literal|" to be "
operator|+
name|size
argument_list|)
expr_stmt|;
block|}
comment|// Persist this snapshot's size into the map
name|snapshotSizes
operator|.
name|add
argument_list|(
operator|new
name|SnapshotWithSize
argument_list|(
name|snapshotName
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
comment|// Make sure that we don't double-count the same file
for|for
control|(
name|StoreFileReference
name|ref
range|:
name|unreferencedStoreFileNames
control|)
block|{
for|for
control|(
name|String
name|fileNames
range|:
name|ref
operator|.
name|getFamilyToFilesMapping
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|snapshotReferencedFiles
operator|.
name|add
argument_list|(
name|fileNames
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|snapshotSizes
return|;
block|}
comment|/**    * Computes the size of each store file in {@code storeFileNames}    */
name|long
name|getSizeOfStoreFiles
parameter_list|(
name|TableName
name|tn
parameter_list|,
name|Set
argument_list|<
name|StoreFileReference
argument_list|>
name|storeFileNames
parameter_list|)
block|{
return|return
name|storeFileNames
operator|.
name|stream
argument_list|()
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|summingLong
argument_list|(
parameter_list|(
name|sfr
parameter_list|)
lambda|->
name|getSizeOfStoreFile
argument_list|(
name|tn
argument_list|,
name|sfr
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Computes the size of the store files for a single region.    */
name|long
name|getSizeOfStoreFile
parameter_list|(
name|TableName
name|tn
parameter_list|,
name|StoreFileReference
name|storeFileName
parameter_list|)
block|{
name|String
name|regionName
init|=
name|storeFileName
operator|.
name|getRegionName
argument_list|()
decl_stmt|;
return|return
name|storeFileName
operator|.
name|getFamilyToFilesMapping
argument_list|()
operator|.
name|entries
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|summingLong
argument_list|(
parameter_list|(
name|e
parameter_list|)
lambda|->
name|getSizeOfStoreFile
argument_list|(
name|tn
argument_list|,
name|regionName
argument_list|,
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Computes the size of the store file given its name, region and family name in    * the archive directory.    */
name|long
name|getSizeOfStoreFile
parameter_list|(
name|TableName
name|tn
parameter_list|,
name|String
name|regionName
parameter_list|,
name|String
name|family
parameter_list|,
name|String
name|storeFile
parameter_list|)
block|{
name|Path
name|familyArchivePath
decl_stmt|;
try|try
block|{
name|familyArchivePath
operator|=
name|HFileArchiveUtil
operator|.
name|getStoreArchivePath
argument_list|(
name|conf
argument_list|,
name|tn
argument_list|,
name|regionName
argument_list|,
name|family
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not compute path for the archive directory for the region"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|0L
return|;
block|}
name|Path
name|fileArchivePath
init|=
operator|new
name|Path
argument_list|(
name|familyArchivePath
argument_list|,
name|storeFile
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|fileArchivePath
argument_list|)
condition|)
block|{
name|FileStatus
index|[]
name|status
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|fileArchivePath
argument_list|)
decl_stmt|;
if|if
condition|(
literal|1
operator|!=
name|status
operator|.
name|length
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Expected "
operator|+
name|fileArchivePath
operator|+
literal|" to be a file but was a directory, ignoring reference"
argument_list|)
expr_stmt|;
return|return
literal|0L
return|;
block|}
return|return
name|status
index|[
literal|0
index|]
operator|.
name|getLen
argument_list|()
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not obtain the status of "
operator|+
name|fileArchivePath
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|0L
return|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"Expected "
operator|+
name|fileArchivePath
operator|+
literal|" to exist but does not, ignoring reference."
argument_list|)
expr_stmt|;
return|return
literal|0L
return|;
block|}
comment|/**    * Extracts the names of the store files referenced by this snapshot which satisfy the given    * predicate (the predicate returns {@code true}).    */
name|Set
argument_list|<
name|StoreFileReference
argument_list|>
name|getStoreFilesFromSnapshot
parameter_list|(
name|SnapshotManifest
name|manifest
parameter_list|,
name|Predicate
argument_list|<
name|String
argument_list|>
name|filter
parameter_list|)
block|{
name|Set
argument_list|<
name|StoreFileReference
argument_list|>
name|references
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// For each region referenced by the snapshot
for|for
control|(
name|SnapshotRegionManifest
name|rm
range|:
name|manifest
operator|.
name|getRegionManifests
argument_list|()
control|)
block|{
name|StoreFileReference
name|regionReference
init|=
operator|new
name|StoreFileReference
argument_list|(
name|ProtobufUtil
operator|.
name|toRegionInfo
argument_list|(
name|rm
operator|.
name|getRegionInfo
argument_list|()
argument_list|)
operator|.
name|getEncodedName
argument_list|()
argument_list|)
decl_stmt|;
comment|// For each column family in this region
for|for
control|(
name|FamilyFiles
name|ff
range|:
name|rm
operator|.
name|getFamilyFilesList
argument_list|()
control|)
block|{
specifier|final
name|String
name|familyName
init|=
name|ff
operator|.
name|getFamilyName
argument_list|()
operator|.
name|toStringUtf8
argument_list|()
decl_stmt|;
comment|// And each store file in that family
for|for
control|(
name|StoreFile
name|sf
range|:
name|ff
operator|.
name|getStoreFilesList
argument_list|()
control|)
block|{
name|String
name|storeFileName
init|=
name|sf
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// A snapshot only "inherits" a files size if it uniquely refers to it (no table
comment|// and no other snapshot references it).
if|if
condition|(
name|filter
operator|.
name|test
argument_list|(
name|storeFileName
argument_list|)
condition|)
block|{
name|regionReference
operator|.
name|addFamilyStoreFile
argument_list|(
name|familyName
argument_list|,
name|storeFileName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Only add this Region reference if we retained any files.
if|if
condition|(
operator|!
name|regionReference
operator|.
name|getFamilyToFilesMapping
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|references
operator|.
name|add
argument_list|(
name|regionReference
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|references
return|;
block|}
comment|/**    * Writes the snapshot sizes to the provided {@code table}.    */
name|void
name|persistSnapshotSizes
parameter_list|(
name|Table
name|table
parameter_list|,
name|List
argument_list|<
name|SnapshotWithSize
argument_list|>
name|snapshotSizes
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Convert each entry in the map to a Put and write them to the quota table
name|table
operator|.
name|put
argument_list|(
name|snapshotSizes
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|sws
lambda|->
name|QuotaTableUtil
operator|.
name|createPutForSnapshotSize
argument_list|(
name|tn
argument_list|,
name|sws
operator|.
name|getName
argument_list|()
argument_list|,
name|sws
operator|.
name|getSize
argument_list|()
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * A struct encapsulating the name of a snapshot and its "size" on the filesystem. This size is    * defined as the amount of filesystem space taken by the files the snapshot refers to which    * the originating table no longer refers to.    */
specifier|static
class|class
name|SnapshotWithSize
block|{
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
specifier|private
specifier|final
name|long
name|size
decl_stmt|;
name|SnapshotWithSize
parameter_list|(
name|String
name|name
parameter_list|,
name|long
name|size
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
block|}
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
name|long
name|getSize
parameter_list|()
block|{
return|return
name|size
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
operator|new
name|HashCodeBuilder
argument_list|()
operator|.
name|append
argument_list|(
name|name
argument_list|)
operator|.
name|append
argument_list|(
name|size
argument_list|)
operator|.
name|toHashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|SnapshotWithSize
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|SnapshotWithSize
name|other
init|=
operator|(
name|SnapshotWithSize
operator|)
name|o
decl_stmt|;
return|return
name|name
operator|.
name|equals
argument_list|(
name|other
operator|.
name|name
argument_list|)
operator|&&
name|size
operator|==
name|other
operator|.
name|size
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|32
argument_list|)
decl_stmt|;
return|return
name|sb
operator|.
name|append
argument_list|(
literal|"SnapshotWithSize:["
argument_list|)
operator|.
name|append
argument_list|(
name|name
argument_list|)
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
operator|.
name|append
argument_list|(
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|size
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * A reference to a collection of files in the archive directory for a single region.    */
specifier|static
class|class
name|StoreFileReference
block|{
specifier|private
specifier|final
name|String
name|regionName
decl_stmt|;
specifier|private
specifier|final
name|Multimap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|familyToFiles
decl_stmt|;
name|StoreFileReference
parameter_list|(
name|String
name|regionName
parameter_list|)
block|{
name|this
operator|.
name|regionName
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|regionName
argument_list|)
expr_stmt|;
name|familyToFiles
operator|=
name|HashMultimap
operator|.
name|create
argument_list|()
expr_stmt|;
block|}
name|String
name|getRegionName
parameter_list|()
block|{
return|return
name|regionName
return|;
block|}
name|Multimap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getFamilyToFilesMapping
parameter_list|()
block|{
return|return
name|familyToFiles
return|;
block|}
name|void
name|addFamilyStoreFile
parameter_list|(
name|String
name|family
parameter_list|,
name|String
name|storeFileName
parameter_list|)
block|{
name|familyToFiles
operator|.
name|put
argument_list|(
name|family
argument_list|,
name|storeFileName
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
operator|new
name|HashCodeBuilder
argument_list|()
operator|.
name|append
argument_list|(
name|regionName
argument_list|)
operator|.
name|append
argument_list|(
name|familyToFiles
argument_list|)
operator|.
name|toHashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|StoreFileReference
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|StoreFileReference
name|other
init|=
operator|(
name|StoreFileReference
operator|)
name|o
decl_stmt|;
return|return
name|regionName
operator|.
name|equals
argument_list|(
name|other
operator|.
name|regionName
argument_list|)
operator|&&
name|familyToFiles
operator|.
name|equals
argument_list|(
name|other
operator|.
name|familyToFiles
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
return|return
name|sb
operator|.
name|append
argument_list|(
literal|"StoreFileReference[region="
argument_list|)
operator|.
name|append
argument_list|(
name|regionName
argument_list|)
operator|.
name|append
argument_list|(
literal|", files="
argument_list|)
operator|.
name|append
argument_list|(
name|familyToFiles
argument_list|)
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
block|}
end_class

end_unit

