begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Descriptors
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|Service
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|ServletException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServlet
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServletRequest
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|http
operator|.
name|HttpServletResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ClusterStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CoordinatedStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CoordinatedStateManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|DoNotRetryIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HBaseInterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HColumnDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HTableDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MasterNotRunningException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|MetaTableAccessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|NamespaceDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|PleaseHoldException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ProcedureInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|RegionStateListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ScheduledChore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerLoad
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ServerName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableDescriptors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotDisabledException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|TableNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|UnknownRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|MasterSwitchType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|Result
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|client
operator|.
name|TableState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|coprocessor
operator|.
name|BypassCoprocessorException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|coprocessor
operator|.
name|CoprocessorHost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|DeserializationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|exceptions
operator|.
name|MergeRegionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|executor
operator|.
name|ExecutorType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|CoprocessorRpcUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|RpcServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|ipc
operator|.
name|ServerNotRunningYetException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|MasterRpcServices
operator|.
name|BalanceSwitchMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|balancer
operator|.
name|BalancerChore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|balancer
operator|.
name|BaseLoadBalancer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|balancer
operator|.
name|ClusterStatusChore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|balancer
operator|.
name|LoadBalancerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|cleaner
operator|.
name|HFileCleaner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|cleaner
operator|.
name|LogCleaner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|cleaner
operator|.
name|ReplicationMetaCleaner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|cleaner
operator|.
name|ReplicationZKLockCleanerChore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|normalizer
operator|.
name|NormalizationPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|normalizer
operator|.
name|NormalizationPlan
operator|.
name|PlanType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|normalizer
operator|.
name|RegionNormalizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|normalizer
operator|.
name|RegionNormalizerChore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|normalizer
operator|.
name|RegionNormalizerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|AddColumnFamilyProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|CreateTableProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|DeleteColumnFamilyProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|DeleteTableProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|DisableTableProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|DispatchMergingRegionsProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|EnableTableProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|MasterProcedureConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|MasterProcedureEnv
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|MasterProcedureScheduler
operator|.
name|ProcedureEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|ModifyColumnFamilyProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|ModifyTableProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|ProcedurePrepareLatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|ProcedureSyncWait
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|procedure
operator|.
name|TruncateTableProcedure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|master
operator|.
name|snapshot
operator|.
name|SnapshotManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|mob
operator|.
name|MobConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|monitoring
operator|.
name|MemoryBoundedLogMessageBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|monitoring
operator|.
name|MonitoredTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|monitoring
operator|.
name|TaskMonitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure
operator|.
name|MasterProcedureManagerHost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure
operator|.
name|flush
operator|.
name|MasterFlushTableProcedureManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|ProcedureExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|procedure2
operator|.
name|store
operator|.
name|wal
operator|.
name|WALProcedureStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|AdminProtos
operator|.
name|GetRegionInfoResponse
operator|.
name|CompactionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|HBaseProtos
operator|.
name|RegionServerInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|protobuf
operator|.
name|generated
operator|.
name|WALProtos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|quotas
operator|.
name|MasterQuotaManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|DefaultStoreEngine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegionServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RSRpcServices
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RegionCoprocessorHost
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RegionSplitPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|compactions
operator|.
name|ExploringCompactionPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|compactions
operator|.
name|FIFOCompactionPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|ReplicationFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|ReplicationQueuesZKImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|master
operator|.
name|TableCFsUpdater
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|replication
operator|.
name|regionserver
operator|.
name|Replication
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|security
operator|.
name|UserProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Addressing
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|CompressionTest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|EncryptionTest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|FSUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|HFileArchiveUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|HasThread
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|IdLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ModifyRegionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Threads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|VersionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|ZKDataMigrator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|DrainingServerTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|LoadBalancerTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|MasterAddressTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|MasterMaintenanceModeTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|MetaTableLocator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|RegionNormalizerTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|RegionServerTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|SplitOrMergeTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKClusterId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZKUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|zookeeper
operator|.
name|ZooKeeperWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mortbay
operator|.
name|jetty
operator|.
name|Connector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mortbay
operator|.
name|jetty
operator|.
name|nio
operator|.
name|SelectChannelConnector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mortbay
operator|.
name|jetty
operator|.
name|servlet
operator|.
name|Context
import|;
end_import

begin_comment
comment|/**  * HMaster is the "master server" for HBase. An HBase cluster has one active  * master.  If many masters are started, all compete.  Whichever wins goes on to  * run the cluster.  All others park themselves in their constructor until  * master or cluster shutdown or until the active master loses its lease in  * zookeeper.  Thereafter, all running master jostle to take over master role.  *  *<p>The Master can be asked shutdown the cluster. See {@link #shutdown()}.  In  * this case it will tell all regionservers to go down and then wait on them  * all reporting in that they are down.  This master will then shut itself down.  *  *<p>You can also shutdown just this master.  Call {@link #stopMaster()}.  *  * @see org.apache.zookeeper.Watcher  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
name|HBaseInterfaceAudience
operator|.
name|TOOLS
argument_list|)
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|public
class|class
name|HMaster
extends|extends
name|HRegionServer
implements|implements
name|MasterServices
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|HMaster
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Protection against zombie master. Started once Master accepts active responsibility and    * starts taking over responsibilities. Allows a finite time window before giving up ownership.    */
specifier|private
specifier|static
class|class
name|InitializationMonitor
extends|extends
name|HasThread
block|{
comment|/** The amount of time in milliseconds to sleep before checking initialization status. */
specifier|public
specifier|static
specifier|final
name|String
name|TIMEOUT_KEY
init|=
literal|"hbase.master.initializationmonitor.timeout"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|long
name|TIMEOUT_DEFAULT
init|=
name|TimeUnit
operator|.
name|MILLISECONDS
operator|.
name|convert
argument_list|(
literal|15
argument_list|,
name|TimeUnit
operator|.
name|MINUTES
argument_list|)
decl_stmt|;
comment|/**      * When timeout expired and initialization has not complete, call {@link System#exit(int)} when      * true, do nothing otherwise.      */
specifier|public
specifier|static
specifier|final
name|String
name|HALT_KEY
init|=
literal|"hbase.master.initializationmonitor.haltontimeout"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|boolean
name|HALT_DEFAULT
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
name|HMaster
name|master
decl_stmt|;
specifier|private
specifier|final
name|long
name|timeout
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|haltOnTimeout
decl_stmt|;
comment|/** Creates a Thread that monitors the {@link #isInitialized()} state. */
name|InitializationMonitor
parameter_list|(
name|HMaster
name|master
parameter_list|)
block|{
name|super
argument_list|(
literal|"MasterInitializationMonitor"
argument_list|)
expr_stmt|;
name|this
operator|.
name|master
operator|=
name|master
expr_stmt|;
name|this
operator|.
name|timeout
operator|=
name|master
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getLong
argument_list|(
name|TIMEOUT_KEY
argument_list|,
name|TIMEOUT_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|haltOnTimeout
operator|=
name|master
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getBoolean
argument_list|(
name|HALT_KEY
argument_list|,
name|HALT_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
while|while
condition|(
operator|!
name|master
operator|.
name|isStopped
argument_list|()
operator|&&
name|master
operator|.
name|isActiveMaster
argument_list|()
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|master
operator|.
name|isInitialized
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Initialization completed within allotted tolerance. Monitor exiting."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Master failed to complete initialization after "
operator|+
name|timeout
operator|+
literal|"ms. Please"
operator|+
literal|" consider submitting a bug report including a thread dump of this process."
argument_list|)
expr_stmt|;
if|if
condition|(
name|haltOnTimeout
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Zombie Master exiting. Thread dump to stdout"
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|printThreadInfo
argument_list|(
name|System
operator|.
name|out
argument_list|,
literal|"Zombie HMaster"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"InitMonitor thread interrupted. Existing."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// MASTER is name of the webapp and the attribute name used stuffing this
comment|//instance into web context.
specifier|public
specifier|static
specifier|final
name|String
name|MASTER
init|=
literal|"master"
decl_stmt|;
comment|// Manager and zk listener for master election
specifier|private
specifier|final
name|ActiveMasterManager
name|activeMasterManager
decl_stmt|;
comment|// Region server tracker
name|RegionServerTracker
name|regionServerTracker
decl_stmt|;
comment|// Draining region server tracker
specifier|private
name|DrainingServerTracker
name|drainingServerTracker
decl_stmt|;
comment|// Tracker for load balancer state
name|LoadBalancerTracker
name|loadBalancerTracker
decl_stmt|;
comment|// Tracker for split and merge state
specifier|private
name|SplitOrMergeTracker
name|splitOrMergeTracker
decl_stmt|;
comment|// Tracker for region normalizer state
specifier|private
name|RegionNormalizerTracker
name|regionNormalizerTracker
decl_stmt|;
comment|//Tracker for master maintenance mode setting
specifier|private
name|MasterMaintenanceModeTracker
name|maintenanceModeTracker
decl_stmt|;
specifier|private
name|ClusterSchemaService
name|clusterSchemaService
decl_stmt|;
comment|// Metrics for the HMaster
specifier|final
name|MetricsMaster
name|metricsMaster
decl_stmt|;
comment|// file system manager for the master FS operations
specifier|private
name|MasterFileSystem
name|fileSystemManager
decl_stmt|;
specifier|private
name|MasterWalManager
name|walManager
decl_stmt|;
comment|// server manager to deal with region server info
specifier|private
specifier|volatile
name|ServerManager
name|serverManager
decl_stmt|;
comment|// manager of assignment nodes in zookeeper
specifier|private
name|AssignmentManager
name|assignmentManager
decl_stmt|;
comment|// buffer for "fatal error" notices from region servers
comment|// in the cluster. This is only used for assisting
comment|// operations/debugging.
name|MemoryBoundedLogMessageBuffer
name|rsFatals
decl_stmt|;
comment|// flag set after we become the active master (used for testing)
specifier|private
specifier|volatile
name|boolean
name|isActiveMaster
init|=
literal|false
decl_stmt|;
comment|// flag set after we complete initialization once active,
comment|// it is not private since it's used in unit tests
specifier|private
specifier|final
name|ProcedureEvent
name|initialized
init|=
operator|new
name|ProcedureEvent
argument_list|(
literal|"master initialized"
argument_list|)
decl_stmt|;
comment|// flag set after master services are started,
comment|// initialization may have not completed yet.
specifier|volatile
name|boolean
name|serviceStarted
init|=
literal|false
decl_stmt|;
comment|// flag set after we complete assignMeta.
specifier|private
specifier|final
name|ProcedureEvent
name|serverCrashProcessingEnabled
init|=
operator|new
name|ProcedureEvent
argument_list|(
literal|"server crash processing"
argument_list|)
decl_stmt|;
specifier|private
name|LoadBalancer
name|balancer
decl_stmt|;
specifier|private
name|RegionNormalizer
name|normalizer
decl_stmt|;
specifier|private
name|BalancerChore
name|balancerChore
decl_stmt|;
specifier|private
name|RegionNormalizerChore
name|normalizerChore
decl_stmt|;
specifier|private
name|ClusterStatusChore
name|clusterStatusChore
decl_stmt|;
specifier|private
name|ClusterStatusPublisher
name|clusterStatusPublisherChore
init|=
literal|null
decl_stmt|;
specifier|private
name|PeriodicDoMetrics
name|periodicDoMetricsChore
init|=
literal|null
decl_stmt|;
name|CatalogJanitor
name|catalogJanitorChore
decl_stmt|;
specifier|private
name|ReplicationZKLockCleanerChore
name|replicationZKLockCleanerChore
decl_stmt|;
specifier|private
name|ReplicationMetaCleaner
name|replicationMetaCleaner
decl_stmt|;
specifier|private
name|LogCleaner
name|logCleaner
decl_stmt|;
specifier|private
name|HFileCleaner
name|hfileCleaner
decl_stmt|;
specifier|private
name|ExpiredMobFileCleanerChore
name|expiredMobFileCleanerChore
decl_stmt|;
specifier|private
name|MobCompactionChore
name|mobCompactChore
decl_stmt|;
specifier|private
name|MasterMobCompactionThread
name|mobCompactThread
decl_stmt|;
comment|// used to synchronize the mobCompactionStates
specifier|private
specifier|final
name|IdLock
name|mobCompactionLock
init|=
operator|new
name|IdLock
argument_list|()
decl_stmt|;
comment|// save the information of mob compactions in tables.
comment|// the key is table name, the value is the number of compactions in that table.
specifier|private
name|Map
argument_list|<
name|TableName
argument_list|,
name|AtomicInteger
argument_list|>
name|mobCompactionStates
init|=
name|Maps
operator|.
name|newConcurrentMap
argument_list|()
decl_stmt|;
name|MasterCoprocessorHost
name|cpHost
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|preLoadTableDescriptors
decl_stmt|;
comment|// Time stamps for when a hmaster became active
specifier|private
name|long
name|masterActiveTime
decl_stmt|;
comment|//should we check the compression codec type at master side, default true, HBASE-6370
specifier|private
specifier|final
name|boolean
name|masterCheckCompression
decl_stmt|;
comment|//should we check encryption settings at master side, default true
specifier|private
specifier|final
name|boolean
name|masterCheckEncryption
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Service
argument_list|>
name|coprocessorServiceHandlers
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
comment|// monitor for snapshot of hbase tables
name|SnapshotManager
name|snapshotManager
decl_stmt|;
comment|// monitor for distributed procedures
specifier|private
name|MasterProcedureManagerHost
name|mpmHost
decl_stmt|;
comment|// it is assigned after 'initialized' guard set to true, so should be volatile
specifier|private
specifier|volatile
name|MasterQuotaManager
name|quotaManager
decl_stmt|;
specifier|private
name|ProcedureExecutor
argument_list|<
name|MasterProcedureEnv
argument_list|>
name|procedureExecutor
decl_stmt|;
specifier|private
name|WALProcedureStore
name|procedureStore
decl_stmt|;
comment|// handle table states
specifier|private
name|TableStateManager
name|tableStateManager
decl_stmt|;
specifier|private
name|long
name|splitPlanCount
decl_stmt|;
specifier|private
name|long
name|mergePlanCount
decl_stmt|;
comment|/** flag used in test cases in order to simulate RS failures during master initialization */
specifier|private
specifier|volatile
name|boolean
name|initializationBeforeMetaAssignment
init|=
literal|false
decl_stmt|;
comment|/** jetty server for master to redirect requests to regionserver infoServer */
specifier|private
name|org
operator|.
name|mortbay
operator|.
name|jetty
operator|.
name|Server
name|masterJettyServer
decl_stmt|;
specifier|public
specifier|static
class|class
name|RedirectServlet
extends|extends
name|HttpServlet
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|2894774810058302472L
decl_stmt|;
specifier|private
specifier|static
name|int
name|regionServerInfoPort
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|doGet
parameter_list|(
name|HttpServletRequest
name|request
parameter_list|,
name|HttpServletResponse
name|response
parameter_list|)
throws|throws
name|ServletException
throws|,
name|IOException
block|{
name|String
name|redirectUrl
init|=
name|request
operator|.
name|getScheme
argument_list|()
operator|+
literal|"://"
operator|+
name|request
operator|.
name|getServerName
argument_list|()
operator|+
literal|":"
operator|+
name|regionServerInfoPort
operator|+
name|request
operator|.
name|getRequestURI
argument_list|()
decl_stmt|;
name|response
operator|.
name|sendRedirect
argument_list|(
name|redirectUrl
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
class|class
name|PeriodicDoMetrics
extends|extends
name|ScheduledChore
block|{
specifier|private
specifier|final
name|HMaster
name|server
decl_stmt|;
specifier|public
name|PeriodicDoMetrics
parameter_list|(
name|int
name|doMetricsInterval
parameter_list|,
specifier|final
name|HMaster
name|server
parameter_list|)
block|{
name|super
argument_list|(
name|server
operator|.
name|getServerName
argument_list|()
operator|+
literal|"-DoMetricsChore"
argument_list|,
name|server
argument_list|,
name|doMetricsInterval
argument_list|)
expr_stmt|;
name|this
operator|.
name|server
operator|=
name|server
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|chore
parameter_list|()
block|{
name|server
operator|.
name|doMetrics
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Initializes the HMaster. The steps are as follows:    *<p>    *<ol>    *<li>Initialize the local HRegionServer    *<li>Start the ActiveMasterManager.    *</ol>    *<p>    * Remaining steps of initialization occur in    * #finishActiveMasterInitialization(MonitoredTask) after    * the master becomes the active one.    */
specifier|public
name|HMaster
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
name|CoordinatedStateManager
name|csm
parameter_list|)
throws|throws
name|IOException
throws|,
name|KeeperException
block|{
name|super
argument_list|(
name|conf
argument_list|,
name|csm
argument_list|)
expr_stmt|;
name|this
operator|.
name|rsFatals
operator|=
operator|new
name|MemoryBoundedLogMessageBuffer
argument_list|(
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.master.buffer.for.rs.fatals"
argument_list|,
literal|1
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"hbase.rootdir="
operator|+
name|FSUtils
operator|.
name|getRootDir
argument_list|(
name|this
operator|.
name|conf
argument_list|)
operator|+
literal|", hbase.cluster.distributed="
operator|+
name|this
operator|.
name|conf
operator|.
name|getBoolean
argument_list|(
name|HConstants
operator|.
name|CLUSTER_DISTRIBUTED
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// Disable usage of meta replicas in the master
name|this
operator|.
name|conf
operator|.
name|setBoolean
argument_list|(
name|HConstants
operator|.
name|USE_META_REPLICAS
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Replication
operator|.
name|decorateMasterConfiguration
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
comment|// Hack! Maps DFSClient => Master for logs.  HDFS made this
comment|// config param for task trackers, but we can piggyback off of it.
if|if
condition|(
name|this
operator|.
name|conf
operator|.
name|get
argument_list|(
literal|"mapreduce.task.attempt.id"
argument_list|)
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|conf
operator|.
name|set
argument_list|(
literal|"mapreduce.task.attempt.id"
argument_list|,
literal|"hb_m_"
operator|+
name|this
operator|.
name|serverName
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// should we check the compression codec type at master side, default true, HBASE-6370
name|this
operator|.
name|masterCheckCompression
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.master.check.compression"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// should we check encryption settings at master side, default true
name|this
operator|.
name|masterCheckEncryption
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.master.check.encryption"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|metricsMaster
operator|=
operator|new
name|MetricsMaster
argument_list|(
operator|new
name|MetricsMasterWrapperImpl
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
comment|// preload table descriptor at startup
name|this
operator|.
name|preLoadTableDescriptors
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.master.preload.tabledescriptors"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// Do we publish the status?
name|boolean
name|shouldPublish
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|HConstants
operator|.
name|STATUS_PUBLISHED
argument_list|,
name|HConstants
operator|.
name|STATUS_PUBLISHED_DEFAULT
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|ClusterStatusPublisher
operator|.
name|Publisher
argument_list|>
name|publisherClass
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|ClusterStatusPublisher
operator|.
name|STATUS_PUBLISHER_CLASS
argument_list|,
name|ClusterStatusPublisher
operator|.
name|DEFAULT_STATUS_PUBLISHER_CLASS
argument_list|,
name|ClusterStatusPublisher
operator|.
name|Publisher
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|shouldPublish
condition|)
block|{
if|if
condition|(
name|publisherClass
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|HConstants
operator|.
name|STATUS_PUBLISHED
operator|+
literal|" is true, but "
operator|+
name|ClusterStatusPublisher
operator|.
name|DEFAULT_STATUS_PUBLISHER_CLASS
operator|+
literal|" is not set - not publishing status"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clusterStatusPublisherChore
operator|=
operator|new
name|ClusterStatusPublisher
argument_list|(
name|this
argument_list|,
name|conf
argument_list|,
name|publisherClass
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|clusterStatusPublisherChore
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Some unit tests don't need a cluster, so no zookeeper at all
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.testing.nocluster"
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|setInitLatch
argument_list|(
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|activeMasterManager
operator|=
operator|new
name|ActiveMasterManager
argument_list|(
name|zooKeeper
argument_list|,
name|this
operator|.
name|serverName
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|int
name|infoPort
init|=
name|putUpJettyServer
argument_list|()
decl_stmt|;
name|startActiveMasterManager
argument_list|(
name|infoPort
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|activeMasterManager
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// return the actual infoPort, -1 means disable info server.
specifier|private
name|int
name|putUpJettyServer
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"hbase.master.infoserver.redirect"
argument_list|,
literal|true
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|int
name|infoPort
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.info.port.orig"
argument_list|,
name|HConstants
operator|.
name|DEFAULT_MASTER_INFOPORT
argument_list|)
decl_stmt|;
comment|// -1 is for disabling info server, so no redirecting
if|if
condition|(
name|infoPort
operator|<
literal|0
operator|||
name|infoServer
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|String
name|addr
init|=
name|conf
operator|.
name|get
argument_list|(
literal|"hbase.master.info.bindAddress"
argument_list|,
literal|"0.0.0.0"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Addressing
operator|.
name|isLocalAddress
argument_list|(
name|InetAddress
operator|.
name|getByName
argument_list|(
name|addr
argument_list|)
argument_list|)
condition|)
block|{
name|String
name|msg
init|=
literal|"Failed to start redirecting jetty server. Address "
operator|+
name|addr
operator|+
literal|" does not belong to this host. Correct configuration parameter: "
operator|+
literal|"hbase.master.info.bindAddress"
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
name|RedirectServlet
operator|.
name|regionServerInfoPort
operator|=
name|infoServer
operator|.
name|getPort
argument_list|()
expr_stmt|;
if|if
condition|(
name|RedirectServlet
operator|.
name|regionServerInfoPort
operator|==
name|infoPort
condition|)
block|{
return|return
name|infoPort
return|;
block|}
name|masterJettyServer
operator|=
operator|new
name|org
operator|.
name|mortbay
operator|.
name|jetty
operator|.
name|Server
argument_list|()
expr_stmt|;
name|Connector
name|connector
init|=
operator|new
name|SelectChannelConnector
argument_list|()
decl_stmt|;
name|connector
operator|.
name|setHost
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|connector
operator|.
name|setPort
argument_list|(
name|infoPort
argument_list|)
expr_stmt|;
name|masterJettyServer
operator|.
name|addConnector
argument_list|(
name|connector
argument_list|)
expr_stmt|;
name|masterJettyServer
operator|.
name|setStopAtShutdown
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Context
name|context
init|=
operator|new
name|Context
argument_list|(
name|masterJettyServer
argument_list|,
literal|"/"
argument_list|,
name|Context
operator|.
name|NO_SESSIONS
argument_list|)
decl_stmt|;
name|context
operator|.
name|addServlet
argument_list|(
name|RedirectServlet
operator|.
name|class
argument_list|,
literal|"/*"
argument_list|)
expr_stmt|;
try|try
block|{
name|masterJettyServer
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to start redirecting jetty server"
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|connector
operator|.
name|getLocalPort
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|protected
name|TableDescriptors
name|getFsTableDescriptors
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|super
operator|.
name|getFsTableDescriptors
argument_list|()
return|;
block|}
comment|/**    * For compatibility, if failed with regionserver credentials, try the master one    */
annotation|@
name|Override
specifier|protected
name|void
name|login
parameter_list|(
name|UserProvider
name|user
parameter_list|,
name|String
name|host
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|super
operator|.
name|login
argument_list|(
name|user
argument_list|,
name|host
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|user
operator|.
name|login
argument_list|(
literal|"hbase.master.keytab.file"
argument_list|,
literal|"hbase.master.kerberos.principal"
argument_list|,
name|host
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * If configured to put regions on active master,    * wait till a backup master becomes active.    * Otherwise, loop till the server is stopped or aborted.    */
annotation|@
name|Override
specifier|protected
name|void
name|waitForMasterActive
parameter_list|()
block|{
name|boolean
name|tablesOnMaster
init|=
name|BaseLoadBalancer
operator|.
name|tablesOnMaster
argument_list|(
name|conf
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|tablesOnMaster
operator|&&
name|isActiveMaster
operator|)
operator|&&
operator|!
name|isStopped
argument_list|()
operator|&&
operator|!
name|isAborted
argument_list|()
condition|)
block|{
name|sleeper
operator|.
name|sleep
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|MasterRpcServices
name|getMasterRpcServices
parameter_list|()
block|{
return|return
operator|(
name|MasterRpcServices
operator|)
name|rpcServices
return|;
block|}
specifier|public
name|boolean
name|balanceSwitch
parameter_list|(
specifier|final
name|boolean
name|b
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getMasterRpcServices
argument_list|()
operator|.
name|switchBalancer
argument_list|(
name|b
argument_list|,
name|BalanceSwitchMode
operator|.
name|ASYNC
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|String
name|getProcessName
parameter_list|()
block|{
return|return
name|MASTER
return|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|canCreateBaseZNode
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|canUpdateTableDescriptor
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|protected
name|RSRpcServices
name|createRpcServices
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|MasterRpcServices
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|configureInfoServer
parameter_list|()
block|{
name|infoServer
operator|.
name|addServlet
argument_list|(
literal|"master-status"
argument_list|,
literal|"/master-status"
argument_list|,
name|MasterStatusServlet
operator|.
name|class
argument_list|)
expr_stmt|;
name|infoServer
operator|.
name|setAttribute
argument_list|(
name|MASTER
argument_list|,
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|BaseLoadBalancer
operator|.
name|tablesOnMaster
argument_list|(
name|conf
argument_list|)
condition|)
block|{
name|super
operator|.
name|configureInfoServer
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|Class
argument_list|<
name|?
extends|extends
name|HttpServlet
argument_list|>
name|getDumpServlet
parameter_list|()
block|{
return|return
name|MasterDumpServlet
operator|.
name|class
return|;
block|}
comment|/**    * Emit the HMaster metrics, such as region in transition metrics.    * Surrounding in a try block just to be sure metrics doesn't abort HMaster.    */
specifier|private
name|void
name|doMetrics
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|assignmentManager
operator|!=
literal|null
condition|)
block|{
name|assignmentManager
operator|.
name|updateRegionsInTransitionMetrics
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Couldn't update metrics: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|MetricsMaster
name|getMasterMetrics
parameter_list|()
block|{
return|return
name|metricsMaster
return|;
block|}
comment|/**    * Initialize all ZK based system trackers.    */
name|void
name|initializeZKBasedSystemTrackers
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|KeeperException
throws|,
name|CoordinatedStateException
block|{
name|this
operator|.
name|balancer
operator|=
name|LoadBalancerFactory
operator|.
name|getLoadBalancer
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|normalizer
operator|=
name|RegionNormalizerFactory
operator|.
name|getRegionNormalizer
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|normalizer
operator|.
name|setMasterServices
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|normalizer
operator|.
name|setMasterRpcServices
argument_list|(
operator|(
name|MasterRpcServices
operator|)
name|rpcServices
argument_list|)
expr_stmt|;
name|this
operator|.
name|loadBalancerTracker
operator|=
operator|new
name|LoadBalancerTracker
argument_list|(
name|zooKeeper
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|loadBalancerTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|regionNormalizerTracker
operator|=
operator|new
name|RegionNormalizerTracker
argument_list|(
name|zooKeeper
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionNormalizerTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|splitOrMergeTracker
operator|=
operator|new
name|SplitOrMergeTracker
argument_list|(
name|zooKeeper
argument_list|,
name|conf
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|splitOrMergeTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|=
operator|new
name|AssignmentManager
argument_list|(
name|this
argument_list|,
name|serverManager
argument_list|,
name|this
operator|.
name|balancer
argument_list|,
name|this
operator|.
name|service
argument_list|,
name|this
operator|.
name|metricsMaster
argument_list|,
name|this
operator|.
name|tableLockManager
argument_list|,
name|tableStateManager
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionServerTracker
operator|=
operator|new
name|RegionServerTracker
argument_list|(
name|zooKeeper
argument_list|,
name|this
argument_list|,
name|this
operator|.
name|serverManager
argument_list|)
expr_stmt|;
name|this
operator|.
name|regionServerTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|drainingServerTracker
operator|=
operator|new
name|DrainingServerTracker
argument_list|(
name|zooKeeper
argument_list|,
name|this
argument_list|,
name|this
operator|.
name|serverManager
argument_list|)
expr_stmt|;
name|this
operator|.
name|drainingServerTracker
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|maintenanceModeTracker
operator|=
operator|new
name|MasterMaintenanceModeTracker
argument_list|(
name|zooKeeper
argument_list|)
expr_stmt|;
name|this
operator|.
name|maintenanceModeTracker
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Set the cluster as up.  If new RSs, they'll be waiting on this before
comment|// going ahead with their startup.
name|boolean
name|wasUp
init|=
name|this
operator|.
name|clusterStatusTracker
operator|.
name|isClusterUp
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|wasUp
condition|)
name|this
operator|.
name|clusterStatusTracker
operator|.
name|setClusterUp
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Server active/primary master="
operator|+
name|this
operator|.
name|serverName
operator|+
literal|", sessionid=0x"
operator|+
name|Long
operator|.
name|toHexString
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|getRecoverableZooKeeper
argument_list|()
operator|.
name|getSessionId
argument_list|()
argument_list|)
operator|+
literal|", setting cluster-up flag (Was="
operator|+
name|wasUp
operator|+
literal|")"
argument_list|)
expr_stmt|;
comment|// create/initialize the snapshot manager and other procedure managers
name|this
operator|.
name|snapshotManager
operator|=
operator|new
name|SnapshotManager
argument_list|()
expr_stmt|;
name|this
operator|.
name|mpmHost
operator|=
operator|new
name|MasterProcedureManagerHost
argument_list|()
expr_stmt|;
name|this
operator|.
name|mpmHost
operator|.
name|register
argument_list|(
name|this
operator|.
name|snapshotManager
argument_list|)
expr_stmt|;
name|this
operator|.
name|mpmHost
operator|.
name|register
argument_list|(
operator|new
name|MasterFlushTableProcedureManager
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|mpmHost
operator|.
name|loadProcedures
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|mpmHost
operator|.
name|initialize
argument_list|(
name|this
argument_list|,
name|this
operator|.
name|metricsMaster
argument_list|)
expr_stmt|;
block|}
comment|/**    * Finish initialization of HMaster after becoming the primary master.    *    *<ol>    *<li>Initialize master components - file system manager, server manager,    *     assignment manager, region server tracker, etc</li>    *<li>Start necessary service threads - balancer, catalog janior,    *     executor services, etc</li>    *<li>Set cluster as UP in ZooKeeper</li>    *<li>Wait for RegionServers to check-in</li>    *<li>Split logs and perform data recovery, if necessary</li>    *<li>Ensure assignment of meta/namespace regions<li>    *<li>Handle either fresh cluster start or master failover</li>    *</ol>    */
specifier|private
name|void
name|finishActiveMasterInitialization
parameter_list|(
name|MonitoredTask
name|status
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|KeeperException
throws|,
name|CoordinatedStateException
block|{
name|isActiveMaster
operator|=
literal|true
expr_stmt|;
name|Thread
name|zombieDetector
init|=
operator|new
name|Thread
argument_list|(
operator|new
name|InitializationMonitor
argument_list|(
name|this
argument_list|)
argument_list|)
decl_stmt|;
name|zombieDetector
operator|.
name|start
argument_list|()
expr_stmt|;
comment|/*      * We are active master now... go initialize components we need to run.      * Note, there may be dross in zk from previous runs; it'll get addressed      * below after we determine if cluster startup or failover.      */
name|status
operator|.
name|setStatus
argument_list|(
literal|"Initializing Master file system"
argument_list|)
expr_stmt|;
name|this
operator|.
name|masterActiveTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
comment|// TODO: Do this using Dependency Injection, using PicoContainer, Guice or Spring.
name|this
operator|.
name|fileSystemManager
operator|=
operator|new
name|MasterFileSystem
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|walManager
operator|=
operator|new
name|MasterWalManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// enable table descriptors cache
name|this
operator|.
name|tableDescriptors
operator|.
name|setCacheOn
argument_list|()
expr_stmt|;
comment|// set the META's descriptor to the correct replication
name|this
operator|.
name|tableDescriptors
operator|.
name|get
argument_list|(
name|TableName
operator|.
name|META_TABLE_NAME
argument_list|)
operator|.
name|setRegionReplication
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|META_REPLICAS_NUM
argument_list|,
name|HConstants
operator|.
name|DEFAULT_META_REPLICA_NUM
argument_list|)
argument_list|)
expr_stmt|;
comment|// warm-up HTDs cache on master initialization
if|if
condition|(
name|preLoadTableDescriptors
condition|)
block|{
name|status
operator|.
name|setStatus
argument_list|(
literal|"Pre-loading table descriptors"
argument_list|)
expr_stmt|;
name|this
operator|.
name|tableDescriptors
operator|.
name|getAll
argument_list|()
expr_stmt|;
block|}
comment|// publish cluster ID
name|status
operator|.
name|setStatus
argument_list|(
literal|"Publishing Cluster ID in ZooKeeper"
argument_list|)
expr_stmt|;
name|ZKClusterId
operator|.
name|setClusterId
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|fileSystemManager
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|initLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
name|this
operator|.
name|serverManager
operator|=
name|createServerManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Invalidate all write locks held previously
name|this
operator|.
name|tableLockManager
operator|.
name|reapWriteLocks
argument_list|()
expr_stmt|;
name|this
operator|.
name|tableStateManager
operator|=
operator|new
name|TableStateManager
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Initializing ZK system trackers"
argument_list|)
expr_stmt|;
name|initializeZKBasedSystemTrackers
argument_list|()
expr_stmt|;
comment|// This is for backwards compatibility
comment|// See HBASE-11393
name|status
operator|.
name|setStatus
argument_list|(
literal|"Update TableCFs node in ZNode"
argument_list|)
expr_stmt|;
name|TableCFsUpdater
name|tableCFsUpdater
init|=
operator|new
name|TableCFsUpdater
argument_list|(
name|zooKeeper
argument_list|,
name|conf
argument_list|,
name|this
operator|.
name|clusterConnection
argument_list|)
decl_stmt|;
name|tableCFsUpdater
operator|.
name|update
argument_list|()
expr_stmt|;
comment|// initialize master side coprocessors before we start handling requests
name|status
operator|.
name|setStatus
argument_list|(
literal|"Initializing master coprocessors"
argument_list|)
expr_stmt|;
name|this
operator|.
name|cpHost
operator|=
operator|new
name|MasterCoprocessorHost
argument_list|(
name|this
argument_list|,
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
comment|// start up all service threads.
name|status
operator|.
name|setStatus
argument_list|(
literal|"Initializing master service threads"
argument_list|)
expr_stmt|;
name|startServiceThreads
argument_list|()
expr_stmt|;
comment|// Wake up this server to check in
name|sleeper
operator|.
name|skipSleepCycle
argument_list|()
expr_stmt|;
comment|// Wait for region servers to report in
name|status
operator|.
name|setStatus
argument_list|(
literal|"Wait for region servers to report in"
argument_list|)
expr_stmt|;
name|waitForRegionServers
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|// get a list for previously failed RS which need log splitting work
comment|// we recover hbase:meta region servers inside master initialization and
comment|// handle other failed servers in SSH in order to start up master node ASAP
name|MasterMetaBootstrap
name|metaBootstrap
init|=
name|createMetaBootstrap
argument_list|(
name|this
argument_list|,
name|status
argument_list|)
decl_stmt|;
name|metaBootstrap
operator|.
name|splitMetaLogsBeforeAssignment
argument_list|()
expr_stmt|;
name|this
operator|.
name|initializationBeforeMetaAssignment
operator|=
literal|true
expr_stmt|;
comment|// Wait for regionserver to finish initialization.
if|if
condition|(
name|BaseLoadBalancer
operator|.
name|tablesOnMaster
argument_list|(
name|conf
argument_list|)
condition|)
block|{
name|waitForServerOnline
argument_list|()
expr_stmt|;
block|}
comment|//initialize load balancer
name|this
operator|.
name|balancer
operator|.
name|setClusterStatus
argument_list|(
name|getClusterStatus
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|balancer
operator|.
name|setMasterServices
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|balancer
operator|.
name|initialize
argument_list|()
expr_stmt|;
comment|// Check if master is shutting down because of some issue
comment|// in initializing the regionserver or the balancer.
if|if
condition|(
name|isStopped
argument_list|()
condition|)
return|return;
comment|// Make sure meta assigned before proceeding.
name|status
operator|.
name|setStatus
argument_list|(
literal|"Assigning Meta Region"
argument_list|)
expr_stmt|;
name|metaBootstrap
operator|.
name|assignMeta
argument_list|()
expr_stmt|;
comment|// check if master is shutting down because above assignMeta could return even hbase:meta isn't
comment|// assigned when master is shutting down
if|if
condition|(
name|isStopped
argument_list|()
condition|)
return|return;
comment|// migrating existent table state from zk, so splitters
comment|// and recovery process treat states properly.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|TableName
argument_list|,
name|TableState
operator|.
name|State
argument_list|>
name|entry
range|:
name|ZKDataMigrator
operator|.
name|queryForTableStates
argument_list|(
name|getZooKeeper
argument_list|()
argument_list|)
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Converting state from zk to new states:"
operator|+
name|entry
argument_list|)
expr_stmt|;
name|tableStateManager
operator|.
name|setTableState
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ZKUtil
operator|.
name|deleteChildrenRecursively
argument_list|(
name|getZooKeeper
argument_list|()
argument_list|,
name|getZooKeeper
argument_list|()
operator|.
name|tableZNode
argument_list|)
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Submitting log splitting work for previously failed region servers"
argument_list|)
expr_stmt|;
name|metaBootstrap
operator|.
name|processDeadServers
argument_list|()
expr_stmt|;
comment|// Fix up assignment manager status
name|status
operator|.
name|setStatus
argument_list|(
literal|"Starting assignment manager"
argument_list|)
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|.
name|joinCluster
argument_list|()
expr_stmt|;
comment|// set cluster status again after user regions are assigned
name|this
operator|.
name|balancer
operator|.
name|setClusterStatus
argument_list|(
name|getClusterStatus
argument_list|()
argument_list|)
expr_stmt|;
comment|// Start balancer and meta catalog janitor after meta and regions have been assigned.
name|status
operator|.
name|setStatus
argument_list|(
literal|"Starting balancer and catalog janitor"
argument_list|)
expr_stmt|;
name|this
operator|.
name|clusterStatusChore
operator|=
operator|new
name|ClusterStatusChore
argument_list|(
name|this
argument_list|,
name|balancer
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|clusterStatusChore
argument_list|)
expr_stmt|;
name|this
operator|.
name|balancerChore
operator|=
operator|new
name|BalancerChore
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|balancerChore
argument_list|)
expr_stmt|;
name|this
operator|.
name|normalizerChore
operator|=
operator|new
name|RegionNormalizerChore
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|normalizerChore
argument_list|)
expr_stmt|;
name|this
operator|.
name|catalogJanitorChore
operator|=
operator|new
name|CatalogJanitor
argument_list|(
name|this
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|catalogJanitorChore
argument_list|)
expr_stmt|;
comment|// Do Metrics periodically
name|periodicDoMetricsChore
operator|=
operator|new
name|PeriodicDoMetrics
argument_list|(
name|msgInterval
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|periodicDoMetricsChore
argument_list|)
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Starting cluster schema service"
argument_list|)
expr_stmt|;
name|initClusterSchemaService
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|this
operator|.
name|cpHost
operator|.
name|preMasterInitialization
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Coprocessor preMasterInitialization() hook failed"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|status
operator|.
name|markComplete
argument_list|(
literal|"Initialization successful"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Master has completed initialization"
argument_list|)
expr_stmt|;
name|configurationManager
operator|.
name|registerObserver
argument_list|(
name|this
operator|.
name|balancer
argument_list|)
expr_stmt|;
comment|// Set master as 'initialized'.
name|setInitialized
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Assign meta replicas"
argument_list|)
expr_stmt|;
name|metaBootstrap
operator|.
name|assignMetaReplicas
argument_list|()
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Starting quota manager"
argument_list|)
expr_stmt|;
name|initQuotaManager
argument_list|()
expr_stmt|;
comment|// clear the dead servers with same host name and port of online server because we are not
comment|// removing dead server with same hostname and port of rs which is trying to check in before
comment|// master initialization. See HBASE-5916.
name|this
operator|.
name|serverManager
operator|.
name|clearDeadServersWithSameHostNameAndPortOfOnlineServer
argument_list|()
expr_stmt|;
comment|// Check and set the znode ACLs if needed in case we are overtaking a non-secure configuration
name|status
operator|.
name|setStatus
argument_list|(
literal|"Checking ZNode ACLs"
argument_list|)
expr_stmt|;
name|zooKeeper
operator|.
name|checkAndSetZNodeAcls
argument_list|()
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Initializing MOB Cleaner"
argument_list|)
expr_stmt|;
name|initMobCleaner
argument_list|()
expr_stmt|;
name|status
operator|.
name|setStatus
argument_list|(
literal|"Calling postStartMaster coprocessors"
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
comment|// don't let cp initialization errors kill the master
try|try
block|{
name|this
operator|.
name|cpHost
operator|.
name|postStartMaster
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Coprocessor postStartMaster() hook failed"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
name|zombieDetector
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|initMobCleaner
parameter_list|()
block|{
name|this
operator|.
name|expiredMobFileCleanerChore
operator|=
operator|new
name|ExpiredMobFileCleanerChore
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|expiredMobFileCleanerChore
argument_list|)
expr_stmt|;
name|int
name|mobCompactionPeriod
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|MobConstants
operator|.
name|MOB_COMPACTION_CHORE_PERIOD
argument_list|,
name|MobConstants
operator|.
name|DEFAULT_MOB_COMPACTION_CHORE_PERIOD
argument_list|)
decl_stmt|;
if|if
condition|(
name|mobCompactionPeriod
operator|>
literal|0
condition|)
block|{
name|this
operator|.
name|mobCompactChore
operator|=
operator|new
name|MobCompactionChore
argument_list|(
name|this
argument_list|,
name|mobCompactionPeriod
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|mobCompactChore
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"The period is "
operator|+
name|mobCompactionPeriod
operator|+
literal|" seconds, MobCompactionChore is disabled"
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|mobCompactThread
operator|=
operator|new
name|MasterMobCompactionThread
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a {@link MasterMetaBootstrap} instance.    */
name|MasterMetaBootstrap
name|createMetaBootstrap
parameter_list|(
specifier|final
name|HMaster
name|master
parameter_list|,
specifier|final
name|MonitoredTask
name|status
parameter_list|)
block|{
comment|// We put this out here in a method so can do a Mockito.spy and stub it out
comment|// w/ a mocked up MasterMetaBootstrap.
return|return
operator|new
name|MasterMetaBootstrap
argument_list|(
name|master
argument_list|,
name|status
argument_list|)
return|;
block|}
comment|/**    * Create a {@link ServerManager} instance.    */
name|ServerManager
name|createServerManager
parameter_list|(
specifier|final
name|MasterServices
name|master
parameter_list|)
throws|throws
name|IOException
block|{
comment|// We put this out here in a method so can do a Mockito.spy and stub it out
comment|// w/ a mocked up ServerManager.
name|setupClusterConnection
argument_list|()
expr_stmt|;
return|return
operator|new
name|ServerManager
argument_list|(
name|master
argument_list|)
return|;
block|}
specifier|private
name|void
name|waitForRegionServers
parameter_list|(
specifier|final
name|MonitoredTask
name|status
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|this
operator|.
name|serverManager
operator|.
name|waitForRegionServers
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|// Check zk for region servers that are up but didn't register
for|for
control|(
name|ServerName
name|sn
range|:
name|this
operator|.
name|regionServerTracker
operator|.
name|getOnlineServers
argument_list|()
control|)
block|{
comment|// The isServerOnline check is opportunistic, correctness is handled inside
if|if
condition|(
operator|!
name|this
operator|.
name|serverManager
operator|.
name|isServerOnline
argument_list|(
name|sn
argument_list|)
operator|&&
name|serverManager
operator|.
name|checkAndRecordNewServer
argument_list|(
name|sn
argument_list|,
name|ServerLoad
operator|.
name|EMPTY_SERVERLOAD
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Registered server found up in zk but who has not yet reported in: "
operator|+
name|sn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|void
name|initClusterSchemaService
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|this
operator|.
name|clusterSchemaService
operator|=
operator|new
name|ClusterSchemaServiceImpl
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|clusterSchemaService
operator|.
name|startAndWait
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|this
operator|.
name|clusterSchemaService
operator|.
name|isRunning
argument_list|()
condition|)
throw|throw
operator|new
name|HBaseIOException
argument_list|(
literal|"Failed start"
argument_list|)
throw|;
block|}
name|void
name|initQuotaManager
parameter_list|()
throws|throws
name|IOException
block|{
name|MasterQuotaManager
name|quotaManager
init|=
operator|new
name|MasterQuotaManager
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|this
operator|.
name|assignmentManager
operator|.
name|setRegionStateListener
argument_list|(
operator|(
name|RegionStateListener
operator|)
name|quotaManager
argument_list|)
expr_stmt|;
name|quotaManager
operator|.
name|start
argument_list|()
expr_stmt|;
name|this
operator|.
name|quotaManager
operator|=
name|quotaManager
expr_stmt|;
block|}
name|boolean
name|isCatalogJanitorEnabled
parameter_list|()
block|{
return|return
name|catalogJanitorChore
operator|!=
literal|null
condition|?
name|catalogJanitorChore
operator|.
name|getEnabled
argument_list|()
else|:
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|TableDescriptors
name|getTableDescriptors
parameter_list|()
block|{
return|return
name|this
operator|.
name|tableDescriptors
return|;
block|}
annotation|@
name|Override
specifier|public
name|ServerManager
name|getServerManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|serverManager
return|;
block|}
annotation|@
name|Override
specifier|public
name|MasterFileSystem
name|getMasterFileSystem
parameter_list|()
block|{
return|return
name|this
operator|.
name|fileSystemManager
return|;
block|}
annotation|@
name|Override
specifier|public
name|MasterWalManager
name|getMasterWalManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|walManager
return|;
block|}
annotation|@
name|Override
specifier|public
name|TableStateManager
name|getTableStateManager
parameter_list|()
block|{
return|return
name|tableStateManager
return|;
block|}
comment|/*    * Start up all services. If any of these threads gets an unhandled exception    * then they just die with a logged message.  This should be fine because    * in general, we do not expect the master to get such unhandled exceptions    *  as OOMEs; it should be lightly loaded. See what HRegionServer does if    *  need to install an unexpected exception handler.    */
specifier|private
name|void
name|startServiceThreads
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Start the executor service pools
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_OPEN_REGION
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.executor.openregion.threads"
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_CLOSE_REGION
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.executor.closeregion.threads"
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_SERVER_OPERATIONS
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.executor.serverops.threads"
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_META_SERVER_OPERATIONS
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.executor.meta.serverops.threads"
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|M_LOG_REPLAY_OPS
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.executor.logreplayops.threads"
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
comment|// We depend on there being only one instance of this executor running
comment|// at a time.  To do concurrency, would need fencing of enable/disable of
comment|// tables.
comment|// Any time changing this maxThreads to> 1, pls see the comment at
comment|// AccessController#postCompletedCreateTableAction
name|this
operator|.
name|service
operator|.
name|startExecutorService
argument_list|(
name|ExecutorType
operator|.
name|MASTER_TABLE_OPERATIONS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|startProcedureExecutor
argument_list|()
expr_stmt|;
comment|// Start log cleaner thread
name|int
name|cleanerInterval
init|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"hbase.master.cleaner.interval"
argument_list|,
literal|60
operator|*
literal|1000
argument_list|)
decl_stmt|;
name|this
operator|.
name|logCleaner
operator|=
operator|new
name|LogCleaner
argument_list|(
name|cleanerInterval
argument_list|,
name|this
argument_list|,
name|conf
argument_list|,
name|getMasterWalManager
argument_list|()
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|getMasterWalManager
argument_list|()
operator|.
name|getOldLogDir
argument_list|()
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|logCleaner
argument_list|)
expr_stmt|;
comment|//start the hfile archive cleaner thread
name|Path
name|archiveDir
init|=
name|HFileArchiveUtil
operator|.
name|getArchivePath
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|params
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|params
operator|.
name|put
argument_list|(
name|MASTER
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|hfileCleaner
operator|=
operator|new
name|HFileCleaner
argument_list|(
name|cleanerInterval
argument_list|,
name|this
argument_list|,
name|conf
argument_list|,
name|getMasterFileSystem
argument_list|()
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|archiveDir
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|hfileCleaner
argument_list|)
expr_stmt|;
name|serviceStarted
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Started service threads"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conf
operator|.
name|getClass
argument_list|(
literal|"hbase.region.replica.replication.replicationQueues.class"
argument_list|,
name|ReplicationFactory
operator|.
name|defaultReplicationQueueClass
argument_list|)
operator|==
name|ReplicationQueuesZKImpl
operator|.
name|class
operator|&&
operator|!
name|conf
operator|.
name|getBoolean
argument_list|(
name|HConstants
operator|.
name|ZOOKEEPER_USEMULTI
argument_list|,
literal|true
argument_list|)
condition|)
block|{
try|try
block|{
name|replicationZKLockCleanerChore
operator|=
operator|new
name|ReplicationZKLockCleanerChore
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|cleanerInterval
argument_list|,
name|this
operator|.
name|getZooKeeper
argument_list|()
argument_list|,
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|replicationZKLockCleanerChore
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"start replicationZKLockCleanerChore failed"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|replicationMetaCleaner
operator|=
operator|new
name|ReplicationMetaCleaner
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|cleanerInterval
argument_list|)
expr_stmt|;
name|getChoreService
argument_list|()
operator|.
name|scheduleChore
argument_list|(
name|replicationMetaCleaner
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|sendShutdownInterrupt
parameter_list|()
block|{
name|super
operator|.
name|sendShutdownInterrupt
argument_list|()
expr_stmt|;
name|stopProcedureExecutor
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|stopServiceThreads
parameter_list|()
block|{
if|if
condition|(
name|masterJettyServer
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping master jetty server"
argument_list|)
expr_stmt|;
try|try
block|{
name|masterJettyServer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to stop master jetty server"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|super
operator|.
name|stopServiceThreads
argument_list|()
expr_stmt|;
name|stopChores
argument_list|()
expr_stmt|;
comment|// Wait for all the remaining region servers to report in IFF we were
comment|// running a cluster shutdown AND we were NOT aborting.
if|if
condition|(
operator|!
name|isAborted
argument_list|()
operator|&&
name|this
operator|.
name|serverManager
operator|!=
literal|null
operator|&&
name|this
operator|.
name|serverManager
operator|.
name|isClusterShutdown
argument_list|()
condition|)
block|{
name|this
operator|.
name|serverManager
operator|.
name|letRegionServersShutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Stopping service threads"
argument_list|)
expr_stmt|;
block|}
comment|// Clean up and close up shop
if|if
condition|(
name|this
operator|.
name|logCleaner
operator|!=
literal|null
condition|)
name|this
operator|.
name|logCleaner
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|hfileCleaner
operator|!=
literal|null
condition|)
name|this
operator|.
name|hfileCleaner
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|replicationZKLockCleanerChore
operator|!=
literal|null
condition|)
name|this
operator|.
name|replicationZKLockCleanerChore
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|replicationMetaCleaner
operator|!=
literal|null
condition|)
name|this
operator|.
name|replicationMetaCleaner
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|quotaManager
operator|!=
literal|null
condition|)
name|this
operator|.
name|quotaManager
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|activeMasterManager
operator|!=
literal|null
condition|)
name|this
operator|.
name|activeMasterManager
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|serverManager
operator|!=
literal|null
condition|)
name|this
operator|.
name|serverManager
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|assignmentManager
operator|!=
literal|null
condition|)
name|this
operator|.
name|assignmentManager
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|walManager
operator|!=
literal|null
condition|)
name|this
operator|.
name|walManager
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|fileSystemManager
operator|!=
literal|null
condition|)
name|this
operator|.
name|fileSystemManager
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|mpmHost
operator|!=
literal|null
condition|)
name|this
operator|.
name|mpmHost
operator|.
name|stop
argument_list|(
literal|"server shutting down."
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|startProcedureExecutor
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|MasterProcedureEnv
name|procEnv
init|=
operator|new
name|MasterProcedureEnv
argument_list|(
name|this
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|logDir
init|=
operator|new
name|Path
argument_list|(
name|fileSystemManager
operator|.
name|getRootDir
argument_list|()
argument_list|,
name|MasterProcedureConstants
operator|.
name|MASTER_PROCEDURE_LOGDIR
argument_list|)
decl_stmt|;
name|procedureStore
operator|=
operator|new
name|WALProcedureStore
argument_list|(
name|conf
argument_list|,
name|fileSystemManager
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|logDir
argument_list|,
operator|new
name|MasterProcedureEnv
operator|.
name|WALStoreLeaseRecovery
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|procedureStore
operator|.
name|registerListener
argument_list|(
operator|new
name|MasterProcedureEnv
operator|.
name|MasterProcedureStoreListener
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|procedureExecutor
operator|=
operator|new
name|ProcedureExecutor
argument_list|(
name|conf
argument_list|,
name|procEnv
argument_list|,
name|procedureStore
argument_list|,
name|procEnv
operator|.
name|getProcedureQueue
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|int
name|numThreads
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|MasterProcedureConstants
operator|.
name|MASTER_PROCEDURE_THREADS
argument_list|,
name|Math
operator|.
name|max
argument_list|(
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|availableProcessors
argument_list|()
argument_list|,
name|MasterProcedureConstants
operator|.
name|DEFAULT_MIN_MASTER_PROCEDURE_THREADS
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|abortOnCorruption
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|MasterProcedureConstants
operator|.
name|EXECUTOR_ABORT_ON_CORRUPTION
argument_list|,
name|MasterProcedureConstants
operator|.
name|DEFAULT_EXECUTOR_ABORT_ON_CORRUPTION
argument_list|)
decl_stmt|;
name|procedureStore
operator|.
name|start
argument_list|(
name|numThreads
argument_list|)
expr_stmt|;
name|procedureExecutor
operator|.
name|start
argument_list|(
name|numThreads
argument_list|,
name|abortOnCorruption
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|stopProcedureExecutor
parameter_list|()
block|{
if|if
condition|(
name|procedureExecutor
operator|!=
literal|null
condition|)
block|{
name|procedureExecutor
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|procedureStore
operator|!=
literal|null
condition|)
block|{
name|procedureStore
operator|.
name|stop
argument_list|(
name|isAborted
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|stopChores
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|expiredMobFileCleanerChore
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|expiredMobFileCleanerChore
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|mobCompactChore
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|mobCompactChore
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|balancerChore
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|balancerChore
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|normalizerChore
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|normalizerChore
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|clusterStatusChore
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|clusterStatusChore
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|catalogJanitorChore
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|catalogJanitorChore
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|clusterStatusPublisherChore
operator|!=
literal|null
condition|)
block|{
name|clusterStatusPublisherChore
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|mobCompactThread
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|mobCompactThread
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|periodicDoMetricsChore
operator|!=
literal|null
condition|)
block|{
name|periodicDoMetricsChore
operator|.
name|cancel
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * @return Get remote side's InetAddress    */
name|InetAddress
name|getRemoteInetAddress
parameter_list|(
specifier|final
name|int
name|port
parameter_list|,
specifier|final
name|long
name|serverStartCode
parameter_list|)
throws|throws
name|UnknownHostException
block|{
comment|// Do it out here in its own little method so can fake an address when
comment|// mocking up in tests.
name|InetAddress
name|ia
init|=
name|RpcServer
operator|.
name|getRemoteIp
argument_list|()
decl_stmt|;
comment|// The call could be from the local regionserver,
comment|// in which case, there is no remote address.
if|if
condition|(
name|ia
operator|==
literal|null
operator|&&
name|serverStartCode
operator|==
name|startcode
condition|)
block|{
name|InetSocketAddress
name|isa
init|=
name|rpcServices
operator|.
name|getSocketAddress
argument_list|()
decl_stmt|;
if|if
condition|(
name|isa
operator|!=
literal|null
operator|&&
name|isa
operator|.
name|getPort
argument_list|()
operator|==
name|port
condition|)
block|{
name|ia
operator|=
name|isa
operator|.
name|getAddress
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|ia
return|;
block|}
comment|/**    * @return Maximum time we should run balancer for    */
specifier|private
name|int
name|getBalancerCutoffTime
parameter_list|()
block|{
name|int
name|balancerCutoffTime
init|=
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"hbase.balancer.max.balancing"
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|balancerCutoffTime
operator|==
operator|-
literal|1
condition|)
block|{
comment|// if cutoff time isn't set, defaulting it to period time
name|int
name|balancerPeriod
init|=
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
literal|"hbase.balancer.period"
argument_list|,
literal|300000
argument_list|)
decl_stmt|;
name|balancerCutoffTime
operator|=
name|balancerPeriod
expr_stmt|;
block|}
return|return
name|balancerCutoffTime
return|;
block|}
specifier|public
name|boolean
name|balance
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|balance
argument_list|(
literal|false
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|balance
parameter_list|(
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
comment|// if master not initialized, don't run balancer.
if|if
condition|(
operator|!
name|isInitialized
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Master has not been initialized, don't run balancer."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|isInMaintenanceMode
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Master is in maintenanceMode mode, don't run balancer."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Do this call outside of synchronized block.
name|int
name|maximumBalanceTime
init|=
name|getBalancerCutoffTime
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|balancer
init|)
block|{
comment|// If balance not true, don't run balancer.
if|if
condition|(
operator|!
name|this
operator|.
name|loadBalancerTracker
operator|.
name|isBalancerOn
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// Only allow one balance run at at time.
if|if
condition|(
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|isRegionsInTransition
argument_list|()
condition|)
block|{
name|Set
argument_list|<
name|RegionState
argument_list|>
name|regionsInTransition
init|=
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getRegionsInTransition
argument_list|()
decl_stmt|;
comment|// if hbase:meta region is in transition, result of assignment cannot be recorded
comment|// ignore the force flag in that case
name|boolean
name|metaInTransition
init|=
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|isMetaRegionInTransition
argument_list|()
decl_stmt|;
name|String
name|prefix
init|=
name|force
operator|&&
operator|!
name|metaInTransition
condition|?
literal|"R"
else|:
literal|"Not r"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|prefix
operator|+
literal|"unning balancer because "
operator|+
name|regionsInTransition
operator|.
name|size
argument_list|()
operator|+
literal|" region(s) in transition: "
operator|+
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
operator|.
name|abbreviate
argument_list|(
name|regionsInTransition
operator|.
name|toString
argument_list|()
argument_list|,
literal|256
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|force
operator|||
name|metaInTransition
condition|)
return|return
literal|false
return|;
block|}
if|if
condition|(
name|this
operator|.
name|serverManager
operator|.
name|areDeadServersInProgress
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Not running balancer because processing dead regionserver(s): "
operator|+
name|this
operator|.
name|serverManager
operator|.
name|getDeadServers
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|this
operator|.
name|cpHost
operator|.
name|preBalance
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Coprocessor bypassing balancer request"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error invoking master coprocessor preBalance()"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|Map
argument_list|<
name|TableName
argument_list|,
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
argument_list|>
name|assignmentsByTable
init|=
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getAssignmentsByTable
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RegionPlan
argument_list|>
name|plans
init|=
operator|new
name|ArrayList
argument_list|<
name|RegionPlan
argument_list|>
argument_list|()
decl_stmt|;
comment|//Give the balancer the current cluster state.
name|this
operator|.
name|balancer
operator|.
name|setClusterStatus
argument_list|(
name|getClusterStatus
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|TableName
argument_list|,
name|Map
argument_list|<
name|ServerName
argument_list|,
name|List
argument_list|<
name|HRegionInfo
argument_list|>
argument_list|>
argument_list|>
name|e
range|:
name|assignmentsByTable
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|List
argument_list|<
name|RegionPlan
argument_list|>
name|partialPlans
init|=
name|this
operator|.
name|balancer
operator|.
name|balanceCluster
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|partialPlans
operator|!=
literal|null
condition|)
name|plans
operator|.
name|addAll
argument_list|(
name|partialPlans
argument_list|)
expr_stmt|;
block|}
name|long
name|cutoffTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|maximumBalanceTime
decl_stmt|;
name|int
name|rpCount
init|=
literal|0
decl_stmt|;
comment|// number of RegionPlans balanced so far
name|long
name|totalRegPlanExecTime
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|plans
operator|!=
literal|null
operator|&&
operator|!
name|plans
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|RegionPlan
name|plan
range|:
name|plans
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"balance "
operator|+
name|plan
argument_list|)
expr_stmt|;
name|long
name|balStartTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|//TODO: bulk assign
name|this
operator|.
name|assignmentManager
operator|.
name|balance
argument_list|(
name|plan
argument_list|)
expr_stmt|;
name|totalRegPlanExecTime
operator|+=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|balStartTime
expr_stmt|;
name|rpCount
operator|++
expr_stmt|;
if|if
condition|(
name|rpCount
operator|<
name|plans
operator|.
name|size
argument_list|()
operator|&&
comment|// if performing next balance exceeds cutoff time, exit the loop
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
operator|(
name|totalRegPlanExecTime
operator|/
name|rpCount
operator|)
operator|)
operator|>
name|cutoffTime
condition|)
block|{
comment|//TODO: After balance, there should not be a cutoff time (keeping it as
comment|// a security net for now)
name|LOG
operator|.
name|debug
argument_list|(
literal|"No more balancing till next balance run; maximumBalanceTime="
operator|+
name|maximumBalanceTime
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|this
operator|.
name|cpHost
operator|.
name|postBalance
argument_list|(
name|rpCount
operator|<
name|plans
operator|.
name|size
argument_list|()
condition|?
name|plans
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|rpCount
argument_list|)
else|:
name|plans
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// balancing already succeeded so don't change the result
name|LOG
operator|.
name|error
argument_list|(
literal|"Error invoking master coprocessor postBalance()"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// If LoadBalancer did not generate any plans, it means the cluster is already balanced.
comment|// Return true indicating a success.
return|return
literal|true
return|;
block|}
annotation|@
name|Override
annotation|@
name|VisibleForTesting
specifier|public
name|RegionNormalizer
name|getRegionNormalizer
parameter_list|()
block|{
return|return
name|this
operator|.
name|normalizer
return|;
block|}
comment|/**    * Perform normalization of cluster (invoked by {@link RegionNormalizerChore}).    *    * @return true if normalization step was performed successfully, false otherwise    *    (specifically, if HMaster hasn't been initialized properly or normalization    *    is globally disabled)    */
specifier|public
name|boolean
name|normalizeRegions
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isInitialized
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Master has not been initialized, don't run region normalizer."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|isInMaintenanceMode
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Master is in maintenance mode, don't run region normalizer."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|this
operator|.
name|regionNormalizerTracker
operator|.
name|isNormalizerOn
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Region normalization is disabled, don't run region normalizer."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
synchronized|synchronized
init|(
name|this
operator|.
name|normalizer
init|)
block|{
comment|// Don't run the normalizer concurrently
name|List
argument_list|<
name|TableName
argument_list|>
name|allEnabledTables
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|this
operator|.
name|tableStateManager
operator|.
name|getTablesInStates
argument_list|(
name|TableState
operator|.
name|State
operator|.
name|ENABLED
argument_list|)
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|allEnabledTables
argument_list|)
expr_stmt|;
for|for
control|(
name|TableName
name|table
range|:
name|allEnabledTables
control|)
block|{
if|if
condition|(
name|isInMaintenanceMode
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Master is in maintenance mode, stop running region normalizer."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|HTableDescriptor
name|tblDesc
init|=
name|getTableDescriptors
argument_list|()
operator|.
name|get
argument_list|(
name|table
argument_list|)
decl_stmt|;
if|if
condition|(
name|table
operator|.
name|isSystemTable
argument_list|()
operator|||
operator|(
name|tblDesc
operator|!=
literal|null
operator|&&
operator|!
name|tblDesc
operator|.
name|isNormalizationEnabled
argument_list|()
operator|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping normalization for table: "
operator|+
name|table
operator|+
literal|", as it's either system"
operator|+
literal|" table or doesn't have auto normalization turned on"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|List
argument_list|<
name|NormalizationPlan
argument_list|>
name|plans
init|=
name|this
operator|.
name|normalizer
operator|.
name|computePlanForTable
argument_list|(
name|table
argument_list|)
decl_stmt|;
if|if
condition|(
name|plans
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|NormalizationPlan
name|plan
range|:
name|plans
control|)
block|{
name|plan
operator|.
name|execute
argument_list|(
name|clusterConnection
operator|.
name|getAdmin
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|plan
operator|.
name|getType
argument_list|()
operator|==
name|PlanType
operator|.
name|SPLIT
condition|)
block|{
name|splitPlanCount
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|plan
operator|.
name|getType
argument_list|()
operator|==
name|PlanType
operator|.
name|MERGE
condition|)
block|{
name|mergePlanCount
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|// If Region did not generate any plans, it means the cluster is already balanced.
comment|// Return true indicating a success.
return|return
literal|true
return|;
block|}
comment|/**    * @return Client info for use as prefix on an audit log string; who did an action    */
name|String
name|getClientIdAuditPrefix
parameter_list|()
block|{
return|return
literal|"Client="
operator|+
name|RpcServer
operator|.
name|getRequestUserName
argument_list|()
operator|+
literal|"/"
operator|+
name|RpcServer
operator|.
name|getRemoteAddress
argument_list|()
return|;
block|}
comment|/**    * Switch for the background CatalogJanitor thread.    * Used for testing.  The thread will continue to run.  It will just be a noop    * if disabled.    * @param b If false, the catalog janitor won't do anything.    */
specifier|public
name|void
name|setCatalogJanitorEnabled
parameter_list|(
specifier|final
name|boolean
name|b
parameter_list|)
block|{
name|this
operator|.
name|catalogJanitorChore
operator|.
name|setEnabled
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|dispatchMergingRegions
parameter_list|(
specifier|final
name|HRegionInfo
name|regionInfoA
parameter_list|,
specifier|final
name|HRegionInfo
name|regionInfoB
parameter_list|,
specifier|final
name|boolean
name|forcible
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
name|TableName
name|tableName
init|=
name|regionInfoA
operator|.
name|getTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|tableName
operator|==
literal|null
operator|||
name|regionInfoB
operator|.
name|getTable
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownRegionException
argument_list|(
literal|"Can't merge regions without table associated"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|tableName
operator|.
name|equals
argument_list|(
name|regionInfoB
operator|.
name|getTable
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot merge regions from two different tables"
argument_list|)
throw|;
block|}
if|if
condition|(
name|regionInfoA
operator|.
name|compareTo
argument_list|(
name|regionInfoB
argument_list|)
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|MergeRegionException
argument_list|(
literal|"Cannot merge a region to itself "
operator|+
name|regionInfoA
operator|+
literal|", "
operator|+
name|regionInfoB
argument_list|)
throw|;
block|}
name|HRegionInfo
index|[]
name|regionsToMerge
init|=
operator|new
name|HRegionInfo
index|[
literal|2
index|]
decl_stmt|;
name|regionsToMerge
index|[
literal|0
index|]
operator|=
name|regionInfoA
expr_stmt|;
name|regionsToMerge
index|[
literal|1
index|]
operator|=
name|regionInfoB
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preDispatchMerge
argument_list|(
name|regionInfoA
argument_list|,
name|regionInfoB
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" Merge regions "
operator|+
name|regionInfoA
operator|.
name|getEncodedName
argument_list|()
operator|+
literal|" and "
operator|+
name|regionInfoB
operator|.
name|getEncodedName
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|procId
init|=
name|this
operator|.
name|procedureExecutor
operator|.
name|submitProcedure
argument_list|(
operator|new
name|DispatchMergingRegionsProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|tableName
argument_list|,
name|regionsToMerge
argument_list|,
name|forcible
argument_list|)
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postDispatchMerge
argument_list|(
name|regionInfoA
argument_list|,
name|regionInfoB
argument_list|)
expr_stmt|;
block|}
return|return
name|procId
return|;
block|}
name|void
name|move
parameter_list|(
specifier|final
name|byte
index|[]
name|encodedRegionName
parameter_list|,
specifier|final
name|byte
index|[]
name|destServerName
parameter_list|)
throws|throws
name|HBaseIOException
block|{
name|RegionState
name|regionState
init|=
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getRegionState
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|encodedRegionName
argument_list|)
argument_list|)
decl_stmt|;
name|HRegionInfo
name|hri
decl_stmt|;
if|if
condition|(
name|regionState
operator|!=
literal|null
condition|)
block|{
name|hri
operator|=
name|regionState
operator|.
name|getRegion
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnknownRegionException
argument_list|(
name|Bytes
operator|.
name|toStringBinary
argument_list|(
name|encodedRegionName
argument_list|)
argument_list|)
throw|;
block|}
name|ServerName
name|dest
decl_stmt|;
if|if
condition|(
name|destServerName
operator|==
literal|null
operator|||
name|destServerName
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Passed destination servername is null/empty so "
operator|+
literal|"choosing a server at random"
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|ServerName
argument_list|>
name|destServers
init|=
name|this
operator|.
name|serverManager
operator|.
name|createDestinationServersList
argument_list|(
name|regionState
operator|.
name|getServerName
argument_list|()
argument_list|)
decl_stmt|;
name|dest
operator|=
name|balancer
operator|.
name|randomAssignment
argument_list|(
name|hri
argument_list|,
name|destServers
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unable to determine a plan to assign "
operator|+
name|hri
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|ServerName
name|candidate
init|=
name|ServerName
operator|.
name|valueOf
argument_list|(
name|Bytes
operator|.
name|toString
argument_list|(
name|destServerName
argument_list|)
argument_list|)
decl_stmt|;
name|dest
operator|=
name|balancer
operator|.
name|randomAssignment
argument_list|(
name|hri
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|candidate
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unable to determine a plan to assign "
operator|+
name|hri
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dest
operator|.
name|equals
argument_list|(
name|serverName
argument_list|)
operator|&&
name|balancer
operator|instanceof
name|BaseLoadBalancer
operator|&&
operator|!
operator|(
operator|(
name|BaseLoadBalancer
operator|)
name|balancer
operator|)
operator|.
name|shouldBeOnMaster
argument_list|(
name|hri
argument_list|)
condition|)
block|{
comment|// To avoid unnecessary region moving later by balancer. Don't put user
comment|// regions on master. Regions on master could be put on other region
comment|// server intentionally by test however.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping move of region "
operator|+
name|hri
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" to avoid unnecessary region moving later by load balancer,"
operator|+
literal|" because it should not be on master"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|dest
operator|.
name|equals
argument_list|(
name|regionState
operator|.
name|getServerName
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping move of region "
operator|+
name|hri
operator|.
name|getRegionNameAsString
argument_list|()
operator|+
literal|" because region already assigned to the same server "
operator|+
name|dest
operator|+
literal|"."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Now we can do the move
name|RegionPlan
name|rp
init|=
operator|new
name|RegionPlan
argument_list|(
name|hri
argument_list|,
name|regionState
operator|.
name|getServerName
argument_list|()
argument_list|,
name|dest
argument_list|)
decl_stmt|;
try|try
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|cpHost
operator|.
name|preMove
argument_list|(
name|hri
argument_list|,
name|rp
operator|.
name|getSource
argument_list|()
argument_list|,
name|rp
operator|.
name|getDestination
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
comment|// warmup the region on the destination before initiating the move. this call
comment|// is synchronous and takes some time. doing it before the source region gets
comment|// closed
name|serverManager
operator|.
name|sendRegionWarmup
argument_list|(
name|rp
operator|.
name|getDestination
argument_list|()
argument_list|,
name|hri
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" move "
operator|+
name|rp
operator|+
literal|", running balancer"
argument_list|)
expr_stmt|;
name|this
operator|.
name|assignmentManager
operator|.
name|balance
argument_list|(
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|cpHost
operator|.
name|postMove
argument_list|(
name|hri
argument_list|,
name|rp
operator|.
name|getSource
argument_list|()
argument_list|,
name|rp
operator|.
name|getDestination
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
if|if
condition|(
name|ioe
operator|instanceof
name|HBaseIOException
condition|)
block|{
throw|throw
operator|(
name|HBaseIOException
operator|)
name|ioe
throw|;
block|}
throw|throw
operator|new
name|HBaseIOException
argument_list|(
name|ioe
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|long
name|createTable
parameter_list|(
specifier|final
name|HTableDescriptor
name|hTableDescriptor
parameter_list|,
specifier|final
name|byte
index|[]
index|[]
name|splitKeys
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isStopped
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MasterNotRunningException
argument_list|()
throw|;
block|}
name|checkInitialized
argument_list|()
expr_stmt|;
name|String
name|namespace
init|=
name|hTableDescriptor
operator|.
name|getTableName
argument_list|()
operator|.
name|getNamespaceAsString
argument_list|()
decl_stmt|;
name|this
operator|.
name|clusterSchemaService
operator|.
name|getNamespace
argument_list|(
name|namespace
argument_list|)
expr_stmt|;
name|HRegionInfo
index|[]
name|newRegions
init|=
name|ModifyRegionUtils
operator|.
name|createHRegionInfos
argument_list|(
name|hTableDescriptor
argument_list|,
name|splitKeys
argument_list|)
decl_stmt|;
name|checkInitialized
argument_list|()
expr_stmt|;
name|sanityCheckTableDescriptor
argument_list|(
name|hTableDescriptor
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preCreateTable
argument_list|(
name|hTableDescriptor
argument_list|,
name|newRegions
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" create "
operator|+
name|hTableDescriptor
argument_list|)
expr_stmt|;
comment|// TODO: We can handle/merge duplicate requests, and differentiate the case of
comment|//       TableExistsException by saying if the schema is the same or not.
name|ProcedurePrepareLatch
name|latch
init|=
name|ProcedurePrepareLatch
operator|.
name|createLatch
argument_list|()
decl_stmt|;
name|long
name|procId
init|=
name|this
operator|.
name|procedureExecutor
operator|.
name|submitProcedure
argument_list|(
operator|new
name|CreateTableProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|hTableDescriptor
argument_list|,
name|newRegions
argument_list|,
name|latch
argument_list|)
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
decl_stmt|;
name|latch
operator|.
name|await
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postCreateTable
argument_list|(
name|hTableDescriptor
argument_list|,
name|newRegions
argument_list|)
expr_stmt|;
block|}
return|return
name|procId
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|createSystemTable
parameter_list|(
specifier|final
name|HTableDescriptor
name|hTableDescriptor
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isStopped
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MasterNotRunningException
argument_list|()
throw|;
block|}
name|TableName
name|tableName
init|=
name|hTableDescriptor
operator|.
name|getTableName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|tableName
operator|.
name|isSystemTable
argument_list|()
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Only system table creation can use this createSystemTable API"
argument_list|)
throw|;
block|}
name|HRegionInfo
index|[]
name|newRegions
init|=
name|ModifyRegionUtils
operator|.
name|createHRegionInfos
argument_list|(
name|hTableDescriptor
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" create "
operator|+
name|hTableDescriptor
argument_list|)
expr_stmt|;
comment|// This special create table is called locally to master.  Therefore, no RPC means no need
comment|// to use nonce to detect duplicated RPC call.
name|long
name|procId
init|=
name|this
operator|.
name|procedureExecutor
operator|.
name|submitProcedure
argument_list|(
operator|new
name|CreateTableProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|hTableDescriptor
argument_list|,
name|newRegions
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|procId
return|;
block|}
comment|/**    * Checks whether the table conforms to some sane limits, and configured    * values (compression, etc) work. Throws an exception if something is wrong.    * @throws IOException    */
specifier|private
name|void
name|sanityCheckTableDescriptor
parameter_list|(
specifier|final
name|HTableDescriptor
name|htd
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
name|CONF_KEY
init|=
literal|"hbase.table.sanity.checks"
decl_stmt|;
name|boolean
name|logWarn
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolean
argument_list|(
name|CONF_KEY
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|logWarn
operator|=
literal|true
expr_stmt|;
block|}
name|String
name|tableVal
init|=
name|htd
operator|.
name|getConfigurationValue
argument_list|(
name|CONF_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|tableVal
operator|!=
literal|null
operator|&&
operator|!
name|Boolean
operator|.
name|valueOf
argument_list|(
name|tableVal
argument_list|)
condition|)
block|{
name|logWarn
operator|=
literal|true
expr_stmt|;
block|}
comment|// check max file size
name|long
name|maxFileSizeLowerLimit
init|=
literal|2
operator|*
literal|1024
operator|*
literal|1024L
decl_stmt|;
comment|// 2M is the default lower limit
name|long
name|maxFileSize
init|=
name|htd
operator|.
name|getMaxFileSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|maxFileSize
operator|<
literal|0
condition|)
block|{
name|maxFileSize
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|HConstants
operator|.
name|HREGION_MAX_FILESIZE
argument_list|,
name|maxFileSizeLowerLimit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maxFileSize
operator|<
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.hregion.max.filesize.limit"
argument_list|,
name|maxFileSizeLowerLimit
argument_list|)
condition|)
block|{
name|String
name|message
init|=
literal|"MAX_FILESIZE for table descriptor or "
operator|+
literal|"\"hbase.hregion.max.filesize\" ("
operator|+
name|maxFileSize
operator|+
literal|") is too small, which might cause over splitting into unmanageable "
operator|+
literal|"number of regions."
decl_stmt|;
name|warnOrThrowExceptionForFailure
argument_list|(
name|logWarn
argument_list|,
name|CONF_KEY
argument_list|,
name|message
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// check flush size
name|long
name|flushSizeLowerLimit
init|=
literal|1024
operator|*
literal|1024L
decl_stmt|;
comment|// 1M is the default lower limit
name|long
name|flushSize
init|=
name|htd
operator|.
name|getMemStoreFlushSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|flushSize
operator|<
literal|0
condition|)
block|{
name|flushSize
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|HConstants
operator|.
name|HREGION_MEMSTORE_FLUSH_SIZE
argument_list|,
name|flushSizeLowerLimit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flushSize
operator|<
name|conf
operator|.
name|getLong
argument_list|(
literal|"hbase.hregion.memstore.flush.size.limit"
argument_list|,
name|flushSizeLowerLimit
argument_list|)
condition|)
block|{
name|String
name|message
init|=
literal|"MEMSTORE_FLUSHSIZE for table descriptor or "
operator|+
literal|"\"hbase.hregion.memstore.flush.size\" ("
operator|+
name|flushSize
operator|+
literal|") is too small, which might cause"
operator|+
literal|" very frequent flushing."
decl_stmt|;
name|warnOrThrowExceptionForFailure
argument_list|(
name|logWarn
argument_list|,
name|CONF_KEY
argument_list|,
name|message
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// check that coprocessors and other specified plugin classes can be loaded
try|try
block|{
name|checkClassLoading
argument_list|(
name|conf
argument_list|,
name|htd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|warnOrThrowExceptionForFailure
argument_list|(
name|logWarn
argument_list|,
name|CONF_KEY
argument_list|,
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// check compression can be loaded
try|try
block|{
name|checkCompression
argument_list|(
name|htd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|warnOrThrowExceptionForFailure
argument_list|(
name|logWarn
argument_list|,
name|CONF_KEY
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// check encryption can be loaded
try|try
block|{
name|checkEncryption
argument_list|(
name|conf
argument_list|,
name|htd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|warnOrThrowExceptionForFailure
argument_list|(
name|logWarn
argument_list|,
name|CONF_KEY
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// Verify compaction policy
try|try
block|{
name|checkCompactionPolicy
argument_list|(
name|conf
argument_list|,
name|htd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|warnOrThrowExceptionForFailure
argument_list|(
literal|false
argument_list|,
name|CONF_KEY
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// check that we have at least 1 CF
if|if
condition|(
name|htd
operator|.
name|getColumnFamilies
argument_list|()
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|String
name|message
init|=
literal|"Table should have at least one column family."
decl_stmt|;
name|warnOrThrowExceptionForFailure
argument_list|(
name|logWarn
argument_list|,
name|CONF_KEY
argument_list|,
name|message
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|HColumnDescriptor
name|hcd
range|:
name|htd
operator|.
name|getColumnFamilies
argument_list|()
control|)
block|{
if|if
condition|(
name|hcd
operator|.
name|getTimeToLive
argument_list|()
operator|<=
literal|0
condition|)
block|{
name|String
name|message
init|=
literal|"TTL for column family "
operator|+
name|hcd
operator|.
name|getNameAsString
argument_list|()
operator|+
literal|" must be positive."
decl_stmt|;
name|warnOrThrowExceptionForFailure
argument_list|(
name|logWarn
argument_list|,
name|CONF_KEY
argument_list|,
name|message
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// check blockSize
if|if
condition|(
name|hcd
operator|.
name|getBlocksize
argument_list|()
operator|<
literal|1024
operator|||
name|hcd
operator|.
name|getBlocksize
argument_list|()
operator|>
literal|16
operator|*
literal|1024
operator|*
literal|1024
condition|)
block|{
name|String
name|message
init|=
literal|"Block size for column family "
operator|+
name|hcd
operator|.
name|getNameAsString
argument_list|()
operator|+
literal|"  must be between 1K and 16MB."
decl_stmt|;
name|warnOrThrowExceptionForFailure
argument_list|(
name|logWarn
argument_list|,
name|CONF_KEY
argument_list|,
name|message
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// check versions
if|if
condition|(
name|hcd
operator|.
name|getMinVersions
argument_list|()
operator|<
literal|0
condition|)
block|{
name|String
name|message
init|=
literal|"Min versions for column family "
operator|+
name|hcd
operator|.
name|getNameAsString
argument_list|()
operator|+
literal|"  must be positive."
decl_stmt|;
name|warnOrThrowExceptionForFailure
argument_list|(
name|logWarn
argument_list|,
name|CONF_KEY
argument_list|,
name|message
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// max versions already being checked
comment|// HBASE-13776 Setting illegal versions for HColumnDescriptor
comment|//  does not throw IllegalArgumentException
comment|// check minVersions<= maxVerions
if|if
condition|(
name|hcd
operator|.
name|getMinVersions
argument_list|()
operator|>
name|hcd
operator|.
name|getMaxVersions
argument_list|()
condition|)
block|{
name|String
name|message
init|=
literal|"Min versions for column family "
operator|+
name|hcd
operator|.
name|getNameAsString
argument_list|()
operator|+
literal|" must be less than the Max versions."
decl_stmt|;
name|warnOrThrowExceptionForFailure
argument_list|(
name|logWarn
argument_list|,
name|CONF_KEY
argument_list|,
name|message
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// check replication scope
name|checkReplicationScope
argument_list|(
name|hcd
argument_list|)
expr_stmt|;
comment|// check data replication factor, it can be 0(default value) when user has not explicitly
comment|// set the value, in this case we use default replication factor set in the file system.
if|if
condition|(
name|hcd
operator|.
name|getDFSReplication
argument_list|()
operator|<
literal|0
condition|)
block|{
name|String
name|message
init|=
literal|"HFile Replication for column family "
operator|+
name|hcd
operator|.
name|getNameAsString
argument_list|()
operator|+
literal|"  must be greater than zero."
decl_stmt|;
name|warnOrThrowExceptionForFailure
argument_list|(
name|logWarn
argument_list|,
name|CONF_KEY
argument_list|,
name|message
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// TODO: should we check coprocessors and encryption ?
block|}
block|}
specifier|private
name|void
name|checkReplicationScope
parameter_list|(
name|HColumnDescriptor
name|hcd
parameter_list|)
throws|throws
name|IOException
block|{
comment|// check replication scope
name|WALProtos
operator|.
name|ScopeType
name|scop
init|=
name|WALProtos
operator|.
name|ScopeType
operator|.
name|valueOf
argument_list|(
name|hcd
operator|.
name|getScope
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|scop
operator|==
literal|null
condition|)
block|{
name|String
name|message
init|=
literal|"Replication scope for column family "
operator|+
name|hcd
operator|.
name|getNameAsString
argument_list|()
operator|+
literal|" is "
operator|+
name|hcd
operator|.
name|getScope
argument_list|()
operator|+
literal|" which is invalid."
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DoNotRetryIOException
argument_list|(
name|message
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|checkCompactionPolicy
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|HTableDescriptor
name|htd
parameter_list|)
throws|throws
name|IOException
block|{
comment|// FIFO compaction has some requirements
comment|// Actually FCP ignores periodic major compactions
name|String
name|className
init|=
name|htd
operator|.
name|getConfigurationValue
argument_list|(
name|DefaultStoreEngine
operator|.
name|DEFAULT_COMPACTION_POLICY_CLASS_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|className
operator|==
literal|null
condition|)
block|{
name|className
operator|=
name|conf
operator|.
name|get
argument_list|(
name|DefaultStoreEngine
operator|.
name|DEFAULT_COMPACTION_POLICY_CLASS_KEY
argument_list|,
name|ExploringCompactionPolicy
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
name|blockingFileCount
init|=
name|HStore
operator|.
name|DEFAULT_BLOCKING_STOREFILE_COUNT
decl_stmt|;
name|String
name|sv
init|=
name|htd
operator|.
name|getConfigurationValue
argument_list|(
name|HStore
operator|.
name|BLOCKING_STOREFILES_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|sv
operator|!=
literal|null
condition|)
block|{
name|blockingFileCount
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|blockingFileCount
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|HStore
operator|.
name|BLOCKING_STOREFILES_KEY
argument_list|,
name|blockingFileCount
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|HColumnDescriptor
name|hcd
range|:
name|htd
operator|.
name|getColumnFamilies
argument_list|()
control|)
block|{
name|String
name|compactionPolicy
init|=
name|hcd
operator|.
name|getConfigurationValue
argument_list|(
name|DefaultStoreEngine
operator|.
name|DEFAULT_COMPACTION_POLICY_CLASS_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|compactionPolicy
operator|==
literal|null
condition|)
block|{
name|compactionPolicy
operator|=
name|className
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|compactionPolicy
operator|.
name|equals
argument_list|(
name|FIFOCompactionPolicy
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// FIFOCompaction
name|String
name|message
init|=
literal|null
decl_stmt|;
comment|// 1. Check TTL
if|if
condition|(
name|hcd
operator|.
name|getTimeToLive
argument_list|()
operator|==
name|HColumnDescriptor
operator|.
name|DEFAULT_TTL
condition|)
block|{
name|message
operator|=
literal|"Default TTL is not supported for FIFO compaction"
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|message
argument_list|)
throw|;
block|}
comment|// 2. Check min versions
if|if
condition|(
name|hcd
operator|.
name|getMinVersions
argument_list|()
operator|>
literal|0
condition|)
block|{
name|message
operator|=
literal|"MIN_VERSION> 0 is not supported for FIFO compaction"
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|message
argument_list|)
throw|;
block|}
comment|// 3. blocking file count
name|String
name|sbfc
init|=
name|htd
operator|.
name|getConfigurationValue
argument_list|(
name|HStore
operator|.
name|BLOCKING_STOREFILES_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|sbfc
operator|!=
literal|null
condition|)
block|{
name|blockingFileCount
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|sbfc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|blockingFileCount
operator|<
literal|1000
condition|)
block|{
name|message
operator|=
literal|"blocking file count '"
operator|+
name|HStore
operator|.
name|BLOCKING_STOREFILES_KEY
operator|+
literal|"' "
operator|+
name|blockingFileCount
operator|+
literal|" is below recommended minimum of 1000"
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|message
argument_list|)
throw|;
block|}
block|}
block|}
comment|// HBASE-13350 - Helper method to log warning on sanity check failures if checks disabled.
specifier|private
specifier|static
name|void
name|warnOrThrowExceptionForFailure
parameter_list|(
name|boolean
name|logWarn
parameter_list|,
name|String
name|confKey
parameter_list|,
name|String
name|message
parameter_list|,
name|Exception
name|cause
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|logWarn
condition|)
block|{
throw|throw
operator|new
name|DoNotRetryIOException
argument_list|(
name|message
operator|+
literal|" Set "
operator|+
name|confKey
operator|+
literal|" to false at conf or table descriptor if you want to bypass sanity checks"
argument_list|,
name|cause
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|startActiveMasterManager
parameter_list|(
name|int
name|infoPort
parameter_list|)
throws|throws
name|KeeperException
block|{
name|String
name|backupZNode
init|=
name|ZKUtil
operator|.
name|joinZNode
argument_list|(
name|zooKeeper
operator|.
name|backupMasterAddressesZNode
argument_list|,
name|serverName
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
comment|/*     * Add a ZNode for ourselves in the backup master directory since we     * may not become the active master. If so, we want the actual active     * master to know we are backup masters, so that it won't assign     * regions to us if so configured.     *     * If we become the active master later, ActiveMasterManager will delete     * this node explicitly.  If we crash before then, ZooKeeper will delete     * this node for us since it is ephemeral.     */
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding backup master ZNode "
operator|+
name|backupZNode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MasterAddressTracker
operator|.
name|setMasterAddress
argument_list|(
name|zooKeeper
argument_list|,
name|backupZNode
argument_list|,
name|serverName
argument_list|,
name|infoPort
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed create of "
operator|+
name|backupZNode
operator|+
literal|" by "
operator|+
name|serverName
argument_list|)
expr_stmt|;
block|}
name|activeMasterManager
operator|.
name|setInfoPort
argument_list|(
name|infoPort
argument_list|)
expr_stmt|;
comment|// Start a thread to try to become the active master, so we won't block here
name|Threads
operator|.
name|setDaemonThreadRunning
argument_list|(
operator|new
name|Thread
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|int
name|timeout
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|ZK_SESSION_TIMEOUT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_ZK_SESSION_TIMEOUT
argument_list|)
decl_stmt|;
comment|// If we're a backup master, stall until a primary to writes his address
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|HConstants
operator|.
name|MASTER_TYPE_BACKUP
argument_list|,
name|HConstants
operator|.
name|DEFAULT_MASTER_TYPE_BACKUP
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"HMaster started in backup mode. "
operator|+
literal|"Stalling until master znode is written."
argument_list|)
expr_stmt|;
comment|// This will only be a minute or so while the cluster starts up,
comment|// so don't worry about setting watches on the parent znode
while|while
condition|(
operator|!
name|activeMasterManager
operator|.
name|hasActiveMaster
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting for master address ZNode to be written "
operator|+
literal|"(Also watching cluster state node)"
argument_list|)
expr_stmt|;
name|Threads
operator|.
name|sleep
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
name|MonitoredTask
name|status
init|=
name|TaskMonitor
operator|.
name|get
argument_list|()
operator|.
name|createStatus
argument_list|(
literal|"Master startup"
argument_list|)
decl_stmt|;
name|status
operator|.
name|setDescription
argument_list|(
literal|"Master startup"
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|activeMasterManager
operator|.
name|blockUntilBecomingActiveMaster
argument_list|(
name|timeout
argument_list|,
name|status
argument_list|)
condition|)
block|{
name|finishActiveMasterInitialization
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|status
operator|.
name|setStatus
argument_list|(
literal|"Failed to become active: "
operator|+
name|t
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Failed to become active master"
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|// HBASE-5680: Likely hadoop23 vs hadoop 20.x/1.x incompatibility
if|if
condition|(
name|t
operator|instanceof
name|NoClassDefFoundError
operator|&&
name|t
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"org/apache/hadoop/hdfs/protocol/HdfsConstants$SafeModeAction"
argument_list|)
condition|)
block|{
comment|// improved error message for this special case
name|abort
argument_list|(
literal|"HBase is having a problem with its Hadoop jars.  You may need to "
operator|+
literal|"recompile HBase against Hadoop version "
operator|+
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|VersionInfo
operator|.
name|getVersion
argument_list|()
operator|+
literal|" or change your hadoop jars to start properly"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|abort
argument_list|(
literal|"Unhandled exception. Starting shutdown."
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|status
operator|.
name|cleanup
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|,
name|getServerName
argument_list|()
operator|.
name|toShortString
argument_list|()
operator|+
literal|".activeMasterManager"
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkCompression
parameter_list|(
specifier|final
name|HTableDescriptor
name|htd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|masterCheckCompression
condition|)
return|return;
for|for
control|(
name|HColumnDescriptor
name|hcd
range|:
name|htd
operator|.
name|getColumnFamilies
argument_list|()
control|)
block|{
name|checkCompression
argument_list|(
name|hcd
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|checkCompression
parameter_list|(
specifier|final
name|HColumnDescriptor
name|hcd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|masterCheckCompression
condition|)
return|return;
name|CompressionTest
operator|.
name|testCompression
argument_list|(
name|hcd
operator|.
name|getCompressionType
argument_list|()
argument_list|)
expr_stmt|;
name|CompressionTest
operator|.
name|testCompression
argument_list|(
name|hcd
operator|.
name|getCompactionCompressionType
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkEncryption
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|HTableDescriptor
name|htd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|masterCheckEncryption
condition|)
return|return;
for|for
control|(
name|HColumnDescriptor
name|hcd
range|:
name|htd
operator|.
name|getColumnFamilies
argument_list|()
control|)
block|{
name|checkEncryption
argument_list|(
name|conf
argument_list|,
name|hcd
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|checkEncryption
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|HColumnDescriptor
name|hcd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|masterCheckEncryption
condition|)
return|return;
name|EncryptionTest
operator|.
name|testEncryption
argument_list|(
name|conf
argument_list|,
name|hcd
operator|.
name|getEncryptionType
argument_list|()
argument_list|,
name|hcd
operator|.
name|getEncryptionKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|checkClassLoading
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|HTableDescriptor
name|htd
parameter_list|)
throws|throws
name|IOException
block|{
name|RegionSplitPolicy
operator|.
name|getSplitPolicyClass
argument_list|(
name|htd
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|RegionCoprocessorHost
operator|.
name|testTableCoprocessorAttrs
argument_list|(
name|conf
argument_list|,
name|htd
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|boolean
name|isCatalogTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
block|{
return|return
name|tableName
operator|.
name|equals
argument_list|(
name|TableName
operator|.
name|META_TABLE_NAME
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|deleteTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preDeleteTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" delete "
operator|+
name|tableName
argument_list|)
expr_stmt|;
comment|// TODO: We can handle/merge duplicate request
name|ProcedurePrepareLatch
name|latch
init|=
name|ProcedurePrepareLatch
operator|.
name|createLatch
argument_list|()
decl_stmt|;
name|long
name|procId
init|=
name|this
operator|.
name|procedureExecutor
operator|.
name|submitProcedure
argument_list|(
operator|new
name|DeleteTableProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|tableName
argument_list|,
name|latch
argument_list|)
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
decl_stmt|;
name|latch
operator|.
name|await
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postDeleteTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
return|return
name|procId
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|truncateTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|boolean
name|preserveSplits
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preTruncateTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" truncate "
operator|+
name|tableName
argument_list|)
expr_stmt|;
name|long
name|procId
init|=
name|this
operator|.
name|procedureExecutor
operator|.
name|submitProcedure
argument_list|(
operator|new
name|TruncateTableProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|tableName
argument_list|,
name|preserveSplits
argument_list|)
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
decl_stmt|;
name|ProcedureSyncWait
operator|.
name|waitForProcedureToComplete
argument_list|(
name|procedureExecutor
argument_list|,
name|procId
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postTruncateTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
return|return
name|procId
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|addColumn
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|HColumnDescriptor
name|columnDescriptor
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
name|checkCompression
argument_list|(
name|columnDescriptor
argument_list|)
expr_stmt|;
name|checkEncryption
argument_list|(
name|conf
argument_list|,
name|columnDescriptor
argument_list|)
expr_stmt|;
name|checkReplicationScope
argument_list|(
name|columnDescriptor
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|cpHost
operator|.
name|preAddColumn
argument_list|(
name|tableName
argument_list|,
name|columnDescriptor
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|// Execute the operation synchronously - wait for the operation to complete before continuing.
name|long
name|procId
init|=
name|this
operator|.
name|procedureExecutor
operator|.
name|submitProcedure
argument_list|(
operator|new
name|AddColumnFamilyProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|tableName
argument_list|,
name|columnDescriptor
argument_list|)
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
decl_stmt|;
name|ProcedureSyncWait
operator|.
name|waitForProcedureToComplete
argument_list|(
name|procedureExecutor
argument_list|,
name|procId
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postAddColumn
argument_list|(
name|tableName
argument_list|,
name|columnDescriptor
argument_list|)
expr_stmt|;
block|}
return|return
name|procId
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|modifyColumn
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|HColumnDescriptor
name|descriptor
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
name|checkCompression
argument_list|(
name|descriptor
argument_list|)
expr_stmt|;
name|checkEncryption
argument_list|(
name|conf
argument_list|,
name|descriptor
argument_list|)
expr_stmt|;
name|checkReplicationScope
argument_list|(
name|descriptor
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|cpHost
operator|.
name|preModifyColumn
argument_list|(
name|tableName
argument_list|,
name|descriptor
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" modify "
operator|+
name|descriptor
argument_list|)
expr_stmt|;
comment|// Execute the operation synchronously - wait for the operation to complete before continuing.
name|long
name|procId
init|=
name|this
operator|.
name|procedureExecutor
operator|.
name|submitProcedure
argument_list|(
operator|new
name|ModifyColumnFamilyProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|tableName
argument_list|,
name|descriptor
argument_list|)
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
decl_stmt|;
name|ProcedureSyncWait
operator|.
name|waitForProcedureToComplete
argument_list|(
name|procedureExecutor
argument_list|,
name|procId
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postModifyColumn
argument_list|(
name|tableName
argument_list|,
name|descriptor
argument_list|)
expr_stmt|;
block|}
return|return
name|procId
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|deleteColumn
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|columnName
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|cpHost
operator|.
name|preDeleteColumn
argument_list|(
name|tableName
argument_list|,
name|columnName
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" delete "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|columnName
argument_list|)
argument_list|)
expr_stmt|;
comment|// Execute the operation synchronously - wait for the operation to complete before continuing.
name|long
name|procId
init|=
name|this
operator|.
name|procedureExecutor
operator|.
name|submitProcedure
argument_list|(
operator|new
name|DeleteColumnFamilyProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|tableName
argument_list|,
name|columnName
argument_list|)
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
decl_stmt|;
name|ProcedureSyncWait
operator|.
name|waitForProcedureToComplete
argument_list|(
name|procedureExecutor
argument_list|,
name|procId
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postDeleteColumn
argument_list|(
name|tableName
argument_list|,
name|columnName
argument_list|)
expr_stmt|;
block|}
return|return
name|procId
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|enableTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preEnableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" enable "
operator|+
name|tableName
argument_list|)
expr_stmt|;
comment|// Execute the operation asynchronously - client will check the progress of the operation
specifier|final
name|ProcedurePrepareLatch
name|prepareLatch
init|=
name|ProcedurePrepareLatch
operator|.
name|createLatch
argument_list|()
decl_stmt|;
name|long
name|procId
init|=
name|this
operator|.
name|procedureExecutor
operator|.
name|submitProcedure
argument_list|(
operator|new
name|EnableTableProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|tableName
argument_list|,
literal|false
argument_list|,
name|prepareLatch
argument_list|)
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
decl_stmt|;
comment|// Before returning to client, we want to make sure that the table is prepared to be
comment|// enabled (the table is locked and the table state is set).
comment|//
comment|// Note: if the procedure throws exception, we will catch it and rethrow.
name|prepareLatch
operator|.
name|await
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postEnableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
return|return
name|procId
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|disableTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preDisableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" disable "
operator|+
name|tableName
argument_list|)
expr_stmt|;
comment|// Execute the operation asynchronously - client will check the progress of the operation
specifier|final
name|ProcedurePrepareLatch
name|prepareLatch
init|=
name|ProcedurePrepareLatch
operator|.
name|createLatch
argument_list|()
decl_stmt|;
comment|// Execute the operation asynchronously - client will check the progress of the operation
name|long
name|procId
init|=
name|this
operator|.
name|procedureExecutor
operator|.
name|submitProcedure
argument_list|(
operator|new
name|DisableTableProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|tableName
argument_list|,
literal|false
argument_list|,
name|prepareLatch
argument_list|)
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
decl_stmt|;
comment|// Before returning to client, we want to make sure that the table is prepared to be
comment|// enabled (the table is locked and the table state is set).
comment|//
comment|// Note: if the procedure throws exception, we will catch it and rethrow.
name|prepareLatch
operator|.
name|await
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postDisableTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
return|return
name|procId
return|;
block|}
comment|/**    * Return the region and current deployment for the region containing    * the given row. If the region cannot be found, returns null. If it    * is found, but not currently deployed, the second element of the pair    * may be null.    */
annotation|@
name|VisibleForTesting
comment|// Used by TestMaster.
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|getTableRegionForRow
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|byte
index|[]
name|rowKey
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|AtomicReference
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|AtomicReference
argument_list|<
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
argument_list|>
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|MetaTableAccessor
operator|.
name|Visitor
name|visitor
init|=
operator|new
name|MetaTableAccessor
operator|.
name|Visitor
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|visit
parameter_list|(
name|Result
name|data
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|data
operator|==
literal|null
operator|||
name|data
operator|.
name|size
argument_list|()
operator|<=
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
name|Pair
argument_list|<
name|HRegionInfo
argument_list|,
name|ServerName
argument_list|>
name|pair
init|=
operator|new
name|Pair
argument_list|(
name|MetaTableAccessor
operator|.
name|getHRegionInfo
argument_list|(
name|data
argument_list|)
argument_list|,
name|MetaTableAccessor
operator|.
name|getServerName
argument_list|(
name|data
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|pair
operator|.
name|getFirst
argument_list|()
operator|.
name|getTable
argument_list|()
operator|.
name|equals
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|result
operator|.
name|set
argument_list|(
name|pair
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
decl_stmt|;
name|MetaTableAccessor
operator|.
name|scanMeta
argument_list|(
name|clusterConnection
argument_list|,
name|visitor
argument_list|,
name|tableName
argument_list|,
name|rowKey
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|result
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|modifyTable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|,
specifier|final
name|HTableDescriptor
name|descriptor
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
name|sanityCheckTableDescriptor
argument_list|(
name|descriptor
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preModifyTable
argument_list|(
name|tableName
argument_list|,
name|descriptor
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" modify "
operator|+
name|tableName
argument_list|)
expr_stmt|;
comment|// Execute the operation synchronously - wait for the operation completes before continuing.
name|long
name|procId
init|=
name|this
operator|.
name|procedureExecutor
operator|.
name|submitProcedure
argument_list|(
operator|new
name|ModifyTableProcedure
argument_list|(
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
argument_list|,
name|descriptor
argument_list|)
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
decl_stmt|;
name|ProcedureSyncWait
operator|.
name|waitForProcedureToComplete
argument_list|(
name|procedureExecutor
argument_list|,
name|procId
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postModifyTable
argument_list|(
name|tableName
argument_list|,
name|descriptor
argument_list|)
expr_stmt|;
block|}
return|return
name|procId
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|checkTableModifiable
parameter_list|(
specifier|final
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
throws|,
name|TableNotFoundException
throws|,
name|TableNotDisabledException
block|{
if|if
condition|(
name|isCatalogTable
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can't modify catalog tables"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|MetaTableAccessor
operator|.
name|tableExists
argument_list|(
name|getConnection
argument_list|()
argument_list|,
name|tableName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TableNotFoundException
argument_list|(
name|tableName
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|getTableStateManager
argument_list|()
operator|.
name|isTableState
argument_list|(
name|tableName
argument_list|,
name|TableState
operator|.
name|State
operator|.
name|DISABLED
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TableNotDisabledException
argument_list|(
name|tableName
argument_list|)
throw|;
block|}
block|}
comment|/**    * @return cluster status    */
specifier|public
name|ClusterStatus
name|getClusterStatus
parameter_list|()
throws|throws
name|InterruptedIOException
block|{
comment|// Build Set of backup masters from ZK nodes
name|List
argument_list|<
name|String
argument_list|>
name|backupMasterStrings
decl_stmt|;
try|try
block|{
name|backupMasterStrings
operator|=
name|ZKUtil
operator|.
name|listChildrenNoWatch
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|this
operator|.
name|zooKeeper
operator|.
name|backupMasterAddressesZNode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|prefix
argument_list|(
literal|"Unable to list backup servers"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|backupMasterStrings
operator|=
literal|null
expr_stmt|;
block|}
name|List
argument_list|<
name|ServerName
argument_list|>
name|backupMasters
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|backupMasterStrings
operator|!=
literal|null
operator|&&
operator|!
name|backupMasterStrings
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|backupMasters
operator|=
operator|new
name|ArrayList
argument_list|<
name|ServerName
argument_list|>
argument_list|(
name|backupMasterStrings
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|backupMasterStrings
control|)
block|{
try|try
block|{
name|byte
index|[]
name|bytes
decl_stmt|;
try|try
block|{
name|bytes
operator|=
name|ZKUtil
operator|.
name|getData
argument_list|(
name|this
operator|.
name|zooKeeper
argument_list|,
name|ZKUtil
operator|.
name|joinZNode
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|backupMasterAddressesZNode
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InterruptedIOException
argument_list|()
throw|;
block|}
if|if
condition|(
name|bytes
operator|!=
literal|null
condition|)
block|{
name|ServerName
name|sn
decl_stmt|;
try|try
block|{
name|sn
operator|=
name|ServerName
operator|.
name|parseFrom
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DeserializationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed parse, skipping registering backup server"
argument_list|,
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|backupMasters
operator|.
name|add
argument_list|(
name|sn
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|this
operator|.
name|zooKeeper
operator|.
name|prefix
argument_list|(
literal|"Unable to get information about "
operator|+
literal|"backup servers"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|backupMasters
argument_list|,
operator|new
name|Comparator
argument_list|<
name|ServerName
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|ServerName
name|s1
parameter_list|,
name|ServerName
name|s2
parameter_list|)
block|{
return|return
name|s1
operator|.
name|getServerName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|s2
operator|.
name|getServerName
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
name|String
name|clusterId
init|=
name|fileSystemManager
operator|!=
literal|null
condition|?
name|fileSystemManager
operator|.
name|getClusterId
argument_list|()
operator|.
name|toString
argument_list|()
else|:
literal|null
decl_stmt|;
name|Set
argument_list|<
name|RegionState
argument_list|>
name|regionsInTransition
init|=
name|assignmentManager
operator|!=
literal|null
condition|?
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
operator|.
name|getRegionsInTransition
argument_list|()
else|:
literal|null
decl_stmt|;
name|String
index|[]
name|coprocessors
init|=
name|cpHost
operator|!=
literal|null
condition|?
name|getMasterCoprocessors
argument_list|()
else|:
literal|null
decl_stmt|;
name|boolean
name|balancerOn
init|=
name|loadBalancerTracker
operator|!=
literal|null
condition|?
name|loadBalancerTracker
operator|.
name|isBalancerOn
argument_list|()
else|:
literal|false
decl_stmt|;
name|Map
argument_list|<
name|ServerName
argument_list|,
name|ServerLoad
argument_list|>
name|onlineServers
init|=
literal|null
decl_stmt|;
name|Set
argument_list|<
name|ServerName
argument_list|>
name|deadServers
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|serverManager
operator|!=
literal|null
condition|)
block|{
name|deadServers
operator|=
name|serverManager
operator|.
name|getDeadServers
argument_list|()
operator|.
name|copyServerNames
argument_list|()
expr_stmt|;
name|onlineServers
operator|=
name|serverManager
operator|.
name|getOnlineServers
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|ClusterStatus
argument_list|(
name|VersionInfo
operator|.
name|getVersion
argument_list|()
argument_list|,
name|clusterId
argument_list|,
name|onlineServers
argument_list|,
name|deadServers
argument_list|,
name|serverName
argument_list|,
name|backupMasters
argument_list|,
name|regionsInTransition
argument_list|,
name|coprocessors
argument_list|,
name|balancerOn
argument_list|)
return|;
block|}
comment|/**    * The set of loaded coprocessors is stored in a static set. Since it's    * statically allocated, it does not require that HMaster's cpHost be    * initialized prior to accessing it.    * @return a String representation of the set of names of the loaded coprocessors.    */
specifier|public
specifier|static
name|String
name|getLoadedCoprocessors
parameter_list|()
block|{
return|return
name|CoprocessorHost
operator|.
name|getLoadedCoprocessors
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * @return timestamp in millis when HMaster was started.    */
specifier|public
name|long
name|getMasterStartTime
parameter_list|()
block|{
return|return
name|startcode
return|;
block|}
comment|/**    * @return timestamp in millis when HMaster became the active master.    */
specifier|public
name|long
name|getMasterActiveTime
parameter_list|()
block|{
return|return
name|masterActiveTime
return|;
block|}
specifier|public
name|int
name|getNumWALFiles
parameter_list|()
block|{
return|return
name|procedureStore
operator|!=
literal|null
condition|?
name|procedureStore
operator|.
name|getActiveLogs
argument_list|()
operator|.
name|size
argument_list|()
else|:
literal|0
return|;
block|}
specifier|public
name|WALProcedureStore
name|getWalProcedureStore
parameter_list|()
block|{
return|return
name|procedureStore
return|;
block|}
specifier|public
name|int
name|getRegionServerInfoPort
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|)
block|{
name|RegionServerInfo
name|info
init|=
name|this
operator|.
name|regionServerTracker
operator|.
name|getRegionServerInfo
argument_list|(
name|sn
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
operator|||
name|info
operator|.
name|getInfoPort
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|conf
operator|.
name|getInt
argument_list|(
name|HConstants
operator|.
name|REGIONSERVER_INFO_PORT
argument_list|,
name|HConstants
operator|.
name|DEFAULT_REGIONSERVER_INFOPORT
argument_list|)
return|;
block|}
return|return
name|info
operator|.
name|getInfoPort
argument_list|()
return|;
block|}
specifier|public
name|String
name|getRegionServerVersion
parameter_list|(
specifier|final
name|ServerName
name|sn
parameter_list|)
block|{
name|RegionServerInfo
name|info
init|=
name|this
operator|.
name|regionServerTracker
operator|.
name|getRegionServerInfo
argument_list|(
name|sn
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
operator|&&
name|info
operator|.
name|hasVersionInfo
argument_list|()
condition|)
block|{
return|return
name|info
operator|.
name|getVersionInfo
argument_list|()
operator|.
name|getVersion
argument_list|()
return|;
block|}
return|return
literal|"Unknown"
return|;
block|}
comment|/**    * @return array of coprocessor SimpleNames.    */
specifier|public
name|String
index|[]
name|getMasterCoprocessors
parameter_list|()
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|masterCoprocessors
init|=
name|getMasterCoprocessorHost
argument_list|()
operator|.
name|getCoprocessors
argument_list|()
decl_stmt|;
return|return
name|masterCoprocessors
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|masterCoprocessors
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|abort
parameter_list|(
specifier|final
name|String
name|msg
parameter_list|,
specifier|final
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|isAborted
argument_list|()
operator|||
name|isStopped
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
comment|// HBASE-4014: dump a list of loaded coprocessors.
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Master server abort: loaded coprocessors are: "
operator|+
name|getLoadedCoprocessors
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
name|LOG
operator|.
name|fatal
argument_list|(
name|msg
argument_list|,
name|t
argument_list|)
expr_stmt|;
try|try
block|{
name|stopMaster
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception occurred while stopping master"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|ZooKeeperWatcher
name|getZooKeeper
parameter_list|()
block|{
return|return
name|zooKeeper
return|;
block|}
annotation|@
name|Override
specifier|public
name|MasterCoprocessorHost
name|getMasterCoprocessorHost
parameter_list|()
block|{
return|return
name|cpHost
return|;
block|}
annotation|@
name|Override
specifier|public
name|MasterQuotaManager
name|getMasterQuotaManager
parameter_list|()
block|{
return|return
name|quotaManager
return|;
block|}
annotation|@
name|Override
specifier|public
name|ProcedureExecutor
argument_list|<
name|MasterProcedureEnv
argument_list|>
name|getMasterProcedureExecutor
parameter_list|()
block|{
return|return
name|procedureExecutor
return|;
block|}
annotation|@
name|Override
specifier|public
name|ServerName
name|getServerName
parameter_list|()
block|{
return|return
name|this
operator|.
name|serverName
return|;
block|}
annotation|@
name|Override
specifier|public
name|AssignmentManager
name|getAssignmentManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|assignmentManager
return|;
block|}
annotation|@
name|Override
specifier|public
name|CatalogJanitor
name|getCatalogJanitor
parameter_list|()
block|{
return|return
name|this
operator|.
name|catalogJanitorChore
return|;
block|}
specifier|public
name|MemoryBoundedLogMessageBuffer
name|getRegionServerFatalLogBuffer
parameter_list|()
block|{
return|return
name|rsFatals
return|;
block|}
specifier|public
name|void
name|shutdown
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preShutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|serverManager
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|serverManager
operator|.
name|shutdownCluster
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|clusterStatusTracker
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|this
operator|.
name|clusterStatusTracker
operator|.
name|setClusterDown
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"ZooKeeper exception trying to set cluster as down in ZK"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|stopMaster
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preStopMaster
argument_list|()
expr_stmt|;
block|}
name|stop
argument_list|(
literal|"Stopped by "
operator|+
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|void
name|checkServiceStarted
parameter_list|()
throws|throws
name|ServerNotRunningYetException
block|{
if|if
condition|(
operator|!
name|serviceStarted
condition|)
block|{
throw|throw
operator|new
name|ServerNotRunningYetException
argument_list|(
literal|"Server is not running yet"
argument_list|)
throw|;
block|}
block|}
name|void
name|checkInitialized
parameter_list|()
throws|throws
name|PleaseHoldException
throws|,
name|ServerNotRunningYetException
block|{
name|checkServiceStarted
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isInitialized
argument_list|()
condition|)
throw|throw
operator|new
name|PleaseHoldException
argument_list|(
literal|"Master is initializing"
argument_list|)
throw|;
block|}
comment|/**    * Report whether this master is currently the active master or not.    * If not active master, we are parked on ZK waiting to become active.    *    * This method is used for testing.    *    * @return true if active master, false if not.    */
annotation|@
name|Override
specifier|public
name|boolean
name|isActiveMaster
parameter_list|()
block|{
return|return
name|isActiveMaster
return|;
block|}
comment|/**    * Report whether this master has completed with its initialization and is    * ready.  If ready, the master is also the active master.  A standby master    * is never ready.    *    * This method is used for testing.    *    * @return true if master is ready to go, false if not.    */
annotation|@
name|Override
specifier|public
name|boolean
name|isInitialized
parameter_list|()
block|{
return|return
name|initialized
operator|.
name|isReady
argument_list|()
return|;
block|}
comment|/**    * Report whether this master is in maintenance mode.    *    * @return true if master is in maintenanceMode    */
annotation|@
name|Override
specifier|public
name|boolean
name|isInMaintenanceMode
parameter_list|()
block|{
return|return
name|maintenanceModeTracker
operator|.
name|isInMaintenanceMode
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|void
name|setInitialized
parameter_list|(
name|boolean
name|isInitialized
parameter_list|)
block|{
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
operator|.
name|setEventReady
argument_list|(
name|initialized
argument_list|,
name|isInitialized
argument_list|)
expr_stmt|;
block|}
specifier|public
name|ProcedureEvent
name|getInitializedEvent
parameter_list|()
block|{
return|return
name|initialized
return|;
block|}
comment|/**    * ServerCrashProcessingEnabled is set false before completing assignMeta to prevent processing    * of crashed servers.    * @return true if assignMeta has completed;    */
annotation|@
name|Override
specifier|public
name|boolean
name|isServerCrashProcessingEnabled
parameter_list|()
block|{
return|return
name|serverCrashProcessingEnabled
operator|.
name|isReady
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|void
name|setServerCrashProcessingEnabled
parameter_list|(
specifier|final
name|boolean
name|b
parameter_list|)
block|{
name|procedureExecutor
operator|.
name|getEnvironment
argument_list|()
operator|.
name|setEventReady
argument_list|(
name|serverCrashProcessingEnabled
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
specifier|public
name|ProcedureEvent
name|getServerCrashProcessingEnabledEvent
parameter_list|()
block|{
return|return
name|serverCrashProcessingEnabled
return|;
block|}
comment|/**    * Report whether this master has started initialization and is about to do meta region assignment    * @return true if master is in initialization&amp; about to assign hbase:meta regions    */
specifier|public
name|boolean
name|isInitializationStartsMetaRegionAssignment
parameter_list|()
block|{
return|return
name|this
operator|.
name|initializationBeforeMetaAssignment
return|;
block|}
comment|/**    * Compute the average load across all region servers.    * Currently, this uses a very naive computation - just uses the number of    * regions being served, ignoring stats about number of requests.    * @return the average load    */
specifier|public
name|double
name|getAverageLoad
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|assignmentManager
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
name|RegionStates
name|regionStates
init|=
name|this
operator|.
name|assignmentManager
operator|.
name|getRegionStates
argument_list|()
decl_stmt|;
if|if
condition|(
name|regionStates
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|regionStates
operator|.
name|getAverageLoad
argument_list|()
return|;
block|}
comment|/*    * @return the count of region split plans executed    */
specifier|public
name|long
name|getSplitPlanCount
parameter_list|()
block|{
return|return
name|splitPlanCount
return|;
block|}
comment|/*    * @return the count of region merge plans executed    */
specifier|public
name|long
name|getMergePlanCount
parameter_list|()
block|{
return|return
name|mergePlanCount
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|registerService
parameter_list|(
name|Service
name|instance
parameter_list|)
block|{
comment|/*      * No stacking of instances is allowed for a single service name      */
name|Descriptors
operator|.
name|ServiceDescriptor
name|serviceDesc
init|=
name|instance
operator|.
name|getDescriptorForType
argument_list|()
decl_stmt|;
name|String
name|serviceName
init|=
name|CoprocessorRpcUtils
operator|.
name|getServiceName
argument_list|(
name|serviceDesc
argument_list|)
decl_stmt|;
if|if
condition|(
name|coprocessorServiceHandlers
operator|.
name|containsKey
argument_list|(
name|serviceName
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Coprocessor service "
operator|+
name|serviceName
operator|+
literal|" already registered, rejecting request from "
operator|+
name|instance
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|coprocessorServiceHandlers
operator|.
name|put
argument_list|(
name|serviceName
argument_list|,
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Registered master coprocessor service: service="
operator|+
name|serviceName
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Utility for constructing an instance of the passed HMaster class.    * @param masterClass    * @return HMaster instance.    */
specifier|public
specifier|static
name|HMaster
name|constructMaster
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|HMaster
argument_list|>
name|masterClass
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|CoordinatedStateManager
name|cp
parameter_list|)
block|{
try|try
block|{
name|Constructor
argument_list|<
name|?
extends|extends
name|HMaster
argument_list|>
name|c
init|=
name|masterClass
operator|.
name|getConstructor
argument_list|(
name|Configuration
operator|.
name|class
argument_list|,
name|CoordinatedStateManager
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|c
operator|.
name|newInstance
argument_list|(
name|conf
argument_list|,
name|cp
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|Throwable
name|error
init|=
name|e
decl_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|InvocationTargetException
operator|&&
operator|(
operator|(
name|InvocationTargetException
operator|)
name|e
operator|)
operator|.
name|getTargetException
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|error
operator|=
operator|(
operator|(
name|InvocationTargetException
operator|)
name|e
operator|)
operator|.
name|getTargetException
argument_list|()
expr_stmt|;
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Failed construction of Master: "
operator|+
name|masterClass
operator|.
name|toString
argument_list|()
operator|+
literal|". "
argument_list|,
name|error
argument_list|)
throw|;
block|}
block|}
comment|/**    * @see org.apache.hadoop.hbase.master.HMasterCommandLine    */
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|VersionInfo
operator|.
name|logVersion
argument_list|()
expr_stmt|;
operator|new
name|HMasterCommandLine
argument_list|(
name|HMaster
operator|.
name|class
argument_list|)
operator|.
name|doMain
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
specifier|public
name|HFileCleaner
name|getHFileCleaner
parameter_list|()
block|{
return|return
name|this
operator|.
name|hfileCleaner
return|;
block|}
comment|/**    * @return the underlying snapshot manager    */
annotation|@
name|Override
specifier|public
name|SnapshotManager
name|getSnapshotManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|snapshotManager
return|;
block|}
comment|/**    * @return the underlying MasterProcedureManagerHost    */
annotation|@
name|Override
specifier|public
name|MasterProcedureManagerHost
name|getMasterProcedureManagerHost
parameter_list|()
block|{
return|return
name|mpmHost
return|;
block|}
annotation|@
name|Override
specifier|public
name|ClusterSchema
name|getClusterSchema
parameter_list|()
block|{
return|return
name|this
operator|.
name|clusterSchemaService
return|;
block|}
comment|/**    * Create a new Namespace.    * @param namespaceDescriptor descriptor for new Namespace    * @param nonceGroup Identifier for the source of the request, a client or process.    * @param nonce A unique identifier for this operation from the client or process identified by    *<code>nonceGroup</code> (the source must ensure each operation gets a unique id).    * @return procedure id    */
name|long
name|createNamespace
parameter_list|(
specifier|final
name|NamespaceDescriptor
name|namespaceDescriptor
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
name|TableName
operator|.
name|isLegalNamespaceName
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|namespaceDescriptor
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
operator|&&
name|this
operator|.
name|cpHost
operator|.
name|preCreateNamespace
argument_list|(
name|namespaceDescriptor
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BypassCoprocessorException
argument_list|()
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" creating "
operator|+
name|namespaceDescriptor
argument_list|)
expr_stmt|;
comment|// Execute the operation synchronously - wait for the operation to complete before continuing.
name|long
name|procId
init|=
name|getClusterSchema
argument_list|()
operator|.
name|createNamespace
argument_list|(
name|namespaceDescriptor
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
name|this
operator|.
name|cpHost
operator|.
name|postCreateNamespace
argument_list|(
name|namespaceDescriptor
argument_list|)
expr_stmt|;
return|return
name|procId
return|;
block|}
comment|/**    * Modify an existing Namespace.    * @param nonceGroup Identifier for the source of the request, a client or process.    * @param nonce A unique identifier for this operation from the client or process identified by    *<code>nonceGroup</code> (the source must ensure each operation gets a unique id).    * @return procedure id    */
name|long
name|modifyNamespace
parameter_list|(
specifier|final
name|NamespaceDescriptor
name|namespaceDescriptor
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
name|TableName
operator|.
name|isLegalNamespaceName
argument_list|(
name|Bytes
operator|.
name|toBytes
argument_list|(
name|namespaceDescriptor
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
operator|&&
name|this
operator|.
name|cpHost
operator|.
name|preModifyNamespace
argument_list|(
name|namespaceDescriptor
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BypassCoprocessorException
argument_list|()
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" modify "
operator|+
name|namespaceDescriptor
argument_list|)
expr_stmt|;
comment|// Execute the operation synchronously - wait for the operation to complete before continuing.
name|long
name|procId
init|=
name|getClusterSchema
argument_list|()
operator|.
name|modifyNamespace
argument_list|(
name|namespaceDescriptor
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
name|this
operator|.
name|cpHost
operator|.
name|postModifyNamespace
argument_list|(
name|namespaceDescriptor
argument_list|)
expr_stmt|;
return|return
name|procId
return|;
block|}
comment|/**    * Delete an existing Namespace. Only empty Namespaces (no tables) can be removed.    * @param nonceGroup Identifier for the source of the request, a client or process.    * @param nonce A unique identifier for this operation from the client or process identified by    *<code>nonceGroup</code> (the source must ensure each operation gets a unique id).    * @return procedure id    */
name|long
name|deleteNamespace
parameter_list|(
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|long
name|nonceGroup
parameter_list|,
specifier|final
name|long
name|nonce
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
operator|&&
name|this
operator|.
name|cpHost
operator|.
name|preDeleteNamespace
argument_list|(
name|name
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BypassCoprocessorException
argument_list|()
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|getClientIdAuditPrefix
argument_list|()
operator|+
literal|" delete "
operator|+
name|name
argument_list|)
expr_stmt|;
comment|// Execute the operation synchronously - wait for the operation to complete before continuing.
name|long
name|procId
init|=
name|getClusterSchema
argument_list|()
operator|.
name|deleteNamespace
argument_list|(
name|name
argument_list|,
name|nonceGroup
argument_list|,
name|nonce
argument_list|)
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
name|this
operator|.
name|cpHost
operator|.
name|postDeleteNamespace
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|procId
return|;
block|}
comment|/**    * Get a Namespace    * @param name Name of the Namespace    * @return Namespace descriptor for<code>name</code>    */
name|NamespaceDescriptor
name|getNamespace
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
name|this
operator|.
name|cpHost
operator|.
name|preGetNamespaceDescriptor
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|NamespaceDescriptor
name|nsd
init|=
name|this
operator|.
name|clusterSchemaService
operator|.
name|getNamespace
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
name|this
operator|.
name|cpHost
operator|.
name|postGetNamespaceDescriptor
argument_list|(
name|nsd
argument_list|)
expr_stmt|;
return|return
name|nsd
return|;
block|}
comment|/**    * Get all Namespaces    * @return All Namespace descriptors    */
name|List
argument_list|<
name|NamespaceDescriptor
argument_list|>
name|getNamespaces
parameter_list|()
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
specifier|final
name|List
argument_list|<
name|NamespaceDescriptor
argument_list|>
name|nsds
init|=
operator|new
name|ArrayList
argument_list|<
name|NamespaceDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|bypass
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|bypass
operator|=
name|cpHost
operator|.
name|preListNamespaceDescriptors
argument_list|(
name|nsds
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bypass
condition|)
block|{
name|nsds
operator|.
name|addAll
argument_list|(
name|this
operator|.
name|clusterSchemaService
operator|.
name|getNamespaces
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|cpHost
operator|!=
literal|null
condition|)
name|this
operator|.
name|cpHost
operator|.
name|postListNamespaceDescriptors
argument_list|(
name|nsds
argument_list|)
expr_stmt|;
block|}
return|return
name|nsds
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|TableName
argument_list|>
name|listTableNamesByNamespace
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
return|return
name|listTableNames
argument_list|(
name|name
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|HTableDescriptor
argument_list|>
name|listTableDescriptorsByNamespace
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|checkInitialized
argument_list|()
expr_stmt|;
return|return
name|listTableDescriptors
argument_list|(
name|name
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|abortProcedure
parameter_list|(
specifier|final
name|long
name|procId
parameter_list|,
specifier|final
name|boolean
name|mayInterruptIfRunning
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preAbortProcedure
argument_list|(
name|this
operator|.
name|procedureExecutor
argument_list|,
name|procId
argument_list|)
expr_stmt|;
block|}
specifier|final
name|boolean
name|result
init|=
name|this
operator|.
name|procedureExecutor
operator|.
name|abort
argument_list|(
name|procId
argument_list|,
name|mayInterruptIfRunning
argument_list|)
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postAbortProcedure
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|ProcedureInfo
argument_list|>
name|listProcedures
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|preListProcedures
argument_list|()
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|ProcedureInfo
argument_list|>
name|procInfoList
init|=
name|this
operator|.
name|procedureExecutor
operator|.
name|listProcedures
argument_list|()
decl_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postListProcedures
argument_list|(
name|procInfoList
argument_list|)
expr_stmt|;
block|}
return|return
name|procInfoList
return|;
block|}
comment|/**    * Returns the list of table descriptors that match the specified request    * @param namespace the namespace to query, or null if querying for all    * @param regex The regular expression to match against, or null if querying for all    * @param tableNameList the list of table names, or null if querying for all    * @param includeSysTables False to match only against userspace tables    * @return the list of table descriptors    */
specifier|public
name|List
argument_list|<
name|HTableDescriptor
argument_list|>
name|listTableDescriptors
parameter_list|(
specifier|final
name|String
name|namespace
parameter_list|,
specifier|final
name|String
name|regex
parameter_list|,
specifier|final
name|List
argument_list|<
name|TableName
argument_list|>
name|tableNameList
parameter_list|,
specifier|final
name|boolean
name|includeSysTables
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|HTableDescriptor
argument_list|>
name|htds
init|=
operator|new
name|ArrayList
argument_list|<
name|HTableDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|bypass
init|=
name|cpHost
operator|!=
literal|null
condition|?
name|cpHost
operator|.
name|preGetTableDescriptors
argument_list|(
name|tableNameList
argument_list|,
name|htds
argument_list|,
name|regex
argument_list|)
else|:
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|bypass
condition|)
block|{
name|htds
operator|=
name|getTableDescriptors
argument_list|(
name|htds
argument_list|,
name|namespace
argument_list|,
name|regex
argument_list|,
name|tableNameList
argument_list|,
name|includeSysTables
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
block|{
name|cpHost
operator|.
name|postGetTableDescriptors
argument_list|(
name|tableNameList
argument_list|,
name|htds
argument_list|,
name|regex
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|htds
return|;
block|}
comment|/**    * Returns the list of table names that match the specified request    * @param regex The regular expression to match against, or null if querying for all    * @param namespace the namespace to query, or null if querying for all    * @param includeSysTables False to match only against userspace tables    * @return the list of table names    */
specifier|public
name|List
argument_list|<
name|TableName
argument_list|>
name|listTableNames
parameter_list|(
specifier|final
name|String
name|namespace
parameter_list|,
specifier|final
name|String
name|regex
parameter_list|,
specifier|final
name|boolean
name|includeSysTables
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|HTableDescriptor
argument_list|>
name|htds
init|=
operator|new
name|ArrayList
argument_list|<
name|HTableDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|bypass
init|=
name|cpHost
operator|!=
literal|null
condition|?
name|cpHost
operator|.
name|preGetTableNames
argument_list|(
name|htds
argument_list|,
name|regex
argument_list|)
else|:
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|bypass
condition|)
block|{
name|htds
operator|=
name|getTableDescriptors
argument_list|(
name|htds
argument_list|,
name|namespace
argument_list|,
name|regex
argument_list|,
literal|null
argument_list|,
name|includeSysTables
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpHost
operator|!=
literal|null
condition|)
name|cpHost
operator|.
name|postGetTableNames
argument_list|(
name|htds
argument_list|,
name|regex
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|TableName
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|TableName
argument_list|>
argument_list|(
name|htds
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|HTableDescriptor
name|htd
range|:
name|htds
control|)
name|result
operator|.
name|add
argument_list|(
name|htd
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * @return list of table table descriptors after filtering by regex and whether to include system    *    tables, etc.    * @throws IOException    */
specifier|private
name|List
argument_list|<
name|HTableDescriptor
argument_list|>
name|getTableDescriptors
parameter_list|(
specifier|final
name|List
argument_list|<
name|HTableDescriptor
argument_list|>
name|htds
parameter_list|,
specifier|final
name|String
name|namespace
parameter_list|,
specifier|final
name|String
name|regex
parameter_list|,
specifier|final
name|List
argument_list|<
name|TableName
argument_list|>
name|tableNameList
parameter_list|,
specifier|final
name|boolean
name|includeSysTables
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|tableNameList
operator|==
literal|null
operator|||
name|tableNameList
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// request for all TableDescriptors
name|Collection
argument_list|<
name|HTableDescriptor
argument_list|>
name|allHtds
decl_stmt|;
if|if
condition|(
name|namespace
operator|!=
literal|null
operator|&&
name|namespace
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Do a check on the namespace existence. Will fail if does not exist.
name|this
operator|.
name|clusterSchemaService
operator|.
name|getNamespace
argument_list|(
name|namespace
argument_list|)
expr_stmt|;
name|allHtds
operator|=
name|tableDescriptors
operator|.
name|getByNamespace
argument_list|(
name|namespace
argument_list|)
operator|.
name|values
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|allHtds
operator|=
name|tableDescriptors
operator|.
name|getAll
argument_list|()
operator|.
name|values
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|HTableDescriptor
name|desc
range|:
name|allHtds
control|)
block|{
if|if
condition|(
name|tableStateManager
operator|.
name|isTablePresent
argument_list|(
name|desc
operator|.
name|getTableName
argument_list|()
argument_list|)
operator|&&
operator|(
name|includeSysTables
operator|||
operator|!
name|desc
operator|.
name|getTableName
argument_list|()
operator|.
name|isSystemTable
argument_list|()
operator|)
condition|)
block|{
name|htds
operator|.
name|add
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|TableName
name|s
range|:
name|tableNameList
control|)
block|{
if|if
condition|(
name|tableStateManager
operator|.
name|isTablePresent
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|HTableDescriptor
name|desc
init|=
name|tableDescriptors
operator|.
name|get
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|!=
literal|null
condition|)
block|{
name|htds
operator|.
name|add
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Retains only those matched by regular expression.
if|if
condition|(
name|regex
operator|!=
literal|null
condition|)
name|filterTablesByRegex
argument_list|(
name|htds
argument_list|,
name|Pattern
operator|.
name|compile
argument_list|(
name|regex
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|htds
return|;
block|}
comment|/**    * Removes the table descriptors that don't match the pattern.    * @param descriptors list of table descriptors to filter    * @param pattern the regex to use    */
specifier|private
specifier|static
name|void
name|filterTablesByRegex
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|HTableDescriptor
argument_list|>
name|descriptors
parameter_list|,
specifier|final
name|Pattern
name|pattern
parameter_list|)
block|{
specifier|final
name|String
name|defaultNS
init|=
name|NamespaceDescriptor
operator|.
name|DEFAULT_NAMESPACE_NAME_STR
decl_stmt|;
name|Iterator
argument_list|<
name|HTableDescriptor
argument_list|>
name|itr
init|=
name|descriptors
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|itr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|HTableDescriptor
name|htd
init|=
name|itr
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|tableName
init|=
name|htd
operator|.
name|getTableName
argument_list|()
operator|.
name|getNameAsString
argument_list|()
decl_stmt|;
name|boolean
name|matched
init|=
name|pattern
operator|.
name|matcher
argument_list|(
name|tableName
argument_list|)
operator|.
name|matches
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|matched
operator|&&
name|htd
operator|.
name|getTableName
argument_list|()
operator|.
name|getNamespaceAsString
argument_list|()
operator|.
name|equals
argument_list|(
name|defaultNS
argument_list|)
condition|)
block|{
name|matched
operator|=
name|pattern
operator|.
name|matcher
argument_list|(
name|defaultNS
operator|+
name|TableName
operator|.
name|NAMESPACE_DELIM
operator|+
name|tableName
argument_list|)
operator|.
name|matches
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|matched
condition|)
block|{
name|itr
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|long
name|getLastMajorCompactionTimestamp
parameter_list|(
name|TableName
name|table
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getClusterStatus
argument_list|()
operator|.
name|getLastMajorCompactionTsForTable
argument_list|(
name|table
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getLastMajorCompactionTimestampForRegion
parameter_list|(
name|byte
index|[]
name|regionName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getClusterStatus
argument_list|()
operator|.
name|getLastMajorCompactionTsForRegion
argument_list|(
name|regionName
argument_list|)
return|;
block|}
comment|/**    * Gets the mob file compaction state for a specific table.    * Whether all the mob files are selected is known during the compaction execution, but    * the statistic is done just before compaction starts, it is hard to know the compaction    * type at that time, so the rough statistics are chosen for the mob file compaction. Only two    * compaction states are available, CompactionState.MAJOR_AND_MINOR and CompactionState.NONE.    * @param tableName The current table name.    * @return If a given table is in mob file compaction now.    */
specifier|public
name|CompactionState
name|getMobCompactionState
parameter_list|(
name|TableName
name|tableName
parameter_list|)
block|{
name|AtomicInteger
name|compactionsCount
init|=
name|mobCompactionStates
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|compactionsCount
operator|!=
literal|null
operator|&&
name|compactionsCount
operator|.
name|get
argument_list|()
operator|!=
literal|0
condition|)
block|{
return|return
name|CompactionState
operator|.
name|MAJOR_AND_MINOR
return|;
block|}
return|return
name|CompactionState
operator|.
name|NONE
return|;
block|}
specifier|public
name|void
name|reportMobCompactionStart
parameter_list|(
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|IdLock
operator|.
name|Entry
name|lockEntry
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lockEntry
operator|=
name|mobCompactionLock
operator|.
name|getLockEntry
argument_list|(
name|tableName
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
name|AtomicInteger
name|compactionsCount
init|=
name|mobCompactionStates
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|compactionsCount
operator|==
literal|null
condition|)
block|{
name|compactionsCount
operator|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|mobCompactionStates
operator|.
name|put
argument_list|(
name|tableName
argument_list|,
name|compactionsCount
argument_list|)
expr_stmt|;
block|}
name|compactionsCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|lockEntry
operator|!=
literal|null
condition|)
block|{
name|mobCompactionLock
operator|.
name|releaseLockEntry
argument_list|(
name|lockEntry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|reportMobCompactionEnd
parameter_list|(
name|TableName
name|tableName
parameter_list|)
throws|throws
name|IOException
block|{
name|IdLock
operator|.
name|Entry
name|lockEntry
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lockEntry
operator|=
name|mobCompactionLock
operator|.
name|getLockEntry
argument_list|(
name|tableName
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
name|AtomicInteger
name|compactionsCount
init|=
name|mobCompactionStates
operator|.
name|get
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|compactionsCount
operator|!=
literal|null
condition|)
block|{
name|int
name|count
init|=
name|compactionsCount
operator|.
name|decrementAndGet
argument_list|()
decl_stmt|;
comment|// remove the entry if the count is 0.
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|mobCompactionStates
operator|.
name|remove
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|lockEntry
operator|!=
literal|null
condition|)
block|{
name|mobCompactionLock
operator|.
name|releaseLockEntry
argument_list|(
name|lockEntry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Requests mob compaction.    * @param tableName The table the compact.    * @param columns The compacted columns.    * @param allFiles Whether add all mob files into the compaction.    */
specifier|public
name|void
name|requestMobCompaction
parameter_list|(
name|TableName
name|tableName
parameter_list|,
name|List
argument_list|<
name|HColumnDescriptor
argument_list|>
name|columns
parameter_list|,
name|boolean
name|allFiles
parameter_list|)
throws|throws
name|IOException
block|{
name|mobCompactThread
operator|.
name|requestMobCompaction
argument_list|(
name|conf
argument_list|,
name|fs
argument_list|,
name|tableName
argument_list|,
name|columns
argument_list|,
name|tableLockManager
argument_list|,
name|allFiles
argument_list|)
expr_stmt|;
block|}
comment|/**    * Queries the state of the {@link LoadBalancerTracker}. If the balancer is not initialized,    * false is returned.    *    * @return The state of the load balancer, or false if the load balancer isn't defined.    */
specifier|public
name|boolean
name|isBalancerOn
parameter_list|()
block|{
if|if
condition|(
literal|null
operator|==
name|loadBalancerTracker
operator|||
name|isInMaintenanceMode
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|loadBalancerTracker
operator|.
name|isBalancerOn
argument_list|()
return|;
block|}
comment|/**    * Queries the state of the {@link RegionNormalizerTracker}. If it's not initialized,    * false is returned.    */
specifier|public
name|boolean
name|isNormalizerOn
parameter_list|()
block|{
return|return
operator|(
literal|null
operator|==
name|regionNormalizerTracker
operator|||
name|isInMaintenanceMode
argument_list|()
operator|)
condition|?
literal|false
else|:
name|regionNormalizerTracker
operator|.
name|isNormalizerOn
argument_list|()
return|;
block|}
comment|/**    * Queries the state of the {@link SplitOrMergeTracker}. If it is not initialized,    * false is returned. If switchType is illegal, false will return.    * @param switchType see {@link org.apache.hadoop.hbase.client.MasterSwitchType}    * @return The state of the switch    */
specifier|public
name|boolean
name|isSplitOrMergeEnabled
parameter_list|(
name|MasterSwitchType
name|switchType
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|splitOrMergeTracker
operator|||
name|isInMaintenanceMode
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|splitOrMergeTracker
operator|.
name|isSplitOrMergeEnabled
argument_list|(
name|switchType
argument_list|)
return|;
block|}
comment|/**    * Fetch the configured {@link LoadBalancer} class name. If none is set, a default is returned.    *    * @return The name of the {@link LoadBalancer} in use.    */
specifier|public
name|String
name|getLoadBalancerClassName
parameter_list|()
block|{
return|return
name|conf
operator|.
name|get
argument_list|(
name|HConstants
operator|.
name|HBASE_MASTER_LOADBALANCER_CLASS
argument_list|,
name|LoadBalancerFactory
operator|.
name|getDefaultLoadBalancerClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @return RegionNormalizerTracker instance    */
specifier|public
name|RegionNormalizerTracker
name|getRegionNormalizerTracker
parameter_list|()
block|{
return|return
name|regionNormalizerTracker
return|;
block|}
specifier|public
name|SplitOrMergeTracker
name|getSplitOrMergeTracker
parameter_list|()
block|{
return|return
name|splitOrMergeTracker
return|;
block|}
annotation|@
name|Override
specifier|public
name|LoadBalancer
name|getLoadBalancer
parameter_list|()
block|{
return|return
name|balancer
return|;
block|}
block|}
end_class

end_unit

